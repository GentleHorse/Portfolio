{
  "version": 3,
  "sources": ["../../@darkroom.engineering/tempus/src/index.js", "../../src/index.tsx", "../../src/store.ts"],
  "sourcesContent": ["class Tempus {\r\n  constructor() {\r\n    this.callbacks = []\r\n    this.now = performance.now()\r\n    requestAnimationFrame(this.raf)\r\n  }\r\n\r\n  add(callback, priority = 0) {\r\n    this.callbacks.push({ callback, priority })\r\n    this.callbacks.sort((a, b) => a.priority - b.priority)\r\n\r\n    return () => this.remove(callback)\r\n  }\r\n\r\n  remove(callback) {\r\n    this.callbacks = this.callbacks.filter(({ callback: cb }) => callback !== cb)\r\n  }\r\n\r\n  raf = (now) => {\r\n    requestAnimationFrame(this.raf)\r\n\r\n    const deltaTime = now - this.now\r\n    this.now = now\r\n\r\n    for (let i = 0; i < this.callbacks.length; i++) {\r\n      this.callbacks[i].callback(now, deltaTime)\r\n    }\r\n  }\r\n}\r\n\r\nconst isClient = typeof window !== 'undefined'\r\n\r\nexport default isClient && new Tempus()\r\n", "'use client'\r\n\r\nimport Tempus from '@darkroom.engineering/tempus'\r\nimport Lenis, { type ScrollCallback } from 'lenis'\r\nimport {\r\n  createContext,\r\n  forwardRef,\r\n  useCallback,\r\n  useContext,\r\n  useEffect,\r\n  useImperativeHandle,\r\n  useRef,\r\n  useState,\r\n} from 'react'\r\nimport { Store, useStore } from './store'\r\nimport type { LenisContextValue, LenisProps, LenisRef } from './types'\r\n\r\nexport const LenisContext = createContext<LenisContextValue | null>(null)\r\n\r\nconst rootLenisContextStore = new Store<LenisContextValue | null>(null)\r\n\r\n// Fall back to an empty object if both context and store are not available\r\nconst fallbackContext: Partial<LenisContextValue> = {}\r\n\r\n/**\r\n * Hook to access the Lenis instance and its methods\r\n *\r\n * @example <caption>Scroll callback</caption>\r\n *          useLenis((lenis) => {\r\n *            if (lenis.isScrolling) {\r\n *              console.log('Scrolling...')\r\n *            }\r\n *\r\n *            if (lenis.progress === 1) {\r\n *              console.log('At the end!')\r\n *            }\r\n *          })\r\n *\r\n * @example <caption>Scroll callback with dependencies</caption>\r\n *          useLenis((lenis) => {\r\n *            if (lenis.isScrolling) {\r\n *              console.log('Scrolling...', someDependency)\r\n *            }\r\n *          }, [someDependency])\r\n * @example <caption>Scroll callback with priority</caption>\r\n *          useLenis((lenis) => {\r\n *            if (lenis.isScrolling) {\r\n *              console.log('Scrolling...')\r\n *            }\r\n *          }, [], 1)\r\n * @example <caption>Instance access</caption>\r\n *          const lenis = useLenis()\r\n *\r\n *          handleClick() {\r\n *            lenis.scrollTo(100, {\r\n *              lerp: 0.1,\r\n *              duration: 1,\r\n *              easing: (t) => t,\r\n *              onComplete: () => {\r\n *                console.log('Complete!')\r\n *              }\r\n *            })\r\n *          }\r\n */\r\nexport function useLenis(\r\n  callback?: ScrollCallback,\r\n  deps: any[] = [],\r\n  priority = 0\r\n) {\r\n  // Try to get the lenis instance from the context first\r\n  const localContext = useContext(LenisContext)\r\n  // Fall back to the root store if the context is not available\r\n  const rootContext = useStore(rootLenisContextStore)\r\n  // Fall back to the fallback context if all else fails\r\n  const currentContext = localContext ?? rootContext ?? fallbackContext\r\n\r\n  const { lenis, addCallback, removeCallback } = currentContext\r\n\r\n  useEffect(() => {\r\n    if (!callback || !addCallback || !removeCallback || !lenis) return\r\n\r\n    addCallback(callback, priority)\r\n    callback(lenis)\r\n\r\n    return () => {\r\n      removeCallback(callback)\r\n    }\r\n  }, [lenis, addCallback, removeCallback, priority, ...deps])\r\n\r\n  return lenis\r\n}\r\n\r\n/**\r\n * React component to setup a Lenis instance\r\n */\r\nconst ReactLenis = forwardRef<LenisRef, LenisProps>(\r\n  (\r\n    {\r\n      children,\r\n      root = false,\r\n      options = {},\r\n      autoRaf = true,\r\n      rafPriority = 0,\r\n      className,\r\n      props,\r\n    }: LenisProps,\r\n    ref\r\n  ) => {\r\n    const wrapperRef = useRef<HTMLDivElement | null>(null)\r\n    const contentRef = useRef<HTMLDivElement | null>(null)\r\n\r\n    const [lenis, setLenis] = useState<Lenis | undefined>(undefined)\r\n\r\n    // Setup ref\r\n    useImperativeHandle(\r\n      ref,\r\n      () => ({\r\n        wrapper: wrapperRef.current,\r\n        content: contentRef.current,\r\n        lenis,\r\n      }),\r\n      [lenis]\r\n    )\r\n\r\n    // Setup lenis instance\r\n    useEffect(() => {\r\n      const lenis = new Lenis({\r\n        ...options,\r\n        ...(!root && {\r\n          wrapper: wrapperRef.current!,\r\n          content: contentRef.current!,\r\n        }),\r\n      })\r\n\r\n      setLenis(lenis)\r\n\r\n      return () => {\r\n        lenis.destroy()\r\n        setLenis(undefined)\r\n      }\r\n    }, [root, JSON.stringify(options)])\r\n\r\n    // Setup raf\r\n    useEffect(() => {\r\n      if (!lenis || !autoRaf) return\r\n\r\n      return Tempus.add((time: number) => lenis.raf(time), rafPriority)\r\n    }, [lenis, autoRaf, rafPriority])\r\n\r\n    // Handle callbacks\r\n    const callbacksRefs = useRef<\r\n      {\r\n        callback: ScrollCallback\r\n        priority: number\r\n      }[]\r\n    >([])\r\n\r\n    const addCallback: LenisContextValue['addCallback'] = useCallback(\r\n      (callback, priority) => {\r\n        callbacksRefs.current.push({ callback, priority })\r\n        callbacksRefs.current.sort((a, b) => a.priority - b.priority)\r\n      },\r\n      []\r\n    )\r\n\r\n    const removeCallback: LenisContextValue['removeCallback'] = useCallback(\r\n      (callback) => {\r\n        callbacksRefs.current = callbacksRefs.current.filter(\r\n          (cb) => cb.callback !== callback\r\n        )\r\n      },\r\n      []\r\n    )\r\n\r\n    // This makes sure to set the global context if the root is true\r\n    useEffect(() => {\r\n      if (root && lenis) {\r\n        rootLenisContextStore.set({ lenis, addCallback, removeCallback })\r\n\r\n        return () => rootLenisContextStore.set(null)\r\n      }\r\n    }, [root, lenis, addCallback, removeCallback])\r\n\r\n    // Setup callback listeners\r\n    useEffect(() => {\r\n      if (!lenis) return\r\n\r\n      const onScroll: ScrollCallback = (data) => {\r\n        for (let i = 0; i < callbacksRefs.current.length; i++) {\r\n          callbacksRefs.current[i].callback(data)\r\n        }\r\n      }\r\n\r\n      lenis.on('scroll', onScroll)\r\n\r\n      return () => {\r\n        lenis.off('scroll', onScroll)\r\n      }\r\n    }, [lenis])\r\n\r\n    return (\r\n      <LenisContext.Provider\r\n        value={{ lenis: lenis!, addCallback, removeCallback }}\r\n      >\r\n        {root ? (\r\n          children\r\n        ) : (\r\n          <div ref={wrapperRef} className={className} {...props}>\r\n            <div ref={contentRef}>{children}</div>\r\n          </div>\r\n        )}\r\n      </LenisContext.Provider>\r\n    )\r\n  }\r\n)\r\n\r\nexport * from './types'\r\nexport { ReactLenis as Lenis, ReactLenis }\r\nexport default ReactLenis\r\n", "import { useEffect, useState } from 'react'\r\n\r\ntype Listener<S> = (state: S) => void\r\n\r\nexport class Store<S> {\r\n  private listeners: Listener<S>[] = []\r\n\r\n  constructor(private state: S) {}\r\n\r\n  set(state: S) {\r\n    this.state = state\r\n\r\n    for (let listener of this.listeners) {\r\n      listener(this.state)\r\n    }\r\n  }\r\n\r\n  subscribe(listener: Listener<S>) {\r\n    this.listeners = [...this.listeners, listener]\r\n    return () => {\r\n      this.listeners = this.listeners.filter((l) => l !== listener)\r\n    }\r\n  }\r\n\r\n  get() {\r\n    return this.state\r\n  }\r\n}\r\n\r\nexport function useStore<S>(store: Store<S>) {\r\n  const [state, setState] = useState(store.get())\r\n\r\n  useEffect(() => {\r\n    return store.subscribe((state) => setState(state))\r\n  }, [store])\r\n\r\n  return state\r\n}\r\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AAgCA,IAAA,IAFmC,eAAA,OAAXA,UAEG,IAhC3B,MAAA;EACEC,cAAAA;AAAAA,SAiBAC,MAAOC,CAAAA,OAAAA;AACLC,4BAAsBC,KAAKH,GAAAA;AAE3B,YAAMI,IAAYH,KAAME,KAAKF;AAC7BE,WAAKF,MAAMA;AAEX,eAASI,KAAI,GAAGA,KAAIF,KAAKG,UAAUC,QAAQF;AACzCF,aAAKG,UAAUD,EAAAA,EAAGG,SAASP,IAAKG,CAAAA;IAClC,GAxBAD,KAAKG,YAAY,CAAA,GACjBH,KAAKF,MAAMQ,YAAYR,IAAAA,GACvBC,sBAAsBC,KAAKH,GAAAA;EAC7B;EAEAU,IAAIF,IAAUG,IAAW,GAAA;AAIvB,WAHAR,KAAKG,UAAUM,KAAK,EAAEJ,UAAAA,IAAUG,UAAAA,EAAAA,CAAAA,GAChCR,KAAKG,UAAUO,KAAK,CAACC,IAAGC,OAAMD,GAAEH,WAAWI,GAAEJ,QAAAA,GAEtC,MAAMR,KAAKa,OAAOR,EAAAA;EAC3B;EAEAQ,OAAOR,IAAAA;AACLL,SAAKG,YAAYH,KAAKG,UAAUW,OAAO,CAAA,EAAGT,UAAUU,EAAAA,MAASV,OAAaU,CAAAA;EAC5E;AAAA;;;;ICCWC,QAAeC,aAAAA,eAAwC,IAAA;IAE9DC,IAAwB,IAAA,MCfjBC,MAAAA;EAGX,YAAoBC,IAAAA;AAAAC,SAAKD,QAALA,IAFZC,KAASC,YAAkB,CAAA;EAEH;EAEhC,IAAIF,IAAAA;AACFC,SAAKD,QAAQA;AAEb,aAASG,MAAYF,KAAKC;AACxBC,MAAAA,GAASF,KAAKD,KAAAA;EAEjB;EAED,UAAUG,IAAAA;AAER,WADAF,KAAKC,YAAY,CAAA,GAAID,KAAKC,WAAWC,EAAAA,GAC9B,MAAA;AACLF,WAAKC,YAAYD,KAAKC,UAAUE,OAAQC,OAAMA,MAAMF,EAAAA;IAAS;EAEhE;EAED,MAAAG;AACE,WAAOL,KAAKD;EACb;AAAA,EDP+D,IAAA;IAG5DO,IAA8C,CAAA;AA0C9C,SAAUC,SACdC,IACAC,IAAc,CAAA,GACdC,IAAW,GAAA;AAAA,MAAAC;AAGX,QAAMC,SAAeC,aAAAA,YAAWlB,CAAAA,GAE1BmB,KC3CF,SAAUC,SAAYC,IAAAA;AAC1B,UAAA,CAAOjB,IAAOkB,EAAAA,QAAYC,aAAAA,UAASF,GAAMX,IAAAA,CAAAA;AAMzC,eAJAc,aAAAA,WAAU,MACDH,GAAMI,UAAWrB,CAAAA,OAAUkB,GAASlB,EAAAA,CAAAA,GAC1C,CAACiB,EAAAA,CAAAA,GAEGjB;EACT,EDmC+BF,CAAAA,GAEvBwB,KAAgD,UAA/BC,KAAAV,QAAAA,KAAAA,KAAgBE,OAAAA,WAAeQ,KAAAA,KAAAhB,GAAAA,EAEhDiB,OAAEA,IAAKC,aAAEA,IAAWC,gBAAEA,EAAAA,IAAmBJ;AAa/C,aAXAF,aAAAA,WAAU,MAAA;AACR,QAAKX,MAAagB,MAAgBC,KAAmBF;AAKrD,aAHAC,GAAYhB,IAAUE,CAAAA,GACtBF,GAASe,EAAAA,GAEF,MAAA;AACLE,UAAejB,EAAAA;MAAS;EACzB,GACA,CAACe,IAAOC,IAAaC,GAAgBf,GAAAA,GAAaD,CAAAA,CAAAA,GAE9Cc;AACT;AAKA,IAAMG,QAAaC,aAAAA,YACjB,CAAA,EAEIC,UAAAA,IACAC,MAAAA,KAAAA,OACAC,SAAAA,KAAU,CAAA,GACVC,SAAAA,KAAAA,MACAC,aAAAA,KAAc,GACdC,WAAAA,GACAC,OAAAA,EAAAA,GAEFC,MAAAA;AAEA,QAAMC,QAAaC,aAAAA,QAA8B,IAAA,GAC3CC,QAAaD,aAAAA,QAA8B,IAAA,GAAA,CAE1Cd,GAAOgB,CAAAA,QAAYrB,aAAAA,UAAAA,MAA4BsB;AAGtDC,mBAAAA,qBACEN,GACA,OAAO,EACLO,SAASN,EAAWO,SACpBC,SAASN,EAAWK,SACpBpB,OAAAA,EAAAA,IAEF,CAACA,CAAAA,CAAAA,OAIHJ,aAAAA,WAAU,MAAA;AACR,UAAMI,KAAQ,IAAIsB,MAAKC,OAAAC,OAAAD,OAAAC,OAAA,CAAA,GAClBjB,EAAAA,GAAAA,CACED,MAAQ,EACXa,SAASN,EAAWO,SACpBC,SAASN,EAAWK,QAAAA,CAAAA,CAAAA;AAMxB,WAFAJ,EAAShB,EAAAA,GAEF,MAAA;AACLA,MAAAA,GAAMyB,QAAAA,GACNT,EAAAA,MAASC;IAAU;EACpB,GACA,CAACX,IAAMoB,KAAKC,UAAUpB,EAAAA,CAAAA,CAAAA,OAGzBX,aAAAA,WAAU,MAAA;AACR,QAAKI,KAAUQ;AAEf,aAAOoB,EAAOC,IAAKC,CAAAA,OAAiB9B,EAAM+B,IAAID,EAAAA,GAAOrB,EAAAA;EAAY,GAChE,CAACT,GAAOQ,IAASC,EAAAA,CAAAA;AAGpB,QAAMuB,QAAgBlB,aAAAA,QAKpB,CAAA,CAAA,GAEIb,QAAgDgC,aAAAA,aACpD,CAAChD,IAAUE,MAAAA;AACT6C,MAAcZ,QAAQc,KAAK,EAAEjD,UAAAA,IAAUE,UAAAA,EAAAA,CAAAA,GACvC6C,EAAcZ,QAAQe,KAAK,CAACC,IAAGC,OAAMD,GAAEjD,WAAWkD,GAAElD,QAAAA;EAAS,GAE/D,CAAA,CAAA,GAGIe,QAAsD+B,aAAAA,aACzDhD,CAAAA,OAAAA;AACC+C,MAAcZ,UAAUY,EAAcZ,QAAQxC,OAC3C0D,OAAOA,EAAGrD,aAAaA,EAAAA;EACzB,GAEH,CAAA,CAAA;AA6BF,aAzBAW,aAAAA,WAAU,MAAA;AACR,QAAIU,MAAQN;AAGV,aAFA1B,EAAsBiE,IAAI,EAAEvC,OAAAA,GAAOC,aAAAA,GAAaC,gBAAAA,EAAAA,CAAAA,GAEzC,MAAM5B,EAAsBiE,IAAI,IAAA;EACxC,GACA,CAACjC,IAAMN,GAAOC,GAAaC,CAAAA,CAAAA,OAG9BN,aAAAA,WAAU,MAAA;AACR,QAAA,CAAKI;AAAO;AAEZ,UAAMwC,WAA4BC,CAAAA,OAAAA;AAChC,eAASrD,IAAI,GAAGA,IAAI4C,EAAcZ,QAAQsB,QAAQtD;AAChD4C,UAAcZ,QAAQhC,CAAAA,EAAGH,SAASwD,EAAAA;IACnC;AAKH,WAFAzC,EAAM2C,GAAG,UAAUH,QAAAA,GAEZ,MAAA;AACLxC,QAAM4C,IAAI,UAAUJ,QAAAA;IAAS;EAC9B,GACA,CAACxC,CAAAA,CAAAA,OAGF6C,mBAAAA,KAACzE,EAAa0E,UACZ,EAAAC,OAAO,EAAE/C,OAAOA,GAAQC,aAAAA,GAAaC,gBAAAA,EAAAA,GAAgBG,UAEpDC,KACClB,SAEAyD,mBAAAA,KAAA,OAAAtB,OAAAC,OAAA,EAAKZ,KAAKC,GAAYH,WAAWA,EAAAA,GAAeC,GAAAA,EAAAA,cAC9CkC,mBAAAA,KAAK,OAAA,EAAAjC,KAAKG,GAAaV,UAAAA,GAAAA,CAAAA,EAAAA,CAAAA,CAAAA,EAAAA,CAAAA;AAI9B,CAAA;",
  "names": ["window", "constructor", "raf", "now", "requestAnimationFrame", "this", "deltaTime", "i", "callbacks", "length", "callback", "performance", "add", "priority", "push", "sort", "a", "b", "remove", "filter", "cb", "LenisContext", "createContext", "rootLenisContextStore", "Store", "state", "this", "listeners", "listener", "filter", "l", "get", "fallbackContext", "useLenis", "callback", "deps", "priority", "i", "localContext", "useContext", "rootContext", "useStore", "store", "setState", "useState", "useEffect", "subscribe", "currentContext", "_a", "lenis", "addCallback", "removeCallback", "ReactLenis", "forwardRef", "children", "root", "options", "autoRaf", "rafPriority", "className", "props", "ref", "wrapperRef", "useRef", "contentRef", "setLenis", "undefined", "useImperativeHandle", "wrapper", "current", "content", "Lenis", "Object", "assign", "destroy", "JSON", "stringify", "Tempus", "add", "time", "raf", "callbacksRefs", "useCallback", "push", "sort", "a", "b", "cb", "set", "onScroll", "data", "length", "on", "off", "_jsx", "Provider", "value"]
}
