import {
  clamp
} from "./chunk-5R7AGACV.js";
import {
  create
} from "./chunk-5LN4NR6U.js";
import {
  require_jsx_runtime
} from "./chunk-XE53ZM2I.js";
import {
  context,
  createPortal,
  reconciler,
  useFrame,
  useLoader,
  useStore,
  useThree
} from "./chunk-ALODSIP4.js";
import {
  Box2,
  Box3,
  BufferAttribute,
  BufferGeometry,
  Color,
  DynamicDrawUsage,
  Euler,
  FileLoader,
  Float32BufferAttribute,
  FrontSide,
  Group,
  HalfFloatType,
  InstancedBufferAttribute,
  LinearFilter,
  Loader,
  Material,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshDistanceMaterial,
  MeshPhongMaterial,
  MeshPhysicalMaterial,
  Object3D,
  OrthographicCamera,
  Path,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  Quaternion,
  RGBADepthPacking,
  Raycaster,
  SRGBColorSpace,
  Scene,
  Shape,
  ShapeGeometry,
  ShapePath,
  ShapeUtils,
  Sphere,
  Texture,
  TextureLoader,
  Vector2,
  Vector3,
  VideoTexture,
  WebGLRenderTarget
} from "./chunk-SRMN6EMH.js";
import "./chunk-KBUAZBQ3.js";
import {
  require_react
} from "./chunk-ZLZLTJQL.js";
import {
  __commonJS,
  __esm,
  __export,
  __publicField,
  __toCommonJS,
  __toESM
} from "./chunk-2LSFTFF7.js";

// node_modules/he/he.js
var require_he = __commonJS({
  "node_modules/he/he.js"(exports, module) {
    (function(root) {
      var freeExports = typeof exports == "object" && exports;
      var freeModule = typeof module == "object" && module && module.exports == freeExports && module;
      var freeGlobal = typeof global == "object" && global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
        root = freeGlobal;
      }
      var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      var regexAsciiWhitelist = /[\x01-\x7F]/g;
      var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
      var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
      var encodeMap = { "Â­": "shy", "â€Œ": "zwnj", "â€": "zwj", "â€": "lrm", "â£": "ic", "â¢": "it", "â¡": "af", "â€": "rlm", "â€‹": "ZeroWidthSpace", "â ": "NoBreak", "Ì‘": "DownBreve", "âƒ›": "tdot", "âƒœ": "DotDot", "	": "Tab", "\n": "NewLine", "â€ˆ": "puncsp", "âŸ": "MediumSpace", "â€‰": "thinsp", "â€Š": "hairsp", "â€„": "emsp13", "â€‚": "ensp", "â€…": "emsp14", "â€ƒ": "emsp", "â€‡": "numsp", "Â ": "nbsp", "âŸâ€Š": "ThickSpace", "â€¾": "oline", "_": "lowbar", "â€": "dash", "â€“": "ndash", "â€”": "mdash", "â€•": "horbar", ",": "comma", ";": "semi", "â": "bsemi", ":": "colon", "â©´": "Colone", "!": "excl", "Â¡": "iexcl", "?": "quest", "Â¿": "iquest", ".": "period", "â€¥": "nldr", "â€¦": "mldr", "Â·": "middot", "'": "apos", "â€˜": "lsquo", "â€™": "rsquo", "â€š": "sbquo", "â€¹": "lsaquo", "â€º": "rsaquo", '"': "quot", "â€œ": "ldquo", "â€": "rdquo", "â€": "bdquo", "Â«": "laquo", "Â»": "raquo", "(": "lpar", ")": "rpar", "[": "lsqb", "]": "rsqb", "{": "lcub", "}": "rcub", "âŒˆ": "lceil", "âŒ‰": "rceil", "âŒŠ": "lfloor", "âŒ‹": "rfloor", "â¦…": "lopar", "â¦†": "ropar", "â¦‹": "lbrke", "â¦Œ": "rbrke", "â¦": "lbrkslu", "â¦": "rbrksld", "â¦": "lbrksld", "â¦": "rbrkslu", "â¦‘": "langd", "â¦’": "rangd", "â¦“": "lparlt", "â¦”": "rpargt", "â¦•": "gtlPar", "â¦–": "ltrPar", "âŸ¦": "lobrk", "âŸ§": "robrk", "âŸ¨": "lang", "âŸ©": "rang", "âŸª": "Lang", "âŸ«": "Rang", "âŸ¬": "loang", "âŸ­": "roang", "â²": "lbbrk", "â³": "rbbrk", "â€–": "Vert", "Â§": "sect", "Â¶": "para", "@": "commat", "*": "ast", "/": "sol", "undefined": null, "&": "amp", "#": "num", "%": "percnt", "â€°": "permil", "â€±": "pertenk", "â€ ": "dagger", "â€¡": "Dagger", "â€¢": "bull", "âƒ": "hybull", "â€²": "prime", "â€³": "Prime", "â€´": "tprime", "â—": "qprime", "â€µ": "bprime", "â": "caret", "`": "grave", "Â´": "acute", "Ëœ": "tilde", "^": "Hat", "Â¯": "macr", "Ë˜": "breve", "Ë™": "dot", "Â¨": "die", "Ëš": "ring", "Ë": "dblac", "Â¸": "cedil", "Ë›": "ogon", "Ë†": "circ", "Ë‡": "caron", "Â°": "deg", "Â©": "copy", "Â®": "reg", "â„—": "copysr", "â„˜": "wp", "â„": "rx", "â„§": "mho", "â„©": "iiota", "â†": "larr", "â†š": "nlarr", "â†’": "rarr", "â†›": "nrarr", "â†‘": "uarr", "â†“": "darr", "â†”": "harr", "â†®": "nharr", "â†•": "varr", "â†–": "nwarr", "â†—": "nearr", "â†˜": "searr", "â†™": "swarr", "â†": "rarrw", "â†Ì¸": "nrarrw", "â†": "Larr", "â†Ÿ": "Uarr", "â† ": "Rarr", "â†¡": "Darr", "â†¢": "larrtl", "â†£": "rarrtl", "â†¤": "mapstoleft", "â†¥": "mapstoup", "â†¦": "map", "â†§": "mapstodown", "â†©": "larrhk", "â†ª": "rarrhk", "â†«": "larrlp", "â†¬": "rarrlp", "â†­": "harrw", "â†°": "lsh", "â†±": "rsh", "â†²": "ldsh", "â†³": "rdsh", "â†µ": "crarr", "â†¶": "cularr", "â†·": "curarr", "â†º": "olarr", "â†»": "orarr", "â†¼": "lharu", "â†½": "lhard", "â†¾": "uharr", "â†¿": "uharl", "â‡€": "rharu", "â‡": "rhard", "â‡‚": "dharr", "â‡ƒ": "dharl", "â‡„": "rlarr", "â‡…": "udarr", "â‡†": "lrarr", "â‡‡": "llarr", "â‡ˆ": "uuarr", "â‡‰": "rrarr", "â‡Š": "ddarr", "â‡‹": "lrhar", "â‡Œ": "rlhar", "â‡": "lArr", "â‡": "nlArr", "â‡‘": "uArr", "â‡’": "rArr", "â‡": "nrArr", "â‡“": "dArr", "â‡”": "iff", "â‡": "nhArr", "â‡•": "vArr", "â‡–": "nwArr", "â‡—": "neArr", "â‡˜": "seArr", "â‡™": "swArr", "â‡š": "lAarr", "â‡›": "rAarr", "â‡": "zigrarr", "â‡¤": "larrb", "â‡¥": "rarrb", "â‡µ": "duarr", "â‡½": "loarr", "â‡¾": "roarr", "â‡¿": "hoarr", "âˆ€": "forall", "âˆ": "comp", "âˆ‚": "part", "âˆ‚Ì¸": "npart", "âˆƒ": "exist", "âˆ„": "nexist", "âˆ…": "empty", "âˆ‡": "Del", "âˆˆ": "in", "âˆ‰": "notin", "âˆ‹": "ni", "âˆŒ": "notni", "Ï¶": "bepsi", "âˆ": "prod", "âˆ": "coprod", "âˆ‘": "sum", "+": "plus", "Â±": "pm", "Ã·": "div", "Ã—": "times", "<": "lt", "â‰®": "nlt", "<âƒ’": "nvlt", "=": "equals", "â‰ ": "ne", "=âƒ¥": "bne", "â©µ": "Equal", ">": "gt", "â‰¯": "ngt", ">âƒ’": "nvgt", "Â¬": "not", "|": "vert", "Â¦": "brvbar", "âˆ’": "minus", "âˆ“": "mp", "âˆ”": "plusdo", "â„": "frasl", "âˆ–": "setmn", "âˆ—": "lowast", "âˆ˜": "compfn", "âˆš": "Sqrt", "âˆ": "prop", "âˆ": "infin", "âˆŸ": "angrt", "âˆ ": "ang", "âˆ âƒ’": "nang", "âˆ¡": "angmsd", "âˆ¢": "angsph", "âˆ£": "mid", "âˆ¤": "nmid", "âˆ¥": "par", "âˆ¦": "npar", "âˆ§": "and", "âˆ¨": "or", "âˆ©": "cap", "âˆ©ï¸€": "caps", "âˆª": "cup", "âˆªï¸€": "cups", "âˆ«": "int", "âˆ¬": "Int", "âˆ­": "tint", "â¨Œ": "qint", "âˆ®": "oint", "âˆ¯": "Conint", "âˆ°": "Cconint", "âˆ±": "cwint", "âˆ²": "cwconint", "âˆ³": "awconint", "âˆ´": "there4", "âˆµ": "becaus", "âˆ¶": "ratio", "âˆ·": "Colon", "âˆ¸": "minusd", "âˆº": "mDDot", "âˆ»": "homtht", "âˆ¼": "sim", "â‰": "nsim", "âˆ¼âƒ’": "nvsim", "âˆ½": "bsim", "âˆ½Ì±": "race", "âˆ¾": "ac", "âˆ¾Ì³": "acE", "âˆ¿": "acd", "â‰€": "wr", "â‰‚": "esim", "â‰‚Ì¸": "nesim", "â‰ƒ": "sime", "â‰„": "nsime", "â‰…": "cong", "â‰‡": "ncong", "â‰†": "simne", "â‰ˆ": "ap", "â‰‰": "nap", "â‰Š": "ape", "â‰‹": "apid", "â‰‹Ì¸": "napid", "â‰Œ": "bcong", "â‰": "CupCap", "â‰­": "NotCupCap", "â‰âƒ’": "nvap", "â‰": "bump", "â‰Ì¸": "nbump", "â‰": "bumpe", "â‰Ì¸": "nbumpe", "â‰": "doteq", "â‰Ì¸": "nedot", "â‰‘": "eDot", "â‰’": "efDot", "â‰“": "erDot", "â‰”": "colone", "â‰•": "ecolon", "â‰–": "ecir", "â‰—": "cire", "â‰™": "wedgeq", "â‰š": "veeeq", "â‰œ": "trie", "â‰Ÿ": "equest", "â‰¡": "equiv", "â‰¢": "nequiv", "â‰¡âƒ¥": "bnequiv", "â‰¤": "le", "â‰°": "nle", "â‰¤âƒ’": "nvle", "â‰¥": "ge", "â‰±": "nge", "â‰¥âƒ’": "nvge", "â‰¦": "lE", "â‰¦Ì¸": "nlE", "â‰§": "gE", "â‰§Ì¸": "ngE", "â‰¨ï¸€": "lvnE", "â‰¨": "lnE", "â‰©": "gnE", "â‰©ï¸€": "gvnE", "â‰ª": "ll", "â‰ªÌ¸": "nLtv", "â‰ªâƒ’": "nLt", "â‰«": "gg", "â‰«Ì¸": "nGtv", "â‰«âƒ’": "nGt", "â‰¬": "twixt", "â‰²": "lsim", "â‰´": "nlsim", "â‰³": "gsim", "â‰µ": "ngsim", "â‰¶": "lg", "â‰¸": "ntlg", "â‰·": "gl", "â‰¹": "ntgl", "â‰º": "pr", "âŠ€": "npr", "â‰»": "sc", "âŠ": "nsc", "â‰¼": "prcue", "â‹ ": "nprcue", "â‰½": "sccue", "â‹¡": "nsccue", "â‰¾": "prsim", "â‰¿": "scsim", "â‰¿Ì¸": "NotSucceedsTilde", "âŠ‚": "sub", "âŠ„": "nsub", "âŠ‚âƒ’": "vnsub", "âŠƒ": "sup", "âŠ…": "nsup", "âŠƒâƒ’": "vnsup", "âŠ†": "sube", "âŠˆ": "nsube", "âŠ‡": "supe", "âŠ‰": "nsupe", "âŠŠï¸€": "vsubne", "âŠŠ": "subne", "âŠ‹ï¸€": "vsupne", "âŠ‹": "supne", "âŠ": "cupdot", "âŠ": "uplus", "âŠ": "sqsub", "âŠÌ¸": "NotSquareSubset", "âŠ": "sqsup", "âŠÌ¸": "NotSquareSuperset", "âŠ‘": "sqsube", "â‹¢": "nsqsube", "âŠ’": "sqsupe", "â‹£": "nsqsupe", "âŠ“": "sqcap", "âŠ“ï¸€": "sqcaps", "âŠ”": "sqcup", "âŠ”ï¸€": "sqcups", "âŠ•": "oplus", "âŠ–": "ominus", "âŠ—": "otimes", "âŠ˜": "osol", "âŠ™": "odot", "âŠš": "ocir", "âŠ›": "oast", "âŠ": "odash", "âŠ": "plusb", "âŠŸ": "minusb", "âŠ ": "timesb", "âŠ¡": "sdotb", "âŠ¢": "vdash", "âŠ¬": "nvdash", "âŠ£": "dashv", "âŠ¤": "top", "âŠ¥": "bot", "âŠ§": "models", "âŠ¨": "vDash", "âŠ­": "nvDash", "âŠ©": "Vdash", "âŠ®": "nVdash", "âŠª": "Vvdash", "âŠ«": "VDash", "âŠ¯": "nVDash", "âŠ°": "prurel", "âŠ²": "vltri", "â‹ª": "nltri", "âŠ³": "vrtri", "â‹«": "nrtri", "âŠ´": "ltrie", "â‹¬": "nltrie", "âŠ´âƒ’": "nvltrie", "âŠµ": "rtrie", "â‹­": "nrtrie", "âŠµâƒ’": "nvrtrie", "âŠ¶": "origof", "âŠ·": "imof", "âŠ¸": "mumap", "âŠ¹": "hercon", "âŠº": "intcal", "âŠ»": "veebar", "âŠ½": "barvee", "âŠ¾": "angrtvb", "âŠ¿": "lrtri", "â‹€": "Wedge", "â‹": "Vee", "â‹‚": "xcap", "â‹ƒ": "xcup", "â‹„": "diam", "â‹…": "sdot", "â‹†": "Star", "â‹‡": "divonx", "â‹ˆ": "bowtie", "â‹‰": "ltimes", "â‹Š": "rtimes", "â‹‹": "lthree", "â‹Œ": "rthree", "â‹": "bsime", "â‹": "cuvee", "â‹": "cuwed", "â‹": "Sub", "â‹‘": "Sup", "â‹’": "Cap", "â‹“": "Cup", "â‹”": "fork", "â‹•": "epar", "â‹–": "ltdot", "â‹—": "gtdot", "â‹˜": "Ll", "â‹˜Ì¸": "nLl", "â‹™": "Gg", "â‹™Ì¸": "nGg", "â‹šï¸€": "lesg", "â‹š": "leg", "â‹›": "gel", "â‹›ï¸€": "gesl", "â‹": "cuepr", "â‹Ÿ": "cuesc", "â‹¦": "lnsim", "â‹§": "gnsim", "â‹¨": "prnsim", "â‹©": "scnsim", "â‹®": "vellip", "â‹¯": "ctdot", "â‹°": "utdot", "â‹±": "dtdot", "â‹²": "disin", "â‹³": "isinsv", "â‹´": "isins", "â‹µ": "isindot", "â‹µÌ¸": "notindot", "â‹¶": "notinvc", "â‹·": "notinvb", "â‹¹": "isinE", "â‹¹Ì¸": "notinE", "â‹º": "nisd", "â‹»": "xnis", "â‹¼": "nis", "â‹½": "notnivc", "â‹¾": "notnivb", "âŒ…": "barwed", "âŒ†": "Barwed", "âŒŒ": "drcrop", "âŒ": "dlcrop", "âŒ": "urcrop", "âŒ": "ulcrop", "âŒ": "bnot", "âŒ’": "profline", "âŒ“": "profsurf", "âŒ•": "telrec", "âŒ–": "target", "âŒœ": "ulcorn", "âŒ": "urcorn", "âŒ": "dlcorn", "âŒŸ": "drcorn", "âŒ¢": "frown", "âŒ£": "smile", "âŒ­": "cylcty", "âŒ®": "profalar", "âŒ¶": "topbot", "âŒ½": "ovbar", "âŒ¿": "solbar", "â¼": "angzarr", "â°": "lmoust", "â±": "rmoust", "â´": "tbrk", "âµ": "bbrk", "â¶": "bbrktbrk", "âœ": "OverParenthesis", "â": "UnderParenthesis", "â": "OverBrace", "âŸ": "UnderBrace", "â¢": "trpezium", "â§": "elinters", "â£": "blank", "â”€": "boxh", "â”‚": "boxv", "â”Œ": "boxdr", "â”": "boxdl", "â””": "boxur", "â”˜": "boxul", "â”œ": "boxvr", "â”¤": "boxvl", "â”¬": "boxhd", "â”´": "boxhu", "â”¼": "boxvh", "â•": "boxH", "â•‘": "boxV", "â•’": "boxdR", "â•“": "boxDr", "â•”": "boxDR", "â••": "boxdL", "â•–": "boxDl", "â•—": "boxDL", "â•˜": "boxuR", "â•™": "boxUr", "â•š": "boxUR", "â•›": "boxuL", "â•œ": "boxUl", "â•": "boxUL", "â•": "boxvR", "â•Ÿ": "boxVr", "â• ": "boxVR", "â•¡": "boxvL", "â•¢": "boxVl", "â•£": "boxVL", "â•¤": "boxHd", "â•¥": "boxhD", "â•¦": "boxHD", "â•§": "boxHu", "â•¨": "boxhU", "â•©": "boxHU", "â•ª": "boxvH", "â•«": "boxVh", "â•¬": "boxVH", "â–€": "uhblk", "â–„": "lhblk", "â–ˆ": "block", "â–‘": "blk14", "â–’": "blk12", "â–“": "blk34", "â–¡": "squ", "â–ª": "squf", "â–«": "EmptyVerySmallSquare", "â–­": "rect", "â–®": "marker", "â–±": "fltns", "â–³": "xutri", "â–´": "utrif", "â–µ": "utri", "â–¸": "rtrif", "â–¹": "rtri", "â–½": "xdtri", "â–¾": "dtrif", "â–¿": "dtri", "â—‚": "ltrif", "â—ƒ": "ltri", "â—Š": "loz", "â—‹": "cir", "â—¬": "tridot", "â—¯": "xcirc", "â—¸": "ultri", "â—¹": "urtri", "â—º": "lltri", "â—»": "EmptySmallSquare", "â—¼": "FilledSmallSquare", "â˜…": "starf", "â˜†": "star", "â˜": "phone", "â™€": "female", "â™‚": "male", "â™ ": "spades", "â™£": "clubs", "â™¥": "hearts", "â™¦": "diams", "â™ª": "sung", "âœ“": "check", "âœ—": "cross", "âœ ": "malt", "âœ¶": "sext", "â˜": "VerticalSeparator", "âŸˆ": "bsolhsub", "âŸ‰": "suphsol", "âŸµ": "xlarr", "âŸ¶": "xrarr", "âŸ·": "xharr", "âŸ¸": "xlArr", "âŸ¹": "xrArr", "âŸº": "xhArr", "âŸ¼": "xmap", "âŸ¿": "dzigrarr", "â¤‚": "nvlArr", "â¤ƒ": "nvrArr", "â¤„": "nvHarr", "â¤…": "Map", "â¤Œ": "lbarr", "â¤": "rbarr", "â¤": "lBarr", "â¤": "rBarr", "â¤": "RBarr", "â¤‘": "DDotrahd", "â¤’": "UpArrowBar", "â¤“": "DownArrowBar", "â¤–": "Rarrtl", "â¤™": "latail", "â¤š": "ratail", "â¤›": "lAtail", "â¤œ": "rAtail", "â¤": "larrfs", "â¤": "rarrfs", "â¤Ÿ": "larrbfs", "â¤ ": "rarrbfs", "â¤£": "nwarhk", "â¤¤": "nearhk", "â¤¥": "searhk", "â¤¦": "swarhk", "â¤§": "nwnear", "â¤¨": "toea", "â¤©": "tosa", "â¤ª": "swnwar", "â¤³": "rarrc", "â¤³Ì¸": "nrarrc", "â¤µ": "cudarrr", "â¤¶": "ldca", "â¤·": "rdca", "â¤¸": "cudarrl", "â¤¹": "larrpl", "â¤¼": "curarrm", "â¤½": "cularrp", "â¥…": "rarrpl", "â¥ˆ": "harrcir", "â¥‰": "Uarrocir", "â¥Š": "lurdshar", "â¥‹": "ldrushar", "â¥": "LeftRightVector", "â¥": "RightUpDownVector", "â¥": "DownLeftRightVector", "â¥‘": "LeftUpDownVector", "â¥’": "LeftVectorBar", "â¥“": "RightVectorBar", "â¥”": "RightUpVectorBar", "â¥•": "RightDownVectorBar", "â¥–": "DownLeftVectorBar", "â¥—": "DownRightVectorBar", "â¥˜": "LeftUpVectorBar", "â¥™": "LeftDownVectorBar", "â¥š": "LeftTeeVector", "â¥›": "RightTeeVector", "â¥œ": "RightUpTeeVector", "â¥": "RightDownTeeVector", "â¥": "DownLeftTeeVector", "â¥Ÿ": "DownRightTeeVector", "â¥ ": "LeftUpTeeVector", "â¥¡": "LeftDownTeeVector", "â¥¢": "lHar", "â¥£": "uHar", "â¥¤": "rHar", "â¥¥": "dHar", "â¥¦": "luruhar", "â¥§": "ldrdhar", "â¥¨": "ruluhar", "â¥©": "rdldhar", "â¥ª": "lharul", "â¥«": "llhard", "â¥¬": "rharul", "â¥­": "lrhard", "â¥®": "udhar", "â¥¯": "duhar", "â¥°": "RoundImplies", "â¥±": "erarr", "â¥²": "simrarr", "â¥³": "larrsim", "â¥´": "rarrsim", "â¥µ": "rarrap", "â¥¶": "ltlarr", "â¥¸": "gtrarr", "â¥¹": "subrarr", "â¥»": "suplarr", "â¥¼": "lfisht", "â¥½": "rfisht", "â¥¾": "ufisht", "â¥¿": "dfisht", "â¦š": "vzigzag", "â¦œ": "vangrt", "â¦": "angrtvbd", "â¦¤": "ange", "â¦¥": "range", "â¦¦": "dwangle", "â¦§": "uwangle", "â¦¨": "angmsdaa", "â¦©": "angmsdab", "â¦ª": "angmsdac", "â¦«": "angmsdad", "â¦¬": "angmsdae", "â¦­": "angmsdaf", "â¦®": "angmsdag", "â¦¯": "angmsdah", "â¦°": "bemptyv", "â¦±": "demptyv", "â¦²": "cemptyv", "â¦³": "raemptyv", "â¦´": "laemptyv", "â¦µ": "ohbar", "â¦¶": "omid", "â¦·": "opar", "â¦¹": "operp", "â¦»": "olcross", "â¦¼": "odsold", "â¦¾": "olcir", "â¦¿": "ofcir", "â§€": "olt", "â§": "ogt", "â§‚": "cirscir", "â§ƒ": "cirE", "â§„": "solb", "â§…": "bsolb", "â§‰": "boxbox", "â§": "trisb", "â§": "rtriltri", "â§": "LeftTriangleBar", "â§Ì¸": "NotLeftTriangleBar", "â§": "RightTriangleBar", "â§Ì¸": "NotRightTriangleBar", "â§œ": "iinfin", "â§": "infintie", "â§": "nvinfin", "â§£": "eparsl", "â§¤": "smeparsl", "â§¥": "eqvparsl", "â§«": "lozf", "â§´": "RuleDelayed", "â§¶": "dsol", "â¨€": "xodot", "â¨": "xoplus", "â¨‚": "xotime", "â¨„": "xuplus", "â¨†": "xsqcup", "â¨": "fpartint", "â¨": "cirfnint", "â¨‘": "awint", "â¨’": "rppolint", "â¨“": "scpolint", "â¨”": "npolint", "â¨•": "pointint", "â¨–": "quatint", "â¨—": "intlarhk", "â¨¢": "pluscir", "â¨£": "plusacir", "â¨¤": "simplus", "â¨¥": "plusdu", "â¨¦": "plussim", "â¨§": "plustwo", "â¨©": "mcomma", "â¨ª": "minusdu", "â¨­": "loplus", "â¨®": "roplus", "â¨¯": "Cross", "â¨°": "timesd", "â¨±": "timesbar", "â¨³": "smashp", "â¨´": "lotimes", "â¨µ": "rotimes", "â¨¶": "otimesas", "â¨·": "Otimes", "â¨¸": "odiv", "â¨¹": "triplus", "â¨º": "triminus", "â¨»": "tritime", "â¨¼": "iprod", "â¨¿": "amalg", "â©€": "capdot", "â©‚": "ncup", "â©ƒ": "ncap", "â©„": "capand", "â©…": "cupor", "â©†": "cupcap", "â©‡": "capcup", "â©ˆ": "cupbrcap", "â©‰": "capbrcup", "â©Š": "cupcup", "â©‹": "capcap", "â©Œ": "ccups", "â©": "ccaps", "â©": "ccupssm", "â©“": "And", "â©”": "Or", "â©•": "andand", "â©–": "oror", "â©—": "orslope", "â©˜": "andslope", "â©š": "andv", "â©›": "orv", "â©œ": "andd", "â©": "ord", "â©Ÿ": "wedbar", "â©¦": "sdote", "â©ª": "simdot", "â©­": "congdot", "â©­Ì¸": "ncongdot", "â©®": "easter", "â©¯": "apacir", "â©°": "apE", "â©°Ì¸": "napE", "â©±": "eplus", "â©²": "pluse", "â©³": "Esim", "â©·": "eDDot", "â©¸": "equivDD", "â©¹": "ltcir", "â©º": "gtcir", "â©»": "ltquest", "â©¼": "gtquest", "â©½": "les", "â©½Ì¸": "nles", "â©¾": "ges", "â©¾Ì¸": "nges", "â©¿": "lesdot", "âª€": "gesdot", "âª": "lesdoto", "âª‚": "gesdoto", "âªƒ": "lesdotor", "âª„": "gesdotol", "âª…": "lap", "âª†": "gap", "âª‡": "lne", "âªˆ": "gne", "âª‰": "lnap", "âªŠ": "gnap", "âª‹": "lEg", "âªŒ": "gEl", "âª": "lsime", "âª": "gsime", "âª": "lsimg", "âª": "gsiml", "âª‘": "lgE", "âª’": "glE", "âª“": "lesges", "âª”": "gesles", "âª•": "els", "âª–": "egs", "âª—": "elsdot", "âª˜": "egsdot", "âª™": "el", "âªš": "eg", "âª": "siml", "âª": "simg", "âªŸ": "simlE", "âª ": "simgE", "âª¡": "LessLess", "âª¡Ì¸": "NotNestedLessLess", "âª¢": "GreaterGreater", "âª¢Ì¸": "NotNestedGreaterGreater", "âª¤": "glj", "âª¥": "gla", "âª¦": "ltcc", "âª§": "gtcc", "âª¨": "lescc", "âª©": "gescc", "âªª": "smt", "âª«": "lat", "âª¬": "smte", "âª¬ï¸€": "smtes", "âª­": "late", "âª­ï¸€": "lates", "âª®": "bumpE", "âª¯": "pre", "âª¯Ì¸": "npre", "âª°": "sce", "âª°Ì¸": "nsce", "âª³": "prE", "âª´": "scE", "âªµ": "prnE", "âª¶": "scnE", "âª·": "prap", "âª¸": "scap", "âª¹": "prnap", "âªº": "scnap", "âª»": "Pr", "âª¼": "Sc", "âª½": "subdot", "âª¾": "supdot", "âª¿": "subplus", "â«€": "supplus", "â«": "submult", "â«‚": "supmult", "â«ƒ": "subedot", "â«„": "supedot", "â«…": "subE", "â«…Ì¸": "nsubE", "â«†": "supE", "â«†Ì¸": "nsupE", "â«‡": "subsim", "â«ˆ": "supsim", "â«‹ï¸€": "vsubnE", "â«‹": "subnE", "â«Œï¸€": "vsupnE", "â«Œ": "supnE", "â«": "csub", "â«": "csup", "â«‘": "csube", "â«’": "csupe", "â«“": "subsup", "â«”": "supsub", "â«•": "subsub", "â«–": "supsup", "â«—": "suphsub", "â«˜": "supdsub", "â«™": "forkv", "â«š": "topfork", "â«›": "mlcp", "â«¤": "Dashv", "â«¦": "Vdashl", "â«§": "Barv", "â«¨": "vBar", "â«©": "vBarv", "â««": "Vbar", "â«¬": "Not", "â«­": "bNot", "â«®": "rnmid", "â«¯": "cirmid", "â«°": "midcir", "â«±": "topcir", "â«²": "nhpar", "â«³": "parsim", "â«½": "parsl", "â«½âƒ¥": "nparsl", "â™­": "flat", "â™®": "natur", "â™¯": "sharp", "Â¤": "curren", "Â¢": "cent", "$": "dollar", "Â£": "pound", "Â¥": "yen", "â‚¬": "euro", "Â¹": "sup1", "Â½": "half", "â…“": "frac13", "Â¼": "frac14", "â…•": "frac15", "â…™": "frac16", "â…›": "frac18", "Â²": "sup2", "â…”": "frac23", "â…–": "frac25", "Â³": "sup3", "Â¾": "frac34", "â…—": "frac35", "â…œ": "frac38", "â…˜": "frac45", "â…š": "frac56", "â…": "frac58", "â…": "frac78", "ğ’¶": "ascr", "ğ•’": "aopf", "ğ”": "afr", "ğ”¸": "Aopf", "ğ”„": "Afr", "ğ’œ": "Ascr", "Âª": "ordf", "Ã¡": "aacute", "Ã": "Aacute", "Ã ": "agrave", "Ã€": "Agrave", "Äƒ": "abreve", "Ä‚": "Abreve", "Ã¢": "acirc", "Ã‚": "Acirc", "Ã¥": "aring", "Ã…": "angst", "Ã¤": "auml", "Ã„": "Auml", "Ã£": "atilde", "Ãƒ": "Atilde", "Ä…": "aogon", "Ä„": "Aogon", "Ä": "amacr", "Ä€": "Amacr", "Ã¦": "aelig", "Ã†": "AElig", "ğ’·": "bscr", "ğ•“": "bopf", "ğ”Ÿ": "bfr", "ğ”¹": "Bopf", "â„¬": "Bscr", "ğ”…": "Bfr", "ğ” ": "cfr", "ğ’¸": "cscr", "ğ•”": "copf", "â„­": "Cfr", "ğ’": "Cscr", "â„‚": "Copf", "Ä‡": "cacute", "Ä†": "Cacute", "Ä‰": "ccirc", "Äˆ": "Ccirc", "Ä": "ccaron", "ÄŒ": "Ccaron", "Ä‹": "cdot", "ÄŠ": "Cdot", "Ã§": "ccedil", "Ã‡": "Ccedil", "â„…": "incare", "ğ”¡": "dfr", "â…†": "dd", "ğ••": "dopf", "ğ’¹": "dscr", "ğ’Ÿ": "Dscr", "ğ”‡": "Dfr", "â……": "DD", "ğ”»": "Dopf", "Ä": "dcaron", "Ä": "Dcaron", "Ä‘": "dstrok", "Ä": "Dstrok", "Ã°": "eth", "Ã": "ETH", "â…‡": "ee", "â„¯": "escr", "ğ”¢": "efr", "ğ•–": "eopf", "â„°": "Escr", "ğ”ˆ": "Efr", "ğ”¼": "Eopf", "Ã©": "eacute", "Ã‰": "Eacute", "Ã¨": "egrave", "Ãˆ": "Egrave", "Ãª": "ecirc", "ÃŠ": "Ecirc", "Ä›": "ecaron", "Äš": "Ecaron", "Ã«": "euml", "Ã‹": "Euml", "Ä—": "edot", "Ä–": "Edot", "Ä™": "eogon", "Ä˜": "Eogon", "Ä“": "emacr", "Ä’": "Emacr", "ğ”£": "ffr", "ğ•—": "fopf", "ğ’»": "fscr", "ğ”‰": "Ffr", "ğ”½": "Fopf", "â„±": "Fscr", "ï¬€": "fflig", "ï¬ƒ": "ffilig", "ï¬„": "ffllig", "ï¬": "filig", "fj": "fjlig", "ï¬‚": "fllig", "Æ’": "fnof", "â„Š": "gscr", "ğ•˜": "gopf", "ğ”¤": "gfr", "ğ’¢": "Gscr", "ğ”¾": "Gopf", "ğ”Š": "Gfr", "Çµ": "gacute", "ÄŸ": "gbreve", "Ä": "Gbreve", "Ä": "gcirc", "Äœ": "Gcirc", "Ä¡": "gdot", "Ä ": "Gdot", "Ä¢": "Gcedil", "ğ”¥": "hfr", "â„": "planckh", "ğ’½": "hscr", "ğ•™": "hopf", "â„‹": "Hscr", "â„Œ": "Hfr", "â„": "Hopf", "Ä¥": "hcirc", "Ä¤": "Hcirc", "â„": "hbar", "Ä§": "hstrok", "Ä¦": "Hstrok", "ğ•š": "iopf", "ğ”¦": "ifr", "ğ’¾": "iscr", "â…ˆ": "ii", "ğ•€": "Iopf", "â„": "Iscr", "â„‘": "Im", "Ã­": "iacute", "Ã": "Iacute", "Ã¬": "igrave", "ÃŒ": "Igrave", "Ã®": "icirc", "Ã": "Icirc", "Ã¯": "iuml", "Ã": "Iuml", "Ä©": "itilde", "Ä¨": "Itilde", "Ä°": "Idot", "Ä¯": "iogon", "Ä®": "Iogon", "Ä«": "imacr", "Äª": "Imacr", "Ä³": "ijlig", "Ä²": "IJlig", "Ä±": "imath", "ğ’¿": "jscr", "ğ•›": "jopf", "ğ”§": "jfr", "ğ’¥": "Jscr", "ğ”": "Jfr", "ğ•": "Jopf", "Äµ": "jcirc", "Ä´": "Jcirc", "È·": "jmath", "ğ•œ": "kopf", "ğ“€": "kscr", "ğ”¨": "kfr", "ğ’¦": "Kscr", "ğ•‚": "Kopf", "ğ”": "Kfr", "Ä·": "kcedil", "Ä¶": "Kcedil", "ğ”©": "lfr", "ğ“": "lscr", "â„“": "ell", "ğ•": "lopf", "â„’": "Lscr", "ğ”": "Lfr", "ğ•ƒ": "Lopf", "Äº": "lacute", "Ä¹": "Lacute", "Ä¾": "lcaron", "Ä½": "Lcaron", "Ä¼": "lcedil", "Ä»": "Lcedil", "Å‚": "lstrok", "Å": "Lstrok", "Å€": "lmidot", "Ä¿": "Lmidot", "ğ”ª": "mfr", "ğ•": "mopf", "ğ“‚": "mscr", "ğ”": "Mfr", "ğ•„": "Mopf", "â„³": "Mscr", "ğ”«": "nfr", "ğ•Ÿ": "nopf", "ğ“ƒ": "nscr", "â„•": "Nopf", "ğ’©": "Nscr", "ğ”‘": "Nfr", "Å„": "nacute", "Åƒ": "Nacute", "Åˆ": "ncaron", "Å‡": "Ncaron", "Ã±": "ntilde", "Ã‘": "Ntilde", "Å†": "ncedil", "Å…": "Ncedil", "â„–": "numero", "Å‹": "eng", "ÅŠ": "ENG", "ğ• ": "oopf", "ğ”¬": "ofr", "â„´": "oscr", "ğ’ª": "Oscr", "ğ”’": "Ofr", "ğ•†": "Oopf", "Âº": "ordm", "Ã³": "oacute", "Ã“": "Oacute", "Ã²": "ograve", "Ã’": "Ograve", "Ã´": "ocirc", "Ã”": "Ocirc", "Ã¶": "ouml", "Ã–": "Ouml", "Å‘": "odblac", "Å": "Odblac", "Ãµ": "otilde", "Ã•": "Otilde", "Ã¸": "oslash", "Ã˜": "Oslash", "Å": "omacr", "ÅŒ": "Omacr", "Å“": "oelig", "Å’": "OElig", "ğ”­": "pfr", "ğ“…": "pscr", "ğ•¡": "popf", "â„™": "Popf", "ğ”“": "Pfr", "ğ’«": "Pscr", "ğ•¢": "qopf", "ğ”®": "qfr", "ğ“†": "qscr", "ğ’¬": "Qscr", "ğ””": "Qfr", "â„š": "Qopf", "Ä¸": "kgreen", "ğ”¯": "rfr", "ğ•£": "ropf", "ğ“‡": "rscr", "â„›": "Rscr", "â„œ": "Re", "â„": "Ropf", "Å•": "racute", "Å”": "Racute", "Å™": "rcaron", "Å˜": "Rcaron", "Å—": "rcedil", "Å–": "Rcedil", "ğ•¤": "sopf", "ğ“ˆ": "sscr", "ğ”°": "sfr", "ğ•Š": "Sopf", "ğ”–": "Sfr", "ğ’®": "Sscr", "â“ˆ": "oS", "Å›": "sacute", "Åš": "Sacute", "Å": "scirc", "Åœ": "Scirc", "Å¡": "scaron", "Å ": "Scaron", "ÅŸ": "scedil", "Å": "Scedil", "ÃŸ": "szlig", "ğ”±": "tfr", "ğ“‰": "tscr", "ğ•¥": "topf", "ğ’¯": "Tscr", "ğ”—": "Tfr", "ğ•‹": "Topf", "Å¥": "tcaron", "Å¤": "Tcaron", "Å£": "tcedil", "Å¢": "Tcedil", "â„¢": "trade", "Å§": "tstrok", "Å¦": "Tstrok", "ğ“Š": "uscr", "ğ•¦": "uopf", "ğ”²": "ufr", "ğ•Œ": "Uopf", "ğ”˜": "Ufr", "ğ’°": "Uscr", "Ãº": "uacute", "Ãš": "Uacute", "Ã¹": "ugrave", "Ã™": "Ugrave", "Å­": "ubreve", "Å¬": "Ubreve", "Ã»": "ucirc", "Ã›": "Ucirc", "Å¯": "uring", "Å®": "Uring", "Ã¼": "uuml", "Ãœ": "Uuml", "Å±": "udblac", "Å°": "Udblac", "Å©": "utilde", "Å¨": "Utilde", "Å³": "uogon", "Å²": "Uogon", "Å«": "umacr", "Åª": "Umacr", "ğ”³": "vfr", "ğ•§": "vopf", "ğ“‹": "vscr", "ğ”™": "Vfr", "ğ•": "Vopf", "ğ’±": "Vscr", "ğ•¨": "wopf", "ğ“Œ": "wscr", "ğ”´": "wfr", "ğ’²": "Wscr", "ğ•": "Wopf", "ğ”š": "Wfr", "Åµ": "wcirc", "Å´": "Wcirc", "ğ”µ": "xfr", "ğ“": "xscr", "ğ•©": "xopf", "ğ•": "Xopf", "ğ”›": "Xfr", "ğ’³": "Xscr", "ğ”¶": "yfr", "ğ“": "yscr", "ğ•ª": "yopf", "ğ’´": "Yscr", "ğ”œ": "Yfr", "ğ•": "Yopf", "Ã½": "yacute", "Ã": "Yacute", "Å·": "ycirc", "Å¶": "Ycirc", "Ã¿": "yuml", "Å¸": "Yuml", "ğ“": "zscr", "ğ”·": "zfr", "ğ•«": "zopf", "â„¨": "Zfr", "â„¤": "Zopf", "ğ’µ": "Zscr", "Åº": "zacute", "Å¹": "Zacute", "Å¾": "zcaron", "Å½": "Zcaron", "Å¼": "zdot", "Å»": "Zdot", "Æµ": "imped", "Ã¾": "thorn", "Ã": "THORN", "Å‰": "napos", "Î±": "alpha", "Î‘": "Alpha", "Î²": "beta", "Î’": "Beta", "Î³": "gamma", "Î“": "Gamma", "Î´": "delta", "Î”": "Delta", "Îµ": "epsi", "Ïµ": "epsiv", "Î•": "Epsilon", "Ï": "gammad", "Ïœ": "Gammad", "Î¶": "zeta", "Î–": "Zeta", "Î·": "eta", "Î—": "Eta", "Î¸": "theta", "Ï‘": "thetav", "Î˜": "Theta", "Î¹": "iota", "Î™": "Iota", "Îº": "kappa", "Ï°": "kappav", "Îš": "Kappa", "Î»": "lambda", "Î›": "Lambda", "Î¼": "mu", "Âµ": "micro", "Îœ": "Mu", "Î½": "nu", "Î": "Nu", "Î¾": "xi", "Î": "Xi", "Î¿": "omicron", "ÎŸ": "Omicron", "Ï€": "pi", "Ï–": "piv", "Î ": "Pi", "Ï": "rho", "Ï±": "rhov", "Î¡": "Rho", "Ïƒ": "sigma", "Î£": "Sigma", "Ï‚": "sigmaf", "Ï„": "tau", "Î¤": "Tau", "Ï…": "upsi", "Î¥": "Upsilon", "Ï’": "Upsi", "Ï†": "phi", "Ï•": "phiv", "Î¦": "Phi", "Ï‡": "chi", "Î§": "Chi", "Ïˆ": "psi", "Î¨": "Psi", "Ï‰": "omega", "Î©": "ohm", "Ğ°": "acy", "Ğ": "Acy", "Ğ±": "bcy", "Ğ‘": "Bcy", "Ğ²": "vcy", "Ğ’": "Vcy", "Ğ³": "gcy", "Ğ“": "Gcy", "Ñ“": "gjcy", "Ğƒ": "GJcy", "Ğ´": "dcy", "Ğ”": "Dcy", "Ñ’": "djcy", "Ğ‚": "DJcy", "Ğµ": "iecy", "Ğ•": "IEcy", "Ñ‘": "iocy", "Ğ": "IOcy", "Ñ”": "jukcy", "Ğ„": "Jukcy", "Ğ¶": "zhcy", "Ğ–": "ZHcy", "Ğ·": "zcy", "Ğ—": "Zcy", "Ñ•": "dscy", "Ğ…": "DScy", "Ğ¸": "icy", "Ğ˜": "Icy", "Ñ–": "iukcy", "Ğ†": "Iukcy", "Ñ—": "yicy", "Ğ‡": "YIcy", "Ğ¹": "jcy", "Ğ™": "Jcy", "Ñ˜": "jsercy", "Ğˆ": "Jsercy", "Ğº": "kcy", "Ğš": "Kcy", "Ñœ": "kjcy", "ĞŒ": "KJcy", "Ğ»": "lcy", "Ğ›": "Lcy", "Ñ™": "ljcy", "Ğ‰": "LJcy", "Ğ¼": "mcy", "Ğœ": "Mcy", "Ğ½": "ncy", "Ğ": "Ncy", "Ñš": "njcy", "ĞŠ": "NJcy", "Ğ¾": "ocy", "Ğ": "Ocy", "Ğ¿": "pcy", "ĞŸ": "Pcy", "Ñ€": "rcy", "Ğ ": "Rcy", "Ñ": "scy", "Ğ¡": "Scy", "Ñ‚": "tcy", "Ğ¢": "Tcy", "Ñ›": "tshcy", "Ğ‹": "TSHcy", "Ñƒ": "ucy", "Ğ£": "Ucy", "Ñ": "ubrcy", "Ğ": "Ubrcy", "Ñ„": "fcy", "Ğ¤": "Fcy", "Ñ…": "khcy", "Ğ¥": "KHcy", "Ñ†": "tscy", "Ğ¦": "TScy", "Ñ‡": "chcy", "Ğ§": "CHcy", "ÑŸ": "dzcy", "Ğ": "DZcy", "Ñˆ": "shcy", "Ğ¨": "SHcy", "Ñ‰": "shchcy", "Ğ©": "SHCHcy", "ÑŠ": "hardcy", "Ğª": "HARDcy", "Ñ‹": "ycy", "Ğ«": "Ycy", "ÑŒ": "softcy", "Ğ¬": "SOFTcy", "Ñ": "ecy", "Ğ­": "Ecy", "Ñ": "yucy", "Ğ®": "YUcy", "Ñ": "yacy", "Ğ¯": "YAcy", "â„µ": "aleph", "â„¶": "beth", "â„·": "gimel", "â„¸": "daleth" };
      var regexEscape = /["&'<>`]/g;
      var escapeMap = {
        '"': "&quot;",
        "&": "&amp;",
        "'": "&#x27;",
        "<": "&lt;",
        // See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
        // following is not strictly necessary unless itâ€™s part of a tag or an
        // unquoted attribute value. Weâ€™re only escaping it to support those
        // situations, and for XML support.
        ">": "&gt;",
        // In Internet Explorer â‰¤ 8, the backtick character can be used
        // to break out of (un)quoted attribute values or HTML comments.
        // See http://html5sec.org/#102, http://html5sec.org/#108, and
        // http://html5sec.org/#133.
        "`": "&#x60;"
      };
      var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
      var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
      var regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
      var decodeMap = { "aacute": "Ã¡", "Aacute": "Ã", "abreve": "Äƒ", "Abreve": "Ä‚", "ac": "âˆ¾", "acd": "âˆ¿", "acE": "âˆ¾Ì³", "acirc": "Ã¢", "Acirc": "Ã‚", "acute": "Â´", "acy": "Ğ°", "Acy": "Ğ", "aelig": "Ã¦", "AElig": "Ã†", "af": "â¡", "afr": "ğ”", "Afr": "ğ”„", "agrave": "Ã ", "Agrave": "Ã€", "alefsym": "â„µ", "aleph": "â„µ", "alpha": "Î±", "Alpha": "Î‘", "amacr": "Ä", "Amacr": "Ä€", "amalg": "â¨¿", "amp": "&", "AMP": "&", "and": "âˆ§", "And": "â©“", "andand": "â©•", "andd": "â©œ", "andslope": "â©˜", "andv": "â©š", "ang": "âˆ ", "ange": "â¦¤", "angle": "âˆ ", "angmsd": "âˆ¡", "angmsdaa": "â¦¨", "angmsdab": "â¦©", "angmsdac": "â¦ª", "angmsdad": "â¦«", "angmsdae": "â¦¬", "angmsdaf": "â¦­", "angmsdag": "â¦®", "angmsdah": "â¦¯", "angrt": "âˆŸ", "angrtvb": "âŠ¾", "angrtvbd": "â¦", "angsph": "âˆ¢", "angst": "Ã…", "angzarr": "â¼", "aogon": "Ä…", "Aogon": "Ä„", "aopf": "ğ•’", "Aopf": "ğ”¸", "ap": "â‰ˆ", "apacir": "â©¯", "ape": "â‰Š", "apE": "â©°", "apid": "â‰‹", "apos": "'", "ApplyFunction": "â¡", "approx": "â‰ˆ", "approxeq": "â‰Š", "aring": "Ã¥", "Aring": "Ã…", "ascr": "ğ’¶", "Ascr": "ğ’œ", "Assign": "â‰”", "ast": "*", "asymp": "â‰ˆ", "asympeq": "â‰", "atilde": "Ã£", "Atilde": "Ãƒ", "auml": "Ã¤", "Auml": "Ã„", "awconint": "âˆ³", "awint": "â¨‘", "backcong": "â‰Œ", "backepsilon": "Ï¶", "backprime": "â€µ", "backsim": "âˆ½", "backsimeq": "â‹", "Backslash": "âˆ–", "Barv": "â«§", "barvee": "âŠ½", "barwed": "âŒ…", "Barwed": "âŒ†", "barwedge": "âŒ…", "bbrk": "âµ", "bbrktbrk": "â¶", "bcong": "â‰Œ", "bcy": "Ğ±", "Bcy": "Ğ‘", "bdquo": "â€", "becaus": "âˆµ", "because": "âˆµ", "Because": "âˆµ", "bemptyv": "â¦°", "bepsi": "Ï¶", "bernou": "â„¬", "Bernoullis": "â„¬", "beta": "Î²", "Beta": "Î’", "beth": "â„¶", "between": "â‰¬", "bfr": "ğ”Ÿ", "Bfr": "ğ”…", "bigcap": "â‹‚", "bigcirc": "â—¯", "bigcup": "â‹ƒ", "bigodot": "â¨€", "bigoplus": "â¨", "bigotimes": "â¨‚", "bigsqcup": "â¨†", "bigstar": "â˜…", "bigtriangledown": "â–½", "bigtriangleup": "â–³", "biguplus": "â¨„", "bigvee": "â‹", "bigwedge": "â‹€", "bkarow": "â¤", "blacklozenge": "â§«", "blacksquare": "â–ª", "blacktriangle": "â–´", "blacktriangledown": "â–¾", "blacktriangleleft": "â—‚", "blacktriangleright": "â–¸", "blank": "â£", "blk12": "â–’", "blk14": "â–‘", "blk34": "â–“", "block": "â–ˆ", "bne": "=âƒ¥", "bnequiv": "â‰¡âƒ¥", "bnot": "âŒ", "bNot": "â«­", "bopf": "ğ•“", "Bopf": "ğ”¹", "bot": "âŠ¥", "bottom": "âŠ¥", "bowtie": "â‹ˆ", "boxbox": "â§‰", "boxdl": "â”", "boxdL": "â••", "boxDl": "â•–", "boxDL": "â•—", "boxdr": "â”Œ", "boxdR": "â•’", "boxDr": "â•“", "boxDR": "â•”", "boxh": "â”€", "boxH": "â•", "boxhd": "â”¬", "boxhD": "â•¥", "boxHd": "â•¤", "boxHD": "â•¦", "boxhu": "â”´", "boxhU": "â•¨", "boxHu": "â•§", "boxHU": "â•©", "boxminus": "âŠŸ", "boxplus": "âŠ", "boxtimes": "âŠ ", "boxul": "â”˜", "boxuL": "â•›", "boxUl": "â•œ", "boxUL": "â•", "boxur": "â””", "boxuR": "â•˜", "boxUr": "â•™", "boxUR": "â•š", "boxv": "â”‚", "boxV": "â•‘", "boxvh": "â”¼", "boxvH": "â•ª", "boxVh": "â•«", "boxVH": "â•¬", "boxvl": "â”¤", "boxvL": "â•¡", "boxVl": "â•¢", "boxVL": "â•£", "boxvr": "â”œ", "boxvR": "â•", "boxVr": "â•Ÿ", "boxVR": "â• ", "bprime": "â€µ", "breve": "Ë˜", "Breve": "Ë˜", "brvbar": "Â¦", "bscr": "ğ’·", "Bscr": "â„¬", "bsemi": "â", "bsim": "âˆ½", "bsime": "â‹", "bsol": "\\", "bsolb": "â§…", "bsolhsub": "âŸˆ", "bull": "â€¢", "bullet": "â€¢", "bump": "â‰", "bumpe": "â‰", "bumpE": "âª®", "bumpeq": "â‰", "Bumpeq": "â‰", "cacute": "Ä‡", "Cacute": "Ä†", "cap": "âˆ©", "Cap": "â‹’", "capand": "â©„", "capbrcup": "â©‰", "capcap": "â©‹", "capcup": "â©‡", "capdot": "â©€", "CapitalDifferentialD": "â……", "caps": "âˆ©ï¸€", "caret": "â", "caron": "Ë‡", "Cayleys": "â„­", "ccaps": "â©", "ccaron": "Ä", "Ccaron": "ÄŒ", "ccedil": "Ã§", "Ccedil": "Ã‡", "ccirc": "Ä‰", "Ccirc": "Äˆ", "Cconint": "âˆ°", "ccups": "â©Œ", "ccupssm": "â©", "cdot": "Ä‹", "Cdot": "ÄŠ", "cedil": "Â¸", "Cedilla": "Â¸", "cemptyv": "â¦²", "cent": "Â¢", "centerdot": "Â·", "CenterDot": "Â·", "cfr": "ğ” ", "Cfr": "â„­", "chcy": "Ñ‡", "CHcy": "Ğ§", "check": "âœ“", "checkmark": "âœ“", "chi": "Ï‡", "Chi": "Î§", "cir": "â—‹", "circ": "Ë†", "circeq": "â‰—", "circlearrowleft": "â†º", "circlearrowright": "â†»", "circledast": "âŠ›", "circledcirc": "âŠš", "circleddash": "âŠ", "CircleDot": "âŠ™", "circledR": "Â®", "circledS": "â“ˆ", "CircleMinus": "âŠ–", "CirclePlus": "âŠ•", "CircleTimes": "âŠ—", "cire": "â‰—", "cirE": "â§ƒ", "cirfnint": "â¨", "cirmid": "â«¯", "cirscir": "â§‚", "ClockwiseContourIntegral": "âˆ²", "CloseCurlyDoubleQuote": "â€", "CloseCurlyQuote": "â€™", "clubs": "â™£", "clubsuit": "â™£", "colon": ":", "Colon": "âˆ·", "colone": "â‰”", "Colone": "â©´", "coloneq": "â‰”", "comma": ",", "commat": "@", "comp": "âˆ", "compfn": "âˆ˜", "complement": "âˆ", "complexes": "â„‚", "cong": "â‰…", "congdot": "â©­", "Congruent": "â‰¡", "conint": "âˆ®", "Conint": "âˆ¯", "ContourIntegral": "âˆ®", "copf": "ğ•”", "Copf": "â„‚", "coprod": "âˆ", "Coproduct": "âˆ", "copy": "Â©", "COPY": "Â©", "copysr": "â„—", "CounterClockwiseContourIntegral": "âˆ³", "crarr": "â†µ", "cross": "âœ—", "Cross": "â¨¯", "cscr": "ğ’¸", "Cscr": "ğ’", "csub": "â«", "csube": "â«‘", "csup": "â«", "csupe": "â«’", "ctdot": "â‹¯", "cudarrl": "â¤¸", "cudarrr": "â¤µ", "cuepr": "â‹", "cuesc": "â‹Ÿ", "cularr": "â†¶", "cularrp": "â¤½", "cup": "âˆª", "Cup": "â‹“", "cupbrcap": "â©ˆ", "cupcap": "â©†", "CupCap": "â‰", "cupcup": "â©Š", "cupdot": "âŠ", "cupor": "â©…", "cups": "âˆªï¸€", "curarr": "â†·", "curarrm": "â¤¼", "curlyeqprec": "â‹", "curlyeqsucc": "â‹Ÿ", "curlyvee": "â‹", "curlywedge": "â‹", "curren": "Â¤", "curvearrowleft": "â†¶", "curvearrowright": "â†·", "cuvee": "â‹", "cuwed": "â‹", "cwconint": "âˆ²", "cwint": "âˆ±", "cylcty": "âŒ­", "dagger": "â€ ", "Dagger": "â€¡", "daleth": "â„¸", "darr": "â†“", "dArr": "â‡“", "Darr": "â†¡", "dash": "â€", "dashv": "âŠ£", "Dashv": "â«¤", "dbkarow": "â¤", "dblac": "Ë", "dcaron": "Ä", "Dcaron": "Ä", "dcy": "Ğ´", "Dcy": "Ğ”", "dd": "â…†", "DD": "â……", "ddagger": "â€¡", "ddarr": "â‡Š", "DDotrahd": "â¤‘", "ddotseq": "â©·", "deg": "Â°", "Del": "âˆ‡", "delta": "Î´", "Delta": "Î”", "demptyv": "â¦±", "dfisht": "â¥¿", "dfr": "ğ”¡", "Dfr": "ğ”‡", "dHar": "â¥¥", "dharl": "â‡ƒ", "dharr": "â‡‚", "DiacriticalAcute": "Â´", "DiacriticalDot": "Ë™", "DiacriticalDoubleAcute": "Ë", "DiacriticalGrave": "`", "DiacriticalTilde": "Ëœ", "diam": "â‹„", "diamond": "â‹„", "Diamond": "â‹„", "diamondsuit": "â™¦", "diams": "â™¦", "die": "Â¨", "DifferentialD": "â…†", "digamma": "Ï", "disin": "â‹²", "div": "Ã·", "divide": "Ã·", "divideontimes": "â‹‡", "divonx": "â‹‡", "djcy": "Ñ’", "DJcy": "Ğ‚", "dlcorn": "âŒ", "dlcrop": "âŒ", "dollar": "$", "dopf": "ğ••", "Dopf": "ğ”»", "dot": "Ë™", "Dot": "Â¨", "DotDot": "âƒœ", "doteq": "â‰", "doteqdot": "â‰‘", "DotEqual": "â‰", "dotminus": "âˆ¸", "dotplus": "âˆ”", "dotsquare": "âŠ¡", "doublebarwedge": "âŒ†", "DoubleContourIntegral": "âˆ¯", "DoubleDot": "Â¨", "DoubleDownArrow": "â‡“", "DoubleLeftArrow": "â‡", "DoubleLeftRightArrow": "â‡”", "DoubleLeftTee": "â«¤", "DoubleLongLeftArrow": "âŸ¸", "DoubleLongLeftRightArrow": "âŸº", "DoubleLongRightArrow": "âŸ¹", "DoubleRightArrow": "â‡’", "DoubleRightTee": "âŠ¨", "DoubleUpArrow": "â‡‘", "DoubleUpDownArrow": "â‡•", "DoubleVerticalBar": "âˆ¥", "downarrow": "â†“", "Downarrow": "â‡“", "DownArrow": "â†“", "DownArrowBar": "â¤“", "DownArrowUpArrow": "â‡µ", "DownBreve": "Ì‘", "downdownarrows": "â‡Š", "downharpoonleft": "â‡ƒ", "downharpoonright": "â‡‚", "DownLeftRightVector": "â¥", "DownLeftTeeVector": "â¥", "DownLeftVector": "â†½", "DownLeftVectorBar": "â¥–", "DownRightTeeVector": "â¥Ÿ", "DownRightVector": "â‡", "DownRightVectorBar": "â¥—", "DownTee": "âŠ¤", "DownTeeArrow": "â†§", "drbkarow": "â¤", "drcorn": "âŒŸ", "drcrop": "âŒŒ", "dscr": "ğ’¹", "Dscr": "ğ’Ÿ", "dscy": "Ñ•", "DScy": "Ğ…", "dsol": "â§¶", "dstrok": "Ä‘", "Dstrok": "Ä", "dtdot": "â‹±", "dtri": "â–¿", "dtrif": "â–¾", "duarr": "â‡µ", "duhar": "â¥¯", "dwangle": "â¦¦", "dzcy": "ÑŸ", "DZcy": "Ğ", "dzigrarr": "âŸ¿", "eacute": "Ã©", "Eacute": "Ã‰", "easter": "â©®", "ecaron": "Ä›", "Ecaron": "Äš", "ecir": "â‰–", "ecirc": "Ãª", "Ecirc": "ÃŠ", "ecolon": "â‰•", "ecy": "Ñ", "Ecy": "Ğ­", "eDDot": "â©·", "edot": "Ä—", "eDot": "â‰‘", "Edot": "Ä–", "ee": "â…‡", "efDot": "â‰’", "efr": "ğ”¢", "Efr": "ğ”ˆ", "eg": "âªš", "egrave": "Ã¨", "Egrave": "Ãˆ", "egs": "âª–", "egsdot": "âª˜", "el": "âª™", "Element": "âˆˆ", "elinters": "â§", "ell": "â„“", "els": "âª•", "elsdot": "âª—", "emacr": "Ä“", "Emacr": "Ä’", "empty": "âˆ…", "emptyset": "âˆ…", "EmptySmallSquare": "â—»", "emptyv": "âˆ…", "EmptyVerySmallSquare": "â–«", "emsp": "â€ƒ", "emsp13": "â€„", "emsp14": "â€…", "eng": "Å‹", "ENG": "ÅŠ", "ensp": "â€‚", "eogon": "Ä™", "Eogon": "Ä˜", "eopf": "ğ•–", "Eopf": "ğ”¼", "epar": "â‹•", "eparsl": "â§£", "eplus": "â©±", "epsi": "Îµ", "epsilon": "Îµ", "Epsilon": "Î•", "epsiv": "Ïµ", "eqcirc": "â‰–", "eqcolon": "â‰•", "eqsim": "â‰‚", "eqslantgtr": "âª–", "eqslantless": "âª•", "Equal": "â©µ", "equals": "=", "EqualTilde": "â‰‚", "equest": "â‰Ÿ", "Equilibrium": "â‡Œ", "equiv": "â‰¡", "equivDD": "â©¸", "eqvparsl": "â§¥", "erarr": "â¥±", "erDot": "â‰“", "escr": "â„¯", "Escr": "â„°", "esdot": "â‰", "esim": "â‰‚", "Esim": "â©³", "eta": "Î·", "Eta": "Î—", "eth": "Ã°", "ETH": "Ã", "euml": "Ã«", "Euml": "Ã‹", "euro": "â‚¬", "excl": "!", "exist": "âˆƒ", "Exists": "âˆƒ", "expectation": "â„°", "exponentiale": "â…‡", "ExponentialE": "â…‡", "fallingdotseq": "â‰’", "fcy": "Ñ„", "Fcy": "Ğ¤", "female": "â™€", "ffilig": "ï¬ƒ", "fflig": "ï¬€", "ffllig": "ï¬„", "ffr": "ğ”£", "Ffr": "ğ”‰", "filig": "ï¬", "FilledSmallSquare": "â—¼", "FilledVerySmallSquare": "â–ª", "fjlig": "fj", "flat": "â™­", "fllig": "ï¬‚", "fltns": "â–±", "fnof": "Æ’", "fopf": "ğ•—", "Fopf": "ğ”½", "forall": "âˆ€", "ForAll": "âˆ€", "fork": "â‹”", "forkv": "â«™", "Fouriertrf": "â„±", "fpartint": "â¨", "frac12": "Â½", "frac13": "â…“", "frac14": "Â¼", "frac15": "â…•", "frac16": "â…™", "frac18": "â…›", "frac23": "â…”", "frac25": "â…–", "frac34": "Â¾", "frac35": "â…—", "frac38": "â…œ", "frac45": "â…˜", "frac56": "â…š", "frac58": "â…", "frac78": "â…", "frasl": "â„", "frown": "âŒ¢", "fscr": "ğ’»", "Fscr": "â„±", "gacute": "Çµ", "gamma": "Î³", "Gamma": "Î“", "gammad": "Ï", "Gammad": "Ïœ", "gap": "âª†", "gbreve": "ÄŸ", "Gbreve": "Ä", "Gcedil": "Ä¢", "gcirc": "Ä", "Gcirc": "Äœ", "gcy": "Ğ³", "Gcy": "Ğ“", "gdot": "Ä¡", "Gdot": "Ä ", "ge": "â‰¥", "gE": "â‰§", "gel": "â‹›", "gEl": "âªŒ", "geq": "â‰¥", "geqq": "â‰§", "geqslant": "â©¾", "ges": "â©¾", "gescc": "âª©", "gesdot": "âª€", "gesdoto": "âª‚", "gesdotol": "âª„", "gesl": "â‹›ï¸€", "gesles": "âª”", "gfr": "ğ”¤", "Gfr": "ğ”Š", "gg": "â‰«", "Gg": "â‹™", "ggg": "â‹™", "gimel": "â„·", "gjcy": "Ñ“", "GJcy": "Ğƒ", "gl": "â‰·", "gla": "âª¥", "glE": "âª’", "glj": "âª¤", "gnap": "âªŠ", "gnapprox": "âªŠ", "gne": "âªˆ", "gnE": "â‰©", "gneq": "âªˆ", "gneqq": "â‰©", "gnsim": "â‹§", "gopf": "ğ•˜", "Gopf": "ğ”¾", "grave": "`", "GreaterEqual": "â‰¥", "GreaterEqualLess": "â‹›", "GreaterFullEqual": "â‰§", "GreaterGreater": "âª¢", "GreaterLess": "â‰·", "GreaterSlantEqual": "â©¾", "GreaterTilde": "â‰³", "gscr": "â„Š", "Gscr": "ğ’¢", "gsim": "â‰³", "gsime": "âª", "gsiml": "âª", "gt": ">", "Gt": "â‰«", "GT": ">", "gtcc": "âª§", "gtcir": "â©º", "gtdot": "â‹—", "gtlPar": "â¦•", "gtquest": "â©¼", "gtrapprox": "âª†", "gtrarr": "â¥¸", "gtrdot": "â‹—", "gtreqless": "â‹›", "gtreqqless": "âªŒ", "gtrless": "â‰·", "gtrsim": "â‰³", "gvertneqq": "â‰©ï¸€", "gvnE": "â‰©ï¸€", "Hacek": "Ë‡", "hairsp": "â€Š", "half": "Â½", "hamilt": "â„‹", "hardcy": "ÑŠ", "HARDcy": "Ğª", "harr": "â†”", "hArr": "â‡”", "harrcir": "â¥ˆ", "harrw": "â†­", "Hat": "^", "hbar": "â„", "hcirc": "Ä¥", "Hcirc": "Ä¤", "hearts": "â™¥", "heartsuit": "â™¥", "hellip": "â€¦", "hercon": "âŠ¹", "hfr": "ğ”¥", "Hfr": "â„Œ", "HilbertSpace": "â„‹", "hksearow": "â¤¥", "hkswarow": "â¤¦", "hoarr": "â‡¿", "homtht": "âˆ»", "hookleftarrow": "â†©", "hookrightarrow": "â†ª", "hopf": "ğ•™", "Hopf": "â„", "horbar": "â€•", "HorizontalLine": "â”€", "hscr": "ğ’½", "Hscr": "â„‹", "hslash": "â„", "hstrok": "Ä§", "Hstrok": "Ä¦", "HumpDownHump": "â‰", "HumpEqual": "â‰", "hybull": "âƒ", "hyphen": "â€", "iacute": "Ã­", "Iacute": "Ã", "ic": "â£", "icirc": "Ã®", "Icirc": "Ã", "icy": "Ğ¸", "Icy": "Ğ˜", "Idot": "Ä°", "iecy": "Ğµ", "IEcy": "Ğ•", "iexcl": "Â¡", "iff": "â‡”", "ifr": "ğ”¦", "Ifr": "â„‘", "igrave": "Ã¬", "Igrave": "ÃŒ", "ii": "â…ˆ", "iiiint": "â¨Œ", "iiint": "âˆ­", "iinfin": "â§œ", "iiota": "â„©", "ijlig": "Ä³", "IJlig": "Ä²", "Im": "â„‘", "imacr": "Ä«", "Imacr": "Äª", "image": "â„‘", "ImaginaryI": "â…ˆ", "imagline": "â„", "imagpart": "â„‘", "imath": "Ä±", "imof": "âŠ·", "imped": "Æµ", "Implies": "â‡’", "in": "âˆˆ", "incare": "â„…", "infin": "âˆ", "infintie": "â§", "inodot": "Ä±", "int": "âˆ«", "Int": "âˆ¬", "intcal": "âŠº", "integers": "â„¤", "Integral": "âˆ«", "intercal": "âŠº", "Intersection": "â‹‚", "intlarhk": "â¨—", "intprod": "â¨¼", "InvisibleComma": "â£", "InvisibleTimes": "â¢", "iocy": "Ñ‘", "IOcy": "Ğ", "iogon": "Ä¯", "Iogon": "Ä®", "iopf": "ğ•š", "Iopf": "ğ•€", "iota": "Î¹", "Iota": "Î™", "iprod": "â¨¼", "iquest": "Â¿", "iscr": "ğ’¾", "Iscr": "â„", "isin": "âˆˆ", "isindot": "â‹µ", "isinE": "â‹¹", "isins": "â‹´", "isinsv": "â‹³", "isinv": "âˆˆ", "it": "â¢", "itilde": "Ä©", "Itilde": "Ä¨", "iukcy": "Ñ–", "Iukcy": "Ğ†", "iuml": "Ã¯", "Iuml": "Ã", "jcirc": "Äµ", "Jcirc": "Ä´", "jcy": "Ğ¹", "Jcy": "Ğ™", "jfr": "ğ”§", "Jfr": "ğ”", "jmath": "È·", "jopf": "ğ•›", "Jopf": "ğ•", "jscr": "ğ’¿", "Jscr": "ğ’¥", "jsercy": "Ñ˜", "Jsercy": "Ğˆ", "jukcy": "Ñ”", "Jukcy": "Ğ„", "kappa": "Îº", "Kappa": "Îš", "kappav": "Ï°", "kcedil": "Ä·", "Kcedil": "Ä¶", "kcy": "Ğº", "Kcy": "Ğš", "kfr": "ğ”¨", "Kfr": "ğ”", "kgreen": "Ä¸", "khcy": "Ñ…", "KHcy": "Ğ¥", "kjcy": "Ñœ", "KJcy": "ĞŒ", "kopf": "ğ•œ", "Kopf": "ğ•‚", "kscr": "ğ“€", "Kscr": "ğ’¦", "lAarr": "â‡š", "lacute": "Äº", "Lacute": "Ä¹", "laemptyv": "â¦´", "lagran": "â„’", "lambda": "Î»", "Lambda": "Î›", "lang": "âŸ¨", "Lang": "âŸª", "langd": "â¦‘", "langle": "âŸ¨", "lap": "âª…", "Laplacetrf": "â„’", "laquo": "Â«", "larr": "â†", "lArr": "â‡", "Larr": "â†", "larrb": "â‡¤", "larrbfs": "â¤Ÿ", "larrfs": "â¤", "larrhk": "â†©", "larrlp": "â†«", "larrpl": "â¤¹", "larrsim": "â¥³", "larrtl": "â†¢", "lat": "âª«", "latail": "â¤™", "lAtail": "â¤›", "late": "âª­", "lates": "âª­ï¸€", "lbarr": "â¤Œ", "lBarr": "â¤", "lbbrk": "â²", "lbrace": "{", "lbrack": "[", "lbrke": "â¦‹", "lbrksld": "â¦", "lbrkslu": "â¦", "lcaron": "Ä¾", "Lcaron": "Ä½", "lcedil": "Ä¼", "Lcedil": "Ä»", "lceil": "âŒˆ", "lcub": "{", "lcy": "Ğ»", "Lcy": "Ğ›", "ldca": "â¤¶", "ldquo": "â€œ", "ldquor": "â€", "ldrdhar": "â¥§", "ldrushar": "â¥‹", "ldsh": "â†²", "le": "â‰¤", "lE": "â‰¦", "LeftAngleBracket": "âŸ¨", "leftarrow": "â†", "Leftarrow": "â‡", "LeftArrow": "â†", "LeftArrowBar": "â‡¤", "LeftArrowRightArrow": "â‡†", "leftarrowtail": "â†¢", "LeftCeiling": "âŒˆ", "LeftDoubleBracket": "âŸ¦", "LeftDownTeeVector": "â¥¡", "LeftDownVector": "â‡ƒ", "LeftDownVectorBar": "â¥™", "LeftFloor": "âŒŠ", "leftharpoondown": "â†½", "leftharpoonup": "â†¼", "leftleftarrows": "â‡‡", "leftrightarrow": "â†”", "Leftrightarrow": "â‡”", "LeftRightArrow": "â†”", "leftrightarrows": "â‡†", "leftrightharpoons": "â‡‹", "leftrightsquigarrow": "â†­", "LeftRightVector": "â¥", "LeftTee": "âŠ£", "LeftTeeArrow": "â†¤", "LeftTeeVector": "â¥š", "leftthreetimes": "â‹‹", "LeftTriangle": "âŠ²", "LeftTriangleBar": "â§", "LeftTriangleEqual": "âŠ´", "LeftUpDownVector": "â¥‘", "LeftUpTeeVector": "â¥ ", "LeftUpVector": "â†¿", "LeftUpVectorBar": "â¥˜", "LeftVector": "â†¼", "LeftVectorBar": "â¥’", "leg": "â‹š", "lEg": "âª‹", "leq": "â‰¤", "leqq": "â‰¦", "leqslant": "â©½", "les": "â©½", "lescc": "âª¨", "lesdot": "â©¿", "lesdoto": "âª", "lesdotor": "âªƒ", "lesg": "â‹šï¸€", "lesges": "âª“", "lessapprox": "âª…", "lessdot": "â‹–", "lesseqgtr": "â‹š", "lesseqqgtr": "âª‹", "LessEqualGreater": "â‹š", "LessFullEqual": "â‰¦", "LessGreater": "â‰¶", "lessgtr": "â‰¶", "LessLess": "âª¡", "lesssim": "â‰²", "LessSlantEqual": "â©½", "LessTilde": "â‰²", "lfisht": "â¥¼", "lfloor": "âŒŠ", "lfr": "ğ”©", "Lfr": "ğ”", "lg": "â‰¶", "lgE": "âª‘", "lHar": "â¥¢", "lhard": "â†½", "lharu": "â†¼", "lharul": "â¥ª", "lhblk": "â–„", "ljcy": "Ñ™", "LJcy": "Ğ‰", "ll": "â‰ª", "Ll": "â‹˜", "llarr": "â‡‡", "llcorner": "âŒ", "Lleftarrow": "â‡š", "llhard": "â¥«", "lltri": "â—º", "lmidot": "Å€", "Lmidot": "Ä¿", "lmoust": "â°", "lmoustache": "â°", "lnap": "âª‰", "lnapprox": "âª‰", "lne": "âª‡", "lnE": "â‰¨", "lneq": "âª‡", "lneqq": "â‰¨", "lnsim": "â‹¦", "loang": "âŸ¬", "loarr": "â‡½", "lobrk": "âŸ¦", "longleftarrow": "âŸµ", "Longleftarrow": "âŸ¸", "LongLeftArrow": "âŸµ", "longleftrightarrow": "âŸ·", "Longleftrightarrow": "âŸº", "LongLeftRightArrow": "âŸ·", "longmapsto": "âŸ¼", "longrightarrow": "âŸ¶", "Longrightarrow": "âŸ¹", "LongRightArrow": "âŸ¶", "looparrowleft": "â†«", "looparrowright": "â†¬", "lopar": "â¦…", "lopf": "ğ•", "Lopf": "ğ•ƒ", "loplus": "â¨­", "lotimes": "â¨´", "lowast": "âˆ—", "lowbar": "_", "LowerLeftArrow": "â†™", "LowerRightArrow": "â†˜", "loz": "â—Š", "lozenge": "â—Š", "lozf": "â§«", "lpar": "(", "lparlt": "â¦“", "lrarr": "â‡†", "lrcorner": "âŒŸ", "lrhar": "â‡‹", "lrhard": "â¥­", "lrm": "â€", "lrtri": "âŠ¿", "lsaquo": "â€¹", "lscr": "ğ“", "Lscr": "â„’", "lsh": "â†°", "Lsh": "â†°", "lsim": "â‰²", "lsime": "âª", "lsimg": "âª", "lsqb": "[", "lsquo": "â€˜", "lsquor": "â€š", "lstrok": "Å‚", "Lstrok": "Å", "lt": "<", "Lt": "â‰ª", "LT": "<", "ltcc": "âª¦", "ltcir": "â©¹", "ltdot": "â‹–", "lthree": "â‹‹", "ltimes": "â‹‰", "ltlarr": "â¥¶", "ltquest": "â©»", "ltri": "â—ƒ", "ltrie": "âŠ´", "ltrif": "â—‚", "ltrPar": "â¦–", "lurdshar": "â¥Š", "luruhar": "â¥¦", "lvertneqq": "â‰¨ï¸€", "lvnE": "â‰¨ï¸€", "macr": "Â¯", "male": "â™‚", "malt": "âœ ", "maltese": "âœ ", "map": "â†¦", "Map": "â¤…", "mapsto": "â†¦", "mapstodown": "â†§", "mapstoleft": "â†¤", "mapstoup": "â†¥", "marker": "â–®", "mcomma": "â¨©", "mcy": "Ğ¼", "Mcy": "Ğœ", "mdash": "â€”", "mDDot": "âˆº", "measuredangle": "âˆ¡", "MediumSpace": "âŸ", "Mellintrf": "â„³", "mfr": "ğ”ª", "Mfr": "ğ”", "mho": "â„§", "micro": "Âµ", "mid": "âˆ£", "midast": "*", "midcir": "â«°", "middot": "Â·", "minus": "âˆ’", "minusb": "âŠŸ", "minusd": "âˆ¸", "minusdu": "â¨ª", "MinusPlus": "âˆ“", "mlcp": "â«›", "mldr": "â€¦", "mnplus": "âˆ“", "models": "âŠ§", "mopf": "ğ•", "Mopf": "ğ•„", "mp": "âˆ“", "mscr": "ğ“‚", "Mscr": "â„³", "mstpos": "âˆ¾", "mu": "Î¼", "Mu": "Îœ", "multimap": "âŠ¸", "mumap": "âŠ¸", "nabla": "âˆ‡", "nacute": "Å„", "Nacute": "Åƒ", "nang": "âˆ âƒ’", "nap": "â‰‰", "napE": "â©°Ì¸", "napid": "â‰‹Ì¸", "napos": "Å‰", "napprox": "â‰‰", "natur": "â™®", "natural": "â™®", "naturals": "â„•", "nbsp": "Â ", "nbump": "â‰Ì¸", "nbumpe": "â‰Ì¸", "ncap": "â©ƒ", "ncaron": "Åˆ", "Ncaron": "Å‡", "ncedil": "Å†", "Ncedil": "Å…", "ncong": "â‰‡", "ncongdot": "â©­Ì¸", "ncup": "â©‚", "ncy": "Ğ½", "Ncy": "Ğ", "ndash": "â€“", "ne": "â‰ ", "nearhk": "â¤¤", "nearr": "â†—", "neArr": "â‡—", "nearrow": "â†—", "nedot": "â‰Ì¸", "NegativeMediumSpace": "â€‹", "NegativeThickSpace": "â€‹", "NegativeThinSpace": "â€‹", "NegativeVeryThinSpace": "â€‹", "nequiv": "â‰¢", "nesear": "â¤¨", "nesim": "â‰‚Ì¸", "NestedGreaterGreater": "â‰«", "NestedLessLess": "â‰ª", "NewLine": "\n", "nexist": "âˆ„", "nexists": "âˆ„", "nfr": "ğ”«", "Nfr": "ğ”‘", "nge": "â‰±", "ngE": "â‰§Ì¸", "ngeq": "â‰±", "ngeqq": "â‰§Ì¸", "ngeqslant": "â©¾Ì¸", "nges": "â©¾Ì¸", "nGg": "â‹™Ì¸", "ngsim": "â‰µ", "ngt": "â‰¯", "nGt": "â‰«âƒ’", "ngtr": "â‰¯", "nGtv": "â‰«Ì¸", "nharr": "â†®", "nhArr": "â‡", "nhpar": "â«²", "ni": "âˆ‹", "nis": "â‹¼", "nisd": "â‹º", "niv": "âˆ‹", "njcy": "Ñš", "NJcy": "ĞŠ", "nlarr": "â†š", "nlArr": "â‡", "nldr": "â€¥", "nle": "â‰°", "nlE": "â‰¦Ì¸", "nleftarrow": "â†š", "nLeftarrow": "â‡", "nleftrightarrow": "â†®", "nLeftrightarrow": "â‡", "nleq": "â‰°", "nleqq": "â‰¦Ì¸", "nleqslant": "â©½Ì¸", "nles": "â©½Ì¸", "nless": "â‰®", "nLl": "â‹˜Ì¸", "nlsim": "â‰´", "nlt": "â‰®", "nLt": "â‰ªâƒ’", "nltri": "â‹ª", "nltrie": "â‹¬", "nLtv": "â‰ªÌ¸", "nmid": "âˆ¤", "NoBreak": "â ", "NonBreakingSpace": "Â ", "nopf": "ğ•Ÿ", "Nopf": "â„•", "not": "Â¬", "Not": "â«¬", "NotCongruent": "â‰¢", "NotCupCap": "â‰­", "NotDoubleVerticalBar": "âˆ¦", "NotElement": "âˆ‰", "NotEqual": "â‰ ", "NotEqualTilde": "â‰‚Ì¸", "NotExists": "âˆ„", "NotGreater": "â‰¯", "NotGreaterEqual": "â‰±", "NotGreaterFullEqual": "â‰§Ì¸", "NotGreaterGreater": "â‰«Ì¸", "NotGreaterLess": "â‰¹", "NotGreaterSlantEqual": "â©¾Ì¸", "NotGreaterTilde": "â‰µ", "NotHumpDownHump": "â‰Ì¸", "NotHumpEqual": "â‰Ì¸", "notin": "âˆ‰", "notindot": "â‹µÌ¸", "notinE": "â‹¹Ì¸", "notinva": "âˆ‰", "notinvb": "â‹·", "notinvc": "â‹¶", "NotLeftTriangle": "â‹ª", "NotLeftTriangleBar": "â§Ì¸", "NotLeftTriangleEqual": "â‹¬", "NotLess": "â‰®", "NotLessEqual": "â‰°", "NotLessGreater": "â‰¸", "NotLessLess": "â‰ªÌ¸", "NotLessSlantEqual": "â©½Ì¸", "NotLessTilde": "â‰´", "NotNestedGreaterGreater": "âª¢Ì¸", "NotNestedLessLess": "âª¡Ì¸", "notni": "âˆŒ", "notniva": "âˆŒ", "notnivb": "â‹¾", "notnivc": "â‹½", "NotPrecedes": "âŠ€", "NotPrecedesEqual": "âª¯Ì¸", "NotPrecedesSlantEqual": "â‹ ", "NotReverseElement": "âˆŒ", "NotRightTriangle": "â‹«", "NotRightTriangleBar": "â§Ì¸", "NotRightTriangleEqual": "â‹­", "NotSquareSubset": "âŠÌ¸", "NotSquareSubsetEqual": "â‹¢", "NotSquareSuperset": "âŠÌ¸", "NotSquareSupersetEqual": "â‹£", "NotSubset": "âŠ‚âƒ’", "NotSubsetEqual": "âŠˆ", "NotSucceeds": "âŠ", "NotSucceedsEqual": "âª°Ì¸", "NotSucceedsSlantEqual": "â‹¡", "NotSucceedsTilde": "â‰¿Ì¸", "NotSuperset": "âŠƒâƒ’", "NotSupersetEqual": "âŠ‰", "NotTilde": "â‰", "NotTildeEqual": "â‰„", "NotTildeFullEqual": "â‰‡", "NotTildeTilde": "â‰‰", "NotVerticalBar": "âˆ¤", "npar": "âˆ¦", "nparallel": "âˆ¦", "nparsl": "â«½âƒ¥", "npart": "âˆ‚Ì¸", "npolint": "â¨”", "npr": "âŠ€", "nprcue": "â‹ ", "npre": "âª¯Ì¸", "nprec": "âŠ€", "npreceq": "âª¯Ì¸", "nrarr": "â†›", "nrArr": "â‡", "nrarrc": "â¤³Ì¸", "nrarrw": "â†Ì¸", "nrightarrow": "â†›", "nRightarrow": "â‡", "nrtri": "â‹«", "nrtrie": "â‹­", "nsc": "âŠ", "nsccue": "â‹¡", "nsce": "âª°Ì¸", "nscr": "ğ“ƒ", "Nscr": "ğ’©", "nshortmid": "âˆ¤", "nshortparallel": "âˆ¦", "nsim": "â‰", "nsime": "â‰„", "nsimeq": "â‰„", "nsmid": "âˆ¤", "nspar": "âˆ¦", "nsqsube": "â‹¢", "nsqsupe": "â‹£", "nsub": "âŠ„", "nsube": "âŠˆ", "nsubE": "â«…Ì¸", "nsubset": "âŠ‚âƒ’", "nsubseteq": "âŠˆ", "nsubseteqq": "â«…Ì¸", "nsucc": "âŠ", "nsucceq": "âª°Ì¸", "nsup": "âŠ…", "nsupe": "âŠ‰", "nsupE": "â«†Ì¸", "nsupset": "âŠƒâƒ’", "nsupseteq": "âŠ‰", "nsupseteqq": "â«†Ì¸", "ntgl": "â‰¹", "ntilde": "Ã±", "Ntilde": "Ã‘", "ntlg": "â‰¸", "ntriangleleft": "â‹ª", "ntrianglelefteq": "â‹¬", "ntriangleright": "â‹«", "ntrianglerighteq": "â‹­", "nu": "Î½", "Nu": "Î", "num": "#", "numero": "â„–", "numsp": "â€‡", "nvap": "â‰âƒ’", "nvdash": "âŠ¬", "nvDash": "âŠ­", "nVdash": "âŠ®", "nVDash": "âŠ¯", "nvge": "â‰¥âƒ’", "nvgt": ">âƒ’", "nvHarr": "â¤„", "nvinfin": "â§", "nvlArr": "â¤‚", "nvle": "â‰¤âƒ’", "nvlt": "<âƒ’", "nvltrie": "âŠ´âƒ’", "nvrArr": "â¤ƒ", "nvrtrie": "âŠµâƒ’", "nvsim": "âˆ¼âƒ’", "nwarhk": "â¤£", "nwarr": "â†–", "nwArr": "â‡–", "nwarrow": "â†–", "nwnear": "â¤§", "oacute": "Ã³", "Oacute": "Ã“", "oast": "âŠ›", "ocir": "âŠš", "ocirc": "Ã´", "Ocirc": "Ã”", "ocy": "Ğ¾", "Ocy": "Ğ", "odash": "âŠ", "odblac": "Å‘", "Odblac": "Å", "odiv": "â¨¸", "odot": "âŠ™", "odsold": "â¦¼", "oelig": "Å“", "OElig": "Å’", "ofcir": "â¦¿", "ofr": "ğ”¬", "Ofr": "ğ”’", "ogon": "Ë›", "ograve": "Ã²", "Ograve": "Ã’", "ogt": "â§", "ohbar": "â¦µ", "ohm": "Î©", "oint": "âˆ®", "olarr": "â†º", "olcir": "â¦¾", "olcross": "â¦»", "oline": "â€¾", "olt": "â§€", "omacr": "Å", "Omacr": "ÅŒ", "omega": "Ï‰", "Omega": "Î©", "omicron": "Î¿", "Omicron": "ÎŸ", "omid": "â¦¶", "ominus": "âŠ–", "oopf": "ğ• ", "Oopf": "ğ•†", "opar": "â¦·", "OpenCurlyDoubleQuote": "â€œ", "OpenCurlyQuote": "â€˜", "operp": "â¦¹", "oplus": "âŠ•", "or": "âˆ¨", "Or": "â©”", "orarr": "â†»", "ord": "â©", "order": "â„´", "orderof": "â„´", "ordf": "Âª", "ordm": "Âº", "origof": "âŠ¶", "oror": "â©–", "orslope": "â©—", "orv": "â©›", "oS": "â“ˆ", "oscr": "â„´", "Oscr": "ğ’ª", "oslash": "Ã¸", "Oslash": "Ã˜", "osol": "âŠ˜", "otilde": "Ãµ", "Otilde": "Ã•", "otimes": "âŠ—", "Otimes": "â¨·", "otimesas": "â¨¶", "ouml": "Ã¶", "Ouml": "Ã–", "ovbar": "âŒ½", "OverBar": "â€¾", "OverBrace": "â", "OverBracket": "â´", "OverParenthesis": "âœ", "par": "âˆ¥", "para": "Â¶", "parallel": "âˆ¥", "parsim": "â«³", "parsl": "â«½", "part": "âˆ‚", "PartialD": "âˆ‚", "pcy": "Ğ¿", "Pcy": "ĞŸ", "percnt": "%", "period": ".", "permil": "â€°", "perp": "âŠ¥", "pertenk": "â€±", "pfr": "ğ”­", "Pfr": "ğ”“", "phi": "Ï†", "Phi": "Î¦", "phiv": "Ï•", "phmmat": "â„³", "phone": "â˜", "pi": "Ï€", "Pi": "Î ", "pitchfork": "â‹”", "piv": "Ï–", "planck": "â„", "planckh": "â„", "plankv": "â„", "plus": "+", "plusacir": "â¨£", "plusb": "âŠ", "pluscir": "â¨¢", "plusdo": "âˆ”", "plusdu": "â¨¥", "pluse": "â©²", "PlusMinus": "Â±", "plusmn": "Â±", "plussim": "â¨¦", "plustwo": "â¨§", "pm": "Â±", "Poincareplane": "â„Œ", "pointint": "â¨•", "popf": "ğ•¡", "Popf": "â„™", "pound": "Â£", "pr": "â‰º", "Pr": "âª»", "prap": "âª·", "prcue": "â‰¼", "pre": "âª¯", "prE": "âª³", "prec": "â‰º", "precapprox": "âª·", "preccurlyeq": "â‰¼", "Precedes": "â‰º", "PrecedesEqual": "âª¯", "PrecedesSlantEqual": "â‰¼", "PrecedesTilde": "â‰¾", "preceq": "âª¯", "precnapprox": "âª¹", "precneqq": "âªµ", "precnsim": "â‹¨", "precsim": "â‰¾", "prime": "â€²", "Prime": "â€³", "primes": "â„™", "prnap": "âª¹", "prnE": "âªµ", "prnsim": "â‹¨", "prod": "âˆ", "Product": "âˆ", "profalar": "âŒ®", "profline": "âŒ’", "profsurf": "âŒ“", "prop": "âˆ", "Proportion": "âˆ·", "Proportional": "âˆ", "propto": "âˆ", "prsim": "â‰¾", "prurel": "âŠ°", "pscr": "ğ“…", "Pscr": "ğ’«", "psi": "Ïˆ", "Psi": "Î¨", "puncsp": "â€ˆ", "qfr": "ğ”®", "Qfr": "ğ””", "qint": "â¨Œ", "qopf": "ğ•¢", "Qopf": "â„š", "qprime": "â—", "qscr": "ğ“†", "Qscr": "ğ’¬", "quaternions": "â„", "quatint": "â¨–", "quest": "?", "questeq": "â‰Ÿ", "quot": '"', "QUOT": '"', "rAarr": "â‡›", "race": "âˆ½Ì±", "racute": "Å•", "Racute": "Å”", "radic": "âˆš", "raemptyv": "â¦³", "rang": "âŸ©", "Rang": "âŸ«", "rangd": "â¦’", "range": "â¦¥", "rangle": "âŸ©", "raquo": "Â»", "rarr": "â†’", "rArr": "â‡’", "Rarr": "â† ", "rarrap": "â¥µ", "rarrb": "â‡¥", "rarrbfs": "â¤ ", "rarrc": "â¤³", "rarrfs": "â¤", "rarrhk": "â†ª", "rarrlp": "â†¬", "rarrpl": "â¥…", "rarrsim": "â¥´", "rarrtl": "â†£", "Rarrtl": "â¤–", "rarrw": "â†", "ratail": "â¤š", "rAtail": "â¤œ", "ratio": "âˆ¶", "rationals": "â„š", "rbarr": "â¤", "rBarr": "â¤", "RBarr": "â¤", "rbbrk": "â³", "rbrace": "}", "rbrack": "]", "rbrke": "â¦Œ", "rbrksld": "â¦", "rbrkslu": "â¦", "rcaron": "Å™", "Rcaron": "Å˜", "rcedil": "Å—", "Rcedil": "Å–", "rceil": "âŒ‰", "rcub": "}", "rcy": "Ñ€", "Rcy": "Ğ ", "rdca": "â¤·", "rdldhar": "â¥©", "rdquo": "â€", "rdquor": "â€", "rdsh": "â†³", "Re": "â„œ", "real": "â„œ", "realine": "â„›", "realpart": "â„œ", "reals": "â„", "rect": "â–­", "reg": "Â®", "REG": "Â®", "ReverseElement": "âˆ‹", "ReverseEquilibrium": "â‡‹", "ReverseUpEquilibrium": "â¥¯", "rfisht": "â¥½", "rfloor": "âŒ‹", "rfr": "ğ”¯", "Rfr": "â„œ", "rHar": "â¥¤", "rhard": "â‡", "rharu": "â‡€", "rharul": "â¥¬", "rho": "Ï", "Rho": "Î¡", "rhov": "Ï±", "RightAngleBracket": "âŸ©", "rightarrow": "â†’", "Rightarrow": "â‡’", "RightArrow": "â†’", "RightArrowBar": "â‡¥", "RightArrowLeftArrow": "â‡„", "rightarrowtail": "â†£", "RightCeiling": "âŒ‰", "RightDoubleBracket": "âŸ§", "RightDownTeeVector": "â¥", "RightDownVector": "â‡‚", "RightDownVectorBar": "â¥•", "RightFloor": "âŒ‹", "rightharpoondown": "â‡", "rightharpoonup": "â‡€", "rightleftarrows": "â‡„", "rightleftharpoons": "â‡Œ", "rightrightarrows": "â‡‰", "rightsquigarrow": "â†", "RightTee": "âŠ¢", "RightTeeArrow": "â†¦", "RightTeeVector": "â¥›", "rightthreetimes": "â‹Œ", "RightTriangle": "âŠ³", "RightTriangleBar": "â§", "RightTriangleEqual": "âŠµ", "RightUpDownVector": "â¥", "RightUpTeeVector": "â¥œ", "RightUpVector": "â†¾", "RightUpVectorBar": "â¥”", "RightVector": "â‡€", "RightVectorBar": "â¥“", "ring": "Ëš", "risingdotseq": "â‰“", "rlarr": "â‡„", "rlhar": "â‡Œ", "rlm": "â€", "rmoust": "â±", "rmoustache": "â±", "rnmid": "â«®", "roang": "âŸ­", "roarr": "â‡¾", "robrk": "âŸ§", "ropar": "â¦†", "ropf": "ğ•£", "Ropf": "â„", "roplus": "â¨®", "rotimes": "â¨µ", "RoundImplies": "â¥°", "rpar": ")", "rpargt": "â¦”", "rppolint": "â¨’", "rrarr": "â‡‰", "Rrightarrow": "â‡›", "rsaquo": "â€º", "rscr": "ğ“‡", "Rscr": "â„›", "rsh": "â†±", "Rsh": "â†±", "rsqb": "]", "rsquo": "â€™", "rsquor": "â€™", "rthree": "â‹Œ", "rtimes": "â‹Š", "rtri": "â–¹", "rtrie": "âŠµ", "rtrif": "â–¸", "rtriltri": "â§", "RuleDelayed": "â§´", "ruluhar": "â¥¨", "rx": "â„", "sacute": "Å›", "Sacute": "Åš", "sbquo": "â€š", "sc": "â‰»", "Sc": "âª¼", "scap": "âª¸", "scaron": "Å¡", "Scaron": "Å ", "sccue": "â‰½", "sce": "âª°", "scE": "âª´", "scedil": "ÅŸ", "Scedil": "Å", "scirc": "Å", "Scirc": "Åœ", "scnap": "âªº", "scnE": "âª¶", "scnsim": "â‹©", "scpolint": "â¨“", "scsim": "â‰¿", "scy": "Ñ", "Scy": "Ğ¡", "sdot": "â‹…", "sdotb": "âŠ¡", "sdote": "â©¦", "searhk": "â¤¥", "searr": "â†˜", "seArr": "â‡˜", "searrow": "â†˜", "sect": "Â§", "semi": ";", "seswar": "â¤©", "setminus": "âˆ–", "setmn": "âˆ–", "sext": "âœ¶", "sfr": "ğ”°", "Sfr": "ğ”–", "sfrown": "âŒ¢", "sharp": "â™¯", "shchcy": "Ñ‰", "SHCHcy": "Ğ©", "shcy": "Ñˆ", "SHcy": "Ğ¨", "ShortDownArrow": "â†“", "ShortLeftArrow": "â†", "shortmid": "âˆ£", "shortparallel": "âˆ¥", "ShortRightArrow": "â†’", "ShortUpArrow": "â†‘", "shy": "Â­", "sigma": "Ïƒ", "Sigma": "Î£", "sigmaf": "Ï‚", "sigmav": "Ï‚", "sim": "âˆ¼", "simdot": "â©ª", "sime": "â‰ƒ", "simeq": "â‰ƒ", "simg": "âª", "simgE": "âª ", "siml": "âª", "simlE": "âªŸ", "simne": "â‰†", "simplus": "â¨¤", "simrarr": "â¥²", "slarr": "â†", "SmallCircle": "âˆ˜", "smallsetminus": "âˆ–", "smashp": "â¨³", "smeparsl": "â§¤", "smid": "âˆ£", "smile": "âŒ£", "smt": "âªª", "smte": "âª¬", "smtes": "âª¬ï¸€", "softcy": "ÑŒ", "SOFTcy": "Ğ¬", "sol": "/", "solb": "â§„", "solbar": "âŒ¿", "sopf": "ğ•¤", "Sopf": "ğ•Š", "spades": "â™ ", "spadesuit": "â™ ", "spar": "âˆ¥", "sqcap": "âŠ“", "sqcaps": "âŠ“ï¸€", "sqcup": "âŠ”", "sqcups": "âŠ”ï¸€", "Sqrt": "âˆš", "sqsub": "âŠ", "sqsube": "âŠ‘", "sqsubset": "âŠ", "sqsubseteq": "âŠ‘", "sqsup": "âŠ", "sqsupe": "âŠ’", "sqsupset": "âŠ", "sqsupseteq": "âŠ’", "squ": "â–¡", "square": "â–¡", "Square": "â–¡", "SquareIntersection": "âŠ“", "SquareSubset": "âŠ", "SquareSubsetEqual": "âŠ‘", "SquareSuperset": "âŠ", "SquareSupersetEqual": "âŠ’", "SquareUnion": "âŠ”", "squarf": "â–ª", "squf": "â–ª", "srarr": "â†’", "sscr": "ğ“ˆ", "Sscr": "ğ’®", "ssetmn": "âˆ–", "ssmile": "âŒ£", "sstarf": "â‹†", "star": "â˜†", "Star": "â‹†", "starf": "â˜…", "straightepsilon": "Ïµ", "straightphi": "Ï•", "strns": "Â¯", "sub": "âŠ‚", "Sub": "â‹", "subdot": "âª½", "sube": "âŠ†", "subE": "â«…", "subedot": "â«ƒ", "submult": "â«", "subne": "âŠŠ", "subnE": "â«‹", "subplus": "âª¿", "subrarr": "â¥¹", "subset": "âŠ‚", "Subset": "â‹", "subseteq": "âŠ†", "subseteqq": "â«…", "SubsetEqual": "âŠ†", "subsetneq": "âŠŠ", "subsetneqq": "â«‹", "subsim": "â«‡", "subsub": "â«•", "subsup": "â«“", "succ": "â‰»", "succapprox": "âª¸", "succcurlyeq": "â‰½", "Succeeds": "â‰»", "SucceedsEqual": "âª°", "SucceedsSlantEqual": "â‰½", "SucceedsTilde": "â‰¿", "succeq": "âª°", "succnapprox": "âªº", "succneqq": "âª¶", "succnsim": "â‹©", "succsim": "â‰¿", "SuchThat": "âˆ‹", "sum": "âˆ‘", "Sum": "âˆ‘", "sung": "â™ª", "sup": "âŠƒ", "Sup": "â‹‘", "sup1": "Â¹", "sup2": "Â²", "sup3": "Â³", "supdot": "âª¾", "supdsub": "â«˜", "supe": "âŠ‡", "supE": "â«†", "supedot": "â«„", "Superset": "âŠƒ", "SupersetEqual": "âŠ‡", "suphsol": "âŸ‰", "suphsub": "â«—", "suplarr": "â¥»", "supmult": "â«‚", "supne": "âŠ‹", "supnE": "â«Œ", "supplus": "â«€", "supset": "âŠƒ", "Supset": "â‹‘", "supseteq": "âŠ‡", "supseteqq": "â«†", "supsetneq": "âŠ‹", "supsetneqq": "â«Œ", "supsim": "â«ˆ", "supsub": "â«”", "supsup": "â«–", "swarhk": "â¤¦", "swarr": "â†™", "swArr": "â‡™", "swarrow": "â†™", "swnwar": "â¤ª", "szlig": "ÃŸ", "Tab": "	", "target": "âŒ–", "tau": "Ï„", "Tau": "Î¤", "tbrk": "â´", "tcaron": "Å¥", "Tcaron": "Å¤", "tcedil": "Å£", "Tcedil": "Å¢", "tcy": "Ñ‚", "Tcy": "Ğ¢", "tdot": "âƒ›", "telrec": "âŒ•", "tfr": "ğ”±", "Tfr": "ğ”—", "there4": "âˆ´", "therefore": "âˆ´", "Therefore": "âˆ´", "theta": "Î¸", "Theta": "Î˜", "thetasym": "Ï‘", "thetav": "Ï‘", "thickapprox": "â‰ˆ", "thicksim": "âˆ¼", "ThickSpace": "âŸâ€Š", "thinsp": "â€‰", "ThinSpace": "â€‰", "thkap": "â‰ˆ", "thksim": "âˆ¼", "thorn": "Ã¾", "THORN": "Ã", "tilde": "Ëœ", "Tilde": "âˆ¼", "TildeEqual": "â‰ƒ", "TildeFullEqual": "â‰…", "TildeTilde": "â‰ˆ", "times": "Ã—", "timesb": "âŠ ", "timesbar": "â¨±", "timesd": "â¨°", "tint": "âˆ­", "toea": "â¤¨", "top": "âŠ¤", "topbot": "âŒ¶", "topcir": "â«±", "topf": "ğ•¥", "Topf": "ğ•‹", "topfork": "â«š", "tosa": "â¤©", "tprime": "â€´", "trade": "â„¢", "TRADE": "â„¢", "triangle": "â–µ", "triangledown": "â–¿", "triangleleft": "â—ƒ", "trianglelefteq": "âŠ´", "triangleq": "â‰œ", "triangleright": "â–¹", "trianglerighteq": "âŠµ", "tridot": "â—¬", "trie": "â‰œ", "triminus": "â¨º", "TripleDot": "âƒ›", "triplus": "â¨¹", "trisb": "â§", "tritime": "â¨»", "trpezium": "â¢", "tscr": "ğ“‰", "Tscr": "ğ’¯", "tscy": "Ñ†", "TScy": "Ğ¦", "tshcy": "Ñ›", "TSHcy": "Ğ‹", "tstrok": "Å§", "Tstrok": "Å¦", "twixt": "â‰¬", "twoheadleftarrow": "â†", "twoheadrightarrow": "â† ", "uacute": "Ãº", "Uacute": "Ãš", "uarr": "â†‘", "uArr": "â‡‘", "Uarr": "â†Ÿ", "Uarrocir": "â¥‰", "ubrcy": "Ñ", "Ubrcy": "Ğ", "ubreve": "Å­", "Ubreve": "Å¬", "ucirc": "Ã»", "Ucirc": "Ã›", "ucy": "Ñƒ", "Ucy": "Ğ£", "udarr": "â‡…", "udblac": "Å±", "Udblac": "Å°", "udhar": "â¥®", "ufisht": "â¥¾", "ufr": "ğ”²", "Ufr": "ğ”˜", "ugrave": "Ã¹", "Ugrave": "Ã™", "uHar": "â¥£", "uharl": "â†¿", "uharr": "â†¾", "uhblk": "â–€", "ulcorn": "âŒœ", "ulcorner": "âŒœ", "ulcrop": "âŒ", "ultri": "â—¸", "umacr": "Å«", "Umacr": "Åª", "uml": "Â¨", "UnderBar": "_", "UnderBrace": "âŸ", "UnderBracket": "âµ", "UnderParenthesis": "â", "Union": "â‹ƒ", "UnionPlus": "âŠ", "uogon": "Å³", "Uogon": "Å²", "uopf": "ğ•¦", "Uopf": "ğ•Œ", "uparrow": "â†‘", "Uparrow": "â‡‘", "UpArrow": "â†‘", "UpArrowBar": "â¤’", "UpArrowDownArrow": "â‡…", "updownarrow": "â†•", "Updownarrow": "â‡•", "UpDownArrow": "â†•", "UpEquilibrium": "â¥®", "upharpoonleft": "â†¿", "upharpoonright": "â†¾", "uplus": "âŠ", "UpperLeftArrow": "â†–", "UpperRightArrow": "â†—", "upsi": "Ï…", "Upsi": "Ï’", "upsih": "Ï’", "upsilon": "Ï…", "Upsilon": "Î¥", "UpTee": "âŠ¥", "UpTeeArrow": "â†¥", "upuparrows": "â‡ˆ", "urcorn": "âŒ", "urcorner": "âŒ", "urcrop": "âŒ", "uring": "Å¯", "Uring": "Å®", "urtri": "â—¹", "uscr": "ğ“Š", "Uscr": "ğ’°", "utdot": "â‹°", "utilde": "Å©", "Utilde": "Å¨", "utri": "â–µ", "utrif": "â–´", "uuarr": "â‡ˆ", "uuml": "Ã¼", "Uuml": "Ãœ", "uwangle": "â¦§", "vangrt": "â¦œ", "varepsilon": "Ïµ", "varkappa": "Ï°", "varnothing": "âˆ…", "varphi": "Ï•", "varpi": "Ï–", "varpropto": "âˆ", "varr": "â†•", "vArr": "â‡•", "varrho": "Ï±", "varsigma": "Ï‚", "varsubsetneq": "âŠŠï¸€", "varsubsetneqq": "â«‹ï¸€", "varsupsetneq": "âŠ‹ï¸€", "varsupsetneqq": "â«Œï¸€", "vartheta": "Ï‘", "vartriangleleft": "âŠ²", "vartriangleright": "âŠ³", "vBar": "â«¨", "Vbar": "â««", "vBarv": "â«©", "vcy": "Ğ²", "Vcy": "Ğ’", "vdash": "âŠ¢", "vDash": "âŠ¨", "Vdash": "âŠ©", "VDash": "âŠ«", "Vdashl": "â«¦", "vee": "âˆ¨", "Vee": "â‹", "veebar": "âŠ»", "veeeq": "â‰š", "vellip": "â‹®", "verbar": "|", "Verbar": "â€–", "vert": "|", "Vert": "â€–", "VerticalBar": "âˆ£", "VerticalLine": "|", "VerticalSeparator": "â˜", "VerticalTilde": "â‰€", "VeryThinSpace": "â€Š", "vfr": "ğ”³", "Vfr": "ğ”™", "vltri": "âŠ²", "vnsub": "âŠ‚âƒ’", "vnsup": "âŠƒâƒ’", "vopf": "ğ•§", "Vopf": "ğ•", "vprop": "âˆ", "vrtri": "âŠ³", "vscr": "ğ“‹", "Vscr": "ğ’±", "vsubne": "âŠŠï¸€", "vsubnE": "â«‹ï¸€", "vsupne": "âŠ‹ï¸€", "vsupnE": "â«Œï¸€", "Vvdash": "âŠª", "vzigzag": "â¦š", "wcirc": "Åµ", "Wcirc": "Å´", "wedbar": "â©Ÿ", "wedge": "âˆ§", "Wedge": "â‹€", "wedgeq": "â‰™", "weierp": "â„˜", "wfr": "ğ”´", "Wfr": "ğ”š", "wopf": "ğ•¨", "Wopf": "ğ•", "wp": "â„˜", "wr": "â‰€", "wreath": "â‰€", "wscr": "ğ“Œ", "Wscr": "ğ’²", "xcap": "â‹‚", "xcirc": "â—¯", "xcup": "â‹ƒ", "xdtri": "â–½", "xfr": "ğ”µ", "Xfr": "ğ”›", "xharr": "âŸ·", "xhArr": "âŸº", "xi": "Î¾", "Xi": "Î", "xlarr": "âŸµ", "xlArr": "âŸ¸", "xmap": "âŸ¼", "xnis": "â‹»", "xodot": "â¨€", "xopf": "ğ•©", "Xopf": "ğ•", "xoplus": "â¨", "xotime": "â¨‚", "xrarr": "âŸ¶", "xrArr": "âŸ¹", "xscr": "ğ“", "Xscr": "ğ’³", "xsqcup": "â¨†", "xuplus": "â¨„", "xutri": "â–³", "xvee": "â‹", "xwedge": "â‹€", "yacute": "Ã½", "Yacute": "Ã", "yacy": "Ñ", "YAcy": "Ğ¯", "ycirc": "Å·", "Ycirc": "Å¶", "ycy": "Ñ‹", "Ycy": "Ğ«", "yen": "Â¥", "yfr": "ğ”¶", "Yfr": "ğ”œ", "yicy": "Ñ—", "YIcy": "Ğ‡", "yopf": "ğ•ª", "Yopf": "ğ•", "yscr": "ğ“", "Yscr": "ğ’´", "yucy": "Ñ", "YUcy": "Ğ®", "yuml": "Ã¿", "Yuml": "Å¸", "zacute": "Åº", "Zacute": "Å¹", "zcaron": "Å¾", "Zcaron": "Å½", "zcy": "Ğ·", "Zcy": "Ğ—", "zdot": "Å¼", "Zdot": "Å»", "zeetrf": "â„¨", "ZeroWidthSpace": "â€‹", "zeta": "Î¶", "Zeta": "Î–", "zfr": "ğ”·", "Zfr": "â„¨", "zhcy": "Ğ¶", "ZHcy": "Ğ–", "zigrarr": "â‡", "zopf": "ğ•«", "Zopf": "â„¤", "zscr": "ğ“", "Zscr": "ğ’µ", "zwj": "â€", "zwnj": "â€Œ" };
      var decodeMapLegacy = { "aacute": "Ã¡", "Aacute": "Ã", "acirc": "Ã¢", "Acirc": "Ã‚", "acute": "Â´", "aelig": "Ã¦", "AElig": "Ã†", "agrave": "Ã ", "Agrave": "Ã€", "amp": "&", "AMP": "&", "aring": "Ã¥", "Aring": "Ã…", "atilde": "Ã£", "Atilde": "Ãƒ", "auml": "Ã¤", "Auml": "Ã„", "brvbar": "Â¦", "ccedil": "Ã§", "Ccedil": "Ã‡", "cedil": "Â¸", "cent": "Â¢", "copy": "Â©", "COPY": "Â©", "curren": "Â¤", "deg": "Â°", "divide": "Ã·", "eacute": "Ã©", "Eacute": "Ã‰", "ecirc": "Ãª", "Ecirc": "ÃŠ", "egrave": "Ã¨", "Egrave": "Ãˆ", "eth": "Ã°", "ETH": "Ã", "euml": "Ã«", "Euml": "Ã‹", "frac12": "Â½", "frac14": "Â¼", "frac34": "Â¾", "gt": ">", "GT": ">", "iacute": "Ã­", "Iacute": "Ã", "icirc": "Ã®", "Icirc": "Ã", "iexcl": "Â¡", "igrave": "Ã¬", "Igrave": "ÃŒ", "iquest": "Â¿", "iuml": "Ã¯", "Iuml": "Ã", "laquo": "Â«", "lt": "<", "LT": "<", "macr": "Â¯", "micro": "Âµ", "middot": "Â·", "nbsp": "Â ", "not": "Â¬", "ntilde": "Ã±", "Ntilde": "Ã‘", "oacute": "Ã³", "Oacute": "Ã“", "ocirc": "Ã´", "Ocirc": "Ã”", "ograve": "Ã²", "Ograve": "Ã’", "ordf": "Âª", "ordm": "Âº", "oslash": "Ã¸", "Oslash": "Ã˜", "otilde": "Ãµ", "Otilde": "Ã•", "ouml": "Ã¶", "Ouml": "Ã–", "para": "Â¶", "plusmn": "Â±", "pound": "Â£", "quot": '"', "QUOT": '"', "raquo": "Â»", "reg": "Â®", "REG": "Â®", "sect": "Â§", "shy": "Â­", "sup1": "Â¹", "sup2": "Â²", "sup3": "Â³", "szlig": "ÃŸ", "thorn": "Ã¾", "THORN": "Ã", "times": "Ã—", "uacute": "Ãº", "Uacute": "Ãš", "ucirc": "Ã»", "Ucirc": "Ã›", "ugrave": "Ã¹", "Ugrave": "Ã™", "uml": "Â¨", "uuml": "Ã¼", "Uuml": "Ãœ", "yacute": "Ã½", "Yacute": "Ã", "yen": "Â¥", "yuml": "Ã¿" };
      var decodeMapNumeric = { "0": "ï¿½", "128": "â‚¬", "130": "â€š", "131": "Æ’", "132": "â€", "133": "â€¦", "134": "â€ ", "135": "â€¡", "136": "Ë†", "137": "â€°", "138": "Å ", "139": "â€¹", "140": "Å’", "142": "Å½", "145": "â€˜", "146": "â€™", "147": "â€œ", "148": "â€", "149": "â€¢", "150": "â€“", "151": "â€”", "152": "Ëœ", "153": "â„¢", "154": "Å¡", "155": "â€º", "156": "Å“", "158": "Å¾", "159": "Å¸" };
      var invalidReferenceCodePoints = [1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 64976, 64977, 64978, 64979, 64980, 64981, 64982, 64983, 64984, 64985, 64986, 64987, 64988, 64989, 64990, 64991, 64992, 64993, 64994, 64995, 64996, 64997, 64998, 64999, 65e3, 65001, 65002, 65003, 65004, 65005, 65006, 65007, 65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111];
      var stringFromCharCode = String.fromCharCode;
      var object = {};
      var hasOwnProperty2 = object.hasOwnProperty;
      var has = function(object2, propertyName) {
        return hasOwnProperty2.call(object2, propertyName);
      };
      var contains = function(array, value) {
        var index = -1;
        var length = array.length;
        while (++index < length) {
          if (array[index] == value) {
            return true;
          }
        }
        return false;
      };
      var merge = function(options, defaults) {
        if (!options) {
          return defaults;
        }
        var result = {};
        var key2;
        for (key2 in defaults) {
          result[key2] = has(options, key2) ? options[key2] : defaults[key2];
        }
        return result;
      };
      var codePointToSymbol = function(codePoint, strict) {
        var output = "";
        if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
          if (strict) {
            parseError("character reference outside the permissible Unicode range");
          }
          return "ï¿½";
        }
        if (has(decodeMapNumeric, codePoint)) {
          if (strict) {
            parseError("disallowed character reference");
          }
          return decodeMapNumeric[codePoint];
        }
        if (strict && contains(invalidReferenceCodePoints, codePoint)) {
          parseError("disallowed character reference");
        }
        if (codePoint > 65535) {
          codePoint -= 65536;
          output += stringFromCharCode(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        output += stringFromCharCode(codePoint);
        return output;
      };
      var hexEscape = function(codePoint) {
        return "&#x" + codePoint.toString(16).toUpperCase() + ";";
      };
      var decEscape = function(codePoint) {
        return "&#" + codePoint + ";";
      };
      var parseError = function(message) {
        throw Error("Parse error: " + message);
      };
      var encode = function(string, options) {
        options = merge(options, encode.options);
        var strict = options.strict;
        if (strict && regexInvalidRawCodePoint.test(string)) {
          parseError("forbidden code point");
        }
        var encodeEverything = options.encodeEverything;
        var useNamedReferences = options.useNamedReferences;
        var allowUnsafeSymbols = options.allowUnsafeSymbols;
        var escapeCodePoint = options.decimal ? decEscape : hexEscape;
        var escapeBmpSymbol = function(symbol) {
          return escapeCodePoint(symbol.charCodeAt(0));
        };
        if (encodeEverything) {
          string = string.replace(regexAsciiWhitelist, function(symbol) {
            if (useNamedReferences && has(encodeMap, symbol)) {
              return "&" + encodeMap[symbol] + ";";
            }
            return escapeBmpSymbol(symbol);
          });
          if (useNamedReferences) {
            string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;").replace(/&#x66;&#x6A;/g, "&fjlig;");
          }
          if (useNamedReferences) {
            string = string.replace(regexEncodeNonAscii, function(string2) {
              return "&" + encodeMap[string2] + ";";
            });
          }
        } else if (useNamedReferences) {
          if (!allowUnsafeSymbols) {
            string = string.replace(regexEscape, function(string2) {
              return "&" + encodeMap[string2] + ";";
            });
          }
          string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;");
          string = string.replace(regexEncodeNonAscii, function(string2) {
            return "&" + encodeMap[string2] + ";";
          });
        } else if (!allowUnsafeSymbols) {
          string = string.replace(regexEscape, escapeBmpSymbol);
        }
        return string.replace(regexAstralSymbols, function($02) {
          var high = $02.charCodeAt(0);
          var low = $02.charCodeAt(1);
          var codePoint = (high - 55296) * 1024 + low - 56320 + 65536;
          return escapeCodePoint(codePoint);
        }).replace(regexBmpWhitelist, escapeBmpSymbol);
      };
      encode.options = {
        "allowUnsafeSymbols": false,
        "encodeEverything": false,
        "strict": false,
        "useNamedReferences": false,
        "decimal": false
      };
      var decode = function(html, options) {
        options = merge(options, decode.options);
        var strict = options.strict;
        if (strict && regexInvalidEntity.test(html)) {
          parseError("malformed character reference");
        }
        return html.replace(regexDecode, function($02, $1, $2, $3, $4, $5, $6, $7, $8) {
          var codePoint;
          var semicolon;
          var decDigits;
          var hexDigits;
          var reference;
          var next;
          if ($1) {
            reference = $1;
            return decodeMap[reference];
          }
          if ($2) {
            reference = $2;
            next = $3;
            if (next && options.isAttributeValue) {
              if (strict && next == "=") {
                parseError("`&` did not start a character reference");
              }
              return $02;
            } else {
              if (strict) {
                parseError(
                  "named character reference was not terminated by a semicolon"
                );
              }
              return decodeMapLegacy[reference] + (next || "");
            }
          }
          if ($4) {
            decDigits = $4;
            semicolon = $5;
            if (strict && !semicolon) {
              parseError("character reference was not terminated by a semicolon");
            }
            codePoint = parseInt(decDigits, 10);
            return codePointToSymbol(codePoint, strict);
          }
          if ($6) {
            hexDigits = $6;
            semicolon = $7;
            if (strict && !semicolon) {
              parseError("character reference was not terminated by a semicolon");
            }
            codePoint = parseInt(hexDigits, 16);
            return codePointToSymbol(codePoint, strict);
          }
          if (strict) {
            parseError(
              "named character reference was not terminated by a semicolon"
            );
          }
          return $02;
        });
      };
      decode.options = {
        "isAttributeValue": false,
        "strict": false
      };
      var escape = function(string) {
        return string.replace(regexEscape, function($02) {
          return escapeMap[$02];
        });
      };
      var he3 = {
        "version": "1.2.0",
        "encode": encode,
        "decode": decode,
        "escape": escape,
        "unescape": decode
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define(function() {
          return he3;
        });
      } else if (freeExports && !freeExports.nodeType) {
        if (freeModule) {
          freeModule.exports = he3;
        } else {
          for (var key in he3) {
            has(he3, key) && (freeExports[key] = he3[key]);
          }
        }
      } else {
        root.he = he3;
      }
    })(exports);
  }
});

// node_modules/node-html-parser/dist/nodes/node.js
var require_node = __commonJS({
  "node_modules/node-html-parser/dist/nodes/node.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var he_1 = require_he();
    var Node2 = (
      /** @class */
      function() {
        function Node3(parentNode, range) {
          if (parentNode === void 0) {
            parentNode = null;
          }
          this.parentNode = parentNode;
          this.childNodes = [];
          Object.defineProperty(this, "range", {
            enumerable: false,
            writable: true,
            configurable: true,
            value: range !== null && range !== void 0 ? range : [-1, -1]
          });
        }
        Node3.prototype.remove = function() {
          var _this = this;
          if (this.parentNode) {
            var children = this.parentNode.childNodes;
            this.parentNode.childNodes = children.filter(function(child) {
              return _this !== child;
            });
            this.parentNode = null;
          }
          return this;
        };
        Object.defineProperty(Node3.prototype, "innerText", {
          get: function() {
            return this.rawText;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node3.prototype, "textContent", {
          get: function() {
            return (0, he_1.decode)(this.rawText);
          },
          set: function(val) {
            this.rawText = (0, he_1.encode)(val);
          },
          enumerable: false,
          configurable: true
        });
        return Node3;
      }()
    );
    exports.default = Node2;
  }
});

// node_modules/node-html-parser/dist/nodes/type.js
var require_type = __commonJS({
  "node_modules/node-html-parser/dist/nodes/type.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NodeType2;
    (function(NodeType3) {
      NodeType3[NodeType3["ELEMENT_NODE"] = 1] = "ELEMENT_NODE";
      NodeType3[NodeType3["TEXT_NODE"] = 3] = "TEXT_NODE";
      NodeType3[NodeType3["COMMENT_NODE"] = 8] = "COMMENT_NODE";
    })(NodeType2 || (NodeType2 = {}));
    exports.default = NodeType2;
  }
});

// node_modules/node-html-parser/dist/nodes/comment.js
var require_comment = __commonJS({
  "node_modules/node-html-parser/dist/nodes/comment.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d2, b3) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b4) {
          d3.__proto__ = b4;
        } || function(d3, b4) {
          for (var p2 in b4)
            if (Object.prototype.hasOwnProperty.call(b4, p2))
              d3[p2] = b4[p2];
        };
        return extendStatics(d2, b3);
      };
      return function(d2, b3) {
        if (typeof b3 !== "function" && b3 !== null)
          throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
        extendStatics(d2, b3);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var node_1 = __importDefault(require_node());
    var type_1 = __importDefault(require_type());
    var CommentNode = (
      /** @class */
      function(_super) {
        __extends(CommentNode2, _super);
        function CommentNode2(rawText, parentNode, range, rawTagName) {
          if (parentNode === void 0) {
            parentNode = null;
          }
          if (rawTagName === void 0) {
            rawTagName = "!--";
          }
          var _this = _super.call(this, parentNode, range) || this;
          _this.rawText = rawText;
          _this.rawTagName = rawTagName;
          _this.nodeType = type_1.default.COMMENT_NODE;
          return _this;
        }
        CommentNode2.prototype.clone = function() {
          return new CommentNode2(this.rawText, null, void 0, this.rawTagName);
        };
        Object.defineProperty(CommentNode2.prototype, "text", {
          /**
           * Get unescaped text value of current node and its children.
           * @return {string} text content
           */
          get: function() {
            return this.rawText;
          },
          enumerable: false,
          configurable: true
        });
        CommentNode2.prototype.toString = function() {
          return "<!--".concat(this.rawText, "-->");
        };
        return CommentNode2;
      }(node_1.default)
    );
    exports.default = CommentNode;
  }
});

// node_modules/domelementtype/lib/index.js
var require_lib = __commonJS({
  "node_modules/domelementtype/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;
    var ElementType2;
    (function(ElementType3) {
      ElementType3["Root"] = "root";
      ElementType3["Text"] = "text";
      ElementType3["Directive"] = "directive";
      ElementType3["Comment"] = "comment";
      ElementType3["Script"] = "script";
      ElementType3["Style"] = "style";
      ElementType3["Tag"] = "tag";
      ElementType3["CDATA"] = "cdata";
      ElementType3["Doctype"] = "doctype";
    })(ElementType2 = exports.ElementType || (exports.ElementType = {}));
    function isTag(elem) {
      return elem.type === ElementType2.Tag || elem.type === ElementType2.Script || elem.type === ElementType2.Style;
    }
    exports.isTag = isTag;
    exports.Root = ElementType2.Root;
    exports.Text = ElementType2.Text;
    exports.Directive = ElementType2.Directive;
    exports.Comment = ElementType2.Comment;
    exports.Script = ElementType2.Script;
    exports.Style = ElementType2.Style;
    exports.Tag = ElementType2.Tag;
    exports.CDATA = ElementType2.CDATA;
    exports.Doctype = ElementType2.Doctype;
  }
});

// node_modules/domhandler/lib/node.js
var require_node2 = __commonJS({
  "node_modules/domhandler/lib/node.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d2, b3) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b4) {
          d3.__proto__ = b4;
        } || function(d3, b4) {
          for (var p2 in b4)
            if (Object.prototype.hasOwnProperty.call(b4, p2))
              d3[p2] = b4[p2];
        };
        return extendStatics(d2, b3);
      };
      return function(d2, b3) {
        if (typeof b3 !== "function" && b3 !== null)
          throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
        extendStatics(d2, b3);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cloneNode = exports.hasChildren = exports.isDocument = exports.isDirective = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = exports.Element = exports.Document = exports.CDATA = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = void 0;
    var domelementtype_1 = require_lib();
    var Node2 = (
      /** @class */
      function() {
        function Node3() {
          this.parent = null;
          this.prev = null;
          this.next = null;
          this.startIndex = null;
          this.endIndex = null;
        }
        Object.defineProperty(Node3.prototype, "parentNode", {
          // Read-write aliases for properties
          /**
           * Same as {@link parent}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.parent;
          },
          set: function(parent) {
            this.parent = parent;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node3.prototype, "previousSibling", {
          /**
           * Same as {@link prev}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.prev;
          },
          set: function(prev) {
            this.prev = prev;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node3.prototype, "nextSibling", {
          /**
           * Same as {@link next}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.next;
          },
          set: function(next) {
            this.next = next;
          },
          enumerable: false,
          configurable: true
        });
        Node3.prototype.cloneNode = function(recursive) {
          if (recursive === void 0) {
            recursive = false;
          }
          return cloneNode(this, recursive);
        };
        return Node3;
      }()
    );
    exports.Node = Node2;
    var DataNode = (
      /** @class */
      function(_super) {
        __extends(DataNode2, _super);
        function DataNode2(data) {
          var _this = _super.call(this) || this;
          _this.data = data;
          return _this;
        }
        Object.defineProperty(DataNode2.prototype, "nodeValue", {
          /**
           * Same as {@link data}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.data;
          },
          set: function(data) {
            this.data = data;
          },
          enumerable: false,
          configurable: true
        });
        return DataNode2;
      }(Node2)
    );
    exports.DataNode = DataNode;
    var Text2 = (
      /** @class */
      function(_super) {
        __extends(Text3, _super);
        function Text3() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Text;
          return _this;
        }
        Object.defineProperty(Text3.prototype, "nodeType", {
          get: function() {
            return 3;
          },
          enumerable: false,
          configurable: true
        });
        return Text3;
      }(DataNode)
    );
    exports.Text = Text2;
    var Comment = (
      /** @class */
      function(_super) {
        __extends(Comment2, _super);
        function Comment2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Comment;
          return _this;
        }
        Object.defineProperty(Comment2.prototype, "nodeType", {
          get: function() {
            return 8;
          },
          enumerable: false,
          configurable: true
        });
        return Comment2;
      }(DataNode)
    );
    exports.Comment = Comment;
    var ProcessingInstruction = (
      /** @class */
      function(_super) {
        __extends(ProcessingInstruction2, _super);
        function ProcessingInstruction2(name, data) {
          var _this = _super.call(this, data) || this;
          _this.name = name;
          _this.type = domelementtype_1.ElementType.Directive;
          return _this;
        }
        Object.defineProperty(ProcessingInstruction2.prototype, "nodeType", {
          get: function() {
            return 1;
          },
          enumerable: false,
          configurable: true
        });
        return ProcessingInstruction2;
      }(DataNode)
    );
    exports.ProcessingInstruction = ProcessingInstruction;
    var NodeWithChildren = (
      /** @class */
      function(_super) {
        __extends(NodeWithChildren2, _super);
        function NodeWithChildren2(children) {
          var _this = _super.call(this) || this;
          _this.children = children;
          return _this;
        }
        Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
          // Aliases
          /** First child of the node. */
          get: function() {
            var _a;
            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
          /** Last child of the node. */
          get: function() {
            return this.children.length > 0 ? this.children[this.children.length - 1] : null;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
          /**
           * Same as {@link children}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.children;
          },
          set: function(children) {
            this.children = children;
          },
          enumerable: false,
          configurable: true
        });
        return NodeWithChildren2;
      }(Node2)
    );
    exports.NodeWithChildren = NodeWithChildren;
    var CDATA = (
      /** @class */
      function(_super) {
        __extends(CDATA2, _super);
        function CDATA2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.CDATA;
          return _this;
        }
        Object.defineProperty(CDATA2.prototype, "nodeType", {
          get: function() {
            return 4;
          },
          enumerable: false,
          configurable: true
        });
        return CDATA2;
      }(NodeWithChildren)
    );
    exports.CDATA = CDATA;
    var Document = (
      /** @class */
      function(_super) {
        __extends(Document2, _super);
        function Document2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Root;
          return _this;
        }
        Object.defineProperty(Document2.prototype, "nodeType", {
          get: function() {
            return 9;
          },
          enumerable: false,
          configurable: true
        });
        return Document2;
      }(NodeWithChildren)
    );
    exports.Document = Document;
    var Element = (
      /** @class */
      function(_super) {
        __extends(Element2, _super);
        function Element2(name, attribs, children, type) {
          if (children === void 0) {
            children = [];
          }
          if (type === void 0) {
            type = name === "script" ? domelementtype_1.ElementType.Script : name === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
          }
          var _this = _super.call(this, children) || this;
          _this.name = name;
          _this.attribs = attribs;
          _this.type = type;
          return _this;
        }
        Object.defineProperty(Element2.prototype, "nodeType", {
          get: function() {
            return 1;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Element2.prototype, "tagName", {
          // DOM Level 1 aliases
          /**
           * Same as {@link name}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.name;
          },
          set: function(name) {
            this.name = name;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Element2.prototype, "attributes", {
          get: function() {
            var _this = this;
            return Object.keys(this.attribs).map(function(name) {
              var _a, _b;
              return {
                name,
                value: _this.attribs[name],
                namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
                prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
              };
            });
          },
          enumerable: false,
          configurable: true
        });
        return Element2;
      }(NodeWithChildren)
    );
    exports.Element = Element;
    function isTag(node) {
      return (0, domelementtype_1.isTag)(node);
    }
    exports.isTag = isTag;
    function isCDATA(node) {
      return node.type === domelementtype_1.ElementType.CDATA;
    }
    exports.isCDATA = isCDATA;
    function isText(node) {
      return node.type === domelementtype_1.ElementType.Text;
    }
    exports.isText = isText;
    function isComment(node) {
      return node.type === domelementtype_1.ElementType.Comment;
    }
    exports.isComment = isComment;
    function isDirective(node) {
      return node.type === domelementtype_1.ElementType.Directive;
    }
    exports.isDirective = isDirective;
    function isDocument(node) {
      return node.type === domelementtype_1.ElementType.Root;
    }
    exports.isDocument = isDocument;
    function hasChildren(node) {
      return Object.prototype.hasOwnProperty.call(node, "children");
    }
    exports.hasChildren = hasChildren;
    function cloneNode(node, recursive) {
      if (recursive === void 0) {
        recursive = false;
      }
      var result;
      if (isText(node)) {
        result = new Text2(node.data);
      } else if (isComment(node)) {
        result = new Comment(node.data);
      } else if (isTag(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_1 = new Element(node.name, __assign({}, node.attribs), children);
        children.forEach(function(child) {
          return child.parent = clone_1;
        });
        if (node.namespace != null) {
          clone_1.namespace = node.namespace;
        }
        if (node["x-attribsNamespace"]) {
          clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
        }
        if (node["x-attribsPrefix"]) {
          clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
        }
        result = clone_1;
      } else if (isCDATA(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_2 = new CDATA(children);
        children.forEach(function(child) {
          return child.parent = clone_2;
        });
        result = clone_2;
      } else if (isDocument(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_3 = new Document(children);
        children.forEach(function(child) {
          return child.parent = clone_3;
        });
        if (node["x-mode"]) {
          clone_3["x-mode"] = node["x-mode"];
        }
        result = clone_3;
      } else if (isDirective(node)) {
        var instruction = new ProcessingInstruction(node.name, node.data);
        if (node["x-name"] != null) {
          instruction["x-name"] = node["x-name"];
          instruction["x-publicId"] = node["x-publicId"];
          instruction["x-systemId"] = node["x-systemId"];
        }
        result = instruction;
      } else {
        throw new Error("Not implemented yet: ".concat(node.type));
      }
      result.startIndex = node.startIndex;
      result.endIndex = node.endIndex;
      if (node.sourceCodeLocation != null) {
        result.sourceCodeLocation = node.sourceCodeLocation;
      }
      return result;
    }
    exports.cloneNode = cloneNode;
    function cloneChildren(childs) {
      var children = childs.map(function(child) {
        return cloneNode(child, true);
      });
      for (var i2 = 1; i2 < children.length; i2++) {
        children[i2].prev = children[i2 - 1];
        children[i2 - 1].next = children[i2];
      }
      return children;
    }
  }
});

// node_modules/domhandler/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/domhandler/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p2 in m)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DomHandler = void 0;
    var domelementtype_1 = require_lib();
    var node_js_1 = require_node2();
    __exportStar(require_node2(), exports);
    var defaultOpts = {
      withStartIndices: false,
      withEndIndices: false,
      xmlMode: false
    };
    var DomHandler = (
      /** @class */
      function() {
        function DomHandler2(callback, options, elementCB) {
          this.dom = [];
          this.root = new node_js_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
          if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts;
          }
          if (typeof callback === "object") {
            options = callback;
            callback = void 0;
          }
          this.callback = callback !== null && callback !== void 0 ? callback : null;
          this.options = options !== null && options !== void 0 ? options : defaultOpts;
          this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
        }
        DomHandler2.prototype.onparserinit = function(parser) {
          this.parser = parser;
        };
        DomHandler2.prototype.onreset = function() {
          this.dom = [];
          this.root = new node_js_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
        };
        DomHandler2.prototype.onend = function() {
          if (this.done)
            return;
          this.done = true;
          this.parser = null;
          this.handleCallback(null);
        };
        DomHandler2.prototype.onerror = function(error) {
          this.handleCallback(error);
        };
        DomHandler2.prototype.onclosetag = function() {
          this.lastNode = null;
          var elem = this.tagStack.pop();
          if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
          }
          if (this.elementCB)
            this.elementCB(elem);
        };
        DomHandler2.prototype.onopentag = function(name, attribs) {
          var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : void 0;
          var element = new node_js_1.Element(name, attribs, void 0, type);
          this.addNode(element);
          this.tagStack.push(element);
        };
        DomHandler2.prototype.ontext = function(data) {
          var lastNode = this.lastNode;
          if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
            lastNode.data += data;
            if (this.options.withEndIndices) {
              lastNode.endIndex = this.parser.endIndex;
            }
          } else {
            var node = new node_js_1.Text(data);
            this.addNode(node);
            this.lastNode = node;
          }
        };
        DomHandler2.prototype.oncomment = function(data) {
          if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
            this.lastNode.data += data;
            return;
          }
          var node = new node_js_1.Comment(data);
          this.addNode(node);
          this.lastNode = node;
        };
        DomHandler2.prototype.oncommentend = function() {
          this.lastNode = null;
        };
        DomHandler2.prototype.oncdatastart = function() {
          var text = new node_js_1.Text("");
          var node = new node_js_1.CDATA([text]);
          this.addNode(node);
          text.parent = node;
          this.lastNode = text;
        };
        DomHandler2.prototype.oncdataend = function() {
          this.lastNode = null;
        };
        DomHandler2.prototype.onprocessinginstruction = function(name, data) {
          var node = new node_js_1.ProcessingInstruction(name, data);
          this.addNode(node);
        };
        DomHandler2.prototype.handleCallback = function(error) {
          if (typeof this.callback === "function") {
            this.callback(error, this.dom);
          } else if (error) {
            throw error;
          }
        };
        DomHandler2.prototype.addNode = function(node) {
          var parent = this.tagStack[this.tagStack.length - 1];
          var previousSibling = parent.children[parent.children.length - 1];
          if (this.options.withStartIndices) {
            node.startIndex = this.parser.startIndex;
          }
          if (this.options.withEndIndices) {
            node.endIndex = this.parser.endIndex;
          }
          parent.children.push(node);
          if (previousSibling) {
            node.prev = previousSibling;
            previousSibling.next = node;
          }
          node.parent = parent;
          this.lastNode = null;
        };
        return DomHandler2;
      }()
    );
    exports.DomHandler = DomHandler;
    exports.default = DomHandler;
  }
});

// node_modules/entities/lib/generated/decode-data-html.js
var require_decode_data_html = __commonJS({
  "node_modules/entities/lib/generated/decode-data-html.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new Uint16Array(
      // prettier-ignore
      'áµ<Ã•Ä±ÊŠÒÕ»×ÙµÛŞ¢ß–à à©Šàª‘à¶¡à¹­à¼‰à¼¦áƒŠáˆ¨á‹¡á•á’á“ƒá“Ÿá”¥\0\0\0\0\0\0á•«á›á¦á°’á·á½¾â â†°âŠâ€â»â‘‚â ¤â¤’â´ˆâ¹ˆâ¿ã€–ãŠºã˜¹ã¬ã£¾ã¨¨ã©±ã« ã¬®à €EMabcfglmnoprstu\\bfmsÂ„Â‹ÂÂ•Â˜Â¦Â³Â¹ÃˆÃligè€»Ã†äƒ†Pè€»&ä€¦cuteè€»Ãäƒreve;ä„‚Ä€iyx}rcè€»Ã‚äƒ‚;är;ì€€ğ”„raveè€»Ã€äƒ€pha;ä‘acr;ä„€d;æ©“Ä€gpÂÂ¡on;ä„„f;ì€€ğ”¸plyFunction;æ¡ingè€»Ã…äƒ…Ä€csÂ¾Ãƒr;ì€€ğ’œign;æ‰”ildeè€»Ãƒäƒƒmlè€»Ã„äƒ„Ğ€aceforsuÃ¥Ã»Ã¾Ä—ÄœÄ¢Ä§ÄªÄ€crÃªÃ²kslash;æˆ–Å¶Ã¶Ã¸;æ«§ed;æŒ†y;ä‘Æ€crtÄ…Ä‹Ä”ause;æˆµnoullis;æ„¬a;ä’r;ì€€ğ”…pf;ì€€ğ”¹eve;ä‹˜cÃ²Ä“mpeq;æ‰Ü€HOacdefhilorsuÅÅ‘Å–Æ€ÆÆ¢ÆµÆ·ÆºÇœÈ•É³É¸É¾cy;ä§PYè€»Â©ä‚©Æ€cpyÅÅ¢Åºute;ä„†Ä€;iÅ§Å¨æ‹’talDifferentialD;æ……leys;æ„­È€aeioÆ‰ÆÆ”Æ˜ron;ä„Œdilè€»Ã‡äƒ‡rc;ä„ˆnint;æˆ°ot;ä„ŠÄ€dnÆ§Æ­illa;ä‚¸terDot;ä‚·Ã²Å¿i;ä§rcleÈ€DMPTÇ‡Ç‹Ç‘Ç–ot;æŠ™inus;æŠ–lus;æŠ•imes;æŠ—oÄ€csÇ¢Ç¸kwiseContourIntegral;æˆ²eCurlyÄ€DQÈƒÈoubleQuote;æ€uote;æ€™È€lnpuÈÈ¨É‡É•onÄ€;eÈ¥È¦æˆ·;æ©´Æ€gitÈ¯È¶Èºruent;æ‰¡nt;æˆ¯ourIntegral;æˆ®Ä€frÉŒÉ;æ„‚oduct;æˆnterClockwiseContourIntegral;æˆ³oss;æ¨¯cr;ì€€ğ’pÄ€;CÊ„Ê…æ‹“ap;æ‰Ö€DJSZacefiosÊ Ê¬Ê°Ê´Ê¸Ë‹Ë—Ë¡Ë¦Ì³ÒÄ€;oÅ¹Ê¥trahd;æ¤‘cy;ä‚cy;ä…cy;äÆ€grsÊ¿Ë„Ë‡ger;æ€¡r;æ†¡hv;æ«¤Ä€ayËË•ron;ä„;ä”lÄ€;tËËæˆ‡a;ä”r;ì€€ğ”‡Ä€afË«Ì§Ä€cmË°Ì¢riticalÈ€ADGTÌ€Ì†Ì–Ìœcute;ä‚´oÅ´Ì‹Ì;ä‹™bleAcute;ä‹rave;ä ilde;ä‹œond;æ‹„ferentialD;æ…†Ñ°Ì½\0\0\0Í‚Í”\0Ğ…f;ì€€ğ”»Æ€;DEÍˆÍ‰Íä‚¨ot;æƒœqual;æ‰bleÌ€CDLRUVÍ£Í²Î‚ÏÏ¢Ï¸ontourIntegraÃ¬È¹oÉ´Í¹\0\0Í»Â»Í‰nArrow;æ‡“Ä€eoÎ‡Î¤ftÆ€ARTÎÎ–Î¡rrow;æ‡ightArrow;æ‡”eÃ¥ËŠngÄ€LRÎ«Ï„eftÄ€ARÎ³Î¹rrow;æŸ¸ightArrow;æŸºightArrow;æŸ¹ightÄ€ATÏ˜Ïrrow;æ‡’ee;æŠ¨pÉÏ©\0\0Ï¯rrow;æ‡‘ownArrow;æ‡•erticalBar;æˆ¥nÌ€ABLRTaĞ’ĞªĞ°ÑÑ¿Í¼rrowÆ€;BUĞĞĞ¢æ†“ar;æ¤“pArrow;æ‡µreve;äŒ‘eftË’Ğº\0Ñ†\0ÑightVector;æ¥eeVector;æ¥ectorÄ€;BÑ™Ñšæ†½ar;æ¥–ightÇ”Ñ§\0Ñ±eeVector;æ¥ŸectorÄ€;BÑºÑ»æ‡ar;æ¥—eeÄ€;AÒ†Ò‡æŠ¤rrow;æ†§Ä€ctÒ’Ò—r;ì€€ğ’Ÿrok;ä„à €NTacdfglmopqstuxÒ½Ó€Ó„Ó‹ÓÓ¢Ó§Ó®ÓµÔ¡Ô¯Ô¶Õ’ÕÕ Õ¥G;ä…ŠHè€»Ãäƒcuteè€»Ã‰äƒ‰Æ€aiyÓ’Ó—Óœron;ä„šrcè€»ÃŠäƒŠ;ä­ot;ä„–r;ì€€ğ”ˆraveè€»Ãˆäƒˆement;æˆˆÄ€apÓºÓ¾cr;ä„’tyÉ“Ô†\0\0Ô’mallSquare;æ—»erySmallSquare;æ–«Ä€gpÔ¦Ôªon;ä„˜f;ì€€ğ”¼silon;ä•uÄ€aiÔ¼Õ‰lÄ€;TÕ‚Õƒæ©µilde;æ‰‚librium;æ‡ŒÄ€ciÕ—Õšr;æ„°m;æ©³a;ä—mlè€»Ã‹äƒ‹Ä€ipÕªÕ¯sts;æˆƒonentialE;æ…‡Ê€cfiosÖ…ÖˆÖÖ²×Œy;ä¤r;ì€€ğ”‰lledÉ“Ö—\0\0Ö£mallSquare;æ—¼erySmallSquare;æ–ªÍ°Öº\0Ö¿\0\0×„f;ì€€ğ”½All;æˆ€riertrf;æ„±cÃ²×‹Ø€JTabcdfgorst×¨×¬×¯×ºØ€Ø’Ø–Ø›ØØ£Ù¬Ù²cy;äƒè€»>ä€¾mmaÄ€;d×·×¸ä“;äœreve;ä„Æ€eiyØ‡ØŒØdil;ä„¢rc;ä„œ;ä“ot;ä„ r;ì€€ğ”Š;æ‹™pf;ì€€ğ”¾eaterÌ€EFGLSTØµÙ„ÙÙ–Ù›Ù¦qualÄ€;LØ¾Ø¿æ‰¥ess;æ‹›ullEqual;æ‰§reater;æª¢ess;æ‰·lantEqual;æ©¾ilde;æ‰³cr;ì€€ğ’¢;æ‰«Ğ€AacfiosuÚ…Ú‹Ú–Ú›ÚÚªÚ¾ÛŠRDcy;äªÄ€ctÚÚ”ek;ä‹‡;äirc;ä„¤r;æ„ŒlbertSpace;æ„‹Ç°Ú¯\0Ú²f;æ„izontalLine;æ”€Ä€ctÛƒÛ…Ã²Ú©rok;ä„¦mpÅ„ÛÛ˜ownHumÃ°Ä¯qual;æ‰Ü€EJOacdfgmnostuÛºÛ¾ÜƒÜ‡ÜÜšÜÜ¡Ü¨İ„İ¸Ş‹ŞŞ•cy;ä•lig;ä„²cy;äcuteè€»ÃäƒÄ€iyÜ“Ü˜rcè€»Ãäƒ;ä˜ot;ä„°r;æ„‘raveè€»ÃŒäƒŒÆ€;apÜ Ü¯Ü¿Ä€cgÜ´Ü·r;ä„ªinaryI;æ…ˆlieÃ³ÏÇ´İ‰\0İ¢Ä€;eİİæˆ¬Ä€grİ“İ˜ral;æˆ«section;æ‹‚isibleÄ€CTİ¬İ²omma;æ£imes;æ¢Æ€gptİ¿ŞƒŞˆon;ä„®f;ì€€ğ•€a;ä™cr;æ„ilde;ä„¨Ç«Şš\0Şcy;ä†lè€»ÃäƒÊ€cfosuŞ¬Ş·Ş¼ß‚ßÄ€iyŞ±Şµrc;ä„´;ä™r;ì€€ğ”pf;ì€€ğ•Ç£ß‡\0ßŒr;ì€€ğ’¥rcy;äˆkcy;ä„Î€HJacfosß¤ß¨ß¬ß±ß½à ‚à ˆcy;ä¥cy;äŒppa;äšÄ€eyß¶ß»dil;ä„¶;äšr;ì€€ğ”pf;ì€€ğ•‚cr;ì€€ğ’¦Ö€JTaceflmostà ¥à ©à ¬à¡à¡£à¦³à¦¸à§‡à§à¨·à©‡cy;ä‰è€»<ä€¼Ê€cmnprà ·à ¼à¡à¡„à¡ute;ä„¹bda;ä›g;æŸªlacetrf;æ„’r;æ†Æ€aeyà¡—à¡œà¡¡ron;ä„½dil;ä„»;ä›Ä€fsà¡¨à¥°tÔ€ACDFRTUVarà¡¾à¢©à¢±à£ à£¦à£¼à¤¯à¥›Îà¥ªÄ€nrà¢ƒà¢gleBracket;æŸ¨rowÆ€;BRà¢™à¢šà¢æ†ar;æ‡¤ightArrow;æ‡†eiling;æŒˆoÇµà¢·\0à£ƒbleBracket;æŸ¦nÇ”à£ˆ\0à£’eeVector;æ¥¡ectorÄ€;Bà£›à£œæ‡ƒar;æ¥™loor;æŒŠightÄ€AVà£¯à£µrrow;æ†”ector;æ¥Ä€erà¤à¤—eÆ€;AVà¤‰à¤Šà¤æŠ£rrow;æ†¤ector;æ¥šiangleÆ€;BEà¤¤à¤¥à¤©æŠ²ar;æ§qual;æŠ´pÆ€DTVà¤·à¥‚à¥ŒownVector;æ¥‘eeVector;æ¥ ectorÄ€;Bà¥–à¥—æ†¿ar;æ¥˜ectorÄ€;Bà¥¥à¥¦æ†¼ar;æ¥’ightÃ¡ÎœsÌ€EFGLSTà¥¾à¦‹à¦•à¦à¦¢à¦­qualGreater;æ‹šullEqual;æ‰¦reater;æ‰¶ess;æª¡lantEqual;æ©½ilde;æ‰²r;ì€€ğ”Ä€;eà¦½à¦¾æ‹˜ftarrow;æ‡šidot;ä„¿Æ€npwà§”à¨–à¨›gÈ€LRlrà§à§·à¨‚à¨eftÄ€ARà§¦à§¬rrow;æŸµightArrow;æŸ·ightArrow;æŸ¶eftÄ€arÎ³à¨ŠightÃ¡Î¿ightÃ¡ÏŠf;ì€€ğ•ƒerÄ€LRà¨¢à¨¬eftArrow;æ†™ightArrow;æ†˜Æ€chtà¨¾à©€à©‚Ã²à¡Œ;æ†°rok;ä…;æ‰ªĞ€acefiosuà©šà©à© à©·à©¼àª…àª‹àªp;æ¤…y;äœÄ€dlà©¥à©¯iumSpace;æŸlintrf;æ„³r;ì€€ğ”nusPlus;æˆ“pf;ì€€ğ•„cÃ²à©¶;äœÒ€Jacefostuàª£àª§àª­à«€à¬”à¬™à¶‘à¶—à¶cy;äŠcute;ä…ƒÆ€aeyàª´àª¹àª¾ron;ä…‡dil;ä……;äÆ€gswà«‡à«°à¬ativeÆ€MTVà«“à«Ÿà«¨ediumSpace;æ€‹hiÄ€cnà«¦à«˜Ã«à«™eryThiÃ®à«™tedÄ€GLà«¸à¬†reaterGreateÃ²Ù³essLesÃ³à©ˆLine;ä€Šr;ì€€ğ”‘È€Bnptà¬¢à¬¨à¬·à¬ºreak;æ BreakingSpace;ä‚ f;æ„•Ú€;CDEGHLNPRSTVà­•à­–à­ªà­¼à®¡à¯«à°„à±à²„à²¦à³˜àµ¡à¶…æ«¬Ä€ouà­›à­¤ngruent;æ‰¢pCap;æ‰­oubleVerticalBar;æˆ¦Æ€lqxà®ƒà®Šà®›ement;æˆ‰ualÄ€;Tà®’à®“æ‰ ilde;ì€€â‰‚Ì¸ists;æˆ„reaterÎ€;EFGLSTà®¶à®·à®½à¯‰à¯“à¯˜à¯¥æ‰¯qual;æ‰±ullEqual;ì€€â‰§Ì¸reater;ì€€â‰«Ì¸ess;æ‰¹lantEqual;ì€€â©¾Ì¸ilde;æ‰µumpÅ„à¯²à¯½ownHump;ì€€â‰Ì¸qual;ì€€â‰Ì¸eÄ€fsà°Šà°§tTriangleÆ€;BEà°šà°›à°¡æ‹ªar;ì€€â§Ì¸qual;æ‹¬sÌ€;EGLSTà°µà°¶à°¼à±„à±‹à±˜æ‰®qual;æ‰°reater;æ‰¸ess;ì€€â‰ªÌ¸lantEqual;ì€€â©½Ì¸ilde;æ‰´estedÄ€GLà±¨à±¹reaterGreater;ì€€âª¢Ì¸essLess;ì€€âª¡Ì¸recedesÆ€;ESà²’à²“à²›æŠ€qual;ì€€âª¯Ì¸lantEqual;æ‹ Ä€eià²«à²¹verseElement;æˆŒghtTriangleÆ€;BEà³‹à³Œà³’æ‹«ar;ì€€â§Ì¸qual;æ‹­Ä€quà³à´ŒuareSuÄ€bpà³¨à³¹setÄ€;Eà³°à³³ì€€âŠÌ¸qual;æ‹¢ersetÄ€;Eà´ƒà´†ì€€âŠÌ¸qual;æ‹£Æ€bcpà´“à´¤àµsetÄ€;Eà´›à´ì€€âŠ‚âƒ’qual;æŠˆceedsÈ€;ESTà´²à´³à´»àµ†æŠqual;ì€€âª°Ì¸lantEqual;æ‹¡ilde;ì€€â‰¿Ì¸ersetÄ€;Eàµ˜àµ›ì€€âŠƒâƒ’qual;æŠ‰ildeÈ€;EFTàµ®àµ¯àµµàµ¿æ‰qual;æ‰„ullEqual;æ‰‡ilde;æ‰‰erticalBar;æˆ¤cr;ì€€ğ’©ildeè€»Ã‘äƒ‘;äÜ€Eacdfgmoprstuvà¶½à·‚à·‰à·•à·›à· à·§à·¼à¸‚à¸ à¸¢à¸²à¸¿à¹„lig;ä…’cuteè€»Ã“äƒ“Ä€iyà·à·“rcè€»Ã”äƒ”;äblac;ä…r;ì€€ğ”’raveè€»Ã’äƒ’Æ€aeià·®à·²à·¶cr;ä…Œga;ä©cron;äŸpf;ì€€ğ•†enCurlyÄ€DQà¸à¸šoubleQuote;æ€œuote;æ€˜;æ©”Ä€clà¸§à¸¬r;ì€€ğ’ªashè€»Ã˜äƒ˜iÅ¬à¸·à¸¼deè€»Ã•äƒ•es;æ¨·mlè€»Ã–äƒ–erÄ€BPà¹‹à¹ Ä€arà¹à¹“r;æ€¾acÄ€ekà¹šà¹œ;æet;æ´arenthesis;æœÒ€acfhilorsà¹¿àº‡àºŠàºàº’àº”àºàº°à»¼rtialD;æˆ‚y;äŸr;ì€€ğ”“i;ä¦;ä usMinus;ä‚±Ä€ipàº¢àº­ncareplanÃ¥Úf;æ„™È€;eioàº¹àººà» à»¤æª»cedesÈ€;ESTà»ˆà»‰à»à»šæ‰ºqual;æª¯lantEqual;æ‰¼ilde;æ‰¾me;æ€³Ä€dpà»©à»®uct;æˆortionÄ€;aÈ¥à»¹l;æˆÄ€cià¼à¼†r;ì€€ğ’«;ä¨È€Ufosà¼‘à¼–à¼›à¼ŸOTè€»"ä€¢r;ì€€ğ””pf;æ„šcr;ì€€ğ’¬Ø€BEacefhiorsuà¼¾à½ƒà½‡à½ à½³à¾§à¾ªà¾­á‚–á‚©á‚´á‚¾arr;æ¤Gè€»Â®ä‚®Æ€cnrà½à½“à½–ute;ä…”g;æŸ«rÄ€;tà½œà½æ† l;æ¤–Æ€aeyà½§à½¬à½±ron;ä…˜dil;ä…–;ä Ä€;và½¸à½¹æ„œerseÄ€EUà¾‚à¾™Ä€lqà¾‡à¾ement;æˆ‹uilibrium;æ‡‹pEquilibrium;æ¥¯rÂ»à½¹o;ä¡ghtĞ€ACDFTUVaà¿à¿«à¿³á€¢á€¨á›á‚‡Ï˜Ä€nrà¿†à¿’gleBracket;æŸ©rowÆ€;BLà¿œà¿à¿¡æ†’ar;æ‡¥eftArrow;æ‡„eiling;æŒ‰oÇµà¿¹\0á€…bleBracket;æŸ§nÇ”á€Š\0á€”eeVector;æ¥ectorÄ€;Bá€á€æ‡‚ar;æ¥•loor;æŒ‹Ä€erá€­áƒeÆ€;AVá€µá€¶á€¼æŠ¢rrow;æ†¦ector;æ¥›iangleÆ€;BEáá‘á•æŠ³ar;æ§qual;æŠµpÆ€DTVá£á®á¸ownVector;æ¥eeVector;æ¥œectorÄ€;Bá‚‚á‚ƒæ†¾ar;æ¥”ectorÄ€;Bá‚‘á‚’æ‡€ar;æ¥“Ä€puá‚›á‚f;æ„ndImplies;æ¥°ightarrow;æ‡›Ä€chá‚¹á‚¼r;æ„›;æ†±leDelayed;æ§´Ú€HOacfhimoqstuáƒ¤áƒ±áƒ·áƒ½á„™á„á…‘á…–á…¡á…§á†µá†»á†¿Ä€Ccáƒ©áƒ®Hcy;ä©y;ä¨FTcy;ä¬cute;ä…šÊ€;aeiyá„ˆá„‰á„á„“á„—æª¼ron;ä… dil;ä…rc;ä…œ;ä¡r;ì€€ğ”–ortÈ€DLRUá„ªá„´á„¾á…‰ownArrowÂ»ĞeftArrowÂ»à¢šightArrowÂ»à¿pArrow;æ†‘gma;ä£allCircle;æˆ˜pf;ì€€ğ•ŠÉ²á…­\0\0á…°t;æˆšareÈ€;ISUá…»á…¼á†‰á†¯æ–¡ntersection;æŠ“uÄ€bpá†á†setÄ€;Eá†—á†˜æŠqual;æŠ‘ersetÄ€;Eá†¨á†©æŠqual;æŠ’nion;æŠ”cr;ì€€ğ’®ar;æ‹†È€bcmpá‡ˆá‡›áˆ‰áˆ‹Ä€;sá‡á‡æ‹etÄ€;Eá‡á‡•qual;æŠ†Ä€chá‡ áˆ…eedsÈ€;ESTá‡­á‡®á‡´á‡¿æ‰»qual;æª°lantEqual;æ‰½ilde;æ‰¿ThÃ¡à¾Œ;æˆ‘Æ€;esáˆ’áˆ“áˆ£æ‹‘rsetÄ€;EáˆœáˆæŠƒqual;æŠ‡etÂ»áˆ“Ö€HRSacfhiorsáˆ¾á‰„á‰‰á‰•á‰á‰±á‰¶áŠŸá‹‚á‹ˆá‹‘ORNè€»ÃäƒADE;æ„¢Ä€Hcá‰á‰’cy;ä‹y;ä¦Ä€buá‰šá‰œ;ä€‰;ä¤Æ€aeyá‰¥á‰ªá‰¯ron;ä…¤dil;ä…¢;ä¢r;ì€€ğ”—Ä€eiá‰»áŠ‰Ç²áŠ€\0áŠ‡efore;æˆ´a;ä˜Ä€cnáŠáŠ˜kSpace;ì€€âŸâ€ŠSpace;æ€‰ldeÈ€;EFTáŠ«áŠ¬áŠ²áŠ¼æˆ¼qual;æ‰ƒullEqual;æ‰…ilde;æ‰ˆpf;ì€€ğ•‹ipleDot;æƒ›Ä€ctá‹–á‹›r;ì€€ğ’¯rok;ä…¦à«¡á‹·áŒáŒšáŒ¦\0áŒ¬áŒ±\0\0\0\0\0áŒ¸áŒ½á·á…\0á¿á„áŠáÄ€crá‹»áŒuteè€»ÃšäƒšrÄ€;oáŒ‡áŒˆæ†Ÿcir;æ¥‰rÇ£áŒ“\0áŒ–y;äve;ä…¬Ä€iyáŒáŒ£rcè€»Ã›äƒ›;ä£blac;ä…°r;ì€€ğ”˜raveè€»Ã™äƒ™acr;ä…ªÄ€diáá©erÄ€BPáˆáÄ€aráár;äŸacÄ€eká—á™;æŸet;æµarenthesis;æonÄ€;Pá°á±æ‹ƒlus;æŠÄ€gpá»á¿on;ä…²f;ì€€ğ•ŒĞ€ADETadpsá•á®á¸á„Ï¨á’á—á³rrowÆ€;BDá…á á¤ar;æ¤’ownArrow;æ‡…ownArrow;æ†•quilibrium;æ¥®eeÄ€;Aá‹áŒæŠ¥rrow;æ†¥ownÃ¡Ï³erÄ€LRáá¨eftArrow;æ†–ightArrow;æ†—iÄ€;lá¹áºä’on;ä¥ing;ä…®cr;ì€€ğ’°ilde;ä…¨mlè€»ÃœäƒœÒ€Dbcdefosvá§á¬á°á³á¾á’…á’Šá’á’–ash;æŠ«ar;æ««y;ä’ashÄ€;lá»á¼æŠ©;æ«¦Ä€erá‘ƒá‘…;æ‹Æ€btyá‘Œá‘á‘ºar;æ€–Ä€;iá‘á‘•calÈ€BLSTá‘¡á‘¥á‘ªá‘´ar;æˆ£ine;ä¼eparator;æ˜ilde;æ‰€ThinSpace;æ€Šr;ì€€ğ”™pf;ì€€ğ•cr;ì€€ğ’±dash;æŠªÊ€cefosá’§á’¬á’±á’¶á’¼irc;ä…´dge;æ‹€r;ì€€ğ”špf;ì€€ğ•cr;ì€€ğ’²È€fiosá“‹á“á“’á“˜r;ì€€ğ”›;äpf;ì€€ğ•cr;ì€€ğ’³Ò€AIUacfosuá“±á“µá“¹á“½á”„á”á””á”šá” cy;ä¯cy;ä‡cy;ä®cuteè€»ÃäƒÄ€iyá”‰á”rc;ä…¶;ä«r;ì€€ğ”œpf;ì€€ğ•cr;ì€€ğ’´ml;ä…¸Ğ€Hacdefosá”µá”¹á”¿á•‹á•á•á• á•¤cy;ä–cute;ä…¹Ä€ayá•„á•‰ron;ä…½;ä—ot;ä…»Ç²á•”\0á•›oWidtÃ¨à«™a;ä–r;æ„¨pf;æ„¤cr;ì€€ğ’µà¯¡á–ƒá–Šá–\0á–°á–¶á–¿\0\0\0\0á—†á—›á—«á™Ÿá™­\0áš•áš›áš²áš¹\0áš¾cuteè€»Ã¡äƒ¡reve;ä„ƒÌ€;Ediuyá–œá–á–¡á–£á–¨á–­æˆ¾;ì€€âˆ¾Ì³;æˆ¿rcè€»Ã¢äƒ¢teè‚»Â´Ì†;ä°ligè€»Ã¦äƒ¦Ä€;rÂ²á–º;ì€€ğ”raveè€»Ã äƒ Ä€epá—Šá—–Ä€fpá—á—”sym;æ„µÃ¨á—“ha;ä±Ä€apá—ŸcÄ€clá—¤á—§r;ä„g;æ¨¿É¤á—°\0\0á˜ŠÊ€;adsvá—ºá—»á—¿á˜á˜‡æˆ§nd;æ©•;æ©œlope;æ©˜;æ©šÎ€;elmrszá˜˜á˜™á˜›á˜á˜¿á™á™™æˆ ;æ¦¤eÂ»á˜™sdÄ€;aá˜¥á˜¦æˆ¡Ñ¡á˜°á˜²á˜´á˜¶á˜¸á˜ºá˜¼á˜¾;æ¦¨;æ¦©;æ¦ª;æ¦«;æ¦¬;æ¦­;æ¦®;æ¦¯tÄ€;vá™…á™†æˆŸbÄ€;dá™Œá™æŠ¾;æ¦Ä€ptá™”á™—h;æˆ¢Â»Â¹arr;æ¼Ä€gpá™£á™§on;ä„…f;ì€€ğ•’Î€;Eaeiopá‹á™»á™½áš‚áš„áš‡ášŠ;æ©°cir;æ©¯;æ‰Šd;æ‰‹s;ä€§roxÄ€;eá‹áš’Ã±ášƒingè€»Ã¥äƒ¥Æ€ctyáš¡áš¦áš¨r;ì€€ğ’¶;ä€ªmpÄ€;eá‹áš¯Ã±Êˆildeè€»Ã£äƒ£mlè€»Ã¤äƒ¤Ä€ciá›‚á›ˆoninÃ´É²nt;æ¨‘à €Nabcdefiklnoprsuá›­á›±áœ°áœ¼áƒáˆá¸á½áŸ áŸ¦á ¹á¡áœá¤½á¥ˆá¥°ot;æ«­Ä€crá›¶áœkÈ€cepsáœ€áœ…áœáœ“ong;æ‰Œpsilon;ä¶rime;æ€µimÄ€;eáœšáœ›æˆ½q;æ‹Å¶áœ¢áœ¦ee;æŠ½edÄ€;gáœ¬áœ­æŒ…eÂ»áœ­rkÄ€;táœáœ·brk;æ¶Ä€oyáœá;ä±quo;æ€Ê€cmprtá“á›á¡á¤á¨ausÄ€;eÄŠÄ‰ptyv;æ¦°sÃ©áœŒnoÃµÄ“Æ€ahwá¯á±á³;ä²;æ„¶een;æ‰¬r;ì€€ğ”ŸgÎ€costuvwááá³áŸáŸ•áŸ›áŸÆ€aiuá”á–ášÃ°İ rc;æ—¯pÂ»á±Æ€dptá¤á¨á­ot;æ¨€lus;æ¨imes;æ¨‚É±á¹\0\0á¾cup;æ¨†ar;æ˜…riangleÄ€duáŸáŸ’own;æ–½p;æ–³plus;æ¨„eÃ¥á‘„Ã¥á’­arow;æ¤Æ€akoáŸ­á ¦á µÄ€cnáŸ²á £kÆ€lstáŸºÖ«á ‚ozenge;æ§«riangleÈ€;dlrá ’á “á ˜á æ–´own;æ–¾eft;æ—‚ight;æ–¸k;æ£Æ±á «\0á ³Æ²á ¯\0á ±;æ–’;æ–‘4;æ–“ck;æ–ˆÄ€eoá ¾á¡Ä€;qá¡ƒá¡†ì€€=âƒ¥uiv;ì€€â‰¡âƒ¥t;æŒÈ€ptwxá¡™á¡á¡§á¡¬f;ì€€ğ•“Ä€;tá‹á¡£omÂ»áŒtie;æ‹ˆØ€DHUVbdhmptuvá¢…á¢–á¢ªá¢»á£—á£›á£¬á£¿á¤…á¤Šá¤á¤¡È€LRlrá¢á¢á¢’á¢”;æ•—;æ•”;æ•–;æ•“Ê€;DUduá¢¡á¢¢á¢¤á¢¦á¢¨æ•;æ•¦;æ•©;æ•¤;æ•§È€LRlrá¢³á¢µá¢·á¢¹;æ•;æ•š;æ•œ;æ•™Î€;HLRhlrá£Šá£‹á£á£á£‘á£“á£•æ•‘;æ•¬;æ•£;æ• ;æ•«;æ•¢;æ•Ÿox;æ§‰È€LRlrá£¤á£¦á£¨á£ª;æ••;æ•’;æ”;æ”ŒÊ€;DUduÚ½á£·á£¹á£»á£½;æ•¥;æ•¨;æ”¬;æ”´inus;æŠŸlus;æŠimes;æŠ È€LRlrá¤™á¤›á¤á¤Ÿ;æ•›;æ•˜;æ”˜;æ””Î€;HLRhlrá¤°á¤±á¤³á¤µá¤·á¤¹á¤»æ”‚;æ•ª;æ•¡;æ•;æ”¼;æ”¤;æ”œÄ€evÄ£á¥‚barè€»Â¦ä‚¦È€ceioá¥‘á¥–á¥šá¥ r;ì€€ğ’·mi;æmÄ€;eáœšáœœlÆ€;bhá¥¨á¥©á¥«äœ;æ§…sub;æŸˆÅ¬á¥´á¥¾lÄ€;eá¥¹á¥ºæ€¢tÂ»á¥ºpÆ€;EeÄ¯á¦…á¦‡;æª®Ä€;qÛœÛ›à³¡á¦§\0á§¨á¨‘á¨•á¨²\0á¨·á©\0\0áª´\0\0á«\0\0á¬¡á¬®á­á­’\0á¯½\0á°ŒÆ€cprá¦­á¦²á§ute;ä„‡Ì€;abcdsá¦¿á§€á§„á§Šá§•á§™æˆ©nd;æ©„rcup;æ©‰Ä€auá§á§’p;æ©‹p;æ©‡ot;æ©€;ì€€âˆ©ï¸€Ä€eoá§¢á§¥t;æÃ®Ú“È€aeiuá§°á§»á¨á¨…Ç°á§µ\0á§¸s;æ©on;ä„dilè€»Ã§äƒ§rc;ä„‰psÄ€;sá¨Œá¨æ©Œm;æ©ot;ä„‹Æ€dmná¨›á¨ á¨¦ilè‚»Â¸Æ­ptyv;æ¦²tè„€Â¢;eá¨­á¨®ä‚¢rÃ¤Æ²r;ì€€ğ” Æ€ceiá¨½á©€á©y;ä‘‡ckÄ€;má©‡á©ˆæœ“arkÂ»á©ˆ;ä‡rÎ€;Ecefmsá©Ÿá© á©¢á©«áª¤áªªáª®æ—‹;æ§ƒÆ€;elá©©á©ªá©­ä‹†q;æ‰—eÉ¡á©´\0\0áªˆrrowÄ€lrá©¼áªeft;æ†ºight;æ†»Ê€RSacdáª’áª”áª–áªšáªŸÂ»à½‡;æ“ˆst;æŠ›irc;æŠšash;æŠnint;æ¨id;æ«¯cir;æ§‚ubsÄ€;uáª»áª¼æ™£itÂ»áª¼Ë¬á«‡á«”á«º\0á¬ŠonÄ€;eá«á«ä€ºÄ€;qÃ‡Ã†É­á«™\0\0á«¢aÄ€;tá«á«Ÿä€¬;ä€Æ€;flá«¨á«©á««æˆÃ®á… eÄ€mxá«±á«¶entÂ»á«©eÃ³ÉÇ§á«¾\0á¬‡Ä€;dáŠ»á¬‚ot;æ©­nÃ´É†Æ€fryá¬á¬”á¬—;ì€€ğ•”oÃ¤É”è„€Â©;sÅ•á¬r;æ„—Ä€aoá¬¥á¬©rr;æ†µss;æœ—Ä€cuá¬²á¬·r;ì€€ğ’¸Ä€bpá¬¼á­„Ä€;eá­á­‚æ«;æ«‘Ä€;eá­‰á­Šæ«;æ«’dot;æ‹¯Î€delprvwá­ á­¬á­·á®‚á®¬á¯”á¯¹arrÄ€lrá­¨á­ª;æ¤¸;æ¤µÉ°á­²\0\0á­µr;æ‹c;æ‹ŸarrÄ€;pá­¿á®€æ†¶;æ¤½Ì€;bcdosá®á®á®–á®¡á®¥á®¨æˆªrcap;æ©ˆÄ€auá®›á®p;æ©†p;æ©Šot;æŠr;æ©…;ì€€âˆªï¸€È€alrvá®µá®¿á¯á¯£rrÄ€;má®¼á®½æ†·;æ¤¼yÆ€evwá¯‡á¯”á¯˜qÉ°á¯\0\0á¯’reÃ£á­³uÃ£á­µee;æ‹edge;æ‹enè€»Â¤ä‚¤earrowÄ€lrá¯®á¯³eftÂ»á®€ightÂ»á®½eÃ¤á¯Ä€ciá°á°‡oninÃ´Ç·nt;æˆ±lcty;æŒ­à¦€AHabcdefhijlorstuwzá°¸á°»á°¿á±á±©á±µá²Šá²á²¬á²·á³»á³¿á´áµ»á¶‘á¶«á¶»á·†á·rÃ²Îar;æ¥¥È€glrsá±ˆá±á±’á±”ger;æ€ eth;æ„¸Ã²á„³hÄ€;vá±šá±›æ€Â»à¤ŠÅ«á±¡á±§arow;æ¤aÃ£Ì•Ä€ayá±®á±³ron;ä„;ä´Æ€;aoÌ²á±¼á²„Ä€grÊ¿á²r;æ‡Štseq;æ©·Æ€glmá²‘á²”á²˜è€»Â°ä‚°ta;ä´ptyv;æ¦±Ä€irá²£á²¨sht;æ¥¿;ì€€ğ”¡arÄ€lrá²³á²µÂ»à£œÂ»á€Ê€aegsvá³‚Í¸á³–á³œá³ mÆ€;osÌ¦á³Šá³”ndÄ€;sÌ¦á³‘uit;æ™¦amma;äin;æ‹²Æ€;ioá³§á³¨á³¸äƒ·deè„€Ã·;oá³§á³°ntimes;æ‹‡nÃ¸á³·cy;ä‘’cÉ¯á´†\0\0á´Šrn;æŒop;æŒÊ€lptuwá´˜á´á´¢áµ‰áµ•lar;ä€¤f;ì€€ğ••Ê€;empsÌ‹á´­á´·á´½áµ‚qÄ€;dÍ’á´³ot;æ‰‘inus;æˆ¸lus;æˆ”quare;æŠ¡blebarwedgÃ¥ÃºnÆ€adhá„®áµáµ§ownarrowÃ³á²ƒarpoonÄ€lráµ²áµ¶efÃ´á²´ighÃ´á²¶Å¢áµ¿á¶…karoÃ·à½‚É¯á¶Š\0\0á¶rn;æŒŸop;æŒŒÆ€cotá¶˜á¶£á¶¦Ä€ryá¶á¶¡;ì€€ğ’¹;ä‘•l;æ§¶rok;ä„‘Ä€drá¶°á¶´ot;æ‹±iÄ€;fá¶ºá –æ–¿Ä€ahá·€á·ƒrÃ²Ğ©aÃ²à¾¦angle;æ¦¦Ä€ciá·’á·•y;ä‘Ÿgrarr;æŸ¿à¤€Dacdefglmnopqrstuxá¸á¸‰á¸™á¸¸Õ¸á¸¼á¹‰á¹¡á¹¾áº¥áº¯áº½á»¡á¼ªá¼·á½„á½á½šÄ€Doá¸†á´´oÃ´á²‰Ä€csá¸á¸”uteè€»Ã©äƒ©ter;æ©®È€aioyá¸¢á¸§á¸±á¸¶ron;ä„›rÄ€;cá¸­á¸®æ‰–è€»Ãªäƒªlon;æ‰•;ä‘ot;ä„—Ä€Drá¹á¹…ot;æ‰’;ì€€ğ”¢Æ€;rsá¹á¹‘á¹—æªšaveè€»Ã¨äƒ¨Ä€;dá¹œá¹æª–ot;æª˜È€;ilsá¹ªá¹«á¹²á¹´æª™nters;æ§;æ„“Ä€;dá¹¹á¹ºæª•ot;æª—Æ€apsáº…áº‰áº—cr;ä„“tyÆ€;sváº’áº“áº•æˆ…etÂ»áº“pÄ€1;áºáº¤Ä³áº¡áº£;æ€„;æ€…æ€ƒÄ€gsáºªáº¬;ä…‹p;æ€‚Ä€gpáº´áº¸on;ä„™f;ì€€ğ•–Æ€alsá»„á»á»’rÄ€;sá»Šá»‹æ‹•l;æ§£us;æ©±iÆ€;lvá»šá»›á»ŸäµonÂ»á»›;äµÈ€csuvá»ªá»³á¼‹á¼£Ä€ioá»¯á¸±rcÂ»á¸®É©á»¹\0\0á»»Ã­ÕˆantÄ€glá¼‚á¼†trÂ»á¹essÂ»á¹ºÆ€aeiá¼’á¼–á¼šls;ä€½st;æ‰ŸvÄ€;DÈµá¼ D;æ©¸parsl;æ§¥Ä€Daá¼¯á¼³ot;æ‰“rr;æ¥±Æ€cdiá¼¾á½á»¸r;æ„¯oÃ´Í’Ä€ahá½‰á½‹;ä·è€»Ã°äƒ°Ä€mrá½“á½—lè€»Ã«äƒ«o;æ‚¬Æ€cipá½¡á½¤á½§l;ä€¡sÃ´Õ®Ä€eoá½¬á½´ctatioÃ®Õ™nentialÃ¥Õ¹à§¡á¾’\0á¾\0á¾¡á¾§\0\0á¿†á¿Œ\0á¿“\0á¿¦á¿ªâ€€\0â€ˆâšllingdotseÃ±á¹„y;ä‘„male;æ™€Æ€ilrá¾­á¾³á¿lig;è€€ï¬ƒÉ©á¾¹\0\0á¾½g;è€€ï¬€ig;è€€ï¬„;ì€€ğ”£lig;è€€ï¬lig;ì€€fjÆ€altá¿™á¿œá¿¡t;æ™­ig;è€€ï¬‚ns;æ–±of;ä†’Ç°á¿®\0á¿³f;ì€€ğ•—Ä€akÖ¿á¿·Ä€;vá¿¼á¿½æ‹”;æ«™artint;æ¨Ä€aoâ€Œâ•Ä€csâ€‘â’Î±â€šâ€°â€¸â…âˆ\0âÎ²â€¢â€¥â€§â€ªâ€¬\0â€®è€»Â½ä‚½;æ…“è€»Â¼ä‚¼;æ…•;æ…™;æ…›Æ³â€´\0â€¶;æ…”;æ…–Ê´â€¾â\0\0âƒè€»Â¾ä‚¾;æ…—;æ…œ5;æ…˜Æ¶âŒ\0â;æ…š;æ…8;æ…l;æ„wn;æŒ¢cr;ì€€ğ’»à¢€Eabcdefgijlnorstvâ‚‚â‚‰â‚Ÿâ‚¥â‚°â‚´âƒ°âƒµâƒºâƒ¿â„ƒâ„’â„¸Ì—â„¾â…’â†Ä€;lÙâ‚‡;æªŒÆ€cmpâ‚â‚•â‚ute;ä‡µmaÄ€;dâ‚œá³šä³;æª†reve;ä„ŸÄ€iyâ‚ªâ‚®rc;ä„;ä³ot;ä„¡È€;lqsØ¾Ù‚â‚½âƒ‰Æ€;qsØ¾ÙŒâƒ„lanÃ´Ù¥È€;cdlÙ¥âƒ’âƒ•âƒ¥c;æª©otÄ€;oâƒœâƒæª€Ä€;lâƒ¢âƒ£æª‚;æª„Ä€;eâƒªâƒ­ì€€â‹›ï¸€s;æª”r;ì€€ğ”¤Ä€;gÙ³Ø›mel;æ„·cy;ä‘“È€;EajÙšâ„Œâ„â„;æª’;æª¥;æª¤È€Eaesâ„›â„â„©â„´;æ‰©pÄ€;pâ„£â„¤æªŠroxÂ»â„¤Ä€;qâ„®â„¯æªˆÄ€;qâ„®â„›im;æ‹§pf;ì€€ğ•˜Ä€ciâ…ƒâ…†r;æ„ŠmÆ€;elÙ«â…â…;æª;æªèŒ€>;cdlqr×®â… â…ªâ…®â…³â…¹Ä€ciâ…¥â…§;æª§r;æ©ºot;æ‹—Par;æ¦•uest;æ©¼Ê€adelsâ†„â…ªâ†Ù–â†›Ç°â†‰\0â†proÃ¸â‚r;æ¥¸qÄ€lqØ¿â†–lesÃ³â‚ˆiÃ­Ù«Ä€enâ†£â†­rtneqq;ì€€â‰©ï¸€Ã…â†ªÔ€Aabcefkosyâ‡„â‡‡â‡±â‡µâ‡ºâˆ˜âˆâˆ¯â‰¨â‰½rÃ²Î È€ilmrâ‡â‡”â‡—â‡›rsÃ°á’„fÂ»â€¤ilÃ´Ú©Ä€drâ‡ â‡¤cy;ä‘ŠÆ€;cwà£´â‡«â‡¯ir;æ¥ˆ;æ†­ar;æ„irc;ä„¥Æ€alrâˆâˆâˆ“rtsÄ€;uâˆ‰âˆŠæ™¥itÂ»âˆŠlip;æ€¦con;æŠ¹r;ì€€ğ”¥sÄ€ewâˆ£âˆ©arow;æ¤¥arow;æ¤¦Ê€amoprâˆºâˆ¾â‰ƒâ‰â‰£rr;æ‡¿tht;æˆ»kÄ€lrâ‰‰â‰“eftarrow;æ†©ightarrow;æ†ªf;ì€€ğ•™bar;æ€•Æ€cltâ‰¯â‰´â‰¸r;ì€€ğ’½asÃ¨â‡´rok;ä„§Ä€bpâŠ‚âŠ‡ull;æƒhenÂ»á±›à«¡âŠ£\0âŠª\0âŠ¸â‹…â‹\0â‹•â‹³\0\0â‹¸âŒ¢â§â¢â¿\0â†âªâ´cuteè€»Ã­äƒ­Æ€;iyİ±âŠ°âŠµrcè€»Ã®äƒ®;ä¸Ä€cxâŠ¼âŠ¿y;äµclè€»Â¡ä‚¡Ä€frÎŸâ‹‰;ì€€ğ”¦raveè€»Ã¬äƒ¬È€;inoÜ¾â‹â‹©â‹®Ä€inâ‹¢â‹¦nt;æ¨Œt;æˆ­fin;æ§œta;æ„©lig;ä„³Æ€aopâ‹¾âŒšâŒÆ€cgtâŒ…âŒˆâŒ—r;ä„«Æ€elpÜŸâŒâŒ“inÃ¥ŞarÃ´Ü h;ä„±f;æŠ·ed;ä†µÊ€;cfotÓ´âŒ¬âŒ±âŒ½âare;æ„…inÄ€;tâŒ¸âŒ¹æˆie;æ§doÃ´âŒ™Ê€;celpİ—âŒââ›â¡al;æŠºÄ€grâ•â™erÃ³á•£Ã£âarhk;æ¨—rod;æ¨¼È€cgptâ¯â²â¶â»y;ä‘‘on;ä„¯f;ì€€ğ•ša;ä¹uestè€»Â¿ä‚¿Ä€ciâŠâr;ì€€ğ’¾nÊ€;EdsvÓ´â›ââ¡Ó³;æ‹¹ot;æ‹µÄ€;vâ¦â§æ‹´;æ‹³Ä€;iİ·â®lde;ä„©Ç«â¸\0â¼cy;ä‘–lè€»Ã¯äƒ¯Ì€cfmosuâŒâ—âœâ¡â§âµÄ€iyâ‘â•rc;ä„µ;ä¹r;ì€€ğ”§ath;äˆ·pf;ì€€ğ•›Ç£â¬\0â±r;ì€€ğ’¿rcy;ä‘˜kcy;ä‘”Ğ€acfghjosâ‹â–â¢â§â­â±âµâ»ppaÄ€;vâ“â”äº;ä°Ä€eyâ›â dil;ä„·;äºr;ì€€ğ”¨reen;ä„¸cy;ä‘…cy;ä‘œpf;ì€€ğ•œcr;ì€€ğ“€à®€ABEHabcdefghjlmnoprstuvâ‘°â’â’†â’â’‘â”â”½â•šâ–€â™â™â™¥â™¹â™½âššâš²â›˜ââ¨â‹âŸ€â â ’Æ€artâ‘·â‘ºâ‘¼rÃ²à§†Ã²Î•ail;æ¤›arr;æ¤Ä€;gà¦”â’‹;æª‹ar;æ¥¢à¥£â’¥\0â’ª\0â’±\0\0\0\0\0â’µâ’º\0â“†â“ˆâ“\0â“¹ute;ä„ºmptyv;æ¦´raÃ®à¡Œbda;ä»gÆ€;dlà¢â“â“ƒ;æ¦‘Ã¥à¢;æª…uoè€»Â«ä‚«rĞ€;bfhlpstà¢™â“â“¦â“©â“«â“®â“±â“µÄ€;fà¢â“£s;æ¤Ÿs;æ¤Ã«â‰’p;æ†«l;æ¤¹im;æ¥³l;æ†¢Æ€;aeâ“¿â”€â”„æª«il;æ¤™Ä€;sâ”‰â”Šæª­;ì€€âª­ï¸€Æ€abrâ”•â”™â”rr;æ¤Œrk;æ²Ä€akâ”¢â”¬cÄ€ekâ”¨â”ª;ä»;ä›Ä€esâ”±â”³;æ¦‹lÄ€duâ”¹â”»;æ¦;æ¦È€aeuyâ•†â•‹â•–â•˜ron;ä„¾Ä€diâ•â•”il;ä„¼Ã¬à¢°Ã¢â”©;ä»È€cqrsâ•£â•¦â•­â•½a;æ¤¶uoÄ€;rà¸™á†Ä€duâ•²â•·har;æ¥§shar;æ¥‹h;æ†²Ê€;fgqsâ–‹â–Œà¦‰â—³â—¿æ‰¤tÊ€ahlrtâ–˜â–¤â–·â—‚â—¨rrowÄ€;tà¢™â–¡aÃ©â“¶arpoonÄ€duâ–¯â–´ownÂ»ÑšpÂ»à¥¦eftarrows;æ‡‡ightÆ€ahsâ—â—–â—rrowÄ€;sà£´à¢§arpoonÃ³à¾˜quigarroÃ·â‡°hreetimes;æ‹‹Æ€;qsâ–‹à¦“â—ºlanÃ´à¦¬Ê€;cdgsà¦¬â˜Šâ˜â˜â˜¨c;æª¨otÄ€;oâ˜”â˜•æ©¿Ä€;râ˜šâ˜›æª;æªƒÄ€;eâ˜¢â˜¥ì€€â‹šï¸€s;æª“Ê€adegsâ˜³â˜¹â˜½â™‰â™‹pproÃ¸â“†ot;æ‹–qÄ€gqâ™ƒâ™…Ã´à¦‰gtÃ²â’ŒÃ´à¦›iÃ­à¦²Æ€ilrâ™•à£¡â™šsht;æ¥¼;ì€€ğ”©Ä€;Eà¦œâ™£;æª‘Å¡â™©â™¶rÄ€duâ–²â™®Ä€;là¥¥â™³;æ¥ªlk;æ–„cy;ä‘™Ê€;achtà©ˆâšˆâš‹âš‘âš–rÃ²â—orneÃ²á´ˆard;æ¥«ri;æ—ºÄ€ioâšŸâš¤dot;ä…€ustÄ€;aâš¬âš­æ°cheÂ»âš­È€Eaesâš»âš½â›‰â›”;æ‰¨pÄ€;pâ›ƒâ›„æª‰roxÂ»â›„Ä€;qâ›â›æª‡Ä€;qâ›âš»im;æ‹¦Ğ€abnoptwzâ›©â›´â›·âœšâœ¯ââ‡âÄ€nrâ›®â›±g;æŸ¬r;æ‡½rÃ«à£gÆ€lmrâ›¿âœâœ”eftÄ€arà§¦âœ‡ightÃ¡à§²apsto;æŸ¼ightÃ¡à§½parrowÄ€lrâœ¥âœ©efÃ´â“­ight;æ†¬Æ€aflâœ¶âœ¹âœ½r;æ¦…;ì€€ğ•us;æ¨­imes;æ¨´Å¡â‹âst;æˆ—Ã¡áÆ€;efâ—â˜á €æ—ŠngeÂ»â˜arÄ€;lâ¤â¥ä€¨t;æ¦“Ê€achmtâ³â¶â¼â…â‡rÃ²à¢¨orneÃ²á¶ŒarÄ€;dà¾˜âƒ;æ¥­;æ€ri;æŠ¿Ì€achiqtâ˜âà©€â¢â®â»quo;æ€¹r;ì€€ğ“mÆ€;egà¦²âªâ¬;æª;æªÄ€buâ”ªâ³oÄ€;rà¸Ÿâ¹;æ€šrok;ä…‚è€<;cdhilqrà «âŸ’â˜¹âŸœâŸ âŸ¥âŸªâŸ°Ä€ciâŸ—âŸ™;æª¦r;æ©¹reÃ¥â—²mes;æ‹‰arr;æ¥¶uest;æ©»Ä€PiâŸµâŸ¹ar;æ¦–Æ€;efâ €à¤­á ›æ—ƒrÄ€duâ ‡â shar;æ¥Šhar;æ¥¦Ä€enâ —â ¡rtneqq;ì€€â‰¨ï¸€Ã…â Ü€Dacdefhilnopsuâ¡€â¡…â¢‚â¢â¢“â¢ â¢¥â¢¨â£šâ£¢â£¤àªƒâ£³â¤‚Dot;æˆºÈ€clprâ¡â¡’â¡£â¡½rè€»Â¯ä‚¯Ä€etâ¡—â¡™;æ™‚Ä€;eâ¡â¡Ÿæœ seÂ»â¡ŸÄ€;sá€»â¡¨toÈ€;dluá€»â¡³â¡·â¡»owÃ®ÒŒefÃ´à¤Ã°á‘ker;æ–®Ä€oyâ¢‡â¢Œmma;æ¨©;ä¼ash;æ€”asuredangleÂ»á˜¦r;ì€€ğ”ªo;æ„§Æ€cdnâ¢¯â¢´â£‰roè€»Âµä‚µÈ€;acdá‘¤â¢½â£€â£„sÃ´áš§ir;æ«°otè‚»Â·ÆµusÆ€;bdâ£’á¤ƒâ£“æˆ’Ä€;uá´¼â£˜;æ¨ªÅ£â£â£¡p;æ«›Ã²âˆ’Ã°àªÄ€dpâ£©â£®els;æŠ§f;ì€€ğ•Ä€ctâ£¸â£½r;ì€€ğ“‚posÂ»á–Æ€;lmâ¤‰â¤Šâ¤ä¼timap;æŠ¸à°€GLRVabcdefghijlmoprstuvwâ¥‚â¥“â¥¾â¦‰â¦˜â§šâ§©â¨•â¨šâ©˜â©âªƒâª•âª¤âª¨â¬„â¬‡â­„â­¿â®®â°´â±§â±¼â³©Ä€gtâ¥‡â¥‹;ì€€â‹™Ì¸Ä€;vâ¥à¯ì€€â‰«âƒ’Æ€eltâ¥šâ¥²â¥¶ftÄ€arâ¥¡â¥§rrow;æ‡ightarrow;æ‡;ì€€â‹˜Ì¸Ä€;vâ¥»à±‡ì€€â‰ªâƒ’ightarrow;æ‡Ä€Ddâ¦â¦“ash;æŠ¯ash;æŠ®Ê€bcnptâ¦£â¦§â¦¬â¦±â§ŒlaÂ»Ëute;ä…„g;ì€€âˆ âƒ’Ê€;Eiopà¶„â¦¼â§€â§…â§ˆ;ì€€â©°Ì¸d;ì€€â‰‹Ì¸s;ä…‰roÃ¸à¶„urÄ€;aâ§“â§”æ™®lÄ€;sâ§“à¬¸Ç³â§Ÿ\0â§£pè‚»Â à¬·mpÄ€;eà¯¹à°€Ê€aeouyâ§´â§¾â¨ƒâ¨â¨“Ç°â§¹\0â§»;æ©ƒon;ä…ˆdil;ä…†ngÄ€;dàµ¾â¨Šot;ì€€â©­Ì¸p;æ©‚;ä½ash;æ€“Î€;Aadqsxà®’â¨©â¨­â¨»â©â©…â©rr;æ‡—rÄ€hrâ¨³â¨¶k;æ¤¤Ä€;oá²á°ot;ì€€â‰Ì¸uiÃ¶à­£Ä€eiâ©Šâ©ar;æ¤¨Ã­à®˜istÄ€;sà® à®Ÿr;ì€€ğ”«È€Eestà¯…â©¦â©¹â©¼Æ€;qsà®¼â©­à¯¡Æ€;qsà®¼à¯…â©´lanÃ´à¯¢iÃ­à¯ªÄ€;rà®¶âªÂ»à®·Æ€AapâªŠâªâª‘rÃ²â¥±rr;æ†®ar;æ«²Æ€;svà¾âªœà¾ŒÄ€;dâª¡âª¢æ‹¼;æ‹ºcy;ä‘šÎ€AEadestâª·âªºâª¾â«‚â«…â«¶â«¹rÃ²â¥¦;ì€€â‰¦Ì¸rr;æ†šr;æ€¥È€;fqsà°»â«â«£â«¯tÄ€arâ«”â«™rroÃ·â«ightarroÃ·âªÆ€;qsà°»âªºâ«ªlanÃ´à±•Ä€;sà±•â«´Â»à°¶iÃ­à±Ä€;rà°µâ«¾iÄ€;eà°šà°¥iÃ¤à¶Ä€ptâ¬Œâ¬‘f;ì€€ğ•Ÿè†€Â¬;inâ¬™â¬šâ¬¶ä‚¬nÈ€;Edvà®‰â¬¤â¬¨â¬®;ì€€â‹¹Ì¸ot;ì€€â‹µÌ¸Ç¡à®‰â¬³â¬µ;æ‹·;æ‹¶iÄ€;và²¸â¬¼Ç¡à²¸â­â­ƒ;æ‹¾;æ‹½Æ€aorâ­‹â­£â­©rÈ€;astà­»â­•â­šâ­ŸlleÃ¬à­»l;ì€€â«½âƒ¥;ì€€âˆ‚Ì¸lint;æ¨”Æ€;ceà²’â­°â­³uÃ¥à²¥Ä€;cà²˜â­¸Ä€;eà²’â­½Ã±à²˜È€Aaitâ®ˆâ®‹â®â®§rÃ²â¦ˆrrÆ€;cwâ®”â®•â®™æ†›;ì€€â¤³Ì¸;ì€€â†Ì¸ghtarrowÂ»â®•riÄ€;eà³‹à³–Î€chimpquâ®½â¯â¯™â¬„à­¸â¯¤â¯¯È€;cerà´²â¯†à´·â¯‰uÃ¥àµ…;ì€€ğ“ƒortÉ­â¬…\0\0â¯–arÃ¡â­–mÄ€;eàµ®â¯ŸÄ€;qàµ´àµ³suÄ€bpâ¯«â¯­Ã¥à³¸Ã¥à´‹Æ€bcpâ¯¶â°‘â°™È€;Eesâ¯¿â°€à´¢â°„æŠ„;ì€€â«…Ì¸etÄ€;eà´›â°‹qÄ€;qà´£â°€cÄ€;eà´²â°—Ã±à´¸È€;Eesâ°¢â°£àµŸâ°§æŠ…;ì€€â«†Ì¸etÄ€;eàµ˜â°®qÄ€;qàµ â°£È€gilrâ°½â°¿â±…â±‡Ã¬à¯—ldeè€»Ã±äƒ±Ã§à±ƒiangleÄ€lrâ±’â±œeftÄ€;eà°šâ±šÃ±à°¦ightÄ€;eà³‹â±¥Ã±à³—Ä€;mâ±¬â±­ä½Æ€;esâ±´â±µâ±¹ä€£ro;æ„–p;æ€‡Ò€DHadgilrsâ²â²”â²™â²â²£â²°â²¶â³“â³£ash;æŠ­arr;æ¤„p;ì€€â‰âƒ’ash;æŠ¬Ä€etâ²¨â²¬;ì€€â‰¥âƒ’;ì€€>âƒ’nfin;æ§Æ€Aetâ²½â³â³…rr;æ¤‚;ì€€â‰¤âƒ’Ä€;râ³Šâ³ì€€<âƒ’ie;ì€€âŠ´âƒ’Ä€Atâ³˜â³œrr;æ¤ƒrie;ì€€âŠµâƒ’im;ì€€âˆ¼âƒ’Æ€Aanâ³°â³´â´‚rr;æ‡–rÄ€hrâ³ºâ³½k;æ¤£Ä€;oá§á¥ear;æ¤§á‰“áª•\0\0\0\0\0\0\0\0\0\0\0\0\0â´­\0â´¸âµˆâµ âµ¥âµ²â¶„á¬‡\0\0â¶â¶«\0â·ˆâ·\0â·œâ¸™â¸«â¸¾â¹ƒÄ€csâ´±áª—uteè€»Ã³äƒ³Ä€iyâ´¼âµ…rÄ€;cáªâµ‚è€»Ã´äƒ´;ä¾Ê€abiosáª âµ’âµ—Çˆâµšlac;ä…‘v;æ¨¸old;æ¦¼lig;ä…“Ä€crâµ©âµ­ir;æ¦¿;ì€€ğ”¬Í¯âµ¹\0\0âµ¼\0â¶‚n;ä‹›aveè€»Ã²äƒ²;æ§Ä€bmâ¶ˆà·´ar;æ¦µÈ€acitâ¶•â¶˜â¶¥â¶¨rÃ²áª€Ä€irâ¶â¶ r;æ¦¾oss;æ¦»nÃ¥à¹’;æ§€Æ€aeiâ¶±â¶µâ¶¹cr;ä…ga;ä‰Æ€cdnâ·€â·…Çron;ä¿;æ¦¶pf;ì€€ğ• Æ€aelâ·”â·—Ç’r;æ¦·rp;æ¦¹Î€;adiosvâ·ªâ·«â·®â¸ˆâ¸â¸â¸–æˆ¨rÃ²áª†È€;efmâ··â·¸â¸‚â¸…æ©rÄ€;oâ·¾â·¿æ„´fÂ»â·¿è€»Âªä‚ªè€»Âºä‚ºgof;æŠ¶r;æ©–lope;æ©—;æ©›Æ€cloâ¸Ÿâ¸¡â¸§Ã²â¸ashè€»Ã¸äƒ¸l;æŠ˜iÅ¬â¸¯â¸´deè€»ÃµäƒµesÄ€;aÇ›â¸ºs;æ¨¶mlè€»Ã¶äƒ¶bar;æŒ½à«¡â¹\0â¹½\0âº€âº\0âº¢âº¹\0\0â»‹àºœ\0â¼“\0\0â¼«â¾¼\0â¿ˆrÈ€;astĞƒâ¹§â¹²àº…è„€Â¶;lâ¹­â¹®ä‚¶leÃ¬ĞƒÉ©â¹¸\0\0â¹»m;æ«³;æ«½y;ä¿rÊ€cimptâº‹âºâº“á¡¥âº—nt;ä€¥od;ä€®il;æ€°enk;æ€±r;ì€€ğ”­Æ€imoâº¨âº°âº´Ä€;vâº­âº®ä†;ä•maÃ´à©¶ne;æ˜Æ€;tvâº¿â»€â»ˆä€chforkÂ»á¿½;ä–Ä€auâ»â»ŸnÄ€ckâ»•â»kÄ€;hâ‡´â»›;æ„Ã¶â‡´sÒ€;abcdemstâ»³â»´á¤ˆâ»¹â»½â¼„â¼†â¼Šâ¼ä€«cir;æ¨£ir;æ¨¢Ä€ouáµ€â¼‚;æ¨¥;æ©²nè‚»Â±àºim;æ¨¦wo;æ¨§Æ€ipuâ¼™â¼ â¼¥ntint;æ¨•f;ì€€ğ•¡ndè€»Â£ä‚£Ô€;Eaceinosuà»ˆâ¼¿â½â½„â½‡â¾â¾‰â¾’â½¾â¾¶;æª³p;æª·uÃ¥à»™Ä€;cà»â½ŒÌ€;acensà»ˆâ½™â½Ÿâ½¦â½¨â½¾pproÃ¸â½ƒurlyeÃ±à»™Ã±à»Æ€aesâ½¯â½¶â½ºpprox;æª¹qq;æªµim;æ‹¨iÃ­à»ŸmeÄ€;sâ¾ˆàº®æ€²Æ€Easâ½¸â¾â½ºÃ°â½µÆ€dfpà»¬â¾™â¾¯Æ€alsâ¾ â¾¥â¾ªlar;æŒ®ine;æŒ’urf;æŒ“Ä€;tà»»â¾´Ã¯à»»rel;æŠ°Ä€ciâ¿€â¿…r;ì€€ğ“…;äˆncsp;æ€ˆÌ€fiopsuâ¿šâ‹¢â¿Ÿâ¿¥â¿«â¿±r;ì€€ğ”®pf;ì€€ğ•¢rime;æ—cr;ì€€ğ“†Æ€aeoâ¿¸ã€‰ã€“tÄ€eiâ¿¾ã€…rnionÃ³Ú°nt;æ¨–stÄ€;eã€ã€‘ä€¿Ã±á¼™Ã´à¼”àª€ABHabcdefhilmnoprstuxã€ã‘ã•ã™ãƒ ã„ã„«ã…‡ã…¢ã…²ã†ãˆ†ãˆ•ãˆ¤ãˆ©ã‰˜ã‰®ã‰²ãŠãŠ°ãŠ·Æ€artã‡ãŠãŒrÃ²á‚³Ã²Ïail;æ¤œarÃ²á±¥ar;æ¥¤Î€cdenqrtã¨ãµã¸ã¿ã‚ã‚”ãƒŒÄ€euã­ã±;ì€€âˆ½Ì±te;ä…•iÃ£á…®mptyv;æ¦³gÈ€;delà¿‘ã‚‰ã‚‹ã‚;æ¦’;æ¦¥Ã¥à¿‘uoè€»Â»ä‚»rÖ€;abcfhlpstwà¿œã‚¬ã‚¯ã‚·ã‚¹ã‚¼ã‚¾ãƒ€ãƒƒãƒ‡ãƒŠp;æ¥µÄ€;fà¿ ã‚´s;æ¤ ;æ¤³s;æ¤Ã«â‰Ã°âœ®l;æ¥…im;æ¥´l;æ†£;æ†Ä€aiãƒ‘ãƒ•il;æ¤šoÄ€;nãƒ›ãƒœæˆ¶alÃ³à¼Æ€abrãƒ§ãƒªãƒ®rÃ²áŸ¥rk;æ³Ä€akãƒ³ãƒ½cÄ€ekãƒ¹ãƒ»;ä½;äÄ€esã„‚ã„„;æ¦ŒlÄ€duã„Šã„Œ;æ¦;æ¦È€aeuyã„—ã„œã„§ã„©ron;ä…™Ä€diã„¡ã„¥il;ä…—Ã¬à¿²Ã¢ãƒº;ä‘€È€clqsã„´ã„·ã„½ã…„a;æ¤·dhar;æ¥©uoÄ€;rÈÈh;æ†³Æ€acgã…ã…Ÿà½„lÈ€;ipsà½¸ã…˜ã…›á‚œnÃ¥á‚»arÃ´à¾©t;æ–­Æ€ilrã…©á€£ã…®sht;æ¥½;ì€€ğ”¯Ä€aoã…·ã††rÄ€duã…½ã…¿Â»Ñ»Ä€;lá‚‘ã†„;æ¥¬Ä€;vã†‹ã†Œä;ä±Æ€gnsã†•ã‡¹ã‡¼htÌ€ahlrstã†¤ã†°ã‡‚ã‡˜ã‡¤ã‡®rrowÄ€;tà¿œã†­aÃ©ãƒˆarpoonÄ€duã†»ã†¿owÃ®ã…¾pÂ»á‚’eftÄ€ahã‡Šã‡rrowÃ³à¿ªarpoonÃ³Õ‘ightarrows;æ‡‰quigarroÃ·ãƒ‹hreetimes;æ‹Œg;ä‹šingdotseÃ±á¼²Æ€ahmãˆãˆãˆ“rÃ²à¿ªaÃ²Õ‘;æ€oustÄ€;aãˆãˆŸæ±cheÂ»ãˆŸmid;æ«®È€abptãˆ²ãˆ½ã‰€ã‰’Ä€nrãˆ·ãˆºg;æŸ­r;æ‡¾rÃ«á€ƒÆ€aflã‰‡ã‰Šã‰r;æ¦†;ì€€ğ•£us;æ¨®imes;æ¨µÄ€apã‰ã‰§rÄ€;gã‰£ã‰¤ä€©t;æ¦”olint;æ¨’arÃ²ã‡£È€achqã‰»ãŠ€á‚¼ãŠ…quo;æ€ºr;ì€€ğ“‡Ä€buãƒ»ãŠŠoÄ€;rÈ”È“Æ€hirãŠ—ãŠ›ãŠ reÃ¥ã‡¸mes;æ‹ŠiÈ€;eflãŠªá™á ¡ãŠ«æ–¹tri;æ§luhar;æ¥¨;æ„àµ¡ã‹•ã‹›ã‹ŸãŒ¬ãŒ¸ã±\0ãºã¤\0\0ã¬ã°\0ã¨ã‘ˆã‘šã’­ã’±ã“Šã“±\0ã˜–\0\0ã˜³cute;ä…›quÃ¯âºÔ€;Eaceinpsyá‡­ã‹³ã‹µã‹¿ãŒ‚ãŒ‹ãŒãŒŸãŒ¦ãŒ©;æª´Ç°ã‹º\0ã‹¼;æª¸on;ä…¡uÃ¥á‡¾Ä€;dá‡³ãŒ‡il;ä…Ÿrc;ä…Æ€EasãŒ–ãŒ˜ãŒ›;æª¶p;æªºim;æ‹©olint;æ¨“iÃ­áˆ„;ä‘otÆ€;beãŒ´áµ‡ãŒµæ‹…;æ©¦Î€Aacmstxã†ãŠã—ã›ãã£ã­rr;æ‡˜rÄ€hrãã’Ã«âˆ¨Ä€;oà¨¶à¨´tè€»Â§ä‚§i;ä€»war;æ¤©mÄ€inã©Ã°nuÃ³Ã±t;æœ¶rÄ€;oã¶â•ì€€ğ”°È€acoyã‚ã†ã‘ã rp;æ™¯Ä€hyã‹ãcy;ä‘‰;ä‘ˆrtÉ­ã™\0\0ãœiÃ¤á‘¤araÃ¬â¹¯è€»Â­ä‚­Ä€gmã¨ã´maÆ€;fvã±ã²ã²äƒ;ä‚Ğ€;deglnpráŠ«ã…ã‰ãã–ãã¡ã¦ot;æ©ªÄ€;qáŠ±áŠ°Ä€;Eã“ã”æª;æª Ä€;Eã›ãœæª;æªŸe;æ‰†lus;æ¨¤arr;æ¥²arÃ²á„½È€aeitã¸ãˆãã—Ä€lsã½ã„lsetmÃ©ãªhp;æ¨³parsl;æ§¤Ä€dlá‘£ã”e;æŒ£Ä€;eãœãæªªÄ€;sã¢ã£æª¬;ì€€âª¬ï¸€Æ€flpã®ã³ã‘‚tcy;ä‘ŒÄ€;bã¸ã¹ä€¯Ä€;aã¾ã¿æ§„r;æŒ¿f;ì€€ğ•¤aÄ€drã‘Ğ‚esÄ€;uã‘”ã‘•æ™ itÂ»ã‘•Æ€csuã‘ ã‘¹ã’ŸÄ€auã‘¥ã‘¯pÄ€;sá†ˆã‘«;ì€€âŠ“ï¸€pÄ€;sá†´ã‘µ;ì€€âŠ”ï¸€uÄ€bpã‘¿ã’Æ€;esá†—á†œã’†etÄ€;eá†—ã’Ã±á†Æ€;esá†¨á†­ã’–etÄ€;eá†¨ã’Ã±á†®Æ€;afá…»ã’¦Ö°rÅ¥ã’«Ö±Â»á…¼arÃ²á…ˆÈ€cemtã’¹ã’¾ã“‚ã“…r;ì€€ğ“ˆtmÃ®Ã±iÃ¬ã•arÃ¦á†¾Ä€arã“ã“•rÄ€;fã“”á¿æ˜†Ä€anã“šã“­ightÄ€epã“£ã“ªpsiloÃ®á» hÃ©âº¯sÂ»â¡’Ê€bcmnpã“»ã•áˆ‰ã–‹ã–Ò€;Edemnprsã”ã”ã”‘ã”•ã”ã”£ã”¬ã”±ã”¶æŠ‚;æ«…ot;æª½Ä€;dá‡šã”šot;æ«ƒult;æ«Ä€Eeã”¨ã”ª;æ«‹;æŠŠlus;æª¿arr;æ¥¹Æ€eiuã”½ã•’ã••tÆ€;enã”ã•…ã•‹qÄ€;qá‡šã”eqÄ€;qã”«ã”¨m;æ«‡Ä€bpã•šã•œ;æ«•;æ«“cÌ€;acensá‡­ã•¬ã•²ã•¹ã•»ãŒ¦pproÃ¸ã‹ºurlyeÃ±á‡¾Ã±á‡³Æ€aesã–‚ã–ˆãŒ›pproÃ¸ãŒšqÃ±ãŒ—g;æ™ªÚ€123;Edehlmnpsã–©ã–¬ã–¯áˆœã–²ã–´ã—€ã—‰ã—•ã—šã—Ÿã—¨ã—­è€»Â¹ä‚¹è€»Â²ä‚²è€»Â³ä‚³;æ«†Ä€osã–¹ã–¼t;æª¾ub;æ«˜Ä€;dáˆ¢ã—…ot;æ«„sÄ€ouã—ã—’l;æŸ‰b;æ«—arr;æ¥»ult;æ«‚Ä€Eeã—¤ã—¦;æ«Œ;æŠ‹lus;æ«€Æ€eiuã—´ã˜‰ã˜ŒtÆ€;enáˆœã—¼ã˜‚qÄ€;qáˆ¢ã–²eqÄ€;qã—§ã—¤m;æ«ˆÄ€bpã˜‘ã˜“;æ«”;æ«–Æ€Aanã˜œã˜ ã˜­rr;æ‡™rÄ€hrã˜¦ã˜¨Ã«âˆ®Ä€;oà¨«à¨©war;æ¤ªligè€»ÃŸäƒŸà¯¡ã™‘ã™ã™ á‹ã™³ã™¹\0ã™¾ã›‚\0\0\0\0\0ã››ãœƒ\0ãœ‰ã¬\0\0\0ã‡É²ã™–\0\0ã™›get;æŒ–;ä„rÃ«à¹ŸÆ€aeyã™¦ã™«ã™°ron;ä…¥dil;ä…£;ä‘‚lrec;æŒ•r;ì€€ğ”±È€eikoãš†ãšãšµãš¼Ç²ãš‹\0ãš‘eÄ€4fáŠ„áŠaÆ€;svãš˜ãš™ãš›ä¸ym;ä‘Ä€cnãš¢ãš²kÄ€asãš¨ãš®pproÃ¸á‹imÂ»áŠ¬sÃ°áŠÄ€asãšºãš®Ã°á‹rnè€»Ã¾äƒ¾Ç¬ÌŸã›†â‹§esè†€Ã—;bdã›ã›ã›˜äƒ—Ä€;aá¤ã›•r;æ¨±;æ¨°Æ€epsã›¡ã›£ãœ€Ã¡â©È€;bcfÒ†ã›¬ã›°ã›´ot;æŒ¶ir;æ«±Ä€;oã›¹ã›¼ì€€ğ•¥rk;æ«šÃ¡ã¢rime;æ€´Æ€aipãœãœ’ã¤dÃ¥á‰ˆÎ€adempstãœ¡ãã€ã‘ã—ãœãŸngleÊ€;dlqrãœ°ãœ±ãœ¶ã€ã‚æ–µownÂ»á¶»eftÄ€;eâ €ãœ¾Ã±à¤®;æ‰œightÄ€;eãŠªã‹Ã±ášot;æ—¬inus;æ¨ºlus;æ¨¹b;æ§ime;æ¨»ezium;æ¢Æ€chtã²ã½ãÄ€ryã·ã»;ì€€ğ“‰;ä‘†cy;ä‘›rok;ä…§Ä€ioã‹ãxÃ´á·headÄ€lrã—ã eftarroÃ·à¡ightarrowÂ»à½à¤€AHabcdfghlmoprstuwãŸãŸ“ãŸ—ãŸ¤ãŸ°ãŸ¼ã ã œã £ã ´ã¡‘ã¡ã¡«ã¢©ã£Œã£’ã£ªã£¶rÃ²Ï­ar;æ¥£Ä€crãŸœãŸ¢uteè€»ÃºäƒºÃ²á…rÇ£ãŸª\0ãŸ­y;ä‘ve;ä…­Ä€iyãŸµãŸºrcè€»Ã»äƒ»;ä‘ƒÆ€abhã ƒã †ã ‹rÃ²á­lac;ä…±aÃ²áƒÄ€irã “ã ˜sht;æ¥¾;ì€€ğ”²raveè€»Ã¹äƒ¹Å¡ã §ã ±rÄ€lrã ¬ã ®Â»à¥—Â»á‚ƒlk;æ–€Ä€ctã ¹ã¡É¯ã ¿\0\0ã¡ŠrnÄ€;eã¡…ã¡†æŒœrÂ»ã¡†op;æŒri;æ—¸Ä€alã¡–ã¡šcr;ä…«è‚»Â¨Í‰Ä€gpã¡¢ã¡¦on;ä…³f;ì€€ğ•¦Ì€adhlsuá…‹ã¡¸ã¡½á²ã¢‘ã¢ ownÃ¡á³arpoonÄ€lrã¢ˆã¢ŒefÃ´ã ­ighÃ´ã ¯iÆ€;hlã¢™ã¢šã¢œä…Â»áºonÂ»ã¢šparrows;æ‡ˆÆ€citã¢°ã£„ã£ˆÉ¯ã¢¶\0\0ã£rnÄ€;eã¢¼ã¢½æŒrÂ»ã¢½op;æŒng;ä…¯ri;æ—¹cr;ì€€ğ“ŠÆ€dirã£™ã£ã£¢ot;æ‹°lde;ä…©iÄ€;fãœ°ã£¨Â»á “Ä€amã£¯ã£²rÃ²ã¢¨lè€»Ã¼äƒ¼angle;æ¦§Ş€ABDacdeflnoprszã¤œã¤Ÿã¤©ã¤­ã¦µã¦¸ã¦½ã§Ÿã§¤ã§¨ã§³ã§¹ã§½ã¨ã¨ rÃ²Ï·arÄ€;vã¤¦ã¤§æ«¨;æ«©asÃ¨Ï¡Ä€nrã¤²ã¤·grt;æ¦œÎ€eknprstã“£ã¥†ã¥‹ã¥’ã¥ã¥¤ã¦–appÃ¡â•othinÃ§áº–Æ€hirã“«â»ˆã¥™opÃ´â¾µÄ€;há·ã¥¢Ã¯ã†Ä€iuã¥©ã¥­gmÃ¡ã³Ä€bpã¥²ã¦„setneqÄ€;qã¥½ã¦€ì€€âŠŠï¸€;ì€€â«‹ï¸€setneqÄ€;qã¦ã¦’ì€€âŠ‹ï¸€;ì€€â«Œï¸€Ä€hrã¦›ã¦ŸetÃ¡ãšœiangleÄ€lrã¦ªã¦¯eftÂ»à¤¥ightÂ»á‘y;ä²ashÂ»á€¶Æ€elrã§„ã§’ã§—Æ€;beâ·ªã§‹ã§ar;æŠ»q;æ‰šlip;æ‹®Ä€btã§œá‘¨aÃ²á‘©r;ì€€ğ”³trÃ©ã¦®suÄ€bpã§¯ã§±Â»à´œÂ»àµ™pf;ì€€ğ•§roÃ°à»»trÃ©ã¦´Ä€cuã¨†ã¨‹r;ì€€ğ“‹Ä€bpã¨ã¨˜nÄ€Eeã¦€ã¨–Â»ã¥¾nÄ€Eeã¦’ã¨Â»ã¦igzag;æ¦šÎ€cefoprsã¨¶ã¨»ã©–ã©›ã©”ã©¡ã©ªirc;ä…µÄ€diã©€ã©‘Ä€bgã©…ã©‰ar;æ©ŸeÄ€;qá—ºã©;æ‰™erp;æ„˜r;ì€€ğ”´pf;ì€€ğ•¨Ä€;eá‘¹ã©¦atÃ¨á‘¹cr;ì€€ğ“Œà«£áãª‡\0ãª‹\0ãªãª›\0\0ãªãª¨ãª«ãª¯\0\0ã«ƒã«\0ã«˜áŸœáŸŸtrÃ©áŸ‘r;ì€€ğ”µÄ€Aaãª”ãª—rÃ²ÏƒrÃ²à§¶;ä¾Ä€Aaãª¡ãª¤rÃ²Î¸rÃ²à§«aÃ°âœ“is;æ‹»Æ€dptá¤ãªµãª¾Ä€flãªºá©;ì€€ğ•©imÃ¥á²Ä€Aaã«‡ã«ŠrÃ²ÏrÃ²à¨Ä€cqã«’á¸r;ì€€ğ“Ä€ptáŸ–ã«œrÃ©áŸ”Ğ€acefiosuã«°ã«½ã¬ˆã¬Œã¬‘ã¬•ã¬›ã¬¡cÄ€uyã«¶ã«»teè€»Ã½äƒ½;ä‘Ä€iyã¬‚ã¬†rc;ä…·;ä‘‹nè€»Â¥ä‚¥r;ì€€ğ”¶cy;ä‘—pf;ì€€ğ•ªcr;ì€€ğ“Ä€cmã¬¦ã¬©y;ä‘lè€»Ã¿äƒ¿Ô€acdefhioswã­‚ã­ˆã­”ã­˜ã­¤ã­©ã­­ã­´ã­ºã®€cute;ä…ºÄ€ayã­ã­’ron;ä…¾;ä·ot;ä…¼Ä€etã­ã­¡trÃ¦á•Ÿa;ä¶r;ì€€ğ”·cy;ä¶grarr;æ‡pf;ì€€ğ•«cr;ì€€ğ“Ä€jnã®…ã®‡;æ€j;æ€Œ'.split("").map(function(c2) {
        return c2.charCodeAt(0);
      })
    );
  }
});

// node_modules/entities/lib/generated/decode-data-xml.js
var require_decode_data_xml = __commonJS({
  "node_modules/entities/lib/generated/decode-data-xml.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new Uint16Array(
      // prettier-ignore
      "È€aglq	\x1BÉ­\0\0p;ä€¦os;ä€§t;ä€¾t;ä€¼uot;ä€¢".split("").map(function(c2) {
        return c2.charCodeAt(0);
      })
    );
  }
});

// node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint = __commonJS({
  "node_modules/entities/lib/decode_codepoint.js"(exports) {
    "use strict";
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.replaceCodePoint = exports.fromCodePoint = void 0;
    var decodeMap = /* @__PURE__ */ new Map([
      [0, 65533],
      // C1 Unicode control character reference replacements
      [128, 8364],
      [130, 8218],
      [131, 402],
      [132, 8222],
      [133, 8230],
      [134, 8224],
      [135, 8225],
      [136, 710],
      [137, 8240],
      [138, 352],
      [139, 8249],
      [140, 338],
      [142, 381],
      [145, 8216],
      [146, 8217],
      [147, 8220],
      [148, 8221],
      [149, 8226],
      [150, 8211],
      [151, 8212],
      [152, 732],
      [153, 8482],
      [154, 353],
      [155, 8250],
      [156, 339],
      [158, 382],
      [159, 376]
    ]);
    exports.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
    (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
      var output = "";
      if (codePoint > 65535) {
        codePoint -= 65536;
        output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      output += String.fromCharCode(codePoint);
      return output;
    };
    function replaceCodePoint(codePoint) {
      var _a2;
      if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
        return 65533;
      }
      return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
    }
    exports.replaceCodePoint = replaceCodePoint;
    function decodeCodePoint(codePoint) {
      return (0, exports.fromCodePoint)(replaceCodePoint(codePoint));
    }
    exports.default = decodeCodePoint;
  }
});

// node_modules/entities/lib/decode.js
var require_decode = __commonJS({
  "node_modules/entities/lib/decode.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeXML = exports.decodeHTMLStrict = exports.decodeHTMLAttribute = exports.decodeHTML = exports.determineBranch = exports.EntityDecoder = exports.DecodingMode = exports.BinTrieFlags = exports.fromCodePoint = exports.replaceCodePoint = exports.decodeCodePoint = exports.xmlDecodeTree = exports.htmlDecodeTree = void 0;
    var decode_data_html_js_1 = __importDefault(require_decode_data_html());
    exports.htmlDecodeTree = decode_data_html_js_1.default;
    var decode_data_xml_js_1 = __importDefault(require_decode_data_xml());
    exports.xmlDecodeTree = decode_data_xml_js_1.default;
    var decode_codepoint_js_1 = __importStar(require_decode_codepoint());
    exports.decodeCodePoint = decode_codepoint_js_1.default;
    var decode_codepoint_js_2 = require_decode_codepoint();
    Object.defineProperty(exports, "replaceCodePoint", { enumerable: true, get: function() {
      return decode_codepoint_js_2.replaceCodePoint;
    } });
    Object.defineProperty(exports, "fromCodePoint", { enumerable: true, get: function() {
      return decode_codepoint_js_2.fromCodePoint;
    } });
    var CharCodes;
    (function(CharCodes2) {
      CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
      CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
      CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
      CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
      CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
      CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
      CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
      CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
      CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
      CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
      CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
      CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
    })(CharCodes || (CharCodes = {}));
    var TO_LOWER_BIT = 32;
    var BinTrieFlags;
    (function(BinTrieFlags2) {
      BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
      BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
      BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
    })(BinTrieFlags = exports.BinTrieFlags || (exports.BinTrieFlags = {}));
    function isNumber(code) {
      return code >= CharCodes.ZERO && code <= CharCodes.NINE;
    }
    function isHexadecimalCharacter(code) {
      return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
    }
    function isAsciiAlphaNumeric(code) {
      return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
    }
    function isEntityInAttributeInvalidEnd(code) {
      return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
    }
    var EntityDecoderState;
    (function(EntityDecoderState2) {
      EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
      EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
      EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
      EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
      EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
    })(EntityDecoderState || (EntityDecoderState = {}));
    var DecodingMode;
    (function(DecodingMode2) {
      DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
      DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
      DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
    })(DecodingMode = exports.DecodingMode || (exports.DecodingMode = {}));
    var EntityDecoder = (
      /** @class */
      function() {
        function EntityDecoder2(decodeTree, emitCodePoint, errors) {
          this.decodeTree = decodeTree;
          this.emitCodePoint = emitCodePoint;
          this.errors = errors;
          this.state = EntityDecoderState.EntityStart;
          this.consumed = 1;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.decodeMode = DecodingMode.Strict;
        }
        EntityDecoder2.prototype.startEntity = function(decodeMode) {
          this.decodeMode = decodeMode;
          this.state = EntityDecoderState.EntityStart;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.consumed = 1;
        };
        EntityDecoder2.prototype.write = function(str, offset) {
          switch (this.state) {
            case EntityDecoderState.EntityStart: {
              if (str.charCodeAt(offset) === CharCodes.NUM) {
                this.state = EntityDecoderState.NumericStart;
                this.consumed += 1;
                return this.stateNumericStart(str, offset + 1);
              }
              this.state = EntityDecoderState.NamedEntity;
              return this.stateNamedEntity(str, offset);
            }
            case EntityDecoderState.NumericStart: {
              return this.stateNumericStart(str, offset);
            }
            case EntityDecoderState.NumericDecimal: {
              return this.stateNumericDecimal(str, offset);
            }
            case EntityDecoderState.NumericHex: {
              return this.stateNumericHex(str, offset);
            }
            case EntityDecoderState.NamedEntity: {
              return this.stateNamedEntity(str, offset);
            }
          }
        };
        EntityDecoder2.prototype.stateNumericStart = function(str, offset) {
          if (offset >= str.length) {
            return -1;
          }
          if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
            this.state = EntityDecoderState.NumericHex;
            this.consumed += 1;
            return this.stateNumericHex(str, offset + 1);
          }
          this.state = EntityDecoderState.NumericDecimal;
          return this.stateNumericDecimal(str, offset);
        };
        EntityDecoder2.prototype.addToNumericResult = function(str, start, end, base) {
          if (start !== end) {
            var digitCount = end - start;
            this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
            this.consumed += digitCount;
          }
        };
        EntityDecoder2.prototype.stateNumericHex = function(str, offset) {
          var startIdx = offset;
          while (offset < str.length) {
            var char = str.charCodeAt(offset);
            if (isNumber(char) || isHexadecimalCharacter(char)) {
              offset += 1;
            } else {
              this.addToNumericResult(str, startIdx, offset, 16);
              return this.emitNumericEntity(char, 3);
            }
          }
          this.addToNumericResult(str, startIdx, offset, 16);
          return -1;
        };
        EntityDecoder2.prototype.stateNumericDecimal = function(str, offset) {
          var startIdx = offset;
          while (offset < str.length) {
            var char = str.charCodeAt(offset);
            if (isNumber(char)) {
              offset += 1;
            } else {
              this.addToNumericResult(str, startIdx, offset, 10);
              return this.emitNumericEntity(char, 2);
            }
          }
          this.addToNumericResult(str, startIdx, offset, 10);
          return -1;
        };
        EntityDecoder2.prototype.emitNumericEntity = function(lastCp, expectedLength) {
          var _a;
          if (this.consumed <= expectedLength) {
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
          }
          if (lastCp === CharCodes.SEMI) {
            this.consumed += 1;
          } else if (this.decodeMode === DecodingMode.Strict) {
            return 0;
          }
          this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
          if (this.errors) {
            if (lastCp !== CharCodes.SEMI) {
              this.errors.missingSemicolonAfterCharacterReference();
            }
            this.errors.validateNumericCharacterReference(this.result);
          }
          return this.consumed;
        };
        EntityDecoder2.prototype.stateNamedEntity = function(str, offset) {
          var decodeTree = this.decodeTree;
          var current = decodeTree[this.treeIndex];
          var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
          for (; offset < str.length; offset++, this.excess++) {
            var char = str.charCodeAt(offset);
            this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
            if (this.treeIndex < 0) {
              return this.result === 0 || // If we are parsing an attribute
              this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
              (valueLength === 0 || // And there should be no invalid characters.
              isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
            }
            current = decodeTree[this.treeIndex];
            valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
            if (valueLength !== 0) {
              if (char === CharCodes.SEMI) {
                return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
              }
              if (this.decodeMode !== DecodingMode.Strict) {
                this.result = this.treeIndex;
                this.consumed += this.excess;
                this.excess = 0;
              }
            }
          }
          return -1;
        };
        EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function() {
          var _a;
          var _b = this, result = _b.result, decodeTree = _b.decodeTree;
          var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
          this.emitNamedEntityData(result, valueLength, this.consumed);
          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
          return this.consumed;
        };
        EntityDecoder2.prototype.emitNamedEntityData = function(result, valueLength, consumed) {
          var decodeTree = this.decodeTree;
          this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
          if (valueLength === 3) {
            this.emitCodePoint(decodeTree[result + 2], consumed);
          }
          return consumed;
        };
        EntityDecoder2.prototype.end = function() {
          var _a;
          switch (this.state) {
            case EntityDecoderState.NamedEntity: {
              return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
            }
            case EntityDecoderState.NumericDecimal: {
              return this.emitNumericEntity(0, 2);
            }
            case EntityDecoderState.NumericHex: {
              return this.emitNumericEntity(0, 3);
            }
            case EntityDecoderState.NumericStart: {
              (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
              return 0;
            }
            case EntityDecoderState.EntityStart: {
              return 0;
            }
          }
        };
        return EntityDecoder2;
      }()
    );
    exports.EntityDecoder = EntityDecoder;
    function getDecoder(decodeTree) {
      var ret = "";
      var decoder = new EntityDecoder(decodeTree, function(str) {
        return ret += (0, decode_codepoint_js_1.fromCodePoint)(str);
      });
      return function decodeWithTrie(str, decodeMode) {
        var lastIndex = 0;
        var offset = 0;
        while ((offset = str.indexOf("&", offset)) >= 0) {
          ret += str.slice(lastIndex, offset);
          decoder.startEntity(decodeMode);
          var len = decoder.write(
            str,
            // Skip the "&"
            offset + 1
          );
          if (len < 0) {
            lastIndex = offset + decoder.end();
            break;
          }
          lastIndex = offset + len;
          offset = len === 0 ? lastIndex + 1 : lastIndex;
        }
        var result = ret + str.slice(lastIndex);
        ret = "";
        return result;
      };
    }
    function determineBranch(decodeTree, current, nodeIdx, char) {
      var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
      var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
      if (branchCount === 0) {
        return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
      }
      if (jumpOffset) {
        var value = char - jumpOffset;
        return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
      }
      var lo2 = nodeIdx;
      var hi3 = lo2 + branchCount - 1;
      while (lo2 <= hi3) {
        var mid = lo2 + hi3 >>> 1;
        var midVal = decodeTree[mid];
        if (midVal < char) {
          lo2 = mid + 1;
        } else if (midVal > char) {
          hi3 = mid - 1;
        } else {
          return decodeTree[mid + branchCount];
        }
      }
      return -1;
    }
    exports.determineBranch = determineBranch;
    var htmlDecoder = getDecoder(decode_data_html_js_1.default);
    var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
    function decodeHTML(str, mode) {
      if (mode === void 0) {
        mode = DecodingMode.Legacy;
      }
      return htmlDecoder(str, mode);
    }
    exports.decodeHTML = decodeHTML;
    function decodeHTMLAttribute(str) {
      return htmlDecoder(str, DecodingMode.Attribute);
    }
    exports.decodeHTMLAttribute = decodeHTMLAttribute;
    function decodeHTMLStrict(str) {
      return htmlDecoder(str, DecodingMode.Strict);
    }
    exports.decodeHTMLStrict = decodeHTMLStrict;
    function decodeXML(str) {
      return xmlDecoder(str, DecodingMode.Strict);
    }
    exports.decodeXML = decodeXML;
  }
});

// node_modules/entities/lib/generated/encode-html.js
var require_encode_html = __commonJS({
  "node_modules/entities/lib/generated/encode-html.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function restoreDiff(arr) {
      for (var i2 = 1; i2 < arr.length; i2++) {
        arr[i2][0] += arr[i2 - 1][0] + 1;
      }
      return arr;
    }
    exports.default = new Map(restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));
  }
});

// node_modules/entities/lib/escape.js
var require_escape = __commonJS({
  "node_modules/entities/lib/escape.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.getCodePoint = exports.xmlReplacer = void 0;
    exports.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
    var xmlCodeMap = /* @__PURE__ */ new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [39, "&apos;"],
      [60, "&lt;"],
      [62, "&gt;"]
    ]);
    exports.getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.prototype.codePointAt != null ? function(str, index) {
      return str.codePointAt(index);
    } : (
      // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      function(c2, index) {
        return (c2.charCodeAt(index) & 64512) === 55296 ? (c2.charCodeAt(index) - 55296) * 1024 + c2.charCodeAt(index + 1) - 56320 + 65536 : c2.charCodeAt(index);
      }
    );
    function encodeXML(str) {
      var ret = "";
      var lastIdx = 0;
      var match;
      while ((match = exports.xmlReplacer.exec(str)) !== null) {
        var i2 = match.index;
        var char = str.charCodeAt(i2);
        var next = xmlCodeMap.get(char);
        if (next !== void 0) {
          ret += str.substring(lastIdx, i2) + next;
          lastIdx = i2 + 1;
        } else {
          ret += "".concat(str.substring(lastIdx, i2), "&#x").concat((0, exports.getCodePoint)(str, i2).toString(16), ";");
          lastIdx = exports.xmlReplacer.lastIndex += Number((char & 64512) === 55296);
        }
      }
      return ret + str.substr(lastIdx);
    }
    exports.encodeXML = encodeXML;
    exports.escape = encodeXML;
    function getEscaper(regex, map) {
      return function escape(data) {
        var match;
        var lastIdx = 0;
        var result = "";
        while (match = regex.exec(data)) {
          if (lastIdx !== match.index) {
            result += data.substring(lastIdx, match.index);
          }
          result += map.get(match[0].charCodeAt(0));
          lastIdx = match.index + 1;
        }
        return result + data.substring(lastIdx);
      };
    }
    exports.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
    exports.escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [160, "&nbsp;"]
    ]));
    exports.escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
      [38, "&amp;"],
      [60, "&lt;"],
      [62, "&gt;"],
      [160, "&nbsp;"]
    ]));
  }
});

// node_modules/entities/lib/encode.js
var require_encode = __commonJS({
  "node_modules/entities/lib/encode.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeNonAsciiHTML = exports.encodeHTML = void 0;
    var encode_html_js_1 = __importDefault(require_encode_html());
    var escape_js_1 = require_escape();
    var htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
    function encodeHTML(data) {
      return encodeHTMLTrieRe(htmlReplacer, data);
    }
    exports.encodeHTML = encodeHTML;
    function encodeNonAsciiHTML(data) {
      return encodeHTMLTrieRe(escape_js_1.xmlReplacer, data);
    }
    exports.encodeNonAsciiHTML = encodeNonAsciiHTML;
    function encodeHTMLTrieRe(regExp, str) {
      var ret = "";
      var lastIdx = 0;
      var match;
      while ((match = regExp.exec(str)) !== null) {
        var i2 = match.index;
        ret += str.substring(lastIdx, i2);
        var char = str.charCodeAt(i2);
        var next = encode_html_js_1.default.get(char);
        if (typeof next === "object") {
          if (i2 + 1 < str.length) {
            var nextChar = str.charCodeAt(i2 + 1);
            var value = typeof next.n === "number" ? next.n === nextChar ? next.o : void 0 : next.n.get(nextChar);
            if (value !== void 0) {
              ret += value;
              lastIdx = regExp.lastIndex += 1;
              continue;
            }
          }
          next = next.v;
        }
        if (next !== void 0) {
          ret += next;
          lastIdx = i2 + 1;
        } else {
          var cp = (0, escape_js_1.getCodePoint)(str, i2);
          ret += "&#x".concat(cp.toString(16), ";");
          lastIdx = regExp.lastIndex += Number(cp !== char);
        }
      }
      return ret + str.substr(lastIdx);
    }
  }
});

// node_modules/entities/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/entities/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLAttribute = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.DecodingMode = exports.EntityDecoder = exports.encodeHTML5 = exports.encodeHTML4 = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = exports.EncodingMode = exports.EntityLevel = void 0;
    var decode_js_1 = require_decode();
    var encode_js_1 = require_encode();
    var escape_js_1 = require_escape();
    var EntityLevel;
    (function(EntityLevel2) {
      EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
      EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
    })(EntityLevel = exports.EntityLevel || (exports.EntityLevel = {}));
    var EncodingMode;
    (function(EncodingMode2) {
      EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
      EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
      EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
      EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
      EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
    })(EncodingMode = exports.EncodingMode || (exports.EncodingMode = {}));
    function decode(data, options) {
      if (options === void 0) {
        options = EntityLevel.XML;
      }
      var level = typeof options === "number" ? options : options.level;
      if (level === EntityLevel.HTML) {
        var mode = typeof options === "object" ? options.mode : void 0;
        return (0, decode_js_1.decodeHTML)(data, mode);
      }
      return (0, decode_js_1.decodeXML)(data);
    }
    exports.decode = decode;
    function decodeStrict(data, options) {
      var _a;
      if (options === void 0) {
        options = EntityLevel.XML;
      }
      var opts = typeof options === "number" ? { level: options } : options;
      (_a = opts.mode) !== null && _a !== void 0 ? _a : opts.mode = decode_js_1.DecodingMode.Strict;
      return decode(data, opts);
    }
    exports.decodeStrict = decodeStrict;
    function encode(data, options) {
      if (options === void 0) {
        options = EntityLevel.XML;
      }
      var opts = typeof options === "number" ? { level: options } : options;
      if (opts.mode === EncodingMode.UTF8)
        return (0, escape_js_1.escapeUTF8)(data);
      if (opts.mode === EncodingMode.Attribute)
        return (0, escape_js_1.escapeAttribute)(data);
      if (opts.mode === EncodingMode.Text)
        return (0, escape_js_1.escapeText)(data);
      if (opts.level === EntityLevel.HTML) {
        if (opts.mode === EncodingMode.ASCII) {
          return (0, encode_js_1.encodeNonAsciiHTML)(data);
        }
        return (0, encode_js_1.encodeHTML)(data);
      }
      return (0, escape_js_1.encodeXML)(data);
    }
    exports.encode = encode;
    var escape_js_2 = require_escape();
    Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function() {
      return escape_js_2.encodeXML;
    } });
    Object.defineProperty(exports, "escape", { enumerable: true, get: function() {
      return escape_js_2.escape;
    } });
    Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function() {
      return escape_js_2.escapeUTF8;
    } });
    Object.defineProperty(exports, "escapeAttribute", { enumerable: true, get: function() {
      return escape_js_2.escapeAttribute;
    } });
    Object.defineProperty(exports, "escapeText", { enumerable: true, get: function() {
      return escape_js_2.escapeText;
    } });
    var encode_js_2 = require_encode();
    Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function() {
      return encode_js_2.encodeHTML;
    } });
    Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function() {
      return encode_js_2.encodeNonAsciiHTML;
    } });
    Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function() {
      return encode_js_2.encodeHTML;
    } });
    Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function() {
      return encode_js_2.encodeHTML;
    } });
    var decode_js_2 = require_decode();
    Object.defineProperty(exports, "EntityDecoder", { enumerable: true, get: function() {
      return decode_js_2.EntityDecoder;
    } });
    Object.defineProperty(exports, "DecodingMode", { enumerable: true, get: function() {
      return decode_js_2.DecodingMode;
    } });
    Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function() {
      return decode_js_2.decodeXML;
    } });
    Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function() {
      return decode_js_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeHTMLAttribute", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLAttribute;
    } });
    Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function() {
      return decode_js_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function() {
      return decode_js_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function() {
      return decode_js_2.decodeXML;
    } });
  }
});

// node_modules/dom-serializer/lib/foreignNames.js
var require_foreignNames = __commonJS({
  "node_modules/dom-serializer/lib/foreignNames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.attributeNames = exports.elementNames = void 0;
    exports.elementNames = new Map([
      "altGlyph",
      "altGlyphDef",
      "altGlyphItem",
      "animateColor",
      "animateMotion",
      "animateTransform",
      "clipPath",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feDropShadow",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence",
      "foreignObject",
      "glyphRef",
      "linearGradient",
      "radialGradient",
      "textPath"
    ].map(function(val) {
      return [val.toLowerCase(), val];
    }));
    exports.attributeNames = new Map([
      "definitionURL",
      "attributeName",
      "attributeType",
      "baseFrequency",
      "baseProfile",
      "calcMode",
      "clipPathUnits",
      "diffuseConstant",
      "edgeMode",
      "filterUnits",
      "glyphRef",
      "gradientTransform",
      "gradientUnits",
      "kernelMatrix",
      "kernelUnitLength",
      "keyPoints",
      "keySplines",
      "keyTimes",
      "lengthAdjust",
      "limitingConeAngle",
      "markerHeight",
      "markerUnits",
      "markerWidth",
      "maskContentUnits",
      "maskUnits",
      "numOctaves",
      "pathLength",
      "patternContentUnits",
      "patternTransform",
      "patternUnits",
      "pointsAtX",
      "pointsAtY",
      "pointsAtZ",
      "preserveAlpha",
      "preserveAspectRatio",
      "primitiveUnits",
      "refX",
      "refY",
      "repeatCount",
      "repeatDur",
      "requiredExtensions",
      "requiredFeatures",
      "specularConstant",
      "specularExponent",
      "spreadMethod",
      "startOffset",
      "stdDeviation",
      "stitchTiles",
      "surfaceScale",
      "systemLanguage",
      "tableValues",
      "targetX",
      "targetY",
      "textLength",
      "viewBox",
      "viewTarget",
      "xChannelSelector",
      "yChannelSelector",
      "zoomAndPan"
    ].map(function(val) {
      return [val.toLowerCase(), val];
    }));
  }
});

// node_modules/dom-serializer/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/dom-serializer/lib/index.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.render = void 0;
    var ElementType2 = __importStar(require_lib());
    var entities_1 = require_lib3();
    var foreignNames_js_1 = require_foreignNames();
    var unencodedElements = /* @__PURE__ */ new Set([
      "style",
      "script",
      "xmp",
      "iframe",
      "noembed",
      "noframes",
      "plaintext",
      "noscript"
    ]);
    function replaceQuotes(value) {
      return value.replace(/"/g, "&quot;");
    }
    function formatAttributes(attributes, opts) {
      var _a;
      if (!attributes)
        return;
      var encode = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? entities_1.encodeXML : entities_1.escapeAttribute;
      return Object.keys(attributes).map(function(key) {
        var _a2, _b;
        var value = (_a2 = attributes[key]) !== null && _a2 !== void 0 ? _a2 : "";
        if (opts.xmlMode === "foreign") {
          key = (_b = foreignNames_js_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
        }
        if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
          return key;
        }
        return "".concat(key, '="').concat(encode(value), '"');
      }).join(" ");
    }
    var singleTag = /* @__PURE__ */ new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    function render(node, options) {
      if (options === void 0) {
        options = {};
      }
      var nodes = "length" in node ? node : [node];
      var output = "";
      for (var i2 = 0; i2 < nodes.length; i2++) {
        output += renderNode(nodes[i2], options);
      }
      return output;
    }
    exports.render = render;
    exports.default = render;
    function renderNode(node, options) {
      switch (node.type) {
        case ElementType2.Root:
          return render(node.children, options);
        case ElementType2.Doctype:
        case ElementType2.Directive:
          return renderDirective(node);
        case ElementType2.Comment:
          return renderComment(node);
        case ElementType2.CDATA:
          return renderCdata(node);
        case ElementType2.Script:
        case ElementType2.Style:
        case ElementType2.Tag:
          return renderTag(node, options);
        case ElementType2.Text:
          return renderText(node, options);
      }
    }
    var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignObject",
      "desc",
      "title"
    ]);
    var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
    function renderTag(elem, opts) {
      var _a;
      if (opts.xmlMode === "foreign") {
        elem.name = (_a = foreignNames_js_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
        if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
          opts = __assign(__assign({}, opts), { xmlMode: false });
        }
      }
      if (!opts.xmlMode && foreignElements.has(elem.name)) {
        opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
      }
      var tag = "<".concat(elem.name);
      var attribs = formatAttributes(elem.attribs, opts);
      if (attribs) {
        tag += " ".concat(attribs);
      }
      if (elem.children.length === 0 && (opts.xmlMode ? (
        // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
        opts.selfClosingTags !== false
      ) : (
        // User explicitly asked for self-closing tags, even in HTML mode
        opts.selfClosingTags && singleTag.has(elem.name)
      ))) {
        if (!opts.xmlMode)
          tag += " ";
        tag += "/>";
      } else {
        tag += ">";
        if (elem.children.length > 0) {
          tag += render(elem.children, opts);
        }
        if (opts.xmlMode || !singleTag.has(elem.name)) {
          tag += "</".concat(elem.name, ">");
        }
      }
      return tag;
    }
    function renderDirective(elem) {
      return "<".concat(elem.data, ">");
    }
    function renderText(elem, opts) {
      var _a;
      var data = elem.data || "";
      if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
        data = opts.xmlMode || opts.encodeEntities !== "utf8" ? (0, entities_1.encodeXML)(data) : (0, entities_1.escapeText)(data);
      }
      return data;
    }
    function renderCdata(elem) {
      return "<![CDATA[".concat(elem.children[0].data, "]]>");
    }
    function renderComment(elem) {
      return "<!--".concat(elem.data, "-->");
    }
  }
});

// node_modules/domutils/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/domutils/lib/stringify.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.innerText = exports.textContent = exports.getText = exports.getInnerHTML = exports.getOuterHTML = void 0;
    var domhandler_1 = require_lib2();
    var dom_serializer_1 = __importDefault(require_lib4());
    var domelementtype_1 = require_lib();
    function getOuterHTML(node, options) {
      return (0, dom_serializer_1.default)(node, options);
    }
    exports.getOuterHTML = getOuterHTML;
    function getInnerHTML(node, options) {
      return (0, domhandler_1.hasChildren)(node) ? node.children.map(function(node2) {
        return getOuterHTML(node2, options);
      }).join("") : "";
    }
    exports.getInnerHTML = getInnerHTML;
    function getText(node) {
      if (Array.isArray(node))
        return node.map(getText).join("");
      if ((0, domhandler_1.isTag)(node))
        return node.name === "br" ? "\n" : getText(node.children);
      if ((0, domhandler_1.isCDATA)(node))
        return getText(node.children);
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports.getText = getText;
    function textContent(node) {
      if (Array.isArray(node))
        return node.map(textContent).join("");
      if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
        return textContent(node.children);
      }
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports.textContent = textContent;
    function innerText(node) {
      if (Array.isArray(node))
        return node.map(innerText).join("");
      if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
        return innerText(node.children);
      }
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports.innerText = innerText;
  }
});

// node_modules/domutils/lib/traversal.js
var require_traversal = __commonJS({
  "node_modules/domutils/lib/traversal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prevElementSibling = exports.nextElementSibling = exports.getName = exports.hasAttrib = exports.getAttributeValue = exports.getSiblings = exports.getParent = exports.getChildren = void 0;
    var domhandler_1 = require_lib2();
    function getChildren(elem) {
      return (0, domhandler_1.hasChildren)(elem) ? elem.children : [];
    }
    exports.getChildren = getChildren;
    function getParent(elem) {
      return elem.parent || null;
    }
    exports.getParent = getParent;
    function getSiblings(elem) {
      var _a, _b;
      var parent = getParent(elem);
      if (parent != null)
        return getChildren(parent);
      var siblings = [elem];
      var prev = elem.prev, next = elem.next;
      while (prev != null) {
        siblings.unshift(prev);
        _a = prev, prev = _a.prev;
      }
      while (next != null) {
        siblings.push(next);
        _b = next, next = _b.next;
      }
      return siblings;
    }
    exports.getSiblings = getSiblings;
    function getAttributeValue(elem, name) {
      var _a;
      return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
    }
    exports.getAttributeValue = getAttributeValue;
    function hasAttrib(elem, name) {
      return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
    }
    exports.hasAttrib = hasAttrib;
    function getName(elem) {
      return elem.name;
    }
    exports.getName = getName;
    function nextElementSibling(elem) {
      var _a;
      var next = elem.next;
      while (next !== null && !(0, domhandler_1.isTag)(next))
        _a = next, next = _a.next;
      return next;
    }
    exports.nextElementSibling = nextElementSibling;
    function prevElementSibling(elem) {
      var _a;
      var prev = elem.prev;
      while (prev !== null && !(0, domhandler_1.isTag)(prev))
        _a = prev, prev = _a.prev;
      return prev;
    }
    exports.prevElementSibling = prevElementSibling;
  }
});

// node_modules/domutils/lib/manipulation.js
var require_manipulation = __commonJS({
  "node_modules/domutils/lib/manipulation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prepend = exports.prependChild = exports.append = exports.appendChild = exports.replaceElement = exports.removeElement = void 0;
    function removeElement(elem) {
      if (elem.prev)
        elem.prev.next = elem.next;
      if (elem.next)
        elem.next.prev = elem.prev;
      if (elem.parent) {
        var childs = elem.parent.children;
        var childsIndex = childs.lastIndexOf(elem);
        if (childsIndex >= 0) {
          childs.splice(childsIndex, 1);
        }
      }
      elem.next = null;
      elem.prev = null;
      elem.parent = null;
    }
    exports.removeElement = removeElement;
    function replaceElement(elem, replacement) {
      var prev = replacement.prev = elem.prev;
      if (prev) {
        prev.next = replacement;
      }
      var next = replacement.next = elem.next;
      if (next) {
        next.prev = replacement;
      }
      var parent = replacement.parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs[childs.lastIndexOf(elem)] = replacement;
        elem.parent = null;
      }
    }
    exports.replaceElement = replaceElement;
    function appendChild(parent, child) {
      removeElement(child);
      child.next = null;
      child.parent = parent;
      if (parent.children.push(child) > 1) {
        var sibling = parent.children[parent.children.length - 2];
        sibling.next = child;
        child.prev = sibling;
      } else {
        child.prev = null;
      }
    }
    exports.appendChild = appendChild;
    function append(elem, next) {
      removeElement(next);
      var parent = elem.parent;
      var currNext = elem.next;
      next.next = currNext;
      next.prev = elem;
      elem.next = next;
      next.parent = parent;
      if (currNext) {
        currNext.prev = next;
        if (parent) {
          var childs = parent.children;
          childs.splice(childs.lastIndexOf(currNext), 0, next);
        }
      } else if (parent) {
        parent.children.push(next);
      }
    }
    exports.append = append;
    function prependChild(parent, child) {
      removeElement(child);
      child.parent = parent;
      child.prev = null;
      if (parent.children.unshift(child) !== 1) {
        var sibling = parent.children[1];
        sibling.prev = child;
        child.next = sibling;
      } else {
        child.next = null;
      }
    }
    exports.prependChild = prependChild;
    function prepend(elem, prev) {
      removeElement(prev);
      var parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs.splice(childs.indexOf(elem), 0, prev);
      }
      if (elem.prev) {
        elem.prev.next = prev;
      }
      prev.parent = parent;
      prev.prev = elem.prev;
      prev.next = elem;
      elem.prev = prev;
    }
    exports.prepend = prepend;
  }
});

// node_modules/domutils/lib/querying.js
var require_querying = __commonJS({
  "node_modules/domutils/lib/querying.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findAll = exports.existsOne = exports.findOne = exports.findOneChild = exports.find = exports.filter = void 0;
    var domhandler_1 = require_lib2();
    function filter(test, node, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return find(test, Array.isArray(node) ? node : [node], recurse, limit);
    }
    exports.filter = filter;
    function find(test, nodes, recurse, limit) {
      var result = [];
      var nodeStack = [nodes];
      var indexStack = [0];
      for (; ; ) {
        if (indexStack[0] >= nodeStack[0].length) {
          if (indexStack.length === 1) {
            return result;
          }
          nodeStack.shift();
          indexStack.shift();
          continue;
        }
        var elem = nodeStack[0][indexStack[0]++];
        if (test(elem)) {
          result.push(elem);
          if (--limit <= 0)
            return result;
        }
        if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
          indexStack.unshift(0);
          nodeStack.unshift(elem.children);
        }
      }
    }
    exports.find = find;
    function findOneChild(test, nodes) {
      return nodes.find(test);
    }
    exports.findOneChild = findOneChild;
    function findOne(test, nodes, recurse) {
      if (recurse === void 0) {
        recurse = true;
      }
      var elem = null;
      for (var i2 = 0; i2 < nodes.length && !elem; i2++) {
        var node = nodes[i2];
        if (!(0, domhandler_1.isTag)(node)) {
          continue;
        } else if (test(node)) {
          elem = node;
        } else if (recurse && node.children.length > 0) {
          elem = findOne(test, node.children, true);
        }
      }
      return elem;
    }
    exports.findOne = findOne;
    function existsOne(test, nodes) {
      return nodes.some(function(checked) {
        return (0, domhandler_1.isTag)(checked) && (test(checked) || existsOne(test, checked.children));
      });
    }
    exports.existsOne = existsOne;
    function findAll(test, nodes) {
      var result = [];
      var nodeStack = [nodes];
      var indexStack = [0];
      for (; ; ) {
        if (indexStack[0] >= nodeStack[0].length) {
          if (nodeStack.length === 1) {
            return result;
          }
          nodeStack.shift();
          indexStack.shift();
          continue;
        }
        var elem = nodeStack[0][indexStack[0]++];
        if (!(0, domhandler_1.isTag)(elem))
          continue;
        if (test(elem))
          result.push(elem);
        if (elem.children.length > 0) {
          indexStack.unshift(0);
          nodeStack.unshift(elem.children);
        }
      }
    }
    exports.findAll = findAll;
  }
});

// node_modules/domutils/lib/legacy.js
var require_legacy = __commonJS({
  "node_modules/domutils/lib/legacy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getElementsByTagType = exports.getElementsByTagName = exports.getElementById = exports.getElements = exports.testElement = void 0;
    var domhandler_1 = require_lib2();
    var querying_js_1 = require_querying();
    var Checks = {
      tag_name: function(name) {
        if (typeof name === "function") {
          return function(elem) {
            return (0, domhandler_1.isTag)(elem) && name(elem.name);
          };
        } else if (name === "*") {
          return domhandler_1.isTag;
        }
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && elem.name === name;
        };
      },
      tag_type: function(type) {
        if (typeof type === "function") {
          return function(elem) {
            return type(elem.type);
          };
        }
        return function(elem) {
          return elem.type === type;
        };
      },
      tag_contains: function(data) {
        if (typeof data === "function") {
          return function(elem) {
            return (0, domhandler_1.isText)(elem) && data(elem.data);
          };
        }
        return function(elem) {
          return (0, domhandler_1.isText)(elem) && elem.data === data;
        };
      }
    };
    function getAttribCheck(attrib, value) {
      if (typeof value === "function") {
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
        };
      }
      return function(elem) {
        return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value;
      };
    }
    function combineFuncs(a2, b3) {
      return function(elem) {
        return a2(elem) || b3(elem);
      };
    }
    function compileTest(options) {
      var funcs = Object.keys(options).map(function(key) {
        var value = options[key];
        return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
      });
      return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
    }
    function testElement(options, node) {
      var test = compileTest(options);
      return test ? test(node) : true;
    }
    exports.testElement = testElement;
    function getElements(options, nodes, recurse, limit) {
      if (limit === void 0) {
        limit = Infinity;
      }
      var test = compileTest(options);
      return test ? (0, querying_js_1.filter)(test, nodes, recurse, limit) : [];
    }
    exports.getElements = getElements;
    function getElementById(id, nodes, recurse) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (!Array.isArray(nodes))
        nodes = [nodes];
      return (0, querying_js_1.findOne)(getAttribCheck("id", id), nodes, recurse);
    }
    exports.getElementById = getElementById;
    function getElementsByTagName(tagName, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_js_1.filter)(Checks["tag_name"](tagName), nodes, recurse, limit);
    }
    exports.getElementsByTagName = getElementsByTagName;
    function getElementsByTagType(type, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_js_1.filter)(Checks["tag_type"](type), nodes, recurse, limit);
    }
    exports.getElementsByTagType = getElementsByTagType;
  }
});

// node_modules/domutils/lib/helpers.js
var require_helpers = __commonJS({
  "node_modules/domutils/lib/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uniqueSort = exports.compareDocumentPosition = exports.DocumentPosition = exports.removeSubsets = void 0;
    var domhandler_1 = require_lib2();
    function removeSubsets(nodes) {
      var idx = nodes.length;
      while (--idx >= 0) {
        var node = nodes[idx];
        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
          nodes.splice(idx, 1);
          continue;
        }
        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
          if (nodes.includes(ancestor)) {
            nodes.splice(idx, 1);
            break;
          }
        }
      }
      return nodes;
    }
    exports.removeSubsets = removeSubsets;
    var DocumentPosition;
    (function(DocumentPosition2) {
      DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
      DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
      DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
      DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
      DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
    })(DocumentPosition = exports.DocumentPosition || (exports.DocumentPosition = {}));
    function compareDocumentPosition(nodeA, nodeB) {
      var aParents = [];
      var bParents = [];
      if (nodeA === nodeB) {
        return 0;
      }
      var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
      while (current) {
        aParents.unshift(current);
        current = current.parent;
      }
      current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
      while (current) {
        bParents.unshift(current);
        current = current.parent;
      }
      var maxIdx = Math.min(aParents.length, bParents.length);
      var idx = 0;
      while (idx < maxIdx && aParents[idx] === bParents[idx]) {
        idx++;
      }
      if (idx === 0) {
        return DocumentPosition.DISCONNECTED;
      }
      var sharedParent = aParents[idx - 1];
      var siblings = sharedParent.children;
      var aSibling = aParents[idx];
      var bSibling = bParents[idx];
      if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
          return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
        }
        return DocumentPosition.FOLLOWING;
      }
      if (sharedParent === nodeA) {
        return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
      }
      return DocumentPosition.PRECEDING;
    }
    exports.compareDocumentPosition = compareDocumentPosition;
    function uniqueSort(nodes) {
      nodes = nodes.filter(function(node, i2, arr) {
        return !arr.includes(node, i2 + 1);
      });
      nodes.sort(function(a2, b3) {
        var relative = compareDocumentPosition(a2, b3);
        if (relative & DocumentPosition.PRECEDING) {
          return -1;
        } else if (relative & DocumentPosition.FOLLOWING) {
          return 1;
        }
        return 0;
      });
      return nodes;
    }
    exports.uniqueSort = uniqueSort;
  }
});

// node_modules/domutils/lib/feeds.js
var require_feeds = __commonJS({
  "node_modules/domutils/lib/feeds.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFeed = void 0;
    var stringify_js_1 = require_stringify();
    var legacy_js_1 = require_legacy();
    function getFeed(doc) {
      var feedRoot = getOneElement(isValidFeed, doc);
      return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
    }
    exports.getFeed = getFeed;
    function getAtomFeed(feedRoot) {
      var _a;
      var childs = feedRoot.children;
      var feed = {
        type: "atom",
        items: (0, legacy_js_1.getElementsByTagName)("entry", childs).map(function(item) {
          var _a2;
          var children = item.children;
          var entry = { media: getMediaElements(children) };
          addConditionally(entry, "id", "id", children);
          addConditionally(entry, "title", "title", children);
          var href2 = (_a2 = getOneElement("link", children)) === null || _a2 === void 0 ? void 0 : _a2.attribs["href"];
          if (href2) {
            entry.link = href2;
          }
          var description = fetch2("summary", children) || fetch2("content", children);
          if (description) {
            entry.description = description;
          }
          var pubDate = fetch2("updated", children);
          if (pubDate) {
            entry.pubDate = new Date(pubDate);
          }
          return entry;
        })
      };
      addConditionally(feed, "id", "id", childs);
      addConditionally(feed, "title", "title", childs);
      var href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
      if (href) {
        feed.link = href;
      }
      addConditionally(feed, "description", "subtitle", childs);
      var updated = fetch2("updated", childs);
      if (updated) {
        feed.updated = new Date(updated);
      }
      addConditionally(feed, "author", "email", childs, true);
      return feed;
    }
    function getRssFeed(feedRoot) {
      var _a, _b;
      var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
      var feed = {
        type: feedRoot.name.substr(0, 3),
        id: "",
        items: (0, legacy_js_1.getElementsByTagName)("item", feedRoot.children).map(function(item) {
          var children = item.children;
          var entry = { media: getMediaElements(children) };
          addConditionally(entry, "id", "guid", children);
          addConditionally(entry, "title", "title", children);
          addConditionally(entry, "link", "link", children);
          addConditionally(entry, "description", "description", children);
          var pubDate = fetch2("pubDate", children) || fetch2("dc:date", children);
          if (pubDate)
            entry.pubDate = new Date(pubDate);
          return entry;
        })
      };
      addConditionally(feed, "title", "title", childs);
      addConditionally(feed, "link", "link", childs);
      addConditionally(feed, "description", "description", childs);
      var updated = fetch2("lastBuildDate", childs);
      if (updated) {
        feed.updated = new Date(updated);
      }
      addConditionally(feed, "author", "managingEditor", childs, true);
      return feed;
    }
    var MEDIA_KEYS_STRING = ["url", "type", "lang"];
    var MEDIA_KEYS_INT = [
      "fileSize",
      "bitrate",
      "framerate",
      "samplingrate",
      "channels",
      "duration",
      "height",
      "width"
    ];
    function getMediaElements(where) {
      return (0, legacy_js_1.getElementsByTagName)("media:content", where).map(function(elem) {
        var attribs = elem.attribs;
        var media = {
          medium: attribs["medium"],
          isDefault: !!attribs["isDefault"]
        };
        for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
          var attrib = MEDIA_KEYS_STRING_1[_i];
          if (attribs[attrib]) {
            media[attrib] = attribs[attrib];
          }
        }
        for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {
          var attrib = MEDIA_KEYS_INT_1[_a];
          if (attribs[attrib]) {
            media[attrib] = parseInt(attribs[attrib], 10);
          }
        }
        if (attribs["expression"]) {
          media.expression = attribs["expression"];
        }
        return media;
      });
    }
    function getOneElement(tagName, node) {
      return (0, legacy_js_1.getElementsByTagName)(tagName, node, true, 1)[0];
    }
    function fetch2(tagName, where, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      return (0, stringify_js_1.textContent)((0, legacy_js_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
    }
    function addConditionally(obj, prop, tagName, where, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      var val = fetch2(tagName, where, recurse);
      if (val)
        obj[prop] = val;
    }
    function isValidFeed(value) {
      return value === "rss" || value === "feed" || value === "rdf:RDF";
    }
  }
});

// node_modules/domutils/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/domutils/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p2 in m)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;
    __exportStar(require_stringify(), exports);
    __exportStar(require_traversal(), exports);
    __exportStar(require_manipulation(), exports);
    __exportStar(require_querying(), exports);
    __exportStar(require_legacy(), exports);
    __exportStar(require_helpers(), exports);
    __exportStar(require_feeds(), exports);
    var domhandler_1 = require_lib2();
    Object.defineProperty(exports, "isTag", { enumerable: true, get: function() {
      return domhandler_1.isTag;
    } });
    Object.defineProperty(exports, "isCDATA", { enumerable: true, get: function() {
      return domhandler_1.isCDATA;
    } });
    Object.defineProperty(exports, "isText", { enumerable: true, get: function() {
      return domhandler_1.isText;
    } });
    Object.defineProperty(exports, "isComment", { enumerable: true, get: function() {
      return domhandler_1.isComment;
    } });
    Object.defineProperty(exports, "isDocument", { enumerable: true, get: function() {
      return domhandler_1.isDocument;
    } });
    Object.defineProperty(exports, "hasChildren", { enumerable: true, get: function() {
      return domhandler_1.hasChildren;
    } });
  }
});

// node_modules/boolbase/index.js
var require_boolbase = __commonJS({
  "node_modules/boolbase/index.js"(exports, module) {
    module.exports = {
      trueFunc: function trueFunc() {
        return true;
      },
      falseFunc: function falseFunc() {
        return false;
      }
    };
  }
});

// node_modules/css-what/lib/es/types.js
var SelectorType, IgnoreCaseMode, AttributeAction;
var init_types = __esm({
  "node_modules/css-what/lib/es/types.js"() {
    (function(SelectorType2) {
      SelectorType2["Attribute"] = "attribute";
      SelectorType2["Pseudo"] = "pseudo";
      SelectorType2["PseudoElement"] = "pseudo-element";
      SelectorType2["Tag"] = "tag";
      SelectorType2["Universal"] = "universal";
      SelectorType2["Adjacent"] = "adjacent";
      SelectorType2["Child"] = "child";
      SelectorType2["Descendant"] = "descendant";
      SelectorType2["Parent"] = "parent";
      SelectorType2["Sibling"] = "sibling";
      SelectorType2["ColumnCombinator"] = "column-combinator";
    })(SelectorType || (SelectorType = {}));
    IgnoreCaseMode = {
      Unknown: null,
      QuirksMode: "quirks",
      IgnoreCase: true,
      CaseSensitive: false
    };
    (function(AttributeAction2) {
      AttributeAction2["Any"] = "any";
      AttributeAction2["Element"] = "element";
      AttributeAction2["End"] = "end";
      AttributeAction2["Equals"] = "equals";
      AttributeAction2["Exists"] = "exists";
      AttributeAction2["Hyphen"] = "hyphen";
      AttributeAction2["Not"] = "not";
      AttributeAction2["Start"] = "start";
    })(AttributeAction || (AttributeAction = {}));
  }
});

// node_modules/css-what/lib/es/parse.js
function isTraversal(selector) {
  switch (selector.type) {
    case SelectorType.Adjacent:
    case SelectorType.Child:
    case SelectorType.Descendant:
    case SelectorType.Parent:
    case SelectorType.Sibling:
    case SelectorType.ColumnCombinator:
      return true;
    default:
      return false;
  }
}
function funescape(_3, escaped, escapedWhitespace) {
  const high = parseInt(escaped, 16) - 65536;
  return high !== high || escapedWhitespace ? escaped : high < 0 ? (
    // BMP codepoint
    String.fromCharCode(high + 65536)
  ) : (
    // Supplemental Plane codepoint (surrogate pair)
    String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
  );
}
function unescapeCSS(str) {
  return str.replace(reEscape, funescape);
}
function isQuote(c2) {
  return c2 === 39 || c2 === 34;
}
function isWhitespace(c2) {
  return c2 === 32 || c2 === 9 || c2 === 10 || c2 === 12 || c2 === 13;
}
function parse(selector) {
  const subselects = [];
  const endIndex = parseSelector(subselects, `${selector}`, 0);
  if (endIndex < selector.length) {
    throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);
  }
  return subselects;
}
function parseSelector(subselects, selector, selectorIndex) {
  let tokens = [];
  function getName(offset) {
    const match = selector.slice(selectorIndex + offset).match(reName);
    if (!match) {
      throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);
    }
    const [name] = match;
    selectorIndex += offset + name.length;
    return unescapeCSS(name);
  }
  function stripWhitespace(offset) {
    selectorIndex += offset;
    while (selectorIndex < selector.length && isWhitespace(selector.charCodeAt(selectorIndex))) {
      selectorIndex++;
    }
  }
  function readValueWithParenthesis() {
    selectorIndex += 1;
    const start = selectorIndex;
    let counter = 1;
    for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
      if (selector.charCodeAt(selectorIndex) === 40 && !isEscaped(selectorIndex)) {
        counter++;
      } else if (selector.charCodeAt(selectorIndex) === 41 && !isEscaped(selectorIndex)) {
        counter--;
      }
    }
    if (counter) {
      throw new Error("Parenthesis not matched");
    }
    return unescapeCSS(selector.slice(start, selectorIndex - 1));
  }
  function isEscaped(pos) {
    let slashCount = 0;
    while (selector.charCodeAt(--pos) === 92)
      slashCount++;
    return (slashCount & 1) === 1;
  }
  function ensureNotTraversal() {
    if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {
      throw new Error("Did not expect successive traversals.");
    }
  }
  function addTraversal(type) {
    if (tokens.length > 0 && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens[tokens.length - 1].type = type;
      return;
    }
    ensureNotTraversal();
    tokens.push({ type });
  }
  function addSpecialAttribute(name, action) {
    tokens.push({
      type: SelectorType.Attribute,
      name,
      action,
      value: getName(1),
      namespace: null,
      ignoreCase: "quirks"
    });
  }
  function finalizeSubselector() {
    if (tokens.length && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens.pop();
    }
    if (tokens.length === 0) {
      throw new Error("Empty sub-selector");
    }
    subselects.push(tokens);
  }
  stripWhitespace(0);
  if (selector.length === selectorIndex) {
    return selectorIndex;
  }
  loop:
    while (selectorIndex < selector.length) {
      const firstChar = selector.charCodeAt(selectorIndex);
      switch (firstChar) {
        case 32:
        case 9:
        case 10:
        case 12:
        case 13: {
          if (tokens.length === 0 || tokens[0].type !== SelectorType.Descendant) {
            ensureNotTraversal();
            tokens.push({ type: SelectorType.Descendant });
          }
          stripWhitespace(1);
          break;
        }
        case 62: {
          addTraversal(SelectorType.Child);
          stripWhitespace(1);
          break;
        }
        case 60: {
          addTraversal(SelectorType.Parent);
          stripWhitespace(1);
          break;
        }
        case 126: {
          addTraversal(SelectorType.Sibling);
          stripWhitespace(1);
          break;
        }
        case 43: {
          addTraversal(SelectorType.Adjacent);
          stripWhitespace(1);
          break;
        }
        case 46: {
          addSpecialAttribute("class", AttributeAction.Element);
          break;
        }
        case 35: {
          addSpecialAttribute("id", AttributeAction.Equals);
          break;
        }
        case 91: {
          stripWhitespace(1);
          let name;
          let namespace = null;
          if (selector.charCodeAt(selectorIndex) === 124) {
            name = getName(1);
          } else if (selector.startsWith("*|", selectorIndex)) {
            namespace = "*";
            name = getName(2);
          } else {
            name = getName(0);
            if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 61) {
              namespace = name;
              name = getName(1);
            }
          }
          stripWhitespace(0);
          let action = AttributeAction.Exists;
          const possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));
          if (possibleAction) {
            action = possibleAction;
            if (selector.charCodeAt(selectorIndex + 1) !== 61) {
              throw new Error("Expected `=`");
            }
            stripWhitespace(2);
          } else if (selector.charCodeAt(selectorIndex) === 61) {
            action = AttributeAction.Equals;
            stripWhitespace(1);
          }
          let value = "";
          let ignoreCase = null;
          if (action !== "exists") {
            if (isQuote(selector.charCodeAt(selectorIndex))) {
              const quote = selector.charCodeAt(selectorIndex);
              let sectionEnd = selectorIndex + 1;
              while (sectionEnd < selector.length && (selector.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd))) {
                sectionEnd += 1;
              }
              if (selector.charCodeAt(sectionEnd) !== quote) {
                throw new Error("Attribute value didn't end");
              }
              value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
              selectorIndex = sectionEnd + 1;
            } else {
              const valueStart = selectorIndex;
              while (selectorIndex < selector.length && (!isWhitespace(selector.charCodeAt(selectorIndex)) && selector.charCodeAt(selectorIndex) !== 93 || isEscaped(selectorIndex))) {
                selectorIndex += 1;
              }
              value = unescapeCSS(selector.slice(valueStart, selectorIndex));
            }
            stripWhitespace(0);
            const forceIgnore = selector.charCodeAt(selectorIndex) | 32;
            if (forceIgnore === 115) {
              ignoreCase = false;
              stripWhitespace(1);
            } else if (forceIgnore === 105) {
              ignoreCase = true;
              stripWhitespace(1);
            }
          }
          if (selector.charCodeAt(selectorIndex) !== 93) {
            throw new Error("Attribute selector didn't terminate");
          }
          selectorIndex += 1;
          const attributeSelector = {
            type: SelectorType.Attribute,
            name,
            action,
            value,
            namespace,
            ignoreCase
          };
          tokens.push(attributeSelector);
          break;
        }
        case 58: {
          if (selector.charCodeAt(selectorIndex + 1) === 58) {
            tokens.push({
              type: SelectorType.PseudoElement,
              name: getName(2).toLowerCase(),
              data: selector.charCodeAt(selectorIndex) === 40 ? readValueWithParenthesis() : null
            });
            continue;
          }
          const name = getName(1).toLowerCase();
          let data = null;
          if (selector.charCodeAt(selectorIndex) === 40) {
            if (unpackPseudos.has(name)) {
              if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
                throw new Error(`Pseudo-selector ${name} cannot be quoted`);
              }
              data = [];
              selectorIndex = parseSelector(data, selector, selectorIndex + 1);
              if (selector.charCodeAt(selectorIndex) !== 41) {
                throw new Error(`Missing closing parenthesis in :${name} (${selector})`);
              }
              selectorIndex += 1;
            } else {
              data = readValueWithParenthesis();
              if (stripQuotesFromPseudos.has(name)) {
                const quot = data.charCodeAt(0);
                if (quot === data.charCodeAt(data.length - 1) && isQuote(quot)) {
                  data = data.slice(1, -1);
                }
              }
              data = unescapeCSS(data);
            }
          }
          tokens.push({ type: SelectorType.Pseudo, name, data });
          break;
        }
        case 44: {
          finalizeSubselector();
          tokens = [];
          stripWhitespace(1);
          break;
        }
        default: {
          if (selector.startsWith("/*", selectorIndex)) {
            const endIndex = selector.indexOf("*/", selectorIndex + 2);
            if (endIndex < 0) {
              throw new Error("Comment was not terminated");
            }
            selectorIndex = endIndex + 2;
            if (tokens.length === 0) {
              stripWhitespace(0);
            }
            break;
          }
          let namespace = null;
          let name;
          if (firstChar === 42) {
            selectorIndex += 1;
            name = "*";
          } else if (firstChar === 124) {
            name = "";
            if (selector.charCodeAt(selectorIndex + 1) === 124) {
              addTraversal(SelectorType.ColumnCombinator);
              stripWhitespace(2);
              break;
            }
          } else if (reName.test(selector.slice(selectorIndex))) {
            name = getName(0);
          } else {
            break loop;
          }
          if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 124) {
            namespace = name;
            if (selector.charCodeAt(selectorIndex + 1) === 42) {
              name = "*";
              selectorIndex += 2;
            } else {
              name = getName(1);
            }
          }
          tokens.push(name === "*" ? { type: SelectorType.Universal, namespace } : { type: SelectorType.Tag, name, namespace });
        }
      }
    }
  finalizeSubselector();
  return selectorIndex;
}
var reName, reEscape, actionTypes, unpackPseudos, stripQuotesFromPseudos;
var init_parse = __esm({
  "node_modules/css-what/lib/es/parse.js"() {
    init_types();
    reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
    reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
    actionTypes = /* @__PURE__ */ new Map([
      [126, AttributeAction.Element],
      [94, AttributeAction.Start],
      [36, AttributeAction.End],
      [42, AttributeAction.Any],
      [33, AttributeAction.Not],
      [124, AttributeAction.Hyphen]
    ]);
    unpackPseudos = /* @__PURE__ */ new Set([
      "has",
      "not",
      "matches",
      "is",
      "where",
      "host",
      "host-context"
    ]);
    stripQuotesFromPseudos = /* @__PURE__ */ new Set(["contains", "icontains"]);
  }
});

// node_modules/css-what/lib/es/stringify.js
function stringify(selector) {
  return selector.map((token) => token.map(stringifyToken).join("")).join(", ");
}
function stringifyToken(token, index, arr) {
  switch (token.type) {
    case SelectorType.Child:
      return index === 0 ? "> " : " > ";
    case SelectorType.Parent:
      return index === 0 ? "< " : " < ";
    case SelectorType.Sibling:
      return index === 0 ? "~ " : " ~ ";
    case SelectorType.Adjacent:
      return index === 0 ? "+ " : " + ";
    case SelectorType.Descendant:
      return " ";
    case SelectorType.ColumnCombinator:
      return index === 0 ? "|| " : " || ";
    case SelectorType.Universal:
      return token.namespace === "*" && index + 1 < arr.length && "name" in arr[index + 1] ? "" : `${getNamespace(token.namespace)}*`;
    case SelectorType.Tag:
      return getNamespacedName(token);
    case SelectorType.PseudoElement:
      return `::${escapeName(token.name, charsToEscapeInName)}${token.data === null ? "" : `(${escapeName(token.data, charsToEscapeInPseudoValue)})`}`;
    case SelectorType.Pseudo:
      return `:${escapeName(token.name, charsToEscapeInName)}${token.data === null ? "" : `(${typeof token.data === "string" ? escapeName(token.data, charsToEscapeInPseudoValue) : stringify(token.data)})`}`;
    case SelectorType.Attribute: {
      if (token.name === "id" && token.action === AttributeAction.Equals && token.ignoreCase === "quirks" && !token.namespace) {
        return `#${escapeName(token.value, charsToEscapeInName)}`;
      }
      if (token.name === "class" && token.action === AttributeAction.Element && token.ignoreCase === "quirks" && !token.namespace) {
        return `.${escapeName(token.value, charsToEscapeInName)}`;
      }
      const name = getNamespacedName(token);
      if (token.action === AttributeAction.Exists) {
        return `[${name}]`;
      }
      return `[${name}${getActionValue(token.action)}="${escapeName(token.value, charsToEscapeInAttributeValue)}"${token.ignoreCase === null ? "" : token.ignoreCase ? " i" : " s"}]`;
    }
  }
}
function getActionValue(action) {
  switch (action) {
    case AttributeAction.Equals:
      return "";
    case AttributeAction.Element:
      return "~";
    case AttributeAction.Start:
      return "^";
    case AttributeAction.End:
      return "$";
    case AttributeAction.Any:
      return "*";
    case AttributeAction.Not:
      return "!";
    case AttributeAction.Hyphen:
      return "|";
    case AttributeAction.Exists:
      throw new Error("Shouldn't be here");
  }
}
function getNamespacedName(token) {
  return `${getNamespace(token.namespace)}${escapeName(token.name, charsToEscapeInName)}`;
}
function getNamespace(namespace) {
  return namespace !== null ? `${namespace === "*" ? "*" : escapeName(namespace, charsToEscapeInName)}|` : "";
}
function escapeName(str, charsToEscape) {
  let lastIdx = 0;
  let ret = "";
  for (let i2 = 0; i2 < str.length; i2++) {
    if (charsToEscape.has(str.charCodeAt(i2))) {
      ret += `${str.slice(lastIdx, i2)}\\${str.charAt(i2)}`;
      lastIdx = i2 + 1;
    }
  }
  return ret.length > 0 ? ret + str.slice(lastIdx) : str;
}
var attribValChars, pseudoValChars, charsToEscapeInAttributeValue, charsToEscapeInPseudoValue, charsToEscapeInName;
var init_stringify = __esm({
  "node_modules/css-what/lib/es/stringify.js"() {
    init_types();
    attribValChars = ["\\", '"'];
    pseudoValChars = [...attribValChars, "(", ")"];
    charsToEscapeInAttributeValue = new Set(attribValChars.map((c2) => c2.charCodeAt(0)));
    charsToEscapeInPseudoValue = new Set(pseudoValChars.map((c2) => c2.charCodeAt(0)));
    charsToEscapeInName = new Set([
      ...pseudoValChars,
      "~",
      "^",
      "$",
      "*",
      "+",
      "!",
      "|",
      ":",
      "[",
      "]",
      " ",
      "."
    ].map((c2) => c2.charCodeAt(0)));
  }
});

// node_modules/css-what/lib/es/index.js
var es_exports = {};
__export(es_exports, {
  AttributeAction: () => AttributeAction,
  IgnoreCaseMode: () => IgnoreCaseMode,
  SelectorType: () => SelectorType,
  isTraversal: () => isTraversal,
  parse: () => parse,
  stringify: () => stringify
});
var init_es = __esm({
  "node_modules/css-what/lib/es/index.js"() {
    init_types();
    init_parse();
    init_stringify();
  }
});

// node_modules/css-select/lib/sort.js
var require_sort = __commonJS({
  "node_modules/css-select/lib/sort.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTraversal = void 0;
    var css_what_1 = (init_es(), __toCommonJS(es_exports));
    var procedure = /* @__PURE__ */ new Map([
      [css_what_1.SelectorType.Universal, 50],
      [css_what_1.SelectorType.Tag, 30],
      [css_what_1.SelectorType.Attribute, 1],
      [css_what_1.SelectorType.Pseudo, 0]
    ]);
    function isTraversal2(token) {
      return !procedure.has(token.type);
    }
    exports.isTraversal = isTraversal2;
    var attributes = /* @__PURE__ */ new Map([
      [css_what_1.AttributeAction.Exists, 10],
      [css_what_1.AttributeAction.Equals, 8],
      [css_what_1.AttributeAction.Not, 7],
      [css_what_1.AttributeAction.Start, 6],
      [css_what_1.AttributeAction.End, 6],
      [css_what_1.AttributeAction.Any, 5]
    ]);
    function sortByProcedure(arr) {
      var procs = arr.map(getProcedure);
      for (var i2 = 1; i2 < arr.length; i2++) {
        var procNew = procs[i2];
        if (procNew < 0)
          continue;
        for (var j2 = i2 - 1; j2 >= 0 && procNew < procs[j2]; j2--) {
          var token = arr[j2 + 1];
          arr[j2 + 1] = arr[j2];
          arr[j2] = token;
          procs[j2 + 1] = procs[j2];
          procs[j2] = procNew;
        }
      }
    }
    exports.default = sortByProcedure;
    function getProcedure(token) {
      var _a, _b;
      var proc = (_a = procedure.get(token.type)) !== null && _a !== void 0 ? _a : -1;
      if (token.type === css_what_1.SelectorType.Attribute) {
        proc = (_b = attributes.get(token.action)) !== null && _b !== void 0 ? _b : 4;
        if (token.action === css_what_1.AttributeAction.Equals && token.name === "id") {
          proc = 9;
        }
        if (token.ignoreCase) {
          proc >>= 1;
        }
      } else if (token.type === css_what_1.SelectorType.Pseudo) {
        if (!token.data) {
          proc = 3;
        } else if (token.name === "has" || token.name === "contains") {
          proc = 0;
        } else if (Array.isArray(token.data)) {
          proc = Math.min.apply(Math, token.data.map(function(d2) {
            return Math.min.apply(Math, d2.map(getProcedure));
          }));
          if (proc < 0) {
            proc = 0;
          }
        } else {
          proc = 2;
        }
      }
      return proc;
    }
  }
});

// node_modules/css-select/lib/attributes.js
var require_attributes = __commonJS({
  "node_modules/css-select/lib/attributes.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.attributeRules = void 0;
    var boolbase_1 = __importDefault(require_boolbase());
    var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
    function escapeRegex(value) {
      return value.replace(reChars, "\\$&");
    }
    var caseInsensitiveAttributes = /* @__PURE__ */ new Set([
      "accept",
      "accept-charset",
      "align",
      "alink",
      "axis",
      "bgcolor",
      "charset",
      "checked",
      "clear",
      "codetype",
      "color",
      "compact",
      "declare",
      "defer",
      "dir",
      "direction",
      "disabled",
      "enctype",
      "face",
      "frame",
      "hreflang",
      "http-equiv",
      "lang",
      "language",
      "link",
      "media",
      "method",
      "multiple",
      "nohref",
      "noresize",
      "noshade",
      "nowrap",
      "readonly",
      "rel",
      "rev",
      "rules",
      "scope",
      "scrolling",
      "selected",
      "shape",
      "target",
      "text",
      "type",
      "valign",
      "valuetype",
      "vlink"
    ]);
    function shouldIgnoreCase(selector, options) {
      return typeof selector.ignoreCase === "boolean" ? selector.ignoreCase : selector.ignoreCase === "quirks" ? !!options.quirksMode : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);
    }
    exports.attributeRules = {
      equals: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && attr.length === value.length && attr.toLowerCase() === value && next(elem);
          };
        }
        return function(elem) {
          return adapter.getAttributeValue(elem, name) === value && next(elem);
        };
      },
      hyphen: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        var len = value.length;
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function hyphenIC(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len).toLowerCase() === value && next(elem);
          };
        }
        return function hyphen(elem) {
          var attr = adapter.getAttributeValue(elem, name);
          return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len) === value && next(elem);
        };
      },
      element: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name, value = data.value;
        if (/\s/.test(value)) {
          return boolbase_1.default.falseFunc;
        }
        var regex = new RegExp("(?:^|\\s)".concat(escapeRegex(value), "(?:$|\\s)"), shouldIgnoreCase(data, options) ? "i" : "");
        return function element(elem) {
          var attr = adapter.getAttributeValue(elem, name);
          return attr != null && attr.length >= value.length && regex.test(attr) && next(elem);
        };
      },
      exists: function(next, _a, _b) {
        var name = _a.name;
        var adapter = _b.adapter;
        return function(elem) {
          return adapter.hasAttrib(elem, name) && next(elem);
        };
      },
      start: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        var len = value.length;
        if (len === 0) {
          return boolbase_1.default.falseFunc;
        }
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && attr.length >= len && attr.substr(0, len).toLowerCase() === value && next(elem);
          };
        }
        return function(elem) {
          var _a;
          return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.startsWith(value)) && next(elem);
        };
      },
      end: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        var len = -value.length;
        if (len === 0) {
          return boolbase_1.default.falseFunc;
        }
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function(elem) {
            var _a;
            return ((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.substr(len).toLowerCase()) === value && next(elem);
          };
        }
        return function(elem) {
          var _a;
          return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.endsWith(value)) && next(elem);
        };
      },
      any: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name, value = data.value;
        if (value === "") {
          return boolbase_1.default.falseFunc;
        }
        if (shouldIgnoreCase(data, options)) {
          var regex_1 = new RegExp(escapeRegex(value), "i");
          return function anyIC(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && attr.length >= value.length && regex_1.test(attr) && next(elem);
          };
        }
        return function(elem) {
          var _a;
          return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.includes(value)) && next(elem);
        };
      },
      not: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        if (value === "") {
          return function(elem) {
            return !!adapter.getAttributeValue(elem, name) && next(elem);
          };
        } else if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return (attr == null || attr.length !== value.length || attr.toLowerCase() !== value) && next(elem);
          };
        }
        return function(elem) {
          return adapter.getAttributeValue(elem, name) !== value && next(elem);
        };
      }
    };
  }
});

// node_modules/nth-check/lib/parse.js
var require_parse = __commonJS({
  "node_modules/nth-check/lib/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = void 0;
    var whitespace = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]);
    var ZERO = "0".charCodeAt(0);
    var NINE = "9".charCodeAt(0);
    function parse2(formula) {
      formula = formula.trim().toLowerCase();
      if (formula === "even") {
        return [2, 0];
      } else if (formula === "odd") {
        return [2, 1];
      }
      var idx = 0;
      var a2 = 0;
      var sign2 = readSign();
      var number = readNumber();
      if (idx < formula.length && formula.charAt(idx) === "n") {
        idx++;
        a2 = sign2 * (number !== null && number !== void 0 ? number : 1);
        skipWhitespace2();
        if (idx < formula.length) {
          sign2 = readSign();
          skipWhitespace2();
          number = readNumber();
        } else {
          sign2 = number = 0;
        }
      }
      if (number === null || idx < formula.length) {
        throw new Error("n-th rule couldn't be parsed ('".concat(formula, "')"));
      }
      return [a2, sign2 * number];
      function readSign() {
        if (formula.charAt(idx) === "-") {
          idx++;
          return -1;
        }
        if (formula.charAt(idx) === "+") {
          idx++;
        }
        return 1;
      }
      function readNumber() {
        var start = idx;
        var value = 0;
        while (idx < formula.length && formula.charCodeAt(idx) >= ZERO && formula.charCodeAt(idx) <= NINE) {
          value = value * 10 + (formula.charCodeAt(idx) - ZERO);
          idx++;
        }
        return idx === start ? null : value;
      }
      function skipWhitespace2() {
        while (idx < formula.length && whitespace.has(formula.charCodeAt(idx))) {
          idx++;
        }
      }
    }
    exports.parse = parse2;
  }
});

// node_modules/nth-check/lib/compile.js
var require_compile = __commonJS({
  "node_modules/nth-check/lib/compile.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generate = exports.compile = void 0;
    var boolbase_1 = __importDefault(require_boolbase());
    function compile(parsed) {
      var a2 = parsed[0];
      var b3 = parsed[1] - 1;
      if (b3 < 0 && a2 <= 0)
        return boolbase_1.default.falseFunc;
      if (a2 === -1)
        return function(index) {
          return index <= b3;
        };
      if (a2 === 0)
        return function(index) {
          return index === b3;
        };
      if (a2 === 1)
        return b3 < 0 ? boolbase_1.default.trueFunc : function(index) {
          return index >= b3;
        };
      var absA = Math.abs(a2);
      var bMod = (b3 % absA + absA) % absA;
      return a2 > 1 ? function(index) {
        return index >= b3 && index % absA === bMod;
      } : function(index) {
        return index <= b3 && index % absA === bMod;
      };
    }
    exports.compile = compile;
    function generate(parsed) {
      var a2 = parsed[0];
      var b3 = parsed[1] - 1;
      var n2 = 0;
      if (a2 < 0) {
        var aPos_1 = -a2;
        var minValue_1 = (b3 % aPos_1 + aPos_1) % aPos_1;
        return function() {
          var val = minValue_1 + aPos_1 * n2++;
          return val > b3 ? null : val;
        };
      }
      if (a2 === 0)
        return b3 < 0 ? (
          // There are no result â€” always return `null`
          function() {
            return null;
          }
        ) : (
          // Return `b` exactly once
          function() {
            return n2++ === 0 ? b3 : null;
          }
        );
      if (b3 < 0) {
        b3 += a2 * Math.ceil(-b3 / a2);
      }
      return function() {
        return a2 * n2++ + b3;
      };
    }
    exports.generate = generate;
  }
});

// node_modules/nth-check/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/nth-check/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sequence = exports.generate = exports.compile = exports.parse = void 0;
    var parse_js_1 = require_parse();
    Object.defineProperty(exports, "parse", { enumerable: true, get: function() {
      return parse_js_1.parse;
    } });
    var compile_js_1 = require_compile();
    Object.defineProperty(exports, "compile", { enumerable: true, get: function() {
      return compile_js_1.compile;
    } });
    Object.defineProperty(exports, "generate", { enumerable: true, get: function() {
      return compile_js_1.generate;
    } });
    function nthCheck(formula) {
      return (0, compile_js_1.compile)((0, parse_js_1.parse)(formula));
    }
    exports.default = nthCheck;
    function sequence(formula) {
      return (0, compile_js_1.generate)((0, parse_js_1.parse)(formula));
    }
    exports.sequence = sequence;
  }
});

// node_modules/css-select/lib/pseudo-selectors/filters.js
var require_filters = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/filters.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filters = void 0;
    var nth_check_1 = __importDefault(require_lib6());
    var boolbase_1 = __importDefault(require_boolbase());
    function getChildFunc(next, adapter) {
      return function(elem) {
        var parent = adapter.getParent(elem);
        return parent != null && adapter.isTag(parent) && next(elem);
      };
    }
    exports.filters = {
      contains: function(next, text, _a) {
        var adapter = _a.adapter;
        return function contains(elem) {
          return next(elem) && adapter.getText(elem).includes(text);
        };
      },
      icontains: function(next, text, _a) {
        var adapter = _a.adapter;
        var itext = text.toLowerCase();
        return function icontains(elem) {
          return next(elem) && adapter.getText(elem).toLowerCase().includes(itext);
        };
      },
      // Location specific methods
      "nth-child": function(next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        if (func === boolbase_1.default.trueFunc)
          return getChildFunc(next, adapter);
        return function nthChild(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i2 = 0; i2 < siblings.length; i2++) {
            if (equals(elem, siblings[i2]))
              break;
            if (adapter.isTag(siblings[i2])) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      "nth-last-child": function(next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        if (func === boolbase_1.default.trueFunc)
          return getChildFunc(next, adapter);
        return function nthLastChild(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i2 = siblings.length - 1; i2 >= 0; i2--) {
            if (equals(elem, siblings[i2]))
              break;
            if (adapter.isTag(siblings[i2])) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      "nth-of-type": function(next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        if (func === boolbase_1.default.trueFunc)
          return getChildFunc(next, adapter);
        return function nthOfType(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i2 = 0; i2 < siblings.length; i2++) {
            var currentSibling = siblings[i2];
            if (equals(elem, currentSibling))
              break;
            if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      "nth-last-of-type": function(next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        if (func === boolbase_1.default.trueFunc)
          return getChildFunc(next, adapter);
        return function nthLastOfType(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i2 = siblings.length - 1; i2 >= 0; i2--) {
            var currentSibling = siblings[i2];
            if (equals(elem, currentSibling))
              break;
            if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      // TODO determine the actual root element
      root: function(next, _rule, _a) {
        var adapter = _a.adapter;
        return function(elem) {
          var parent = adapter.getParent(elem);
          return (parent == null || !adapter.isTag(parent)) && next(elem);
        };
      },
      scope: function(next, rule, options, context2) {
        var equals = options.equals;
        if (!context2 || context2.length === 0) {
          return exports.filters["root"](next, rule, options);
        }
        if (context2.length === 1) {
          return function(elem) {
            return equals(context2[0], elem) && next(elem);
          };
        }
        return function(elem) {
          return context2.includes(elem) && next(elem);
        };
      },
      hover: dynamicStatePseudo("isHovered"),
      visited: dynamicStatePseudo("isVisited"),
      active: dynamicStatePseudo("isActive")
    };
    function dynamicStatePseudo(name) {
      return function dynamicPseudo(next, _rule, _a) {
        var adapter = _a.adapter;
        var func = adapter[name];
        if (typeof func !== "function") {
          return boolbase_1.default.falseFunc;
        }
        return function active(elem) {
          return func(elem) && next(elem);
        };
      };
    }
  }
});

// node_modules/css-select/lib/pseudo-selectors/pseudos.js
var require_pseudos = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/pseudos.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyPseudoArgs = exports.pseudos = void 0;
    exports.pseudos = {
      empty: function(elem, _a) {
        var adapter = _a.adapter;
        return !adapter.getChildren(elem).some(function(elem2) {
          return adapter.isTag(elem2) || adapter.getText(elem2) !== "";
        });
      },
      "first-child": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        if (adapter.prevElementSibling) {
          return adapter.prevElementSibling(elem) == null;
        }
        var firstChild = adapter.getSiblings(elem).find(function(elem2) {
          return adapter.isTag(elem2);
        });
        return firstChild != null && equals(elem, firstChild);
      },
      "last-child": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        for (var i2 = siblings.length - 1; i2 >= 0; i2--) {
          if (equals(elem, siblings[i2]))
            return true;
          if (adapter.isTag(siblings[i2]))
            break;
        }
        return false;
      },
      "first-of-type": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        var elemName = adapter.getName(elem);
        for (var i2 = 0; i2 < siblings.length; i2++) {
          var currentSibling = siblings[i2];
          if (equals(elem, currentSibling))
            return true;
          if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
            break;
          }
        }
        return false;
      },
      "last-of-type": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        var elemName = adapter.getName(elem);
        for (var i2 = siblings.length - 1; i2 >= 0; i2--) {
          var currentSibling = siblings[i2];
          if (equals(elem, currentSibling))
            return true;
          if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
            break;
          }
        }
        return false;
      },
      "only-of-type": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var elemName = adapter.getName(elem);
        return adapter.getSiblings(elem).every(function(sibling) {
          return equals(elem, sibling) || !adapter.isTag(sibling) || adapter.getName(sibling) !== elemName;
        });
      },
      "only-child": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        return adapter.getSiblings(elem).every(function(sibling) {
          return equals(elem, sibling) || !adapter.isTag(sibling);
        });
      }
    };
    function verifyPseudoArgs(func, name, subselect, argIndex) {
      if (subselect === null) {
        if (func.length > argIndex) {
          throw new Error("Pseudo-class :".concat(name, " requires an argument"));
        }
      } else if (func.length === argIndex) {
        throw new Error("Pseudo-class :".concat(name, " doesn't have any arguments"));
      }
    }
    exports.verifyPseudoArgs = verifyPseudoArgs;
  }
});

// node_modules/css-select/lib/pseudo-selectors/aliases.js
var require_aliases = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/aliases.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.aliases = void 0;
    exports.aliases = {
      // Links
      "any-link": ":is(a, area, link)[href]",
      link: ":any-link:not(:visited)",
      // Forms
      // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
      disabled: ":is(\n        :is(button, input, select, textarea, optgroup, option)[disabled],\n        optgroup[disabled] > option,\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\n    )",
      enabled: ":not(:disabled)",
      checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
      required: ":is(input, select, textarea)[required]",
      optional: ":is(input, select, textarea):not([required])",
      // JQuery extensions
      // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
      selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
      checkbox: "[type=checkbox]",
      file: "[type=file]",
      password: "[type=password]",
      radio: "[type=radio]",
      reset: "[type=reset]",
      image: "[type=image]",
      submit: "[type=submit]",
      parent: ":not(:empty)",
      header: ":is(h1, h2, h3, h4, h5, h6)",
      button: ":is(button, input[type=button])",
      input: ":is(input, textarea, select, button)",
      text: "input:is(:not([type!='']), [type=text])"
    };
  }
});

// node_modules/css-select/lib/pseudo-selectors/subselects.js
var require_subselects = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/subselects.js"(exports) {
    "use strict";
    var __spreadArray = exports && exports.__spreadArray || function(to2, from, pack) {
      if (pack || arguments.length === 2)
        for (var i2 = 0, l2 = from.length, ar3; i2 < l2; i2++) {
          if (ar3 || !(i2 in from)) {
            if (!ar3)
              ar3 = Array.prototype.slice.call(from, 0, i2);
            ar3[i2] = from[i2];
          }
        }
      return to2.concat(ar3 || Array.prototype.slice.call(from));
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.subselects = exports.getNextSiblings = exports.ensureIsTag = exports.PLACEHOLDER_ELEMENT = void 0;
    var boolbase_1 = __importDefault(require_boolbase());
    var sort_js_1 = require_sort();
    exports.PLACEHOLDER_ELEMENT = {};
    function ensureIsTag(next, adapter) {
      if (next === boolbase_1.default.falseFunc)
        return boolbase_1.default.falseFunc;
      return function(elem) {
        return adapter.isTag(elem) && next(elem);
      };
    }
    exports.ensureIsTag = ensureIsTag;
    function getNextSiblings(elem, adapter) {
      var siblings = adapter.getSiblings(elem);
      if (siblings.length <= 1)
        return [];
      var elemIndex = siblings.indexOf(elem);
      if (elemIndex < 0 || elemIndex === siblings.length - 1)
        return [];
      return siblings.slice(elemIndex + 1).filter(adapter.isTag);
    }
    exports.getNextSiblings = getNextSiblings;
    function copyOptions(options) {
      return {
        xmlMode: !!options.xmlMode,
        lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,
        lowerCaseTags: !!options.lowerCaseTags,
        quirksMode: !!options.quirksMode,
        cacheResults: !!options.cacheResults,
        pseudos: options.pseudos,
        adapter: options.adapter,
        equals: options.equals
      };
    }
    var is = function(next, token, options, context2, compileToken) {
      var func = compileToken(token, copyOptions(options), context2);
      return func === boolbase_1.default.trueFunc ? next : func === boolbase_1.default.falseFunc ? boolbase_1.default.falseFunc : function(elem) {
        return func(elem) && next(elem);
      };
    };
    exports.subselects = {
      is,
      /**
       * `:matches` and `:where` are aliases for `:is`.
       */
      matches: is,
      where: is,
      not: function(next, token, options, context2, compileToken) {
        var func = compileToken(token, copyOptions(options), context2);
        return func === boolbase_1.default.falseFunc ? next : func === boolbase_1.default.trueFunc ? boolbase_1.default.falseFunc : function(elem) {
          return !func(elem) && next(elem);
        };
      },
      has: function(next, subselect, options, _context, compileToken) {
        var adapter = options.adapter;
        var opts = copyOptions(options);
        opts.relativeSelector = true;
        var context2 = subselect.some(function(s2) {
          return s2.some(sort_js_1.isTraversal);
        }) ? (
          // Used as a placeholder. Will be replaced with the actual element.
          [exports.PLACEHOLDER_ELEMENT]
        ) : void 0;
        var compiled = compileToken(subselect, opts, context2);
        if (compiled === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        var hasElement = ensureIsTag(compiled, adapter);
        if (context2 && compiled !== boolbase_1.default.trueFunc) {
          var _a = compiled.shouldTestNextSiblings, shouldTestNextSiblings_1 = _a === void 0 ? false : _a;
          return function(elem) {
            if (!next(elem))
              return false;
            context2[0] = elem;
            var childs = adapter.getChildren(elem);
            var nextElements = shouldTestNextSiblings_1 ? __spreadArray(__spreadArray([], childs, true), getNextSiblings(elem, adapter), true) : childs;
            return adapter.existsOne(hasElement, nextElements);
          };
        }
        return function(elem) {
          return next(elem) && adapter.existsOne(hasElement, adapter.getChildren(elem));
        };
      }
    };
  }
});

// node_modules/css-select/lib/pseudo-selectors/index.js
var require_pseudo_selectors = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compilePseudoSelector = exports.aliases = exports.pseudos = exports.filters = void 0;
    var css_what_1 = (init_es(), __toCommonJS(es_exports));
    var filters_js_1 = require_filters();
    Object.defineProperty(exports, "filters", { enumerable: true, get: function() {
      return filters_js_1.filters;
    } });
    var pseudos_js_1 = require_pseudos();
    Object.defineProperty(exports, "pseudos", { enumerable: true, get: function() {
      return pseudos_js_1.pseudos;
    } });
    var aliases_js_1 = require_aliases();
    Object.defineProperty(exports, "aliases", { enumerable: true, get: function() {
      return aliases_js_1.aliases;
    } });
    var subselects_js_1 = require_subselects();
    function compilePseudoSelector(next, selector, options, context2, compileToken) {
      var _a;
      var name = selector.name, data = selector.data;
      if (Array.isArray(data)) {
        if (!(name in subselects_js_1.subselects)) {
          throw new Error("Unknown pseudo-class :".concat(name, "(").concat(data, ")"));
        }
        return subselects_js_1.subselects[name](next, data, options, context2, compileToken);
      }
      var userPseudo = (_a = options.pseudos) === null || _a === void 0 ? void 0 : _a[name];
      var stringPseudo = typeof userPseudo === "string" ? userPseudo : aliases_js_1.aliases[name];
      if (typeof stringPseudo === "string") {
        if (data != null) {
          throw new Error("Pseudo ".concat(name, " doesn't have any arguments"));
        }
        var alias = (0, css_what_1.parse)(stringPseudo);
        return subselects_js_1.subselects["is"](next, alias, options, context2, compileToken);
      }
      if (typeof userPseudo === "function") {
        (0, pseudos_js_1.verifyPseudoArgs)(userPseudo, name, data, 1);
        return function(elem) {
          return userPseudo(elem, data) && next(elem);
        };
      }
      if (name in filters_js_1.filters) {
        return filters_js_1.filters[name](next, data, options, context2);
      }
      if (name in pseudos_js_1.pseudos) {
        var pseudo_1 = pseudos_js_1.pseudos[name];
        (0, pseudos_js_1.verifyPseudoArgs)(pseudo_1, name, data, 2);
        return function(elem) {
          return pseudo_1(elem, options, data) && next(elem);
        };
      }
      throw new Error("Unknown pseudo-class :".concat(name));
    }
    exports.compilePseudoSelector = compilePseudoSelector;
  }
});

// node_modules/css-select/lib/general.js
var require_general = __commonJS({
  "node_modules/css-select/lib/general.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compileGeneralSelector = void 0;
    var attributes_js_1 = require_attributes();
    var index_js_1 = require_pseudo_selectors();
    var css_what_1 = (init_es(), __toCommonJS(es_exports));
    function getElementParent(node, adapter) {
      var parent = adapter.getParent(node);
      if (parent && adapter.isTag(parent)) {
        return parent;
      }
      return null;
    }
    function compileGeneralSelector(next, selector, options, context2, compileToken) {
      var adapter = options.adapter, equals = options.equals;
      switch (selector.type) {
        case css_what_1.SelectorType.PseudoElement: {
          throw new Error("Pseudo-elements are not supported by css-select");
        }
        case css_what_1.SelectorType.ColumnCombinator: {
          throw new Error("Column combinators are not yet supported by css-select");
        }
        case css_what_1.SelectorType.Attribute: {
          if (selector.namespace != null) {
            throw new Error("Namespaced attributes are not yet supported by css-select");
          }
          if (!options.xmlMode || options.lowerCaseAttributeNames) {
            selector.name = selector.name.toLowerCase();
          }
          return attributes_js_1.attributeRules[selector.action](next, selector, options);
        }
        case css_what_1.SelectorType.Pseudo: {
          return (0, index_js_1.compilePseudoSelector)(next, selector, options, context2, compileToken);
        }
        case css_what_1.SelectorType.Tag: {
          if (selector.namespace != null) {
            throw new Error("Namespaced tag names are not yet supported by css-select");
          }
          var name_1 = selector.name;
          if (!options.xmlMode || options.lowerCaseTags) {
            name_1 = name_1.toLowerCase();
          }
          return function tag(elem) {
            return adapter.getName(elem) === name_1 && next(elem);
          };
        }
        case css_what_1.SelectorType.Descendant: {
          if (options.cacheResults === false || typeof WeakSet === "undefined") {
            return function descendant(elem) {
              var current = elem;
              while (current = getElementParent(current, adapter)) {
                if (next(current)) {
                  return true;
                }
              }
              return false;
            };
          }
          var isFalseCache_1 = /* @__PURE__ */ new WeakSet();
          return function cachedDescendant(elem) {
            var current = elem;
            while (current = getElementParent(current, adapter)) {
              if (!isFalseCache_1.has(current)) {
                if (adapter.isTag(current) && next(current)) {
                  return true;
                }
                isFalseCache_1.add(current);
              }
            }
            return false;
          };
        }
        case "_flexibleDescendant": {
          return function flexibleDescendant(elem) {
            var current = elem;
            do {
              if (next(current))
                return true;
            } while (current = getElementParent(current, adapter));
            return false;
          };
        }
        case css_what_1.SelectorType.Parent: {
          return function parent(elem) {
            return adapter.getChildren(elem).some(function(elem2) {
              return adapter.isTag(elem2) && next(elem2);
            });
          };
        }
        case css_what_1.SelectorType.Child: {
          return function child(elem) {
            var parent = adapter.getParent(elem);
            return parent != null && adapter.isTag(parent) && next(parent);
          };
        }
        case css_what_1.SelectorType.Sibling: {
          return function sibling(elem) {
            var siblings = adapter.getSiblings(elem);
            for (var i2 = 0; i2 < siblings.length; i2++) {
              var currentSibling = siblings[i2];
              if (equals(elem, currentSibling))
                break;
              if (adapter.isTag(currentSibling) && next(currentSibling)) {
                return true;
              }
            }
            return false;
          };
        }
        case css_what_1.SelectorType.Adjacent: {
          if (adapter.prevElementSibling) {
            return function adjacent(elem) {
              var previous = adapter.prevElementSibling(elem);
              return previous != null && next(previous);
            };
          }
          return function adjacent(elem) {
            var siblings = adapter.getSiblings(elem);
            var lastElement;
            for (var i2 = 0; i2 < siblings.length; i2++) {
              var currentSibling = siblings[i2];
              if (equals(elem, currentSibling))
                break;
              if (adapter.isTag(currentSibling)) {
                lastElement = currentSibling;
              }
            }
            return !!lastElement && next(lastElement);
          };
        }
        case css_what_1.SelectorType.Universal: {
          if (selector.namespace != null && selector.namespace !== "*") {
            throw new Error("Namespaced universal selectors are not yet supported by css-select");
          }
          return next;
        }
      }
    }
    exports.compileGeneralSelector = compileGeneralSelector;
  }
});

// node_modules/css-select/lib/compile.js
var require_compile2 = __commonJS({
  "node_modules/css-select/lib/compile.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compileToken = exports.compileUnsafe = exports.compile = void 0;
    var css_what_1 = (init_es(), __toCommonJS(es_exports));
    var boolbase_1 = __importDefault(require_boolbase());
    var sort_js_1 = __importStar(require_sort());
    var general_js_1 = require_general();
    var subselects_js_1 = require_subselects();
    function compile(selector, options, context2) {
      var next = compileUnsafe(selector, options, context2);
      return (0, subselects_js_1.ensureIsTag)(next, options.adapter);
    }
    exports.compile = compile;
    function compileUnsafe(selector, options, context2) {
      var token = typeof selector === "string" ? (0, css_what_1.parse)(selector) : selector;
      return compileToken(token, options, context2);
    }
    exports.compileUnsafe = compileUnsafe;
    function includesScopePseudo(t2) {
      return t2.type === css_what_1.SelectorType.Pseudo && (t2.name === "scope" || Array.isArray(t2.data) && t2.data.some(function(data) {
        return data.some(includesScopePseudo);
      }));
    }
    var DESCENDANT_TOKEN = { type: css_what_1.SelectorType.Descendant };
    var FLEXIBLE_DESCENDANT_TOKEN = {
      type: "_flexibleDescendant"
    };
    var SCOPE_TOKEN = {
      type: css_what_1.SelectorType.Pseudo,
      name: "scope",
      data: null
    };
    function absolutize(token, _a, context2) {
      var adapter = _a.adapter;
      var hasContext = !!(context2 === null || context2 === void 0 ? void 0 : context2.every(function(e2) {
        var parent = adapter.isTag(e2) && adapter.getParent(e2);
        return e2 === subselects_js_1.PLACEHOLDER_ELEMENT || parent && adapter.isTag(parent);
      }));
      for (var _i = 0, token_1 = token; _i < token_1.length; _i++) {
        var t2 = token_1[_i];
        if (t2.length > 0 && (0, sort_js_1.isTraversal)(t2[0]) && t2[0].type !== css_what_1.SelectorType.Descendant) {
        } else if (hasContext && !t2.some(includesScopePseudo)) {
          t2.unshift(DESCENDANT_TOKEN);
        } else {
          continue;
        }
        t2.unshift(SCOPE_TOKEN);
      }
    }
    function compileToken(token, options, context2) {
      var _a;
      token.forEach(sort_js_1.default);
      context2 = (_a = options.context) !== null && _a !== void 0 ? _a : context2;
      var isArrayContext = Array.isArray(context2);
      var finalContext = context2 && (Array.isArray(context2) ? context2 : [context2]);
      if (options.relativeSelector !== false) {
        absolutize(token, options, finalContext);
      } else if (token.some(function(t2) {
        return t2.length > 0 && (0, sort_js_1.isTraversal)(t2[0]);
      })) {
        throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");
      }
      var shouldTestNextSiblings = false;
      var query = token.map(function(rules) {
        if (rules.length >= 2) {
          var first = rules[0], second = rules[1];
          if (first.type !== css_what_1.SelectorType.Pseudo || first.name !== "scope") {
          } else if (isArrayContext && second.type === css_what_1.SelectorType.Descendant) {
            rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
          } else if (second.type === css_what_1.SelectorType.Adjacent || second.type === css_what_1.SelectorType.Sibling) {
            shouldTestNextSiblings = true;
          }
        }
        return compileRules(rules, options, finalContext);
      }).reduce(reduceRules, boolbase_1.default.falseFunc);
      query.shouldTestNextSiblings = shouldTestNextSiblings;
      return query;
    }
    exports.compileToken = compileToken;
    function compileRules(rules, options, context2) {
      var _a;
      return rules.reduce(function(previous, rule) {
        return previous === boolbase_1.default.falseFunc ? boolbase_1.default.falseFunc : (0, general_js_1.compileGeneralSelector)(previous, rule, options, context2, compileToken);
      }, (_a = options.rootFunc) !== null && _a !== void 0 ? _a : boolbase_1.default.trueFunc);
    }
    function reduceRules(a2, b3) {
      if (b3 === boolbase_1.default.falseFunc || a2 === boolbase_1.default.trueFunc) {
        return a2;
      }
      if (a2 === boolbase_1.default.falseFunc || b3 === boolbase_1.default.trueFunc) {
        return b3;
      }
      return function combine(elem) {
        return a2(elem) || b3(elem);
      };
    }
  }
});

// node_modules/css-select/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/css-select/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.aliases = exports.pseudos = exports.filters = exports.is = exports.selectOne = exports.selectAll = exports.prepareContext = exports._compileToken = exports._compileUnsafe = exports.compile = void 0;
    var DomUtils = __importStar(require_lib5());
    var boolbase_1 = __importDefault(require_boolbase());
    var compile_js_1 = require_compile2();
    var subselects_js_1 = require_subselects();
    var defaultEquals = function(a2, b3) {
      return a2 === b3;
    };
    var defaultOptions = {
      adapter: DomUtils,
      equals: defaultEquals
    };
    function convertOptionFormats(options) {
      var _a, _b, _c, _d;
      var opts = options !== null && options !== void 0 ? options : defaultOptions;
      (_a = opts.adapter) !== null && _a !== void 0 ? _a : opts.adapter = DomUtils;
      (_b = opts.equals) !== null && _b !== void 0 ? _b : opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals;
      return opts;
    }
    function wrapCompile(func) {
      return function addAdapter(selector, options, context2) {
        var opts = convertOptionFormats(options);
        return func(selector, opts, context2);
      };
    }
    exports.compile = wrapCompile(compile_js_1.compile);
    exports._compileUnsafe = wrapCompile(compile_js_1.compileUnsafe);
    exports._compileToken = wrapCompile(compile_js_1.compileToken);
    function getSelectorFunc(searchFunc) {
      return function select(query, elements, options) {
        var opts = convertOptionFormats(options);
        if (typeof query !== "function") {
          query = (0, compile_js_1.compileUnsafe)(query, opts, elements);
        }
        var filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);
        return searchFunc(query, filteredElements, opts);
      };
    }
    function prepareContext(elems, adapter, shouldTestNextSiblings) {
      if (shouldTestNextSiblings === void 0) {
        shouldTestNextSiblings = false;
      }
      if (shouldTestNextSiblings) {
        elems = appendNextSiblings(elems, adapter);
      }
      return Array.isArray(elems) ? adapter.removeSubsets(elems) : adapter.getChildren(elems);
    }
    exports.prepareContext = prepareContext;
    function appendNextSiblings(elem, adapter) {
      var elems = Array.isArray(elem) ? elem.slice(0) : [elem];
      var elemsLength = elems.length;
      for (var i2 = 0; i2 < elemsLength; i2++) {
        var nextSiblings = (0, subselects_js_1.getNextSiblings)(elems[i2], adapter);
        elems.push.apply(elems, nextSiblings);
      }
      return elems;
    }
    exports.selectAll = getSelectorFunc(function(query, elems, options) {
      return query === boolbase_1.default.falseFunc || !elems || elems.length === 0 ? [] : options.adapter.findAll(query, elems);
    });
    exports.selectOne = getSelectorFunc(function(query, elems, options) {
      return query === boolbase_1.default.falseFunc || !elems || elems.length === 0 ? null : options.adapter.findOne(query, elems);
    });
    function is(elem, query, options) {
      var opts = convertOptionFormats(options);
      return (typeof query === "function" ? query : (0, compile_js_1.compile)(query, opts))(elem);
    }
    exports.is = is;
    exports.default = exports.selectAll;
    var index_js_1 = require_pseudo_selectors();
    Object.defineProperty(exports, "filters", { enumerable: true, get: function() {
      return index_js_1.filters;
    } });
    Object.defineProperty(exports, "pseudos", { enumerable: true, get: function() {
      return index_js_1.pseudos;
    } });
    Object.defineProperty(exports, "aliases", { enumerable: true, get: function() {
      return index_js_1.aliases;
    } });
  }
});

// node_modules/node-html-parser/dist/back.js
var require_back = __commonJS({
  "node_modules/node-html-parser/dist/back.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function arr_back(arr) {
      return arr[arr.length - 1];
    }
    exports.default = arr_back;
  }
});

// node_modules/node-html-parser/dist/matcher.js
var require_matcher = __commonJS({
  "node_modules/node-html-parser/dist/matcher.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var type_1 = __importDefault(require_type());
    function isTag(node) {
      return node && node.nodeType === type_1.default.ELEMENT_NODE;
    }
    function getAttributeValue(elem, name) {
      return isTag(elem) ? elem.getAttribute(name) : void 0;
    }
    function getName(elem) {
      return (elem && elem.rawTagName || "").toLowerCase();
    }
    function getChildren(node) {
      return node && node.childNodes;
    }
    function getParent(node) {
      return node ? node.parentNode : null;
    }
    function getText(node) {
      return node.text;
    }
    function removeSubsets(nodes) {
      var idx = nodes.length;
      var node;
      var ancestor;
      var replace;
      while (--idx > -1) {
        node = ancestor = nodes[idx];
        nodes[idx] = null;
        replace = true;
        while (ancestor) {
          if (nodes.indexOf(ancestor) > -1) {
            replace = false;
            nodes.splice(idx, 1);
            break;
          }
          ancestor = getParent(ancestor);
        }
        if (replace) {
          nodes[idx] = node;
        }
      }
      return nodes;
    }
    function existsOne(test, elems) {
      return elems.some(function(elem) {
        return isTag(elem) ? test(elem) || existsOne(test, getChildren(elem)) : false;
      });
    }
    function getSiblings(node) {
      var parent = getParent(node);
      return parent ? getChildren(parent) : [];
    }
    function hasAttrib(elem, name) {
      return getAttributeValue(elem, name) !== void 0;
    }
    function findOne(test, elems) {
      var elem = null;
      for (var i2 = 0, l2 = elems === null || elems === void 0 ? void 0 : elems.length; i2 < l2 && !elem; i2++) {
        var el2 = elems[i2];
        if (test(el2)) {
          elem = el2;
        } else {
          var childs = getChildren(el2);
          if (childs && childs.length > 0) {
            elem = findOne(test, childs);
          }
        }
      }
      return elem;
    }
    function findAll(test, nodes) {
      var result = [];
      for (var i2 = 0, j2 = nodes.length; i2 < j2; i2++) {
        if (!isTag(nodes[i2]))
          continue;
        if (test(nodes[i2]))
          result.push(nodes[i2]);
        var childs = getChildren(nodes[i2]);
        if (childs)
          result = result.concat(findAll(test, childs));
      }
      return result;
    }
    exports.default = {
      isTag,
      getAttributeValue,
      getName,
      getChildren,
      getParent,
      getText,
      removeSubsets,
      existsOne,
      getSiblings,
      hasAttrib,
      findOne,
      findAll
    };
  }
});

// node_modules/node-html-parser/dist/void-tag.js
var require_void_tag = __commonJS({
  "node_modules/node-html-parser/dist/void-tag.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var VoidTag = (
      /** @class */
      function() {
        function VoidTag2(addClosingSlash, tags) {
          if (addClosingSlash === void 0) {
            addClosingSlash = false;
          }
          this.addClosingSlash = addClosingSlash;
          if (Array.isArray(tags)) {
            this.voidTags = tags.reduce(function(set, tag) {
              return set.add(tag.toLowerCase()).add(tag.toUpperCase()).add(tag);
            }, /* @__PURE__ */ new Set());
          } else {
            this.voidTags = ["area", "base", "br", "col", "embed", "hr", "img", "input", "link", "meta", "param", "source", "track", "wbr"].reduce(function(set, tag) {
              return set.add(tag.toLowerCase()).add(tag.toUpperCase()).add(tag);
            }, /* @__PURE__ */ new Set());
          }
        }
        VoidTag2.prototype.formatNode = function(tag, attrs, innerHTML) {
          var addClosingSlash = this.addClosingSlash;
          var closingSpace = addClosingSlash && attrs && !attrs.endsWith(" ") ? " " : "";
          var closingSlash = addClosingSlash ? "".concat(closingSpace, "/") : "";
          return this.isVoidElement(tag.toLowerCase()) ? "<".concat(tag).concat(attrs).concat(closingSlash, ">") : "<".concat(tag).concat(attrs, ">").concat(innerHTML, "</").concat(tag, ">");
        };
        VoidTag2.prototype.isVoidElement = function(tag) {
          return this.voidTags.has(tag);
        };
        return VoidTag2;
      }()
    );
    exports.default = VoidTag;
  }
});

// node_modules/node-html-parser/dist/nodes/text.js
var require_text = __commonJS({
  "node_modules/node-html-parser/dist/nodes/text.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d2, b3) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b4) {
          d3.__proto__ = b4;
        } || function(d3, b4) {
          for (var p2 in b4)
            if (Object.prototype.hasOwnProperty.call(b4, p2))
              d3[p2] = b4[p2];
        };
        return extendStatics(d2, b3);
      };
      return function(d2, b3) {
        if (typeof b3 !== "function" && b3 !== null)
          throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
        extendStatics(d2, b3);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var he_1 = require_he();
    var node_1 = __importDefault(require_node());
    var type_1 = __importDefault(require_type());
    var TextNode2 = (
      /** @class */
      function(_super) {
        __extends(TextNode3, _super);
        function TextNode3(rawText, parentNode, range) {
          if (parentNode === void 0) {
            parentNode = null;
          }
          var _this = _super.call(this, parentNode, range) || this;
          _this.nodeType = type_1.default.TEXT_NODE;
          _this.rawTagName = "";
          _this._rawText = rawText;
          return _this;
        }
        TextNode3.prototype.clone = function() {
          return new TextNode3(this._rawText, null);
        };
        Object.defineProperty(TextNode3.prototype, "rawText", {
          get: function() {
            return this._rawText;
          },
          /**
           * Set rawText and invalidate trimmed caches
           */
          set: function(text) {
            this._rawText = text;
            this._trimmedRawText = void 0;
            this._trimmedText = void 0;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(TextNode3.prototype, "trimmedRawText", {
          /**
           * Returns raw text with all whitespace trimmed except single leading/trailing non-breaking space
           */
          get: function() {
            if (this._trimmedRawText !== void 0)
              return this._trimmedRawText;
            this._trimmedRawText = trimText(this.rawText);
            return this._trimmedRawText;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(TextNode3.prototype, "trimmedText", {
          /**
           * Returns text with all whitespace trimmed except single leading/trailing non-breaking space
           */
          get: function() {
            if (this._trimmedText !== void 0)
              return this._trimmedText;
            this._trimmedText = trimText(this.text);
            return this._trimmedText;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(TextNode3.prototype, "text", {
          /**
           * Get unescaped text value of current node and its children.
           * @return {string} text content
           */
          get: function() {
            return (0, he_1.decode)(this.rawText);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(TextNode3.prototype, "isWhitespace", {
          /**
           * Detect if the node contains only white space.
           * @return {boolean}
           */
          get: function() {
            return /^(\s|&nbsp;)*$/.test(this.rawText);
          },
          enumerable: false,
          configurable: true
        });
        TextNode3.prototype.toString = function() {
          return this.rawText;
        };
        return TextNode3;
      }(node_1.default)
    );
    exports.default = TextNode2;
    function trimText(text) {
      var i2 = 0;
      var startPos;
      var endPos;
      while (i2 >= 0 && i2 < text.length) {
        if (/\S/.test(text[i2])) {
          if (startPos === void 0) {
            startPos = i2;
            i2 = text.length;
          } else {
            endPos = i2;
            i2 = void 0;
          }
        }
        if (startPos === void 0)
          i2++;
        else
          i2--;
      }
      if (startPos === void 0)
        startPos = 0;
      if (endPos === void 0)
        endPos = text.length - 1;
      var hasLeadingSpace = startPos > 0 && /[^\S\r\n]/.test(text[startPos - 1]);
      var hasTrailingSpace = endPos < text.length - 1 && /[^\S\r\n]/.test(text[endPos + 1]);
      return (hasLeadingSpace ? " " : "") + text.slice(startPos, endPos + 1) + (hasTrailingSpace ? " " : "");
    }
  }
});

// node_modules/node-html-parser/dist/nodes/html.js
var require_html = __commonJS({
  "node_modules/node-html-parser/dist/nodes/html.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d2, b3) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b4) {
          d3.__proto__ = b4;
        } || function(d3, b4) {
          for (var p2 in b4)
            if (Object.prototype.hasOwnProperty.call(b4, p2))
              d3[p2] = b4[p2];
        };
        return extendStatics(d2, b3);
      };
      return function(d2, b3) {
        if (typeof b3 !== "function" && b3 !== null)
          throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
        extendStatics(d2, b3);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    var __spreadArray = exports && exports.__spreadArray || function(to2, from, pack) {
      if (pack || arguments.length === 2)
        for (var i2 = 0, l2 = from.length, ar3; i2 < l2; i2++) {
          if (ar3 || !(i2 in from)) {
            if (!ar3)
              ar3 = Array.prototype.slice.call(from, 0, i2);
            ar3[i2] = from[i2];
          }
        }
      return to2.concat(ar3 || Array.prototype.slice.call(from));
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = exports.base_parse = void 0;
    var css_select_1 = require_lib7();
    var he_1 = __importDefault(require_he());
    var back_1 = __importDefault(require_back());
    var matcher_1 = __importDefault(require_matcher());
    var void_tag_1 = __importDefault(require_void_tag());
    var comment_1 = __importDefault(require_comment());
    var node_1 = __importDefault(require_node());
    var text_1 = __importDefault(require_text());
    var type_1 = __importDefault(require_type());
    function decode(val) {
      return JSON.parse(JSON.stringify(he_1.default.decode(val)));
    }
    var Htags = ["h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup"];
    var Dtags = ["details", "dialog", "dd", "div", "dt"];
    var Ftags = ["fieldset", "figcaption", "figure", "footer", "form"];
    var tableTags = ["table", "td", "tr"];
    var htmlTags = ["address", "article", "aside", "blockquote", "br", "hr", "li", "main", "nav", "ol", "p", "pre", "section", "ul"];
    var kBlockElements = /* @__PURE__ */ new Set();
    function addToKBlockElement() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var addToSet = function(array) {
        for (var index = 0; index < array.length; index++) {
          var element = array[index];
          kBlockElements.add(element);
          kBlockElements.add(element.toUpperCase());
        }
      };
      for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
        var arg = args_1[_a];
        addToSet(arg);
      }
    }
    addToKBlockElement(Htags, Dtags, Ftags, tableTags, htmlTags);
    var DOMTokenList = (
      /** @class */
      function() {
        function DOMTokenList2(valuesInit, afterUpdate) {
          if (valuesInit === void 0) {
            valuesInit = [];
          }
          if (afterUpdate === void 0) {
            afterUpdate = function() {
              return null;
            };
          }
          this._set = new Set(valuesInit);
          this._afterUpdate = afterUpdate;
        }
        DOMTokenList2.prototype._validate = function(c2) {
          if (/\s/.test(c2)) {
            throw new Error("DOMException in DOMTokenList.add: The token '".concat(c2, "' contains HTML space characters, which are not valid in tokens."));
          }
        };
        DOMTokenList2.prototype.add = function(c2) {
          this._validate(c2);
          this._set.add(c2);
          this._afterUpdate(this);
        };
        DOMTokenList2.prototype.replace = function(c1, c2) {
          this._validate(c2);
          this._set.delete(c1);
          this._set.add(c2);
          this._afterUpdate(this);
        };
        DOMTokenList2.prototype.remove = function(c2) {
          this._set.delete(c2) && this._afterUpdate(this);
        };
        DOMTokenList2.prototype.toggle = function(c2) {
          this._validate(c2);
          if (this._set.has(c2))
            this._set.delete(c2);
          else
            this._set.add(c2);
          this._afterUpdate(this);
        };
        DOMTokenList2.prototype.contains = function(c2) {
          return this._set.has(c2);
        };
        Object.defineProperty(DOMTokenList2.prototype, "length", {
          get: function() {
            return this._set.size;
          },
          enumerable: false,
          configurable: true
        });
        DOMTokenList2.prototype.values = function() {
          return this._set.values();
        };
        Object.defineProperty(DOMTokenList2.prototype, "value", {
          get: function() {
            return Array.from(this._set.values());
          },
          enumerable: false,
          configurable: true
        });
        DOMTokenList2.prototype.toString = function() {
          return Array.from(this._set.values()).join(" ");
        };
        return DOMTokenList2;
      }()
    );
    var HTMLElement4 = (
      /** @class */
      function(_super) {
        __extends(HTMLElement5, _super);
        function HTMLElement5(tagName, keyAttrs, rawAttrs, parentNode, range, voidTag, _parseOptions) {
          if (rawAttrs === void 0) {
            rawAttrs = "";
          }
          if (parentNode === void 0) {
            parentNode = null;
          }
          if (voidTag === void 0) {
            voidTag = new void_tag_1.default();
          }
          if (_parseOptions === void 0) {
            _parseOptions = {};
          }
          var _this = _super.call(this, parentNode, range) || this;
          _this.rawAttrs = rawAttrs;
          _this.voidTag = voidTag;
          _this.nodeType = type_1.default.ELEMENT_NODE;
          _this.rawTagName = tagName;
          _this.rawAttrs = rawAttrs || "";
          _this.id = keyAttrs.id || "";
          _this.childNodes = [];
          _this._parseOptions = _parseOptions;
          _this.classList = new DOMTokenList(
            keyAttrs.class ? keyAttrs.class.split(/\s+/) : [],
            function(classList) {
              return _this.setAttribute("class", classList.toString());
            }
            // eslint-disable-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
          );
          if (keyAttrs.id) {
            if (!rawAttrs) {
              _this.rawAttrs = 'id="'.concat(keyAttrs.id, '"');
            }
          }
          if (keyAttrs.class) {
            if (!rawAttrs) {
              var cls = 'class="'.concat(_this.classList.toString(), '"');
              if (_this.rawAttrs) {
                _this.rawAttrs += " ".concat(cls);
              } else {
                _this.rawAttrs = cls;
              }
            }
          }
          return _this;
        }
        HTMLElement5.prototype.quoteAttribute = function(attr) {
          if (attr == null) {
            return "null";
          }
          return JSON.stringify(attr.replace(/"/g, "&quot;")).replace(/\\t/g, "	").replace(/\\n/g, "\n").replace(/\\r/g, "\r").replace(/\\/g, "");
        };
        HTMLElement5.prototype.removeChild = function(node) {
          this.childNodes = this.childNodes.filter(function(child) {
            return child !== node;
          });
          return this;
        };
        HTMLElement5.prototype.exchangeChild = function(oldNode, newNode) {
          var children = this.childNodes;
          this.childNodes = children.map(function(child) {
            if (child === oldNode) {
              return newNode;
            }
            return child;
          });
          return this;
        };
        Object.defineProperty(HTMLElement5.prototype, "tagName", {
          get: function() {
            return this.rawTagName ? this.rawTagName.toUpperCase() : this.rawTagName;
          },
          set: function(newname) {
            this.rawTagName = newname.toLowerCase();
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(HTMLElement5.prototype, "localName", {
          get: function() {
            return this.rawTagName.toLowerCase();
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(HTMLElement5.prototype, "isVoidElement", {
          get: function() {
            return this.voidTag.isVoidElement(this.localName);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(HTMLElement5.prototype, "rawText", {
          /**
           * Get escpaed (as-it) text value of current node and its children.
           * @return {string} text content
           */
          get: function() {
            if (/^br$/i.test(this.rawTagName)) {
              return "\n";
            }
            return this.childNodes.reduce(function(pre, cur) {
              return pre += cur.rawText;
            }, "");
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(HTMLElement5.prototype, "textContent", {
          get: function() {
            return decode(this.rawText);
          },
          set: function(val) {
            var content = [new text_1.default(val, this)];
            this.childNodes = content;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(HTMLElement5.prototype, "text", {
          /**
           * Get unescaped text value of current node and its children.
           * @return {string} text content
           */
          get: function() {
            return decode(this.rawText);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(HTMLElement5.prototype, "structuredText", {
          /**
           * Get structured Text (with '\n' etc.)
           * @return {string} structured text
           */
          get: function() {
            var currentBlock = [];
            var blocks = [currentBlock];
            function dfs(node) {
              if (node.nodeType === type_1.default.ELEMENT_NODE) {
                if (kBlockElements.has(node.rawTagName)) {
                  if (currentBlock.length > 0) {
                    blocks.push(currentBlock = []);
                  }
                  node.childNodes.forEach(dfs);
                  if (currentBlock.length > 0) {
                    blocks.push(currentBlock = []);
                  }
                } else {
                  node.childNodes.forEach(dfs);
                }
              } else if (node.nodeType === type_1.default.TEXT_NODE) {
                if (node.isWhitespace) {
                  currentBlock.prependWhitespace = true;
                } else {
                  var text = node.trimmedText;
                  if (currentBlock.prependWhitespace) {
                    text = " ".concat(text);
                    currentBlock.prependWhitespace = false;
                  }
                  currentBlock.push(text);
                }
              }
            }
            dfs(this);
            return blocks.map(function(block) {
              return block.join("").replace(/\s{2,}/g, " ");
            }).join("\n").replace(/\s+$/, "");
          },
          enumerable: false,
          configurable: true
        });
        HTMLElement5.prototype.toString = function() {
          var tag = this.rawTagName;
          if (tag) {
            var attrs = this.rawAttrs ? " ".concat(this.rawAttrs) : "";
            return this.voidTag.formatNode(tag, attrs, this.innerHTML);
          }
          return this.innerHTML;
        };
        Object.defineProperty(HTMLElement5.prototype, "innerHTML", {
          get: function() {
            return this.childNodes.map(function(child) {
              return child.toString();
            }).join("");
          },
          set: function(content) {
            var r2 = parse2(content, this._parseOptions);
            var nodes = r2.childNodes.length ? r2.childNodes : [new text_1.default(content, this)];
            resetParent(nodes, this);
            resetParent(this.childNodes, null);
            this.childNodes = nodes;
          },
          enumerable: false,
          configurable: true
        });
        HTMLElement5.prototype.set_content = function(content, options) {
          if (options === void 0) {
            options = {};
          }
          if (content instanceof node_1.default) {
            content = [content];
          } else if (typeof content == "string") {
            options = __assign(__assign({}, this._parseOptions), options);
            var r2 = parse2(content, options);
            content = r2.childNodes.length ? r2.childNodes : [new text_1.default(r2.innerHTML, this)];
          }
          resetParent(this.childNodes, null);
          resetParent(content, this);
          this.childNodes = content;
          return this;
        };
        HTMLElement5.prototype.replaceWith = function() {
          var _this = this;
          var nodes = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
          }
          var parent = this.parentNode;
          var content = nodes.map(function(node) {
            if (node instanceof node_1.default) {
              return [node];
            } else if (typeof node == "string") {
              var r2 = parse2(node, _this._parseOptions);
              return r2.childNodes.length ? r2.childNodes : [new text_1.default(node, _this)];
            }
            return [];
          }).flat();
          var idx = parent.childNodes.findIndex(function(child) {
            return child === _this;
          });
          resetParent([this], null);
          parent.childNodes = __spreadArray(__spreadArray(__spreadArray([], parent.childNodes.slice(0, idx), true), resetParent(content, parent), true), parent.childNodes.slice(idx + 1), true);
          return this;
        };
        Object.defineProperty(HTMLElement5.prototype, "outerHTML", {
          get: function() {
            return this.toString();
          },
          enumerable: false,
          configurable: true
        });
        HTMLElement5.prototype.trimRight = function(pattern) {
          for (var i2 = 0; i2 < this.childNodes.length; i2++) {
            var childNode = this.childNodes[i2];
            if (childNode.nodeType === type_1.default.ELEMENT_NODE) {
              childNode.trimRight(pattern);
            } else {
              var index = childNode.rawText.search(pattern);
              if (index > -1) {
                childNode.rawText = childNode.rawText.substr(0, index);
                this.childNodes.length = i2 + 1;
              }
            }
          }
          return this;
        };
        Object.defineProperty(HTMLElement5.prototype, "structure", {
          /**
           * Get DOM structure
           * @return {string} structure
           */
          get: function() {
            var res = [];
            var indention = 0;
            function write(str) {
              res.push("  ".repeat(indention) + str);
            }
            function dfs(node) {
              var idStr = node.id ? "#".concat(node.id) : "";
              var classStr = node.classList.length ? ".".concat(node.classList.value.join(".")) : "";
              write("".concat(node.rawTagName).concat(idStr).concat(classStr));
              indention++;
              node.childNodes.forEach(function(childNode) {
                if (childNode.nodeType === type_1.default.ELEMENT_NODE) {
                  dfs(childNode);
                } else if (childNode.nodeType === type_1.default.TEXT_NODE) {
                  if (!childNode.isWhitespace) {
                    write("#text");
                  }
                }
              });
              indention--;
            }
            dfs(this);
            return res.join("\n");
          },
          enumerable: false,
          configurable: true
        });
        HTMLElement5.prototype.removeWhitespace = function() {
          var _this = this;
          var o2 = 0;
          this.childNodes.forEach(function(node) {
            if (node.nodeType === type_1.default.TEXT_NODE) {
              if (node.isWhitespace) {
                return;
              }
              node.rawText = node.trimmedRawText;
            } else if (node.nodeType === type_1.default.ELEMENT_NODE) {
              node.removeWhitespace();
            }
            _this.childNodes[o2++] = node;
          });
          this.childNodes.length = o2;
          return this;
        };
        HTMLElement5.prototype.querySelectorAll = function(selector) {
          return (0, css_select_1.selectAll)(selector, this, {
            xmlMode: true,
            adapter: matcher_1.default
          });
        };
        HTMLElement5.prototype.querySelector = function(selector) {
          return (0, css_select_1.selectOne)(selector, this, {
            xmlMode: true,
            adapter: matcher_1.default
          });
        };
        HTMLElement5.prototype.getElementsByTagName = function(tagName) {
          var upperCasedTagName = tagName.toUpperCase();
          var re3 = [];
          var stack = [];
          var currentNodeReference = this;
          var index = 0;
          while (index !== void 0) {
            var child = void 0;
            do {
              child = currentNodeReference.childNodes[index++];
            } while (index < currentNodeReference.childNodes.length && child === void 0);
            if (child === void 0) {
              currentNodeReference = currentNodeReference.parentNode;
              index = stack.pop();
              continue;
            }
            if (child.nodeType === type_1.default.ELEMENT_NODE) {
              if (tagName === "*" || child.tagName === upperCasedTagName)
                re3.push(child);
              if (child.childNodes.length > 0) {
                stack.push(index);
                currentNodeReference = child;
                index = 0;
              }
            }
          }
          return re3;
        };
        HTMLElement5.prototype.getElementById = function(id) {
          var stack = [];
          var currentNodeReference = this;
          var index = 0;
          while (index !== void 0) {
            var child = void 0;
            do {
              child = currentNodeReference.childNodes[index++];
            } while (index < currentNodeReference.childNodes.length && child === void 0);
            if (child === void 0) {
              currentNodeReference = currentNodeReference.parentNode;
              index = stack.pop();
              continue;
            }
            if (child.nodeType === type_1.default.ELEMENT_NODE) {
              if (child.id === id) {
                return child;
              }
              ;
              if (child.childNodes.length > 0) {
                stack.push(index);
                currentNodeReference = child;
                index = 0;
              }
            }
          }
          return null;
        };
        HTMLElement5.prototype.closest = function(selector) {
          var mapChild = /* @__PURE__ */ new Map();
          var el2 = this;
          var old = null;
          function findOne(test, elems) {
            var elem = null;
            for (var i2 = 0, l2 = elems.length; i2 < l2 && !elem; i2++) {
              var el_1 = elems[i2];
              if (test(el_1)) {
                elem = el_1;
              } else {
                var child = mapChild.get(el_1);
                if (child) {
                  elem = findOne(test, [child]);
                }
              }
            }
            return elem;
          }
          while (el2) {
            mapChild.set(el2, old);
            old = el2;
            el2 = el2.parentNode;
          }
          el2 = this;
          while (el2) {
            var e2 = (0, css_select_1.selectOne)(selector, el2, {
              xmlMode: true,
              adapter: __assign(__assign({}, matcher_1.default), { getChildren: function(node) {
                var child = mapChild.get(node);
                return child && [child];
              }, getSiblings: function(node) {
                return [node];
              }, findOne, findAll: function() {
                return [];
              } })
            });
            if (e2) {
              return e2;
            }
            el2 = el2.parentNode;
          }
          return null;
        };
        HTMLElement5.prototype.appendChild = function(node) {
          node.remove();
          this.childNodes.push(node);
          node.parentNode = this;
          return node;
        };
        Object.defineProperty(HTMLElement5.prototype, "firstChild", {
          /**
           * Get first child node
           * @return {Node | undefined} first child node; or undefined if none
           */
          get: function() {
            return this.childNodes[0];
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(HTMLElement5.prototype, "lastChild", {
          /**
           * Get last child node
           * @return {Node | undefined} last child node; or undefined if none
           */
          get: function() {
            return (0, back_1.default)(this.childNodes);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(HTMLElement5.prototype, "attrs", {
          /**
           * Get attributes
           * @access private
           * @return {Object} parsed and unescaped attributes
           */
          get: function() {
            if (this._attrs) {
              return this._attrs;
            }
            this._attrs = {};
            var attrs = this.rawAttributes;
            for (var key in attrs) {
              var val = attrs[key] || "";
              this._attrs[key.toLowerCase()] = decode(val);
            }
            return this._attrs;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(HTMLElement5.prototype, "attributes", {
          get: function() {
            var ret_attrs = {};
            var attrs = this.rawAttributes;
            for (var key in attrs) {
              var val = attrs[key] || "";
              ret_attrs[key] = decode(val);
            }
            return ret_attrs;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(HTMLElement5.prototype, "rawAttributes", {
          /**
           * Get escaped (as-is) attributes
           * @return {Object} parsed attributes
           */
          get: function() {
            if (this._rawAttrs) {
              return this._rawAttrs;
            }
            var attrs = {};
            if (this.rawAttrs) {
              var re3 = /([a-zA-Z()[\]#@$.?:][a-zA-Z0-9-_:()[\]#]*)(?:\s*=\s*((?:'[^']*')|(?:"[^"]*")|\S+))?/g;
              var match = void 0;
              while (match = re3.exec(this.rawAttrs)) {
                var key = match[1];
                var val = match[2] || null;
                if (val && (val[0] === "'" || val[0] === '"'))
                  val = val.slice(1, val.length - 1);
                attrs[key] = attrs[key] || val;
              }
            }
            this._rawAttrs = attrs;
            return attrs;
          },
          enumerable: false,
          configurable: true
        });
        HTMLElement5.prototype.removeAttribute = function(key) {
          var _this = this;
          var attrs = this.rawAttributes;
          delete attrs[key];
          if (this._attrs) {
            delete this._attrs[key];
          }
          this.rawAttrs = Object.keys(attrs).map(function(name) {
            var val = _this.quoteAttribute(attrs[name]);
            if (val === "null" || val === '""')
              return name;
            return "".concat(name, "=").concat(val);
          }).join(" ");
          if (key === "id") {
            this.id = "";
          }
          return this;
        };
        HTMLElement5.prototype.hasAttribute = function(key) {
          return key.toLowerCase() in this.attrs;
        };
        HTMLElement5.prototype.getAttribute = function(key) {
          return this.attrs[key.toLowerCase()];
        };
        HTMLElement5.prototype.setAttribute = function(key, value) {
          var _this = this;
          if (arguments.length < 2) {
            throw new Error("Failed to execute 'setAttribute' on 'Element'");
          }
          var k2 = key.toLowerCase();
          var attrs = this.rawAttributes;
          for (var k in attrs) {
            if (k.toLowerCase() === k2) {
              key = k;
              break;
            }
          }
          attrs[key] = String(value);
          if (this._attrs) {
            this._attrs[k2] = decode(attrs[key]);
          }
          this.rawAttrs = Object.keys(attrs).map(function(name) {
            var val = _this.quoteAttribute(attrs[name]);
            if (val === "null" || val === '""')
              return name;
            return "".concat(name, "=").concat(val);
          }).join(" ");
          if (key === "id") {
            this.id = value;
          }
          return this;
        };
        HTMLElement5.prototype.setAttributes = function(attributes) {
          var _this = this;
          if (this._attrs) {
            delete this._attrs;
          }
          if (this._rawAttrs) {
            delete this._rawAttrs;
          }
          this.rawAttrs = Object.keys(attributes).map(function(name) {
            var val = attributes[name];
            if (val === "null" || val === '""')
              return name;
            return "".concat(name, "=").concat(_this.quoteAttribute(String(val)));
          }).join(" ");
          return this;
        };
        HTMLElement5.prototype.insertAdjacentHTML = function(where, html) {
          var _a, _b, _c;
          var _this = this;
          if (arguments.length < 2) {
            throw new Error("2 arguments required");
          }
          var p2 = parse2(html, this._parseOptions);
          if (where === "afterend") {
            var idx = this.parentNode.childNodes.findIndex(function(child) {
              return child === _this;
            });
            resetParent(p2.childNodes, this.parentNode);
            (_a = this.parentNode.childNodes).splice.apply(_a, __spreadArray([idx + 1, 0], p2.childNodes, false));
          } else if (where === "afterbegin") {
            resetParent(p2.childNodes, this);
            (_b = this.childNodes).unshift.apply(_b, p2.childNodes);
          } else if (where === "beforeend") {
            p2.childNodes.forEach(function(n2) {
              _this.appendChild(n2);
            });
          } else if (where === "beforebegin") {
            var idx = this.parentNode.childNodes.findIndex(function(child) {
              return child === _this;
            });
            resetParent(p2.childNodes, this.parentNode);
            (_c = this.parentNode.childNodes).splice.apply(_c, __spreadArray([idx, 0], p2.childNodes, false));
          } else {
            throw new Error("The value provided ('".concat(where, "') is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'"));
          }
          return this;
        };
        Object.defineProperty(HTMLElement5.prototype, "nextSibling", {
          get: function() {
            if (this.parentNode) {
              var children = this.parentNode.childNodes;
              var i2 = 0;
              while (i2 < children.length) {
                var child = children[i2++];
                if (this === child)
                  return children[i2] || null;
              }
              return null;
            }
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(HTMLElement5.prototype, "nextElementSibling", {
          get: function() {
            if (this.parentNode) {
              var children = this.parentNode.childNodes;
              var i2 = 0;
              var find = false;
              while (i2 < children.length) {
                var child = children[i2++];
                if (find) {
                  if (child instanceof HTMLElement5) {
                    return child || null;
                  }
                } else if (this === child) {
                  find = true;
                }
              }
              return null;
            }
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(HTMLElement5.prototype, "previousSibling", {
          get: function() {
            if (this.parentNode) {
              var children = this.parentNode.childNodes;
              var i2 = children.length;
              while (i2 > 0) {
                var child = children[--i2];
                if (this === child)
                  return children[i2 - 1] || null;
              }
              return null;
            }
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(HTMLElement5.prototype, "previousElementSibling", {
          get: function() {
            if (this.parentNode) {
              var children = this.parentNode.childNodes;
              var i2 = children.length;
              var find = false;
              while (i2 > 0) {
                var child = children[--i2];
                if (find) {
                  if (child instanceof HTMLElement5) {
                    return child || null;
                  }
                } else if (this === child) {
                  find = true;
                }
              }
              return null;
            }
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(HTMLElement5.prototype, "classNames", {
          get: function() {
            return this.classList.toString();
          },
          enumerable: false,
          configurable: true
        });
        HTMLElement5.prototype.clone = function() {
          return parse2(this.toString(), this._parseOptions).firstChild;
        };
        return HTMLElement5;
      }(node_1.default)
    );
    exports.default = HTMLElement4;
    var kMarkupPattern = /<!--[\s\S]*?-->|<(\/?)([a-zA-Z][-.:0-9_a-zA-Z]*)((?:\s+[^>]*?(?:(?:'[^']*')|(?:"[^"]*"))?)*)\s*(\/?)>/g;
    var kAttributePattern = /(?:^|\s)(id|class)\s*=\s*((?:'[^']*')|(?:"[^"]*")|\S+)/gi;
    var kElementsClosedByOpening = {
      li: { li: true, LI: true },
      LI: { li: true, LI: true },
      p: { p: true, div: true, P: true, DIV: true },
      P: { p: true, div: true, P: true, DIV: true },
      b: { div: true, DIV: true },
      B: { div: true, DIV: true },
      td: { td: true, th: true, TD: true, TH: true },
      TD: { td: true, th: true, TD: true, TH: true },
      th: { td: true, th: true, TD: true, TH: true },
      TH: { td: true, th: true, TD: true, TH: true },
      h1: { h1: true, H1: true },
      H1: { h1: true, H1: true },
      h2: { h2: true, H2: true },
      H2: { h2: true, H2: true },
      h3: { h3: true, H3: true },
      H3: { h3: true, H3: true },
      h4: { h4: true, H4: true },
      H4: { h4: true, H4: true },
      h5: { h5: true, H5: true },
      H5: { h5: true, H5: true },
      h6: { h6: true, H6: true },
      H6: { h6: true, H6: true }
    };
    var kElementsClosedByClosing = {
      li: { ul: true, ol: true, UL: true, OL: true },
      LI: { ul: true, ol: true, UL: true, OL: true },
      a: { div: true, DIV: true },
      A: { div: true, DIV: true },
      b: { div: true, DIV: true },
      B: { div: true, DIV: true },
      i: { div: true, DIV: true },
      I: { div: true, DIV: true },
      p: { div: true, DIV: true },
      P: { div: true, DIV: true },
      td: { tr: true, table: true, TR: true, TABLE: true },
      TD: { tr: true, table: true, TR: true, TABLE: true },
      th: { tr: true, table: true, TR: true, TABLE: true },
      TH: { tr: true, table: true, TR: true, TABLE: true }
    };
    var frameflag = "documentfragmentcontainer";
    function base_parse(data, options) {
      var _a, _b;
      if (options === void 0) {
        options = {};
      }
      var voidTag = new void_tag_1.default((_a = options === null || options === void 0 ? void 0 : options.voidTag) === null || _a === void 0 ? void 0 : _a.closingSlash, (_b = options === null || options === void 0 ? void 0 : options.voidTag) === null || _b === void 0 ? void 0 : _b.tags);
      var elements = options.blockTextElements || {
        script: true,
        noscript: true,
        style: true,
        pre: true
      };
      var element_names = Object.keys(elements);
      var kBlockTextElements = element_names.map(function(it3) {
        return new RegExp("^".concat(it3, "$"), "i");
      });
      var kIgnoreElements = element_names.filter(function(it3) {
        return Boolean(elements[it3]);
      }).map(function(it3) {
        return new RegExp("^".concat(it3, "$"), "i");
      });
      function element_should_be_ignore(tag) {
        return kIgnoreElements.some(function(it3) {
          return it3.test(tag);
        });
      }
      function is_block_text_element(tag) {
        return kBlockTextElements.some(function(it3) {
          return it3.test(tag);
        });
      }
      var createRange = function(startPos, endPos) {
        return [startPos - frameFlagOffset, endPos - frameFlagOffset];
      };
      var root = new HTMLElement4(null, {}, "", null, [0, data.length], voidTag, options);
      var currentParent = root;
      var stack = [root];
      var lastTextPos = -1;
      var noNestedTagIndex = void 0;
      var match;
      data = "<".concat(frameflag, ">").concat(data, "</").concat(frameflag, ">");
      var lowerCaseTagName = options.lowerCaseTagName, fixNestedATags = options.fixNestedATags;
      var dataEndPos = data.length - (frameflag.length + 2);
      var frameFlagOffset = frameflag.length + 2;
      while (match = kMarkupPattern.exec(data)) {
        var matchText = match[0], leadingSlash = match[1], tagName = match[2], attributes = match[3], closingSlash = match[4];
        var matchLength = matchText.length;
        var tagStartPos = kMarkupPattern.lastIndex - matchLength;
        var tagEndPos = kMarkupPattern.lastIndex;
        if (lastTextPos > -1) {
          if (lastTextPos + matchLength < tagEndPos) {
            var text = data.substring(lastTextPos, tagStartPos);
            currentParent.appendChild(new text_1.default(text, currentParent, createRange(lastTextPos, tagStartPos)));
          }
        }
        lastTextPos = kMarkupPattern.lastIndex;
        if (tagName === frameflag)
          continue;
        if (matchText[1] === "!") {
          if (options.comment) {
            var text = data.substring(tagStartPos + 4, tagEndPos - 3);
            currentParent.appendChild(new comment_1.default(text, currentParent, createRange(tagStartPos, tagEndPos)));
          }
          continue;
        }
        if (lowerCaseTagName)
          tagName = tagName.toLowerCase();
        if (!leadingSlash) {
          var attrs = {};
          for (var attMatch = void 0; attMatch = kAttributePattern.exec(attributes); ) {
            var key = attMatch[1], val = attMatch[2];
            var isQuoted = val[0] === "'" || val[0] === '"';
            attrs[key.toLowerCase()] = isQuoted ? val.slice(1, val.length - 1) : val;
          }
          var parentTagName = currentParent.rawTagName;
          if (!closingSlash && kElementsClosedByOpening[parentTagName]) {
            if (kElementsClosedByOpening[parentTagName][tagName]) {
              stack.pop();
              currentParent = (0, back_1.default)(stack);
            }
          }
          if (fixNestedATags && (tagName === "a" || tagName === "A")) {
            if (noNestedTagIndex !== void 0) {
              stack.splice(noNestedTagIndex);
              currentParent = (0, back_1.default)(stack);
            }
            noNestedTagIndex = stack.length;
          }
          var tagEndPos_1 = kMarkupPattern.lastIndex;
          var tagStartPos_1 = tagEndPos_1 - matchLength;
          currentParent = currentParent.appendChild(
            // Initialize range (end position updated later for closed tags)
            new HTMLElement4(tagName, attrs, attributes.slice(1), null, createRange(tagStartPos_1, tagEndPos_1), voidTag, options)
          );
          stack.push(currentParent);
          if (is_block_text_element(tagName)) {
            var closeMarkup = "</".concat(tagName, ">");
            var closeIndex = lowerCaseTagName ? data.toLocaleLowerCase().indexOf(closeMarkup, kMarkupPattern.lastIndex) : data.indexOf(closeMarkup, kMarkupPattern.lastIndex);
            var textEndPos = closeIndex === -1 ? dataEndPos : closeIndex;
            if (element_should_be_ignore(tagName)) {
              var text = data.substring(tagEndPos_1, textEndPos);
              if (text.length > 0 && /\S/.test(text)) {
                currentParent.appendChild(new text_1.default(text, currentParent, createRange(tagEndPos_1, textEndPos)));
              }
            }
            if (closeIndex === -1) {
              lastTextPos = kMarkupPattern.lastIndex = data.length + 1;
            } else {
              lastTextPos = kMarkupPattern.lastIndex = closeIndex + closeMarkup.length;
              leadingSlash = "/";
            }
          }
        }
        if (leadingSlash || closingSlash || voidTag.isVoidElement(tagName)) {
          while (true) {
            if (noNestedTagIndex != null && (tagName === "a" || tagName === "A"))
              noNestedTagIndex = void 0;
            if (currentParent.rawTagName === tagName) {
              currentParent.range[1] = createRange(-1, Math.max(lastTextPos, tagEndPos))[1];
              stack.pop();
              currentParent = (0, back_1.default)(stack);
              break;
            } else {
              var parentTagName = currentParent.tagName;
              if (kElementsClosedByClosing[parentTagName]) {
                if (kElementsClosedByClosing[parentTagName][tagName]) {
                  stack.pop();
                  currentParent = (0, back_1.default)(stack);
                  continue;
                }
              }
              break;
            }
          }
        }
      }
      return stack;
    }
    exports.base_parse = base_parse;
    function parse2(data, options) {
      if (options === void 0) {
        options = {};
      }
      var stack = base_parse(data, options);
      var root = stack[0];
      var _loop_1 = function() {
        var last = stack.pop();
        var oneBefore = (0, back_1.default)(stack);
        if (last.parentNode && last.parentNode.parentNode) {
          if (last.parentNode === oneBefore && last.tagName === oneBefore.tagName) {
            if (options.parseNoneClosedTags !== true) {
              oneBefore.removeChild(last);
              last.childNodes.forEach(function(child) {
                oneBefore.parentNode.appendChild(child);
              });
              stack.pop();
            }
          } else {
            if (options.parseNoneClosedTags !== true) {
              oneBefore.removeChild(last);
              last.childNodes.forEach(function(child) {
                oneBefore.appendChild(child);
              });
            }
          }
        } else {
        }
      };
      while (stack.length > 1) {
        _loop_1();
      }
      return root;
    }
    exports.parse = parse2;
    function resetParent(nodes, parent) {
      return nodes.map(function(node) {
        node.parentNode = parent;
        return node;
      });
    }
  }
});

// node_modules/node-html-parser/dist/parse.js
var require_parse2 = __commonJS({
  "node_modules/node-html-parser/dist/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = void 0;
    var html_1 = require_html();
    Object.defineProperty(exports, "default", { enumerable: true, get: function() {
      return html_1.parse;
    } });
  }
});

// node_modules/node-html-parser/dist/valid.js
var require_valid = __commonJS({
  "node_modules/node-html-parser/dist/valid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var html_1 = require_html();
    function valid(data, options) {
      if (options === void 0) {
        options = {};
      }
      var stack = (0, html_1.base_parse)(data, options);
      return Boolean(stack.length === 1);
    }
    exports.default = valid;
  }
});

// node_modules/node-html-parser/dist/index.js
var require_dist = __commonJS({
  "node_modules/node-html-parser/dist/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NodeType = exports.TextNode = exports.Node = exports.valid = exports.CommentNode = exports.HTMLElement = exports.parse = void 0;
    var comment_1 = __importDefault(require_comment());
    exports.CommentNode = comment_1.default;
    var html_1 = __importDefault(require_html());
    exports.HTMLElement = html_1.default;
    var node_1 = __importDefault(require_node());
    exports.Node = node_1.default;
    var text_1 = __importDefault(require_text());
    exports.TextNode = text_1.default;
    var type_1 = __importDefault(require_type());
    exports.NodeType = type_1.default;
    var parse_1 = __importDefault(require_parse2());
    var valid_1 = __importDefault(require_valid());
    exports.valid = valid_1.default;
    function parse2(data, options) {
      if (options === void 0) {
        options = {};
      }
      return (0, parse_1.default)(data, options);
    }
    exports.default = parse2;
    exports.parse = parse2;
    parse2.parse = parse_1.default;
    parse2.HTMLElement = html_1.default;
    parse2.CommentNode = comment_1.default;
    parse2.valid = valid_1.default;
    parse2.Node = node_1.default;
    parse2.TextNode = text_1.default;
    parse2.NodeType = type_1.default;
  }
});

// node_modules/inline-style-parser/index.js
var require_inline_style_parser = __commonJS({
  "node_modules/inline-style-parser/index.js"(exports, module) {
    var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
    var NEWLINE_REGEX = /\n/g;
    var WHITESPACE_REGEX = /^\s*/;
    var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
    var COLON_REGEX = /^:\s*/;
    var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
    var SEMICOLON_REGEX = /^[;\s]*/;
    var TRIM_REGEX = /^\s+|\s+$/g;
    var NEWLINE = "\n";
    var FORWARD_SLASH = "/";
    var ASTERISK = "*";
    var EMPTY_STRING = "";
    var TYPE_COMMENT = "comment";
    var TYPE_DECLARATION = "declaration";
    module.exports = function(style, options) {
      if (typeof style !== "string") {
        throw new TypeError("First argument must be a string");
      }
      if (!style)
        return [];
      options = options || {};
      var lineno = 1;
      var column = 1;
      function updatePosition(str) {
        var lines = str.match(NEWLINE_REGEX);
        if (lines)
          lineno += lines.length;
        var i2 = str.lastIndexOf(NEWLINE);
        column = ~i2 ? str.length - i2 : column + str.length;
      }
      function position() {
        var start = { line: lineno, column };
        return function(node) {
          node.position = new Position(start);
          whitespace();
          return node;
        };
      }
      function Position(start) {
        this.start = start;
        this.end = { line: lineno, column };
        this.source = options.source;
      }
      Position.prototype.content = style;
      var errorsList = [];
      function error(msg) {
        var err = new Error(
          options.source + ":" + lineno + ":" + column + ": " + msg
        );
        err.reason = msg;
        err.filename = options.source;
        err.line = lineno;
        err.column = column;
        err.source = style;
        if (options.silent) {
          errorsList.push(err);
        } else {
          throw err;
        }
      }
      function match(re3) {
        var m = re3.exec(style);
        if (!m)
          return;
        var str = m[0];
        updatePosition(str);
        style = style.slice(str.length);
        return m;
      }
      function whitespace() {
        match(WHITESPACE_REGEX);
      }
      function comments(rules) {
        var c2;
        rules = rules || [];
        while (c2 = comment()) {
          if (c2 !== false) {
            rules.push(c2);
          }
        }
        return rules;
      }
      function comment() {
        var pos = position();
        if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1))
          return;
        var i2 = 2;
        while (EMPTY_STRING != style.charAt(i2) && (ASTERISK != style.charAt(i2) || FORWARD_SLASH != style.charAt(i2 + 1))) {
          ++i2;
        }
        i2 += 2;
        if (EMPTY_STRING === style.charAt(i2 - 1)) {
          return error("End of comment missing");
        }
        var str = style.slice(2, i2 - 2);
        column += 2;
        updatePosition(str);
        style = style.slice(i2);
        column += 2;
        return pos({
          type: TYPE_COMMENT,
          comment: str
        });
      }
      function declaration() {
        var pos = position();
        var prop = match(PROPERTY_REGEX);
        if (!prop)
          return;
        comment();
        if (!match(COLON_REGEX))
          return error("property missing ':'");
        var val = match(VALUE_REGEX);
        var ret = pos({
          type: TYPE_DECLARATION,
          property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
          value: val ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
        });
        match(SEMICOLON_REGEX);
        return ret;
      }
      function declarations() {
        var decls = [];
        comments(decls);
        var decl;
        while (decl = declaration()) {
          if (decl !== false) {
            decls.push(decl);
            comments(decls);
          }
        }
        return decls;
      }
      whitespace();
      return declarations();
    };
    function trim(str) {
      return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
    }
  }
});

// node_modules/@react-three/uikit/node_modules/prettier/plugins/babel.js
var require_babel = __commonJS({
  "node_modules/@react-three/uikit/node_modules/prettier/plugins/babel.js"(exports, module) {
    (function(f2) {
      function e2() {
        var i2 = f2();
        return i2.default || i2;
      }
      if (typeof exports == "object" && typeof module == "object")
        module.exports = e2();
      else if (typeof define == "function" && define.amd)
        define(e2);
      else {
        var t2 = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
        t2.prettierPlugins = t2.prettierPlugins || {}, t2.prettierPlugins.babel = e2();
      }
    })(function() {
      "use strict";
      var $s2 = Object.create;
      var Se3 = Object.defineProperty;
      var Vs2 = Object.getOwnPropertyDescriptor;
      var qs2 = Object.getOwnPropertyNames;
      var zs2 = Object.getPrototypeOf, Ks = Object.prototype.hasOwnProperty;
      var Hs2 = (a2, t2) => () => (t2 || a2((t2 = { exports: {} }).exports, t2), t2.exports), Ws2 = (a2, t2) => {
        for (var e2 in t2)
          Se3(a2, e2, { get: t2[e2], enumerable: true });
      }, kt3 = (a2, t2, e2, s2) => {
        if (t2 && typeof t2 == "object" || typeof t2 == "function")
          for (let i2 of qs2(t2))
            !Ks.call(a2, i2) && i2 !== e2 && Se3(a2, i2, { get: () => t2[i2], enumerable: !(s2 = Vs2(t2, i2)) || s2.enumerable });
        return a2;
      };
      var vt2 = (a2, t2, e2) => (e2 = a2 != null ? $s2(zs2(a2)) : {}, kt3(t2 || !a2 || !a2.__esModule ? Se3(e2, "default", { value: a2, enumerable: true }) : e2, a2)), Js2 = (a2) => kt3(Se3({}, "__esModule", { value: true }), a2);
      var At3 = Hs2((xe3) => {
        "use strict";
        Object.defineProperty(xe3, "__esModule", { value: true });
        function Ht2(a2, t2) {
          if (a2 == null)
            return {};
          var e2 = {}, s2 = Object.keys(a2), i2, r2;
          for (r2 = 0; r2 < s2.length; r2++)
            i2 = s2[r2], !(t2.indexOf(i2) >= 0) && (e2[i2] = a2[i2]);
          return e2;
        }
        var F = class {
          constructor(t2, e2, s2) {
            this.line = void 0, this.column = void 0, this.index = void 0, this.line = t2, this.column = e2, this.index = s2;
          }
        }, ee3 = class {
          constructor(t2, e2) {
            this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = t2, this.end = e2;
          }
        };
        function v2(a2, t2) {
          let { line: e2, column: s2, index: i2 } = a2;
          return new F(e2, s2 + t2, i2 + t2);
        }
        var Lt2 = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", Xs2 = { ImportMetaOutsideModule: { message: `import.meta may appear only with 'sourceType: "module"'`, code: Lt2 }, ImportOutsideModule: { message: `'import' and 'export' may appear only with 'sourceType: "module"'`, code: Lt2 } }, Dt2 = { ArrayPattern: "array destructuring pattern", AssignmentExpression: "assignment expression", AssignmentPattern: "assignment expression", ArrowFunctionExpression: "arrow function expression", ConditionalExpression: "conditional expression", CatchClause: "catch clause", ForOfStatement: "for-of statement", ForInStatement: "for-in statement", ForStatement: "for-loop", FormalParameters: "function parameter list", Identifier: "identifier", ImportSpecifier: "import specifier", ImportDefaultSpecifier: "import default specifier", ImportNamespaceSpecifier: "import namespace specifier", ObjectPattern: "object destructuring pattern", ParenthesizedExpression: "parenthesized expression", RestElement: "rest element", UpdateExpression: { true: "prefix operation", false: "postfix operation" }, VariableDeclarator: "variable declaration", YieldExpression: "yield expression" }, Ee2 = (a2) => a2.type === "UpdateExpression" ? Dt2.UpdateExpression[`${a2.prefix}`] : Dt2[a2.type], Gs2 = { AccessorIsGenerator: ({ kind: a2 }) => `A ${a2}ter cannot be a generator.`, ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accessor must not have any formal parameters.", BadSetterArity: "A 'set' accessor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: ({ kind: a2 }) => `Missing initializer in ${a2} declaration.`, DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.", DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.', DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: ({ exportName: a2 }) => `\`${a2}\` has already been exported. Exported identifiers must be unique.`, DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", DynamicImportPhaseRequiresImportExpressions: ({ phase: a2 }) => `'import.${a2}(...)' can only be parsed when using the 'createImportExpressions' option.`, ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: ({ localName: a2, exportName: t2 }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${a2}' as '${t2}' } from 'some-module'\`?`, ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: ({ type: a2 }) => `'${a2 === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, ForInUsing: "For-in loop may not start with 'using' declaration.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: ({ type: a2 }) => `Unsyntactic ${a2 === "BreakStatement" ? "break" : "continue"}.`, IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.", ImportBindingIsString: ({ importName: a2 }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${a2}" as foo }\`?`, ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.", ImportCallArity: ({ maxArgumentCount: a2 }) => `\`import()\` requires exactly ${a2 === 1 ? "one argument" : "one or two arguments"}.`, ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.", ImportReflectionHasAssertion: "`import module x` cannot have assertions.", ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.', IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidCoverInitializedName: "Invalid shorthand property initializer.", InvalidDecimal: "Invalid decimal.", InvalidDigit: ({ radix: a2 }) => `Expected number in radix ${a2}.`, InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: ({ reservedWord: a2 }) => `Escape sequence in keyword ${a2}.`, InvalidIdentifier: ({ identifierName: a2 }) => `Invalid identifier ${a2}.`, InvalidLhs: ({ ancestor: a2 }) => `Invalid left-hand side in ${Ee2(a2)}.`, InvalidLhsBinding: ({ ancestor: a2 }) => `Binding invalid left-hand side in ${Ee2(a2)}.`, InvalidLhsOptionalChaining: ({ ancestor: a2 }) => `Invalid optional chaining in the left-hand side of ${Ee2(a2)}.`, InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: ({ unexpected: a2 }) => `Unexpected character '${a2}'.`, InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: ({ identifierName: a2 }) => `Private name #${a2} is not defined.`, InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: ({ labelName: a2 }) => `Label '${a2}' is already declared.`, LetInLexicalBinding: "'let' is disallowed as a lexically bound name.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingPlugin: ({ missingPlugin: a2 }) => `This experimental syntax requires enabling the parser plugin: ${a2.map((t2) => JSON.stringify(t2)).join(", ")}.`, MissingOneOfPlugins: ({ missingPlugin: a2 }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${a2.map((t2) => JSON.stringify(t2)).join(", ")}.`, MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: ({ key: a2 }) => `Duplicate key "${a2}" is not allowed in module attributes.`, ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode: a2 }) => `An export name cannot include a lone surrogate, found '\\u${a2.toString(16)}'.`, ModuleExportUndefined: ({ localName: a2 }) => `Export '${a2}' is not defined.`, MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PrivateInExpectedIn: ({ identifierName: a2 }) => `Private names are only allowed in property accesses (\`obj.#${a2}\`) or in \`in\` expressions (\`#${a2} in obj\`).`, PrivateNameRedeclaration: ({ identifierName: a2 }) => `Duplicate private name #${a2}.`, RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.", SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.', StaticPrototype: "Classes may not have static property named prototype.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: ({ keyword: a2 }) => `Unexpected keyword '${a2}'.`, UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Unexpected private name.", UnexpectedReservedWord: ({ reservedWord: a2 }) => `Unexpected reserved word '${a2}'.`, UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: ({ expected: a2, unexpected: t2 }) => `Unexpected token${t2 ? ` '${t2}'.` : ""}${a2 ? `, expected "${a2}"` : ""}`, UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: ({ target: a2, onlyValidPropertyName: t2 }) => `The only valid meta property for ${a2} is ${a2}.${t2}.`, UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", UsingDeclarationExport: "Using declaration cannot be exported.", UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.", VarRedeclaration: ({ identifierName: a2 }) => `Identifier '${a2}' has already been declared.`, YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." }, Ys2 = { StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: ({ referenceName: a2 }) => `Assigning to '${a2}' in strict mode.`, StrictEvalArgumentsBinding: ({ bindingName: a2 }) => `Binding '${a2}' in strict mode.`, StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode." }, Qs2 = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), Zs = { PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: ({ token: a2 }) => `Invalid topic token ${a2}. In order to use ${a2} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${a2}" }.`, PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipeUnparenthesizedBody: ({ type: a2 }) => `Hack-style pipe body cannot be an unparenthesized ${Ee2({ type: a2 })}; please wrap it in parentheses.`, PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.' }, ei3 = ["toMessage"], ti2 = ["message"];
        function Mt2(a2, t2, e2) {
          Object.defineProperty(a2, t2, { enumerable: false, configurable: true, value: e2 });
        }
        function si2(a2) {
          let { toMessage: t2 } = a2, e2 = Ht2(a2, ei3);
          return function s2(i2, r2) {
            let n2 = new SyntaxError();
            return Object.assign(n2, e2, { loc: i2, pos: i2.index }), "missingPlugin" in r2 && Object.assign(n2, { missingPlugin: r2.missingPlugin }), Mt2(n2, "clone", function(h2 = {}) {
              var c2;
              let { line: l2, column: u2, index: f2 } = (c2 = h2.loc) != null ? c2 : i2;
              return s2(new F(l2, u2, f2), Object.assign({}, r2, h2.details));
            }), Mt2(n2, "details", r2), Object.defineProperty(n2, "message", { configurable: true, get() {
              let o2 = `${t2(r2)} (${i2.line}:${i2.column})`;
              return this.message = o2, o2;
            }, set(o2) {
              Object.defineProperty(this, "message", { value: o2, writable: true });
            } }), n2;
          };
        }
        function j2(a2, t2) {
          if (Array.isArray(a2))
            return (s2) => j2(s2, a2[0]);
          let e2 = {};
          for (let s2 of Object.keys(a2)) {
            let i2 = a2[s2], r2 = typeof i2 == "string" ? { message: () => i2 } : typeof i2 == "function" ? { message: i2 } : i2, { message: n2 } = r2, o2 = Ht2(r2, ti2), h2 = typeof n2 == "string" ? () => n2 : n2;
            e2[s2] = si2(Object.assign({ code: "BABEL_PARSER_SYNTAX_ERROR", reasonCode: s2, toMessage: h2 }, t2 ? { syntaxPlugin: t2 } : {}, o2));
          }
          return e2;
        }
        var p2 = Object.assign({}, j2(Xs2), j2(Gs2), j2(Ys2), j2`pipelineOperator`(Zs)), { defineProperty: ii2 } = Object, Ot2 = (a2, t2) => {
          a2 && ii2(a2, t2, { enumerable: false, value: a2[t2] });
        };
        function oe3(a2) {
          return Ot2(a2.loc.start, "index"), Ot2(a2.loc.end, "index"), a2;
        }
        var ri3 = (a2) => class extends a2 {
          parse() {
            let e2 = oe3(super.parse());
            return this.options.tokens && (e2.tokens = e2.tokens.map(oe3)), e2;
          }
          parseRegExpLiteral({ pattern: e2, flags: s2 }) {
            let i2 = null;
            try {
              i2 = new RegExp(e2, s2);
            } catch {
            }
            let r2 = this.estreeParseLiteral(i2);
            return r2.regex = { pattern: e2, flags: s2 }, r2;
          }
          parseBigIntLiteral(e2) {
            let s2;
            try {
              s2 = BigInt(e2);
            } catch {
              s2 = null;
            }
            let i2 = this.estreeParseLiteral(s2);
            return i2.bigint = String(i2.value || e2), i2;
          }
          parseDecimalLiteral(e2) {
            let i2 = this.estreeParseLiteral(null);
            return i2.decimal = String(i2.value || e2), i2;
          }
          estreeParseLiteral(e2) {
            return this.parseLiteral(e2, "Literal");
          }
          parseStringLiteral(e2) {
            return this.estreeParseLiteral(e2);
          }
          parseNumericLiteral(e2) {
            return this.estreeParseLiteral(e2);
          }
          parseNullLiteral() {
            return this.estreeParseLiteral(null);
          }
          parseBooleanLiteral(e2) {
            return this.estreeParseLiteral(e2);
          }
          directiveToStmt(e2) {
            let s2 = e2.value;
            delete e2.value, s2.type = "Literal", s2.raw = s2.extra.raw, s2.value = s2.extra.expressionValue;
            let i2 = e2;
            return i2.type = "ExpressionStatement", i2.expression = s2, i2.directive = s2.extra.rawValue, delete s2.extra, i2;
          }
          initFunction(e2, s2) {
            super.initFunction(e2, s2), e2.expression = false;
          }
          checkDeclaration(e2) {
            e2 != null && this.isObjectProperty(e2) ? this.checkDeclaration(e2.value) : super.checkDeclaration(e2);
          }
          getObjectOrClassMethodParams(e2) {
            return e2.value.params;
          }
          isValidDirective(e2) {
            var s2;
            return e2.type === "ExpressionStatement" && e2.expression.type === "Literal" && typeof e2.expression.value == "string" && !((s2 = e2.expression.extra) != null && s2.parenthesized);
          }
          parseBlockBody(e2, s2, i2, r2, n2) {
            super.parseBlockBody(e2, s2, i2, r2, n2);
            let o2 = e2.directives.map((h2) => this.directiveToStmt(h2));
            e2.body = o2.concat(e2.body), delete e2.directives;
          }
          pushClassMethod(e2, s2, i2, r2, n2, o2) {
            this.parseMethod(s2, i2, r2, n2, o2, "ClassMethod", true), s2.typeParameters && (s2.value.typeParameters = s2.typeParameters, delete s2.typeParameters), e2.body.push(s2);
          }
          parsePrivateName() {
            let e2 = super.parsePrivateName();
            return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(e2) : e2;
          }
          convertPrivateNameToPrivateIdentifier(e2) {
            let s2 = super.getPrivateNameSV(e2);
            return e2 = e2, delete e2.id, e2.name = s2, e2.type = "PrivateIdentifier", e2;
          }
          isPrivateName(e2) {
            return this.getPluginOption("estree", "classFeatures") ? e2.type === "PrivateIdentifier" : super.isPrivateName(e2);
          }
          getPrivateNameSV(e2) {
            return this.getPluginOption("estree", "classFeatures") ? e2.name : super.getPrivateNameSV(e2);
          }
          parseLiteral(e2, s2) {
            let i2 = super.parseLiteral(e2, s2);
            return i2.raw = i2.extra.raw, delete i2.extra, i2;
          }
          parseFunctionBody(e2, s2, i2 = false) {
            super.parseFunctionBody(e2, s2, i2), e2.expression = e2.body.type !== "BlockStatement";
          }
          parseMethod(e2, s2, i2, r2, n2, o2, h2 = false) {
            let c2 = this.startNode();
            return c2.kind = e2.kind, c2 = super.parseMethod(c2, s2, i2, r2, n2, o2, h2), c2.type = "FunctionExpression", delete c2.kind, e2.value = c2, o2 === "ClassPrivateMethod" && (e2.computed = false), this.finishNode(e2, "MethodDefinition");
          }
          nameIsConstructor(e2) {
            return e2.type === "Literal" ? e2.value === "constructor" : super.nameIsConstructor(e2);
          }
          parseClassProperty(...e2) {
            let s2 = super.parseClassProperty(...e2);
            return this.getPluginOption("estree", "classFeatures") && (s2.type = "PropertyDefinition"), s2;
          }
          parseClassPrivateProperty(...e2) {
            let s2 = super.parseClassPrivateProperty(...e2);
            return this.getPluginOption("estree", "classFeatures") && (s2.type = "PropertyDefinition", s2.computed = false), s2;
          }
          parseObjectMethod(e2, s2, i2, r2, n2) {
            let o2 = super.parseObjectMethod(e2, s2, i2, r2, n2);
            return o2 && (o2.type = "Property", o2.kind === "method" && (o2.kind = "init"), o2.shorthand = false), o2;
          }
          parseObjectProperty(e2, s2, i2, r2) {
            let n2 = super.parseObjectProperty(e2, s2, i2, r2);
            return n2 && (n2.kind = "init", n2.type = "Property"), n2;
          }
          isValidLVal(e2, s2, i2) {
            return e2 === "Property" ? "value" : super.isValidLVal(e2, s2, i2);
          }
          isAssignable(e2, s2) {
            return e2 != null && this.isObjectProperty(e2) ? this.isAssignable(e2.value, s2) : super.isAssignable(e2, s2);
          }
          toAssignable(e2, s2 = false) {
            if (e2 != null && this.isObjectProperty(e2)) {
              let { key: i2, value: r2 } = e2;
              this.isPrivateName(i2) && this.classScope.usePrivateName(this.getPrivateNameSV(i2), i2.loc.start), this.toAssignable(r2, s2);
            } else
              super.toAssignable(e2, s2);
          }
          toAssignableObjectExpressionProp(e2, s2, i2) {
            e2.type === "Property" && (e2.kind === "get" || e2.kind === "set") ? this.raise(p2.PatternHasAccessor, e2.key) : e2.type === "Property" && e2.method ? this.raise(p2.PatternHasMethod, e2.key) : super.toAssignableObjectExpressionProp(e2, s2, i2);
          }
          finishCallExpression(e2, s2) {
            let i2 = super.finishCallExpression(e2, s2);
            if (i2.callee.type === "Import") {
              if (i2.type = "ImportExpression", i2.source = i2.arguments[0], this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
                var r2, n2;
                i2.options = (r2 = i2.arguments[1]) != null ? r2 : null, i2.attributes = (n2 = i2.arguments[1]) != null ? n2 : null;
              }
              delete i2.arguments, delete i2.callee;
            }
            return i2;
          }
          toReferencedArguments(e2) {
            e2.type !== "ImportExpression" && super.toReferencedArguments(e2);
          }
          parseExport(e2, s2) {
            let i2 = this.state.lastTokStartLoc, r2 = super.parseExport(e2, s2);
            switch (r2.type) {
              case "ExportAllDeclaration":
                r2.exported = null;
                break;
              case "ExportNamedDeclaration":
                r2.specifiers.length === 1 && r2.specifiers[0].type === "ExportNamespaceSpecifier" && (r2.type = "ExportAllDeclaration", r2.exported = r2.specifiers[0].exported, delete r2.specifiers);
              case "ExportDefaultDeclaration":
                {
                  var n2;
                  let { declaration: o2 } = r2;
                  (o2 == null ? void 0 : o2.type) === "ClassDeclaration" && ((n2 = o2.decorators) == null ? void 0 : n2.length) > 0 && o2.start === r2.start && this.resetStartLocation(r2, i2);
                }
                break;
            }
            return r2;
          }
          parseSubscript(e2, s2, i2, r2) {
            let n2 = super.parseSubscript(e2, s2, i2, r2);
            if (r2.optionalChainMember) {
              if ((n2.type === "OptionalMemberExpression" || n2.type === "OptionalCallExpression") && (n2.type = n2.type.substring(8)), r2.stop) {
                let o2 = this.startNodeAtNode(n2);
                return o2.expression = n2, this.finishNode(o2, "ChainExpression");
              }
            } else
              (n2.type === "MemberExpression" || n2.type === "CallExpression") && (n2.optional = false);
            return n2;
          }
          isOptionalMemberExpression(e2) {
            return e2.type === "ChainExpression" ? e2.expression.type === "MemberExpression" : super.isOptionalMemberExpression(e2);
          }
          hasPropertyAsPrivateName(e2) {
            return e2.type === "ChainExpression" && (e2 = e2.expression), super.hasPropertyAsPrivateName(e2);
          }
          isObjectProperty(e2) {
            return e2.type === "Property" && e2.kind === "init" && !e2.method;
          }
          isObjectMethod(e2) {
            return e2.type === "Property" && (e2.method || e2.kind === "get" || e2.kind === "set");
          }
          finishNodeAt(e2, s2, i2) {
            return oe3(super.finishNodeAt(e2, s2, i2));
          }
          resetStartLocation(e2, s2) {
            super.resetStartLocation(e2, s2), oe3(e2);
          }
          resetEndLocation(e2, s2 = this.state.lastTokEndLoc) {
            super.resetEndLocation(e2, s2), oe3(e2);
          }
        }, X3 = class {
          constructor(t2, e2) {
            this.token = void 0, this.preserveSpace = void 0, this.token = t2, this.preserveSpace = !!e2;
          }
        }, C = { brace: new X3("{"), j_oTag: new X3("<tag"), j_cTag: new X3("</tag"), j_expr: new X3("<tag>...</tag>", true) };
        C.template = new X3("`", true);
        var b3 = true, m = true, $e3 = true, he3 = true, q2 = true, ai2 = true, ve3 = class {
          constructor(t2, e2 = {}) {
            this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = t2, this.keyword = e2.keyword, this.beforeExpr = !!e2.beforeExpr, this.startsExpr = !!e2.startsExpr, this.rightAssociative = !!e2.rightAssociative, this.isLoop = !!e2.isLoop, this.isAssign = !!e2.isAssign, this.prefix = !!e2.prefix, this.postfix = !!e2.postfix, this.binop = e2.binop != null ? e2.binop : null, this.updateContext = null;
          }
        }, ut3 = /* @__PURE__ */ new Map();
        function A(a2, t2 = {}) {
          t2.keyword = a2;
          let e2 = P2(a2, t2);
          return ut3.set(a2, e2), e2;
        }
        function k(a2, t2) {
          return P2(a2, { beforeExpr: b3, binop: t2 });
        }
        var ue2 = -1, U2 = [], ft2 = [], dt3 = [], mt3 = [], yt2 = [], xt3 = [];
        function P2(a2, t2 = {}) {
          var e2, s2, i2, r2;
          return ++ue2, ft2.push(a2), dt3.push((e2 = t2.binop) != null ? e2 : -1), mt3.push((s2 = t2.beforeExpr) != null ? s2 : false), yt2.push((i2 = t2.startsExpr) != null ? i2 : false), xt3.push((r2 = t2.prefix) != null ? r2 : false), U2.push(new ve3(a2, t2)), ue2;
        }
        function T3(a2, t2 = {}) {
          var e2, s2, i2, r2;
          return ++ue2, ut3.set(a2, ue2), ft2.push(a2), dt3.push((e2 = t2.binop) != null ? e2 : -1), mt3.push((s2 = t2.beforeExpr) != null ? s2 : false), yt2.push((i2 = t2.startsExpr) != null ? i2 : false), xt3.push((r2 = t2.prefix) != null ? r2 : false), U2.push(new ve3("name", t2)), ue2;
        }
        var ni2 = { bracketL: P2("[", { beforeExpr: b3, startsExpr: m }), bracketHashL: P2("#[", { beforeExpr: b3, startsExpr: m }), bracketBarL: P2("[|", { beforeExpr: b3, startsExpr: m }), bracketR: P2("]"), bracketBarR: P2("|]"), braceL: P2("{", { beforeExpr: b3, startsExpr: m }), braceBarL: P2("{|", { beforeExpr: b3, startsExpr: m }), braceHashL: P2("#{", { beforeExpr: b3, startsExpr: m }), braceR: P2("}"), braceBarR: P2("|}"), parenL: P2("(", { beforeExpr: b3, startsExpr: m }), parenR: P2(")"), comma: P2(",", { beforeExpr: b3 }), semi: P2(";", { beforeExpr: b3 }), colon: P2(":", { beforeExpr: b3 }), doubleColon: P2("::", { beforeExpr: b3 }), dot: P2("."), question: P2("?", { beforeExpr: b3 }), questionDot: P2("?."), arrow: P2("=>", { beforeExpr: b3 }), template: P2("template"), ellipsis: P2("...", { beforeExpr: b3 }), backQuote: P2("`", { startsExpr: m }), dollarBraceL: P2("${", { beforeExpr: b3, startsExpr: m }), templateTail: P2("...`", { startsExpr: m }), templateNonTail: P2("...${", { beforeExpr: b3, startsExpr: m }), at: P2("@"), hash: P2("#", { startsExpr: m }), interpreterDirective: P2("#!..."), eq: P2("=", { beforeExpr: b3, isAssign: he3 }), assign: P2("_=", { beforeExpr: b3, isAssign: he3 }), slashAssign: P2("_=", { beforeExpr: b3, isAssign: he3 }), xorAssign: P2("_=", { beforeExpr: b3, isAssign: he3 }), moduloAssign: P2("_=", { beforeExpr: b3, isAssign: he3 }), incDec: P2("++/--", { prefix: q2, postfix: ai2, startsExpr: m }), bang: P2("!", { beforeExpr: b3, prefix: q2, startsExpr: m }), tilde: P2("~", { beforeExpr: b3, prefix: q2, startsExpr: m }), doubleCaret: P2("^^", { startsExpr: m }), doubleAt: P2("@@", { startsExpr: m }), pipeline: k("|>", 0), nullishCoalescing: k("??", 1), logicalOR: k("||", 1), logicalAND: k("&&", 2), bitwiseOR: k("|", 3), bitwiseXOR: k("^", 4), bitwiseAND: k("&", 5), equality: k("==/!=/===/!==", 6), lt: k("</>/<=/>=", 7), gt: k("</>/<=/>=", 7), relational: k("</>/<=/>=", 7), bitShift: k("<</>>/>>>", 8), bitShiftL: k("<</>>/>>>", 8), bitShiftR: k("<</>>/>>>", 8), plusMin: P2("+/-", { beforeExpr: b3, binop: 9, prefix: q2, startsExpr: m }), modulo: P2("%", { binop: 10, startsExpr: m }), star: P2("*", { binop: 10 }), slash: k("/", 10), exponent: P2("**", { beforeExpr: b3, binop: 11, rightAssociative: true }), _in: A("in", { beforeExpr: b3, binop: 7 }), _instanceof: A("instanceof", { beforeExpr: b3, binop: 7 }), _break: A("break"), _case: A("case", { beforeExpr: b3 }), _catch: A("catch"), _continue: A("continue"), _debugger: A("debugger"), _default: A("default", { beforeExpr: b3 }), _else: A("else", { beforeExpr: b3 }), _finally: A("finally"), _function: A("function", { startsExpr: m }), _if: A("if"), _return: A("return", { beforeExpr: b3 }), _switch: A("switch"), _throw: A("throw", { beforeExpr: b3, prefix: q2, startsExpr: m }), _try: A("try"), _var: A("var"), _const: A("const"), _with: A("with"), _new: A("new", { beforeExpr: b3, startsExpr: m }), _this: A("this", { startsExpr: m }), _super: A("super", { startsExpr: m }), _class: A("class", { startsExpr: m }), _extends: A("extends", { beforeExpr: b3 }), _export: A("export"), _import: A("import", { startsExpr: m }), _null: A("null", { startsExpr: m }), _true: A("true", { startsExpr: m }), _false: A("false", { startsExpr: m }), _typeof: A("typeof", { beforeExpr: b3, prefix: q2, startsExpr: m }), _void: A("void", { beforeExpr: b3, prefix: q2, startsExpr: m }), _delete: A("delete", { beforeExpr: b3, prefix: q2, startsExpr: m }), _do: A("do", { isLoop: $e3, beforeExpr: b3 }), _for: A("for", { isLoop: $e3 }), _while: A("while", { isLoop: $e3 }), _as: T3("as", { startsExpr: m }), _assert: T3("assert", { startsExpr: m }), _async: T3("async", { startsExpr: m }), _await: T3("await", { startsExpr: m }), _defer: T3("defer", { startsExpr: m }), _from: T3("from", { startsExpr: m }), _get: T3("get", { startsExpr: m }), _let: T3("let", { startsExpr: m }), _meta: T3("meta", { startsExpr: m }), _of: T3("of", { startsExpr: m }), _sent: T3("sent", { startsExpr: m }), _set: T3("set", { startsExpr: m }), _source: T3("source", { startsExpr: m }), _static: T3("static", { startsExpr: m }), _using: T3("using", { startsExpr: m }), _yield: T3("yield", { startsExpr: m }), _asserts: T3("asserts", { startsExpr: m }), _checks: T3("checks", { startsExpr: m }), _exports: T3("exports", { startsExpr: m }), _global: T3("global", { startsExpr: m }), _implements: T3("implements", { startsExpr: m }), _intrinsic: T3("intrinsic", { startsExpr: m }), _infer: T3("infer", { startsExpr: m }), _is: T3("is", { startsExpr: m }), _mixins: T3("mixins", { startsExpr: m }), _proto: T3("proto", { startsExpr: m }), _require: T3("require", { startsExpr: m }), _satisfies: T3("satisfies", { startsExpr: m }), _keyof: T3("keyof", { startsExpr: m }), _readonly: T3("readonly", { startsExpr: m }), _unique: T3("unique", { startsExpr: m }), _abstract: T3("abstract", { startsExpr: m }), _declare: T3("declare", { startsExpr: m }), _enum: T3("enum", { startsExpr: m }), _module: T3("module", { startsExpr: m }), _namespace: T3("namespace", { startsExpr: m }), _interface: T3("interface", { startsExpr: m }), _type: T3("type", { startsExpr: m }), _opaque: T3("opaque", { startsExpr: m }), name: P2("name", { startsExpr: m }), string: P2("string", { startsExpr: m }), num: P2("num", { startsExpr: m }), bigint: P2("bigint", { startsExpr: m }), decimal: P2("decimal", { startsExpr: m }), regexp: P2("regexp", { startsExpr: m }), privateName: P2("#name", { startsExpr: m }), eof: P2("eof"), jsxName: P2("jsxName"), jsxText: P2("jsxText", { beforeExpr: true }), jsxTagStart: P2("jsxTagStart", { startsExpr: true }), jsxTagEnd: P2("jsxTagEnd"), placeholder: P2("%%", { startsExpr: true }) };
        function w2(a2) {
          return a2 >= 93 && a2 <= 132;
        }
        function oi2(a2) {
          return a2 <= 92;
        }
        function M3(a2) {
          return a2 >= 58 && a2 <= 132;
        }
        function Wt2(a2) {
          return a2 >= 58 && a2 <= 136;
        }
        function hi3(a2) {
          return mt3[a2];
        }
        function He2(a2) {
          return yt2[a2];
        }
        function li3(a2) {
          return a2 >= 29 && a2 <= 33;
        }
        function Ft3(a2) {
          return a2 >= 129 && a2 <= 131;
        }
        function ci3(a2) {
          return a2 >= 90 && a2 <= 92;
        }
        function Pt2(a2) {
          return a2 >= 58 && a2 <= 92;
        }
        function pi3(a2) {
          return a2 >= 39 && a2 <= 59;
        }
        function ui2(a2) {
          return a2 === 34;
        }
        function fi2(a2) {
          return xt3[a2];
        }
        function di2(a2) {
          return a2 >= 121 && a2 <= 123;
        }
        function mi(a2) {
          return a2 >= 124 && a2 <= 130;
        }
        function K2(a2) {
          return ft2[a2];
        }
        function Ie3(a2) {
          return dt3[a2];
        }
        function yi(a2) {
          return a2 === 57;
        }
        function Le3(a2) {
          return a2 >= 24 && a2 <= 25;
        }
        function R3(a2) {
          return U2[a2];
        }
        U2[8].updateContext = (a2) => {
          a2.pop();
        }, U2[5].updateContext = U2[7].updateContext = U2[23].updateContext = (a2) => {
          a2.push(C.brace);
        }, U2[22].updateContext = (a2) => {
          a2[a2.length - 1] === C.template ? a2.pop() : a2.push(C.template);
        }, U2[142].updateContext = (a2) => {
          a2.push(C.j_expr, C.j_oTag);
        };
        var gt2 = "ÂªÂµÂºÃ€-Ã–Ã˜-Ã¶Ã¸-ËË†-Ë‘Ë -Ë¤Ë¬Ë®Í°-Í´Í¶Í·Íº-Í½Í¿Î†Îˆ-ÎŠÎŒÎ-Î¡Î£-ÏµÏ·-ÒÒŠ-Ô¯Ô±-Õ–Õ™Õ -Öˆ×-×ª×¯-×²Ø -ÙŠÙ®Ù¯Ù±-Û“Û•Û¥Û¦Û®Û¯Ûº-Û¼Û¿ÜÜ’-Ü¯İ-Ş¥Ş±ßŠ-ßªß´ßµßºà €-à •à šà ¤à ¨à¡€-à¡˜à¡ -à¡ªà¡°-à¢‡à¢‰-à¢à¢ -à£‰à¤„-à¤¹à¤½à¥à¥˜-à¥¡à¥±-à¦€à¦…-à¦Œà¦à¦à¦“-à¦¨à¦ª-à¦°à¦²à¦¶-à¦¹à¦½à§à§œà§à§Ÿ-à§¡à§°à§±à§¼à¨…-à¨Šà¨à¨à¨“-à¨¨à¨ª-à¨°à¨²à¨³à¨µà¨¶à¨¸à¨¹à©™-à©œà©à©²-à©´àª…-àªàª-àª‘àª“-àª¨àªª-àª°àª²àª³àªµ-àª¹àª½à«à« à«¡à«¹à¬…-à¬Œà¬à¬à¬“-à¬¨à¬ª-à¬°à¬²à¬³à¬µ-à¬¹à¬½à­œà­à­Ÿ-à­¡à­±à®ƒà®…-à®Šà®-à®à®’-à®•à®™à®šà®œà®à®Ÿà®£à®¤à®¨-à®ªà®®-à®¹à¯à°…-à°Œà°-à°à°’-à°¨à°ª-à°¹à°½à±˜-à±šà±à± à±¡à²€à²…-à²Œà²-à²à²’-à²¨à²ª-à²³à²µ-à²¹à²½à³à³à³ à³¡à³±à³²à´„-à´Œà´-à´à´’-à´ºà´½àµàµ”-àµ–àµŸ-àµ¡àµº-àµ¿à¶…-à¶–à¶š-à¶±à¶³-à¶»à¶½à·€-à·†à¸-à¸°à¸²à¸³à¹€-à¹†àºàº‚àº„àº†-àºŠàºŒ-àº£àº¥àº§-àº°àº²àº³àº½à»€-à»„à»†à»œ-à»Ÿà¼€à½€-à½‡à½‰-à½¬à¾ˆ-à¾Œá€€-á€ªá€¿á-á•áš-áá¡á¥á¦á®-á°áµ-á‚á‚á‚ -áƒ…áƒ‡áƒáƒ-áƒºáƒ¼-á‰ˆá‰Š-á‰á‰-á‰–á‰˜á‰š-á‰á‰ -áŠˆáŠŠ-áŠáŠ-áŠ°áŠ²-áŠµáŠ¸-áŠ¾á‹€á‹‚-á‹…á‹ˆ-á‹–á‹˜-áŒáŒ’-áŒ•áŒ˜-ášá€-áá -áµá¸-á½á-á™¬á™¯-á™¿áš-áššáš -á›ªá›®-á›¸áœ€-áœ‘áœŸ-áœ±á€-á‘á -á¬á®-á°á€-á³áŸ—áŸœá  -á¡¸á¢€-á¢¨á¢ªá¢°-á£µá¤€-á¤á¥-á¥­á¥°-á¥´á¦€-á¦«á¦°-á§‰á¨€-á¨–á¨ -á©”áª§á¬…-á¬³á­…-á­Œá®ƒ-á® á®®á®¯á®º-á¯¥á°€-á°£á±-á±á±š-á±½á²€-á²ˆá²-á²ºá²½-á²¿á³©-á³¬á³®-á³³á³µá³¶á³ºá´€-á¶¿á¸€-á¼•á¼˜-á¼á¼ -á½…á½ˆ-á½á½-á½—á½™á½›á½á½Ÿ-á½½á¾€-á¾´á¾¶-á¾¼á¾¾á¿‚-á¿„á¿†-á¿Œá¿-á¿“á¿–-á¿›á¿ -á¿¬á¿²-á¿´á¿¶-á¿¼â±â¿â‚-â‚œâ„‚â„‡â„Š-â„“â„•â„˜-â„â„¤â„¦â„¨â„ª-â„¹â„¼-â„¿â……-â…‰â…â… -â†ˆâ°€-â³¤â³«-â³®â³²â³³â´€-â´¥â´§â´­â´°-âµ§âµ¯â¶€-â¶–â¶ -â¶¦â¶¨-â¶®â¶°-â¶¶â¶¸-â¶¾â·€-â·†â·ˆ-â·â·-â·–â·˜-â·ã€…-ã€‡ã€¡-ã€©ã€±-ã€µã€¸-ã€¼ã-ã‚–ã‚›-ã‚Ÿã‚¡-ãƒºãƒ¼-ãƒ¿ã„…-ã„¯ã„±-ã†ã† -ã†¿ã‡°-ã‡¿ã€-ä¶¿ä¸€-ê’Œê“-ê“½ê”€-ê˜Œê˜-ê˜Ÿê˜ªê˜«ê™€-ê™®ê™¿-êšêš -ê›¯êœ—-êœŸêœ¢-êˆê‹-êŸŠêŸêŸ‘êŸ“êŸ•-êŸ™êŸ²-ê ê ƒ-ê …ê ‡-ê Šê Œ-ê ¢ê¡€-ê¡³ê¢‚-ê¢³ê£²-ê£·ê£»ê£½ê£¾ê¤Š-ê¤¥ê¤°-ê¥†ê¥ -ê¥¼ê¦„-ê¦²ê§ê§ -ê§¤ê§¦-ê§¯ê§º-ê§¾ê¨€-ê¨¨ê©€-ê©‚ê©„-ê©‹ê© -ê©¶ê©ºê©¾-êª¯êª±êªµêª¶êª¹-êª½ê«€ê«‚ê«›-ê«ê« -ê«ªê«²-ê«´ê¬-ê¬†ê¬‰-ê¬ê¬‘-ê¬–ê¬ -ê¬¦ê¬¨-ê¬®ê¬°-ê­šê­œ-ê­©ê­°-ê¯¢ê°€-í£í°-íŸ†íŸ‹-íŸ»ï¤€-ï©­ï©°-ï«™ï¬€-ï¬†ï¬“-ï¬—ï¬ï¬Ÿ-ï¬¨ï¬ª-ï¬¶ï¬¸-ï¬¼ï¬¾ï­€ï­ï­ƒï­„ï­†-ï®±ï¯“-ï´½ïµ-ï¶ï¶’-ï·‡ï·°-ï·»ï¹°-ï¹´ï¹¶-ï»¼ï¼¡-ï¼ºï½-ï½šï½¦-ï¾¾ï¿‚-ï¿‡ï¿Š-ï¿ï¿’-ï¿—ï¿š-ï¿œ", Jt2 = "â€Œâ€Â·Ì€-Í¯Î‡Òƒ-Ò‡Ö‘-Ö½Ö¿××‚×„×…×‡Ø-ØšÙ‹-Ù©Ù°Û–-ÛœÛŸ-Û¤Û§Û¨Ûª-Û­Û°-Û¹Ü‘Ü°-İŠŞ¦-Ş°ß€-ß‰ß«-ß³ß½à –-à ™à ›-à £à ¥-à §à ©-à ­à¡™-à¡›à¢˜-à¢Ÿà£Š-à£¡à££-à¤ƒà¤º-à¤¼à¤¾-à¥à¥‘-à¥—à¥¢à¥£à¥¦-à¥¯à¦-à¦ƒà¦¼à¦¾-à§„à§‡à§ˆà§‹-à§à§—à§¢à§£à§¦-à§¯à§¾à¨-à¨ƒà¨¼à¨¾-à©‚à©‡à©ˆà©‹-à©à©‘à©¦-à©±à©µàª-àªƒàª¼àª¾-à«…à«‡-à«‰à«‹-à«à«¢à«£à«¦-à«¯à«º-à«¿à¬-à¬ƒà¬¼à¬¾-à­„à­‡à­ˆà­‹-à­à­•-à­—à­¢à­£à­¦-à­¯à®‚à®¾-à¯‚à¯†-à¯ˆà¯Š-à¯à¯—à¯¦-à¯¯à°€-à°„à°¼à°¾-à±„à±†-à±ˆà±Š-à±à±•à±–à±¢à±£à±¦-à±¯à²-à²ƒà²¼à²¾-à³„à³†-à³ˆà³Š-à³à³•à³–à³¢à³£à³¦-à³¯à³³à´€-à´ƒà´»à´¼à´¾-àµ„àµ†-àµˆàµŠ-àµàµ—àµ¢àµ£àµ¦-àµ¯à¶-à¶ƒà·Šà·-à·”à·–à·˜-à·Ÿà·¦-à·¯à·²à·³à¸±à¸´-à¸ºà¹‡-à¹à¹-à¹™àº±àº´-àº¼à»ˆ-à»à»-à»™à¼˜à¼™à¼ -à¼©à¼µà¼·à¼¹à¼¾à¼¿à½±-à¾„à¾†à¾‡à¾-à¾—à¾™-à¾¼à¿†á€«-á€¾á€-á‰á–-á™á-á á¢-á¤á§-á­á±-á´á‚‚-á‚á‚-á‚á-áŸá©-á±áœ’-áœ•áœ²-áœ´á’á“á²á³á´-áŸ“áŸáŸ -áŸ©á ‹-á á -á ™á¢©á¤ -á¤«á¤°-á¤»á¥†-á¥á§-á§šá¨—-á¨›á©•-á©á© -á©¼á©¿-áª‰áª-áª™áª°-áª½áª¿-á«á¬€-á¬„á¬´-á­„á­-á­™á­«-á­³á®€-á®‚á®¡-á®­á®°-á®¹á¯¦-á¯³á°¤-á°·á±€-á±‰á±-á±™á³-á³’á³”-á³¨á³­á³´á³·-á³¹á·€-á·¿â€Œâ€â€¿â€â”âƒ-âƒœâƒ¡âƒ¥-âƒ°â³¯-â³±âµ¿â· -â·¿ã€ª-ã€¯ã‚™ã‚šãƒ»ê˜ -ê˜©ê™¯ê™´-ê™½êšêšŸê›°ê›±ê ‚ê †ê ‹ê £-ê §ê ¬ê¢€ê¢ê¢´-ê£…ê£-ê£™ê£ -ê£±ê£¿-ê¤‰ê¤¦-ê¤­ê¥‡-ê¥“ê¦€-ê¦ƒê¦³-ê§€ê§-ê§™ê§¥ê§°-ê§¹ê¨©-ê¨¶ê©ƒê©Œê©ê©-ê©™ê©»-ê©½êª°êª²-êª´êª·êª¸êª¾êª¿ê«ê««-ê«¯ê«µê«¶ê¯£-ê¯ªê¯¬ê¯­ê¯°-ê¯¹ï¬ï¸€-ï¸ï¸ -ï¸¯ï¸³ï¸´ï¹-ï¹ï¼-ï¼™ï¼¿ï½¥", xi = new RegExp("[" + gt2 + "]"), Pi = new RegExp("[" + gt2 + Jt2 + "]");
        gt2 = Jt2 = null;
        var Xt = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], gi = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
        function We2(a2, t2) {
          let e2 = 65536;
          for (let s2 = 0, i2 = t2.length; s2 < i2; s2 += 2) {
            if (e2 += t2[s2], e2 > a2)
              return false;
            if (e2 += t2[s2 + 1], e2 >= a2)
              return true;
          }
          return false;
        }
        function _3(a2) {
          return a2 < 65 ? a2 === 36 : a2 <= 90 ? true : a2 < 97 ? a2 === 95 : a2 <= 122 ? true : a2 <= 65535 ? a2 >= 170 && xi.test(String.fromCharCode(a2)) : We2(a2, Xt);
        }
        function Q3(a2) {
          return a2 < 48 ? a2 === 36 : a2 < 58 ? true : a2 < 65 ? false : a2 <= 90 ? true : a2 < 97 ? a2 === 95 : a2 <= 122 ? true : a2 <= 65535 ? a2 >= 170 && Pi.test(String.fromCharCode(a2)) : We2(a2, Xt) || We2(a2, gi);
        }
        var Tt2 = { keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"], strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], strictBind: ["eval", "arguments"] }, Ti2 = new Set(Tt2.keyword), bi = new Set(Tt2.strict), Ai2 = new Set(Tt2.strictBind);
        function Gt2(a2, t2) {
          return t2 && a2 === "await" || a2 === "enum";
        }
        function Yt2(a2, t2) {
          return Gt2(a2, t2) || bi.has(a2);
        }
        function Qt2(a2) {
          return Ai2.has(a2);
        }
        function Zt(a2, t2) {
          return Yt2(a2, t2) || Qt2(a2);
        }
        function Si2(a2) {
          return Ti2.has(a2);
        }
        function wi(a2, t2, e2) {
          return a2 === 64 && t2 === 64 && _3(e2);
        }
        var Ci = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
        function Ei(a2) {
          return Ci.has(a2);
        }
        var de2 = class {
          constructor(t2) {
            this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = t2;
          }
        }, me2 = class {
          constructor(t2, e2) {
            this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = t2, this.inModule = e2;
          }
          get inTopLevel() {
            return (this.currentScope().flags & 1) > 0;
          }
          get inFunction() {
            return (this.currentVarScopeFlags() & 2) > 0;
          }
          get allowSuper() {
            return (this.currentThisScopeFlags() & 16) > 0;
          }
          get allowDirectSuper() {
            return (this.currentThisScopeFlags() & 32) > 0;
          }
          get inClass() {
            return (this.currentThisScopeFlags() & 64) > 0;
          }
          get inClassAndNotInNonArrowFunction() {
            let t2 = this.currentThisScopeFlags();
            return (t2 & 64) > 0 && (t2 & 2) === 0;
          }
          get inStaticBlock() {
            for (let t2 = this.scopeStack.length - 1; ; t2--) {
              let { flags: e2 } = this.scopeStack[t2];
              if (e2 & 128)
                return true;
              if (e2 & 451)
                return false;
            }
          }
          get inNonArrowFunction() {
            return (this.currentThisScopeFlags() & 2) > 0;
          }
          get treatFunctionsAsVar() {
            return this.treatFunctionsAsVarInScope(this.currentScope());
          }
          createScope(t2) {
            return new de2(t2);
          }
          enter(t2) {
            this.scopeStack.push(this.createScope(t2));
          }
          exit() {
            return this.scopeStack.pop().flags;
          }
          treatFunctionsAsVarInScope(t2) {
            return !!(t2.flags & 130 || !this.parser.inModule && t2.flags & 1);
          }
          declareName(t2, e2, s2) {
            let i2 = this.currentScope();
            if (e2 & 8 || e2 & 16) {
              this.checkRedeclarationInScope(i2, t2, e2, s2);
              let r2 = i2.names.get(t2) || 0;
              e2 & 16 ? r2 = r2 | 4 : (i2.firstLexicalName || (i2.firstLexicalName = t2), r2 = r2 | 2), i2.names.set(t2, r2), e2 & 8 && this.maybeExportDefined(i2, t2);
            } else if (e2 & 4)
              for (let r2 = this.scopeStack.length - 1; r2 >= 0 && (i2 = this.scopeStack[r2], this.checkRedeclarationInScope(i2, t2, e2, s2), i2.names.set(t2, (i2.names.get(t2) || 0) | 1), this.maybeExportDefined(i2, t2), !(i2.flags & 387)); --r2)
                ;
            this.parser.inModule && i2.flags & 1 && this.undefinedExports.delete(t2);
          }
          maybeExportDefined(t2, e2) {
            this.parser.inModule && t2.flags & 1 && this.undefinedExports.delete(e2);
          }
          checkRedeclarationInScope(t2, e2, s2, i2) {
            this.isRedeclaredInScope(t2, e2, s2) && this.parser.raise(p2.VarRedeclaration, i2, { identifierName: e2 });
          }
          isRedeclaredInScope(t2, e2, s2) {
            if (!(s2 & 1))
              return false;
            if (s2 & 8)
              return t2.names.has(e2);
            let i2 = t2.names.get(e2);
            return s2 & 16 ? (i2 & 2) > 0 || !this.treatFunctionsAsVarInScope(t2) && (i2 & 1) > 0 : (i2 & 2) > 0 && !(t2.flags & 8 && t2.firstLexicalName === e2) || !this.treatFunctionsAsVarInScope(t2) && (i2 & 4) > 0;
          }
          checkLocalExport(t2) {
            let { name: e2 } = t2;
            this.scopeStack[0].names.has(e2) || this.undefinedExports.set(e2, t2.loc.start);
          }
          currentScope() {
            return this.scopeStack[this.scopeStack.length - 1];
          }
          currentVarScopeFlags() {
            for (let t2 = this.scopeStack.length - 1; ; t2--) {
              let { flags: e2 } = this.scopeStack[t2];
              if (e2 & 387)
                return e2;
            }
          }
          currentThisScopeFlags() {
            for (let t2 = this.scopeStack.length - 1; ; t2--) {
              let { flags: e2 } = this.scopeStack[t2];
              if (e2 & 451 && !(e2 & 4))
                return e2;
            }
          }
        }, Je2 = class extends de2 {
          constructor(...t2) {
            super(...t2), this.declareFunctions = /* @__PURE__ */ new Set();
          }
        }, Xe2 = class extends me2 {
          createScope(t2) {
            return new Je2(t2);
          }
          declareName(t2, e2, s2) {
            let i2 = this.currentScope();
            if (e2 & 2048) {
              this.checkRedeclarationInScope(i2, t2, e2, s2), this.maybeExportDefined(i2, t2), i2.declareFunctions.add(t2);
              return;
            }
            super.declareName(t2, e2, s2);
          }
          isRedeclaredInScope(t2, e2, s2) {
            if (super.isRedeclaredInScope(t2, e2, s2))
              return true;
            if (s2 & 2048 && !t2.declareFunctions.has(e2)) {
              let i2 = t2.names.get(e2);
              return (i2 & 4) > 0 || (i2 & 2) > 0;
            }
            return false;
          }
          checkLocalExport(t2) {
            this.scopeStack[0].declareFunctions.has(t2.name) || super.checkLocalExport(t2);
          }
        }, Ge3 = class {
          constructor() {
            this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
          }
          hasPlugin(t2) {
            if (typeof t2 == "string")
              return this.plugins.has(t2);
            {
              let [e2, s2] = t2;
              if (!this.hasPlugin(e2))
                return false;
              let i2 = this.plugins.get(e2);
              for (let r2 of Object.keys(s2))
                if ((i2 == null ? void 0 : i2[r2]) !== s2[r2])
                  return false;
              return true;
            }
          }
          getPluginOption(t2, e2) {
            var s2;
            return (s2 = this.plugins.get(t2)) == null ? void 0 : s2[e2];
          }
        };
        function es(a2, t2) {
          a2.trailingComments === void 0 ? a2.trailingComments = t2 : a2.trailingComments.unshift(...t2);
        }
        function Ii2(a2, t2) {
          a2.leadingComments === void 0 ? a2.leadingComments = t2 : a2.leadingComments.unshift(...t2);
        }
        function ye(a2, t2) {
          a2.innerComments === void 0 ? a2.innerComments = t2 : a2.innerComments.unshift(...t2);
        }
        function le2(a2, t2, e2) {
          let s2 = null, i2 = t2.length;
          for (; s2 === null && i2 > 0; )
            s2 = t2[--i2];
          s2 === null || s2.start > e2.start ? ye(a2, e2.comments) : es(s2, e2.comments);
        }
        var Ye2 = class extends Ge3 {
          addComment(t2) {
            this.filename && (t2.loc.filename = this.filename);
            let { commentsLen: e2 } = this.state;
            this.comments.length !== e2 && (this.comments.length = e2), this.comments.push(t2), this.state.commentsLen++;
          }
          processComment(t2) {
            let { commentStack: e2 } = this.state, s2 = e2.length;
            if (s2 === 0)
              return;
            let i2 = s2 - 1, r2 = e2[i2];
            r2.start === t2.end && (r2.leadingNode = t2, i2--);
            let { start: n2 } = t2;
            for (; i2 >= 0; i2--) {
              let o2 = e2[i2], h2 = o2.end;
              if (h2 > n2)
                o2.containingNode = t2, this.finalizeComment(o2), e2.splice(i2, 1);
              else {
                h2 === n2 && (o2.trailingNode = t2);
                break;
              }
            }
          }
          finalizeComment(t2) {
            let { comments: e2 } = t2;
            if (t2.leadingNode !== null || t2.trailingNode !== null)
              t2.leadingNode !== null && es(t2.leadingNode, e2), t2.trailingNode !== null && Ii2(t2.trailingNode, e2);
            else {
              let { containingNode: s2, start: i2 } = t2;
              if (this.input.charCodeAt(i2 - 1) === 44)
                switch (s2.type) {
                  case "ObjectExpression":
                  case "ObjectPattern":
                  case "RecordExpression":
                    le2(s2, s2.properties, t2);
                    break;
                  case "CallExpression":
                  case "OptionalCallExpression":
                    le2(s2, s2.arguments, t2);
                    break;
                  case "FunctionDeclaration":
                  case "FunctionExpression":
                  case "ArrowFunctionExpression":
                  case "ObjectMethod":
                  case "ClassMethod":
                  case "ClassPrivateMethod":
                    le2(s2, s2.params, t2);
                    break;
                  case "ArrayExpression":
                  case "ArrayPattern":
                  case "TupleExpression":
                    le2(s2, s2.elements, t2);
                    break;
                  case "ExportNamedDeclaration":
                  case "ImportDeclaration":
                    le2(s2, s2.specifiers, t2);
                    break;
                  default:
                    ye(s2, e2);
                }
              else
                ye(s2, e2);
            }
          }
          finalizeRemainingComments() {
            let { commentStack: t2 } = this.state;
            for (let e2 = t2.length - 1; e2 >= 0; e2--)
              this.finalizeComment(t2[e2]);
            this.state.commentStack = [];
          }
          resetPreviousNodeTrailingComments(t2) {
            let { commentStack: e2 } = this.state, { length: s2 } = e2;
            if (s2 === 0)
              return;
            let i2 = e2[s2 - 1];
            i2.leadingNode === t2 && (i2.leadingNode = null);
          }
          resetPreviousIdentifierLeadingComments(t2) {
            let { commentStack: e2 } = this.state, { length: s2 } = e2;
            s2 !== 0 && (e2[s2 - 1].trailingNode === t2 ? e2[s2 - 1].trailingNode = null : s2 >= 2 && e2[s2 - 2].trailingNode === t2 && (e2[s2 - 2].trailingNode = null));
          }
          takeSurroundingComments(t2, e2, s2) {
            let { commentStack: i2 } = this.state, r2 = i2.length;
            if (r2 === 0)
              return;
            let n2 = r2 - 1;
            for (; n2 >= 0; n2--) {
              let o2 = i2[n2], h2 = o2.end;
              if (o2.start === s2)
                o2.leadingNode = t2;
              else if (h2 === e2)
                o2.trailingNode = t2;
              else if (h2 < e2)
                break;
            }
          }
        }, ts = /\r\n?|[\n\u2028\u2029]/, we3 = new RegExp(ts.source, "g");
        function fe2(a2) {
          switch (a2) {
            case 10:
            case 13:
            case 8232:
            case 8233:
              return true;
            default:
              return false;
          }
        }
        var Ve2 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Ne2 = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, Bt2 = new RegExp("(?=(" + Ne2.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
        function Ni(a2) {
          switch (a2) {
            case 9:
            case 11:
            case 12:
            case 32:
            case 160:
            case 5760:
            case 8192:
            case 8193:
            case 8194:
            case 8195:
            case 8196:
            case 8197:
            case 8198:
            case 8199:
            case 8200:
            case 8201:
            case 8202:
            case 8239:
            case 8287:
            case 12288:
            case 65279:
              return true;
            default:
              return false;
          }
        }
        var Qe3 = class a2 {
          constructor() {
            this.flags = 1024, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 139, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [C.brace], this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
          }
          get strict() {
            return (this.flags & 1) > 0;
          }
          set strict(t2) {
            t2 ? this.flags |= 1 : this.flags &= -2;
          }
          init({ strictMode: t2, sourceType: e2, startLine: s2, startColumn: i2 }) {
            this.strict = t2 === false ? false : t2 === true ? true : e2 === "module", this.curLine = s2, this.lineStart = -i2, this.startLoc = this.endLoc = new F(s2, i2, 0);
          }
          get maybeInArrowParameters() {
            return (this.flags & 2) > 0;
          }
          set maybeInArrowParameters(t2) {
            t2 ? this.flags |= 2 : this.flags &= -3;
          }
          get inType() {
            return (this.flags & 4) > 0;
          }
          set inType(t2) {
            t2 ? this.flags |= 4 : this.flags &= -5;
          }
          get noAnonFunctionType() {
            return (this.flags & 8) > 0;
          }
          set noAnonFunctionType(t2) {
            t2 ? this.flags |= 8 : this.flags &= -9;
          }
          get hasFlowComment() {
            return (this.flags & 16) > 0;
          }
          set hasFlowComment(t2) {
            t2 ? this.flags |= 16 : this.flags &= -17;
          }
          get isAmbientContext() {
            return (this.flags & 32) > 0;
          }
          set isAmbientContext(t2) {
            t2 ? this.flags |= 32 : this.flags &= -33;
          }
          get inAbstractClass() {
            return (this.flags & 64) > 0;
          }
          set inAbstractClass(t2) {
            t2 ? this.flags |= 64 : this.flags &= -65;
          }
          get inDisallowConditionalTypesContext() {
            return (this.flags & 128) > 0;
          }
          set inDisallowConditionalTypesContext(t2) {
            t2 ? this.flags |= 128 : this.flags &= -129;
          }
          get soloAwait() {
            return (this.flags & 256) > 0;
          }
          set soloAwait(t2) {
            t2 ? this.flags |= 256 : this.flags &= -257;
          }
          get inFSharpPipelineDirectBody() {
            return (this.flags & 512) > 0;
          }
          set inFSharpPipelineDirectBody(t2) {
            t2 ? this.flags |= 512 : this.flags &= -513;
          }
          get canStartJSXElement() {
            return (this.flags & 1024) > 0;
          }
          set canStartJSXElement(t2) {
            t2 ? this.flags |= 1024 : this.flags &= -1025;
          }
          get containsEsc() {
            return (this.flags & 2048) > 0;
          }
          set containsEsc(t2) {
            t2 ? this.flags |= 2048 : this.flags &= -2049;
          }
          curPosition() {
            return new F(this.curLine, this.pos - this.lineStart, this.pos);
          }
          clone() {
            let t2 = new a2();
            return t2.flags = this.flags, t2.curLine = this.curLine, t2.lineStart = this.lineStart, t2.startLoc = this.startLoc, t2.endLoc = this.endLoc, t2.errors = this.errors.slice(), t2.potentialArrowAt = this.potentialArrowAt, t2.noArrowAt = this.noArrowAt.slice(), t2.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), t2.topicContext = this.topicContext, t2.labels = this.labels.slice(), t2.commentsLen = this.commentsLen, t2.commentStack = this.commentStack.slice(), t2.pos = this.pos, t2.type = this.type, t2.value = this.value, t2.start = this.start, t2.end = this.end, t2.lastTokEndLoc = this.lastTokEndLoc, t2.lastTokStartLoc = this.lastTokStartLoc, t2.context = this.context.slice(), t2.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, t2.strictErrors = this.strictErrors, t2.tokensLength = this.tokensLength, t2;
          }
        }, ki = function(t2) {
          return t2 >= 48 && t2 <= 57;
        }, Rt2 = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, Ce3 = { bin: (a2) => a2 === 48 || a2 === 49, oct: (a2) => a2 >= 48 && a2 <= 55, dec: (a2) => a2 >= 48 && a2 <= 57, hex: (a2) => a2 >= 48 && a2 <= 57 || a2 >= 65 && a2 <= 70 || a2 >= 97 && a2 <= 102 };
        function Ut2(a2, t2, e2, s2, i2, r2) {
          let n2 = e2, o2 = s2, h2 = i2, c2 = "", l2 = null, u2 = e2, { length: f2 } = t2;
          for (; ; ) {
            if (e2 >= f2) {
              r2.unterminated(n2, o2, h2), c2 += t2.slice(u2, e2);
              break;
            }
            let d2 = t2.charCodeAt(e2);
            if (vi2(a2, d2, t2, e2)) {
              c2 += t2.slice(u2, e2);
              break;
            }
            if (d2 === 92) {
              c2 += t2.slice(u2, e2);
              let y3 = Li2(t2, e2, s2, i2, a2 === "template", r2);
              y3.ch === null && !l2 ? l2 = { pos: e2, lineStart: s2, curLine: i2 } : c2 += y3.ch, { pos: e2, lineStart: s2, curLine: i2 } = y3, u2 = e2;
            } else
              d2 === 8232 || d2 === 8233 ? (++e2, ++i2, s2 = e2) : d2 === 10 || d2 === 13 ? a2 === "template" ? (c2 += t2.slice(u2, e2) + `
`, ++e2, d2 === 13 && t2.charCodeAt(e2) === 10 && ++e2, ++i2, u2 = s2 = e2) : r2.unterminated(n2, o2, h2) : ++e2;
          }
          return { pos: e2, str: c2, firstInvalidLoc: l2, lineStart: s2, curLine: i2, containsInvalid: !!l2 };
        }
        function vi2(a2, t2, e2, s2) {
          return a2 === "template" ? t2 === 96 || t2 === 36 && e2.charCodeAt(s2 + 1) === 123 : t2 === (a2 === "double" ? 34 : 39);
        }
        function Li2(a2, t2, e2, s2, i2, r2) {
          let n2 = !i2;
          t2++;
          let o2 = (c2) => ({ pos: t2, ch: c2, lineStart: e2, curLine: s2 }), h2 = a2.charCodeAt(t2++);
          switch (h2) {
            case 110:
              return o2(`
`);
            case 114:
              return o2("\r");
            case 120: {
              let c2;
              return { code: c2, pos: t2 } = Ze2(a2, t2, e2, s2, 2, false, n2, r2), o2(c2 === null ? null : String.fromCharCode(c2));
            }
            case 117: {
              let c2;
              return { code: c2, pos: t2 } = is(a2, t2, e2, s2, n2, r2), o2(c2 === null ? null : String.fromCodePoint(c2));
            }
            case 116:
              return o2("	");
            case 98:
              return o2("\b");
            case 118:
              return o2("\v");
            case 102:
              return o2("\f");
            case 13:
              a2.charCodeAt(t2) === 10 && ++t2;
            case 10:
              e2 = t2, ++s2;
            case 8232:
            case 8233:
              return o2("");
            case 56:
            case 57:
              if (i2)
                return o2(null);
              r2.strictNumericEscape(t2 - 1, e2, s2);
            default:
              if (h2 >= 48 && h2 <= 55) {
                let c2 = t2 - 1, u2 = /^[0-7]+/.exec(a2.slice(c2, t2 + 2))[0], f2 = parseInt(u2, 8);
                f2 > 255 && (u2 = u2.slice(0, -1), f2 = parseInt(u2, 8)), t2 += u2.length - 1;
                let d2 = a2.charCodeAt(t2);
                if (u2 !== "0" || d2 === 56 || d2 === 57) {
                  if (i2)
                    return o2(null);
                  r2.strictNumericEscape(c2, e2, s2);
                }
                return o2(String.fromCharCode(f2));
              }
              return o2(String.fromCharCode(h2));
          }
        }
        function Ze2(a2, t2, e2, s2, i2, r2, n2, o2) {
          let h2 = t2, c2;
          return { n: c2, pos: t2 } = ss(a2, t2, e2, s2, 16, i2, r2, false, o2, !n2), c2 === null && (n2 ? o2.invalidEscapeSequence(h2, e2, s2) : t2 = h2 - 1), { code: c2, pos: t2 };
        }
        function ss(a2, t2, e2, s2, i2, r2, n2, o2, h2, c2) {
          let l2 = t2, u2 = i2 === 16 ? Rt2.hex : Rt2.decBinOct, f2 = i2 === 16 ? Ce3.hex : i2 === 10 ? Ce3.dec : i2 === 8 ? Ce3.oct : Ce3.bin, d2 = false, y3 = 0;
          for (let E2 = 0, L3 = r2 ?? 1 / 0; E2 < L3; ++E2) {
            let S3 = a2.charCodeAt(t2), I2;
            if (S3 === 95 && o2 !== "bail") {
              let Ae3 = a2.charCodeAt(t2 - 1), ne3 = a2.charCodeAt(t2 + 1);
              if (o2) {
                if (Number.isNaN(ne3) || !f2(ne3) || u2.has(Ae3) || u2.has(ne3)) {
                  if (c2)
                    return { n: null, pos: t2 };
                  h2.unexpectedNumericSeparator(t2, e2, s2);
                }
              } else {
                if (c2)
                  return { n: null, pos: t2 };
                h2.numericSeparatorInEscapeSequence(t2, e2, s2);
              }
              ++t2;
              continue;
            }
            if (S3 >= 97 ? I2 = S3 - 97 + 10 : S3 >= 65 ? I2 = S3 - 65 + 10 : ki(S3) ? I2 = S3 - 48 : I2 = 1 / 0, I2 >= i2) {
              if (I2 <= 9 && c2)
                return { n: null, pos: t2 };
              if (I2 <= 9 && h2.invalidDigit(t2, e2, s2, i2))
                I2 = 0;
              else if (n2)
                I2 = 0, d2 = true;
              else
                break;
            }
            ++t2, y3 = y3 * i2 + I2;
          }
          return t2 === l2 || r2 != null && t2 - l2 !== r2 || d2 ? { n: null, pos: t2 } : { n: y3, pos: t2 };
        }
        function is(a2, t2, e2, s2, i2, r2) {
          let n2 = a2.charCodeAt(t2), o2;
          if (n2 === 123) {
            if (++t2, { code: o2, pos: t2 } = Ze2(a2, t2, e2, s2, a2.indexOf("}", t2) - t2, true, i2, r2), ++t2, o2 !== null && o2 > 1114111)
              if (i2)
                r2.invalidCodePoint(t2, e2, s2);
              else
                return { code: null, pos: t2 };
          } else
            ({ code: o2, pos: t2 } = Ze2(a2, t2, e2, s2, 4, false, i2, r2));
          return { code: o2, pos: t2 };
        }
        function ce3(a2, t2, e2) {
          return new F(e2, a2 - t2, a2);
        }
        var Di2 = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), O2 = class {
          constructor(t2) {
            this.type = t2.type, this.value = t2.value, this.start = t2.start, this.end = t2.end, this.loc = new ee3(t2.startLoc, t2.endLoc);
          }
        }, et2 = class extends Ye2 {
          constructor(t2, e2) {
            super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = { invalidDigit: (s2, i2, r2, n2) => this.options.errorRecovery ? (this.raise(p2.InvalidDigit, ce3(s2, i2, r2), { radix: n2 }), true) : false, numericSeparatorInEscapeSequence: this.errorBuilder(p2.NumericSeparatorInEscapeSequence), unexpectedNumericSeparator: this.errorBuilder(p2.UnexpectedNumericSeparator) }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, { invalidEscapeSequence: this.errorBuilder(p2.InvalidEscapeSequence), invalidCodePoint: this.errorBuilder(p2.InvalidCodePoint) }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: (s2, i2, r2) => {
              this.recordStrictModeErrors(p2.StrictNumericEscape, ce3(s2, i2, r2));
            }, unterminated: (s2, i2, r2) => {
              throw this.raise(p2.UnterminatedString, ce3(s2 - 1, i2, r2));
            } }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: this.errorBuilder(p2.StrictNumericEscape), unterminated: (s2, i2, r2) => {
              throw this.raise(p2.UnterminatedTemplate, ce3(s2, i2, r2));
            } }), this.state = new Qe3(), this.state.init(t2), this.input = e2, this.length = e2.length, this.comments = [], this.isLookahead = false;
          }
          pushToken(t2) {
            this.tokens.length = this.state.tokensLength, this.tokens.push(t2), ++this.state.tokensLength;
          }
          next() {
            this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new O2(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
          }
          eat(t2) {
            return this.match(t2) ? (this.next(), true) : false;
          }
          match(t2) {
            return this.state.type === t2;
          }
          createLookaheadState(t2) {
            return { pos: t2.pos, value: null, type: t2.type, start: t2.start, end: t2.end, context: [this.curContext()], inType: t2.inType, startLoc: t2.startLoc, lastTokEndLoc: t2.lastTokEndLoc, curLine: t2.curLine, lineStart: t2.lineStart, curPosition: t2.curPosition };
          }
          lookahead() {
            let t2 = this.state;
            this.state = this.createLookaheadState(t2), this.isLookahead = true, this.nextToken(), this.isLookahead = false;
            let e2 = this.state;
            return this.state = t2, e2;
          }
          nextTokenStart() {
            return this.nextTokenStartSince(this.state.pos);
          }
          nextTokenStartSince(t2) {
            return Ve2.lastIndex = t2, Ve2.test(this.input) ? Ve2.lastIndex : t2;
          }
          lookaheadCharCode() {
            return this.input.charCodeAt(this.nextTokenStart());
          }
          nextTokenInLineStart() {
            return this.nextTokenInLineStartSince(this.state.pos);
          }
          nextTokenInLineStartSince(t2) {
            return Ne2.lastIndex = t2, Ne2.test(this.input) ? Ne2.lastIndex : t2;
          }
          lookaheadInLineCharCode() {
            return this.input.charCodeAt(this.nextTokenInLineStart());
          }
          codePointAtPos(t2) {
            let e2 = this.input.charCodeAt(t2);
            if ((e2 & 64512) === 55296 && ++t2 < this.input.length) {
              let s2 = this.input.charCodeAt(t2);
              (s2 & 64512) === 56320 && (e2 = 65536 + ((e2 & 1023) << 10) + (s2 & 1023));
            }
            return e2;
          }
          setStrict(t2) {
            this.state.strict = t2, t2 && (this.state.strictErrors.forEach(([e2, s2]) => this.raise(e2, s2)), this.state.strictErrors.clear());
          }
          curContext() {
            return this.state.context[this.state.context.length - 1];
          }
          nextToken() {
            if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
              this.finishToken(139);
              return;
            }
            this.getTokenFromCode(this.codePointAtPos(this.state.pos));
          }
          skipBlockComment(t2) {
            let e2;
            this.isLookahead || (e2 = this.state.curPosition());
            let s2 = this.state.pos, i2 = this.input.indexOf(t2, s2 + 2);
            if (i2 === -1)
              throw this.raise(p2.UnterminatedComment, this.state.curPosition());
            for (this.state.pos = i2 + t2.length, we3.lastIndex = s2 + 2; we3.test(this.input) && we3.lastIndex <= i2; )
              ++this.state.curLine, this.state.lineStart = we3.lastIndex;
            if (this.isLookahead)
              return;
            let r2 = { type: "CommentBlock", value: this.input.slice(s2 + 2, i2), start: s2, end: i2 + t2.length, loc: new ee3(e2, this.state.curPosition()) };
            return this.options.tokens && this.pushToken(r2), r2;
          }
          skipLineComment(t2) {
            let e2 = this.state.pos, s2;
            this.isLookahead || (s2 = this.state.curPosition());
            let i2 = this.input.charCodeAt(this.state.pos += t2);
            if (this.state.pos < this.length)
              for (; !fe2(i2) && ++this.state.pos < this.length; )
                i2 = this.input.charCodeAt(this.state.pos);
            if (this.isLookahead)
              return;
            let r2 = this.state.pos, o2 = { type: "CommentLine", value: this.input.slice(e2 + t2, r2), start: e2, end: r2, loc: new ee3(s2, this.state.curPosition()) };
            return this.options.tokens && this.pushToken(o2), o2;
          }
          skipSpace() {
            let t2 = this.state.pos, e2 = [];
            e:
              for (; this.state.pos < this.length; ) {
                let s2 = this.input.charCodeAt(this.state.pos);
                switch (s2) {
                  case 32:
                  case 160:
                  case 9:
                    ++this.state.pos;
                    break;
                  case 13:
                    this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
                  case 10:
                  case 8232:
                  case 8233:
                    ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
                    break;
                  case 47:
                    switch (this.input.charCodeAt(this.state.pos + 1)) {
                      case 42: {
                        let i2 = this.skipBlockComment("*/");
                        i2 !== void 0 && (this.addComment(i2), this.options.attachComment && e2.push(i2));
                        break;
                      }
                      case 47: {
                        let i2 = this.skipLineComment(2);
                        i2 !== void 0 && (this.addComment(i2), this.options.attachComment && e2.push(i2));
                        break;
                      }
                      default:
                        break e;
                    }
                    break;
                  default:
                    if (Ni(s2))
                      ++this.state.pos;
                    else if (s2 === 45 && !this.inModule && this.options.annexB) {
                      let i2 = this.state.pos;
                      if (this.input.charCodeAt(i2 + 1) === 45 && this.input.charCodeAt(i2 + 2) === 62 && (t2 === 0 || this.state.lineStart > t2)) {
                        let r2 = this.skipLineComment(3);
                        r2 !== void 0 && (this.addComment(r2), this.options.attachComment && e2.push(r2));
                      } else
                        break e;
                    } else if (s2 === 60 && !this.inModule && this.options.annexB) {
                      let i2 = this.state.pos;
                      if (this.input.charCodeAt(i2 + 1) === 33 && this.input.charCodeAt(i2 + 2) === 45 && this.input.charCodeAt(i2 + 3) === 45) {
                        let r2 = this.skipLineComment(4);
                        r2 !== void 0 && (this.addComment(r2), this.options.attachComment && e2.push(r2));
                      } else
                        break e;
                    } else
                      break e;
                }
              }
            if (e2.length > 0) {
              let s2 = this.state.pos, i2 = { start: t2, end: s2, comments: e2, leadingNode: null, trailingNode: null, containingNode: null };
              this.state.commentStack.push(i2);
            }
          }
          finishToken(t2, e2) {
            this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
            let s2 = this.state.type;
            this.state.type = t2, this.state.value = e2, this.isLookahead || this.updateContext(s2);
          }
          replaceToken(t2) {
            this.state.type = t2, this.updateContext();
          }
          readToken_numberSign() {
            if (this.state.pos === 0 && this.readToken_interpreter())
              return;
            let t2 = this.state.pos + 1, e2 = this.codePointAtPos(t2);
            if (e2 >= 48 && e2 <= 57)
              throw this.raise(p2.UnexpectedDigitAfterHash, this.state.curPosition());
            if (e2 === 123 || e2 === 91 && this.hasPlugin("recordAndTuple")) {
              if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
                throw this.raise(e2 === 123 ? p2.RecordExpressionHashIncorrectStartSyntaxType : p2.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
              this.state.pos += 2, e2 === 123 ? this.finishToken(7) : this.finishToken(1);
            } else
              _3(e2) ? (++this.state.pos, this.finishToken(138, this.readWord1(e2))) : e2 === 92 ? (++this.state.pos, this.finishToken(138, this.readWord1())) : this.finishOp(27, 1);
          }
          readToken_dot() {
            let t2 = this.input.charCodeAt(this.state.pos + 1);
            if (t2 >= 48 && t2 <= 57) {
              this.readNumber(true);
              return;
            }
            t2 === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
          }
          readToken_slash() {
            this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
          }
          readToken_interpreter() {
            if (this.state.pos !== 0 || this.length < 2)
              return false;
            let t2 = this.input.charCodeAt(this.state.pos + 1);
            if (t2 !== 33)
              return false;
            let e2 = this.state.pos;
            for (this.state.pos += 1; !fe2(t2) && ++this.state.pos < this.length; )
              t2 = this.input.charCodeAt(this.state.pos);
            let s2 = this.input.slice(e2 + 2, this.state.pos);
            return this.finishToken(28, s2), true;
          }
          readToken_mult_modulo(t2) {
            let e2 = t2 === 42 ? 55 : 54, s2 = 1, i2 = this.input.charCodeAt(this.state.pos + 1);
            t2 === 42 && i2 === 42 && (s2++, i2 = this.input.charCodeAt(this.state.pos + 2), e2 = 57), i2 === 61 && !this.state.inType && (s2++, e2 = t2 === 37 ? 33 : 30), this.finishOp(e2, s2);
          }
          readToken_pipe_amp(t2) {
            let e2 = this.input.charCodeAt(this.state.pos + 1);
            if (e2 === t2) {
              this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(t2 === 124 ? 41 : 42, 2);
              return;
            }
            if (t2 === 124) {
              if (e2 === 62) {
                this.finishOp(39, 2);
                return;
              }
              if (this.hasPlugin("recordAndTuple") && e2 === 125) {
                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                  throw this.raise(p2.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
                this.state.pos += 2, this.finishToken(9);
                return;
              }
              if (this.hasPlugin("recordAndTuple") && e2 === 93) {
                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                  throw this.raise(p2.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
                this.state.pos += 2, this.finishToken(4);
                return;
              }
            }
            if (e2 === 61) {
              this.finishOp(30, 2);
              return;
            }
            this.finishOp(t2 === 124 ? 43 : 45, 1);
          }
          readToken_caret() {
            let t2 = this.input.charCodeAt(this.state.pos + 1);
            t2 === 61 && !this.state.inType ? this.finishOp(32, 2) : t2 === 94 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "^^" }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
          }
          readToken_atSign() {
            this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "@@" }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
          }
          readToken_plus_min(t2) {
            let e2 = this.input.charCodeAt(this.state.pos + 1);
            if (e2 === t2) {
              this.finishOp(34, 2);
              return;
            }
            e2 === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
          }
          readToken_lt() {
            let { pos: t2 } = this.state, e2 = this.input.charCodeAt(t2 + 1);
            if (e2 === 60) {
              if (this.input.charCodeAt(t2 + 2) === 61) {
                this.finishOp(30, 3);
                return;
              }
              this.finishOp(51, 2);
              return;
            }
            if (e2 === 61) {
              this.finishOp(49, 2);
              return;
            }
            this.finishOp(47, 1);
          }
          readToken_gt() {
            let { pos: t2 } = this.state, e2 = this.input.charCodeAt(t2 + 1);
            if (e2 === 62) {
              let s2 = this.input.charCodeAt(t2 + 2) === 62 ? 3 : 2;
              if (this.input.charCodeAt(t2 + s2) === 61) {
                this.finishOp(30, s2 + 1);
                return;
              }
              this.finishOp(52, s2);
              return;
            }
            if (e2 === 61) {
              this.finishOp(49, 2);
              return;
            }
            this.finishOp(48, 1);
          }
          readToken_eq_excl(t2) {
            let e2 = this.input.charCodeAt(this.state.pos + 1);
            if (e2 === 61) {
              this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
              return;
            }
            if (t2 === 61 && e2 === 62) {
              this.state.pos += 2, this.finishToken(19);
              return;
            }
            this.finishOp(t2 === 61 ? 29 : 35, 1);
          }
          readToken_question() {
            let t2 = this.input.charCodeAt(this.state.pos + 1), e2 = this.input.charCodeAt(this.state.pos + 2);
            t2 === 63 ? e2 === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : t2 === 46 && !(e2 >= 48 && e2 <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
          }
          getTokenFromCode(t2) {
            switch (t2) {
              case 46:
                this.readToken_dot();
                return;
              case 40:
                ++this.state.pos, this.finishToken(10);
                return;
              case 41:
                ++this.state.pos, this.finishToken(11);
                return;
              case 59:
                ++this.state.pos, this.finishToken(13);
                return;
              case 44:
                ++this.state.pos, this.finishToken(12);
                return;
              case 91:
                if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                    throw this.raise(p2.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
                  this.state.pos += 2, this.finishToken(2);
                } else
                  ++this.state.pos, this.finishToken(0);
                return;
              case 93:
                ++this.state.pos, this.finishToken(3);
                return;
              case 123:
                if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                    throw this.raise(p2.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
                  this.state.pos += 2, this.finishToken(6);
                } else
                  ++this.state.pos, this.finishToken(5);
                return;
              case 125:
                ++this.state.pos, this.finishToken(8);
                return;
              case 58:
                this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
                return;
              case 63:
                this.readToken_question();
                return;
              case 96:
                this.readTemplateToken();
                return;
              case 48: {
                let e2 = this.input.charCodeAt(this.state.pos + 1);
                if (e2 === 120 || e2 === 88) {
                  this.readRadixNumber(16);
                  return;
                }
                if (e2 === 111 || e2 === 79) {
                  this.readRadixNumber(8);
                  return;
                }
                if (e2 === 98 || e2 === 66) {
                  this.readRadixNumber(2);
                  return;
                }
              }
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
                this.readNumber(false);
                return;
              case 34:
              case 39:
                this.readString(t2);
                return;
              case 47:
                this.readToken_slash();
                return;
              case 37:
              case 42:
                this.readToken_mult_modulo(t2);
                return;
              case 124:
              case 38:
                this.readToken_pipe_amp(t2);
                return;
              case 94:
                this.readToken_caret();
                return;
              case 43:
              case 45:
                this.readToken_plus_min(t2);
                return;
              case 60:
                this.readToken_lt();
                return;
              case 62:
                this.readToken_gt();
                return;
              case 61:
              case 33:
                this.readToken_eq_excl(t2);
                return;
              case 126:
                this.finishOp(36, 1);
                return;
              case 64:
                this.readToken_atSign();
                return;
              case 35:
                this.readToken_numberSign();
                return;
              case 92:
                this.readWord();
                return;
              default:
                if (_3(t2)) {
                  this.readWord(t2);
                  return;
                }
            }
            throw this.raise(p2.InvalidOrUnexpectedToken, this.state.curPosition(), { unexpected: String.fromCodePoint(t2) });
          }
          finishOp(t2, e2) {
            let s2 = this.input.slice(this.state.pos, this.state.pos + e2);
            this.state.pos += e2, this.finishToken(t2, s2);
          }
          readRegexp() {
            let t2 = this.state.startLoc, e2 = this.state.start + 1, s2, i2, { pos: r2 } = this.state;
            for (; ; ++r2) {
              if (r2 >= this.length)
                throw this.raise(p2.UnterminatedRegExp, v2(t2, 1));
              let c2 = this.input.charCodeAt(r2);
              if (fe2(c2))
                throw this.raise(p2.UnterminatedRegExp, v2(t2, 1));
              if (s2)
                s2 = false;
              else {
                if (c2 === 91)
                  i2 = true;
                else if (c2 === 93 && i2)
                  i2 = false;
                else if (c2 === 47 && !i2)
                  break;
                s2 = c2 === 92;
              }
            }
            let n2 = this.input.slice(e2, r2);
            ++r2;
            let o2 = "", h2 = () => v2(t2, r2 + 2 - e2);
            for (; r2 < this.length; ) {
              let c2 = this.codePointAtPos(r2), l2 = String.fromCharCode(c2);
              if (Di2.has(c2))
                c2 === 118 ? o2.includes("u") && this.raise(p2.IncompatibleRegExpUVFlags, h2()) : c2 === 117 && o2.includes("v") && this.raise(p2.IncompatibleRegExpUVFlags, h2()), o2.includes(l2) && this.raise(p2.DuplicateRegExpFlags, h2());
              else if (Q3(c2) || c2 === 92)
                this.raise(p2.MalformedRegExpFlags, h2());
              else
                break;
              ++r2, o2 += l2;
            }
            this.state.pos = r2, this.finishToken(137, { pattern: n2, flags: o2 });
          }
          readInt(t2, e2, s2 = false, i2 = true) {
            let { n: r2, pos: n2 } = ss(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t2, e2, s2, i2, this.errorHandlers_readInt, false);
            return this.state.pos = n2, r2;
          }
          readRadixNumber(t2) {
            let e2 = this.state.curPosition(), s2 = false;
            this.state.pos += 2;
            let i2 = this.readInt(t2);
            i2 == null && this.raise(p2.InvalidDigit, v2(e2, 2), { radix: t2 });
            let r2 = this.input.charCodeAt(this.state.pos);
            if (r2 === 110)
              ++this.state.pos, s2 = true;
            else if (r2 === 109)
              throw this.raise(p2.InvalidDecimal, e2);
            if (_3(this.codePointAtPos(this.state.pos)))
              throw this.raise(p2.NumberIdentifier, this.state.curPosition());
            if (s2) {
              let n2 = this.input.slice(e2.index, this.state.pos).replace(/[_n]/g, "");
              this.finishToken(135, n2);
              return;
            }
            this.finishToken(134, i2);
          }
          readNumber(t2) {
            let e2 = this.state.pos, s2 = this.state.curPosition(), i2 = false, r2 = false, n2 = false, o2 = false, h2 = false;
            !t2 && this.readInt(10) === null && this.raise(p2.InvalidNumber, this.state.curPosition());
            let c2 = this.state.pos - e2 >= 2 && this.input.charCodeAt(e2) === 48;
            if (c2) {
              let d2 = this.input.slice(e2, this.state.pos);
              if (this.recordStrictModeErrors(p2.StrictOctalLiteral, s2), !this.state.strict) {
                let y3 = d2.indexOf("_");
                y3 > 0 && this.raise(p2.ZeroDigitNumericSeparator, v2(s2, y3));
              }
              h2 = c2 && !/[89]/.test(d2);
            }
            let l2 = this.input.charCodeAt(this.state.pos);
            if (l2 === 46 && !h2 && (++this.state.pos, this.readInt(10), i2 = true, l2 = this.input.charCodeAt(this.state.pos)), (l2 === 69 || l2 === 101) && !h2 && (l2 = this.input.charCodeAt(++this.state.pos), (l2 === 43 || l2 === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(p2.InvalidOrMissingExponent, s2), i2 = true, o2 = true, l2 = this.input.charCodeAt(this.state.pos)), l2 === 110 && ((i2 || c2) && this.raise(p2.InvalidBigIntLiteral, s2), ++this.state.pos, r2 = true), l2 === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (o2 || c2) && this.raise(p2.InvalidDecimal, s2), ++this.state.pos, n2 = true), _3(this.codePointAtPos(this.state.pos)))
              throw this.raise(p2.NumberIdentifier, this.state.curPosition());
            let u2 = this.input.slice(e2, this.state.pos).replace(/[_mn]/g, "");
            if (r2) {
              this.finishToken(135, u2);
              return;
            }
            if (n2) {
              this.finishToken(136, u2);
              return;
            }
            let f2 = h2 ? parseInt(u2, 8) : parseFloat(u2);
            this.finishToken(134, f2);
          }
          readCodePoint(t2) {
            let { code: e2, pos: s2 } = is(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t2, this.errorHandlers_readCodePoint);
            return this.state.pos = s2, e2;
          }
          readString(t2) {
            let { str: e2, pos: s2, curLine: i2, lineStart: r2 } = Ut2(t2 === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
            this.state.pos = s2 + 1, this.state.lineStart = r2, this.state.curLine = i2, this.finishToken(133, e2);
          }
          readTemplateContinuation() {
            this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
          }
          readTemplateToken() {
            let t2 = this.input[this.state.pos], { str: e2, firstInvalidLoc: s2, pos: i2, curLine: r2, lineStart: n2 } = Ut2("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
            this.state.pos = i2 + 1, this.state.lineStart = n2, this.state.curLine = r2, s2 && (this.state.firstInvalidTemplateEscapePos = new F(s2.curLine, s2.pos - s2.lineStart, s2.pos)), this.input.codePointAt(i2) === 96 ? this.finishToken(24, s2 ? null : t2 + e2 + "`") : (this.state.pos++, this.finishToken(25, s2 ? null : t2 + e2 + "${"));
          }
          recordStrictModeErrors(t2, e2) {
            let s2 = e2.index;
            this.state.strict && !this.state.strictErrors.has(s2) ? this.raise(t2, e2) : this.state.strictErrors.set(s2, [t2, e2]);
          }
          readWord1(t2) {
            this.state.containsEsc = false;
            let e2 = "", s2 = this.state.pos, i2 = this.state.pos;
            for (t2 !== void 0 && (this.state.pos += t2 <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
              let r2 = this.codePointAtPos(this.state.pos);
              if (Q3(r2))
                this.state.pos += r2 <= 65535 ? 1 : 2;
              else if (r2 === 92) {
                this.state.containsEsc = true, e2 += this.input.slice(i2, this.state.pos);
                let n2 = this.state.curPosition(), o2 = this.state.pos === s2 ? _3 : Q3;
                if (this.input.charCodeAt(++this.state.pos) !== 117) {
                  this.raise(p2.MissingUnicodeEscape, this.state.curPosition()), i2 = this.state.pos - 1;
                  continue;
                }
                ++this.state.pos;
                let h2 = this.readCodePoint(true);
                h2 !== null && (o2(h2) || this.raise(p2.EscapedCharNotAnIdentifier, n2), e2 += String.fromCodePoint(h2)), i2 = this.state.pos;
              } else
                break;
            }
            return e2 + this.input.slice(i2, this.state.pos);
          }
          readWord(t2) {
            let e2 = this.readWord1(t2), s2 = ut3.get(e2);
            s2 !== void 0 ? this.finishToken(s2, K2(s2)) : this.finishToken(132, e2);
          }
          checkKeywordEscapes() {
            let { type: t2 } = this.state;
            Pt2(t2) && this.state.containsEsc && this.raise(p2.InvalidEscapedReservedWord, this.state.startLoc, { reservedWord: K2(t2) });
          }
          raise(t2, e2, s2 = {}) {
            let i2 = e2 instanceof F ? e2 : e2.loc.start, r2 = t2(i2, s2);
            if (!this.options.errorRecovery)
              throw r2;
            return this.isLookahead || this.state.errors.push(r2), r2;
          }
          raiseOverwrite(t2, e2, s2 = {}) {
            let i2 = e2 instanceof F ? e2 : e2.loc.start, r2 = i2.index, n2 = this.state.errors;
            for (let o2 = n2.length - 1; o2 >= 0; o2--) {
              let h2 = n2[o2];
              if (h2.loc.index === r2)
                return n2[o2] = t2(i2, s2);
              if (h2.loc.index < r2)
                break;
            }
            return this.raise(t2, e2, s2);
          }
          updateContext(t2) {
          }
          unexpected(t2, e2) {
            throw this.raise(p2.UnexpectedToken, t2 ?? this.state.startLoc, { expected: e2 ? K2(e2) : null });
          }
          expectPlugin(t2, e2) {
            if (this.hasPlugin(t2))
              return true;
            throw this.raise(p2.MissingPlugin, e2 ?? this.state.startLoc, { missingPlugin: [t2] });
          }
          expectOnePlugin(t2) {
            if (!t2.some((e2) => this.hasPlugin(e2)))
              throw this.raise(p2.MissingOneOfPlugins, this.state.startLoc, { missingPlugin: t2 });
          }
          errorBuilder(t2) {
            return (e2, s2, i2) => {
              this.raise(t2, ce3(e2, s2, i2));
            };
          }
        }, tt2 = class {
          constructor() {
            this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
          }
        }, st3 = class {
          constructor(t2) {
            this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = t2;
          }
          current() {
            return this.stack[this.stack.length - 1];
          }
          enter() {
            this.stack.push(new tt2());
          }
          exit() {
            let t2 = this.stack.pop(), e2 = this.current();
            for (let [s2, i2] of Array.from(t2.undefinedPrivateNames))
              e2 ? e2.undefinedPrivateNames.has(s2) || e2.undefinedPrivateNames.set(s2, i2) : this.parser.raise(p2.InvalidPrivateFieldResolution, i2, { identifierName: s2 });
          }
          declarePrivateName(t2, e2, s2) {
            let { privateNames: i2, loneAccessors: r2, undefinedPrivateNames: n2 } = this.current(), o2 = i2.has(t2);
            if (e2 & 3) {
              let h2 = o2 && r2.get(t2);
              if (h2) {
                let c2 = h2 & 4, l2 = e2 & 4, u2 = h2 & 3, f2 = e2 & 3;
                o2 = u2 === f2 || c2 !== l2, o2 || r2.delete(t2);
              } else
                o2 || r2.set(t2, e2);
            }
            o2 && this.parser.raise(p2.PrivateNameRedeclaration, s2, { identifierName: t2 }), i2.add(t2), n2.delete(t2);
          }
          usePrivateName(t2, e2) {
            let s2;
            for (s2 of this.stack)
              if (s2.privateNames.has(t2))
                return;
            s2 ? s2.undefinedPrivateNames.set(t2, e2) : this.parser.raise(p2.InvalidPrivateFieldResolution, e2, { identifierName: t2 });
          }
        }, te2 = class {
          constructor(t2 = 0) {
            this.type = t2;
          }
          canBeArrowParameterDeclaration() {
            return this.type === 2 || this.type === 1;
          }
          isCertainlyParameterDeclaration() {
            return this.type === 3;
          }
        }, De3 = class extends te2 {
          constructor(t2) {
            super(t2), this.declarationErrors = /* @__PURE__ */ new Map();
          }
          recordDeclarationError(t2, e2) {
            let s2 = e2.index;
            this.declarationErrors.set(s2, [t2, e2]);
          }
          clearDeclarationError(t2) {
            this.declarationErrors.delete(t2);
          }
          iterateErrors(t2) {
            this.declarationErrors.forEach(t2);
          }
        }, it3 = class {
          constructor(t2) {
            this.parser = void 0, this.stack = [new te2()], this.parser = t2;
          }
          enter(t2) {
            this.stack.push(t2);
          }
          exit() {
            this.stack.pop();
          }
          recordParameterInitializerError(t2, e2) {
            let s2 = e2.loc.start, { stack: i2 } = this, r2 = i2.length - 1, n2 = i2[r2];
            for (; !n2.isCertainlyParameterDeclaration(); ) {
              if (n2.canBeArrowParameterDeclaration())
                n2.recordDeclarationError(t2, s2);
              else
                return;
              n2 = i2[--r2];
            }
            this.parser.raise(t2, s2);
          }
          recordArrowParameterBindingError(t2, e2) {
            let { stack: s2 } = this, i2 = s2[s2.length - 1], r2 = e2.loc.start;
            if (i2.isCertainlyParameterDeclaration())
              this.parser.raise(t2, r2);
            else if (i2.canBeArrowParameterDeclaration())
              i2.recordDeclarationError(t2, r2);
            else
              return;
          }
          recordAsyncArrowParametersError(t2) {
            let { stack: e2 } = this, s2 = e2.length - 1, i2 = e2[s2];
            for (; i2.canBeArrowParameterDeclaration(); )
              i2.type === 2 && i2.recordDeclarationError(p2.AwaitBindingIdentifier, t2), i2 = e2[--s2];
          }
          validateAsPattern() {
            let { stack: t2 } = this, e2 = t2[t2.length - 1];
            e2.canBeArrowParameterDeclaration() && e2.iterateErrors(([s2, i2]) => {
              this.parser.raise(s2, i2);
              let r2 = t2.length - 2, n2 = t2[r2];
              for (; n2.canBeArrowParameterDeclaration(); )
                n2.clearDeclarationError(i2.index), n2 = t2[--r2];
            });
          }
        };
        function Mi2() {
          return new te2(3);
        }
        function Oi2() {
          return new De3(1);
        }
        function Fi() {
          return new De3(2);
        }
        function rs() {
          return new te2();
        }
        var rt3 = class {
          constructor() {
            this.stacks = [];
          }
          enter(t2) {
            this.stacks.push(t2);
          }
          exit() {
            this.stacks.pop();
          }
          currentFlags() {
            return this.stacks[this.stacks.length - 1];
          }
          get hasAwait() {
            return (this.currentFlags() & 2) > 0;
          }
          get hasYield() {
            return (this.currentFlags() & 1) > 0;
          }
          get hasReturn() {
            return (this.currentFlags() & 4) > 0;
          }
          get hasIn() {
            return (this.currentFlags() & 8) > 0;
          }
        };
        function ke3(a2, t2) {
          return (a2 ? 2 : 0) | (t2 ? 1 : 0);
        }
        var at3 = class extends et2 {
          addExtra(t2, e2, s2, i2 = true) {
            if (!t2)
              return;
            let r2 = t2.extra = t2.extra || {};
            i2 ? r2[e2] = s2 : Object.defineProperty(r2, e2, { enumerable: i2, value: s2 });
          }
          isContextual(t2) {
            return this.state.type === t2 && !this.state.containsEsc;
          }
          isUnparsedContextual(t2, e2) {
            let s2 = t2 + e2.length;
            if (this.input.slice(t2, s2) === e2) {
              let i2 = this.input.charCodeAt(s2);
              return !(Q3(i2) || (i2 & 64512) === 55296);
            }
            return false;
          }
          isLookaheadContextual(t2) {
            let e2 = this.nextTokenStart();
            return this.isUnparsedContextual(e2, t2);
          }
          eatContextual(t2) {
            return this.isContextual(t2) ? (this.next(), true) : false;
          }
          expectContextual(t2, e2) {
            if (!this.eatContextual(t2)) {
              if (e2 != null)
                throw this.raise(e2, this.state.startLoc);
              this.unexpected(null, t2);
            }
          }
          canInsertSemicolon() {
            return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
          }
          hasPrecedingLineBreak() {
            return ts.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
          }
          hasFollowingLineBreak() {
            return Bt2.lastIndex = this.state.end, Bt2.test(this.input);
          }
          isLineTerminator() {
            return this.eat(13) || this.canInsertSemicolon();
          }
          semicolon(t2 = true) {
            (t2 ? this.isLineTerminator() : this.eat(13)) || this.raise(p2.MissingSemicolon, this.state.lastTokEndLoc);
          }
          expect(t2, e2) {
            this.eat(t2) || this.unexpected(e2, t2);
          }
          tryParse(t2, e2 = this.state.clone()) {
            let s2 = { node: null };
            try {
              let i2 = t2((r2 = null) => {
                throw s2.node = r2, s2;
              });
              if (this.state.errors.length > e2.errors.length) {
                let r2 = this.state;
                return this.state = e2, this.state.tokensLength = r2.tokensLength, { node: i2, error: r2.errors[e2.errors.length], thrown: false, aborted: false, failState: r2 };
              }
              return { node: i2, error: null, thrown: false, aborted: false, failState: null };
            } catch (i2) {
              let r2 = this.state;
              if (this.state = e2, i2 instanceof SyntaxError)
                return { node: null, error: i2, thrown: true, aborted: false, failState: r2 };
              if (i2 === s2)
                return { node: s2.node, error: null, thrown: false, aborted: true, failState: r2 };
              throw i2;
            }
          }
          checkExpressionErrors(t2, e2) {
            if (!t2)
              return false;
            let { shorthandAssignLoc: s2, doubleProtoLoc: i2, privateKeyLoc: r2, optionalParametersLoc: n2 } = t2, o2 = !!s2 || !!i2 || !!n2 || !!r2;
            if (!e2)
              return o2;
            s2 != null && this.raise(p2.InvalidCoverInitializedName, s2), i2 != null && this.raise(p2.DuplicateProto, i2), r2 != null && this.raise(p2.UnexpectedPrivateField, r2), n2 != null && this.unexpected(n2);
          }
          isLiteralPropertyName() {
            return Wt2(this.state.type);
          }
          isPrivateName(t2) {
            return t2.type === "PrivateName";
          }
          getPrivateNameSV(t2) {
            return t2.id.name;
          }
          hasPropertyAsPrivateName(t2) {
            return (t2.type === "MemberExpression" || t2.type === "OptionalMemberExpression") && this.isPrivateName(t2.property);
          }
          isObjectProperty(t2) {
            return t2.type === "ObjectProperty";
          }
          isObjectMethod(t2) {
            return t2.type === "ObjectMethod";
          }
          initializeScopes(t2 = this.options.sourceType === "module") {
            let e2 = this.state.labels;
            this.state.labels = [];
            let s2 = this.exportedIdentifiers;
            this.exportedIdentifiers = /* @__PURE__ */ new Set();
            let i2 = this.inModule;
            this.inModule = t2;
            let r2 = this.scope, n2 = this.getScopeHandler();
            this.scope = new n2(this, t2);
            let o2 = this.prodParam;
            this.prodParam = new rt3();
            let h2 = this.classScope;
            this.classScope = new st3(this);
            let c2 = this.expressionScope;
            return this.expressionScope = new it3(this), () => {
              this.state.labels = e2, this.exportedIdentifiers = s2, this.inModule = i2, this.scope = r2, this.prodParam = o2, this.classScope = h2, this.expressionScope = c2;
            };
          }
          enterInitialScopes() {
            let t2 = 0;
            this.inModule && (t2 |= 2), this.scope.enter(1), this.prodParam.enter(t2);
          }
          checkDestructuringPrivate(t2) {
            let { privateKeyLoc: e2 } = t2;
            e2 !== null && this.expectPlugin("destructuringPrivate", e2);
          }
        }, Z3 = class {
          constructor() {
            this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
          }
        }, se2 = class {
          constructor(t2, e2, s2) {
            this.type = "", this.start = e2, this.end = 0, this.loc = new ee3(s2), t2 != null && t2.options.ranges && (this.range = [e2, 0]), t2 != null && t2.filename && (this.loc.filename = t2.filename);
          }
        }, bt2 = se2.prototype;
        bt2.__clone = function() {
          let a2 = new se2(void 0, this.start, this.loc.start), t2 = Object.keys(this);
          for (let e2 = 0, s2 = t2.length; e2 < s2; e2++) {
            let i2 = t2[e2];
            i2 !== "leadingComments" && i2 !== "trailingComments" && i2 !== "innerComments" && (a2[i2] = this[i2]);
          }
          return a2;
        };
        function Bi2(a2) {
          return $2(a2);
        }
        function $2(a2) {
          let { type: t2, start: e2, end: s2, loc: i2, range: r2, extra: n2, name: o2 } = a2, h2 = Object.create(bt2);
          return h2.type = t2, h2.start = e2, h2.end = s2, h2.loc = i2, h2.range = r2, h2.extra = n2, h2.name = o2, t2 === "Placeholder" && (h2.expectedNode = a2.expectedNode), h2;
        }
        function Ri(a2) {
          let { type: t2, start: e2, end: s2, loc: i2, range: r2, extra: n2 } = a2;
          if (t2 === "Placeholder")
            return Bi2(a2);
          let o2 = Object.create(bt2);
          return o2.type = t2, o2.start = e2, o2.end = s2, o2.loc = i2, o2.range = r2, a2.raw !== void 0 ? o2.raw = a2.raw : o2.extra = n2, o2.value = a2.value, o2;
        }
        var nt3 = class extends at3 {
          startNode() {
            let t2 = this.state.startLoc;
            return new se2(this, t2.index, t2);
          }
          startNodeAt(t2) {
            return new se2(this, t2.index, t2);
          }
          startNodeAtNode(t2) {
            return this.startNodeAt(t2.loc.start);
          }
          finishNode(t2, e2) {
            return this.finishNodeAt(t2, e2, this.state.lastTokEndLoc);
          }
          finishNodeAt(t2, e2, s2) {
            return t2.type = e2, t2.end = s2.index, t2.loc.end = s2, this.options.ranges && (t2.range[1] = s2.index), this.options.attachComment && this.processComment(t2), t2;
          }
          resetStartLocation(t2, e2) {
            t2.start = e2.index, t2.loc.start = e2, this.options.ranges && (t2.range[0] = e2.index);
          }
          resetEndLocation(t2, e2 = this.state.lastTokEndLoc) {
            t2.end = e2.index, t2.loc.end = e2, this.options.ranges && (t2.range[1] = e2.index);
          }
          resetStartLocationFromNode(t2, e2) {
            this.resetStartLocation(t2, e2.loc.start);
          }
        }, Ui = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), g2 = j2`flow`({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: ({ reservedType: a2 }) => `Cannot overwrite reserved type ${a2}.`, DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: ({ memberName: a2, enumName: t2 }) => `Boolean enum members need to be initialized. Use either \`${a2} = true,\` or \`${a2} = false,\` in enum \`${t2}\`.`, EnumDuplicateMemberName: ({ memberName: a2, enumName: t2 }) => `Enum member names need to be unique, but the name \`${a2}\` has already been used before in enum \`${t2}\`.`, EnumInconsistentMemberValues: ({ enumName: a2 }) => `Enum \`${a2}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`, EnumInvalidExplicitType: ({ invalidEnumType: a2, enumName: t2 }) => `Enum type \`${a2}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t2}\`.`, EnumInvalidExplicitTypeUnknownSupplied: ({ enumName: a2 }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${a2}\`.`, EnumInvalidMemberInitializerPrimaryType: ({ enumName: a2, memberName: t2, explicitType: e2 }) => `Enum \`${a2}\` has type \`${e2}\`, so the initializer of \`${t2}\` needs to be a ${e2} literal.`, EnumInvalidMemberInitializerSymbolType: ({ enumName: a2, memberName: t2 }) => `Symbol enum members cannot be initialized. Use \`${t2},\` in enum \`${a2}\`.`, EnumInvalidMemberInitializerUnknownType: ({ enumName: a2, memberName: t2 }) => `The enum member initializer for \`${t2}\` needs to be a literal (either a boolean, number, or string) in enum \`${a2}\`.`, EnumInvalidMemberName: ({ enumName: a2, memberName: t2, suggestion: e2 }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t2}\`, consider using \`${e2}\`, in enum \`${a2}\`.`, EnumNumberMemberNotInitialized: ({ enumName: a2, memberName: t2 }) => `Number enum members need to be initialized, e.g. \`${t2} = 1\` in enum \`${a2}\`.`, EnumStringMemberInconsistentlyInitialized: ({ enumName: a2 }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${a2}\`.`, GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: Object.assign({ message: "A binding pattern parameter cannot be optional in an implementation signature." }, { reasonCode: "OptionalBindingPattern" }), SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: ({ reservedType: a2 }) => `Unexpected reserved type ${a2}.`, UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: ({ unsupportedExportKind: a2, suggestion: t2 }) => `\`declare export ${a2}\` is not supported. Use \`${t2}\` instead.`, UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." });
        function _i(a2) {
          return a2.type === "DeclareExportAllDeclaration" || a2.type === "DeclareExportDeclaration" && (!a2.declaration || a2.declaration.type !== "TypeAlias" && a2.declaration.type !== "InterfaceDeclaration");
        }
        function _t2(a2) {
          return a2.importKind === "type" || a2.importKind === "typeof";
        }
        var ji = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" };
        function $i(a2, t2) {
          let e2 = [], s2 = [];
          for (let i2 = 0; i2 < a2.length; i2++)
            (t2(a2[i2], i2, a2) ? e2 : s2).push(a2[i2]);
          return [e2, s2];
        }
        var Vi = /\*?\s*@((?:no)?flow)\b/, qi2 = (a2) => class extends a2 {
          constructor(...e2) {
            super(...e2), this.flowPragma = void 0;
          }
          getScopeHandler() {
            return Xe2;
          }
          shouldParseTypes() {
            return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
          }
          shouldParseEnums() {
            return !!this.getPluginOption("flow", "enums");
          }
          finishToken(e2, s2) {
            e2 !== 133 && e2 !== 13 && e2 !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(e2, s2);
          }
          addComment(e2) {
            if (this.flowPragma === void 0) {
              let s2 = Vi.exec(e2.value);
              if (s2)
                if (s2[1] === "flow")
                  this.flowPragma = "flow";
                else if (s2[1] === "noflow")
                  this.flowPragma = "noflow";
                else
                  throw new Error("Unexpected flow pragma");
            }
            super.addComment(e2);
          }
          flowParseTypeInitialiser(e2) {
            let s2 = this.state.inType;
            this.state.inType = true, this.expect(e2 || 14);
            let i2 = this.flowParseType();
            return this.state.inType = s2, i2;
          }
          flowParsePredicate() {
            let e2 = this.startNode(), s2 = this.state.startLoc;
            return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > s2.index + 1 && this.raise(g2.UnexpectedSpaceBetweenModuloChecks, s2), this.eat(10) ? (e2.value = super.parseExpression(), this.expect(11), this.finishNode(e2, "DeclaredPredicate")) : this.finishNode(e2, "InferredPredicate");
          }
          flowParseTypeAndPredicateInitialiser() {
            let e2 = this.state.inType;
            this.state.inType = true, this.expect(14);
            let s2 = null, i2 = null;
            return this.match(54) ? (this.state.inType = e2, i2 = this.flowParsePredicate()) : (s2 = this.flowParseType(), this.state.inType = e2, this.match(54) && (i2 = this.flowParsePredicate())), [s2, i2];
          }
          flowParseDeclareClass(e2) {
            return this.next(), this.flowParseInterfaceish(e2, true), this.finishNode(e2, "DeclareClass");
          }
          flowParseDeclareFunction(e2) {
            this.next();
            let s2 = e2.id = this.parseIdentifier(), i2 = this.startNode(), r2 = this.startNode();
            this.match(47) ? i2.typeParameters = this.flowParseTypeParameterDeclaration() : i2.typeParameters = null, this.expect(10);
            let n2 = this.flowParseFunctionTypeParams();
            return i2.params = n2.params, i2.rest = n2.rest, i2.this = n2._this, this.expect(11), [i2.returnType, e2.predicate] = this.flowParseTypeAndPredicateInitialiser(), r2.typeAnnotation = this.finishNode(i2, "FunctionTypeAnnotation"), s2.typeAnnotation = this.finishNode(r2, "TypeAnnotation"), this.resetEndLocation(s2), this.semicolon(), this.scope.declareName(e2.id.name, 2048, e2.id.loc.start), this.finishNode(e2, "DeclareFunction");
          }
          flowParseDeclare(e2, s2) {
            if (this.match(80))
              return this.flowParseDeclareClass(e2);
            if (this.match(68))
              return this.flowParseDeclareFunction(e2);
            if (this.match(74))
              return this.flowParseDeclareVariable(e2);
            if (this.eatContextual(127))
              return this.match(16) ? this.flowParseDeclareModuleExports(e2) : (s2 && this.raise(g2.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(e2));
            if (this.isContextual(130))
              return this.flowParseDeclareTypeAlias(e2);
            if (this.isContextual(131))
              return this.flowParseDeclareOpaqueType(e2);
            if (this.isContextual(129))
              return this.flowParseDeclareInterface(e2);
            if (this.match(82))
              return this.flowParseDeclareExportDeclaration(e2, s2);
            this.unexpected();
          }
          flowParseDeclareVariable(e2) {
            return this.next(), e2.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(e2.id.name, 5, e2.id.loc.start), this.semicolon(), this.finishNode(e2, "DeclareVariable");
          }
          flowParseDeclareModule(e2) {
            this.scope.enter(0), this.match(133) ? e2.id = super.parseExprAtom() : e2.id = this.parseIdentifier();
            let s2 = e2.body = this.startNode(), i2 = s2.body = [];
            for (this.expect(5); !this.match(8); ) {
              let o2 = this.startNode();
              this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(g2.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), super.parseImport(o2)) : (this.expectContextual(125, g2.UnsupportedStatementInDeclareModule), o2 = this.flowParseDeclare(o2, true)), i2.push(o2);
            }
            this.scope.exit(), this.expect(8), this.finishNode(s2, "BlockStatement");
            let r2 = null, n2 = false;
            return i2.forEach((o2) => {
              _i(o2) ? (r2 === "CommonJS" && this.raise(g2.AmbiguousDeclareModuleKind, o2), r2 = "ES") : o2.type === "DeclareModuleExports" && (n2 && this.raise(g2.DuplicateDeclareModuleExports, o2), r2 === "ES" && this.raise(g2.AmbiguousDeclareModuleKind, o2), r2 = "CommonJS", n2 = true);
            }), e2.kind = r2 || "CommonJS", this.finishNode(e2, "DeclareModule");
          }
          flowParseDeclareExportDeclaration(e2, s2) {
            if (this.expect(82), this.eat(65))
              return this.match(68) || this.match(80) ? e2.declaration = this.flowParseDeclare(this.startNode()) : (e2.declaration = this.flowParseType(), this.semicolon()), e2.default = true, this.finishNode(e2, "DeclareExportDeclaration");
            if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !s2) {
              let i2 = this.state.value;
              throw this.raise(g2.UnsupportedDeclareExportKind, this.state.startLoc, { unsupportedExportKind: i2, suggestion: ji[i2] });
            }
            if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
              return e2.declaration = this.flowParseDeclare(this.startNode()), e2.default = false, this.finishNode(e2, "DeclareExportDeclaration");
            if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
              return e2 = this.parseExport(e2, null), e2.type === "ExportNamedDeclaration" && (e2.type = "ExportDeclaration", e2.default = false, delete e2.exportKind), e2.type = "Declare" + e2.type, e2;
            this.unexpected();
          }
          flowParseDeclareModuleExports(e2) {
            return this.next(), this.expectContextual(111), e2.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(e2, "DeclareModuleExports");
          }
          flowParseDeclareTypeAlias(e2) {
            this.next();
            let s2 = this.flowParseTypeAlias(e2);
            return s2.type = "DeclareTypeAlias", s2;
          }
          flowParseDeclareOpaqueType(e2) {
            this.next();
            let s2 = this.flowParseOpaqueType(e2, true);
            return s2.type = "DeclareOpaqueType", s2;
          }
          flowParseDeclareInterface(e2) {
            return this.next(), this.flowParseInterfaceish(e2, false), this.finishNode(e2, "DeclareInterface");
          }
          flowParseInterfaceish(e2, s2) {
            if (e2.id = this.flowParseRestrictedIdentifier(!s2, true), this.scope.declareName(e2.id.name, s2 ? 17 : 8201, e2.id.loc.start), this.match(47) ? e2.typeParameters = this.flowParseTypeParameterDeclaration() : e2.typeParameters = null, e2.extends = [], this.eat(81))
              do
                e2.extends.push(this.flowParseInterfaceExtends());
              while (!s2 && this.eat(12));
            if (s2) {
              if (e2.implements = [], e2.mixins = [], this.eatContextual(117))
                do
                  e2.mixins.push(this.flowParseInterfaceExtends());
                while (this.eat(12));
              if (this.eatContextual(113))
                do
                  e2.implements.push(this.flowParseInterfaceExtends());
                while (this.eat(12));
            }
            e2.body = this.flowParseObjectType({ allowStatic: s2, allowExact: false, allowSpread: false, allowProto: s2, allowInexact: false });
          }
          flowParseInterfaceExtends() {
            let e2 = this.startNode();
            return e2.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? e2.typeParameters = this.flowParseTypeParameterInstantiation() : e2.typeParameters = null, this.finishNode(e2, "InterfaceExtends");
          }
          flowParseInterface(e2) {
            return this.flowParseInterfaceish(e2, false), this.finishNode(e2, "InterfaceDeclaration");
          }
          checkNotUnderscore(e2) {
            e2 === "_" && this.raise(g2.UnexpectedReservedUnderscore, this.state.startLoc);
          }
          checkReservedType(e2, s2, i2) {
            Ui.has(e2) && this.raise(i2 ? g2.AssignReservedType : g2.UnexpectedReservedType, s2, { reservedType: e2 });
          }
          flowParseRestrictedIdentifier(e2, s2) {
            return this.checkReservedType(this.state.value, this.state.startLoc, s2), this.parseIdentifier(e2);
          }
          flowParseTypeAlias(e2) {
            return e2.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(e2.id.name, 8201, e2.id.loc.start), this.match(47) ? e2.typeParameters = this.flowParseTypeParameterDeclaration() : e2.typeParameters = null, e2.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(e2, "TypeAlias");
          }
          flowParseOpaqueType(e2, s2) {
            return this.expectContextual(130), e2.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(e2.id.name, 8201, e2.id.loc.start), this.match(47) ? e2.typeParameters = this.flowParseTypeParameterDeclaration() : e2.typeParameters = null, e2.supertype = null, this.match(14) && (e2.supertype = this.flowParseTypeInitialiser(14)), e2.impltype = null, s2 || (e2.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e2, "OpaqueType");
          }
          flowParseTypeParameter(e2 = false) {
            let s2 = this.state.startLoc, i2 = this.startNode(), r2 = this.flowParseVariance(), n2 = this.flowParseTypeAnnotatableIdentifier();
            return i2.name = n2.name, i2.variance = r2, i2.bound = n2.typeAnnotation, this.match(29) ? (this.eat(29), i2.default = this.flowParseType()) : e2 && this.raise(g2.MissingTypeParamDefault, s2), this.finishNode(i2, "TypeParameter");
          }
          flowParseTypeParameterDeclaration() {
            let e2 = this.state.inType, s2 = this.startNode();
            s2.params = [], this.state.inType = true, this.match(47) || this.match(142) ? this.next() : this.unexpected();
            let i2 = false;
            do {
              let r2 = this.flowParseTypeParameter(i2);
              s2.params.push(r2), r2.default && (i2 = true), this.match(48) || this.expect(12);
            } while (!this.match(48));
            return this.expect(48), this.state.inType = e2, this.finishNode(s2, "TypeParameterDeclaration");
          }
          flowParseTypeParameterInstantiation() {
            let e2 = this.startNode(), s2 = this.state.inType;
            e2.params = [], this.state.inType = true, this.expect(47);
            let i2 = this.state.noAnonFunctionType;
            for (this.state.noAnonFunctionType = false; !this.match(48); )
              e2.params.push(this.flowParseType()), this.match(48) || this.expect(12);
            return this.state.noAnonFunctionType = i2, this.expect(48), this.state.inType = s2, this.finishNode(e2, "TypeParameterInstantiation");
          }
          flowParseTypeParameterInstantiationCallOrNew() {
            let e2 = this.startNode(), s2 = this.state.inType;
            for (e2.params = [], this.state.inType = true, this.expect(47); !this.match(48); )
              e2.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
            return this.expect(48), this.state.inType = s2, this.finishNode(e2, "TypeParameterInstantiation");
          }
          flowParseInterfaceType() {
            let e2 = this.startNode();
            if (this.expectContextual(129), e2.extends = [], this.eat(81))
              do
                e2.extends.push(this.flowParseInterfaceExtends());
              while (this.eat(12));
            return e2.body = this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: false, allowProto: false, allowInexact: false }), this.finishNode(e2, "InterfaceTypeAnnotation");
          }
          flowParseObjectPropertyKey() {
            return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(true);
          }
          flowParseObjectTypeIndexer(e2, s2, i2) {
            return e2.static = s2, this.lookahead().type === 14 ? (e2.id = this.flowParseObjectPropertyKey(), e2.key = this.flowParseTypeInitialiser()) : (e2.id = null, e2.key = this.flowParseType()), this.expect(3), e2.value = this.flowParseTypeInitialiser(), e2.variance = i2, this.finishNode(e2, "ObjectTypeIndexer");
          }
          flowParseObjectTypeInternalSlot(e2, s2) {
            return e2.static = s2, e2.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (e2.method = true, e2.optional = false, e2.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e2.loc.start))) : (e2.method = false, this.eat(17) && (e2.optional = true), e2.value = this.flowParseTypeInitialiser()), this.finishNode(e2, "ObjectTypeInternalSlot");
          }
          flowParseObjectTypeMethodish(e2) {
            for (e2.params = [], e2.rest = null, e2.typeParameters = null, e2.this = null, this.match(47) && (e2.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (e2.this = this.flowParseFunctionTypeParam(true), e2.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
              e2.params.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
            return this.eat(21) && (e2.rest = this.flowParseFunctionTypeParam(false)), this.expect(11), e2.returnType = this.flowParseTypeInitialiser(), this.finishNode(e2, "FunctionTypeAnnotation");
          }
          flowParseObjectTypeCallProperty(e2, s2) {
            let i2 = this.startNode();
            return e2.static = s2, e2.value = this.flowParseObjectTypeMethodish(i2), this.finishNode(e2, "ObjectTypeCallProperty");
          }
          flowParseObjectType({ allowStatic: e2, allowExact: s2, allowSpread: i2, allowProto: r2, allowInexact: n2 }) {
            let o2 = this.state.inType;
            this.state.inType = true;
            let h2 = this.startNode();
            h2.callProperties = [], h2.properties = [], h2.indexers = [], h2.internalSlots = [];
            let c2, l2, u2 = false;
            for (s2 && this.match(6) ? (this.expect(6), c2 = 9, l2 = true) : (this.expect(5), c2 = 8, l2 = false), h2.exact = l2; !this.match(c2); ) {
              let d2 = false, y3 = null, E2 = null, L3 = this.startNode();
              if (r2 && this.isContextual(118)) {
                let I2 = this.lookahead();
                I2.type !== 14 && I2.type !== 17 && (this.next(), y3 = this.state.startLoc, e2 = false);
              }
              if (e2 && this.isContextual(106)) {
                let I2 = this.lookahead();
                I2.type !== 14 && I2.type !== 17 && (this.next(), d2 = true);
              }
              let S3 = this.flowParseVariance();
              if (this.eat(0))
                y3 != null && this.unexpected(y3), this.eat(0) ? (S3 && this.unexpected(S3.loc.start), h2.internalSlots.push(this.flowParseObjectTypeInternalSlot(L3, d2))) : h2.indexers.push(this.flowParseObjectTypeIndexer(L3, d2, S3));
              else if (this.match(10) || this.match(47))
                y3 != null && this.unexpected(y3), S3 && this.unexpected(S3.loc.start), h2.callProperties.push(this.flowParseObjectTypeCallProperty(L3, d2));
              else {
                let I2 = "init";
                if (this.isContextual(99) || this.isContextual(104)) {
                  let ne3 = this.lookahead();
                  Wt2(ne3.type) && (I2 = this.state.value, this.next());
                }
                let Ae3 = this.flowParseObjectTypeProperty(L3, d2, y3, S3, I2, i2, n2 ?? !l2);
                Ae3 === null ? (u2 = true, E2 = this.state.lastTokStartLoc) : h2.properties.push(Ae3);
              }
              this.flowObjectTypeSemicolon(), E2 && !this.match(8) && !this.match(9) && this.raise(g2.UnexpectedExplicitInexactInObject, E2);
            }
            this.expect(c2), i2 && (h2.inexact = u2);
            let f2 = this.finishNode(h2, "ObjectTypeAnnotation");
            return this.state.inType = o2, f2;
          }
          flowParseObjectTypeProperty(e2, s2, i2, r2, n2, o2, h2) {
            if (this.eat(21))
              return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (o2 ? h2 || this.raise(g2.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(g2.InexactInsideNonObject, this.state.lastTokStartLoc), r2 && this.raise(g2.InexactVariance, r2), null) : (o2 || this.raise(g2.UnexpectedSpreadType, this.state.lastTokStartLoc), i2 != null && this.unexpected(i2), r2 && this.raise(g2.SpreadVariance, r2), e2.argument = this.flowParseType(), this.finishNode(e2, "ObjectTypeSpreadProperty"));
            {
              e2.key = this.flowParseObjectPropertyKey(), e2.static = s2, e2.proto = i2 != null, e2.kind = n2;
              let c2 = false;
              return this.match(47) || this.match(10) ? (e2.method = true, i2 != null && this.unexpected(i2), r2 && this.unexpected(r2.loc.start), e2.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e2.loc.start)), (n2 === "get" || n2 === "set") && this.flowCheckGetterSetterParams(e2), !o2 && e2.key.name === "constructor" && e2.value.this && this.raise(g2.ThisParamBannedInConstructor, e2.value.this)) : (n2 !== "init" && this.unexpected(), e2.method = false, this.eat(17) && (c2 = true), e2.value = this.flowParseTypeInitialiser(), e2.variance = r2), e2.optional = c2, this.finishNode(e2, "ObjectTypeProperty");
            }
          }
          flowCheckGetterSetterParams(e2) {
            let s2 = e2.kind === "get" ? 0 : 1, i2 = e2.value.params.length + (e2.value.rest ? 1 : 0);
            e2.value.this && this.raise(e2.kind === "get" ? g2.GetterMayNotHaveThisParam : g2.SetterMayNotHaveThisParam, e2.value.this), i2 !== s2 && this.raise(e2.kind === "get" ? p2.BadGetterArity : p2.BadSetterArity, e2), e2.kind === "set" && e2.value.rest && this.raise(p2.BadSetterRestParameter, e2);
          }
          flowObjectTypeSemicolon() {
            !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
          }
          flowParseQualifiedTypeIdentifier(e2, s2) {
            var i2;
            (i2 = e2) != null || (e2 = this.state.startLoc);
            let r2 = s2 || this.flowParseRestrictedIdentifier(true);
            for (; this.eat(16); ) {
              let n2 = this.startNodeAt(e2);
              n2.qualification = r2, n2.id = this.flowParseRestrictedIdentifier(true), r2 = this.finishNode(n2, "QualifiedTypeIdentifier");
            }
            return r2;
          }
          flowParseGenericType(e2, s2) {
            let i2 = this.startNodeAt(e2);
            return i2.typeParameters = null, i2.id = this.flowParseQualifiedTypeIdentifier(e2, s2), this.match(47) && (i2.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(i2, "GenericTypeAnnotation");
          }
          flowParseTypeofType() {
            let e2 = this.startNode();
            return this.expect(87), e2.argument = this.flowParsePrimaryType(), this.finishNode(e2, "TypeofTypeAnnotation");
          }
          flowParseTupleType() {
            let e2 = this.startNode();
            for (e2.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (e2.types.push(this.flowParseType()), !this.match(3)); )
              this.expect(12);
            return this.expect(3), this.finishNode(e2, "TupleTypeAnnotation");
          }
          flowParseFunctionTypeParam(e2) {
            let s2 = null, i2 = false, r2 = null, n2 = this.startNode(), o2 = this.lookahead(), h2 = this.state.type === 78;
            return o2.type === 14 || o2.type === 17 ? (h2 && !e2 && this.raise(g2.ThisParamMustBeFirst, n2), s2 = this.parseIdentifier(h2), this.eat(17) && (i2 = true, h2 && this.raise(g2.ThisParamMayNotBeOptional, n2)), r2 = this.flowParseTypeInitialiser()) : r2 = this.flowParseType(), n2.name = s2, n2.optional = i2, n2.typeAnnotation = r2, this.finishNode(n2, "FunctionTypeParam");
          }
          reinterpretTypeAsFunctionTypeParam(e2) {
            let s2 = this.startNodeAt(e2.loc.start);
            return s2.name = null, s2.optional = false, s2.typeAnnotation = e2, this.finishNode(s2, "FunctionTypeParam");
          }
          flowParseFunctionTypeParams(e2 = []) {
            let s2 = null, i2 = null;
            for (this.match(78) && (i2 = this.flowParseFunctionTypeParam(true), i2.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
              e2.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
            return this.eat(21) && (s2 = this.flowParseFunctionTypeParam(false)), { params: e2, rest: s2, _this: i2 };
          }
          flowIdentToTypeAnnotation(e2, s2, i2) {
            switch (i2.name) {
              case "any":
                return this.finishNode(s2, "AnyTypeAnnotation");
              case "bool":
              case "boolean":
                return this.finishNode(s2, "BooleanTypeAnnotation");
              case "mixed":
                return this.finishNode(s2, "MixedTypeAnnotation");
              case "empty":
                return this.finishNode(s2, "EmptyTypeAnnotation");
              case "number":
                return this.finishNode(s2, "NumberTypeAnnotation");
              case "string":
                return this.finishNode(s2, "StringTypeAnnotation");
              case "symbol":
                return this.finishNode(s2, "SymbolTypeAnnotation");
              default:
                return this.checkNotUnderscore(i2.name), this.flowParseGenericType(e2, i2);
            }
          }
          flowParsePrimaryType() {
            let e2 = this.state.startLoc, s2 = this.startNode(), i2, r2, n2 = false, o2 = this.state.noAnonFunctionType;
            switch (this.state.type) {
              case 5:
                return this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: true, allowProto: false, allowInexact: true });
              case 6:
                return this.flowParseObjectType({ allowStatic: false, allowExact: true, allowSpread: true, allowProto: false, allowInexact: false });
              case 0:
                return this.state.noAnonFunctionType = false, r2 = this.flowParseTupleType(), this.state.noAnonFunctionType = o2, r2;
              case 47: {
                let h2 = this.startNode();
                return h2.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), i2 = this.flowParseFunctionTypeParams(), h2.params = i2.params, h2.rest = i2.rest, h2.this = i2._this, this.expect(11), this.expect(19), h2.returnType = this.flowParseType(), this.finishNode(h2, "FunctionTypeAnnotation");
              }
              case 10: {
                let h2 = this.startNode();
                if (this.next(), !this.match(11) && !this.match(21))
                  if (w2(this.state.type) || this.match(78)) {
                    let c2 = this.lookahead().type;
                    n2 = c2 !== 17 && c2 !== 14;
                  } else
                    n2 = true;
                if (n2) {
                  if (this.state.noAnonFunctionType = false, r2 = this.flowParseType(), this.state.noAnonFunctionType = o2, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19))
                    return this.expect(11), r2;
                  this.eat(12);
                }
                return r2 ? i2 = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(r2)]) : i2 = this.flowParseFunctionTypeParams(), h2.params = i2.params, h2.rest = i2.rest, h2.this = i2._this, this.expect(11), this.expect(19), h2.returnType = this.flowParseType(), h2.typeParameters = null, this.finishNode(h2, "FunctionTypeAnnotation");
              }
              case 133:
                return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
              case 85:
              case 86:
                return s2.value = this.match(85), this.next(), this.finishNode(s2, "BooleanLiteralTypeAnnotation");
              case 53:
                if (this.state.value === "-") {
                  if (this.next(), this.match(134))
                    return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", s2);
                  if (this.match(135))
                    return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", s2);
                  throw this.raise(g2.UnexpectedSubtractionOperand, this.state.startLoc);
                }
                this.unexpected();
                return;
              case 134:
                return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
              case 135:
                return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
              case 88:
                return this.next(), this.finishNode(s2, "VoidTypeAnnotation");
              case 84:
                return this.next(), this.finishNode(s2, "NullLiteralTypeAnnotation");
              case 78:
                return this.next(), this.finishNode(s2, "ThisTypeAnnotation");
              case 55:
                return this.next(), this.finishNode(s2, "ExistsTypeAnnotation");
              case 87:
                return this.flowParseTypeofType();
              default:
                if (Pt2(this.state.type)) {
                  let h2 = K2(this.state.type);
                  return this.next(), super.createIdentifier(s2, h2);
                } else if (w2(this.state.type))
                  return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(e2, s2, this.parseIdentifier());
            }
            this.unexpected();
          }
          flowParsePostfixType() {
            let e2 = this.state.startLoc, s2 = this.flowParsePrimaryType(), i2 = false;
            for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
              let r2 = this.startNodeAt(e2), n2 = this.eat(18);
              i2 = i2 || n2, this.expect(0), !n2 && this.match(3) ? (r2.elementType = s2, this.next(), s2 = this.finishNode(r2, "ArrayTypeAnnotation")) : (r2.objectType = s2, r2.indexType = this.flowParseType(), this.expect(3), i2 ? (r2.optional = n2, s2 = this.finishNode(r2, "OptionalIndexedAccessType")) : s2 = this.finishNode(r2, "IndexedAccessType"));
            }
            return s2;
          }
          flowParsePrefixType() {
            let e2 = this.startNode();
            return this.eat(17) ? (e2.typeAnnotation = this.flowParsePrefixType(), this.finishNode(e2, "NullableTypeAnnotation")) : this.flowParsePostfixType();
          }
          flowParseAnonFunctionWithoutParens() {
            let e2 = this.flowParsePrefixType();
            if (!this.state.noAnonFunctionType && this.eat(19)) {
              let s2 = this.startNodeAt(e2.loc.start);
              return s2.params = [this.reinterpretTypeAsFunctionTypeParam(e2)], s2.rest = null, s2.this = null, s2.returnType = this.flowParseType(), s2.typeParameters = null, this.finishNode(s2, "FunctionTypeAnnotation");
            }
            return e2;
          }
          flowParseIntersectionType() {
            let e2 = this.startNode();
            this.eat(45);
            let s2 = this.flowParseAnonFunctionWithoutParens();
            for (e2.types = [s2]; this.eat(45); )
              e2.types.push(this.flowParseAnonFunctionWithoutParens());
            return e2.types.length === 1 ? s2 : this.finishNode(e2, "IntersectionTypeAnnotation");
          }
          flowParseUnionType() {
            let e2 = this.startNode();
            this.eat(43);
            let s2 = this.flowParseIntersectionType();
            for (e2.types = [s2]; this.eat(43); )
              e2.types.push(this.flowParseIntersectionType());
            return e2.types.length === 1 ? s2 : this.finishNode(e2, "UnionTypeAnnotation");
          }
          flowParseType() {
            let e2 = this.state.inType;
            this.state.inType = true;
            let s2 = this.flowParseUnionType();
            return this.state.inType = e2, s2;
          }
          flowParseTypeOrImplicitInstantiation() {
            if (this.state.type === 132 && this.state.value === "_") {
              let e2 = this.state.startLoc, s2 = this.parseIdentifier();
              return this.flowParseGenericType(e2, s2);
            } else
              return this.flowParseType();
          }
          flowParseTypeAnnotation() {
            let e2 = this.startNode();
            return e2.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(e2, "TypeAnnotation");
          }
          flowParseTypeAnnotatableIdentifier(e2) {
            let s2 = e2 ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
            return this.match(14) && (s2.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(s2)), s2;
          }
          typeCastToParameter(e2) {
            return e2.expression.typeAnnotation = e2.typeAnnotation, this.resetEndLocation(e2.expression, e2.typeAnnotation.loc.end), e2.expression;
          }
          flowParseVariance() {
            let e2 = null;
            return this.match(53) ? (e2 = this.startNode(), this.state.value === "+" ? e2.kind = "plus" : e2.kind = "minus", this.next(), this.finishNode(e2, "Variance")) : e2;
          }
          parseFunctionBody(e2, s2, i2 = false) {
            if (s2) {
              this.forwardNoArrowParamsConversionAt(e2, () => super.parseFunctionBody(e2, true, i2));
              return;
            }
            super.parseFunctionBody(e2, false, i2);
          }
          parseFunctionBodyAndFinish(e2, s2, i2 = false) {
            if (this.match(14)) {
              let r2 = this.startNode();
              [r2.typeAnnotation, e2.predicate] = this.flowParseTypeAndPredicateInitialiser(), e2.returnType = r2.typeAnnotation ? this.finishNode(r2, "TypeAnnotation") : null;
            }
            return super.parseFunctionBodyAndFinish(e2, s2, i2);
          }
          parseStatementLike(e2) {
            if (this.state.strict && this.isContextual(129)) {
              let i2 = this.lookahead();
              if (M3(i2.type)) {
                let r2 = this.startNode();
                return this.next(), this.flowParseInterface(r2);
              }
            } else if (this.shouldParseEnums() && this.isContextual(126)) {
              let i2 = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(i2);
            }
            let s2 = super.parseStatementLike(e2);
            return this.flowPragma === void 0 && !this.isValidDirective(s2) && (this.flowPragma = null), s2;
          }
          parseExpressionStatement(e2, s2, i2) {
            if (s2.type === "Identifier") {
              if (s2.name === "declare") {
                if (this.match(80) || w2(this.state.type) || this.match(68) || this.match(74) || this.match(82))
                  return this.flowParseDeclare(e2);
              } else if (w2(this.state.type)) {
                if (s2.name === "interface")
                  return this.flowParseInterface(e2);
                if (s2.name === "type")
                  return this.flowParseTypeAlias(e2);
                if (s2.name === "opaque")
                  return this.flowParseOpaqueType(e2, false);
              }
            }
            return super.parseExpressionStatement(e2, s2, i2);
          }
          shouldParseExportDeclaration() {
            let { type: e2 } = this.state;
            return Ft3(e2) || this.shouldParseEnums() && e2 === 126 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
          }
          isExportDefaultSpecifier() {
            let { type: e2 } = this.state;
            return Ft3(e2) || this.shouldParseEnums() && e2 === 126 ? this.state.containsEsc : super.isExportDefaultSpecifier();
          }
          parseExportDefaultExpression() {
            if (this.shouldParseEnums() && this.isContextual(126)) {
              let e2 = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(e2);
            }
            return super.parseExportDefaultExpression();
          }
          parseConditional(e2, s2, i2) {
            if (!this.match(17))
              return e2;
            if (this.state.maybeInArrowParameters) {
              let f2 = this.lookaheadCharCode();
              if (f2 === 44 || f2 === 61 || f2 === 58 || f2 === 41)
                return this.setOptionalParametersError(i2), e2;
            }
            this.expect(17);
            let r2 = this.state.clone(), n2 = this.state.noArrowAt, o2 = this.startNodeAt(s2), { consequent: h2, failed: c2 } = this.tryParseConditionalConsequent(), [l2, u2] = this.getArrowLikeExpressions(h2);
            if (c2 || u2.length > 0) {
              let f2 = [...n2];
              if (u2.length > 0) {
                this.state = r2, this.state.noArrowAt = f2;
                for (let d2 = 0; d2 < u2.length; d2++)
                  f2.push(u2[d2].start);
                ({ consequent: h2, failed: c2 } = this.tryParseConditionalConsequent()), [l2, u2] = this.getArrowLikeExpressions(h2);
              }
              c2 && l2.length > 1 && this.raise(g2.AmbiguousConditionalArrow, r2.startLoc), c2 && l2.length === 1 && (this.state = r2, f2.push(l2[0].start), this.state.noArrowAt = f2, { consequent: h2, failed: c2 } = this.tryParseConditionalConsequent());
            }
            return this.getArrowLikeExpressions(h2, true), this.state.noArrowAt = n2, this.expect(14), o2.test = e2, o2.consequent = h2, o2.alternate = this.forwardNoArrowParamsConversionAt(o2, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(o2, "ConditionalExpression");
          }
          tryParseConditionalConsequent() {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            let e2 = this.parseMaybeAssignAllowIn(), s2 = !this.match(14);
            return this.state.noArrowParamsConversionAt.pop(), { consequent: e2, failed: s2 };
          }
          getArrowLikeExpressions(e2, s2) {
            let i2 = [e2], r2 = [];
            for (; i2.length !== 0; ) {
              let n2 = i2.pop();
              n2.type === "ArrowFunctionExpression" && n2.body.type !== "BlockStatement" ? (n2.typeParameters || !n2.returnType ? this.finishArrowValidation(n2) : r2.push(n2), i2.push(n2.body)) : n2.type === "ConditionalExpression" && (i2.push(n2.consequent), i2.push(n2.alternate));
            }
            return s2 ? (r2.forEach((n2) => this.finishArrowValidation(n2)), [r2, []]) : $i(r2, (n2) => n2.params.every((o2) => this.isAssignable(o2, true)));
          }
          finishArrowValidation(e2) {
            var s2;
            this.toAssignableList(e2.params, (s2 = e2.extra) == null ? void 0 : s2.trailingCommaLoc, false), this.scope.enter(6), super.checkParams(e2, false, true), this.scope.exit();
          }
          forwardNoArrowParamsConversionAt(e2, s2) {
            let i2;
            return this.state.noArrowParamsConversionAt.includes(e2.start) ? (this.state.noArrowParamsConversionAt.push(this.state.start), i2 = s2(), this.state.noArrowParamsConversionAt.pop()) : i2 = s2(), i2;
          }
          parseParenItem(e2, s2) {
            let i2 = super.parseParenItem(e2, s2);
            if (this.eat(17) && (i2.optional = true, this.resetEndLocation(e2)), this.match(14)) {
              let r2 = this.startNodeAt(s2);
              return r2.expression = i2, r2.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(r2, "TypeCastExpression");
            }
            return i2;
          }
          assertModuleNodeAllowed(e2) {
            e2.type === "ImportDeclaration" && (e2.importKind === "type" || e2.importKind === "typeof") || e2.type === "ExportNamedDeclaration" && e2.exportKind === "type" || e2.type === "ExportAllDeclaration" && e2.exportKind === "type" || super.assertModuleNodeAllowed(e2);
          }
          parseExportDeclaration(e2) {
            if (this.isContextual(130)) {
              e2.exportKind = "type";
              let s2 = this.startNode();
              return this.next(), this.match(5) ? (e2.specifiers = this.parseExportSpecifiers(true), super.parseExportFrom(e2), null) : this.flowParseTypeAlias(s2);
            } else if (this.isContextual(131)) {
              e2.exportKind = "type";
              let s2 = this.startNode();
              return this.next(), this.flowParseOpaqueType(s2, false);
            } else if (this.isContextual(129)) {
              e2.exportKind = "type";
              let s2 = this.startNode();
              return this.next(), this.flowParseInterface(s2);
            } else if (this.shouldParseEnums() && this.isContextual(126)) {
              e2.exportKind = "value";
              let s2 = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(s2);
            } else
              return super.parseExportDeclaration(e2);
          }
          eatExportStar(e2) {
            return super.eatExportStar(e2) ? true : this.isContextual(130) && this.lookahead().type === 55 ? (e2.exportKind = "type", this.next(), this.next(), true) : false;
          }
          maybeParseExportNamespaceSpecifier(e2) {
            let { startLoc: s2 } = this.state, i2 = super.maybeParseExportNamespaceSpecifier(e2);
            return i2 && e2.exportKind === "type" && this.unexpected(s2), i2;
          }
          parseClassId(e2, s2, i2) {
            super.parseClassId(e2, s2, i2), this.match(47) && (e2.typeParameters = this.flowParseTypeParameterDeclaration());
          }
          parseClassMember(e2, s2, i2) {
            let { startLoc: r2 } = this.state;
            if (this.isContextual(125)) {
              if (super.parseClassMemberFromModifier(e2, s2))
                return;
              s2.declare = true;
            }
            super.parseClassMember(e2, s2, i2), s2.declare && (s2.type !== "ClassProperty" && s2.type !== "ClassPrivateProperty" && s2.type !== "PropertyDefinition" ? this.raise(g2.DeclareClassElement, r2) : s2.value && this.raise(g2.DeclareClassFieldInitializer, s2.value));
          }
          isIterator(e2) {
            return e2 === "iterator" || e2 === "asyncIterator";
          }
          readIterator() {
            let e2 = super.readWord1(), s2 = "@@" + e2;
            (!this.isIterator(e2) || !this.state.inType) && this.raise(p2.InvalidIdentifier, this.state.curPosition(), { identifierName: s2 }), this.finishToken(132, s2);
          }
          getTokenFromCode(e2) {
            let s2 = this.input.charCodeAt(this.state.pos + 1);
            e2 === 123 && s2 === 124 ? this.finishOp(6, 2) : this.state.inType && (e2 === 62 || e2 === 60) ? this.finishOp(e2 === 62 ? 48 : 47, 1) : this.state.inType && e2 === 63 ? s2 === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : wi(e2, s2, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(e2);
          }
          isAssignable(e2, s2) {
            return e2.type === "TypeCastExpression" ? this.isAssignable(e2.expression, s2) : super.isAssignable(e2, s2);
          }
          toAssignable(e2, s2 = false) {
            !s2 && e2.type === "AssignmentExpression" && e2.left.type === "TypeCastExpression" && (e2.left = this.typeCastToParameter(e2.left)), super.toAssignable(e2, s2);
          }
          toAssignableList(e2, s2, i2) {
            for (let r2 = 0; r2 < e2.length; r2++) {
              let n2 = e2[r2];
              (n2 == null ? void 0 : n2.type) === "TypeCastExpression" && (e2[r2] = this.typeCastToParameter(n2));
            }
            super.toAssignableList(e2, s2, i2);
          }
          toReferencedList(e2, s2) {
            for (let r2 = 0; r2 < e2.length; r2++) {
              var i2;
              let n2 = e2[r2];
              n2 && n2.type === "TypeCastExpression" && !((i2 = n2.extra) != null && i2.parenthesized) && (e2.length > 1 || !s2) && this.raise(g2.TypeCastInPattern, n2.typeAnnotation);
            }
            return e2;
          }
          parseArrayLike(e2, s2, i2, r2) {
            let n2 = super.parseArrayLike(e2, s2, i2, r2);
            return s2 && !this.state.maybeInArrowParameters && this.toReferencedList(n2.elements), n2;
          }
          isValidLVal(e2, s2, i2) {
            return e2 === "TypeCastExpression" || super.isValidLVal(e2, s2, i2);
          }
          parseClassProperty(e2) {
            return this.match(14) && (e2.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e2);
          }
          parseClassPrivateProperty(e2) {
            return this.match(14) && (e2.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e2);
          }
          isClassMethod() {
            return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(14) || super.isClassProperty();
          }
          isNonstaticConstructor(e2) {
            return !this.match(14) && super.isNonstaticConstructor(e2);
          }
          pushClassMethod(e2, s2, i2, r2, n2, o2) {
            if (s2.variance && this.unexpected(s2.variance.loc.start), delete s2.variance, this.match(47) && (s2.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e2, s2, i2, r2, n2, o2), s2.params && n2) {
              let h2 = s2.params;
              h2.length > 0 && this.isThisParam(h2[0]) && this.raise(g2.ThisParamBannedInConstructor, s2);
            } else if (s2.type === "MethodDefinition" && n2 && s2.value.params) {
              let h2 = s2.value.params;
              h2.length > 0 && this.isThisParam(h2[0]) && this.raise(g2.ThisParamBannedInConstructor, s2);
            }
          }
          pushClassPrivateMethod(e2, s2, i2, r2) {
            s2.variance && this.unexpected(s2.variance.loc.start), delete s2.variance, this.match(47) && (s2.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e2, s2, i2, r2);
          }
          parseClassSuper(e2) {
            if (super.parseClassSuper(e2), e2.superClass && this.match(47) && (e2.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(113)) {
              this.next();
              let s2 = e2.implements = [];
              do {
                let i2 = this.startNode();
                i2.id = this.flowParseRestrictedIdentifier(true), this.match(47) ? i2.typeParameters = this.flowParseTypeParameterInstantiation() : i2.typeParameters = null, s2.push(this.finishNode(i2, "ClassImplements"));
              } while (this.eat(12));
            }
          }
          checkGetterSetterParams(e2) {
            super.checkGetterSetterParams(e2);
            let s2 = this.getObjectOrClassMethodParams(e2);
            if (s2.length > 0) {
              let i2 = s2[0];
              this.isThisParam(i2) && e2.kind === "get" ? this.raise(g2.GetterMayNotHaveThisParam, i2) : this.isThisParam(i2) && this.raise(g2.SetterMayNotHaveThisParam, i2);
            }
          }
          parsePropertyNamePrefixOperator(e2) {
            e2.variance = this.flowParseVariance();
          }
          parseObjPropValue(e2, s2, i2, r2, n2, o2, h2) {
            e2.variance && this.unexpected(e2.variance.loc.start), delete e2.variance;
            let c2;
            this.match(47) && !o2 && (c2 = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
            let l2 = super.parseObjPropValue(e2, s2, i2, r2, n2, o2, h2);
            return c2 && ((l2.value || l2).typeParameters = c2), l2;
          }
          parseAssignableListItemTypes(e2) {
            return this.eat(17) && (e2.type !== "Identifier" && this.raise(g2.PatternIsOptional, e2), this.isThisParam(e2) && this.raise(g2.ThisParamMayNotBeOptional, e2), e2.optional = true), this.match(14) ? e2.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(e2) && this.raise(g2.ThisParamAnnotationRequired, e2), this.match(29) && this.isThisParam(e2) && this.raise(g2.ThisParamNoDefault, e2), this.resetEndLocation(e2), e2;
          }
          parseMaybeDefault(e2, s2) {
            let i2 = super.parseMaybeDefault(e2, s2);
            return i2.type === "AssignmentPattern" && i2.typeAnnotation && i2.right.start < i2.typeAnnotation.start && this.raise(g2.TypeBeforeInitializer, i2.typeAnnotation), i2;
          }
          checkImportReflection(e2) {
            super.checkImportReflection(e2), e2.module && e2.importKind !== "value" && this.raise(g2.ImportReflectionHasImportType, e2.specifiers[0].loc.start);
          }
          parseImportSpecifierLocal(e2, s2, i2) {
            s2.local = _t2(e2) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), e2.specifiers.push(this.finishImportSpecifier(s2, i2));
          }
          isPotentialImportPhase(e2) {
            if (super.isPotentialImportPhase(e2))
              return true;
            if (this.isContextual(130)) {
              if (!e2)
                return true;
              let s2 = this.lookaheadCharCode();
              return s2 === 123 || s2 === 42;
            }
            return !e2 && this.isContextual(87);
          }
          applyImportPhase(e2, s2, i2, r2) {
            if (super.applyImportPhase(e2, s2, i2, r2), s2) {
              if (!i2 && this.match(65))
                return;
              e2.exportKind = i2 === "type" ? i2 : "value";
            } else
              i2 === "type" && this.match(55) && this.unexpected(), e2.importKind = i2 === "type" || i2 === "typeof" ? i2 : "value";
          }
          parseImportSpecifier(e2, s2, i2, r2, n2) {
            let o2 = e2.imported, h2 = null;
            o2.type === "Identifier" && (o2.name === "type" ? h2 = "type" : o2.name === "typeof" && (h2 = "typeof"));
            let c2 = false;
            if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
              let u2 = this.parseIdentifier(true);
              h2 !== null && !M3(this.state.type) ? (e2.imported = u2, e2.importKind = h2, e2.local = $2(u2)) : (e2.imported = o2, e2.importKind = null, e2.local = this.parseIdentifier());
            } else {
              if (h2 !== null && M3(this.state.type))
                e2.imported = this.parseIdentifier(true), e2.importKind = h2;
              else {
                if (s2)
                  throw this.raise(p2.ImportBindingIsString, e2, { importName: o2.value });
                e2.imported = o2, e2.importKind = null;
              }
              this.eatContextual(93) ? e2.local = this.parseIdentifier() : (c2 = true, e2.local = $2(e2.imported));
            }
            let l2 = _t2(e2);
            return i2 && l2 && this.raise(g2.ImportTypeShorthandOnlyInPureImport, e2), (i2 || l2) && this.checkReservedType(e2.local.name, e2.local.loc.start, true), c2 && !i2 && !l2 && this.checkReservedWord(e2.local.name, e2.loc.start, true, true), this.finishImportSpecifier(e2, "ImportSpecifier");
          }
          parseBindingAtom() {
            switch (this.state.type) {
              case 78:
                return this.parseIdentifier(true);
              default:
                return super.parseBindingAtom();
            }
          }
          parseFunctionParams(e2, s2) {
            let i2 = e2.kind;
            i2 !== "get" && i2 !== "set" && this.match(47) && (e2.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e2, s2);
          }
          parseVarId(e2, s2) {
            super.parseVarId(e2, s2), this.match(14) && (e2.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e2.id));
          }
          parseAsyncArrowFromCallExpression(e2, s2) {
            if (this.match(14)) {
              let i2 = this.state.noAnonFunctionType;
              this.state.noAnonFunctionType = true, e2.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = i2;
            }
            return super.parseAsyncArrowFromCallExpression(e2, s2);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          parseMaybeAssign(e2, s2) {
            var i2;
            let r2 = null, n2;
            if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
              if (r2 = this.state.clone(), n2 = this.tryParse(() => super.parseMaybeAssign(e2, s2), r2), !n2.error)
                return n2.node;
              let { context: c2 } = this.state, l2 = c2[c2.length - 1];
              (l2 === C.j_oTag || l2 === C.j_expr) && c2.pop();
            }
            if ((i2 = n2) != null && i2.error || this.match(47)) {
              var o2, h2;
              r2 = r2 || this.state.clone();
              let c2, l2 = this.tryParse((f2) => {
                var d2;
                c2 = this.flowParseTypeParameterDeclaration();
                let y3 = this.forwardNoArrowParamsConversionAt(c2, () => {
                  let L3 = super.parseMaybeAssign(e2, s2);
                  return this.resetStartLocationFromNode(L3, c2), L3;
                });
                (d2 = y3.extra) != null && d2.parenthesized && f2();
                let E2 = this.maybeUnwrapTypeCastExpression(y3);
                return E2.type !== "ArrowFunctionExpression" && f2(), E2.typeParameters = c2, this.resetStartLocationFromNode(E2, c2), y3;
              }, r2), u2 = null;
              if (l2.node && this.maybeUnwrapTypeCastExpression(l2.node).type === "ArrowFunctionExpression") {
                if (!l2.error && !l2.aborted)
                  return l2.node.async && this.raise(g2.UnexpectedTypeParameterBeforeAsyncArrowFunction, c2), l2.node;
                u2 = l2.node;
              }
              if ((o2 = n2) != null && o2.node)
                return this.state = n2.failState, n2.node;
              if (u2)
                return this.state = l2.failState, u2;
              throw (h2 = n2) != null && h2.thrown ? n2.error : l2.thrown ? l2.error : this.raise(g2.UnexpectedTokenAfterTypeParameter, c2);
            }
            return super.parseMaybeAssign(e2, s2);
          }
          parseArrow(e2) {
            if (this.match(14)) {
              let s2 = this.tryParse(() => {
                let i2 = this.state.noAnonFunctionType;
                this.state.noAnonFunctionType = true;
                let r2 = this.startNode();
                return [r2.typeAnnotation, e2.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = i2, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), r2;
              });
              if (s2.thrown)
                return null;
              s2.error && (this.state = s2.failState), e2.returnType = s2.node.typeAnnotation ? this.finishNode(s2.node, "TypeAnnotation") : null;
            }
            return super.parseArrow(e2);
          }
          shouldParseArrow(e2) {
            return this.match(14) || super.shouldParseArrow(e2);
          }
          setArrowFunctionParameters(e2, s2) {
            this.state.noArrowParamsConversionAt.includes(e2.start) ? e2.params = s2 : super.setArrowFunctionParameters(e2, s2);
          }
          checkParams(e2, s2, i2, r2 = true) {
            if (!(i2 && this.state.noArrowParamsConversionAt.includes(e2.start))) {
              for (let n2 = 0; n2 < e2.params.length; n2++)
                this.isThisParam(e2.params[n2]) && n2 > 0 && this.raise(g2.ThisParamMustBeFirst, e2.params[n2]);
              super.checkParams(e2, s2, i2, r2);
            }
          }
          parseParenAndDistinguishExpression(e2) {
            return super.parseParenAndDistinguishExpression(e2 && !this.state.noArrowAt.includes(this.state.start));
          }
          parseSubscripts(e2, s2, i2) {
            if (e2.type === "Identifier" && e2.name === "async" && this.state.noArrowAt.includes(s2.index)) {
              this.next();
              let r2 = this.startNodeAt(s2);
              r2.callee = e2, r2.arguments = super.parseCallExpressionArguments(11, false), e2 = this.finishNode(r2, "CallExpression");
            } else if (e2.type === "Identifier" && e2.name === "async" && this.match(47)) {
              let r2 = this.state.clone(), n2 = this.tryParse((h2) => this.parseAsyncArrowWithTypeParameters(s2) || h2(), r2);
              if (!n2.error && !n2.aborted)
                return n2.node;
              let o2 = this.tryParse(() => super.parseSubscripts(e2, s2, i2), r2);
              if (o2.node && !o2.error)
                return o2.node;
              if (n2.node)
                return this.state = n2.failState, n2.node;
              if (o2.node)
                return this.state = o2.failState, o2.node;
              throw n2.error || o2.error;
            }
            return super.parseSubscripts(e2, s2, i2);
          }
          parseSubscript(e2, s2, i2, r2) {
            if (this.match(18) && this.isLookaheadToken_lt()) {
              if (r2.optionalChainMember = true, i2)
                return r2.stop = true, e2;
              this.next();
              let n2 = this.startNodeAt(s2);
              return n2.callee = e2, n2.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), n2.arguments = this.parseCallExpressionArguments(11, false), n2.optional = true, this.finishCallExpression(n2, true);
            } else if (!i2 && this.shouldParseTypes() && this.match(47)) {
              let n2 = this.startNodeAt(s2);
              n2.callee = e2;
              let o2 = this.tryParse(() => (n2.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), n2.arguments = super.parseCallExpressionArguments(11, false), r2.optionalChainMember && (n2.optional = false), this.finishCallExpression(n2, r2.optionalChainMember)));
              if (o2.node)
                return o2.error && (this.state = o2.failState), o2.node;
            }
            return super.parseSubscript(e2, s2, i2, r2);
          }
          parseNewCallee(e2) {
            super.parseNewCallee(e2);
            let s2 = null;
            this.shouldParseTypes() && this.match(47) && (s2 = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), e2.typeArguments = s2;
          }
          parseAsyncArrowWithTypeParameters(e2) {
            let s2 = this.startNodeAt(e2);
            if (this.parseFunctionParams(s2, false), !!this.parseArrow(s2))
              return super.parseArrowExpression(s2, void 0, true);
          }
          readToken_mult_modulo(e2) {
            let s2 = this.input.charCodeAt(this.state.pos + 1);
            if (e2 === 42 && s2 === 47 && this.state.hasFlowComment) {
              this.state.hasFlowComment = false, this.state.pos += 2, this.nextToken();
              return;
            }
            super.readToken_mult_modulo(e2);
          }
          readToken_pipe_amp(e2) {
            let s2 = this.input.charCodeAt(this.state.pos + 1);
            if (e2 === 124 && s2 === 125) {
              this.finishOp(9, 2);
              return;
            }
            super.readToken_pipe_amp(e2);
          }
          parseTopLevel(e2, s2) {
            let i2 = super.parseTopLevel(e2, s2);
            return this.state.hasFlowComment && this.raise(g2.UnterminatedFlowComment, this.state.curPosition()), i2;
          }
          skipBlockComment() {
            if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
              if (this.state.hasFlowComment)
                throw this.raise(g2.NestedFlowComment, this.state.startLoc);
              this.hasFlowCommentCompletion();
              let e2 = this.skipFlowComment();
              e2 && (this.state.pos += e2, this.state.hasFlowComment = true);
              return;
            }
            return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
          }
          skipFlowComment() {
            let { pos: e2 } = this.state, s2 = 2;
            for (; [32, 9].includes(this.input.charCodeAt(e2 + s2)); )
              s2++;
            let i2 = this.input.charCodeAt(s2 + e2), r2 = this.input.charCodeAt(s2 + e2 + 1);
            return i2 === 58 && r2 === 58 ? s2 + 2 : this.input.slice(s2 + e2, s2 + e2 + 12) === "flow-include" ? s2 + 12 : i2 === 58 && r2 !== 58 ? s2 : false;
          }
          hasFlowCommentCompletion() {
            if (this.input.indexOf("*/", this.state.pos) === -1)
              throw this.raise(p2.UnterminatedComment, this.state.curPosition());
          }
          flowEnumErrorBooleanMemberNotInitialized(e2, { enumName: s2, memberName: i2 }) {
            this.raise(g2.EnumBooleanMemberNotInitialized, e2, { memberName: i2, enumName: s2 });
          }
          flowEnumErrorInvalidMemberInitializer(e2, s2) {
            return this.raise(s2.explicitType ? s2.explicitType === "symbol" ? g2.EnumInvalidMemberInitializerSymbolType : g2.EnumInvalidMemberInitializerPrimaryType : g2.EnumInvalidMemberInitializerUnknownType, e2, s2);
          }
          flowEnumErrorNumberMemberNotInitialized(e2, s2) {
            this.raise(g2.EnumNumberMemberNotInitialized, e2, s2);
          }
          flowEnumErrorStringMemberInconsistentlyInitialized(e2, s2) {
            this.raise(g2.EnumStringMemberInconsistentlyInitialized, e2, s2);
          }
          flowEnumMemberInit() {
            let e2 = this.state.startLoc, s2 = () => this.match(12) || this.match(8);
            switch (this.state.type) {
              case 134: {
                let i2 = this.parseNumericLiteral(this.state.value);
                return s2() ? { type: "number", loc: i2.loc.start, value: i2 } : { type: "invalid", loc: e2 };
              }
              case 133: {
                let i2 = this.parseStringLiteral(this.state.value);
                return s2() ? { type: "string", loc: i2.loc.start, value: i2 } : { type: "invalid", loc: e2 };
              }
              case 85:
              case 86: {
                let i2 = this.parseBooleanLiteral(this.match(85));
                return s2() ? { type: "boolean", loc: i2.loc.start, value: i2 } : { type: "invalid", loc: e2 };
              }
              default:
                return { type: "invalid", loc: e2 };
            }
          }
          flowEnumMemberRaw() {
            let e2 = this.state.startLoc, s2 = this.parseIdentifier(true), i2 = this.eat(29) ? this.flowEnumMemberInit() : { type: "none", loc: e2 };
            return { id: s2, init: i2 };
          }
          flowEnumCheckExplicitTypeMismatch(e2, s2, i2) {
            let { explicitType: r2 } = s2;
            r2 !== null && r2 !== i2 && this.flowEnumErrorInvalidMemberInitializer(e2, s2);
          }
          flowEnumMembers({ enumName: e2, explicitType: s2 }) {
            let i2 = /* @__PURE__ */ new Set(), r2 = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] }, n2 = false;
            for (; !this.match(8); ) {
              if (this.eat(21)) {
                n2 = true;
                break;
              }
              let o2 = this.startNode(), { id: h2, init: c2 } = this.flowEnumMemberRaw(), l2 = h2.name;
              if (l2 === "")
                continue;
              /^[a-z]/.test(l2) && this.raise(g2.EnumInvalidMemberName, h2, { memberName: l2, suggestion: l2[0].toUpperCase() + l2.slice(1), enumName: e2 }), i2.has(l2) && this.raise(g2.EnumDuplicateMemberName, h2, { memberName: l2, enumName: e2 }), i2.add(l2);
              let u2 = { enumName: e2, explicitType: s2, memberName: l2 };
              switch (o2.id = h2, c2.type) {
                case "boolean": {
                  this.flowEnumCheckExplicitTypeMismatch(c2.loc, u2, "boolean"), o2.init = c2.value, r2.booleanMembers.push(this.finishNode(o2, "EnumBooleanMember"));
                  break;
                }
                case "number": {
                  this.flowEnumCheckExplicitTypeMismatch(c2.loc, u2, "number"), o2.init = c2.value, r2.numberMembers.push(this.finishNode(o2, "EnumNumberMember"));
                  break;
                }
                case "string": {
                  this.flowEnumCheckExplicitTypeMismatch(c2.loc, u2, "string"), o2.init = c2.value, r2.stringMembers.push(this.finishNode(o2, "EnumStringMember"));
                  break;
                }
                case "invalid":
                  throw this.flowEnumErrorInvalidMemberInitializer(c2.loc, u2);
                case "none":
                  switch (s2) {
                    case "boolean":
                      this.flowEnumErrorBooleanMemberNotInitialized(c2.loc, u2);
                      break;
                    case "number":
                      this.flowEnumErrorNumberMemberNotInitialized(c2.loc, u2);
                      break;
                    default:
                      r2.defaultedMembers.push(this.finishNode(o2, "EnumDefaultedMember"));
                  }
              }
              this.match(8) || this.expect(12);
            }
            return { members: r2, hasUnknownMembers: n2 };
          }
          flowEnumStringMembers(e2, s2, { enumName: i2 }) {
            if (e2.length === 0)
              return s2;
            if (s2.length === 0)
              return e2;
            if (s2.length > e2.length) {
              for (let r2 of e2)
                this.flowEnumErrorStringMemberInconsistentlyInitialized(r2, { enumName: i2 });
              return s2;
            } else {
              for (let r2 of s2)
                this.flowEnumErrorStringMemberInconsistentlyInitialized(r2, { enumName: i2 });
              return e2;
            }
          }
          flowEnumParseExplicitType({ enumName: e2 }) {
            if (!this.eatContextual(102))
              return null;
            if (!w2(this.state.type))
              throw this.raise(g2.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, { enumName: e2 });
            let { value: s2 } = this.state;
            return this.next(), s2 !== "boolean" && s2 !== "number" && s2 !== "string" && s2 !== "symbol" && this.raise(g2.EnumInvalidExplicitType, this.state.startLoc, { enumName: e2, invalidEnumType: s2 }), s2;
          }
          flowEnumBody(e2, s2) {
            let i2 = s2.name, r2 = s2.loc.start, n2 = this.flowEnumParseExplicitType({ enumName: i2 });
            this.expect(5);
            let { members: o2, hasUnknownMembers: h2 } = this.flowEnumMembers({ enumName: i2, explicitType: n2 });
            switch (e2.hasUnknownMembers = h2, n2) {
              case "boolean":
                return e2.explicitType = true, e2.members = o2.booleanMembers, this.expect(8), this.finishNode(e2, "EnumBooleanBody");
              case "number":
                return e2.explicitType = true, e2.members = o2.numberMembers, this.expect(8), this.finishNode(e2, "EnumNumberBody");
              case "string":
                return e2.explicitType = true, e2.members = this.flowEnumStringMembers(o2.stringMembers, o2.defaultedMembers, { enumName: i2 }), this.expect(8), this.finishNode(e2, "EnumStringBody");
              case "symbol":
                return e2.members = o2.defaultedMembers, this.expect(8), this.finishNode(e2, "EnumSymbolBody");
              default: {
                let c2 = () => (e2.members = [], this.expect(8), this.finishNode(e2, "EnumStringBody"));
                e2.explicitType = false;
                let l2 = o2.booleanMembers.length, u2 = o2.numberMembers.length, f2 = o2.stringMembers.length, d2 = o2.defaultedMembers.length;
                if (!l2 && !u2 && !f2 && !d2)
                  return c2();
                if (!l2 && !u2)
                  return e2.members = this.flowEnumStringMembers(o2.stringMembers, o2.defaultedMembers, { enumName: i2 }), this.expect(8), this.finishNode(e2, "EnumStringBody");
                if (!u2 && !f2 && l2 >= d2) {
                  for (let y3 of o2.defaultedMembers)
                    this.flowEnumErrorBooleanMemberNotInitialized(y3.loc.start, { enumName: i2, memberName: y3.id.name });
                  return e2.members = o2.booleanMembers, this.expect(8), this.finishNode(e2, "EnumBooleanBody");
                } else if (!l2 && !f2 && u2 >= d2) {
                  for (let y3 of o2.defaultedMembers)
                    this.flowEnumErrorNumberMemberNotInitialized(y3.loc.start, { enumName: i2, memberName: y3.id.name });
                  return e2.members = o2.numberMembers, this.expect(8), this.finishNode(e2, "EnumNumberBody");
                } else
                  return this.raise(g2.EnumInconsistentMemberValues, r2, { enumName: i2 }), c2();
              }
            }
          }
          flowParseEnumDeclaration(e2) {
            let s2 = this.parseIdentifier();
            return e2.id = s2, e2.body = this.flowEnumBody(this.startNode(), s2), this.finishNode(e2, "EnumDeclaration");
          }
          isLookaheadToken_lt() {
            let e2 = this.nextTokenStart();
            if (this.input.charCodeAt(e2) === 60) {
              let s2 = this.input.charCodeAt(e2 + 1);
              return s2 !== 60 && s2 !== 61;
            }
            return false;
          }
          maybeUnwrapTypeCastExpression(e2) {
            return e2.type === "TypeCastExpression" ? e2.expression : e2;
          }
        }, W2 = j2`jsx`({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: ({ openingTagName: a2 }) => `Expected corresponding JSX closing tag for <${a2}>.`, MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnexpectedToken: ({ unexpected: a2, HTMLEntity: t2 }) => `Unexpected token \`${a2}\`. Did you mean \`${t2}\` or \`{'${a2}'}\`?`, UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" });
        function z3(a2) {
          return a2 ? a2.type === "JSXOpeningFragment" || a2.type === "JSXClosingFragment" : false;
        }
        function Y2(a2) {
          if (a2.type === "JSXIdentifier")
            return a2.name;
          if (a2.type === "JSXNamespacedName")
            return a2.namespace.name + ":" + a2.name.name;
          if (a2.type === "JSXMemberExpression")
            return Y2(a2.object) + "." + Y2(a2.property);
          throw new Error("Node had unexpected type: " + a2.type);
        }
        var zi = (a2) => class extends a2 {
          jsxReadToken() {
            let e2 = "", s2 = this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length)
                throw this.raise(W2.UnterminatedJsxContent, this.state.startLoc);
              let i2 = this.input.charCodeAt(this.state.pos);
              switch (i2) {
                case 60:
                case 123:
                  if (this.state.pos === this.state.start) {
                    i2 === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(142)) : super.getTokenFromCode(i2);
                    return;
                  }
                  e2 += this.input.slice(s2, this.state.pos), this.finishToken(141, e2);
                  return;
                case 38:
                  e2 += this.input.slice(s2, this.state.pos), e2 += this.jsxReadEntity(), s2 = this.state.pos;
                  break;
                case 62:
                case 125:
                default:
                  fe2(i2) ? (e2 += this.input.slice(s2, this.state.pos), e2 += this.jsxReadNewLine(true), s2 = this.state.pos) : ++this.state.pos;
              }
            }
          }
          jsxReadNewLine(e2) {
            let s2 = this.input.charCodeAt(this.state.pos), i2;
            return ++this.state.pos, s2 === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, i2 = e2 ? `
` : `\r
`) : i2 = String.fromCharCode(s2), ++this.state.curLine, this.state.lineStart = this.state.pos, i2;
          }
          jsxReadString(e2) {
            let s2 = "", i2 = ++this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length)
                throw this.raise(p2.UnterminatedString, this.state.startLoc);
              let r2 = this.input.charCodeAt(this.state.pos);
              if (r2 === e2)
                break;
              r2 === 38 ? (s2 += this.input.slice(i2, this.state.pos), s2 += this.jsxReadEntity(), i2 = this.state.pos) : fe2(r2) ? (s2 += this.input.slice(i2, this.state.pos), s2 += this.jsxReadNewLine(false), i2 = this.state.pos) : ++this.state.pos;
            }
            s2 += this.input.slice(i2, this.state.pos++), this.finishToken(133, s2);
          }
          jsxReadEntity() {
            let e2 = ++this.state.pos;
            if (this.codePointAtPos(this.state.pos) === 35) {
              ++this.state.pos;
              let s2 = 10;
              this.codePointAtPos(this.state.pos) === 120 && (s2 = 16, ++this.state.pos);
              let i2 = this.readInt(s2, void 0, false, "bail");
              if (i2 !== null && this.codePointAtPos(this.state.pos) === 59)
                return ++this.state.pos, String.fromCodePoint(i2);
            } else {
              let s2 = 0, i2 = false;
              for (; s2++ < 10 && this.state.pos < this.length && !(i2 = this.codePointAtPos(this.state.pos) === 59); )
                ++this.state.pos;
              if (i2) {
                let r2 = this.input.slice(e2, this.state.pos), n2 = void 0;
                if (++this.state.pos, n2)
                  return n2;
              }
            }
            return this.state.pos = e2, "&";
          }
          jsxReadWord() {
            let e2, s2 = this.state.pos;
            do
              e2 = this.input.charCodeAt(++this.state.pos);
            while (Q3(e2) || e2 === 45);
            this.finishToken(140, this.input.slice(s2, this.state.pos));
          }
          jsxParseIdentifier() {
            let e2 = this.startNode();
            return this.match(140) ? e2.name = this.state.value : Pt2(this.state.type) ? e2.name = K2(this.state.type) : this.unexpected(), this.next(), this.finishNode(e2, "JSXIdentifier");
          }
          jsxParseNamespacedName() {
            let e2 = this.state.startLoc, s2 = this.jsxParseIdentifier();
            if (!this.eat(14))
              return s2;
            let i2 = this.startNodeAt(e2);
            return i2.namespace = s2, i2.name = this.jsxParseIdentifier(), this.finishNode(i2, "JSXNamespacedName");
          }
          jsxParseElementName() {
            let e2 = this.state.startLoc, s2 = this.jsxParseNamespacedName();
            if (s2.type === "JSXNamespacedName")
              return s2;
            for (; this.eat(16); ) {
              let i2 = this.startNodeAt(e2);
              i2.object = s2, i2.property = this.jsxParseIdentifier(), s2 = this.finishNode(i2, "JSXMemberExpression");
            }
            return s2;
          }
          jsxParseAttributeValue() {
            let e2;
            switch (this.state.type) {
              case 5:
                return e2 = this.startNode(), this.setContext(C.brace), this.next(), e2 = this.jsxParseExpressionContainer(e2, C.j_oTag), e2.expression.type === "JSXEmptyExpression" && this.raise(W2.AttributeIsEmpty, e2), e2;
              case 142:
              case 133:
                return this.parseExprAtom();
              default:
                throw this.raise(W2.UnsupportedJsxValue, this.state.startLoc);
            }
          }
          jsxParseEmptyExpression() {
            let e2 = this.startNodeAt(this.state.lastTokEndLoc);
            return this.finishNodeAt(e2, "JSXEmptyExpression", this.state.startLoc);
          }
          jsxParseSpreadChild(e2) {
            return this.next(), e2.expression = this.parseExpression(), this.setContext(C.j_expr), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e2, "JSXSpreadChild");
          }
          jsxParseExpressionContainer(e2, s2) {
            if (this.match(8))
              e2.expression = this.jsxParseEmptyExpression();
            else {
              let i2 = this.parseExpression();
              e2.expression = i2;
            }
            return this.setContext(s2), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e2, "JSXExpressionContainer");
          }
          jsxParseAttribute() {
            let e2 = this.startNode();
            return this.match(5) ? (this.setContext(C.brace), this.next(), this.expect(21), e2.argument = this.parseMaybeAssignAllowIn(), this.setContext(C.j_oTag), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e2, "JSXSpreadAttribute")) : (e2.name = this.jsxParseNamespacedName(), e2.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(e2, "JSXAttribute"));
          }
          jsxParseOpeningElementAt(e2) {
            let s2 = this.startNodeAt(e2);
            return this.eat(143) ? this.finishNode(s2, "JSXOpeningFragment") : (s2.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(s2));
          }
          jsxParseOpeningElementAfterName(e2) {
            let s2 = [];
            for (; !this.match(56) && !this.match(143); )
              s2.push(this.jsxParseAttribute());
            return e2.attributes = s2, e2.selfClosing = this.eat(56), this.expect(143), this.finishNode(e2, "JSXOpeningElement");
          }
          jsxParseClosingElementAt(e2) {
            let s2 = this.startNodeAt(e2);
            return this.eat(143) ? this.finishNode(s2, "JSXClosingFragment") : (s2.name = this.jsxParseElementName(), this.expect(143), this.finishNode(s2, "JSXClosingElement"));
          }
          jsxParseElementAt(e2) {
            let s2 = this.startNodeAt(e2), i2 = [], r2 = this.jsxParseOpeningElementAt(e2), n2 = null;
            if (!r2.selfClosing) {
              e:
                for (; ; )
                  switch (this.state.type) {
                    case 142:
                      if (e2 = this.state.startLoc, this.next(), this.eat(56)) {
                        n2 = this.jsxParseClosingElementAt(e2);
                        break e;
                      }
                      i2.push(this.jsxParseElementAt(e2));
                      break;
                    case 141:
                      i2.push(this.parseLiteral(this.state.value, "JSXText"));
                      break;
                    case 5: {
                      let o2 = this.startNode();
                      this.setContext(C.brace), this.next(), this.match(21) ? i2.push(this.jsxParseSpreadChild(o2)) : i2.push(this.jsxParseExpressionContainer(o2, C.j_expr));
                      break;
                    }
                    default:
                      this.unexpected();
                  }
              z3(r2) && !z3(n2) && n2 !== null ? this.raise(W2.MissingClosingTagFragment, n2) : !z3(r2) && z3(n2) ? this.raise(W2.MissingClosingTagElement, n2, { openingTagName: Y2(r2.name) }) : !z3(r2) && !z3(n2) && Y2(n2.name) !== Y2(r2.name) && this.raise(W2.MissingClosingTagElement, n2, { openingTagName: Y2(r2.name) });
            }
            if (z3(r2) ? (s2.openingFragment = r2, s2.closingFragment = n2) : (s2.openingElement = r2, s2.closingElement = n2), s2.children = i2, this.match(47))
              throw this.raise(W2.UnwrappedAdjacentJSXElements, this.state.startLoc);
            return z3(r2) ? this.finishNode(s2, "JSXFragment") : this.finishNode(s2, "JSXElement");
          }
          jsxParseElement() {
            let e2 = this.state.startLoc;
            return this.next(), this.jsxParseElementAt(e2);
          }
          setContext(e2) {
            let { context: s2 } = this.state;
            s2[s2.length - 1] = e2;
          }
          parseExprAtom(e2) {
            return this.match(142) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(142), this.jsxParseElement()) : super.parseExprAtom(e2);
          }
          skipSpace() {
            this.curContext().preserveSpace || super.skipSpace();
          }
          getTokenFromCode(e2) {
            let s2 = this.curContext();
            if (s2 === C.j_expr) {
              this.jsxReadToken();
              return;
            }
            if (s2 === C.j_oTag || s2 === C.j_cTag) {
              if (_3(e2)) {
                this.jsxReadWord();
                return;
              }
              if (e2 === 62) {
                ++this.state.pos, this.finishToken(143);
                return;
              }
              if ((e2 === 34 || e2 === 39) && s2 === C.j_oTag) {
                this.jsxReadString(e2);
                return;
              }
            }
            if (e2 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
              ++this.state.pos, this.finishToken(142);
              return;
            }
            super.getTokenFromCode(e2);
          }
          updateContext(e2) {
            let { context: s2, type: i2 } = this.state;
            if (i2 === 56 && e2 === 142)
              s2.splice(-2, 2, C.j_cTag), this.state.canStartJSXElement = false;
            else if (i2 === 142)
              s2.push(C.j_oTag);
            else if (i2 === 143) {
              let r2 = s2[s2.length - 1];
              r2 === C.j_oTag && e2 === 56 || r2 === C.j_cTag ? (s2.pop(), this.state.canStartJSXElement = s2[s2.length - 1] === C.j_expr) : (this.setContext(C.j_expr), this.state.canStartJSXElement = true);
            } else
              this.state.canStartJSXElement = hi3(i2);
          }
        }, ot3 = class extends de2 {
          constructor(...t2) {
            super(...t2), this.tsNames = /* @__PURE__ */ new Map();
          }
        }, ht3 = class extends me2 {
          constructor(...t2) {
            super(...t2), this.importsStack = [];
          }
          createScope(t2) {
            return this.importsStack.push(/* @__PURE__ */ new Set()), new ot3(t2);
          }
          enter(t2) {
            t2 === 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(t2);
          }
          exit() {
            let t2 = super.exit();
            return t2 === 256 && this.importsStack.pop(), t2;
          }
          hasImport(t2, e2) {
            let s2 = this.importsStack.length;
            if (this.importsStack[s2 - 1].has(t2))
              return true;
            if (!e2 && s2 > 1) {
              for (let i2 = 0; i2 < s2 - 1; i2++)
                if (this.importsStack[i2].has(t2))
                  return true;
            }
            return false;
          }
          declareName(t2, e2, s2) {
            if (e2 & 4096) {
              this.hasImport(t2, true) && this.parser.raise(p2.VarRedeclaration, s2, { identifierName: t2 }), this.importsStack[this.importsStack.length - 1].add(t2);
              return;
            }
            let i2 = this.currentScope(), r2 = i2.tsNames.get(t2) || 0;
            if (e2 & 1024) {
              this.maybeExportDefined(i2, t2), i2.tsNames.set(t2, r2 | 16);
              return;
            }
            super.declareName(t2, e2, s2), e2 & 2 && (e2 & 1 || (this.checkRedeclarationInScope(i2, t2, e2, s2), this.maybeExportDefined(i2, t2)), r2 = r2 | 1), e2 & 256 && (r2 = r2 | 2), e2 & 512 && (r2 = r2 | 4), e2 & 128 && (r2 = r2 | 8), r2 && i2.tsNames.set(t2, r2);
          }
          isRedeclaredInScope(t2, e2, s2) {
            let i2 = t2.tsNames.get(e2);
            if ((i2 & 2) > 0) {
              if (s2 & 256) {
                let r2 = !!(s2 & 512), n2 = (i2 & 4) > 0;
                return r2 !== n2;
              }
              return true;
            }
            return s2 & 128 && (i2 & 8) > 0 ? t2.names.get(e2) & 2 ? !!(s2 & 1) : false : s2 & 2 && (i2 & 1) > 0 ? true : super.isRedeclaredInScope(t2, e2, s2);
          }
          checkLocalExport(t2) {
            let { name: e2 } = t2;
            if (this.hasImport(e2))
              return;
            let s2 = this.scopeStack.length;
            for (let i2 = s2 - 1; i2 >= 0; i2--) {
              let n2 = this.scopeStack[i2].tsNames.get(e2);
              if ((n2 & 1) > 0 || (n2 & 16) > 0)
                return;
            }
            super.checkLocalExport(t2);
          }
        }, Ki2 = (a2, t2) => hasOwnProperty.call(a2, t2) && a2[t2], as = (a2) => a2.type === "ParenthesizedExpression" ? as(a2.expression) : a2, lt3 = class extends nt3 {
          toAssignable(t2, e2 = false) {
            var s2, i2;
            let r2;
            switch ((t2.type === "ParenthesizedExpression" || (s2 = t2.extra) != null && s2.parenthesized) && (r2 = as(t2), e2 ? r2.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(p2.InvalidParenthesizedAssignment, t2) : r2.type !== "MemberExpression" && !this.isOptionalMemberExpression(r2) && this.raise(p2.InvalidParenthesizedAssignment, t2) : this.raise(p2.InvalidParenthesizedAssignment, t2)), t2.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                break;
              case "ObjectExpression":
                t2.type = "ObjectPattern";
                for (let o2 = 0, h2 = t2.properties.length, c2 = h2 - 1; o2 < h2; o2++) {
                  var n2;
                  let l2 = t2.properties[o2], u2 = o2 === c2;
                  this.toAssignableObjectExpressionProp(l2, u2, e2), u2 && l2.type === "RestElement" && (n2 = t2.extra) != null && n2.trailingCommaLoc && this.raise(p2.RestTrailingComma, t2.extra.trailingCommaLoc);
                }
                break;
              case "ObjectProperty": {
                let { key: o2, value: h2 } = t2;
                this.isPrivateName(o2) && this.classScope.usePrivateName(this.getPrivateNameSV(o2), o2.loc.start), this.toAssignable(h2, e2);
                break;
              }
              case "SpreadElement":
                throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
              case "ArrayExpression":
                t2.type = "ArrayPattern", this.toAssignableList(t2.elements, (i2 = t2.extra) == null ? void 0 : i2.trailingCommaLoc, e2);
                break;
              case "AssignmentExpression":
                t2.operator !== "=" && this.raise(p2.MissingEqInAssignment, t2.left.loc.end), t2.type = "AssignmentPattern", delete t2.operator, this.toAssignable(t2.left, e2);
                break;
              case "ParenthesizedExpression":
                this.toAssignable(r2, e2);
                break;
            }
          }
          toAssignableObjectExpressionProp(t2, e2, s2) {
            if (t2.type === "ObjectMethod")
              this.raise(t2.kind === "get" || t2.kind === "set" ? p2.PatternHasAccessor : p2.PatternHasMethod, t2.key);
            else if (t2.type === "SpreadElement") {
              t2.type = "RestElement";
              let i2 = t2.argument;
              this.checkToRestConversion(i2, false), this.toAssignable(i2, s2), e2 || this.raise(p2.RestTrailingComma, t2);
            } else
              this.toAssignable(t2, s2);
          }
          toAssignableList(t2, e2, s2) {
            let i2 = t2.length - 1;
            for (let r2 = 0; r2 <= i2; r2++) {
              let n2 = t2[r2];
              if (n2) {
                if (n2.type === "SpreadElement") {
                  n2.type = "RestElement";
                  let o2 = n2.argument;
                  this.checkToRestConversion(o2, true), this.toAssignable(o2, s2);
                } else
                  this.toAssignable(n2, s2);
                n2.type === "RestElement" && (r2 < i2 ? this.raise(p2.RestTrailingComma, n2) : e2 && this.raise(p2.RestTrailingComma, e2));
              }
            }
          }
          isAssignable(t2, e2) {
            switch (t2.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                return true;
              case "ObjectExpression": {
                let s2 = t2.properties.length - 1;
                return t2.properties.every((i2, r2) => i2.type !== "ObjectMethod" && (r2 === s2 || i2.type !== "SpreadElement") && this.isAssignable(i2));
              }
              case "ObjectProperty":
                return this.isAssignable(t2.value);
              case "SpreadElement":
                return this.isAssignable(t2.argument);
              case "ArrayExpression":
                return t2.elements.every((s2) => s2 === null || this.isAssignable(s2));
              case "AssignmentExpression":
                return t2.operator === "=";
              case "ParenthesizedExpression":
                return this.isAssignable(t2.expression);
              case "MemberExpression":
              case "OptionalMemberExpression":
                return !e2;
              default:
                return false;
            }
          }
          toReferencedList(t2, e2) {
            return t2;
          }
          toReferencedListDeep(t2, e2) {
            this.toReferencedList(t2, e2);
            for (let s2 of t2)
              (s2 == null ? void 0 : s2.type) === "ArrayExpression" && this.toReferencedListDeep(s2.elements);
          }
          parseSpread(t2) {
            let e2 = this.startNode();
            return this.next(), e2.argument = this.parseMaybeAssignAllowIn(t2, void 0), this.finishNode(e2, "SpreadElement");
          }
          parseRestBinding() {
            let t2 = this.startNode();
            return this.next(), t2.argument = this.parseBindingAtom(), this.finishNode(t2, "RestElement");
          }
          parseBindingAtom() {
            switch (this.state.type) {
              case 0: {
                let t2 = this.startNode();
                return this.next(), t2.elements = this.parseBindingList(3, 93, 1), this.finishNode(t2, "ArrayPattern");
              }
              case 5:
                return this.parseObjectLike(8, true);
            }
            return this.parseIdentifier();
          }
          parseBindingList(t2, e2, s2) {
            let i2 = s2 & 1, r2 = [], n2 = true;
            for (; !this.eat(t2); )
              if (n2 ? n2 = false : this.expect(12), i2 && this.match(12))
                r2.push(null);
              else {
                if (this.eat(t2))
                  break;
                if (this.match(21)) {
                  if (r2.push(this.parseAssignableListItemTypes(this.parseRestBinding(), s2)), !this.checkCommaAfterRest(e2)) {
                    this.expect(t2);
                    break;
                  }
                } else {
                  let o2 = [];
                  for (this.match(26) && this.hasPlugin("decorators") && this.raise(p2.UnsupportedParameterDecorator, this.state.startLoc); this.match(26); )
                    o2.push(this.parseDecorator());
                  r2.push(this.parseAssignableListItem(s2, o2));
                }
              }
            return r2;
          }
          parseBindingRestProperty(t2) {
            return this.next(), t2.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(t2, "RestElement");
          }
          parseBindingProperty() {
            let { type: t2, startLoc: e2 } = this.state;
            if (t2 === 21)
              return this.parseBindingRestProperty(this.startNode());
            let s2 = this.startNode();
            return t2 === 138 ? (this.expectPlugin("destructuringPrivate", e2), this.classScope.usePrivateName(this.state.value, e2), s2.key = this.parsePrivateName()) : this.parsePropertyName(s2), s2.method = false, this.parseObjPropValue(s2, e2, false, false, true, false);
          }
          parseAssignableListItem(t2, e2) {
            let s2 = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(s2, t2);
            let i2 = this.parseMaybeDefault(s2.loc.start, s2);
            return e2.length && (s2.decorators = e2), i2;
          }
          parseAssignableListItemTypes(t2, e2) {
            return t2;
          }
          parseMaybeDefault(t2, e2) {
            var s2, i2;
            if ((s2 = t2) != null || (t2 = this.state.startLoc), e2 = (i2 = e2) != null ? i2 : this.parseBindingAtom(), !this.eat(29))
              return e2;
            let r2 = this.startNodeAt(t2);
            return r2.left = e2, r2.right = this.parseMaybeAssignAllowIn(), this.finishNode(r2, "AssignmentPattern");
          }
          isValidLVal(t2, e2, s2) {
            return Ki2({ AssignmentPattern: "left", RestElement: "argument", ObjectProperty: "value", ParenthesizedExpression: "expression", ArrayPattern: "elements", ObjectPattern: "properties" }, t2);
          }
          isOptionalMemberExpression(t2) {
            return t2.type === "OptionalMemberExpression";
          }
          checkLVal(t2, { in: e2, binding: s2 = 64, checkClashes: i2 = false, strictModeChanged: r2 = false, hasParenthesizedAncestor: n2 = false }) {
            var o2;
            let h2 = t2.type;
            if (this.isObjectMethod(t2))
              return;
            let c2 = this.isOptionalMemberExpression(t2);
            if (c2 || h2 === "MemberExpression") {
              c2 && (this.expectPlugin("optionalChainingAssign", t2.loc.start), e2.type !== "AssignmentExpression" && this.raise(p2.InvalidLhsOptionalChaining, t2, { ancestor: e2 })), s2 !== 64 && this.raise(p2.InvalidPropertyBindingPattern, t2);
              return;
            }
            if (h2 === "Identifier") {
              this.checkIdentifier(t2, s2, r2);
              let { name: y3 } = t2;
              i2 && (i2.has(y3) ? this.raise(p2.ParamDupe, t2) : i2.add(y3));
              return;
            }
            let l2 = this.isValidLVal(h2, !(n2 || (o2 = t2.extra) != null && o2.parenthesized) && e2.type === "AssignmentExpression", s2);
            if (l2 === true)
              return;
            if (l2 === false) {
              let y3 = s2 === 64 ? p2.InvalidLhs : p2.InvalidLhsBinding;
              this.raise(y3, t2, { ancestor: e2 });
              return;
            }
            let [u2, f2] = Array.isArray(l2) ? l2 : [l2, h2 === "ParenthesizedExpression"], d2 = h2 === "ArrayPattern" || h2 === "ObjectPattern" ? { type: h2 } : e2;
            for (let y3 of [].concat(t2[u2]))
              y3 && this.checkLVal(y3, { in: d2, binding: s2, checkClashes: i2, strictModeChanged: r2, hasParenthesizedAncestor: f2 });
          }
          checkIdentifier(t2, e2, s2 = false) {
            this.state.strict && (s2 ? Zt(t2.name, this.inModule) : Qt2(t2.name)) && (e2 === 64 ? this.raise(p2.StrictEvalArguments, t2, { referenceName: t2.name }) : this.raise(p2.StrictEvalArgumentsBinding, t2, { bindingName: t2.name })), e2 & 8192 && t2.name === "let" && this.raise(p2.LetInLexicalBinding, t2), e2 & 64 || this.declareNameFromIdentifier(t2, e2);
          }
          declareNameFromIdentifier(t2, e2) {
            this.scope.declareName(t2.name, e2, t2.loc.start);
          }
          checkToRestConversion(t2, e2) {
            switch (t2.type) {
              case "ParenthesizedExpression":
                this.checkToRestConversion(t2.expression, e2);
                break;
              case "Identifier":
              case "MemberExpression":
                break;
              case "ArrayExpression":
              case "ObjectExpression":
                if (e2)
                  break;
              default:
                this.raise(p2.InvalidRestAssignmentPattern, t2);
            }
          }
          checkCommaAfterRest(t2) {
            return this.match(12) ? (this.raise(this.lookaheadCharCode() === t2 ? p2.RestTrailingComma : p2.ElementAfterRest, this.state.startLoc), true) : false;
          }
        }, Hi = (a2, t2) => hasOwnProperty.call(a2, t2) && a2[t2];
        function Wi(a2) {
          if (a2 == null)
            throw new Error(`Unexpected ${a2} value.`);
          return a2;
        }
        function jt2(a2) {
          if (!a2)
            throw new Error("Assert fail");
        }
        var x2 = j2`typescript`({ AbstractMethodHasImplementation: ({ methodName: a2 }) => `Method '${a2}' cannot have an implementation because it is marked abstract.`, AbstractPropertyHasInitializer: ({ propertyName: a2 }) => `Property '${a2}' cannot have an initializer because it is marked abstract.`, AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: ({ kind: a2 }) => `'declare' is not allowed in ${a2}ters.`, DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: ({ modifier: a2 }) => "Accessibility modifier already seen.", DuplicateModifier: ({ modifier: a2 }) => `Duplicate modifier: '${a2}'.`, EmptyHeritageClauseType: ({ token: a2 }) => `'${a2}' list cannot be empty.`, EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier", IncompatibleModifiers: ({ modifiers: a2 }) => `'${a2[0]}' modifier cannot be used with '${a2[1]}' modifier.`, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: ({ modifier: a2 }) => `Index signatures cannot have an accessibility modifier ('${a2}').`, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.", InvalidModifierOnTypeMember: ({ modifier: a2 }) => `'${a2}' modifier cannot appear on a type member.`, InvalidModifierOnTypeParameter: ({ modifier: a2 }) => `'${a2}' modifier cannot appear on a type parameter.`, InvalidModifierOnTypeParameterPositions: ({ modifier: a2 }) => `'${a2}' modifier can only appear on a type parameter of a class, interface or type alias.`, InvalidModifiersOrder: ({ orderedModifiers: a2 }) => `'${a2[0]}' modifier must precede '${a2[1]}' modifier.`, InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: ({ modifier: a2 }) => `Private elements cannot have an accessibility modifier ('${a2}').`, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.", ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: a2 }) => `Single type parameter ${a2} should have a trailing comma. Example usage: <${a2},>.`, StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: ({ type: a2 }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${a2}.` });
        function Ji(a2) {
          switch (a2) {
            case "any":
              return "TSAnyKeyword";
            case "boolean":
              return "TSBooleanKeyword";
            case "bigint":
              return "TSBigIntKeyword";
            case "never":
              return "TSNeverKeyword";
            case "number":
              return "TSNumberKeyword";
            case "object":
              return "TSObjectKeyword";
            case "string":
              return "TSStringKeyword";
            case "symbol":
              return "TSSymbolKeyword";
            case "undefined":
              return "TSUndefinedKeyword";
            case "unknown":
              return "TSUnknownKeyword";
            default:
              return;
          }
        }
        function $t2(a2) {
          return a2 === "private" || a2 === "public" || a2 === "protected";
        }
        function Xi2(a2) {
          return a2 === "in" || a2 === "out";
        }
        var Gi = (a2) => class extends a2 {
          constructor(...e2) {
            super(...e2), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out"], disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: x2.InvalidModifierOnTypeParameter }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, { allowedModifiers: ["const"], disallowedModifiers: ["in", "out"], errorTemplate: x2.InvalidModifierOnTypeParameterPositions }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out", "const"], disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: x2.InvalidModifierOnTypeParameter });
          }
          getScopeHandler() {
            return ht3;
          }
          tsIsIdentifier() {
            return w2(this.state.type);
          }
          tsTokenCanFollowModifier() {
            return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
          }
          tsNextTokenCanFollowModifier() {
            return this.next(), this.tsTokenCanFollowModifier();
          }
          tsParseModifier(e2, s2) {
            if (!w2(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
              return;
            let i2 = this.state.value;
            if (e2.includes(i2)) {
              if (s2 && this.tsIsStartOfStaticBlocks())
                return;
              if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
                return i2;
            }
          }
          tsParseModifiers({ allowedModifiers: e2, disallowedModifiers: s2, stopOnStartOfClassStaticBlock: i2, errorTemplate: r2 = x2.InvalidModifierOnTypeMember }, n2) {
            let o2 = (c2, l2, u2, f2) => {
              l2 === u2 && n2[f2] && this.raise(x2.InvalidModifiersOrder, c2, { orderedModifiers: [u2, f2] });
            }, h2 = (c2, l2, u2, f2) => {
              (n2[u2] && l2 === f2 || n2[f2] && l2 === u2) && this.raise(x2.IncompatibleModifiers, c2, { modifiers: [u2, f2] });
            };
            for (; ; ) {
              let { startLoc: c2 } = this.state, l2 = this.tsParseModifier(e2.concat(s2 ?? []), i2);
              if (!l2)
                break;
              $t2(l2) ? n2.accessibility ? this.raise(x2.DuplicateAccessibilityModifier, c2, { modifier: l2 }) : (o2(c2, l2, l2, "override"), o2(c2, l2, l2, "static"), o2(c2, l2, l2, "readonly"), n2.accessibility = l2) : Xi2(l2) ? (n2[l2] && this.raise(x2.DuplicateModifier, c2, { modifier: l2 }), n2[l2] = true, o2(c2, l2, "in", "out")) : (hasOwnProperty.call(n2, l2) ? this.raise(x2.DuplicateModifier, c2, { modifier: l2 }) : (o2(c2, l2, "static", "readonly"), o2(c2, l2, "static", "override"), o2(c2, l2, "override", "readonly"), o2(c2, l2, "abstract", "override"), h2(c2, l2, "declare", "override"), h2(c2, l2, "static", "abstract")), n2[l2] = true), s2 != null && s2.includes(l2) && this.raise(r2, c2, { modifier: l2 });
            }
          }
          tsIsListTerminator(e2) {
            switch (e2) {
              case "EnumMembers":
              case "TypeMembers":
                return this.match(8);
              case "HeritageClauseElement":
                return this.match(5);
              case "TupleElementTypes":
                return this.match(3);
              case "TypeParametersOrArguments":
                return this.match(48);
            }
          }
          tsParseList(e2, s2) {
            let i2 = [];
            for (; !this.tsIsListTerminator(e2); )
              i2.push(s2());
            return i2;
          }
          tsParseDelimitedList(e2, s2, i2) {
            return Wi(this.tsParseDelimitedListWorker(e2, s2, true, i2));
          }
          tsParseDelimitedListWorker(e2, s2, i2, r2) {
            let n2 = [], o2 = -1;
            for (; !this.tsIsListTerminator(e2); ) {
              o2 = -1;
              let h2 = s2();
              if (h2 == null)
                return;
              if (n2.push(h2), this.eat(12)) {
                o2 = this.state.lastTokStartLoc.index;
                continue;
              }
              if (this.tsIsListTerminator(e2))
                break;
              i2 && this.expect(12);
              return;
            }
            return r2 && (r2.value = o2), n2;
          }
          tsParseBracketedList(e2, s2, i2, r2, n2) {
            r2 || (i2 ? this.expect(0) : this.expect(47));
            let o2 = this.tsParseDelimitedList(e2, s2, n2);
            return i2 ? this.expect(3) : this.expect(48), o2;
          }
          tsParseImportType() {
            let e2 = this.startNode();
            return this.expect(83), this.expect(10), this.match(133) || this.raise(x2.UnsupportedImportTypeArgument, this.state.startLoc), e2.argument = super.parseExprAtom(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (e2.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (e2.options = super.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11), this.eat(16) && (e2.qualifier = this.tsParseEntityName()), this.match(47) && (e2.typeParameters = this.tsParseTypeArguments()), this.finishNode(e2, "TSImportType");
          }
          tsParseEntityName(e2 = true) {
            let s2 = this.parseIdentifier(e2);
            for (; this.eat(16); ) {
              let i2 = this.startNodeAtNode(s2);
              i2.left = s2, i2.right = this.parseIdentifier(e2), s2 = this.finishNode(i2, "TSQualifiedName");
            }
            return s2;
          }
          tsParseTypeReference() {
            let e2 = this.startNode();
            return e2.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e2.typeParameters = this.tsParseTypeArguments()), this.finishNode(e2, "TSTypeReference");
          }
          tsParseThisTypePredicate(e2) {
            this.next();
            let s2 = this.startNodeAtNode(e2);
            return s2.parameterName = e2, s2.typeAnnotation = this.tsParseTypeAnnotation(false), s2.asserts = false, this.finishNode(s2, "TSTypePredicate");
          }
          tsParseThisTypeNode() {
            let e2 = this.startNode();
            return this.next(), this.finishNode(e2, "TSThisType");
          }
          tsParseTypeQuery() {
            let e2 = this.startNode();
            return this.expect(87), this.match(83) ? e2.exprName = this.tsParseImportType() : e2.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e2.typeParameters = this.tsParseTypeArguments()), this.finishNode(e2, "TSTypeQuery");
          }
          tsParseTypeParameter(e2) {
            let s2 = this.startNode();
            return e2(s2), s2.name = this.tsParseTypeParameterName(), s2.constraint = this.tsEatThenParseType(81), s2.default = this.tsEatThenParseType(29), this.finishNode(s2, "TSTypeParameter");
          }
          tsTryParseTypeParameters(e2) {
            if (this.match(47))
              return this.tsParseTypeParameters(e2);
          }
          tsParseTypeParameters(e2) {
            let s2 = this.startNode();
            this.match(47) || this.match(142) ? this.next() : this.unexpected();
            let i2 = { value: -1 };
            return s2.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, e2), false, true, i2), s2.params.length === 0 && this.raise(x2.EmptyTypeParameters, s2), i2.value !== -1 && this.addExtra(s2, "trailingComma", i2.value), this.finishNode(s2, "TSTypeParameterDeclaration");
          }
          tsFillSignature(e2, s2) {
            let i2 = e2 === 19, r2 = "parameters", n2 = "typeAnnotation";
            s2.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), s2[r2] = this.tsParseBindingListForSignature(), i2 ? s2[n2] = this.tsParseTypeOrTypePredicateAnnotation(e2) : this.match(e2) && (s2[n2] = this.tsParseTypeOrTypePredicateAnnotation(e2));
          }
          tsParseBindingListForSignature() {
            let e2 = super.parseBindingList(11, 41, 2);
            for (let s2 of e2) {
              let { type: i2 } = s2;
              (i2 === "AssignmentPattern" || i2 === "TSParameterProperty") && this.raise(x2.UnsupportedSignatureParameterKind, s2, { type: i2 });
            }
            return e2;
          }
          tsParseTypeMemberSemicolon() {
            !this.eat(12) && !this.isLineTerminator() && this.expect(13);
          }
          tsParseSignatureMember(e2, s2) {
            return this.tsFillSignature(14, s2), this.tsParseTypeMemberSemicolon(), this.finishNode(s2, e2);
          }
          tsIsUnambiguouslyIndexSignature() {
            return this.next(), w2(this.state.type) ? (this.next(), this.match(14)) : false;
          }
          tsTryParseIndexSignature(e2) {
            if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
              return;
            this.expect(0);
            let s2 = this.parseIdentifier();
            s2.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(s2), this.expect(3), e2.parameters = [s2];
            let i2 = this.tsTryParseTypeAnnotation();
            return i2 && (e2.typeAnnotation = i2), this.tsParseTypeMemberSemicolon(), this.finishNode(e2, "TSIndexSignature");
          }
          tsParsePropertyOrMethodSignature(e2, s2) {
            this.eat(17) && (e2.optional = true);
            let i2 = e2;
            if (this.match(10) || this.match(47)) {
              s2 && this.raise(x2.ReadonlyForMethodSignature, e2);
              let r2 = i2;
              r2.kind && this.match(47) && this.raise(x2.AccesorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, r2), this.tsParseTypeMemberSemicolon();
              let n2 = "parameters", o2 = "typeAnnotation";
              if (r2.kind === "get")
                r2[n2].length > 0 && (this.raise(p2.BadGetterArity, this.state.curPosition()), this.isThisParam(r2[n2][0]) && this.raise(x2.AccesorCannotDeclareThisParameter, this.state.curPosition()));
              else if (r2.kind === "set") {
                if (r2[n2].length !== 1)
                  this.raise(p2.BadSetterArity, this.state.curPosition());
                else {
                  let h2 = r2[n2][0];
                  this.isThisParam(h2) && this.raise(x2.AccesorCannotDeclareThisParameter, this.state.curPosition()), h2.type === "Identifier" && h2.optional && this.raise(x2.SetAccesorCannotHaveOptionalParameter, this.state.curPosition()), h2.type === "RestElement" && this.raise(x2.SetAccesorCannotHaveRestParameter, this.state.curPosition());
                }
                r2[o2] && this.raise(x2.SetAccesorCannotHaveReturnType, r2[o2]);
              } else
                r2.kind = "method";
              return this.finishNode(r2, "TSMethodSignature");
            } else {
              let r2 = i2;
              s2 && (r2.readonly = true);
              let n2 = this.tsTryParseTypeAnnotation();
              return n2 && (r2.typeAnnotation = n2), this.tsParseTypeMemberSemicolon(), this.finishNode(r2, "TSPropertySignature");
            }
          }
          tsParseTypeMember() {
            let e2 = this.startNode();
            if (this.match(10) || this.match(47))
              return this.tsParseSignatureMember("TSCallSignatureDeclaration", e2);
            if (this.match(77)) {
              let i2 = this.startNode();
              return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", e2) : (e2.key = this.createIdentifier(i2, "new"), this.tsParsePropertyOrMethodSignature(e2, false));
            }
            this.tsParseModifiers({ allowedModifiers: ["readonly"], disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"] }, e2);
            let s2 = this.tsTryParseIndexSignature(e2);
            return s2 || (super.parsePropertyName(e2), !e2.computed && e2.key.type === "Identifier" && (e2.key.name === "get" || e2.key.name === "set") && this.tsTokenCanFollowModifier() && (e2.kind = e2.key.name, super.parsePropertyName(e2)), this.tsParsePropertyOrMethodSignature(e2, !!e2.readonly));
          }
          tsParseTypeLiteral() {
            let e2 = this.startNode();
            return e2.members = this.tsParseObjectTypeMembers(), this.finishNode(e2, "TSTypeLiteral");
          }
          tsParseObjectTypeMembers() {
            this.expect(5);
            let e2 = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
            return this.expect(8), e2;
          }
          tsIsStartOfMappedType() {
            return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? false : (this.next(), this.match(58)));
          }
          tsParseMappedTypeParameter() {
            let e2 = this.startNode();
            return e2.name = this.tsParseTypeParameterName(), e2.constraint = this.tsExpectThenParseType(58), this.finishNode(e2, "TSTypeParameter");
          }
          tsParseMappedType() {
            let e2 = this.startNode();
            return this.expect(5), this.match(53) ? (e2.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) && (e2.readonly = true), this.expect(0), e2.typeParameter = this.tsParseMappedTypeParameter(), e2.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (e2.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (e2.optional = true), e2.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(e2, "TSMappedType");
          }
          tsParseTupleType() {
            let e2 = this.startNode();
            e2.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
            let s2 = false;
            return e2.elementTypes.forEach((i2) => {
              let { type: r2 } = i2;
              s2 && r2 !== "TSRestType" && r2 !== "TSOptionalType" && !(r2 === "TSNamedTupleMember" && i2.optional) && this.raise(x2.OptionalTypeBeforeRequired, i2), s2 || (s2 = r2 === "TSNamedTupleMember" && i2.optional || r2 === "TSOptionalType");
            }), this.finishNode(e2, "TSTupleType");
          }
          tsParseTupleElementType() {
            let { startLoc: e2 } = this.state, s2 = this.eat(21), i2, r2, n2, o2, c2 = M3(this.state.type) ? this.lookaheadCharCode() : null;
            if (c2 === 58)
              i2 = true, n2 = false, r2 = this.parseIdentifier(true), this.expect(14), o2 = this.tsParseType();
            else if (c2 === 63) {
              n2 = true;
              let l2 = this.state.startLoc, u2 = this.state.value, f2 = this.tsParseNonArrayType();
              this.lookaheadCharCode() === 58 ? (i2 = true, r2 = this.createIdentifier(this.startNodeAt(l2), u2), this.expect(17), this.expect(14), o2 = this.tsParseType()) : (i2 = false, o2 = f2, this.expect(17));
            } else
              o2 = this.tsParseType(), n2 = this.eat(17), i2 = this.eat(14);
            if (i2) {
              let l2;
              r2 ? (l2 = this.startNodeAtNode(r2), l2.optional = n2, l2.label = r2, l2.elementType = o2, this.eat(17) && (l2.optional = true, this.raise(x2.TupleOptionalAfterType, this.state.lastTokStartLoc))) : (l2 = this.startNodeAtNode(o2), l2.optional = n2, this.raise(x2.InvalidTupleMemberLabel, o2), l2.label = o2, l2.elementType = this.tsParseType()), o2 = this.finishNode(l2, "TSNamedTupleMember");
            } else if (n2) {
              let l2 = this.startNodeAtNode(o2);
              l2.typeAnnotation = o2, o2 = this.finishNode(l2, "TSOptionalType");
            }
            if (s2) {
              let l2 = this.startNodeAt(e2);
              l2.typeAnnotation = o2, o2 = this.finishNode(l2, "TSRestType");
            }
            return o2;
          }
          tsParseParenthesizedType() {
            let e2 = this.startNode();
            return this.expect(10), e2.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(e2, "TSParenthesizedType");
          }
          tsParseFunctionOrConstructorType(e2, s2) {
            let i2 = this.startNode();
            return e2 === "TSConstructorType" && (i2.abstract = !!s2, s2 && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, i2)), this.finishNode(i2, e2);
          }
          tsParseLiteralTypeNode() {
            let e2 = this.startNode();
            switch (this.state.type) {
              case 134:
              case 135:
              case 133:
              case 85:
              case 86:
                e2.literal = super.parseExprAtom();
                break;
              default:
                this.unexpected();
            }
            return this.finishNode(e2, "TSLiteralType");
          }
          tsParseTemplateLiteralType() {
            let e2 = this.startNode();
            return e2.literal = super.parseTemplate(false), this.finishNode(e2, "TSLiteralType");
          }
          parseTemplateSubstitution() {
            return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
          }
          tsParseThisTypeOrThisTypePredicate() {
            let e2 = this.tsParseThisTypeNode();
            return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e2) : e2;
          }
          tsParseNonArrayType() {
            switch (this.state.type) {
              case 133:
              case 134:
              case 135:
              case 85:
              case 86:
                return this.tsParseLiteralTypeNode();
              case 53:
                if (this.state.value === "-") {
                  let e2 = this.startNode(), s2 = this.lookahead();
                  return s2.type !== 134 && s2.type !== 135 && this.unexpected(), e2.literal = this.parseMaybeUnary(), this.finishNode(e2, "TSLiteralType");
                }
                break;
              case 78:
                return this.tsParseThisTypeOrThisTypePredicate();
              case 87:
                return this.tsParseTypeQuery();
              case 83:
                return this.tsParseImportType();
              case 5:
                return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
              case 0:
                return this.tsParseTupleType();
              case 10:
                return this.tsParseParenthesizedType();
              case 25:
              case 24:
                return this.tsParseTemplateLiteralType();
              default: {
                let { type: e2 } = this.state;
                if (w2(e2) || e2 === 88 || e2 === 84) {
                  let s2 = e2 === 88 ? "TSVoidKeyword" : e2 === 84 ? "TSNullKeyword" : Ji(this.state.value);
                  if (s2 !== void 0 && this.lookaheadCharCode() !== 46) {
                    let i2 = this.startNode();
                    return this.next(), this.finishNode(i2, s2);
                  }
                  return this.tsParseTypeReference();
                }
              }
            }
            this.unexpected();
          }
          tsParseArrayTypeOrHigher() {
            let e2 = this.tsParseNonArrayType();
            for (; !this.hasPrecedingLineBreak() && this.eat(0); )
              if (this.match(3)) {
                let s2 = this.startNodeAtNode(e2);
                s2.elementType = e2, this.expect(3), e2 = this.finishNode(s2, "TSArrayType");
              } else {
                let s2 = this.startNodeAtNode(e2);
                s2.objectType = e2, s2.indexType = this.tsParseType(), this.expect(3), e2 = this.finishNode(s2, "TSIndexedAccessType");
              }
            return e2;
          }
          tsParseTypeOperator() {
            let e2 = this.startNode(), s2 = this.state.value;
            return this.next(), e2.operator = s2, e2.typeAnnotation = this.tsParseTypeOperatorOrHigher(), s2 === "readonly" && this.tsCheckTypeAnnotationForReadOnly(e2), this.finishNode(e2, "TSTypeOperator");
          }
          tsCheckTypeAnnotationForReadOnly(e2) {
            switch (e2.typeAnnotation.type) {
              case "TSTupleType":
              case "TSArrayType":
                return;
              default:
                this.raise(x2.UnexpectedReadonly, e2);
            }
          }
          tsParseInferType() {
            let e2 = this.startNode();
            this.expectContextual(115);
            let s2 = this.startNode();
            return s2.name = this.tsParseTypeParameterName(), s2.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), e2.typeParameter = this.finishNode(s2, "TSTypeParameter"), this.finishNode(e2, "TSInferType");
          }
          tsParseConstraintForInferType() {
            if (this.eat(81)) {
              let e2 = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
              if (this.state.inDisallowConditionalTypesContext || !this.match(17))
                return e2;
            }
          }
          tsParseTypeOperatorOrHigher() {
            return di2(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
          }
          tsParseUnionOrIntersectionType(e2, s2, i2) {
            let r2 = this.startNode(), n2 = this.eat(i2), o2 = [];
            do
              o2.push(s2());
            while (this.eat(i2));
            return o2.length === 1 && !n2 ? o2[0] : (r2.types = o2, this.finishNode(r2, e2));
          }
          tsParseIntersectionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
          }
          tsParseUnionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
          }
          tsIsStartOfFunctionType() {
            return this.match(47) ? true : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
          }
          tsSkipParameterStart() {
            if (w2(this.state.type) || this.match(78))
              return this.next(), true;
            if (this.match(5)) {
              let { errors: e2 } = this.state, s2 = e2.length;
              try {
                return this.parseObjectLike(8, true), e2.length === s2;
              } catch {
                return false;
              }
            }
            if (this.match(0)) {
              this.next();
              let { errors: e2 } = this.state, s2 = e2.length;
              try {
                return super.parseBindingList(3, 93, 1), e2.length === s2;
              } catch {
                return false;
              }
            }
            return false;
          }
          tsIsUnambiguouslyStartOfFunctionType() {
            return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
          }
          tsParseTypeOrTypePredicateAnnotation(e2) {
            return this.tsInType(() => {
              let s2 = this.startNode();
              this.expect(e2);
              let i2 = this.startNode(), r2 = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
              if (r2 && this.match(78)) {
                let h2 = this.tsParseThisTypeOrThisTypePredicate();
                return h2.type === "TSThisType" ? (i2.parameterName = h2, i2.asserts = true, i2.typeAnnotation = null, h2 = this.finishNode(i2, "TSTypePredicate")) : (this.resetStartLocationFromNode(h2, i2), h2.asserts = true), s2.typeAnnotation = h2, this.finishNode(s2, "TSTypeAnnotation");
              }
              let n2 = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
              if (!n2)
                return r2 ? (i2.parameterName = this.parseIdentifier(), i2.asserts = r2, i2.typeAnnotation = null, s2.typeAnnotation = this.finishNode(i2, "TSTypePredicate"), this.finishNode(s2, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, s2);
              let o2 = this.tsParseTypeAnnotation(false);
              return i2.parameterName = n2, i2.typeAnnotation = o2, i2.asserts = r2, s2.typeAnnotation = this.finishNode(i2, "TSTypePredicate"), this.finishNode(s2, "TSTypeAnnotation");
            });
          }
          tsTryParseTypeOrTypePredicateAnnotation() {
            if (this.match(14))
              return this.tsParseTypeOrTypePredicateAnnotation(14);
          }
          tsTryParseTypeAnnotation() {
            if (this.match(14))
              return this.tsParseTypeAnnotation();
          }
          tsTryParseType() {
            return this.tsEatThenParseType(14);
          }
          tsParseTypePredicatePrefix() {
            let e2 = this.parseIdentifier();
            if (this.isContextual(116) && !this.hasPrecedingLineBreak())
              return this.next(), e2;
          }
          tsParseTypePredicateAsserts() {
            if (this.state.type !== 109)
              return false;
            let e2 = this.state.containsEsc;
            return this.next(), !w2(this.state.type) && !this.match(78) ? false : (e2 && this.raise(p2.InvalidEscapedReservedWord, this.state.lastTokStartLoc, { reservedWord: "asserts" }), true);
          }
          tsParseTypeAnnotation(e2 = true, s2 = this.startNode()) {
            return this.tsInType(() => {
              e2 && this.expect(14), s2.typeAnnotation = this.tsParseType();
            }), this.finishNode(s2, "TSTypeAnnotation");
          }
          tsParseType() {
            jt2(this.state.inType);
            let e2 = this.tsParseNonConditionalType();
            if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
              return e2;
            let s2 = this.startNodeAtNode(e2);
            return s2.checkType = e2, s2.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), s2.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), s2.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(s2, "TSConditionalType");
          }
          isAbstractConstructorSignature() {
            return this.isContextual(124) && this.lookahead().type === 77;
          }
          tsParseNonConditionalType() {
            return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
          }
          tsParseTypeAssertion() {
            this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(x2.ReservedTypeAssertion, this.state.startLoc);
            let e2 = this.startNode();
            return e2.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), e2.expression = this.parseMaybeUnary(), this.finishNode(e2, "TSTypeAssertion");
          }
          tsParseHeritageClause(e2) {
            let s2 = this.state.startLoc, i2 = this.tsParseDelimitedList("HeritageClauseElement", () => {
              let r2 = this.startNode();
              return r2.expression = this.tsParseEntityName(), this.match(47) && (r2.typeParameters = this.tsParseTypeArguments()), this.finishNode(r2, "TSExpressionWithTypeArguments");
            });
            return i2.length || this.raise(x2.EmptyHeritageClauseType, s2, { token: e2 }), i2;
          }
          tsParseInterfaceDeclaration(e2, s2 = {}) {
            if (this.hasFollowingLineBreak())
              return null;
            this.expectContextual(129), s2.declare && (e2.declare = true), w2(this.state.type) ? (e2.id = this.parseIdentifier(), this.checkIdentifier(e2.id, 130)) : (e2.id = null, this.raise(x2.MissingInterfaceName, this.state.startLoc)), e2.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (e2.extends = this.tsParseHeritageClause("extends"));
            let i2 = this.startNode();
            return i2.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), e2.body = this.finishNode(i2, "TSInterfaceBody"), this.finishNode(e2, "TSInterfaceDeclaration");
          }
          tsParseTypeAliasDeclaration(e2) {
            return e2.id = this.parseIdentifier(), this.checkIdentifier(e2.id, 2), e2.typeAnnotation = this.tsInType(() => {
              if (e2.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().type !== 16) {
                let s2 = this.startNode();
                return this.next(), this.finishNode(s2, "TSIntrinsicKeyword");
              }
              return this.tsParseType();
            }), this.semicolon(), this.finishNode(e2, "TSTypeAliasDeclaration");
          }
          tsInNoContext(e2) {
            let s2 = this.state.context;
            this.state.context = [s2[0]];
            try {
              return e2();
            } finally {
              this.state.context = s2;
            }
          }
          tsInType(e2) {
            let s2 = this.state.inType;
            this.state.inType = true;
            try {
              return e2();
            } finally {
              this.state.inType = s2;
            }
          }
          tsInDisallowConditionalTypesContext(e2) {
            let s2 = this.state.inDisallowConditionalTypesContext;
            this.state.inDisallowConditionalTypesContext = true;
            try {
              return e2();
            } finally {
              this.state.inDisallowConditionalTypesContext = s2;
            }
          }
          tsInAllowConditionalTypesContext(e2) {
            let s2 = this.state.inDisallowConditionalTypesContext;
            this.state.inDisallowConditionalTypesContext = false;
            try {
              return e2();
            } finally {
              this.state.inDisallowConditionalTypesContext = s2;
            }
          }
          tsEatThenParseType(e2) {
            if (this.match(e2))
              return this.tsNextThenParseType();
          }
          tsExpectThenParseType(e2) {
            return this.tsInType(() => (this.expect(e2), this.tsParseType()));
          }
          tsNextThenParseType() {
            return this.tsInType(() => (this.next(), this.tsParseType()));
          }
          tsParseEnumMember() {
            let e2 = this.startNode();
            return e2.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true), this.eat(29) && (e2.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(e2, "TSEnumMember");
          }
          tsParseEnumDeclaration(e2, s2 = {}) {
            return s2.const && (e2.const = true), s2.declare && (e2.declare = true), this.expectContextual(126), e2.id = this.parseIdentifier(), this.checkIdentifier(e2.id, e2.const ? 8971 : 8459), this.expect(5), e2.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(e2, "TSEnumDeclaration");
          }
          tsParseModuleBlock() {
            let e2 = this.startNode();
            return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(e2.body = [], void 0, true, 8), this.scope.exit(), this.finishNode(e2, "TSModuleBlock");
          }
          tsParseModuleOrNamespaceDeclaration(e2, s2 = false) {
            if (e2.id = this.parseIdentifier(), s2 || this.checkIdentifier(e2.id, 1024), this.eat(16)) {
              let i2 = this.startNode();
              this.tsParseModuleOrNamespaceDeclaration(i2, true), e2.body = i2;
            } else
              this.scope.enter(256), this.prodParam.enter(0), e2.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
            return this.finishNode(e2, "TSModuleDeclaration");
          }
          tsParseAmbientExternalModuleDeclaration(e2) {
            return this.isContextual(112) ? (e2.global = true, e2.id = this.parseIdentifier()) : this.match(133) ? e2.id = super.parseStringLiteral(this.state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), e2.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e2, "TSModuleDeclaration");
          }
          tsParseImportEqualsDeclaration(e2, s2, i2) {
            e2.isExport = i2 || false, e2.id = s2 || this.parseIdentifier(), this.checkIdentifier(e2.id, 4096), this.expect(29);
            let r2 = this.tsParseModuleReference();
            return e2.importKind === "type" && r2.type !== "TSExternalModuleReference" && this.raise(x2.ImportAliasHasImportType, r2), e2.moduleReference = r2, this.semicolon(), this.finishNode(e2, "TSImportEqualsDeclaration");
          }
          tsIsExternalModuleReference() {
            return this.isContextual(119) && this.lookaheadCharCode() === 40;
          }
          tsParseModuleReference() {
            return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
          }
          tsParseExternalModuleReference() {
            let e2 = this.startNode();
            return this.expectContextual(119), this.expect(10), this.match(133) || this.unexpected(), e2.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = true, this.finishNode(e2, "TSExternalModuleReference");
          }
          tsLookAhead(e2) {
            let s2 = this.state.clone(), i2 = e2();
            return this.state = s2, i2;
          }
          tsTryParseAndCatch(e2) {
            let s2 = this.tryParse((i2) => e2() || i2());
            if (!(s2.aborted || !s2.node))
              return s2.error && (this.state = s2.failState), s2.node;
          }
          tsTryParse(e2) {
            let s2 = this.state.clone(), i2 = e2();
            if (i2 !== void 0 && i2 !== false)
              return i2;
            this.state = s2;
          }
          tsTryParseDeclare(e2) {
            if (this.isLineTerminator())
              return;
            let s2 = this.state.type, i2;
            return this.isContextual(100) && (s2 = 74, i2 = "let"), this.tsInAmbientContext(() => {
              switch (s2) {
                case 68:
                  return e2.declare = true, super.parseFunctionStatement(e2, false, false);
                case 80:
                  return e2.declare = true, this.parseClass(e2, true, false);
                case 126:
                  return this.tsParseEnumDeclaration(e2, { declare: true });
                case 112:
                  return this.tsParseAmbientExternalModuleDeclaration(e2);
                case 75:
                case 74:
                  return !this.match(75) || !this.isLookaheadContextual("enum") ? (e2.declare = true, this.parseVarStatement(e2, i2 || this.state.value, true)) : (this.expect(75), this.tsParseEnumDeclaration(e2, { const: true, declare: true }));
                case 129: {
                  let r2 = this.tsParseInterfaceDeclaration(e2, { declare: true });
                  if (r2)
                    return r2;
                }
                default:
                  if (w2(s2))
                    return this.tsParseDeclaration(e2, this.state.value, true, null);
              }
            });
          }
          tsTryParseExportDeclaration() {
            return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
          }
          tsParseExpressionStatement(e2, s2, i2) {
            switch (s2.name) {
              case "declare": {
                let r2 = this.tsTryParseDeclare(e2);
                return r2 && (r2.declare = true), r2;
              }
              case "global":
                if (this.match(5)) {
                  this.scope.enter(256), this.prodParam.enter(0);
                  let r2 = e2;
                  return r2.global = true, r2.id = s2, r2.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(r2, "TSModuleDeclaration");
                }
                break;
              default:
                return this.tsParseDeclaration(e2, s2.name, false, i2);
            }
          }
          tsParseDeclaration(e2, s2, i2, r2) {
            switch (s2) {
              case "abstract":
                if (this.tsCheckLineTerminator(i2) && (this.match(80) || w2(this.state.type)))
                  return this.tsParseAbstractDeclaration(e2, r2);
                break;
              case "module":
                if (this.tsCheckLineTerminator(i2)) {
                  if (this.match(133))
                    return this.tsParseAmbientExternalModuleDeclaration(e2);
                  if (w2(this.state.type))
                    return this.tsParseModuleOrNamespaceDeclaration(e2);
                }
                break;
              case "namespace":
                if (this.tsCheckLineTerminator(i2) && w2(this.state.type))
                  return this.tsParseModuleOrNamespaceDeclaration(e2);
                break;
              case "type":
                if (this.tsCheckLineTerminator(i2) && w2(this.state.type))
                  return this.tsParseTypeAliasDeclaration(e2);
                break;
            }
          }
          tsCheckLineTerminator(e2) {
            return e2 ? this.hasFollowingLineBreak() ? false : (this.next(), true) : !this.isLineTerminator();
          }
          tsTryParseGenericAsyncArrowFunction(e2) {
            if (!this.match(47))
              return;
            let s2 = this.state.maybeInArrowParameters;
            this.state.maybeInArrowParameters = true;
            let i2 = this.tsTryParseAndCatch(() => {
              let r2 = this.startNodeAt(e2);
              return r2.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(r2), r2.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), r2;
            });
            if (this.state.maybeInArrowParameters = s2, !!i2)
              return super.parseArrowExpression(i2, null, true);
          }
          tsParseTypeArgumentsInExpression() {
            if (this.reScan_lt() === 47)
              return this.tsParseTypeArguments();
          }
          tsParseTypeArguments() {
            let e2 = this.startNode();
            return e2.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), e2.params.length === 0 ? this.raise(x2.EmptyTypeArguments, e2) : !this.state.inType && this.curContext() === C.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(e2, "TSTypeParameterInstantiation");
          }
          tsIsDeclarationStart() {
            return mi(this.state.type);
          }
          isExportDefaultSpecifier() {
            return this.tsIsDeclarationStart() ? false : super.isExportDefaultSpecifier();
          }
          parseAssignableListItem(e2, s2) {
            let i2 = this.state.startLoc, r2 = {};
            this.tsParseModifiers({ allowedModifiers: ["public", "private", "protected", "override", "readonly"] }, r2);
            let n2 = r2.accessibility, o2 = r2.override, h2 = r2.readonly;
            !(e2 & 4) && (n2 || h2 || o2) && this.raise(x2.UnexpectedParameterModifier, i2);
            let c2 = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(c2, e2);
            let l2 = this.parseMaybeDefault(c2.loc.start, c2);
            if (n2 || h2 || o2) {
              let u2 = this.startNodeAt(i2);
              return s2.length && (u2.decorators = s2), n2 && (u2.accessibility = n2), h2 && (u2.readonly = h2), o2 && (u2.override = o2), l2.type !== "Identifier" && l2.type !== "AssignmentPattern" && this.raise(x2.UnsupportedParameterPropertyKind, u2), u2.parameter = l2, this.finishNode(u2, "TSParameterProperty");
            }
            return s2.length && (c2.decorators = s2), l2;
          }
          isSimpleParameter(e2) {
            return e2.type === "TSParameterProperty" && super.isSimpleParameter(e2.parameter) || super.isSimpleParameter(e2);
          }
          tsDisallowOptionalPattern(e2) {
            for (let s2 of e2.params)
              s2.type !== "Identifier" && s2.optional && !this.state.isAmbientContext && this.raise(x2.PatternIsOptional, s2);
          }
          setArrowFunctionParameters(e2, s2, i2) {
            super.setArrowFunctionParameters(e2, s2, i2), this.tsDisallowOptionalPattern(e2);
          }
          parseFunctionBodyAndFinish(e2, s2, i2 = false) {
            this.match(14) && (e2.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
            let r2 = s2 === "FunctionDeclaration" ? "TSDeclareFunction" : s2 === "ClassMethod" || s2 === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
            return r2 && !this.match(5) && this.isLineTerminator() ? this.finishNode(e2, r2) : r2 === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(x2.DeclareFunctionHasImplementation, e2), e2.declare) ? super.parseFunctionBodyAndFinish(e2, r2, i2) : (this.tsDisallowOptionalPattern(e2), super.parseFunctionBodyAndFinish(e2, s2, i2));
          }
          registerFunctionStatementId(e2) {
            !e2.body && e2.id ? this.checkIdentifier(e2.id, 1024) : super.registerFunctionStatementId(e2);
          }
          tsCheckForInvalidTypeCasts(e2) {
            e2.forEach((s2) => {
              (s2 == null ? void 0 : s2.type) === "TSTypeCastExpression" && this.raise(x2.UnexpectedTypeAnnotation, s2.typeAnnotation);
            });
          }
          toReferencedList(e2, s2) {
            return this.tsCheckForInvalidTypeCasts(e2), e2;
          }
          parseArrayLike(e2, s2, i2, r2) {
            let n2 = super.parseArrayLike(e2, s2, i2, r2);
            return n2.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(n2.elements), n2;
          }
          parseSubscript(e2, s2, i2, r2) {
            if (!this.hasPrecedingLineBreak() && this.match(35)) {
              this.state.canStartJSXElement = false, this.next();
              let o2 = this.startNodeAt(s2);
              return o2.expression = e2, this.finishNode(o2, "TSNonNullExpression");
            }
            let n2 = false;
            if (this.match(18) && this.lookaheadCharCode() === 60) {
              if (i2)
                return r2.stop = true, e2;
              r2.optionalChainMember = n2 = true, this.next();
            }
            if (this.match(47) || this.match(51)) {
              let o2, h2 = this.tsTryParseAndCatch(() => {
                if (!i2 && this.atPossibleAsyncArrow(e2)) {
                  let f2 = this.tsTryParseGenericAsyncArrowFunction(s2);
                  if (f2)
                    return f2;
                }
                let c2 = this.tsParseTypeArgumentsInExpression();
                if (!c2)
                  return;
                if (n2 && !this.match(10)) {
                  o2 = this.state.curPosition();
                  return;
                }
                if (Le3(this.state.type)) {
                  let f2 = super.parseTaggedTemplateExpression(e2, s2, r2);
                  return f2.typeParameters = c2, f2;
                }
                if (!i2 && this.eat(10)) {
                  let f2 = this.startNodeAt(s2);
                  return f2.callee = e2, f2.arguments = this.parseCallExpressionArguments(11, false), this.tsCheckForInvalidTypeCasts(f2.arguments), f2.typeParameters = c2, r2.optionalChainMember && (f2.optional = n2), this.finishCallExpression(f2, r2.optionalChainMember);
                }
                let l2 = this.state.type;
                if (l2 === 48 || l2 === 52 || l2 !== 10 && He2(l2) && !this.hasPrecedingLineBreak())
                  return;
                let u2 = this.startNodeAt(s2);
                return u2.expression = e2, u2.typeParameters = c2, this.finishNode(u2, "TSInstantiationExpression");
              });
              if (o2 && this.unexpected(o2, 10), h2)
                return h2.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(x2.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), h2;
            }
            return super.parseSubscript(e2, s2, i2, r2);
          }
          parseNewCallee(e2) {
            var s2;
            super.parseNewCallee(e2);
            let { callee: i2 } = e2;
            i2.type === "TSInstantiationExpression" && !((s2 = i2.extra) != null && s2.parenthesized) && (e2.typeParameters = i2.typeParameters, e2.callee = i2.expression);
          }
          parseExprOp(e2, s2, i2) {
            let r2;
            if (Ie3(58) > i2 && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (r2 = this.isContextual(120)))) {
              let n2 = this.startNodeAt(s2);
              return n2.expression = e2, n2.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (r2 && this.raise(p2.UnexpectedKeyword, this.state.startLoc, { keyword: "const" }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(n2, r2 ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(n2, s2, i2);
            }
            return super.parseExprOp(e2, s2, i2);
          }
          checkReservedWord(e2, s2, i2, r2) {
            this.state.isAmbientContext || super.checkReservedWord(e2, s2, i2, r2);
          }
          checkImportReflection(e2) {
            super.checkImportReflection(e2), e2.module && e2.importKind !== "value" && this.raise(x2.ImportReflectionHasImportType, e2.specifiers[0].loc.start);
          }
          checkDuplicateExports() {
          }
          isPotentialImportPhase(e2) {
            if (super.isPotentialImportPhase(e2))
              return true;
            if (this.isContextual(130)) {
              let s2 = this.lookaheadCharCode();
              return e2 ? s2 === 123 || s2 === 42 : s2 !== 61;
            }
            return !e2 && this.isContextual(87);
          }
          applyImportPhase(e2, s2, i2, r2) {
            super.applyImportPhase(e2, s2, i2, r2), s2 ? e2.exportKind = i2 === "type" ? "type" : "value" : e2.importKind = i2 === "type" || i2 === "typeof" ? i2 : "value";
          }
          parseImport(e2) {
            if (this.match(133))
              return e2.importKind = "value", super.parseImport(e2);
            let s2;
            if (w2(this.state.type) && this.lookaheadCharCode() === 61)
              return e2.importKind = "value", this.tsParseImportEqualsDeclaration(e2);
            if (this.isContextual(130)) {
              let i2 = this.parseMaybeImportPhase(e2, false);
              if (this.lookaheadCharCode() === 61)
                return this.tsParseImportEqualsDeclaration(e2, i2);
              s2 = super.parseImportSpecifiersAndAfter(e2, i2);
            } else
              s2 = super.parseImport(e2);
            return s2.importKind === "type" && s2.specifiers.length > 1 && s2.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(x2.TypeImportCannotSpecifyDefaultAndNamed, s2), s2;
          }
          parseExport(e2, s2) {
            if (this.match(83)) {
              this.next();
              let i2 = e2, r2 = null;
              return this.isContextual(130) && this.isPotentialImportPhase(false) ? r2 = this.parseMaybeImportPhase(i2, false) : i2.importKind = "value", this.tsParseImportEqualsDeclaration(i2, r2, true);
            } else if (this.eat(29)) {
              let i2 = e2;
              return i2.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = true, this.finishNode(i2, "TSExportAssignment");
            } else if (this.eatContextual(93)) {
              let i2 = e2;
              return this.expectContextual(128), i2.id = this.parseIdentifier(), this.semicolon(), this.finishNode(i2, "TSNamespaceExportDeclaration");
            } else
              return super.parseExport(e2, s2);
          }
          isAbstractClass() {
            return this.isContextual(124) && this.lookahead().type === 80;
          }
          parseExportDefaultExpression() {
            if (this.isAbstractClass()) {
              let e2 = this.startNode();
              return this.next(), e2.abstract = true, this.parseClass(e2, true, true);
            }
            if (this.match(129)) {
              let e2 = this.tsParseInterfaceDeclaration(this.startNode());
              if (e2)
                return e2;
            }
            return super.parseExportDefaultExpression();
          }
          parseVarStatement(e2, s2, i2 = false) {
            let { isAmbientContext: r2 } = this.state, n2 = super.parseVarStatement(e2, s2, i2 || r2);
            if (!r2)
              return n2;
            for (let { id: o2, init: h2 } of n2.declarations)
              h2 && (s2 !== "const" || o2.typeAnnotation ? this.raise(x2.InitializerNotAllowedInAmbientContext, h2) : Qi2(h2, this.hasPlugin("estree")) || this.raise(x2.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, h2));
            return n2;
          }
          parseStatementContent(e2, s2) {
            if (this.match(75) && this.isLookaheadContextual("enum")) {
              let i2 = this.startNode();
              return this.expect(75), this.tsParseEnumDeclaration(i2, { const: true });
            }
            if (this.isContextual(126))
              return this.tsParseEnumDeclaration(this.startNode());
            if (this.isContextual(129)) {
              let i2 = this.tsParseInterfaceDeclaration(this.startNode());
              if (i2)
                return i2;
            }
            return super.parseStatementContent(e2, s2);
          }
          parseAccessModifier() {
            return this.tsParseModifier(["public", "protected", "private"]);
          }
          tsHasSomeModifiers(e2, s2) {
            return s2.some((i2) => $t2(i2) ? e2.accessibility === i2 : !!e2[i2]);
          }
          tsIsStartOfStaticBlocks() {
            return this.isContextual(106) && this.lookaheadCharCode() === 123;
          }
          parseClassMember(e2, s2, i2) {
            let r2 = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
            this.tsParseModifiers({ allowedModifiers: r2, disallowedModifiers: ["in", "out"], stopOnStartOfClassStaticBlock: true, errorTemplate: x2.InvalidModifierOnTypeParameterPositions }, s2);
            let n2 = () => {
              this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(s2, r2) && this.raise(x2.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(e2, s2)) : this.parseClassMemberWithIsStatic(e2, s2, i2, !!s2.static);
            };
            s2.declare ? this.tsInAmbientContext(n2) : n2();
          }
          parseClassMemberWithIsStatic(e2, s2, i2, r2) {
            let n2 = this.tsTryParseIndexSignature(s2);
            if (n2) {
              e2.body.push(n2), s2.abstract && this.raise(x2.IndexSignatureHasAbstract, s2), s2.accessibility && this.raise(x2.IndexSignatureHasAccessibility, s2, { modifier: s2.accessibility }), s2.declare && this.raise(x2.IndexSignatureHasDeclare, s2), s2.override && this.raise(x2.IndexSignatureHasOverride, s2);
              return;
            }
            !this.state.inAbstractClass && s2.abstract && this.raise(x2.NonAbstractClassHasAbstractMethod, s2), s2.override && (i2.hadSuperClass || this.raise(x2.OverrideNotInSubClass, s2)), super.parseClassMemberWithIsStatic(e2, s2, i2, r2);
          }
          parsePostMemberNameModifiers(e2) {
            this.eat(17) && (e2.optional = true), e2.readonly && this.match(10) && this.raise(x2.ClassMethodHasReadonly, e2), e2.declare && this.match(10) && this.raise(x2.ClassMethodHasDeclare, e2);
          }
          parseExpressionStatement(e2, s2, i2) {
            return (s2.type === "Identifier" ? this.tsParseExpressionStatement(e2, s2, i2) : void 0) || super.parseExpressionStatement(e2, s2, i2);
          }
          shouldParseExportDeclaration() {
            return this.tsIsDeclarationStart() ? true : super.shouldParseExportDeclaration();
          }
          parseConditional(e2, s2, i2) {
            if (!this.state.maybeInArrowParameters || !this.match(17))
              return super.parseConditional(e2, s2, i2);
            let r2 = this.tryParse(() => super.parseConditional(e2, s2));
            return r2.node ? (r2.error && (this.state = r2.failState), r2.node) : (r2.error && super.setOptionalParametersError(i2, r2.error), e2);
          }
          parseParenItem(e2, s2) {
            let i2 = super.parseParenItem(e2, s2);
            if (this.eat(17) && (i2.optional = true, this.resetEndLocation(e2)), this.match(14)) {
              let r2 = this.startNodeAt(s2);
              return r2.expression = e2, r2.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(r2, "TSTypeCastExpression");
            }
            return e2;
          }
          parseExportDeclaration(e2) {
            if (!this.state.isAmbientContext && this.isContextual(125))
              return this.tsInAmbientContext(() => this.parseExportDeclaration(e2));
            let s2 = this.state.startLoc, i2 = this.eatContextual(125);
            if (i2 && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
              throw this.raise(x2.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
            let n2 = w2(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(e2);
            return n2 ? ((n2.type === "TSInterfaceDeclaration" || n2.type === "TSTypeAliasDeclaration" || i2) && (e2.exportKind = "type"), i2 && (this.resetStartLocation(n2, s2), n2.declare = true), n2) : null;
          }
          parseClassId(e2, s2, i2, r2) {
            if ((!s2 || i2) && this.isContextual(113))
              return;
            super.parseClassId(e2, s2, i2, e2.declare ? 1024 : 8331);
            let n2 = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
            n2 && (e2.typeParameters = n2);
          }
          parseClassPropertyAnnotation(e2) {
            e2.optional || (this.eat(35) ? e2.definite = true : this.eat(17) && (e2.optional = true));
            let s2 = this.tsTryParseTypeAnnotation();
            s2 && (e2.typeAnnotation = s2);
          }
          parseClassProperty(e2) {
            if (this.parseClassPropertyAnnotation(e2), this.state.isAmbientContext && !(e2.readonly && !e2.typeAnnotation) && this.match(29) && this.raise(x2.DeclareClassFieldHasInitializer, this.state.startLoc), e2.abstract && this.match(29)) {
              let { key: s2 } = e2;
              this.raise(x2.AbstractPropertyHasInitializer, this.state.startLoc, { propertyName: s2.type === "Identifier" && !e2.computed ? s2.name : `[${this.input.slice(s2.start, s2.end)}]` });
            }
            return super.parseClassProperty(e2);
          }
          parseClassPrivateProperty(e2) {
            return e2.abstract && this.raise(x2.PrivateElementHasAbstract, e2), e2.accessibility && this.raise(x2.PrivateElementHasAccessibility, e2, { modifier: e2.accessibility }), this.parseClassPropertyAnnotation(e2), super.parseClassPrivateProperty(e2);
          }
          parseClassAccessorProperty(e2) {
            return this.parseClassPropertyAnnotation(e2), e2.optional && this.raise(x2.AccessorCannotBeOptional, e2), super.parseClassAccessorProperty(e2);
          }
          pushClassMethod(e2, s2, i2, r2, n2, o2) {
            let h2 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            h2 && n2 && this.raise(x2.ConstructorHasTypeParameters, h2);
            let { declare: c2 = false, kind: l2 } = s2;
            c2 && (l2 === "get" || l2 === "set") && this.raise(x2.DeclareAccessor, s2, { kind: l2 }), h2 && (s2.typeParameters = h2), super.pushClassMethod(e2, s2, i2, r2, n2, o2);
          }
          pushClassPrivateMethod(e2, s2, i2, r2) {
            let n2 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            n2 && (s2.typeParameters = n2), super.pushClassPrivateMethod(e2, s2, i2, r2);
          }
          declareClassPrivateMethodInScope(e2, s2) {
            e2.type !== "TSDeclareMethod" && (e2.type === "MethodDefinition" && !hasOwnProperty.call(e2.value, "body") || super.declareClassPrivateMethodInScope(e2, s2));
          }
          parseClassSuper(e2) {
            super.parseClassSuper(e2), e2.superClass && (this.match(47) || this.match(51)) && (e2.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (e2.implements = this.tsParseHeritageClause("implements"));
          }
          parseObjPropValue(e2, s2, i2, r2, n2, o2, h2) {
            let c2 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            return c2 && (e2.typeParameters = c2), super.parseObjPropValue(e2, s2, i2, r2, n2, o2, h2);
          }
          parseFunctionParams(e2, s2) {
            let i2 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            i2 && (e2.typeParameters = i2), super.parseFunctionParams(e2, s2);
          }
          parseVarId(e2, s2) {
            super.parseVarId(e2, s2), e2.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (e2.definite = true);
            let i2 = this.tsTryParseTypeAnnotation();
            i2 && (e2.id.typeAnnotation = i2, this.resetEndLocation(e2.id));
          }
          parseAsyncArrowFromCallExpression(e2, s2) {
            return this.match(14) && (e2.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e2, s2);
          }
          parseMaybeAssign(e2, s2) {
            var i2, r2, n2, o2, h2;
            let c2, l2, u2;
            if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
              if (c2 = this.state.clone(), l2 = this.tryParse(() => super.parseMaybeAssign(e2, s2), c2), !l2.error)
                return l2.node;
              let { context: y3 } = this.state, E2 = y3[y3.length - 1];
              (E2 === C.j_oTag || E2 === C.j_expr) && y3.pop();
            }
            if (!((i2 = l2) != null && i2.error) && !this.match(47))
              return super.parseMaybeAssign(e2, s2);
            (!c2 || c2 === this.state) && (c2 = this.state.clone());
            let f2, d2 = this.tryParse((y3) => {
              var E2, L3;
              f2 = this.tsParseTypeParameters(this.tsParseConstModifier);
              let S3 = super.parseMaybeAssign(e2, s2);
              return (S3.type !== "ArrowFunctionExpression" || (E2 = S3.extra) != null && E2.parenthesized) && y3(), ((L3 = f2) == null ? void 0 : L3.params.length) !== 0 && this.resetStartLocationFromNode(S3, f2), S3.typeParameters = f2, S3;
            }, c2);
            if (!d2.error && !d2.aborted)
              return f2 && this.reportReservedArrowTypeParam(f2), d2.node;
            if (!l2 && (jt2(!this.hasPlugin("jsx")), u2 = this.tryParse(() => super.parseMaybeAssign(e2, s2), c2), !u2.error))
              return u2.node;
            if ((r2 = l2) != null && r2.node)
              return this.state = l2.failState, l2.node;
            if (d2.node)
              return this.state = d2.failState, f2 && this.reportReservedArrowTypeParam(f2), d2.node;
            if ((n2 = u2) != null && n2.node)
              return this.state = u2.failState, u2.node;
            throw ((o2 = l2) == null ? void 0 : o2.error) || d2.error || ((h2 = u2) == null ? void 0 : h2.error);
          }
          reportReservedArrowTypeParam(e2) {
            var s2;
            e2.params.length === 1 && !e2.params[0].constraint && !((s2 = e2.extra) != null && s2.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(x2.ReservedArrowTypeParam, e2);
          }
          parseMaybeUnary(e2, s2) {
            return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e2, s2);
          }
          parseArrow(e2) {
            if (this.match(14)) {
              let s2 = this.tryParse((i2) => {
                let r2 = this.tsParseTypeOrTypePredicateAnnotation(14);
                return (this.canInsertSemicolon() || !this.match(19)) && i2(), r2;
              });
              if (s2.aborted)
                return;
              s2.thrown || (s2.error && (this.state = s2.failState), e2.returnType = s2.node);
            }
            return super.parseArrow(e2);
          }
          parseAssignableListItemTypes(e2, s2) {
            if (!(s2 & 2))
              return e2;
            this.eat(17) && (e2.optional = true);
            let i2 = this.tsTryParseTypeAnnotation();
            return i2 && (e2.typeAnnotation = i2), this.resetEndLocation(e2), e2;
          }
          isAssignable(e2, s2) {
            switch (e2.type) {
              case "TSTypeCastExpression":
                return this.isAssignable(e2.expression, s2);
              case "TSParameterProperty":
                return true;
              default:
                return super.isAssignable(e2, s2);
            }
          }
          toAssignable(e2, s2 = false) {
            switch (e2.type) {
              case "ParenthesizedExpression":
                this.toAssignableParenthesizedExpression(e2, s2);
                break;
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSNonNullExpression":
              case "TSTypeAssertion":
                s2 ? this.expressionScope.recordArrowParameterBindingError(x2.UnexpectedTypeCastInParameter, e2) : this.raise(x2.UnexpectedTypeCastInParameter, e2), this.toAssignable(e2.expression, s2);
                break;
              case "AssignmentExpression":
                !s2 && e2.left.type === "TSTypeCastExpression" && (e2.left = this.typeCastToParameter(e2.left));
              default:
                super.toAssignable(e2, s2);
            }
          }
          toAssignableParenthesizedExpression(e2, s2) {
            switch (e2.expression.type) {
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSNonNullExpression":
              case "TSTypeAssertion":
              case "ParenthesizedExpression":
                this.toAssignable(e2.expression, s2);
                break;
              default:
                super.toAssignable(e2, s2);
            }
          }
          checkToRestConversion(e2, s2) {
            switch (e2.type) {
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSTypeAssertion":
              case "TSNonNullExpression":
                this.checkToRestConversion(e2.expression, false);
                break;
              default:
                super.checkToRestConversion(e2, s2);
            }
          }
          isValidLVal(e2, s2, i2) {
            return Hi({ TSTypeCastExpression: true, TSParameterProperty: "parameter", TSNonNullExpression: "expression", TSInstantiationExpression: "expression", TSAsExpression: (i2 !== 64 || !s2) && ["expression", true], TSSatisfiesExpression: (i2 !== 64 || !s2) && ["expression", true], TSTypeAssertion: (i2 !== 64 || !s2) && ["expression", true] }, e2) || super.isValidLVal(e2, s2, i2);
          }
          parseBindingAtom() {
            return this.state.type === 78 ? this.parseIdentifier(true) : super.parseBindingAtom();
          }
          parseMaybeDecoratorArguments(e2) {
            if (this.match(47) || this.match(51)) {
              let s2 = this.tsParseTypeArgumentsInExpression();
              if (this.match(10)) {
                let i2 = super.parseMaybeDecoratorArguments(e2);
                return i2.typeParameters = s2, i2;
              }
              this.unexpected(null, 10);
            }
            return super.parseMaybeDecoratorArguments(e2);
          }
          checkCommaAfterRest(e2) {
            return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e2 ? (this.next(), false) : super.checkCommaAfterRest(e2);
          }
          isClassMethod() {
            return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(35) || this.match(14) || super.isClassProperty();
          }
          parseMaybeDefault(e2, s2) {
            let i2 = super.parseMaybeDefault(e2, s2);
            return i2.type === "AssignmentPattern" && i2.typeAnnotation && i2.right.start < i2.typeAnnotation.start && this.raise(x2.TypeAnnotationAfterAssign, i2.typeAnnotation), i2;
          }
          getTokenFromCode(e2) {
            if (this.state.inType) {
              if (e2 === 62) {
                this.finishOp(48, 1);
                return;
              }
              if (e2 === 60) {
                this.finishOp(47, 1);
                return;
              }
            }
            super.getTokenFromCode(e2);
          }
          reScan_lt_gt() {
            let { type: e2 } = this.state;
            e2 === 47 ? (this.state.pos -= 1, this.readToken_lt()) : e2 === 48 && (this.state.pos -= 1, this.readToken_gt());
          }
          reScan_lt() {
            let { type: e2 } = this.state;
            return e2 === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : e2;
          }
          toAssignableList(e2, s2, i2) {
            for (let r2 = 0; r2 < e2.length; r2++) {
              let n2 = e2[r2];
              (n2 == null ? void 0 : n2.type) === "TSTypeCastExpression" && (e2[r2] = this.typeCastToParameter(n2));
            }
            super.toAssignableList(e2, s2, i2);
          }
          typeCastToParameter(e2) {
            return e2.expression.typeAnnotation = e2.typeAnnotation, this.resetEndLocation(e2.expression, e2.typeAnnotation.loc.end), e2.expression;
          }
          shouldParseArrow(e2) {
            return this.match(14) ? e2.every((s2) => this.isAssignable(s2, true)) : super.shouldParseArrow(e2);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          canHaveLeadingDecorator() {
            return super.canHaveLeadingDecorator() || this.isAbstractClass();
          }
          jsxParseOpeningElementAfterName(e2) {
            if (this.match(47) || this.match(51)) {
              let s2 = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
              s2 && (e2.typeParameters = s2);
            }
            return super.jsxParseOpeningElementAfterName(e2);
          }
          getGetterSetterExpectedParamCount(e2) {
            let s2 = super.getGetterSetterExpectedParamCount(e2), r2 = this.getObjectOrClassMethodParams(e2)[0];
            return r2 && this.isThisParam(r2) ? s2 + 1 : s2;
          }
          parseCatchClauseParam() {
            let e2 = super.parseCatchClauseParam(), s2 = this.tsTryParseTypeAnnotation();
            return s2 && (e2.typeAnnotation = s2, this.resetEndLocation(e2)), e2;
          }
          tsInAmbientContext(e2) {
            let { isAmbientContext: s2, strict: i2 } = this.state;
            this.state.isAmbientContext = true, this.state.strict = false;
            try {
              return e2();
            } finally {
              this.state.isAmbientContext = s2, this.state.strict = i2;
            }
          }
          parseClass(e2, s2, i2) {
            let r2 = this.state.inAbstractClass;
            this.state.inAbstractClass = !!e2.abstract;
            try {
              return super.parseClass(e2, s2, i2);
            } finally {
              this.state.inAbstractClass = r2;
            }
          }
          tsParseAbstractDeclaration(e2, s2) {
            if (this.match(80))
              return e2.abstract = true, this.maybeTakeDecorators(s2, this.parseClass(e2, true, false));
            if (this.isContextual(129)) {
              if (!this.hasFollowingLineBreak())
                return e2.abstract = true, this.raise(x2.NonClassMethodPropertyHasAbstractModifer, e2), this.tsParseInterfaceDeclaration(e2);
            } else
              this.unexpected(null, 80);
          }
          parseMethod(e2, s2, i2, r2, n2, o2, h2) {
            let c2 = super.parseMethod(e2, s2, i2, r2, n2, o2, h2);
            if (c2.abstract && (this.hasPlugin("estree") ? !!c2.value.body : !!c2.body)) {
              let { key: u2 } = c2;
              this.raise(x2.AbstractMethodHasImplementation, c2, { methodName: u2.type === "Identifier" && !c2.computed ? u2.name : `[${this.input.slice(u2.start, u2.end)}]` });
            }
            return c2;
          }
          tsParseTypeParameterName() {
            return this.parseIdentifier().name;
          }
          shouldParseAsAmbientContext() {
            return !!this.getPluginOption("typescript", "dts");
          }
          parse() {
            return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
          }
          getExpression() {
            return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
          }
          parseExportSpecifier(e2, s2, i2, r2) {
            return !s2 && r2 ? (this.parseTypeOnlyImportExportSpecifier(e2, false, i2), this.finishNode(e2, "ExportSpecifier")) : (e2.exportKind = "value", super.parseExportSpecifier(e2, s2, i2, r2));
          }
          parseImportSpecifier(e2, s2, i2, r2, n2) {
            return !s2 && r2 ? (this.parseTypeOnlyImportExportSpecifier(e2, true, i2), this.finishNode(e2, "ImportSpecifier")) : (e2.importKind = "value", super.parseImportSpecifier(e2, s2, i2, r2, i2 ? 4098 : 4096));
          }
          parseTypeOnlyImportExportSpecifier(e2, s2, i2) {
            let r2 = s2 ? "imported" : "local", n2 = s2 ? "local" : "exported", o2 = e2[r2], h2, c2 = false, l2 = true, u2 = o2.loc.start;
            if (this.isContextual(93)) {
              let d2 = this.parseIdentifier();
              if (this.isContextual(93)) {
                let y3 = this.parseIdentifier();
                M3(this.state.type) ? (c2 = true, o2 = d2, h2 = s2 ? this.parseIdentifier() : this.parseModuleExportName(), l2 = false) : (h2 = y3, l2 = false);
              } else
                M3(this.state.type) ? (l2 = false, h2 = s2 ? this.parseIdentifier() : this.parseModuleExportName()) : (c2 = true, o2 = d2);
            } else
              M3(this.state.type) && (c2 = true, s2 ? (o2 = this.parseIdentifier(true), this.isContextual(93) || this.checkReservedWord(o2.name, o2.loc.start, true, true)) : o2 = this.parseModuleExportName());
            c2 && i2 && this.raise(s2 ? x2.TypeModifierIsUsedInTypeImports : x2.TypeModifierIsUsedInTypeExports, u2), e2[r2] = o2, e2[n2] = h2;
            let f2 = s2 ? "importKind" : "exportKind";
            e2[f2] = c2 ? "type" : "value", l2 && this.eatContextual(93) && (e2[n2] = s2 ? this.parseIdentifier() : this.parseModuleExportName()), e2[n2] || (e2[n2] = $2(e2[r2])), s2 && this.checkIdentifier(e2[n2], c2 ? 4098 : 4096);
          }
        };
        function Yi2(a2) {
          if (a2.type !== "MemberExpression")
            return false;
          let { computed: t2, property: e2 } = a2;
          return t2 && e2.type !== "StringLiteral" && (e2.type !== "TemplateLiteral" || e2.expressions.length > 0) ? false : os(a2.object);
        }
        function Qi2(a2, t2) {
          var e2;
          let { type: s2 } = a2;
          if ((e2 = a2.extra) != null && e2.parenthesized)
            return false;
          if (t2) {
            if (s2 === "Literal") {
              let { value: i2 } = a2;
              if (typeof i2 == "string" || typeof i2 == "boolean")
                return true;
            }
          } else if (s2 === "StringLiteral" || s2 === "BooleanLiteral")
            return true;
          return !!(ns(a2, t2) || Zi(a2, t2) || s2 === "TemplateLiteral" && a2.expressions.length === 0 || Yi2(a2));
        }
        function ns(a2, t2) {
          return t2 ? a2.type === "Literal" && (typeof a2.value == "number" || "bigint" in a2) : a2.type === "NumericLiteral" || a2.type === "BigIntLiteral";
        }
        function Zi(a2, t2) {
          if (a2.type === "UnaryExpression") {
            let { operator: e2, argument: s2 } = a2;
            if (e2 === "-" && ns(s2, t2))
              return true;
          }
          return false;
        }
        function os(a2) {
          return a2.type === "Identifier" ? true : a2.type !== "MemberExpression" || a2.computed ? false : os(a2.object);
        }
        var Vt2 = j2`placeholders`({ ClassNameIsRequired: "A class name is required.", UnexpectedSpace: "Unexpected space in placeholder." }), er2 = (a2) => class extends a2 {
          parsePlaceholder(e2) {
            if (this.match(144)) {
              let s2 = this.startNode();
              return this.next(), this.assertNoSpace(), s2.name = super.parseIdentifier(true), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(s2, e2);
            }
          }
          finishPlaceholder(e2, s2) {
            let i2 = e2;
            return (!i2.expectedNode || !i2.type) && (i2 = this.finishNode(i2, "Placeholder")), i2.expectedNode = s2, i2;
          }
          getTokenFromCode(e2) {
            e2 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(144, 2) : super.getTokenFromCode(e2);
          }
          parseExprAtom(e2) {
            return this.parsePlaceholder("Expression") || super.parseExprAtom(e2);
          }
          parseIdentifier(e2) {
            return this.parsePlaceholder("Identifier") || super.parseIdentifier(e2);
          }
          checkReservedWord(e2, s2, i2, r2) {
            e2 !== void 0 && super.checkReservedWord(e2, s2, i2, r2);
          }
          parseBindingAtom() {
            return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
          }
          isValidLVal(e2, s2, i2) {
            return e2 === "Placeholder" || super.isValidLVal(e2, s2, i2);
          }
          toAssignable(e2, s2) {
            e2 && e2.type === "Placeholder" && e2.expectedNode === "Expression" ? e2.expectedNode = "Pattern" : super.toAssignable(e2, s2);
          }
          chStartsBindingIdentifier(e2, s2) {
            return !!(super.chStartsBindingIdentifier(e2, s2) || this.lookahead().type === 144);
          }
          verifyBreakContinue(e2, s2) {
            e2.label && e2.label.type === "Placeholder" || super.verifyBreakContinue(e2, s2);
          }
          parseExpressionStatement(e2, s2) {
            var i2;
            if (s2.type !== "Placeholder" || (i2 = s2.extra) != null && i2.parenthesized)
              return super.parseExpressionStatement(e2, s2);
            if (this.match(14)) {
              let n2 = e2;
              return n2.label = this.finishPlaceholder(s2, "Identifier"), this.next(), n2.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(n2, "LabeledStatement");
            }
            this.semicolon();
            let r2 = e2;
            return r2.name = s2.name, this.finishPlaceholder(r2, "Statement");
          }
          parseBlock(e2, s2, i2) {
            return this.parsePlaceholder("BlockStatement") || super.parseBlock(e2, s2, i2);
          }
          parseFunctionId(e2) {
            return this.parsePlaceholder("Identifier") || super.parseFunctionId(e2);
          }
          parseClass(e2, s2, i2) {
            let r2 = s2 ? "ClassDeclaration" : "ClassExpression";
            this.next();
            let n2 = this.state.strict, o2 = this.parsePlaceholder("Identifier");
            if (o2)
              if (this.match(81) || this.match(144) || this.match(5))
                e2.id = o2;
              else {
                if (i2 || !s2)
                  return e2.id = null, e2.body = this.finishPlaceholder(o2, "ClassBody"), this.finishNode(e2, r2);
                throw this.raise(Vt2.ClassNameIsRequired, this.state.startLoc);
              }
            else
              this.parseClassId(e2, s2, i2);
            return super.parseClassSuper(e2), e2.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!e2.superClass, n2), this.finishNode(e2, r2);
          }
          parseExport(e2, s2) {
            let i2 = this.parsePlaceholder("Identifier");
            if (!i2)
              return super.parseExport(e2, s2);
            let r2 = e2;
            if (!this.isContextual(98) && !this.match(12))
              return r2.specifiers = [], r2.source = null, r2.declaration = this.finishPlaceholder(i2, "Declaration"), this.finishNode(r2, "ExportNamedDeclaration");
            this.expectPlugin("exportDefaultFrom");
            let n2 = this.startNode();
            return n2.exported = i2, r2.specifiers = [this.finishNode(n2, "ExportDefaultSpecifier")], super.parseExport(r2, s2);
          }
          isExportDefaultSpecifier() {
            if (this.match(65)) {
              let e2 = this.nextTokenStart();
              if (this.isUnparsedContextual(e2, "from") && this.input.startsWith(K2(144), this.nextTokenStartSince(e2 + 4)))
                return true;
            }
            return super.isExportDefaultSpecifier();
          }
          maybeParseExportDefaultSpecifier(e2, s2) {
            var i2;
            return (i2 = e2.specifiers) != null && i2.length ? true : super.maybeParseExportDefaultSpecifier(e2, s2);
          }
          checkExport(e2) {
            let { specifiers: s2 } = e2;
            s2 != null && s2.length && (e2.specifiers = s2.filter((i2) => i2.exported.type === "Placeholder")), super.checkExport(e2), e2.specifiers = s2;
          }
          parseImport(e2) {
            let s2 = this.parsePlaceholder("Identifier");
            if (!s2)
              return super.parseImport(e2);
            if (e2.specifiers = [], !this.isContextual(98) && !this.match(12))
              return e2.source = this.finishPlaceholder(s2, "StringLiteral"), this.semicolon(), this.finishNode(e2, "ImportDeclaration");
            let i2 = this.startNodeAtNode(s2);
            return i2.local = s2, e2.specifiers.push(this.finishNode(i2, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(e2) || this.parseNamedImportSpecifiers(e2)), this.expectContextual(98), e2.source = this.parseImportSource(), this.semicolon(), this.finishNode(e2, "ImportDeclaration");
          }
          parseImportSource() {
            return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
          }
          assertNoSpace() {
            this.state.start > this.state.lastTokEndLoc.index && this.raise(Vt2.UnexpectedSpace, this.state.lastTokEndLoc);
          }
        }, tr2 = (a2) => class extends a2 {
          parseV8Intrinsic() {
            if (this.match(54)) {
              let e2 = this.state.startLoc, s2 = this.startNode();
              if (this.next(), w2(this.state.type)) {
                let i2 = this.parseIdentifierName(), r2 = this.createIdentifier(s2, i2);
                if (r2.type = "V8IntrinsicIdentifier", this.match(10))
                  return r2;
              }
              this.unexpected(e2);
            }
          }
          parseExprAtom(e2) {
            return this.parseV8Intrinsic() || super.parseExprAtom(e2);
          }
        };
        function N2(a2, t2) {
          let [e2, s2] = typeof t2 == "string" ? [t2, {}] : t2, i2 = Object.keys(s2), r2 = i2.length === 0;
          return a2.some((n2) => {
            if (typeof n2 == "string")
              return r2 && n2 === e2;
            {
              let [o2, h2] = n2;
              if (o2 !== e2)
                return false;
              for (let c2 of i2)
                if (h2[c2] !== s2[c2])
                  return false;
              return true;
            }
          });
        }
        function J3(a2, t2, e2) {
          let s2 = a2.find((i2) => Array.isArray(i2) ? i2[0] === t2 : i2 === t2);
          return s2 && Array.isArray(s2) && s2.length > 1 ? s2[1][e2] : null;
        }
        var qt2 = ["minimal", "fsharp", "hack", "smart"], zt2 = ["^^", "@@", "^", "%", "#"];
        function sr3(a2) {
          if (N2(a2, "decorators")) {
            if (N2(a2, "decorators-legacy"))
              throw new Error("Cannot use the decorators and decorators-legacy plugin together");
            let t2 = J3(a2, "decorators", "decoratorsBeforeExport");
            if (t2 != null && typeof t2 != "boolean")
              throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
            let e2 = J3(a2, "decorators", "allowCallParenthesized");
            if (e2 != null && typeof e2 != "boolean")
              throw new Error("'allowCallParenthesized' must be a boolean.");
          }
          if (N2(a2, "flow") && N2(a2, "typescript"))
            throw new Error("Cannot combine flow and typescript plugins.");
          if (N2(a2, "placeholders") && N2(a2, "v8intrinsic"))
            throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
          if (N2(a2, "pipelineOperator")) {
            let t2 = J3(a2, "pipelineOperator", "proposal");
            if (!qt2.includes(t2)) {
              let i2 = qt2.map((r2) => `"${r2}"`).join(", ");
              throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${i2}.`);
            }
            let e2 = ["recordAndTuple", { syntaxType: "hash" }], s2 = N2(a2, e2);
            if (t2 === "hack") {
              if (N2(a2, "placeholders"))
                throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
              if (N2(a2, "v8intrinsic"))
                throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
              let i2 = J3(a2, "pipelineOperator", "topicToken");
              if (!zt2.includes(i2)) {
                let r2 = zt2.map((n2) => `"${n2}"`).join(", ");
                throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${r2}.`);
              }
              if (i2 === "#" && s2)
                throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(e2)}\`.`);
            } else if (t2 === "smart" && s2)
              throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(e2)}\`.`);
          }
          if (N2(a2, "moduleAttributes")) {
            if (N2(a2, "importAssertions") || N2(a2, "importAttributes"))
              throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
            if (J3(a2, "moduleAttributes", "version") !== "may-2020")
              throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
          }
          if (N2(a2, "importAssertions") && N2(a2, "importAttributes"))
            throw new Error("Cannot combine importAssertions and importAttributes plugins.");
          if (N2(a2, "recordAndTuple")) {
            let t2 = J3(a2, "recordAndTuple", "syntaxType");
            if (t2 != null) {
              let e2 = ["hash", "bar"];
              if (!e2.includes(t2))
                throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + e2.map((s2) => `'${s2}'`).join(", "));
            }
          }
          if (N2(a2, "asyncDoExpressions") && !N2(a2, "doExpressions")) {
            let t2 = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
            throw t2.missingPlugins = "doExpressions", t2;
          }
          if (N2(a2, "optionalChainingAssign") && J3(a2, "optionalChainingAssign", "version") !== "2023-07")
            throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
        }
        var hs = { estree: ri3, jsx: zi, flow: qi2, typescript: Gi, v8intrinsic: tr2, placeholders: er2 }, ir3 = Object.keys(hs), qe2 = { sourceType: "script", sourceFilename: void 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: false, allowReturnOutsideFunction: false, allowNewTargetOutsideFunction: false, allowImportExportEverywhere: false, allowSuperOutsideMethod: false, allowUndeclaredExports: false, plugins: [], strictMode: null, ranges: false, tokens: false, createImportExpressions: false, createParenthesizedExpressions: false, errorRecovery: false, attachComment: true, annexB: true };
        function rr2(a2) {
          if (a2 == null)
            return Object.assign({}, qe2);
          if (a2.annexB != null && a2.annexB !== false)
            throw new Error("The `annexB` option can only be set to `false`.");
          let t2 = {};
          for (let s2 of Object.keys(qe2)) {
            var e2;
            t2[s2] = (e2 = a2[s2]) != null ? e2 : qe2[s2];
          }
          return t2;
        }
        var ct3 = class extends lt3 {
          checkProto(t2, e2, s2, i2) {
            if (t2.type === "SpreadElement" || this.isObjectMethod(t2) || t2.computed || t2.shorthand)
              return;
            let r2 = t2.key;
            if ((r2.type === "Identifier" ? r2.name : r2.value) === "__proto__") {
              if (e2) {
                this.raise(p2.RecordNoProto, r2);
                return;
              }
              s2.used && (i2 ? i2.doubleProtoLoc === null && (i2.doubleProtoLoc = r2.loc.start) : this.raise(p2.DuplicateProto, r2)), s2.used = true;
            }
          }
          shouldExitDescending(t2, e2) {
            return t2.type === "ArrowFunctionExpression" && t2.start === e2;
          }
          getExpression() {
            this.enterInitialScopes(), this.nextToken();
            let t2 = this.parseExpression();
            return this.match(139) || this.unexpected(), this.finalizeRemainingComments(), t2.comments = this.comments, t2.errors = this.state.errors, this.options.tokens && (t2.tokens = this.tokens), t2;
          }
          parseExpression(t2, e2) {
            return t2 ? this.disallowInAnd(() => this.parseExpressionBase(e2)) : this.allowInAnd(() => this.parseExpressionBase(e2));
          }
          parseExpressionBase(t2) {
            let e2 = this.state.startLoc, s2 = this.parseMaybeAssign(t2);
            if (this.match(12)) {
              let i2 = this.startNodeAt(e2);
              for (i2.expressions = [s2]; this.eat(12); )
                i2.expressions.push(this.parseMaybeAssign(t2));
              return this.toReferencedList(i2.expressions), this.finishNode(i2, "SequenceExpression");
            }
            return s2;
          }
          parseMaybeAssignDisallowIn(t2, e2) {
            return this.disallowInAnd(() => this.parseMaybeAssign(t2, e2));
          }
          parseMaybeAssignAllowIn(t2, e2) {
            return this.allowInAnd(() => this.parseMaybeAssign(t2, e2));
          }
          setOptionalParametersError(t2, e2) {
            var s2;
            t2.optionalParametersLoc = (s2 = e2 == null ? void 0 : e2.loc) != null ? s2 : this.state.startLoc;
          }
          parseMaybeAssign(t2, e2) {
            let s2 = this.state.startLoc;
            if (this.isContextual(108) && this.prodParam.hasYield) {
              let o2 = this.parseYield();
              return e2 && (o2 = e2.call(this, o2, s2)), o2;
            }
            let i2;
            t2 ? i2 = false : (t2 = new Z3(), i2 = true);
            let { type: r2 } = this.state;
            (r2 === 10 || w2(r2)) && (this.state.potentialArrowAt = this.state.start);
            let n2 = this.parseMaybeConditional(t2);
            if (e2 && (n2 = e2.call(this, n2, s2)), li3(this.state.type)) {
              let o2 = this.startNodeAt(s2), h2 = this.state.value;
              if (o2.operator = h2, this.match(29)) {
                this.toAssignable(n2, true), o2.left = n2;
                let c2 = s2.index;
                t2.doubleProtoLoc != null && t2.doubleProtoLoc.index >= c2 && (t2.doubleProtoLoc = null), t2.shorthandAssignLoc != null && t2.shorthandAssignLoc.index >= c2 && (t2.shorthandAssignLoc = null), t2.privateKeyLoc != null && t2.privateKeyLoc.index >= c2 && (this.checkDestructuringPrivate(t2), t2.privateKeyLoc = null);
              } else
                o2.left = n2;
              return this.next(), o2.right = this.parseMaybeAssign(), this.checkLVal(n2, { in: this.finishNode(o2, "AssignmentExpression") }), o2;
            } else
              i2 && this.checkExpressionErrors(t2, true);
            return n2;
          }
          parseMaybeConditional(t2) {
            let e2 = this.state.startLoc, s2 = this.state.potentialArrowAt, i2 = this.parseExprOps(t2);
            return this.shouldExitDescending(i2, s2) ? i2 : this.parseConditional(i2, e2, t2);
          }
          parseConditional(t2, e2, s2) {
            if (this.eat(17)) {
              let i2 = this.startNodeAt(e2);
              return i2.test = t2, i2.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), i2.alternate = this.parseMaybeAssign(), this.finishNode(i2, "ConditionalExpression");
            }
            return t2;
          }
          parseMaybeUnaryOrPrivate(t2) {
            return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(t2);
          }
          parseExprOps(t2) {
            let e2 = this.state.startLoc, s2 = this.state.potentialArrowAt, i2 = this.parseMaybeUnaryOrPrivate(t2);
            return this.shouldExitDescending(i2, s2) ? i2 : this.parseExprOp(i2, e2, -1);
          }
          parseExprOp(t2, e2, s2) {
            if (this.isPrivateName(t2)) {
              let r2 = this.getPrivateNameSV(t2);
              (s2 >= Ie3(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(p2.PrivateInExpectedIn, t2, { identifierName: r2 }), this.classScope.usePrivateName(r2, t2.loc.start);
            }
            let i2 = this.state.type;
            if (pi3(i2) && (this.prodParam.hasIn || !this.match(58))) {
              let r2 = Ie3(i2);
              if (r2 > s2) {
                if (i2 === 39) {
                  if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
                    return t2;
                  this.checkPipelineAtInfixOperator(t2, e2);
                }
                let n2 = this.startNodeAt(e2);
                n2.left = t2, n2.operator = this.state.value;
                let o2 = i2 === 41 || i2 === 42, h2 = i2 === 40;
                if (h2 && (r2 = Ie3(42)), this.next(), i2 === 39 && this.hasPlugin(["pipelineOperator", { proposal: "minimal" }]) && this.state.type === 96 && this.prodParam.hasAwait)
                  throw this.raise(p2.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
                n2.right = this.parseExprOpRightExpr(i2, r2);
                let c2 = this.finishNode(n2, o2 || h2 ? "LogicalExpression" : "BinaryExpression"), l2 = this.state.type;
                if (h2 && (l2 === 41 || l2 === 42) || o2 && l2 === 40)
                  throw this.raise(p2.MixingCoalesceWithLogical, this.state.startLoc);
                return this.parseExprOp(c2, e2, s2);
              }
            }
            return t2;
          }
          parseExprOpRightExpr(t2, e2) {
            let s2 = this.state.startLoc;
            switch (t2) {
              case 39:
                switch (this.getPluginOption("pipelineOperator", "proposal")) {
                  case "hack":
                    return this.withTopicBindingContext(() => this.parseHackPipeBody());
                  case "smart":
                    return this.withTopicBindingContext(() => {
                      if (this.prodParam.hasYield && this.isContextual(108))
                        throw this.raise(p2.PipeBodyIsTighter, this.state.startLoc);
                      return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(t2, e2), s2);
                    });
                  case "fsharp":
                    return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(e2));
                }
              default:
                return this.parseExprOpBaseRightExpr(t2, e2);
            }
          }
          parseExprOpBaseRightExpr(t2, e2) {
            let s2 = this.state.startLoc;
            return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), s2, yi(t2) ? e2 - 1 : e2);
          }
          parseHackPipeBody() {
            var t2;
            let { startLoc: e2 } = this.state, s2 = this.parseMaybeAssign();
            return Qs2.has(s2.type) && !((t2 = s2.extra) != null && t2.parenthesized) && this.raise(p2.PipeUnparenthesizedBody, e2, { type: s2.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(p2.PipeTopicUnused, e2), s2;
          }
          checkExponentialAfterUnary(t2) {
            this.match(57) && this.raise(p2.UnexpectedTokenUnaryExponentiation, t2.argument);
          }
          parseMaybeUnary(t2, e2) {
            let s2 = this.state.startLoc, i2 = this.isContextual(96);
            if (i2 && this.isAwaitAllowed()) {
              this.next();
              let h2 = this.parseAwait(s2);
              return e2 || this.checkExponentialAfterUnary(h2), h2;
            }
            let r2 = this.match(34), n2 = this.startNode();
            if (fi2(this.state.type)) {
              n2.operator = this.state.value, n2.prefix = true, this.match(72) && this.expectPlugin("throwExpressions");
              let h2 = this.match(89);
              if (this.next(), n2.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(t2, true), this.state.strict && h2) {
                let c2 = n2.argument;
                c2.type === "Identifier" ? this.raise(p2.StrictDelete, n2) : this.hasPropertyAsPrivateName(c2) && this.raise(p2.DeletePrivateField, n2);
              }
              if (!r2)
                return e2 || this.checkExponentialAfterUnary(n2), this.finishNode(n2, "UnaryExpression");
            }
            let o2 = this.parseUpdate(n2, r2, t2);
            if (i2) {
              let { type: h2 } = this.state;
              if ((this.hasPlugin("v8intrinsic") ? He2(h2) : He2(h2) && !this.match(54)) && !this.isAmbiguousAwait())
                return this.raiseOverwrite(p2.AwaitNotInAsyncContext, s2), this.parseAwait(s2);
            }
            return o2;
          }
          parseUpdate(t2, e2, s2) {
            if (e2) {
              let n2 = t2;
              return this.checkLVal(n2.argument, { in: this.finishNode(n2, "UpdateExpression") }), t2;
            }
            let i2 = this.state.startLoc, r2 = this.parseExprSubscripts(s2);
            if (this.checkExpressionErrors(s2, false))
              return r2;
            for (; ui2(this.state.type) && !this.canInsertSemicolon(); ) {
              let n2 = this.startNodeAt(i2);
              n2.operator = this.state.value, n2.prefix = false, n2.argument = r2, this.next(), this.checkLVal(r2, { in: r2 = this.finishNode(n2, "UpdateExpression") });
            }
            return r2;
          }
          parseExprSubscripts(t2) {
            let e2 = this.state.startLoc, s2 = this.state.potentialArrowAt, i2 = this.parseExprAtom(t2);
            return this.shouldExitDescending(i2, s2) ? i2 : this.parseSubscripts(i2, e2);
          }
          parseSubscripts(t2, e2, s2) {
            let i2 = { optionalChainMember: false, maybeAsyncArrow: this.atPossibleAsyncArrow(t2), stop: false };
            do
              t2 = this.parseSubscript(t2, e2, s2, i2), i2.maybeAsyncArrow = false;
            while (!i2.stop);
            return t2;
          }
          parseSubscript(t2, e2, s2, i2) {
            let { type: r2 } = this.state;
            if (!s2 && r2 === 15)
              return this.parseBind(t2, e2, s2, i2);
            if (Le3(r2))
              return this.parseTaggedTemplateExpression(t2, e2, i2);
            let n2 = false;
            if (r2 === 18) {
              if (s2 && (this.raise(p2.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
                return i2.stop = true, t2;
              i2.optionalChainMember = n2 = true, this.next();
            }
            if (!s2 && this.match(10))
              return this.parseCoverCallAndAsyncArrowHead(t2, e2, i2, n2);
            {
              let o2 = this.eat(0);
              return o2 || n2 || this.eat(16) ? this.parseMember(t2, e2, i2, o2, n2) : (i2.stop = true, t2);
            }
          }
          parseMember(t2, e2, s2, i2, r2) {
            let n2 = this.startNodeAt(e2);
            return n2.object = t2, n2.computed = i2, i2 ? (n2.property = this.parseExpression(), this.expect(3)) : this.match(138) ? (t2.type === "Super" && this.raise(p2.SuperPrivateField, e2), this.classScope.usePrivateName(this.state.value, this.state.startLoc), n2.property = this.parsePrivateName()) : n2.property = this.parseIdentifier(true), s2.optionalChainMember ? (n2.optional = r2, this.finishNode(n2, "OptionalMemberExpression")) : this.finishNode(n2, "MemberExpression");
          }
          parseBind(t2, e2, s2, i2) {
            let r2 = this.startNodeAt(e2);
            return r2.object = t2, this.next(), r2.callee = this.parseNoCallExpr(), i2.stop = true, this.parseSubscripts(this.finishNode(r2, "BindExpression"), e2, s2);
          }
          parseCoverCallAndAsyncArrowHead(t2, e2, s2, i2) {
            let r2 = this.state.maybeInArrowParameters, n2 = null;
            this.state.maybeInArrowParameters = true, this.next();
            let o2 = this.startNodeAt(e2);
            o2.callee = t2;
            let { maybeAsyncArrow: h2, optionalChainMember: c2 } = s2;
            h2 && (this.expressionScope.enter(Fi()), n2 = new Z3()), c2 && (o2.optional = i2), i2 ? o2.arguments = this.parseCallExpressionArguments(11) : o2.arguments = this.parseCallExpressionArguments(11, t2.type === "Import", t2.type !== "Super", o2, n2);
            let l2 = this.finishCallExpression(o2, c2);
            return h2 && this.shouldParseAsyncArrow() && !i2 ? (s2.stop = true, this.checkDestructuringPrivate(n2), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), l2 = this.parseAsyncArrowFromCallExpression(this.startNodeAt(e2), l2)) : (h2 && (this.checkExpressionErrors(n2, true), this.expressionScope.exit()), this.toReferencedArguments(l2)), this.state.maybeInArrowParameters = r2, l2;
          }
          toReferencedArguments(t2, e2) {
            this.toReferencedListDeep(t2.arguments, e2);
          }
          parseTaggedTemplateExpression(t2, e2, s2) {
            let i2 = this.startNodeAt(e2);
            return i2.tag = t2, i2.quasi = this.parseTemplate(true), s2.optionalChainMember && this.raise(p2.OptionalChainingNoTemplate, e2), this.finishNode(i2, "TaggedTemplateExpression");
          }
          atPossibleAsyncArrow(t2) {
            return t2.type === "Identifier" && t2.name === "async" && this.state.lastTokEndLoc.index === t2.end && !this.canInsertSemicolon() && t2.end - t2.start === 5 && t2.start === this.state.potentialArrowAt;
          }
          expectImportAttributesPlugin() {
            this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
          }
          finishCallExpression(t2, e2) {
            if (t2.callee.type === "Import")
              if (t2.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), t2.arguments.length === 0 || t2.arguments.length > 2)
                this.raise(p2.ImportCallArity, t2, { maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1 });
              else
                for (let s2 of t2.arguments)
                  s2.type === "SpreadElement" && this.raise(p2.ImportCallSpreadArgument, s2);
            return this.finishNode(t2, e2 ? "OptionalCallExpression" : "CallExpression");
          }
          parseCallExpressionArguments(t2, e2, s2, i2, r2) {
            let n2 = [], o2 = true, h2 = this.state.inFSharpPipelineDirectBody;
            for (this.state.inFSharpPipelineDirectBody = false; !this.eat(t2); ) {
              if (o2)
                o2 = false;
              else if (this.expect(12), this.match(t2)) {
                e2 && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(p2.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc), i2 && this.addTrailingCommaExtraToNode(i2), this.next();
                break;
              }
              n2.push(this.parseExprListItem(false, r2, s2));
            }
            return this.state.inFSharpPipelineDirectBody = h2, n2;
          }
          shouldParseAsyncArrow() {
            return this.match(19) && !this.canInsertSemicolon();
          }
          parseAsyncArrowFromCallExpression(t2, e2) {
            var s2;
            return this.resetPreviousNodeTrailingComments(e2), this.expect(19), this.parseArrowExpression(t2, e2.arguments, true, (s2 = e2.extra) == null ? void 0 : s2.trailingCommaLoc), e2.innerComments && ye(t2, e2.innerComments), e2.callee.trailingComments && ye(t2, e2.callee.trailingComments), t2;
          }
          parseNoCallExpr() {
            let t2 = this.state.startLoc;
            return this.parseSubscripts(this.parseExprAtom(), t2, true);
          }
          parseExprAtom(t2) {
            let e2, s2 = null, { type: i2 } = this.state;
            switch (i2) {
              case 79:
                return this.parseSuper();
              case 83:
                return e2 = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(e2) : this.match(10) ? this.options.createImportExpressions ? this.parseImportCall(e2) : this.finishNode(e2, "Import") : (this.raise(p2.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(e2, "Import"));
              case 78:
                return e2 = this.startNode(), this.next(), this.finishNode(e2, "ThisExpression");
              case 90:
                return this.parseDo(this.startNode(), false);
              case 56:
              case 31:
                return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
              case 134:
                return this.parseNumericLiteral(this.state.value);
              case 135:
                return this.parseBigIntLiteral(this.state.value);
              case 136:
                return this.parseDecimalLiteral(this.state.value);
              case 133:
                return this.parseStringLiteral(this.state.value);
              case 84:
                return this.parseNullLiteral();
              case 85:
                return this.parseBooleanLiteral(true);
              case 86:
                return this.parseBooleanLiteral(false);
              case 10: {
                let r2 = this.state.potentialArrowAt === this.state.start;
                return this.parseParenAndDistinguishExpression(r2);
              }
              case 2:
              case 1:
                return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
              case 0:
                return this.parseArrayLike(3, true, false, t2);
              case 6:
              case 7:
                return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
              case 5:
                return this.parseObjectLike(8, false, false, t2);
              case 68:
                return this.parseFunctionOrFunctionSent();
              case 26:
                s2 = this.parseDecorators();
              case 80:
                return this.parseClass(this.maybeTakeDecorators(s2, this.startNode()), false);
              case 77:
                return this.parseNewOrNewTarget();
              case 25:
              case 24:
                return this.parseTemplate(false);
              case 15: {
                e2 = this.startNode(), this.next(), e2.object = null;
                let r2 = e2.callee = this.parseNoCallExpr();
                if (r2.type === "MemberExpression")
                  return this.finishNode(e2, "BindExpression");
                throw this.raise(p2.UnsupportedBind, r2);
              }
              case 138:
                return this.raise(p2.PrivateInExpectedIn, this.state.startLoc, { identifierName: this.state.value }), this.parsePrivateName();
              case 33:
                return this.parseTopicReferenceThenEqualsSign(54, "%");
              case 32:
                return this.parseTopicReferenceThenEqualsSign(44, "^");
              case 37:
              case 38:
                return this.parseTopicReference("hack");
              case 44:
              case 54:
              case 27: {
                let r2 = this.getPluginOption("pipelineOperator", "proposal");
                if (r2)
                  return this.parseTopicReference(r2);
                this.unexpected();
                break;
              }
              case 47: {
                let r2 = this.input.codePointAt(this.nextTokenStart());
                _3(r2) || r2 === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
                break;
              }
              default:
                if (w2(i2)) {
                  if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
                    return this.parseModuleExpression();
                  let r2 = this.state.potentialArrowAt === this.state.start, n2 = this.state.containsEsc, o2 = this.parseIdentifier();
                  if (!n2 && o2.name === "async" && !this.canInsertSemicolon()) {
                    let { type: h2 } = this.state;
                    if (h2 === 68)
                      return this.resetPreviousNodeTrailingComments(o2), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(o2));
                    if (w2(h2))
                      return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(o2)) : o2;
                    if (h2 === 90)
                      return this.resetPreviousNodeTrailingComments(o2), this.parseDo(this.startNodeAtNode(o2), true);
                  }
                  return r2 && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(o2), [o2], false)) : o2;
                } else
                  this.unexpected();
            }
          }
          parseTopicReferenceThenEqualsSign(t2, e2) {
            let s2 = this.getPluginOption("pipelineOperator", "proposal");
            if (s2)
              return this.state.type = t2, this.state.value = e2, this.state.pos--, this.state.end--, this.state.endLoc = v2(this.state.endLoc, -1), this.parseTopicReference(s2);
            this.unexpected();
          }
          parseTopicReference(t2) {
            let e2 = this.startNode(), s2 = this.state.startLoc, i2 = this.state.type;
            return this.next(), this.finishTopicReference(e2, s2, t2, i2);
          }
          finishTopicReference(t2, e2, s2, i2) {
            if (this.testTopicReferenceConfiguration(s2, e2, i2)) {
              let r2 = s2 === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
              return this.topicReferenceIsAllowedInCurrentContext() || this.raise(s2 === "smart" ? p2.PrimaryTopicNotAllowed : p2.PipeTopicUnbound, e2), this.registerTopicReference(), this.finishNode(t2, r2);
            } else
              throw this.raise(p2.PipeTopicUnconfiguredToken, e2, { token: K2(i2) });
          }
          testTopicReferenceConfiguration(t2, e2, s2) {
            switch (t2) {
              case "hack":
                return this.hasPlugin(["pipelineOperator", { topicToken: K2(s2) }]);
              case "smart":
                return s2 === 27;
              default:
                throw this.raise(p2.PipeTopicRequiresHackPipes, e2);
            }
          }
          parseAsyncArrowUnaryFunction(t2) {
            this.prodParam.enter(ke3(true, this.prodParam.hasYield));
            let e2 = [this.parseIdentifier()];
            return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(p2.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(t2, e2, true);
          }
          parseDo(t2, e2) {
            this.expectPlugin("doExpressions"), e2 && this.expectPlugin("asyncDoExpressions"), t2.async = e2, this.next();
            let s2 = this.state.labels;
            return this.state.labels = [], e2 ? (this.prodParam.enter(2), t2.body = this.parseBlock(), this.prodParam.exit()) : t2.body = this.parseBlock(), this.state.labels = s2, this.finishNode(t2, "DoExpression");
          }
          parseSuper() {
            let t2 = this.startNode();
            return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(p2.SuperNotAllowed, t2) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(p2.UnexpectedSuper, t2), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(p2.UnsupportedSuper, t2), this.finishNode(t2, "Super");
          }
          parsePrivateName() {
            let t2 = this.startNode(), e2 = this.startNodeAt(v2(this.state.startLoc, 1)), s2 = this.state.value;
            return this.next(), t2.id = this.createIdentifier(e2, s2), this.finishNode(t2, "PrivateName");
          }
          parseFunctionOrFunctionSent() {
            let t2 = this.startNode();
            if (this.next(), this.prodParam.hasYield && this.match(16)) {
              let e2 = this.createIdentifier(this.startNodeAtNode(t2), "function");
              return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(t2, e2, "sent");
            }
            return this.parseFunction(t2);
          }
          parseMetaProperty(t2, e2, s2) {
            t2.meta = e2;
            let i2 = this.state.containsEsc;
            return t2.property = this.parseIdentifier(true), (t2.property.name !== s2 || i2) && this.raise(p2.UnsupportedMetaProperty, t2.property, { target: e2.name, onlyValidPropertyName: s2 }), this.finishNode(t2, "MetaProperty");
          }
          parseImportMetaProperty(t2) {
            let e2 = this.createIdentifier(this.startNodeAtNode(t2), "import");
            if (this.next(), this.isContextual(101))
              this.inModule || this.raise(p2.ImportMetaOutsideModule, e2), this.sawUnambiguousESM = true;
            else if (this.isContextual(105) || this.isContextual(97)) {
              let s2 = this.isContextual(105);
              if (s2 || this.unexpected(), this.expectPlugin(s2 ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions)
                throw this.raise(p2.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, { phase: this.state.value });
              return this.next(), t2.phase = s2 ? "source" : "defer", this.parseImportCall(t2);
            }
            return this.parseMetaProperty(t2, e2, "meta");
          }
          parseLiteralAtNode(t2, e2, s2) {
            return this.addExtra(s2, "rawValue", t2), this.addExtra(s2, "raw", this.input.slice(s2.start, this.state.end)), s2.value = t2, this.next(), this.finishNode(s2, e2);
          }
          parseLiteral(t2, e2) {
            let s2 = this.startNode();
            return this.parseLiteralAtNode(t2, e2, s2);
          }
          parseStringLiteral(t2) {
            return this.parseLiteral(t2, "StringLiteral");
          }
          parseNumericLiteral(t2) {
            return this.parseLiteral(t2, "NumericLiteral");
          }
          parseBigIntLiteral(t2) {
            return this.parseLiteral(t2, "BigIntLiteral");
          }
          parseDecimalLiteral(t2) {
            return this.parseLiteral(t2, "DecimalLiteral");
          }
          parseRegExpLiteral(t2) {
            let e2 = this.startNode();
            return this.addExtra(e2, "raw", this.input.slice(e2.start, this.state.end)), e2.pattern = t2.pattern, e2.flags = t2.flags, this.next(), this.finishNode(e2, "RegExpLiteral");
          }
          parseBooleanLiteral(t2) {
            let e2 = this.startNode();
            return e2.value = t2, this.next(), this.finishNode(e2, "BooleanLiteral");
          }
          parseNullLiteral() {
            let t2 = this.startNode();
            return this.next(), this.finishNode(t2, "NullLiteral");
          }
          parseParenAndDistinguishExpression(t2) {
            let e2 = this.state.startLoc, s2;
            this.next(), this.expressionScope.enter(Oi2());
            let i2 = this.state.maybeInArrowParameters, r2 = this.state.inFSharpPipelineDirectBody;
            this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
            let n2 = this.state.startLoc, o2 = [], h2 = new Z3(), c2 = true, l2, u2;
            for (; !this.match(11); ) {
              if (c2)
                c2 = false;
              else if (this.expect(12, h2.optionalParametersLoc === null ? null : h2.optionalParametersLoc), this.match(11)) {
                u2 = this.state.startLoc;
                break;
              }
              if (this.match(21)) {
                let y3 = this.state.startLoc;
                if (l2 = this.state.startLoc, o2.push(this.parseParenItem(this.parseRestBinding(), y3)), !this.checkCommaAfterRest(41))
                  break;
              } else
                o2.push(this.parseMaybeAssignAllowIn(h2, this.parseParenItem));
            }
            let f2 = this.state.lastTokEndLoc;
            this.expect(11), this.state.maybeInArrowParameters = i2, this.state.inFSharpPipelineDirectBody = r2;
            let d2 = this.startNodeAt(e2);
            return t2 && this.shouldParseArrow(o2) && (d2 = this.parseArrow(d2)) ? (this.checkDestructuringPrivate(h2), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(d2, o2, false), d2) : (this.expressionScope.exit(), o2.length || this.unexpected(this.state.lastTokStartLoc), u2 && this.unexpected(u2), l2 && this.unexpected(l2), this.checkExpressionErrors(h2, true), this.toReferencedListDeep(o2, true), o2.length > 1 ? (s2 = this.startNodeAt(n2), s2.expressions = o2, this.finishNode(s2, "SequenceExpression"), this.resetEndLocation(s2, f2)) : s2 = o2[0], this.wrapParenthesis(e2, s2));
          }
          wrapParenthesis(t2, e2) {
            if (!this.options.createParenthesizedExpressions)
              return this.addExtra(e2, "parenthesized", true), this.addExtra(e2, "parenStart", t2.index), this.takeSurroundingComments(e2, t2.index, this.state.lastTokEndLoc.index), e2;
            let s2 = this.startNodeAt(t2);
            return s2.expression = e2, this.finishNode(s2, "ParenthesizedExpression");
          }
          shouldParseArrow(t2) {
            return !this.canInsertSemicolon();
          }
          parseArrow(t2) {
            if (this.eat(19))
              return t2;
          }
          parseParenItem(t2, e2) {
            return t2;
          }
          parseNewOrNewTarget() {
            let t2 = this.startNode();
            if (this.next(), this.match(16)) {
              let e2 = this.createIdentifier(this.startNodeAtNode(t2), "new");
              this.next();
              let s2 = this.parseMetaProperty(t2, e2, "target");
              return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(p2.UnexpectedNewTarget, s2), s2;
            }
            return this.parseNew(t2);
          }
          parseNew(t2) {
            if (this.parseNewCallee(t2), this.eat(10)) {
              let e2 = this.parseExprList(11);
              this.toReferencedList(e2), t2.arguments = e2;
            } else
              t2.arguments = [];
            return this.finishNode(t2, "NewExpression");
          }
          parseNewCallee(t2) {
            let e2 = this.match(83), s2 = this.parseNoCallExpr();
            t2.callee = s2, e2 && (s2.type === "Import" || s2.type === "ImportExpression") && this.raise(p2.ImportCallNotNewExpression, s2);
          }
          parseTemplateElement(t2) {
            let { start: e2, startLoc: s2, end: i2, value: r2 } = this.state, n2 = e2 + 1, o2 = this.startNodeAt(v2(s2, 1));
            r2 === null && (t2 || this.raise(p2.InvalidEscapeSequenceTemplate, v2(this.state.firstInvalidTemplateEscapePos, 1)));
            let h2 = this.match(24), c2 = h2 ? -1 : -2, l2 = i2 + c2;
            o2.value = { raw: this.input.slice(n2, l2).replace(/\r\n?/g, `
`), cooked: r2 === null ? null : r2.slice(1, c2) }, o2.tail = h2, this.next();
            let u2 = this.finishNode(o2, "TemplateElement");
            return this.resetEndLocation(u2, v2(this.state.lastTokEndLoc, c2)), u2;
          }
          parseTemplate(t2) {
            let e2 = this.startNode(), s2 = this.parseTemplateElement(t2), i2 = [s2], r2 = [];
            for (; !s2.tail; )
              r2.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), i2.push(s2 = this.parseTemplateElement(t2));
            return e2.expressions = r2, e2.quasis = i2, this.finishNode(e2, "TemplateLiteral");
          }
          parseTemplateSubstitution() {
            return this.parseExpression();
          }
          parseObjectLike(t2, e2, s2, i2) {
            s2 && this.expectPlugin("recordAndTuple");
            let r2 = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            let n2 = /* @__PURE__ */ Object.create(null), o2 = true, h2 = this.startNode();
            for (h2.properties = [], this.next(); !this.match(t2); ) {
              if (o2)
                o2 = false;
              else if (this.expect(12), this.match(t2)) {
                this.addTrailingCommaExtraToNode(h2);
                break;
              }
              let l2;
              e2 ? l2 = this.parseBindingProperty() : (l2 = this.parsePropertyDefinition(i2), this.checkProto(l2, s2, n2, i2)), s2 && !this.isObjectProperty(l2) && l2.type !== "SpreadElement" && this.raise(p2.InvalidRecordProperty, l2), l2.shorthand && this.addExtra(l2, "shorthand", true), h2.properties.push(l2);
            }
            this.next(), this.state.inFSharpPipelineDirectBody = r2;
            let c2 = "ObjectExpression";
            return e2 ? c2 = "ObjectPattern" : s2 && (c2 = "RecordExpression"), this.finishNode(h2, c2);
          }
          addTrailingCommaExtraToNode(t2) {
            this.addExtra(t2, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(t2, "trailingCommaLoc", this.state.lastTokStartLoc, false);
          }
          maybeAsyncOrAccessorProp(t2) {
            return !t2.computed && t2.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
          }
          parsePropertyDefinition(t2) {
            let e2 = [];
            if (this.match(26))
              for (this.hasPlugin("decorators") && this.raise(p2.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
                e2.push(this.parseDecorator());
            let s2 = this.startNode(), i2 = false, r2 = false, n2;
            if (this.match(21))
              return e2.length && this.unexpected(), this.parseSpread();
            e2.length && (s2.decorators = e2, e2 = []), s2.method = false, t2 && (n2 = this.state.startLoc);
            let o2 = this.eat(55);
            this.parsePropertyNamePrefixOperator(s2);
            let h2 = this.state.containsEsc;
            if (this.parsePropertyName(s2, t2), !o2 && !h2 && this.maybeAsyncOrAccessorProp(s2)) {
              let { key: c2 } = s2, l2 = c2.name;
              l2 === "async" && !this.hasPrecedingLineBreak() && (i2 = true, this.resetPreviousNodeTrailingComments(c2), o2 = this.eat(55), this.parsePropertyName(s2)), (l2 === "get" || l2 === "set") && (r2 = true, this.resetPreviousNodeTrailingComments(c2), s2.kind = l2, this.match(55) && (o2 = true, this.raise(p2.AccessorIsGenerator, this.state.curPosition(), { kind: l2 }), this.next()), this.parsePropertyName(s2));
            }
            return this.parseObjPropValue(s2, n2, o2, i2, false, r2, t2);
          }
          getGetterSetterExpectedParamCount(t2) {
            return t2.kind === "get" ? 0 : 1;
          }
          getObjectOrClassMethodParams(t2) {
            return t2.params;
          }
          checkGetterSetterParams(t2) {
            var e2;
            let s2 = this.getGetterSetterExpectedParamCount(t2), i2 = this.getObjectOrClassMethodParams(t2);
            i2.length !== s2 && this.raise(t2.kind === "get" ? p2.BadGetterArity : p2.BadSetterArity, t2), t2.kind === "set" && ((e2 = i2[i2.length - 1]) == null ? void 0 : e2.type) === "RestElement" && this.raise(p2.BadSetterRestParameter, t2);
          }
          parseObjectMethod(t2, e2, s2, i2, r2) {
            if (r2) {
              let n2 = this.parseMethod(t2, e2, false, false, false, "ObjectMethod");
              return this.checkGetterSetterParams(n2), n2;
            }
            if (s2 || e2 || this.match(10))
              return i2 && this.unexpected(), t2.kind = "method", t2.method = true, this.parseMethod(t2, e2, s2, false, false, "ObjectMethod");
          }
          parseObjectProperty(t2, e2, s2, i2) {
            if (t2.shorthand = false, this.eat(14))
              return t2.value = s2 ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(i2), this.finishNode(t2, "ObjectProperty");
            if (!t2.computed && t2.key.type === "Identifier") {
              if (this.checkReservedWord(t2.key.name, t2.key.loc.start, true, false), s2)
                t2.value = this.parseMaybeDefault(e2, $2(t2.key));
              else if (this.match(29)) {
                let r2 = this.state.startLoc;
                i2 != null ? i2.shorthandAssignLoc === null && (i2.shorthandAssignLoc = r2) : this.raise(p2.InvalidCoverInitializedName, r2), t2.value = this.parseMaybeDefault(e2, $2(t2.key));
              } else
                t2.value = $2(t2.key);
              return t2.shorthand = true, this.finishNode(t2, "ObjectProperty");
            }
          }
          parseObjPropValue(t2, e2, s2, i2, r2, n2, o2) {
            let h2 = this.parseObjectMethod(t2, s2, i2, r2, n2) || this.parseObjectProperty(t2, e2, r2, o2);
            return h2 || this.unexpected(), h2;
          }
          parsePropertyName(t2, e2) {
            if (this.eat(0))
              t2.computed = true, t2.key = this.parseMaybeAssignAllowIn(), this.expect(3);
            else {
              let { type: s2, value: i2 } = this.state, r2;
              if (M3(s2))
                r2 = this.parseIdentifier(true);
              else
                switch (s2) {
                  case 134:
                    r2 = this.parseNumericLiteral(i2);
                    break;
                  case 133:
                    r2 = this.parseStringLiteral(i2);
                    break;
                  case 135:
                    r2 = this.parseBigIntLiteral(i2);
                    break;
                  case 136:
                    r2 = this.parseDecimalLiteral(i2);
                    break;
                  case 138: {
                    let n2 = this.state.startLoc;
                    e2 != null ? e2.privateKeyLoc === null && (e2.privateKeyLoc = n2) : this.raise(p2.UnexpectedPrivateField, n2), r2 = this.parsePrivateName();
                    break;
                  }
                  default:
                    this.unexpected();
                }
              t2.key = r2, s2 !== 138 && (t2.computed = false);
            }
          }
          initFunction(t2, e2) {
            t2.id = null, t2.generator = false, t2.async = e2;
          }
          parseMethod(t2, e2, s2, i2, r2, n2, o2 = false) {
            this.initFunction(t2, s2), t2.generator = e2, this.scope.enter(18 | (o2 ? 64 : 0) | (r2 ? 32 : 0)), this.prodParam.enter(ke3(s2, t2.generator)), this.parseFunctionParams(t2, i2);
            let h2 = this.parseFunctionBodyAndFinish(t2, n2, true);
            return this.prodParam.exit(), this.scope.exit(), h2;
          }
          parseArrayLike(t2, e2, s2, i2) {
            s2 && this.expectPlugin("recordAndTuple");
            let r2 = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            let n2 = this.startNode();
            return this.next(), n2.elements = this.parseExprList(t2, !s2, i2, n2), this.state.inFSharpPipelineDirectBody = r2, this.finishNode(n2, s2 ? "TupleExpression" : "ArrayExpression");
          }
          parseArrowExpression(t2, e2, s2, i2) {
            this.scope.enter(6);
            let r2 = ke3(s2, false);
            !this.match(5) && this.prodParam.hasIn && (r2 |= 8), this.prodParam.enter(r2), this.initFunction(t2, s2);
            let n2 = this.state.maybeInArrowParameters;
            return e2 && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(t2, e2, i2)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(t2, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = n2, this.finishNode(t2, "ArrowFunctionExpression");
          }
          setArrowFunctionParameters(t2, e2, s2) {
            this.toAssignableList(e2, s2, false), t2.params = e2;
          }
          parseFunctionBodyAndFinish(t2, e2, s2 = false) {
            return this.parseFunctionBody(t2, false, s2), this.finishNode(t2, e2);
          }
          parseFunctionBody(t2, e2, s2 = false) {
            let i2 = e2 && !this.match(5);
            if (this.expressionScope.enter(rs()), i2)
              t2.body = this.parseMaybeAssign(), this.checkParams(t2, false, e2, false);
            else {
              let r2 = this.state.strict, n2 = this.state.labels;
              this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), t2.body = this.parseBlock(true, false, (o2) => {
                let h2 = !this.isSimpleParamList(t2.params);
                o2 && h2 && this.raise(p2.IllegalLanguageModeDirective, (t2.kind === "method" || t2.kind === "constructor") && t2.key ? t2.key.loc.end : t2);
                let c2 = !r2 && this.state.strict;
                this.checkParams(t2, !this.state.strict && !e2 && !s2 && !h2, e2, c2), this.state.strict && t2.id && this.checkIdentifier(t2.id, 65, c2);
              }), this.prodParam.exit(), this.state.labels = n2;
            }
            this.expressionScope.exit();
          }
          isSimpleParameter(t2) {
            return t2.type === "Identifier";
          }
          isSimpleParamList(t2) {
            for (let e2 = 0, s2 = t2.length; e2 < s2; e2++)
              if (!this.isSimpleParameter(t2[e2]))
                return false;
            return true;
          }
          checkParams(t2, e2, s2, i2 = true) {
            let r2 = !e2 && /* @__PURE__ */ new Set(), n2 = { type: "FormalParameters" };
            for (let o2 of t2.params)
              this.checkLVal(o2, { in: n2, binding: 5, checkClashes: r2, strictModeChanged: i2 });
          }
          parseExprList(t2, e2, s2, i2) {
            let r2 = [], n2 = true;
            for (; !this.eat(t2); ) {
              if (n2)
                n2 = false;
              else if (this.expect(12), this.match(t2)) {
                i2 && this.addTrailingCommaExtraToNode(i2), this.next();
                break;
              }
              r2.push(this.parseExprListItem(e2, s2));
            }
            return r2;
          }
          parseExprListItem(t2, e2, s2) {
            let i2;
            if (this.match(12))
              t2 || this.raise(p2.UnexpectedToken, this.state.curPosition(), { unexpected: "," }), i2 = null;
            else if (this.match(21)) {
              let r2 = this.state.startLoc;
              i2 = this.parseParenItem(this.parseSpread(e2), r2);
            } else if (this.match(17)) {
              this.expectPlugin("partialApplication"), s2 || this.raise(p2.UnexpectedArgumentPlaceholder, this.state.startLoc);
              let r2 = this.startNode();
              this.next(), i2 = this.finishNode(r2, "ArgumentPlaceholder");
            } else
              i2 = this.parseMaybeAssignAllowIn(e2, this.parseParenItem);
            return i2;
          }
          parseIdentifier(t2) {
            let e2 = this.startNode(), s2 = this.parseIdentifierName(t2);
            return this.createIdentifier(e2, s2);
          }
          createIdentifier(t2, e2) {
            return t2.name = e2, t2.loc.identifierName = e2, this.finishNode(t2, "Identifier");
          }
          parseIdentifierName(t2) {
            let e2, { startLoc: s2, type: i2 } = this.state;
            M3(i2) ? e2 = this.state.value : this.unexpected();
            let r2 = oi2(i2);
            return t2 ? r2 && this.replaceToken(132) : this.checkReservedWord(e2, s2, r2, false), this.next(), e2;
          }
          checkReservedWord(t2, e2, s2, i2) {
            if (t2.length > 10 || !Ei(t2))
              return;
            if (s2 && Si2(t2)) {
              this.raise(p2.UnexpectedKeyword, e2, { keyword: t2 });
              return;
            }
            if ((this.state.strict ? i2 ? Zt : Yt2 : Gt2)(t2, this.inModule)) {
              this.raise(p2.UnexpectedReservedWord, e2, { reservedWord: t2 });
              return;
            } else if (t2 === "yield") {
              if (this.prodParam.hasYield) {
                this.raise(p2.YieldBindingIdentifier, e2);
                return;
              }
            } else if (t2 === "await") {
              if (this.prodParam.hasAwait) {
                this.raise(p2.AwaitBindingIdentifier, e2);
                return;
              }
              if (this.scope.inStaticBlock) {
                this.raise(p2.AwaitBindingIdentifierInStaticBlock, e2);
                return;
              }
              this.expressionScope.recordAsyncArrowParametersError(e2);
            } else if (t2 === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
              this.raise(p2.ArgumentsInClass, e2);
              return;
            }
          }
          isAwaitAllowed() {
            return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
          }
          parseAwait(t2) {
            let e2 = this.startNodeAt(t2);
            return this.expressionScope.recordParameterInitializerError(p2.AwaitExpressionFormalParameter, e2), this.eat(55) && this.raise(p2.ObsoleteAwaitStar, e2), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (e2.argument = this.parseMaybeUnary(null, true)), this.finishNode(e2, "AwaitExpression");
          }
          isAmbiguousAwait() {
            if (this.hasPrecedingLineBreak())
              return true;
            let { type: t2 } = this.state;
            return t2 === 53 || t2 === 10 || t2 === 0 || Le3(t2) || t2 === 102 && !this.state.containsEsc || t2 === 137 || t2 === 56 || this.hasPlugin("v8intrinsic") && t2 === 54;
          }
          parseYield() {
            let t2 = this.startNode();
            this.expressionScope.recordParameterInitializerError(p2.YieldInParameter, t2), this.next();
            let e2 = false, s2 = null;
            if (!this.hasPrecedingLineBreak())
              switch (e2 = this.eat(55), this.state.type) {
                case 13:
                case 139:
                case 8:
                case 11:
                case 3:
                case 9:
                case 14:
                case 12:
                  if (!e2)
                    break;
                default:
                  s2 = this.parseMaybeAssign();
              }
            return t2.delegate = e2, t2.argument = s2, this.finishNode(t2, "YieldExpression");
          }
          parseImportCall(t2) {
            return this.next(), t2.source = this.parseMaybeAssignAllowIn(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (t2.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (t2.options = this.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11), this.finishNode(t2, "ImportExpression");
          }
          checkPipelineAtInfixOperator(t2, e2) {
            this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) && t2.type === "SequenceExpression" && this.raise(p2.PipelineHeadSequenceExpression, e2);
          }
          parseSmartPipelineBodyInStyle(t2, e2) {
            if (this.isSimpleReference(t2)) {
              let s2 = this.startNodeAt(e2);
              return s2.callee = t2, this.finishNode(s2, "PipelineBareFunction");
            } else {
              let s2 = this.startNodeAt(e2);
              return this.checkSmartPipeTopicBodyEarlyErrors(e2), s2.expression = t2, this.finishNode(s2, "PipelineTopicExpression");
            }
          }
          isSimpleReference(t2) {
            switch (t2.type) {
              case "MemberExpression":
                return !t2.computed && this.isSimpleReference(t2.object);
              case "Identifier":
                return true;
              default:
                return false;
            }
          }
          checkSmartPipeTopicBodyEarlyErrors(t2) {
            if (this.match(19))
              throw this.raise(p2.PipelineBodyNoArrow, this.state.startLoc);
            this.topicReferenceWasUsedInCurrentContext() || this.raise(p2.PipelineTopicUnused, t2);
          }
          withTopicBindingContext(t2) {
            let e2 = this.state.topicContext;
            this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
            try {
              return t2();
            } finally {
              this.state.topicContext = e2;
            }
          }
          withSmartMixTopicForbiddingContext(t2) {
            if (this.hasPlugin(["pipelineOperator", { proposal: "smart" }])) {
              let e2 = this.state.topicContext;
              this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
              try {
                return t2();
              } finally {
                this.state.topicContext = e2;
              }
            } else
              return t2();
          }
          withSoloAwaitPermittingContext(t2) {
            let e2 = this.state.soloAwait;
            this.state.soloAwait = true;
            try {
              return t2();
            } finally {
              this.state.soloAwait = e2;
            }
          }
          allowInAnd(t2) {
            let e2 = this.prodParam.currentFlags();
            if (8 & ~e2) {
              this.prodParam.enter(e2 | 8);
              try {
                return t2();
              } finally {
                this.prodParam.exit();
              }
            }
            return t2();
          }
          disallowInAnd(t2) {
            let e2 = this.prodParam.currentFlags();
            if (8 & e2) {
              this.prodParam.enter(e2 & -9);
              try {
                return t2();
              } finally {
                this.prodParam.exit();
              }
            }
            return t2();
          }
          registerTopicReference() {
            this.state.topicContext.maxTopicIndex = 0;
          }
          topicReferenceIsAllowedInCurrentContext() {
            return this.state.topicContext.maxNumOfResolvableTopics >= 1;
          }
          topicReferenceWasUsedInCurrentContext() {
            return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
          }
          parseFSharpPipelineBody(t2) {
            let e2 = this.state.startLoc;
            this.state.potentialArrowAt = this.state.start;
            let s2 = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = true;
            let i2 = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), e2, t2);
            return this.state.inFSharpPipelineDirectBody = s2, i2;
          }
          parseModuleExpression() {
            this.expectPlugin("moduleBlocks");
            let t2 = this.startNode();
            this.next(), this.match(5) || this.unexpected(null, 5);
            let e2 = this.startNodeAt(this.state.endLoc);
            this.next();
            let s2 = this.initializeScopes(true);
            this.enterInitialScopes();
            try {
              t2.body = this.parseProgram(e2, 8, "module");
            } finally {
              s2();
            }
            return this.finishNode(t2, "ModuleExpression");
          }
          parsePropertyNamePrefixOperator(t2) {
          }
        }, ze2 = { kind: 1 }, ar3 = { kind: 2 }, nr2 = /[\uD800-\uDFFF]/u, Ke3 = /in(?:stanceof)?/y;
        function or3(a2, t2) {
          for (let e2 = 0; e2 < a2.length; e2++) {
            let s2 = a2[e2], { type: i2 } = s2;
            if (typeof i2 == "number") {
              {
                if (i2 === 138) {
                  let { loc: r2, start: n2, value: o2, end: h2 } = s2, c2 = n2 + 1, l2 = v2(r2.start, 1);
                  a2.splice(e2, 1, new O2({ type: R3(27), value: "#", start: n2, end: c2, startLoc: r2.start, endLoc: l2 }), new O2({ type: R3(132), value: o2, start: c2, end: h2, startLoc: l2, endLoc: r2.end })), e2++;
                  continue;
                }
                if (Le3(i2)) {
                  let { loc: r2, start: n2, value: o2, end: h2 } = s2, c2 = n2 + 1, l2 = v2(r2.start, 1), u2;
                  t2.charCodeAt(n2) === 96 ? u2 = new O2({ type: R3(22), value: "`", start: n2, end: c2, startLoc: r2.start, endLoc: l2 }) : u2 = new O2({ type: R3(8), value: "}", start: n2, end: c2, startLoc: r2.start, endLoc: l2 });
                  let f2, d2, y3, E2;
                  i2 === 24 ? (d2 = h2 - 1, y3 = v2(r2.end, -1), f2 = o2 === null ? null : o2.slice(1, -1), E2 = new O2({ type: R3(22), value: "`", start: d2, end: h2, startLoc: y3, endLoc: r2.end })) : (d2 = h2 - 2, y3 = v2(r2.end, -2), f2 = o2 === null ? null : o2.slice(1, -2), E2 = new O2({ type: R3(23), value: "${", start: d2, end: h2, startLoc: y3, endLoc: r2.end })), a2.splice(e2, 1, u2, new O2({ type: R3(20), value: f2, start: c2, end: d2, startLoc: l2, endLoc: y3 }), E2), e2 += 2;
                  continue;
                }
              }
              s2.type = R3(i2);
            }
          }
          return a2;
        }
        var pt3 = class extends ct3 {
          parseTopLevel(t2, e2) {
            return t2.program = this.parseProgram(e2), t2.comments = this.comments, this.options.tokens && (t2.tokens = or3(this.tokens, this.input)), this.finishNode(t2, "File");
          }
          parseProgram(t2, e2 = 139, s2 = this.options.sourceType) {
            if (t2.sourceType = s2, t2.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(t2, true, true, e2), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
              for (let [r2, n2] of Array.from(this.scope.undefinedExports))
                this.raise(p2.ModuleExportUndefined, n2, { localName: r2 });
            let i2;
            return e2 === 139 ? i2 = this.finishNode(t2, "Program") : i2 = this.finishNodeAt(t2, "Program", v2(this.state.startLoc, -1)), i2;
          }
          stmtToDirective(t2) {
            let e2 = t2;
            e2.type = "Directive", e2.value = e2.expression, delete e2.expression;
            let s2 = e2.value, i2 = s2.value, r2 = this.input.slice(s2.start, s2.end), n2 = s2.value = r2.slice(1, -1);
            return this.addExtra(s2, "raw", r2), this.addExtra(s2, "rawValue", n2), this.addExtra(s2, "expressionValue", i2), s2.type = "DirectiveLiteral", e2;
          }
          parseInterpreterDirective() {
            if (!this.match(28))
              return null;
            let t2 = this.startNode();
            return t2.value = this.state.value, this.next(), this.finishNode(t2, "InterpreterDirective");
          }
          isLet() {
            return this.isContextual(100) ? this.hasFollowingBindingAtom() : false;
          }
          chStartsBindingIdentifier(t2, e2) {
            if (_3(t2)) {
              if (Ke3.lastIndex = e2, Ke3.test(this.input)) {
                let s2 = this.codePointAtPos(Ke3.lastIndex);
                if (!Q3(s2) && s2 !== 92)
                  return false;
              }
              return true;
            } else
              return t2 === 92;
          }
          chStartsBindingPattern(t2) {
            return t2 === 91 || t2 === 123;
          }
          hasFollowingBindingAtom() {
            let t2 = this.nextTokenStart(), e2 = this.codePointAtPos(t2);
            return this.chStartsBindingPattern(e2) || this.chStartsBindingIdentifier(e2, t2);
          }
          hasInLineFollowingBindingIdentifierOrBrace() {
            let t2 = this.nextTokenInLineStart(), e2 = this.codePointAtPos(t2);
            return e2 === 123 || this.chStartsBindingIdentifier(e2, t2);
          }
          startsUsingForOf() {
            let { type: t2, containsEsc: e2 } = this.lookahead();
            if (t2 === 102 && !e2)
              return false;
            if (w2(t2) && !this.hasFollowingLineBreak())
              return this.expectPlugin("explicitResourceManagement"), true;
          }
          startsAwaitUsing() {
            let t2 = this.nextTokenInLineStart();
            if (this.isUnparsedContextual(t2, "using")) {
              t2 = this.nextTokenInLineStartSince(t2 + 5);
              let e2 = this.codePointAtPos(t2);
              if (this.chStartsBindingIdentifier(e2, t2))
                return this.expectPlugin("explicitResourceManagement"), true;
            }
            return false;
          }
          parseModuleItem() {
            return this.parseStatementLike(15);
          }
          parseStatementListItem() {
            return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
          }
          parseStatementOrSloppyAnnexBFunctionDeclaration(t2 = false) {
            let e2 = 0;
            return this.options.annexB && !this.state.strict && (e2 |= 4, t2 && (e2 |= 8)), this.parseStatementLike(e2);
          }
          parseStatement() {
            return this.parseStatementLike(0);
          }
          parseStatementLike(t2) {
            let e2 = null;
            return this.match(26) && (e2 = this.parseDecorators(true)), this.parseStatementContent(t2, e2);
          }
          parseStatementContent(t2, e2) {
            let s2 = this.state.type, i2 = this.startNode(), r2 = !!(t2 & 2), n2 = !!(t2 & 4), o2 = t2 & 1;
            switch (s2) {
              case 60:
                return this.parseBreakContinueStatement(i2, true);
              case 63:
                return this.parseBreakContinueStatement(i2, false);
              case 64:
                return this.parseDebuggerStatement(i2);
              case 90:
                return this.parseDoWhileStatement(i2);
              case 91:
                return this.parseForStatement(i2);
              case 68:
                if (this.lookaheadCharCode() === 46)
                  break;
                return n2 || this.raise(this.state.strict ? p2.StrictFunction : this.options.annexB ? p2.SloppyFunctionAnnexB : p2.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(i2, false, !r2 && n2);
              case 80:
                return r2 || this.unexpected(), this.parseClass(this.maybeTakeDecorators(e2, i2), true);
              case 69:
                return this.parseIfStatement(i2);
              case 70:
                return this.parseReturnStatement(i2);
              case 71:
                return this.parseSwitchStatement(i2);
              case 72:
                return this.parseThrowStatement(i2);
              case 73:
                return this.parseTryStatement(i2);
              case 96:
                if (!this.state.containsEsc && this.startsAwaitUsing())
                  return this.isAwaitAllowed() ? r2 || this.raise(p2.UnexpectedLexicalDeclaration, i2) : this.raise(p2.AwaitUsingNotInAsyncContext, i2), this.next(), this.parseVarStatement(i2, "await using");
                break;
              case 107:
                if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace())
                  break;
                return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(p2.UnexpectedUsingDeclaration, this.state.startLoc) : r2 || this.raise(p2.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(i2, "using");
              case 100: {
                if (this.state.containsEsc)
                  break;
                let l2 = this.nextTokenStart(), u2 = this.codePointAtPos(l2);
                if (u2 !== 91 && (!r2 && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(u2, l2) && u2 !== 123))
                  break;
              }
              case 75:
                r2 || this.raise(p2.UnexpectedLexicalDeclaration, this.state.startLoc);
              case 74: {
                let l2 = this.state.value;
                return this.parseVarStatement(i2, l2);
              }
              case 92:
                return this.parseWhileStatement(i2);
              case 76:
                return this.parseWithStatement(i2);
              case 5:
                return this.parseBlock();
              case 13:
                return this.parseEmptyStatement(i2);
              case 83: {
                let l2 = this.lookaheadCharCode();
                if (l2 === 40 || l2 === 46)
                  break;
              }
              case 82: {
                !this.options.allowImportExportEverywhere && !o2 && this.raise(p2.UnexpectedImportExport, this.state.startLoc), this.next();
                let l2;
                return s2 === 83 ? (l2 = this.parseImport(i2), l2.type === "ImportDeclaration" && (!l2.importKind || l2.importKind === "value") && (this.sawUnambiguousESM = true)) : (l2 = this.parseExport(i2, e2), (l2.type === "ExportNamedDeclaration" && (!l2.exportKind || l2.exportKind === "value") || l2.type === "ExportAllDeclaration" && (!l2.exportKind || l2.exportKind === "value") || l2.type === "ExportDefaultDeclaration") && (this.sawUnambiguousESM = true)), this.assertModuleNodeAllowed(l2), l2;
              }
              default:
                if (this.isAsyncFunction())
                  return r2 || this.raise(p2.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(i2, true, !r2 && n2);
            }
            let h2 = this.state.value, c2 = this.parseExpression();
            return w2(s2) && c2.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(i2, h2, c2, t2) : this.parseExpressionStatement(i2, c2, e2);
          }
          assertModuleNodeAllowed(t2) {
            !this.options.allowImportExportEverywhere && !this.inModule && this.raise(p2.ImportOutsideModule, t2);
          }
          decoratorsEnabledBeforeExport() {
            return this.hasPlugin("decorators-legacy") ? true : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
          }
          maybeTakeDecorators(t2, e2, s2) {
            return t2 && (e2.decorators && e2.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(p2.DecoratorsBeforeAfterExport, e2.decorators[0]), e2.decorators.unshift(...t2)) : e2.decorators = t2, this.resetStartLocationFromNode(e2, t2[0]), s2 && this.resetStartLocationFromNode(s2, e2)), e2;
          }
          canHaveLeadingDecorator() {
            return this.match(80);
          }
          parseDecorators(t2) {
            let e2 = [];
            do
              e2.push(this.parseDecorator());
            while (this.match(26));
            if (this.match(82))
              t2 || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(p2.DecoratorExportClass, this.state.startLoc);
            else if (!this.canHaveLeadingDecorator())
              throw this.raise(p2.UnexpectedLeadingDecorator, this.state.startLoc);
            return e2;
          }
          parseDecorator() {
            this.expectOnePlugin(["decorators", "decorators-legacy"]);
            let t2 = this.startNode();
            if (this.next(), this.hasPlugin("decorators")) {
              let e2 = this.state.startLoc, s2;
              if (this.match(10)) {
                let i2 = this.state.startLoc;
                this.next(), s2 = this.parseExpression(), this.expect(11), s2 = this.wrapParenthesis(i2, s2);
                let r2 = this.state.startLoc;
                t2.expression = this.parseMaybeDecoratorArguments(s2), this.getPluginOption("decorators", "allowCallParenthesized") === false && t2.expression !== s2 && this.raise(p2.DecoratorArgumentsOutsideParentheses, r2);
              } else {
                for (s2 = this.parseIdentifier(false); this.eat(16); ) {
                  let i2 = this.startNodeAt(e2);
                  i2.object = s2, this.match(138) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), i2.property = this.parsePrivateName()) : i2.property = this.parseIdentifier(true), i2.computed = false, s2 = this.finishNode(i2, "MemberExpression");
                }
                t2.expression = this.parseMaybeDecoratorArguments(s2);
              }
            } else
              t2.expression = this.parseExprSubscripts();
            return this.finishNode(t2, "Decorator");
          }
          parseMaybeDecoratorArguments(t2) {
            if (this.eat(10)) {
              let e2 = this.startNodeAtNode(t2);
              return e2.callee = t2, e2.arguments = this.parseCallExpressionArguments(11, false), this.toReferencedList(e2.arguments), this.finishNode(e2, "CallExpression");
            }
            return t2;
          }
          parseBreakContinueStatement(t2, e2) {
            return this.next(), this.isLineTerminator() ? t2.label = null : (t2.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(t2, e2), this.finishNode(t2, e2 ? "BreakStatement" : "ContinueStatement");
          }
          verifyBreakContinue(t2, e2) {
            let s2;
            for (s2 = 0; s2 < this.state.labels.length; ++s2) {
              let i2 = this.state.labels[s2];
              if ((t2.label == null || i2.name === t2.label.name) && (i2.kind != null && (e2 || i2.kind === 1) || t2.label && e2))
                break;
            }
            if (s2 === this.state.labels.length) {
              let i2 = e2 ? "BreakStatement" : "ContinueStatement";
              this.raise(p2.IllegalBreakContinue, t2, { type: i2 });
            }
          }
          parseDebuggerStatement(t2) {
            return this.next(), this.semicolon(), this.finishNode(t2, "DebuggerStatement");
          }
          parseHeaderExpression() {
            this.expect(10);
            let t2 = this.parseExpression();
            return this.expect(11), t2;
          }
          parseDoWhileStatement(t2) {
            return this.next(), this.state.labels.push(ze2), t2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), t2.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(t2, "DoWhileStatement");
          }
          parseForStatement(t2) {
            this.next(), this.state.labels.push(ze2);
            let e2 = null;
            if (this.isAwaitAllowed() && this.eatContextual(96) && (e2 = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(13))
              return e2 !== null && this.unexpected(e2), this.parseFor(t2, null);
            let s2 = this.isContextual(100);
            {
              let h2 = this.isContextual(96) && this.startsAwaitUsing(), c2 = h2 || this.isContextual(107) && this.startsUsingForOf(), l2 = s2 && this.hasFollowingBindingAtom() || c2;
              if (this.match(74) || this.match(75) || l2) {
                let u2 = this.startNode(), f2;
                h2 ? (f2 = "await using", this.isAwaitAllowed() || this.raise(p2.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : f2 = this.state.value, this.next(), this.parseVar(u2, true, f2);
                let d2 = this.finishNode(u2, "VariableDeclaration"), y3 = this.match(58);
                return y3 && c2 && this.raise(p2.ForInUsing, d2), (y3 || this.isContextual(102)) && d2.declarations.length === 1 ? this.parseForIn(t2, d2, e2) : (e2 !== null && this.unexpected(e2), this.parseFor(t2, d2));
              }
            }
            let i2 = this.isContextual(95), r2 = new Z3(), n2 = this.parseExpression(true, r2), o2 = this.isContextual(102);
            if (o2 && (s2 && this.raise(p2.ForOfLet, n2), e2 === null && i2 && n2.type === "Identifier" && this.raise(p2.ForOfAsync, n2)), o2 || this.match(58)) {
              this.checkDestructuringPrivate(r2), this.toAssignable(n2, true);
              let h2 = o2 ? "ForOfStatement" : "ForInStatement";
              return this.checkLVal(n2, { in: { type: h2 } }), this.parseForIn(t2, n2, e2);
            } else
              this.checkExpressionErrors(r2, true);
            return e2 !== null && this.unexpected(e2), this.parseFor(t2, n2);
          }
          parseFunctionStatement(t2, e2, s2) {
            return this.next(), this.parseFunction(t2, 1 | (s2 ? 2 : 0) | (e2 ? 8 : 0));
          }
          parseIfStatement(t2) {
            return this.next(), t2.test = this.parseHeaderExpression(), t2.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), t2.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(t2, "IfStatement");
          }
          parseReturnStatement(t2) {
            return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(p2.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? t2.argument = null : (t2.argument = this.parseExpression(), this.semicolon()), this.finishNode(t2, "ReturnStatement");
          }
          parseSwitchStatement(t2) {
            this.next(), t2.discriminant = this.parseHeaderExpression();
            let e2 = t2.cases = [];
            this.expect(5), this.state.labels.push(ar3), this.scope.enter(0);
            let s2;
            for (let i2; !this.match(8); )
              if (this.match(61) || this.match(65)) {
                let r2 = this.match(61);
                s2 && this.finishNode(s2, "SwitchCase"), e2.push(s2 = this.startNode()), s2.consequent = [], this.next(), r2 ? s2.test = this.parseExpression() : (i2 && this.raise(p2.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), i2 = true, s2.test = null), this.expect(14);
              } else
                s2 ? s2.consequent.push(this.parseStatementListItem()) : this.unexpected();
            return this.scope.exit(), s2 && this.finishNode(s2, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t2, "SwitchStatement");
          }
          parseThrowStatement(t2) {
            return this.next(), this.hasPrecedingLineBreak() && this.raise(p2.NewlineAfterThrow, this.state.lastTokEndLoc), t2.argument = this.parseExpression(), this.semicolon(), this.finishNode(t2, "ThrowStatement");
          }
          parseCatchClauseParam() {
            let t2 = this.parseBindingAtom();
            return this.scope.enter(this.options.annexB && t2.type === "Identifier" ? 8 : 0), this.checkLVal(t2, { in: { type: "CatchClause" }, binding: 9 }), t2;
          }
          parseTryStatement(t2) {
            if (this.next(), t2.block = this.parseBlock(), t2.handler = null, this.match(62)) {
              let e2 = this.startNode();
              this.next(), this.match(10) ? (this.expect(10), e2.param = this.parseCatchClauseParam(), this.expect(11)) : (e2.param = null, this.scope.enter(0)), e2.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), t2.handler = this.finishNode(e2, "CatchClause");
            }
            return t2.finalizer = this.eat(67) ? this.parseBlock() : null, !t2.handler && !t2.finalizer && this.raise(p2.NoCatchOrFinally, t2), this.finishNode(t2, "TryStatement");
          }
          parseVarStatement(t2, e2, s2 = false) {
            return this.next(), this.parseVar(t2, false, e2, s2), this.semicolon(), this.finishNode(t2, "VariableDeclaration");
          }
          parseWhileStatement(t2) {
            return this.next(), t2.test = this.parseHeaderExpression(), this.state.labels.push(ze2), t2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(t2, "WhileStatement");
          }
          parseWithStatement(t2) {
            return this.state.strict && this.raise(p2.StrictWith, this.state.startLoc), this.next(), t2.object = this.parseHeaderExpression(), t2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(t2, "WithStatement");
          }
          parseEmptyStatement(t2) {
            return this.next(), this.finishNode(t2, "EmptyStatement");
          }
          parseLabeledStatement(t2, e2, s2, i2) {
            for (let n2 of this.state.labels)
              n2.name === e2 && this.raise(p2.LabelRedeclaration, s2, { labelName: e2 });
            let r2 = ci3(this.state.type) ? 1 : this.match(71) ? 2 : null;
            for (let n2 = this.state.labels.length - 1; n2 >= 0; n2--) {
              let o2 = this.state.labels[n2];
              if (o2.statementStart === t2.start)
                o2.statementStart = this.state.start, o2.kind = r2;
              else
                break;
            }
            return this.state.labels.push({ name: e2, kind: r2, statementStart: this.state.start }), t2.body = i2 & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement(), this.state.labels.pop(), t2.label = s2, this.finishNode(t2, "LabeledStatement");
          }
          parseExpressionStatement(t2, e2, s2) {
            return t2.expression = e2, this.semicolon(), this.finishNode(t2, "ExpressionStatement");
          }
          parseBlock(t2 = false, e2 = true, s2) {
            let i2 = this.startNode();
            return t2 && this.state.strictErrors.clear(), this.expect(5), e2 && this.scope.enter(0), this.parseBlockBody(i2, t2, false, 8, s2), e2 && this.scope.exit(), this.finishNode(i2, "BlockStatement");
          }
          isValidDirective(t2) {
            return t2.type === "ExpressionStatement" && t2.expression.type === "StringLiteral" && !t2.expression.extra.parenthesized;
          }
          parseBlockBody(t2, e2, s2, i2, r2) {
            let n2 = t2.body = [], o2 = t2.directives = [];
            this.parseBlockOrModuleBlockBody(n2, e2 ? o2 : void 0, s2, i2, r2);
          }
          parseBlockOrModuleBlockBody(t2, e2, s2, i2, r2) {
            let n2 = this.state.strict, o2 = false, h2 = false;
            for (; !this.match(i2); ) {
              let c2 = s2 ? this.parseModuleItem() : this.parseStatementListItem();
              if (e2 && !h2) {
                if (this.isValidDirective(c2)) {
                  let l2 = this.stmtToDirective(c2);
                  e2.push(l2), !o2 && l2.value.value === "use strict" && (o2 = true, this.setStrict(true));
                  continue;
                }
                h2 = true, this.state.strictErrors.clear();
              }
              t2.push(c2);
            }
            r2 == null || r2.call(this, o2), n2 || this.setStrict(false), this.next();
          }
          parseFor(t2, e2) {
            return t2.init = e2, this.semicolon(false), t2.test = this.match(13) ? null : this.parseExpression(), this.semicolon(false), t2.update = this.match(11) ? null : this.parseExpression(), this.expect(11), t2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t2, "ForStatement");
          }
          parseForIn(t2, e2, s2) {
            let i2 = this.match(58);
            return this.next(), i2 ? s2 !== null && this.unexpected(s2) : t2.await = s2 !== null, e2.type === "VariableDeclaration" && e2.declarations[0].init != null && (!i2 || !this.options.annexB || this.state.strict || e2.kind !== "var" || e2.declarations[0].id.type !== "Identifier") && this.raise(p2.ForInOfLoopInitializer, e2, { type: i2 ? "ForInStatement" : "ForOfStatement" }), e2.type === "AssignmentPattern" && this.raise(p2.InvalidLhs, e2, { ancestor: { type: "ForStatement" } }), t2.left = e2, t2.right = i2 ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), t2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t2, i2 ? "ForInStatement" : "ForOfStatement");
          }
          parseVar(t2, e2, s2, i2 = false) {
            let r2 = t2.declarations = [];
            for (t2.kind = s2; ; ) {
              let n2 = this.startNode();
              if (this.parseVarId(n2, s2), n2.init = this.eat(29) ? e2 ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, n2.init === null && !i2 && (n2.id.type !== "Identifier" && !(e2 && (this.match(58) || this.isContextual(102))) ? this.raise(p2.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: "destructuring" }) : (s2 === "const" || s2 === "using" || s2 === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(p2.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: s2 })), r2.push(this.finishNode(n2, "VariableDeclarator")), !this.eat(12))
                break;
            }
            return t2;
          }
          parseVarId(t2, e2) {
            let s2 = this.parseBindingAtom();
            (e2 === "using" || e2 === "await using") && (s2.type === "ArrayPattern" || s2.type === "ObjectPattern") && this.raise(p2.UsingDeclarationHasBindingPattern, s2.loc.start), this.checkLVal(s2, { in: { type: "VariableDeclarator" }, binding: e2 === "var" ? 5 : 8201 }), t2.id = s2;
          }
          parseAsyncFunctionExpression(t2) {
            return this.parseFunction(t2, 8);
          }
          parseFunction(t2, e2 = 0) {
            let s2 = e2 & 2, i2 = !!(e2 & 1), r2 = i2 && !(e2 & 4), n2 = !!(e2 & 8);
            this.initFunction(t2, n2), this.match(55) && (s2 && this.raise(p2.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), t2.generator = true), i2 && (t2.id = this.parseFunctionId(r2));
            let o2 = this.state.maybeInArrowParameters;
            return this.state.maybeInArrowParameters = false, this.scope.enter(2), this.prodParam.enter(ke3(n2, t2.generator)), i2 || (t2.id = this.parseFunctionId()), this.parseFunctionParams(t2, false), this.withSmartMixTopicForbiddingContext(() => {
              this.parseFunctionBodyAndFinish(t2, i2 ? "FunctionDeclaration" : "FunctionExpression");
            }), this.prodParam.exit(), this.scope.exit(), i2 && !s2 && this.registerFunctionStatementId(t2), this.state.maybeInArrowParameters = o2, t2;
          }
          parseFunctionId(t2) {
            return t2 || w2(this.state.type) ? this.parseIdentifier() : null;
          }
          parseFunctionParams(t2, e2) {
            this.expect(10), this.expressionScope.enter(Mi2()), t2.params = this.parseBindingList(11, 41, 2 | (e2 ? 4 : 0)), this.expressionScope.exit();
          }
          registerFunctionStatementId(t2) {
            t2.id && this.scope.declareName(t2.id.name, !this.options.annexB || this.state.strict || t2.generator || t2.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, t2.id.loc.start);
          }
          parseClass(t2, e2, s2) {
            this.next();
            let i2 = this.state.strict;
            return this.state.strict = true, this.parseClassId(t2, e2, s2), this.parseClassSuper(t2), t2.body = this.parseClassBody(!!t2.superClass, i2), this.finishNode(t2, e2 ? "ClassDeclaration" : "ClassExpression");
          }
          isClassProperty() {
            return this.match(29) || this.match(13) || this.match(8);
          }
          isClassMethod() {
            return this.match(10);
          }
          nameIsConstructor(t2) {
            return t2.type === "Identifier" && t2.name === "constructor" || t2.type === "StringLiteral" && t2.value === "constructor";
          }
          isNonstaticConstructor(t2) {
            return !t2.computed && !t2.static && this.nameIsConstructor(t2.key);
          }
          parseClassBody(t2, e2) {
            this.classScope.enter();
            let s2 = { hadConstructor: false, hadSuperClass: t2 }, i2 = [], r2 = this.startNode();
            if (r2.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
              for (; !this.match(8); ) {
                if (this.eat(13)) {
                  if (i2.length > 0)
                    throw this.raise(p2.DecoratorSemicolon, this.state.lastTokEndLoc);
                  continue;
                }
                if (this.match(26)) {
                  i2.push(this.parseDecorator());
                  continue;
                }
                let n2 = this.startNode();
                i2.length && (n2.decorators = i2, this.resetStartLocationFromNode(n2, i2[0]), i2 = []), this.parseClassMember(r2, n2, s2), n2.kind === "constructor" && n2.decorators && n2.decorators.length > 0 && this.raise(p2.DecoratorConstructor, n2);
              }
            }), this.state.strict = e2, this.next(), i2.length)
              throw this.raise(p2.TrailingDecorator, this.state.startLoc);
            return this.classScope.exit(), this.finishNode(r2, "ClassBody");
          }
          parseClassMemberFromModifier(t2, e2) {
            let s2 = this.parseIdentifier(true);
            if (this.isClassMethod()) {
              let i2 = e2;
              return i2.kind = "method", i2.computed = false, i2.key = s2, i2.static = false, this.pushClassMethod(t2, i2, false, false, false, false), true;
            } else if (this.isClassProperty()) {
              let i2 = e2;
              return i2.computed = false, i2.key = s2, i2.static = false, t2.body.push(this.parseClassProperty(i2)), true;
            }
            return this.resetPreviousNodeTrailingComments(s2), false;
          }
          parseClassMember(t2, e2, s2) {
            let i2 = this.isContextual(106);
            if (i2) {
              if (this.parseClassMemberFromModifier(t2, e2))
                return;
              if (this.eat(5)) {
                this.parseClassStaticBlock(t2, e2);
                return;
              }
            }
            this.parseClassMemberWithIsStatic(t2, e2, s2, i2);
          }
          parseClassMemberWithIsStatic(t2, e2, s2, i2) {
            let r2 = e2, n2 = e2, o2 = e2, h2 = e2, c2 = e2, l2 = r2, u2 = r2;
            if (e2.static = i2, this.parsePropertyNamePrefixOperator(e2), this.eat(55)) {
              l2.kind = "method";
              let S3 = this.match(138);
              if (this.parseClassElementName(l2), S3) {
                this.pushClassPrivateMethod(t2, n2, true, false);
                return;
              }
              this.isNonstaticConstructor(r2) && this.raise(p2.ConstructorIsGenerator, r2.key), this.pushClassMethod(t2, r2, true, false, false, false);
              return;
            }
            let f2 = !this.state.containsEsc && w2(this.state.type), d2 = this.parseClassElementName(e2), y3 = f2 ? d2.name : null, E2 = this.isPrivateName(d2), L3 = this.state.startLoc;
            if (this.parsePostMemberNameModifiers(u2), this.isClassMethod()) {
              if (l2.kind = "method", E2) {
                this.pushClassPrivateMethod(t2, n2, false, false);
                return;
              }
              let S3 = this.isNonstaticConstructor(r2), I2 = false;
              S3 && (r2.kind = "constructor", s2.hadConstructor && !this.hasPlugin("typescript") && this.raise(p2.DuplicateConstructor, d2), S3 && this.hasPlugin("typescript") && e2.override && this.raise(p2.OverrideOnConstructor, d2), s2.hadConstructor = true, I2 = s2.hadSuperClass), this.pushClassMethod(t2, r2, false, false, S3, I2);
            } else if (this.isClassProperty())
              E2 ? this.pushClassPrivateProperty(t2, h2) : this.pushClassProperty(t2, o2);
            else if (y3 === "async" && !this.isLineTerminator()) {
              this.resetPreviousNodeTrailingComments(d2);
              let S3 = this.eat(55);
              u2.optional && this.unexpected(L3), l2.kind = "method";
              let I2 = this.match(138);
              this.parseClassElementName(l2), this.parsePostMemberNameModifiers(u2), I2 ? this.pushClassPrivateMethod(t2, n2, S3, true) : (this.isNonstaticConstructor(r2) && this.raise(p2.ConstructorIsAsync, r2.key), this.pushClassMethod(t2, r2, S3, true, false, false));
            } else if ((y3 === "get" || y3 === "set") && !(this.match(55) && this.isLineTerminator())) {
              this.resetPreviousNodeTrailingComments(d2), l2.kind = y3;
              let S3 = this.match(138);
              this.parseClassElementName(r2), S3 ? this.pushClassPrivateMethod(t2, n2, false, false) : (this.isNonstaticConstructor(r2) && this.raise(p2.ConstructorIsAccessor, r2.key), this.pushClassMethod(t2, r2, false, false, false, false)), this.checkGetterSetterParams(r2);
            } else if (y3 === "accessor" && !this.isLineTerminator()) {
              this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(d2);
              let S3 = this.match(138);
              this.parseClassElementName(o2), this.pushClassAccessorProperty(t2, c2, S3);
            } else
              this.isLineTerminator() ? E2 ? this.pushClassPrivateProperty(t2, h2) : this.pushClassProperty(t2, o2) : this.unexpected();
          }
          parseClassElementName(t2) {
            let { type: e2, value: s2 } = this.state;
            if ((e2 === 132 || e2 === 133) && t2.static && s2 === "prototype" && this.raise(p2.StaticPrototype, this.state.startLoc), e2 === 138) {
              s2 === "constructor" && this.raise(p2.ConstructorClassPrivateField, this.state.startLoc);
              let i2 = this.parsePrivateName();
              return t2.key = i2, i2;
            }
            return this.parsePropertyName(t2), t2.key;
          }
          parseClassStaticBlock(t2, e2) {
            var s2;
            this.scope.enter(208);
            let i2 = this.state.labels;
            this.state.labels = [], this.prodParam.enter(0);
            let r2 = e2.body = [];
            this.parseBlockOrModuleBlockBody(r2, void 0, false, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = i2, t2.body.push(this.finishNode(e2, "StaticBlock")), (s2 = e2.decorators) != null && s2.length && this.raise(p2.DecoratorStaticBlock, e2);
          }
          pushClassProperty(t2, e2) {
            !e2.computed && this.nameIsConstructor(e2.key) && this.raise(p2.ConstructorClassField, e2.key), t2.body.push(this.parseClassProperty(e2));
          }
          pushClassPrivateProperty(t2, e2) {
            let s2 = this.parseClassPrivateProperty(e2);
            t2.body.push(s2), this.classScope.declarePrivateName(this.getPrivateNameSV(s2.key), 0, s2.key.loc.start);
          }
          pushClassAccessorProperty(t2, e2, s2) {
            !s2 && !e2.computed && this.nameIsConstructor(e2.key) && this.raise(p2.ConstructorClassField, e2.key);
            let i2 = this.parseClassAccessorProperty(e2);
            t2.body.push(i2), s2 && this.classScope.declarePrivateName(this.getPrivateNameSV(i2.key), 0, i2.key.loc.start);
          }
          pushClassMethod(t2, e2, s2, i2, r2, n2) {
            t2.body.push(this.parseMethod(e2, s2, i2, r2, n2, "ClassMethod", true));
          }
          pushClassPrivateMethod(t2, e2, s2, i2) {
            let r2 = this.parseMethod(e2, s2, i2, false, false, "ClassPrivateMethod", true);
            t2.body.push(r2);
            let n2 = r2.kind === "get" ? r2.static ? 6 : 2 : r2.kind === "set" ? r2.static ? 5 : 1 : 0;
            this.declareClassPrivateMethodInScope(r2, n2);
          }
          declareClassPrivateMethodInScope(t2, e2) {
            this.classScope.declarePrivateName(this.getPrivateNameSV(t2.key), e2, t2.key.loc.start);
          }
          parsePostMemberNameModifiers(t2) {
          }
          parseClassPrivateProperty(t2) {
            return this.parseInitializer(t2), this.semicolon(), this.finishNode(t2, "ClassPrivateProperty");
          }
          parseClassProperty(t2) {
            return this.parseInitializer(t2), this.semicolon(), this.finishNode(t2, "ClassProperty");
          }
          parseClassAccessorProperty(t2) {
            return this.parseInitializer(t2), this.semicolon(), this.finishNode(t2, "ClassAccessorProperty");
          }
          parseInitializer(t2) {
            this.scope.enter(80), this.expressionScope.enter(rs()), this.prodParam.enter(0), t2.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
          }
          parseClassId(t2, e2, s2, i2 = 8331) {
            if (w2(this.state.type))
              t2.id = this.parseIdentifier(), e2 && this.declareNameFromIdentifier(t2.id, i2);
            else if (s2 || !e2)
              t2.id = null;
            else
              throw this.raise(p2.MissingClassName, this.state.startLoc);
          }
          parseClassSuper(t2) {
            t2.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
          }
          parseExport(t2, e2) {
            let s2 = this.parseMaybeImportPhase(t2, true), i2 = this.maybeParseExportDefaultSpecifier(t2, s2), r2 = !i2 || this.eat(12), n2 = r2 && this.eatExportStar(t2), o2 = n2 && this.maybeParseExportNamespaceSpecifier(t2), h2 = r2 && (!o2 || this.eat(12)), c2 = i2 || n2;
            if (n2 && !o2) {
              if (i2 && this.unexpected(), e2)
                throw this.raise(p2.UnsupportedDecoratorExport, t2);
              return this.parseExportFrom(t2, true), this.finishNode(t2, "ExportAllDeclaration");
            }
            let l2 = this.maybeParseExportNamedSpecifiers(t2);
            i2 && r2 && !n2 && !l2 && this.unexpected(null, 5), o2 && h2 && this.unexpected(null, 98);
            let u2;
            if (c2 || l2) {
              if (u2 = false, e2)
                throw this.raise(p2.UnsupportedDecoratorExport, t2);
              this.parseExportFrom(t2, c2);
            } else
              u2 = this.maybeParseExportDeclaration(t2);
            if (c2 || l2 || u2) {
              var f2;
              let d2 = t2;
              if (this.checkExport(d2, true, false, !!d2.source), ((f2 = d2.declaration) == null ? void 0 : f2.type) === "ClassDeclaration")
                this.maybeTakeDecorators(e2, d2.declaration, d2);
              else if (e2)
                throw this.raise(p2.UnsupportedDecoratorExport, t2);
              return this.finishNode(d2, "ExportNamedDeclaration");
            }
            if (this.eat(65)) {
              let d2 = t2, y3 = this.parseExportDefaultExpression();
              if (d2.declaration = y3, y3.type === "ClassDeclaration")
                this.maybeTakeDecorators(e2, y3, d2);
              else if (e2)
                throw this.raise(p2.UnsupportedDecoratorExport, t2);
              return this.checkExport(d2, true, true), this.finishNode(d2, "ExportDefaultDeclaration");
            }
            this.unexpected(null, 5);
          }
          eatExportStar(t2) {
            return this.eat(55);
          }
          maybeParseExportDefaultSpecifier(t2, e2) {
            if (e2 || this.isExportDefaultSpecifier()) {
              this.expectPlugin("exportDefaultFrom", e2 == null ? void 0 : e2.loc.start);
              let s2 = e2 || this.parseIdentifier(true), i2 = this.startNodeAtNode(s2);
              return i2.exported = s2, t2.specifiers = [this.finishNode(i2, "ExportDefaultSpecifier")], true;
            }
            return false;
          }
          maybeParseExportNamespaceSpecifier(t2) {
            if (this.isContextual(93)) {
              var e2, s2;
              (s2 = (e2 = t2).specifiers) != null || (e2.specifiers = []);
              let i2 = this.startNodeAt(this.state.lastTokStartLoc);
              return this.next(), i2.exported = this.parseModuleExportName(), t2.specifiers.push(this.finishNode(i2, "ExportNamespaceSpecifier")), true;
            }
            return false;
          }
          maybeParseExportNamedSpecifiers(t2) {
            if (this.match(5)) {
              let e2 = t2;
              e2.specifiers || (e2.specifiers = []);
              let s2 = e2.exportKind === "type";
              return e2.specifiers.push(...this.parseExportSpecifiers(s2)), e2.source = null, e2.declaration = null, this.hasPlugin("importAssertions") && (e2.assertions = []), true;
            }
            return false;
          }
          maybeParseExportDeclaration(t2) {
            return this.shouldParseExportDeclaration() ? (t2.specifiers = [], t2.source = null, this.hasPlugin("importAssertions") && (t2.assertions = []), t2.declaration = this.parseExportDeclaration(t2), true) : false;
          }
          isAsyncFunction() {
            if (!this.isContextual(95))
              return false;
            let t2 = this.nextTokenInLineStart();
            return this.isUnparsedContextual(t2, "function");
          }
          parseExportDefaultExpression() {
            let t2 = this.startNode();
            if (this.match(68))
              return this.next(), this.parseFunction(t2, 5);
            if (this.isAsyncFunction())
              return this.next(), this.next(), this.parseFunction(t2, 13);
            if (this.match(80))
              return this.parseClass(t2, true, true);
            if (this.match(26))
              return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true && this.raise(p2.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
            if (this.match(75) || this.match(74) || this.isLet())
              throw this.raise(p2.UnsupportedDefaultExport, this.state.startLoc);
            let e2 = this.parseMaybeAssignAllowIn();
            return this.semicolon(), e2;
          }
          parseExportDeclaration(t2) {
            return this.match(80) ? this.parseClass(this.startNode(), true, false) : this.parseStatementListItem();
          }
          isExportDefaultSpecifier() {
            let { type: t2 } = this.state;
            if (w2(t2)) {
              if (t2 === 95 && !this.state.containsEsc || t2 === 100)
                return false;
              if ((t2 === 130 || t2 === 129) && !this.state.containsEsc) {
                let { type: i2 } = this.lookahead();
                if (w2(i2) && i2 !== 98 || i2 === 5)
                  return this.expectOnePlugin(["flow", "typescript"]), false;
              }
            } else if (!this.match(65))
              return false;
            let e2 = this.nextTokenStart(), s2 = this.isUnparsedContextual(e2, "from");
            if (this.input.charCodeAt(e2) === 44 || w2(this.state.type) && s2)
              return true;
            if (this.match(65) && s2) {
              let i2 = this.input.charCodeAt(this.nextTokenStartSince(e2 + 4));
              return i2 === 34 || i2 === 39;
            }
            return false;
          }
          parseExportFrom(t2, e2) {
            this.eatContextual(98) ? (t2.source = this.parseImportSource(), this.checkExport(t2), this.maybeParseImportAttributes(t2), this.checkJSONModuleImport(t2)) : e2 && this.unexpected(), this.semicolon();
          }
          shouldParseExportDeclaration() {
            let { type: t2 } = this.state;
            return t2 === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("decorators", "decoratorsBeforeExport") === true && this.raise(p2.DecoratorBeforeExport, this.state.startLoc), true) : this.isContextual(107) ? (this.raise(p2.UsingDeclarationExport, this.state.startLoc), true) : this.isContextual(96) && this.startsAwaitUsing() ? (this.raise(p2.UsingDeclarationExport, this.state.startLoc), true) : t2 === 74 || t2 === 75 || t2 === 68 || t2 === 80 || this.isLet() || this.isAsyncFunction();
          }
          checkExport(t2, e2, s2, i2) {
            if (e2) {
              var r2;
              if (s2) {
                if (this.checkDuplicateExports(t2, "default"), this.hasPlugin("exportDefaultFrom")) {
                  var n2;
                  let o2 = t2.declaration;
                  o2.type === "Identifier" && o2.name === "from" && o2.end - o2.start === 4 && !((n2 = o2.extra) != null && n2.parenthesized) && this.raise(p2.ExportDefaultFromAsIdentifier, o2);
                }
              } else if ((r2 = t2.specifiers) != null && r2.length)
                for (let o2 of t2.specifiers) {
                  let { exported: h2 } = o2, c2 = h2.type === "Identifier" ? h2.name : h2.value;
                  if (this.checkDuplicateExports(o2, c2), !i2 && o2.local) {
                    let { local: l2 } = o2;
                    l2.type !== "Identifier" ? this.raise(p2.ExportBindingIsString, o2, { localName: l2.value, exportName: c2 }) : (this.checkReservedWord(l2.name, l2.loc.start, true, false), this.scope.checkLocalExport(l2));
                  }
                }
              else if (t2.declaration) {
                let o2 = t2.declaration;
                if (o2.type === "FunctionDeclaration" || o2.type === "ClassDeclaration") {
                  let { id: h2 } = o2;
                  if (!h2)
                    throw new Error("Assertion failure");
                  this.checkDuplicateExports(t2, h2.name);
                } else if (o2.type === "VariableDeclaration")
                  for (let h2 of o2.declarations)
                    this.checkDeclaration(h2.id);
              }
            }
          }
          checkDeclaration(t2) {
            if (t2.type === "Identifier")
              this.checkDuplicateExports(t2, t2.name);
            else if (t2.type === "ObjectPattern")
              for (let e2 of t2.properties)
                this.checkDeclaration(e2);
            else if (t2.type === "ArrayPattern")
              for (let e2 of t2.elements)
                e2 && this.checkDeclaration(e2);
            else
              t2.type === "ObjectProperty" ? this.checkDeclaration(t2.value) : t2.type === "RestElement" ? this.checkDeclaration(t2.argument) : t2.type === "AssignmentPattern" && this.checkDeclaration(t2.left);
          }
          checkDuplicateExports(t2, e2) {
            this.exportedIdentifiers.has(e2) && (e2 === "default" ? this.raise(p2.DuplicateDefaultExport, t2) : this.raise(p2.DuplicateExport, t2, { exportName: e2 })), this.exportedIdentifiers.add(e2);
          }
          parseExportSpecifiers(t2) {
            let e2 = [], s2 = true;
            for (this.expect(5); !this.eat(8); ) {
              if (s2)
                s2 = false;
              else if (this.expect(12), this.eat(8))
                break;
              let i2 = this.isContextual(130), r2 = this.match(133), n2 = this.startNode();
              n2.local = this.parseModuleExportName(), e2.push(this.parseExportSpecifier(n2, r2, t2, i2));
            }
            return e2;
          }
          parseExportSpecifier(t2, e2, s2, i2) {
            return this.eatContextual(93) ? t2.exported = this.parseModuleExportName() : e2 ? t2.exported = Ri(t2.local) : t2.exported || (t2.exported = $2(t2.local)), this.finishNode(t2, "ExportSpecifier");
          }
          parseModuleExportName() {
            if (this.match(133)) {
              let t2 = this.parseStringLiteral(this.state.value), e2 = nr2.exec(t2.value);
              return e2 && this.raise(p2.ModuleExportNameHasLoneSurrogate, t2, { surrogateCharCode: e2[0].charCodeAt(0) }), t2;
            }
            return this.parseIdentifier(true);
          }
          isJSONModuleImport(t2) {
            return t2.assertions != null ? t2.assertions.some(({ key: e2, value: s2 }) => s2.value === "json" && (e2.type === "Identifier" ? e2.name === "type" : e2.value === "type")) : false;
          }
          checkImportReflection(t2) {
            let { specifiers: e2 } = t2, s2 = e2.length === 1 ? e2[0].type : null;
            if (t2.phase === "source")
              s2 !== "ImportDefaultSpecifier" && this.raise(p2.SourcePhaseImportRequiresDefault, e2[0].loc.start);
            else if (t2.phase === "defer")
              s2 !== "ImportNamespaceSpecifier" && this.raise(p2.DeferImportRequiresNamespace, e2[0].loc.start);
            else if (t2.module) {
              var i2;
              s2 !== "ImportDefaultSpecifier" && this.raise(p2.ImportReflectionNotBinding, e2[0].loc.start), ((i2 = t2.assertions) == null ? void 0 : i2.length) > 0 && this.raise(p2.ImportReflectionHasAssertion, e2[0].loc.start);
            }
          }
          checkJSONModuleImport(t2) {
            if (this.isJSONModuleImport(t2) && t2.type !== "ExportAllDeclaration") {
              let { specifiers: e2 } = t2;
              if (e2 != null) {
                let s2 = e2.find((i2) => {
                  let r2;
                  if (i2.type === "ExportSpecifier" ? r2 = i2.local : i2.type === "ImportSpecifier" && (r2 = i2.imported), r2 !== void 0)
                    return r2.type === "Identifier" ? r2.name !== "default" : r2.value !== "default";
                });
                s2 !== void 0 && this.raise(p2.ImportJSONBindingNotDefault, s2.loc.start);
              }
            }
          }
          isPotentialImportPhase(t2) {
            return t2 ? false : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
          }
          applyImportPhase(t2, e2, s2, i2) {
            e2 || (s2 === "module" ? (this.expectPlugin("importReflection", i2), t2.module = true) : this.hasPlugin("importReflection") && (t2.module = false), s2 === "source" ? (this.expectPlugin("sourcePhaseImports", i2), t2.phase = "source") : s2 === "defer" ? (this.expectPlugin("deferredImportEvaluation", i2), t2.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (t2.phase = null));
          }
          parseMaybeImportPhase(t2, e2) {
            if (!this.isPotentialImportPhase(e2))
              return this.applyImportPhase(t2, e2, null), null;
            let s2 = this.parseIdentifier(true), { type: i2 } = this.state;
            return (M3(i2) ? i2 !== 98 || this.lookaheadCharCode() === 102 : i2 !== 12) ? (this.resetPreviousIdentifierLeadingComments(s2), this.applyImportPhase(t2, e2, s2.name, s2.loc.start), null) : (this.applyImportPhase(t2, e2, null), s2);
          }
          isPrecedingIdImportPhase(t2) {
            let { type: e2 } = this.state;
            return w2(e2) ? e2 !== 98 || this.lookaheadCharCode() === 102 : e2 !== 12;
          }
          parseImport(t2) {
            return this.match(133) ? this.parseImportSourceAndAttributes(t2) : this.parseImportSpecifiersAndAfter(t2, this.parseMaybeImportPhase(t2, false));
          }
          parseImportSpecifiersAndAfter(t2, e2) {
            t2.specifiers = [];
            let i2 = !this.maybeParseDefaultImportSpecifier(t2, e2) || this.eat(12), r2 = i2 && this.maybeParseStarImportSpecifier(t2);
            return i2 && !r2 && this.parseNamedImportSpecifiers(t2), this.expectContextual(98), this.parseImportSourceAndAttributes(t2);
          }
          parseImportSourceAndAttributes(t2) {
            var e2;
            return (e2 = t2.specifiers) != null || (t2.specifiers = []), t2.source = this.parseImportSource(), this.maybeParseImportAttributes(t2), this.checkImportReflection(t2), this.checkJSONModuleImport(t2), this.semicolon(), this.finishNode(t2, "ImportDeclaration");
          }
          parseImportSource() {
            return this.match(133) || this.unexpected(), this.parseExprAtom();
          }
          parseImportSpecifierLocal(t2, e2, s2) {
            e2.local = this.parseIdentifier(), t2.specifiers.push(this.finishImportSpecifier(e2, s2));
          }
          finishImportSpecifier(t2, e2, s2 = 8201) {
            return this.checkLVal(t2.local, { in: { type: e2 }, binding: s2 }), this.finishNode(t2, e2);
          }
          parseImportAttributes() {
            this.expect(5);
            let t2 = [], e2 = /* @__PURE__ */ new Set();
            do {
              if (this.match(8))
                break;
              let s2 = this.startNode(), i2 = this.state.value;
              if (e2.has(i2) && this.raise(p2.ModuleAttributesWithDuplicateKeys, this.state.startLoc, { key: i2 }), e2.add(i2), this.match(133) ? s2.key = this.parseStringLiteral(i2) : s2.key = this.parseIdentifier(true), this.expect(14), !this.match(133))
                throw this.raise(p2.ModuleAttributeInvalidValue, this.state.startLoc);
              s2.value = this.parseStringLiteral(this.state.value), t2.push(this.finishNode(s2, "ImportAttribute"));
            } while (this.eat(12));
            return this.expect(8), t2;
          }
          parseModuleAttributes() {
            let t2 = [], e2 = /* @__PURE__ */ new Set();
            do {
              let s2 = this.startNode();
              if (s2.key = this.parseIdentifier(true), s2.key.name !== "type" && this.raise(p2.ModuleAttributeDifferentFromType, s2.key), e2.has(s2.key.name) && this.raise(p2.ModuleAttributesWithDuplicateKeys, s2.key, { key: s2.key.name }), e2.add(s2.key.name), this.expect(14), !this.match(133))
                throw this.raise(p2.ModuleAttributeInvalidValue, this.state.startLoc);
              s2.value = this.parseStringLiteral(this.state.value), t2.push(this.finishNode(s2, "ImportAttribute"));
            } while (this.eat(12));
            return t2;
          }
          maybeParseImportAttributes(t2) {
            let e2, s2 = false;
            if (this.match(76)) {
              if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
                return;
              this.next(), this.hasPlugin("moduleAttributes") ? e2 = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), e2 = this.parseImportAttributes()), s2 = true;
            } else if (this.isContextual(94) && !this.hasPrecedingLineBreak())
              this.hasPlugin("importAttributes") ? (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== true && this.raise(p2.ImportAttributesUseAssert, this.state.startLoc), this.addExtra(t2, "deprecatedAssertSyntax", true)) : this.expectOnePlugin(["importAttributes", "importAssertions"]), this.next(), e2 = this.parseImportAttributes();
            else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))
              e2 = [];
            else if (this.hasPlugin("moduleAttributes"))
              e2 = [];
            else
              return;
            !s2 && this.hasPlugin("importAssertions") ? t2.assertions = e2 : t2.attributes = e2;
          }
          maybeParseDefaultImportSpecifier(t2, e2) {
            if (e2) {
              let s2 = this.startNodeAtNode(e2);
              return s2.local = e2, t2.specifiers.push(this.finishImportSpecifier(s2, "ImportDefaultSpecifier")), true;
            } else if (M3(this.state.type))
              return this.parseImportSpecifierLocal(t2, this.startNode(), "ImportDefaultSpecifier"), true;
            return false;
          }
          maybeParseStarImportSpecifier(t2) {
            if (this.match(55)) {
              let e2 = this.startNode();
              return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(t2, e2, "ImportNamespaceSpecifier"), true;
            }
            return false;
          }
          parseNamedImportSpecifiers(t2) {
            let e2 = true;
            for (this.expect(5); !this.eat(8); ) {
              if (e2)
                e2 = false;
              else {
                if (this.eat(14))
                  throw this.raise(p2.DestructureNamedImport, this.state.startLoc);
                if (this.expect(12), this.eat(8))
                  break;
              }
              let s2 = this.startNode(), i2 = this.match(133), r2 = this.isContextual(130);
              s2.imported = this.parseModuleExportName();
              let n2 = this.parseImportSpecifier(s2, i2, t2.importKind === "type" || t2.importKind === "typeof", r2, void 0);
              t2.specifiers.push(n2);
            }
          }
          parseImportSpecifier(t2, e2, s2, i2, r2) {
            if (this.eatContextual(93))
              t2.local = this.parseIdentifier();
            else {
              let { imported: n2 } = t2;
              if (e2)
                throw this.raise(p2.ImportBindingIsString, t2, { importName: n2.value });
              this.checkReservedWord(n2.name, t2.loc.start, true, true), t2.local || (t2.local = $2(n2));
            }
            return this.finishImportSpecifier(t2, "ImportSpecifier", r2);
          }
          isThisParam(t2) {
            return t2.type === "Identifier" && t2.name === "this";
          }
        }, Me3 = class extends pt3 {
          constructor(t2, e2) {
            t2 = rr2(t2), super(t2, e2), this.options = t2, this.initializeScopes(), this.plugins = hr2(this.options.plugins), this.filename = t2.sourceFilename;
          }
          getScopeHandler() {
            return me2;
          }
          parse() {
            this.enterInitialScopes();
            let t2 = this.startNode(), e2 = this.startNode();
            return this.nextToken(), t2.errors = null, this.parseTopLevel(t2, e2), t2.errors = this.state.errors, t2.comments.length = this.state.commentsLen, t2;
          }
        };
        function hr2(a2) {
          let t2 = /* @__PURE__ */ new Map();
          for (let e2 of a2) {
            let [s2, i2] = Array.isArray(e2) ? e2 : [e2, {}];
            t2.has(s2) || t2.set(s2, i2 || {});
          }
          return t2;
        }
        function lr3(a2, t2) {
          var e2;
          if (((e2 = t2) == null ? void 0 : e2.sourceType) === "unambiguous") {
            t2 = Object.assign({}, t2);
            try {
              t2.sourceType = "module";
              let s2 = pe2(t2, a2), i2 = s2.parse();
              if (s2.sawUnambiguousESM)
                return i2;
              if (s2.ambiguousScriptDifferentAst)
                try {
                  return t2.sourceType = "script", pe2(t2, a2).parse();
                } catch {
                }
              else
                i2.program.sourceType = "script";
              return i2;
            } catch (s2) {
              try {
                return t2.sourceType = "script", pe2(t2, a2).parse();
              } catch {
              }
              throw s2;
            }
          } else
            return pe2(t2, a2).parse();
        }
        function cr3(a2, t2) {
          let e2 = pe2(t2, a2);
          return e2.options.strictMode && (e2.state.strict = true), e2.getExpression();
        }
        function pr3(a2) {
          let t2 = {};
          for (let e2 of Object.keys(a2))
            t2[e2] = R3(a2[e2]);
          return t2;
        }
        var ur3 = pr3(ni2);
        function pe2(a2, t2) {
          let e2 = Me3;
          return a2 != null && a2.plugins && (sr3(a2.plugins), e2 = fr3(a2.plugins)), new e2(a2, t2);
        }
        var Kt2 = {};
        function fr3(a2) {
          let t2 = ir3.filter((i2) => N2(a2, i2)), e2 = t2.join("/"), s2 = Kt2[e2];
          if (!s2) {
            s2 = Me3;
            for (let i2 of t2)
              s2 = hs[i2](s2);
            Kt2[e2] = s2;
          }
          return s2;
        }
        xe3.parse = lr3;
        xe3.parseExpression = cr3;
        xe3.tokTypes = ur3;
      });
      var Zr2 = {};
      Ws2(Zr2, { parsers: () => Qr2 });
      var je2 = vt2(At3(), 1);
      function Oe3(a2) {
        return (t2, e2, s2) => {
          let i2 = !!(s2 != null && s2.backwards);
          if (e2 === false)
            return false;
          let { length: r2 } = t2, n2 = e2;
          for (; n2 >= 0 && n2 < r2; ) {
            let o2 = t2.charAt(n2);
            if (a2 instanceof RegExp) {
              if (!a2.test(o2))
                return n2;
            } else if (!a2.includes(o2))
              return n2;
            i2 ? n2-- : n2++;
          }
          return n2 === -1 || n2 === r2 ? n2 : false;
        };
      }
      var ha2 = Oe3(/\s/u), ls = Oe3(" 	"), la2 = Oe3(",; 	"), cs = Oe3(/[^\n\r]/u);
      function dr3(a2, t2) {
        if (t2 === false)
          return false;
        if (a2.charAt(t2) === "/" && a2.charAt(t2 + 1) === "*") {
          for (let e2 = t2 + 2; e2 < a2.length; ++e2)
            if (a2.charAt(e2) === "*" && a2.charAt(e2 + 1) === "/")
              return e2 + 2;
        }
        return t2;
      }
      var ps = dr3;
      function mr2(a2, t2, e2) {
        let s2 = !!(e2 != null && e2.backwards);
        if (t2 === false)
          return false;
        let i2 = a2.charAt(t2);
        if (s2) {
          if (a2.charAt(t2 - 1) === "\r" && i2 === `
`)
            return t2 - 2;
          if (i2 === `
` || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
            return t2 - 1;
        } else {
          if (i2 === "\r" && a2.charAt(t2 + 1) === `
`)
            return t2 + 2;
          if (i2 === `
` || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
            return t2 + 1;
        }
        return t2;
      }
      var us = mr2;
      function yr3(a2, t2) {
        return t2 === false ? false : a2.charAt(t2) === "/" && a2.charAt(t2 + 1) === "/" ? cs(a2, t2) : t2;
      }
      var fs = yr3;
      function xr3(a2, t2) {
        let e2 = null, s2 = t2;
        for (; s2 !== e2; )
          e2 = s2, s2 = ls(a2, s2), s2 = ps(a2, s2), s2 = fs(a2, s2), s2 = us(a2, s2);
        return s2;
      }
      var ds = xr3;
      function Pr2(a2) {
        let t2 = [];
        for (let e2 of a2)
          try {
            return e2();
          } catch (s2) {
            t2.push(s2);
          }
        throw Object.assign(new Error("All combinations failed"), { errors: t2 });
      }
      var ms = Pr2;
      function gr3(a2) {
        if (!a2.startsWith("#!"))
          return "";
        let t2 = a2.indexOf(`
`);
        return t2 === -1 ? a2 : a2.slice(0, t2);
      }
      var Fe3 = gr3;
      var Tr2 = (a2, t2, e2) => {
        if (!(a2 && t2 == null))
          return Array.isArray(t2) || typeof t2 == "string" ? t2[e2 < 0 ? t2.length + e2 : e2] : t2.at(e2);
      }, St3 = Tr2;
      function br3(a2) {
        return Array.isArray(a2) && a2.length > 0;
      }
      var Pe3 = br3;
      function D(a2) {
        var s2, i2, r2;
        let t2 = ((s2 = a2.range) == null ? void 0 : s2[0]) ?? a2.start, e2 = (r2 = ((i2 = a2.declaration) == null ? void 0 : i2.decorators) ?? a2.decorators) == null ? void 0 : r2[0];
        return e2 ? Math.min(D(e2), t2) : t2;
      }
      function B2(a2) {
        var t2;
        return ((t2 = a2.range) == null ? void 0 : t2[1]) ?? a2.end;
      }
      function Ar3(a2) {
        let t2 = new Set(a2);
        return (e2) => t2.has(e2 == null ? void 0 : e2.type);
      }
      var ys = Ar3;
      var Sr2 = ys(["Block", "CommentBlock", "MultiLine"]), ge2 = Sr2;
      function wr2(a2) {
        let t2 = `*${a2.value}*`.split(`
`);
        return t2.length > 1 && t2.every((e2) => e2.trimStart()[0] === "*");
      }
      var wt3 = wr2;
      function Cr2(a2) {
        return ge2(a2) && a2.value[0] === "*" && /@(?:type|satisfies)\b/u.test(a2.value);
      }
      var xs = Cr2;
      var Te2 = null;
      function be3(a2) {
        if (Te2 !== null && typeof Te2.property) {
          let t2 = Te2;
          return Te2 = be3.prototype = null, t2;
        }
        return Te2 = be3.prototype = a2 ?? /* @__PURE__ */ Object.create(null), new be3();
      }
      var Er2 = 10;
      for (let a2 = 0; a2 <= Er2; a2++)
        be3();
      function Ct(a2) {
        return be3(a2);
      }
      function Ir2(a2, t2 = "type") {
        Ct(a2);
        function e2(s2) {
          let i2 = s2[t2], r2 = a2[i2];
          if (!Array.isArray(r2))
            throw Object.assign(new Error(`Missing visitor keys for '${i2}'.`), { node: s2 });
          return r2;
        }
        return e2;
      }
      var Ps2 = Ir2;
      var gs = { ArrayExpression: ["elements"], AssignmentExpression: ["left", "right"], BinaryExpression: ["left", "right"], InterpreterDirective: [], Directive: ["value"], DirectiveLiteral: [], BlockStatement: ["directives", "body"], BreakStatement: ["label"], CallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], CatchClause: ["param", "body"], ConditionalExpression: ["test", "consequent", "alternate"], ContinueStatement: ["label"], DebuggerStatement: [], DoWhileStatement: ["test", "body"], EmptyStatement: [], ExpressionStatement: ["expression"], File: ["program"], ForInStatement: ["left", "right", "body"], ForStatement: ["init", "test", "update", "body"], FunctionDeclaration: ["id", "params", "body", "returnType", "typeParameters", "predicate"], FunctionExpression: ["id", "params", "body", "returnType", "typeParameters"], Identifier: ["typeAnnotation", "decorators"], IfStatement: ["test", "consequent", "alternate"], LabeledStatement: ["label", "body"], StringLiteral: [], NumericLiteral: [], NullLiteral: [], BooleanLiteral: [], RegExpLiteral: [], LogicalExpression: ["left", "right"], MemberExpression: ["object", "property"], NewExpression: ["callee", "arguments", "typeParameters", "typeArguments"], Program: ["directives", "body"], ObjectExpression: ["properties"], ObjectMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectProperty: ["key", "value", "decorators"], RestElement: ["argument", "typeAnnotation", "decorators"], ReturnStatement: ["argument"], SequenceExpression: ["expressions"], ParenthesizedExpression: ["expression"], SwitchCase: ["test", "consequent"], SwitchStatement: ["discriminant", "cases"], ThisExpression: [], ThrowStatement: ["argument"], TryStatement: ["block", "handler", "finalizer"], UnaryExpression: ["argument"], UpdateExpression: ["argument"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id", "init"], WhileStatement: ["test", "body"], WithStatement: ["object", "body"], AssignmentPattern: ["left", "right", "decorators", "typeAnnotation"], ArrayPattern: ["elements", "typeAnnotation", "decorators"], ArrowFunctionExpression: ["params", "body", "returnType", "typeParameters", "predicate"], ClassBody: ["body"], ClassExpression: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ClassDeclaration: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ExportAllDeclaration: ["source", "attributes", "exported"], ExportDefaultDeclaration: ["declaration"], ExportNamedDeclaration: ["declaration", "specifiers", "source", "attributes"], ExportSpecifier: ["local", "exported"], ForOfStatement: ["left", "right", "body"], ImportDeclaration: ["specifiers", "source", "attributes"], ImportDefaultSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportSpecifier: ["local", "imported"], ImportExpression: ["source", "options", "attributes"], MetaProperty: ["meta", "property"], ClassMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectPattern: ["properties", "typeAnnotation", "decorators"], SpreadElement: ["argument"], Super: [], TaggedTemplateExpression: ["tag", "quasi", "typeParameters", "typeArguments"], TemplateElement: [], TemplateLiteral: ["quasis", "expressions"], YieldExpression: ["argument"], AwaitExpression: ["argument"], Import: [], BigIntLiteral: [], ExportNamespaceSpecifier: ["exported"], OptionalMemberExpression: ["object", "property"], OptionalCallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], ClassProperty: ["key", "value", "typeAnnotation", "decorators", "variance"], ClassAccessorProperty: ["key", "value", "typeAnnotation", "decorators"], ClassPrivateProperty: ["key", "value", "decorators", "typeAnnotation", "variance"], ClassPrivateMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], PrivateName: ["id"], StaticBlock: ["body"], AnyTypeAnnotation: [], ArrayTypeAnnotation: ["elementType"], BooleanTypeAnnotation: [], BooleanLiteralTypeAnnotation: [], NullLiteralTypeAnnotation: [], ClassImplements: ["id", "typeParameters"], DeclareClass: ["id", "typeParameters", "extends", "mixins", "implements", "body"], DeclareFunction: ["id", "predicate"], DeclareInterface: ["id", "typeParameters", "extends", "body"], DeclareModule: ["id", "body"], DeclareModuleExports: ["typeAnnotation"], DeclareTypeAlias: ["id", "typeParameters", "right"], DeclareOpaqueType: ["id", "typeParameters", "supertype"], DeclareVariable: ["id"], DeclareExportDeclaration: ["declaration", "specifiers", "source"], DeclareExportAllDeclaration: ["source"], DeclaredPredicate: ["value"], ExistsTypeAnnotation: [], FunctionTypeAnnotation: ["typeParameters", "params", "rest", "returnType", "this"], FunctionTypeParam: ["name", "typeAnnotation"], GenericTypeAnnotation: ["id", "typeParameters"], InferredPredicate: [], InterfaceExtends: ["id", "typeParameters"], InterfaceDeclaration: ["id", "typeParameters", "extends", "body"], InterfaceTypeAnnotation: ["extends", "body"], IntersectionTypeAnnotation: ["types"], MixedTypeAnnotation: [], EmptyTypeAnnotation: [], NullableTypeAnnotation: ["typeAnnotation"], NumberLiteralTypeAnnotation: [], NumberTypeAnnotation: [], ObjectTypeAnnotation: ["properties", "indexers", "callProperties", "internalSlots"], ObjectTypeInternalSlot: ["id", "value"], ObjectTypeCallProperty: ["value"], ObjectTypeIndexer: ["id", "key", "value", "variance"], ObjectTypeProperty: ["key", "value", "variance"], ObjectTypeSpreadProperty: ["argument"], OpaqueType: ["id", "typeParameters", "supertype", "impltype"], QualifiedTypeIdentifier: ["id", "qualification"], StringLiteralTypeAnnotation: [], StringTypeAnnotation: [], SymbolTypeAnnotation: [], ThisTypeAnnotation: [], TupleTypeAnnotation: ["types", "elementTypes"], TypeofTypeAnnotation: ["argument", "typeArguments"], TypeAlias: ["id", "typeParameters", "right"], TypeAnnotation: ["typeAnnotation"], TypeCastExpression: ["expression", "typeAnnotation"], TypeParameter: ["bound", "default", "variance"], TypeParameterDeclaration: ["params"], TypeParameterInstantiation: ["params"], UnionTypeAnnotation: ["types"], Variance: [], VoidTypeAnnotation: [], EnumDeclaration: ["id", "body"], EnumBooleanBody: ["members"], EnumNumberBody: ["members"], EnumStringBody: ["members"], EnumSymbolBody: ["members"], EnumBooleanMember: ["id", "init"], EnumNumberMember: ["id", "init"], EnumStringMember: ["id", "init"], EnumDefaultedMember: ["id"], IndexedAccessType: ["objectType", "indexType"], OptionalIndexedAccessType: ["objectType", "indexType"], JSXAttribute: ["name", "value"], JSXClosingElement: ["name"], JSXElement: ["openingElement", "children", "closingElement"], JSXEmptyExpression: [], JSXExpressionContainer: ["expression"], JSXSpreadChild: ["expression"], JSXIdentifier: [], JSXMemberExpression: ["object", "property"], JSXNamespacedName: ["namespace", "name"], JSXOpeningElement: ["name", "attributes", "typeArguments", "typeParameters"], JSXSpreadAttribute: ["argument"], JSXText: [], JSXFragment: ["openingFragment", "children", "closingFragment"], JSXOpeningFragment: [], JSXClosingFragment: [], Noop: [], Placeholder: [], V8IntrinsicIdentifier: [], ArgumentPlaceholder: [], BindExpression: ["object", "callee"], ImportAttribute: ["key", "value"], Decorator: ["expression"], DoExpression: ["body"], ExportDefaultSpecifier: ["exported"], RecordExpression: ["properties"], TupleExpression: ["elements"], DecimalLiteral: [], ModuleExpression: ["body"], TopicReference: [], PipelineTopicExpression: ["expression"], PipelineBareFunction: ["callee"], PipelinePrimaryTopicReference: [], TSParameterProperty: ["parameter", "decorators"], TSDeclareFunction: ["id", "typeParameters", "params", "returnType", "body"], TSDeclareMethod: ["decorators", "key", "typeParameters", "params", "returnType"], TSQualifiedName: ["left", "right"], TSCallSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSPropertySignature: ["key", "typeAnnotation"], TSMethodSignature: ["key", "typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSIndexSignature: ["parameters", "typeAnnotation"], TSAnyKeyword: [], TSBooleanKeyword: [], TSBigIntKeyword: [], TSIntrinsicKeyword: [], TSNeverKeyword: [], TSNullKeyword: [], TSNumberKeyword: [], TSObjectKeyword: [], TSStringKeyword: [], TSSymbolKeyword: [], TSUndefinedKeyword: [], TSUnknownKeyword: [], TSVoidKeyword: [], TSThisType: [], TSFunctionType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructorType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSTypeReference: ["typeName", "typeParameters", "typeArguments"], TSTypePredicate: ["parameterName", "typeAnnotation"], TSTypeQuery: ["exprName", "typeParameters", "typeArguments"], TSTypeLiteral: ["members"], TSArrayType: ["elementType"], TSTupleType: ["elementTypes"], TSOptionalType: ["typeAnnotation"], TSRestType: ["typeAnnotation"], TSNamedTupleMember: ["label", "elementType"], TSUnionType: ["types"], TSIntersectionType: ["types"], TSConditionalType: ["checkType", "extendsType", "trueType", "falseType"], TSInferType: ["typeParameter"], TSParenthesizedType: ["typeAnnotation"], TSTypeOperator: ["typeAnnotation"], TSIndexedAccessType: ["objectType", "indexType"], TSMappedType: ["typeParameter", "typeAnnotation", "nameType"], TSLiteralType: ["literal"], TSExpressionWithTypeArguments: ["expression", "typeParameters"], TSInterfaceDeclaration: ["id", "typeParameters", "extends", "body"], TSInterfaceBody: ["body"], TSTypeAliasDeclaration: ["id", "typeParameters", "typeAnnotation"], TSInstantiationExpression: ["expression", "typeParameters", "typeArguments"], TSAsExpression: ["expression", "typeAnnotation"], TSSatisfiesExpression: ["expression", "typeAnnotation"], TSTypeAssertion: ["typeAnnotation", "expression"], TSEnumDeclaration: ["id", "members"], TSEnumMember: ["id", "initializer"], TSModuleDeclaration: ["id", "body"], TSModuleBlock: ["body"], TSImportType: ["argument", "qualifier", "typeParameters", "typeArguments"], TSImportEqualsDeclaration: ["id", "moduleReference"], TSExternalModuleReference: ["expression"], TSNonNullExpression: ["expression"], TSExportAssignment: ["expression"], TSNamespaceExportDeclaration: ["id"], TSTypeAnnotation: ["typeAnnotation"], TSTypeParameterInstantiation: ["params"], TSTypeParameterDeclaration: ["params"], TSTypeParameter: ["constraint", "default", "name"], ChainExpression: ["expression"], ExperimentalRestProperty: ["argument"], ExperimentalSpreadProperty: ["argument"], Literal: [], MethodDefinition: ["decorators", "key", "value"], PrivateIdentifier: [], Property: ["key", "value"], PropertyDefinition: ["decorators", "key", "typeAnnotation", "value", "variance"], AccessorProperty: ["decorators", "key", "typeAnnotation", "value"], TSAbstractAccessorProperty: ["decorators", "key", "typeAnnotation"], TSAbstractKeyword: [], TSAbstractMethodDefinition: ["key", "value"], TSAbstractPropertyDefinition: ["decorators", "key", "typeAnnotation"], TSAsyncKeyword: [], TSClassImplements: ["expression", "typeArguments", "typeParameters"], TSDeclareKeyword: [], TSEmptyBodyFunctionExpression: ["id", "typeParameters", "params", "returnType"], TSEnumBody: ["members"], TSExportKeyword: [], TSInterfaceHeritage: ["expression", "typeArguments", "typeParameters"], TSPrivateKeyword: [], TSProtectedKeyword: [], TSPublicKeyword: [], TSReadonlyKeyword: [], TSStaticKeyword: [], TSTemplateLiteralType: ["quasis", "types"], AsConstExpression: ["expression"], AsExpression: ["expression", "typeAnnotation"], BigIntLiteralTypeAnnotation: [], BigIntTypeAnnotation: [], ComponentDeclaration: ["id", "params", "body", "typeParameters", "rendersType"], ComponentParameter: ["name", "local"], ComponentTypeAnnotation: ["params", "rest", "typeParameters", "rendersType"], ComponentTypeParameter: ["name", "typeAnnotation"], ConditionalTypeAnnotation: ["checkType", "extendsType", "trueType", "falseType"], DeclareComponent: ["id", "params", "rest", "typeParameters", "rendersType"], DeclareEnum: ["id", "body"], DeclareHook: ["id"], DeclareNamespace: ["id", "body"], EnumBigIntBody: ["members"], EnumBigIntMember: ["id", "init"], HookDeclaration: ["id", "params", "body", "typeParameters", "returnType"], HookTypeAnnotation: ["params", "returnType", "rest", "typeParameters"], InferTypeAnnotation: ["typeParameter"], KeyofTypeAnnotation: ["argument"], ObjectTypeMappedTypeProperty: ["keyTparam", "propType", "sourceType", "variance"], QualifiedTypeofIdentifier: ["qualification", "id"], TupleTypeLabeledElement: ["label", "elementType", "variance"], TupleTypeSpreadElement: ["label", "typeAnnotation"], TypeOperator: ["typeAnnotation"], TypePredicate: ["parameterName", "typeAnnotation", "asserts"], NGRoot: ["node"], NGPipeExpression: ["left", "right", "arguments"], NGChainedExpression: ["expressions"], NGEmptyExpression: [], NGMicrosyntax: ["body"], NGMicrosyntaxKey: [], NGMicrosyntaxExpression: ["expression", "alias"], NGMicrosyntaxKeyedExpression: ["key", "expression"], NGMicrosyntaxLet: ["key", "value"], NGMicrosyntaxAs: ["key", "alias"], JsExpressionRoot: ["node"], JsonRoot: ["node"], TSJSDocAllType: [], TSJSDocUnknownType: [], TSJSDocNullableType: ["typeAnnotation"], TSJSDocNonNullableType: ["typeAnnotation"], NeverTypeAnnotation: [], UndefinedTypeAnnotation: [], UnknownTypeAnnotation: [], SatisfiesExpression: ["expression", "typeAnnotation"] };
      var Nr3 = Ps2(gs), Ts2 = Nr3;
      function Et3(a2, t2) {
        if (!(a2 !== null && typeof a2 == "object"))
          return a2;
        if (Array.isArray(a2)) {
          for (let s2 = 0; s2 < a2.length; s2++)
            a2[s2] = Et3(a2[s2], t2);
          return a2;
        }
        let e2 = Ts2(a2);
        for (let s2 = 0; s2 < e2.length; s2++)
          a2[e2[s2]] = Et3(a2[e2[s2]], t2);
        return t2(a2) || a2;
      }
      var Be3 = Et3;
      function kr3(a2, t2) {
        let { parser: e2, text: s2 } = t2;
        if (a2.type === "File" && a2.program.interpreter) {
          let { program: { interpreter: i2 }, comments: r2 } = a2;
          delete a2.program.interpreter, r2.unshift(i2);
        }
        if (e2 === "babel") {
          let i2 = /* @__PURE__ */ new Set();
          a2 = Be3(a2, (r2) => {
            var n2;
            (n2 = r2.leadingComments) != null && n2.some(xs) && i2.add(D(r2));
          }), a2 = Be3(a2, (r2) => {
            if (r2.type === "ParenthesizedExpression") {
              let { expression: n2 } = r2;
              if (n2.type === "TypeCastExpression")
                return n2.range = [...r2.range], n2;
              let o2 = D(r2);
              if (!i2.has(o2))
                return n2.extra = { ...n2.extra, parenthesized: true }, n2;
            }
          });
        }
        if (a2 = Be3(a2, (i2) => {
          var r2;
          switch (i2.type) {
            case "LogicalExpression":
              if (bs2(i2))
                return It2(i2);
              break;
            case "VariableDeclaration": {
              let n2 = St3(false, i2.declarations, -1);
              n2 != null && n2.init && s2[B2(n2)] !== ";" && (i2.range = [D(i2), B2(n2)]);
              break;
            }
            case "TSParenthesizedType":
              return i2.typeAnnotation;
            case "TSTypeParameter":
              if (typeof i2.name == "string") {
                let n2 = D(i2);
                i2.name = { type: "Identifier", name: i2.name, range: [n2, n2 + i2.name.length] };
              }
              break;
            case "TopicReference":
              a2.extra = { ...a2.extra, __isUsingHackPipeline: true };
              break;
            case "ExportAllDeclaration":
              if (e2 === "meriyah" && ((r2 = i2.exported) == null ? void 0 : r2.type) === "Identifier") {
                let { exported: n2 } = i2, o2 = s2.slice(D(n2), B2(n2));
                (o2.startsWith('"') || o2.startsWith("'")) && (i2.exported = { ...i2.exported, type: "Literal", value: i2.exported.name, raw: o2 });
              }
              break;
            case "TSUnionType":
            case "TSIntersectionType":
              if (i2.types.length === 1)
                return i2.types[0];
              break;
          }
        }), Pe3(a2.comments)) {
          let i2 = St3(false, a2.comments, -1);
          for (let r2 = a2.comments.length - 2; r2 >= 0; r2--) {
            let n2 = a2.comments[r2];
            B2(n2) === D(i2) && ge2(n2) && ge2(i2) && wt3(n2) && wt3(i2) && (a2.comments.splice(r2 + 1, 1), n2.value += "*//*" + i2.value, n2.range = [D(n2), B2(i2)]), i2 = n2;
          }
        }
        return a2.type === "Program" && (a2.range = [0, s2.length]), a2;
      }
      function bs2(a2) {
        return a2.type === "LogicalExpression" && a2.right.type === "LogicalExpression" && a2.operator === a2.right.operator;
      }
      function It2(a2) {
        return bs2(a2) ? It2({ type: "LogicalExpression", operator: a2.operator, left: It2({ type: "LogicalExpression", operator: a2.operator, left: a2.left, right: a2.right.left, range: [D(a2.left), B2(a2.right.left)] }), right: a2.right.right, range: [D(a2), B2(a2)] }) : a2;
      }
      var As2 = kr3;
      function vr3(a2, t2) {
        let e2 = new SyntaxError(a2 + " (" + t2.loc.start.line + ":" + t2.loc.start.column + ")");
        return Object.assign(e2, t2);
      }
      var Re3 = vr3;
      function Lr3(a2) {
        let { message: t2, loc: { line: e2, column: s2 }, reasonCode: i2 } = a2, r2 = a2;
        (i2 === "MissingPlugin" || i2 === "MissingOneOfPlugins") && (t2 = "Unexpected token.", r2 = void 0);
        let n2 = ` (${e2}:${s2})`;
        return t2.endsWith(n2) && (t2 = t2.slice(0, -n2.length)), Re3(t2, { loc: { start: { line: e2, column: s2 + 1 } }, cause: r2 });
      }
      var Ue2 = Lr3;
      var Dr2 = (a2, t2, e2, s2) => {
        if (!(a2 && t2 == null))
          return t2.replaceAll ? t2.replaceAll(e2, s2) : e2.global ? t2.replace(e2, s2) : t2.split(e2).join(s2);
      }, ie2 = Dr2;
      var Mr2 = /\*\/$/, Or2 = /^\/\*\*?/, Fr2 = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, Br2 = /(^|\s+)\/\/([^\n\r]*)/g, Ss2 = /^(\r?\n)+/, Rr2 = /(?:^|\r?\n) *(@[^\n\r]*?) *\r?\n *(?![^\n\r@]*\/\/[^]*)([^\s@][^\n\r@]+?) *\r?\n/g, ws = /(?:^|\r?\n) *@(\S+) *([^\n\r]*)/g, Ur2 = /(\r?\n|^) *\* ?/g, _r3 = [];
      function Cs2(a2) {
        let t2 = a2.match(Fr2);
        return t2 ? t2[0].trimStart() : "";
      }
      function Es2(a2) {
        let t2 = `
`;
        a2 = ie2(false, a2.replace(Or2, "").replace(Mr2, ""), Ur2, "$1");
        let e2 = "";
        for (; e2 !== a2; )
          e2 = a2, a2 = ie2(false, a2, Rr2, `${t2}$1 $2${t2}`);
        a2 = a2.replace(Ss2, "").trimEnd();
        let s2 = /* @__PURE__ */ Object.create(null), i2 = ie2(false, a2, ws, "").replace(Ss2, "").trimEnd(), r2;
        for (; r2 = ws.exec(a2); ) {
          let n2 = ie2(false, r2[2], Br2, "");
          if (typeof s2[r2[1]] == "string" || Array.isArray(s2[r2[1]])) {
            let o2 = s2[r2[1]];
            s2[r2[1]] = [..._r3, ...Array.isArray(o2) ? o2 : [o2], n2];
          } else
            s2[r2[1]] = n2;
        }
        return { comments: i2, pragmas: s2 };
      }
      function jr3(a2) {
        let t2 = Fe3(a2);
        t2 && (a2 = a2.slice(t2.length + 1));
        let e2 = Cs2(a2), { pragmas: s2, comments: i2 } = Es2(e2);
        return { shebang: t2, text: a2, pragmas: s2, comments: i2 };
      }
      function Is2(a2) {
        let { pragmas: t2 } = jr3(a2);
        return Object.prototype.hasOwnProperty.call(t2, "prettier") || Object.prototype.hasOwnProperty.call(t2, "format");
      }
      function $r3(a2) {
        return a2 = typeof a2 == "function" ? { parse: a2 } : a2, { astFormat: "estree", hasPragma: Is2, locStart: D, locEnd: B2, ...a2 };
      }
      var G3 = $r3;
      function Vr2(a2) {
        let { filepath: t2 } = a2;
        if (t2) {
          if (t2 = t2.toLowerCase(), t2.endsWith(".cjs"))
            return "script";
          if (t2.endsWith(".mjs"))
            return "module";
        }
      }
      var Ns = Vr2;
      function qr2(a2, t2) {
        let { type: e2 = "JsExpressionRoot", rootMarker: s2, text: i2 } = t2, { tokens: r2, comments: n2 } = a2;
        return delete a2.tokens, delete a2.comments, { tokens: r2, comments: n2, type: e2, node: a2, range: [0, i2.length], rootMarker: s2 };
      }
      var _e3 = qr2;
      var re3 = (a2) => G3(Jr2(a2)), zr2 = { sourceType: "module", allowImportExportEverywhere: true, allowReturnOutsideFunction: true, allowNewTargetOutsideFunction: true, allowSuperOutsideMethod: true, allowUndeclaredExports: true, errorRecovery: true, createParenthesizedExpressions: true, createImportExpressions: true, plugins: ["doExpressions", "exportDefaultFrom", "functionBind", "functionSent", "throwExpressions", "partialApplication", "decorators", "decimal", "moduleBlocks", "asyncDoExpressions", "destructuringPrivate", "decoratorAutoAccessors", "importReflection", "explicitResourceManagement", ["importAttributes", { deprecatedAssertSyntax: true }], "sourcePhaseImports", "deferredImportEvaluation", ["optionalChainingAssign", { version: "2023-07" }], "recordAndTuple"], tokens: true, ranges: true }, ks2 = "v8intrinsic", vs = [["pipelineOperator", { proposal: "hack", topicToken: "%" }], ["pipelineOperator", { proposal: "minimal" }], ["pipelineOperator", { proposal: "fsharp" }]], V2 = (a2, t2 = zr2) => ({ ...t2, plugins: [...t2.plugins, ...a2] }), Kr2 = /@(?:no)?flow\b/u;
      function Hr3(a2, t2) {
        var i2;
        if ((i2 = t2.filepath) != null && i2.endsWith(".js.flow"))
          return true;
        let e2 = Fe3(a2);
        e2 && (a2 = a2.slice(e2.length));
        let s2 = ds(a2, 0);
        return s2 !== false && (a2 = a2.slice(0, s2)), Kr2.test(a2);
      }
      function Wr2(a2, t2, e2) {
        let s2 = a2(t2, e2), i2 = s2.errors.find((r2) => !Xr2.has(r2.reasonCode));
        if (i2)
          throw i2;
        return s2;
      }
      function Jr2({ isExpression: a2 = false, optionsCombinations: t2 }) {
        return (e2, s2 = {}) => {
          if ((s2.parser === "babel" || s2.parser === "__babel_estree") && Hr3(e2, s2))
            return s2.parser = "babel-flow", Bs2.parse(e2, s2);
          let i2 = t2;
          (s2.__babelSourceType ?? Ns(s2)) === "script" && (i2 = i2.map((c2) => ({ ...c2, sourceType: "script" })));
          let n2 = /%[A-Z]/u.test(e2);
          e2.includes("|>") ? i2 = (n2 ? [...vs, ks2] : vs).flatMap((l2) => i2.map((u2) => V2([l2], u2))) : n2 && (i2 = i2.map((c2) => V2([ks2], c2)));
          let o2 = a2 ? je2.parseExpression : je2.parse, h2;
          try {
            h2 = ms(i2.map((c2) => () => Wr2(o2, e2, c2)));
          } catch ({ errors: [c2] }) {
            throw Ue2(c2);
          }
          return a2 && (h2 = _e3(h2, { text: e2, rootMarker: s2.rootMarker })), As2(h2, { parser: "babel", text: e2 });
        };
      }
      var Xr2 = /* @__PURE__ */ new Set(["StrictNumericEscape", "StrictWith", "StrictOctalLiteral", "StrictDelete", "StrictEvalArguments", "StrictEvalArgumentsBinding", "StrictFunction", "ForInOfLoopInitializer", "EmptyTypeArguments", "EmptyTypeParameters", "ConstructorHasTypeParameters", "UnsupportedParameterPropertyKind", "DecoratorExportClass", "ParamDupe", "InvalidDecimal", "RestTrailingComma", "UnsupportedParameterDecorator", "UnterminatedJsxContent", "UnexpectedReservedWord", "ModuleAttributesWithDuplicateKeys", "LineTerminatorBeforeArrow", "InvalidEscapeSequenceTemplate", "NonAbstractClassHasAbstractMethod", "OptionalTypeBeforeRequired", "PatternIsOptional", "OptionalBindingPattern", "DeclareClassFieldHasInitializer", "TypeImportCannotSpecifyDefaultAndNamed", "ConstructorClassField", "VarRedeclaration", "InvalidPrivateFieldResolution", "DuplicateExport"]), Fs2 = [V2(["jsx"])], Ls = re3({ optionsCombinations: Fs2 }), Ds2 = re3({ optionsCombinations: [V2(["jsx", "typescript"]), V2(["typescript"])] }), Ms2 = re3({ isExpression: true, optionsCombinations: [V2(["jsx"])] }), Os2 = re3({ isExpression: true, optionsCombinations: [V2(["typescript"])] }), Bs2 = re3({ optionsCombinations: [V2(["jsx", ["flow", { all: true, enums: true }], "flowComments"])] }), Gr3 = re3({ optionsCombinations: Fs2.map((a2) => V2(["estree"], a2)) }), Rs2 = { babel: Ls, "babel-flow": Bs2, "babel-ts": Ds2, __js_expression: Ms2, __ts_expression: Os2, __vue_expression: Ms2, __vue_ts_expression: Os2, __vue_event_binding: Ls, __vue_ts_event_binding: Ds2, __babel_estree: Gr3 };
      var Us2 = vt2(At3(), 1);
      function _s2(a2 = {}) {
        let { allowComments: t2 = true } = a2;
        return function(s2) {
          let i2;
          try {
            i2 = (0, Us2.parseExpression)(s2, { tokens: true, ranges: true, attachComment: false });
          } catch (r2) {
            throw Ue2(r2);
          }
          if (!t2 && Pe3(i2.comments))
            throw H3(i2.comments[0], "Comment");
          return ae2(i2), _e3(i2, { type: "JsonRoot", text: s2 });
        };
      }
      function H3(a2, t2) {
        let [e2, s2] = [a2.loc.start, a2.loc.end].map(({ line: i2, column: r2 }) => ({ line: i2, column: r2 + 1 }));
        return Re3(`${t2} is not allowed in JSON.`, { loc: { start: e2, end: s2 } });
      }
      function ae2(a2) {
        switch (a2.type) {
          case "ArrayExpression":
            for (let t2 of a2.elements)
              t2 !== null && ae2(t2);
            return;
          case "ObjectExpression":
            for (let t2 of a2.properties)
              ae2(t2);
            return;
          case "ObjectProperty":
            if (a2.computed)
              throw H3(a2.key, "Computed key");
            if (a2.shorthand)
              throw H3(a2.key, "Shorthand property");
            a2.key.type !== "Identifier" && ae2(a2.key), ae2(a2.value);
            return;
          case "UnaryExpression": {
            let { operator: t2, argument: e2 } = a2;
            if (t2 !== "+" && t2 !== "-")
              throw H3(a2, `Operator '${a2.operator}'`);
            if (e2.type === "NumericLiteral" || e2.type === "Identifier" && (e2.name === "Infinity" || e2.name === "NaN"))
              return;
            throw H3(e2, `Operator '${t2}' before '${e2.type}'`);
          }
          case "Identifier":
            if (a2.name !== "Infinity" && a2.name !== "NaN" && a2.name !== "undefined")
              throw H3(a2, `Identifier '${a2.name}'`);
            return;
          case "TemplateLiteral":
            if (Pe3(a2.expressions))
              throw H3(a2.expressions[0], "'TemplateLiteral' with expression");
            for (let t2 of a2.quasis)
              ae2(t2);
            return;
          case "NullLiteral":
          case "BooleanLiteral":
          case "NumericLiteral":
          case "StringLiteral":
          case "TemplateElement":
            return;
          default:
            throw H3(a2, `'${a2.type}'`);
        }
      }
      var Nt2 = _s2(), Yr3 = { json: G3({ parse: Nt2, hasPragma() {
        return true;
      } }), json5: G3(Nt2), jsonc: G3(Nt2), "json-stringify": G3({ parse: _s2({ allowComments: false }), astFormat: "estree-json" }) }, js2 = Yr3;
      var Qr2 = { ...Rs2, ...js2 };
      return Js2(Zr2);
    });
  }
});

// node_modules/@react-three/uikit/node_modules/prettier/plugins/estree.js
var require_estree = __commonJS({
  "node_modules/@react-three/uikit/node_modules/prettier/plugins/estree.js"(exports, module) {
    (function(f2) {
      function e2() {
        var i2 = f2();
        return i2.default || i2;
      }
      if (typeof exports == "object" && typeof module == "object")
        module.exports = e2();
      else if (typeof define == "function" && define.amd)
        define(e2);
      else {
        var t2 = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
        t2.prettierPlugins = t2.prettierPlugins || {}, t2.prettierPlugins.estree = e2();
      }
    })(function() {
      "use strict";
      var In2 = Object.defineProperty;
      var Wa = Object.getOwnPropertyDescriptor;
      var Ga = Object.getOwnPropertyNames;
      var Ua2 = Object.prototype.hasOwnProperty;
      var Js2 = (e2) => {
        throw TypeError(e2);
      };
      var Ar3 = (e2, t2) => {
        for (var r2 in t2)
          In2(e2, r2, { get: t2[r2], enumerable: true });
      }, Na2 = (e2, t2, r2, n2) => {
        if (t2 && typeof t2 == "object" || typeof t2 == "function")
          for (let s2 of Ga(t2))
            !Ua2.call(e2, s2) && s2 !== r2 && In2(e2, s2, { get: () => t2[s2], enumerable: !(n2 = Wa(t2, s2)) || n2.enumerable });
        return e2;
      };
      var Xa = (e2) => Na2(In2({}, "__esModule", { value: true }), e2);
      var qs2 = (e2, t2, r2) => t2.has(e2) || Js2("Cannot " + r2);
      var pt3 = (e2, t2, r2) => (qs2(e2, t2, "read from private field"), r2 ? r2.call(e2) : t2.get(e2)), Ws2 = (e2, t2, r2) => t2.has(e2) ? Js2("Cannot add the same private member more than once") : t2 instanceof WeakSet ? t2.add(e2) : t2.set(e2, r2), Gs2 = (e2, t2, r2, n2) => (qs2(e2, t2, "write to private field"), n2 ? n2.call(e2, r2) : t2.set(e2, r2), r2);
      var om = {};
      Ar3(om, { languages: () => am, options: () => va2, printers: () => im });
      var Us2 = [{ linguistLanguageId: 183, name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib", ".wxs"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell", "zx"], parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"] }, { linguistLanguageId: 183, name: "Flow", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: [], extensions: [".js.flow"], filenames: [], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"] }, { linguistLanguageId: 183, name: "JSX", type: "programming", tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0, aliases: void 0, extensions: [".jsx"], filenames: void 0, interpreters: void 0, parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], group: "JavaScript" }, { linguistLanguageId: 378, name: "TypeScript", type: "programming", color: "#3178c6", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts", ".cts", ".mts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"] }, { linguistLanguageId: 94901924, name: "TSX", type: "programming", color: "#3178c6", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] }];
      var Os2 = {};
      Ar3(Os2, { canAttachComment: () => Ap2, embed: () => Qu3, experimentalFeatures: () => em, getCommentChildNodes: () => Tp2, getVisitorKeys: () => gr3, handleComments: () => zn3, insertPragma: () => pi3, isBlockComment: () => re3, isGap: () => dp, massageAstNode: () => Cu3, print: () => Ia2, printComment: () => Pu2, willPrintOwnComments: () => Qn3 });
      var Ya = (e2, t2, r2, n2) => {
        if (!(e2 && t2 == null))
          return t2.replaceAll ? t2.replaceAll(r2, n2) : r2.global ? t2.replace(r2, n2) : t2.split(r2).join(n2);
      }, N2 = Ya;
      var Ha = (e2, t2, r2) => {
        if (!(e2 && t2 == null))
          return Array.isArray(t2) || typeof t2 == "string" ? t2[r2 < 0 ? t2.length + r2 : r2] : t2.at(r2);
      }, O2 = Ha;
      function Va(e2) {
        return e2 !== null && typeof e2 == "object";
      }
      var Ns = Va;
      function* $a2(e2, t2) {
        let { getVisitorKeys: r2, filter: n2 = () => true } = t2, s2 = (u2) => Ns(u2) && n2(u2);
        for (let u2 of r2(e2)) {
          let i2 = e2[u2];
          if (Array.isArray(i2))
            for (let a2 of i2)
              s2(a2) && (yield a2);
          else
            s2(i2) && (yield i2);
        }
      }
      function* Ka(e2, t2) {
        let r2 = [e2];
        for (let n2 = 0; n2 < r2.length; n2++) {
          let s2 = r2[n2];
          for (let u2 of $a2(s2, t2))
            yield u2, r2.push(u2);
        }
      }
      function Xs2(e2, { getVisitorKeys: t2, predicate: r2 }) {
        for (let n2 of Ka(e2, { getVisitorKeys: t2 }))
          if (r2(n2))
            return true;
        return false;
      }
      var Ys2 = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
      function Hs2(e2) {
        return e2 === 12288 || e2 >= 65281 && e2 <= 65376 || e2 >= 65504 && e2 <= 65510;
      }
      function Vs2(e2) {
        return e2 >= 4352 && e2 <= 4447 || e2 === 8986 || e2 === 8987 || e2 === 9001 || e2 === 9002 || e2 >= 9193 && e2 <= 9196 || e2 === 9200 || e2 === 9203 || e2 === 9725 || e2 === 9726 || e2 === 9748 || e2 === 9749 || e2 >= 9800 && e2 <= 9811 || e2 === 9855 || e2 === 9875 || e2 === 9889 || e2 === 9898 || e2 === 9899 || e2 === 9917 || e2 === 9918 || e2 === 9924 || e2 === 9925 || e2 === 9934 || e2 === 9940 || e2 === 9962 || e2 === 9970 || e2 === 9971 || e2 === 9973 || e2 === 9978 || e2 === 9981 || e2 === 9989 || e2 === 9994 || e2 === 9995 || e2 === 10024 || e2 === 10060 || e2 === 10062 || e2 >= 10067 && e2 <= 10069 || e2 === 10071 || e2 >= 10133 && e2 <= 10135 || e2 === 10160 || e2 === 10175 || e2 === 11035 || e2 === 11036 || e2 === 11088 || e2 === 11093 || e2 >= 11904 && e2 <= 11929 || e2 >= 11931 && e2 <= 12019 || e2 >= 12032 && e2 <= 12245 || e2 >= 12272 && e2 <= 12287 || e2 >= 12289 && e2 <= 12350 || e2 >= 12353 && e2 <= 12438 || e2 >= 12441 && e2 <= 12543 || e2 >= 12549 && e2 <= 12591 || e2 >= 12593 && e2 <= 12686 || e2 >= 12688 && e2 <= 12771 || e2 >= 12783 && e2 <= 12830 || e2 >= 12832 && e2 <= 12871 || e2 >= 12880 && e2 <= 19903 || e2 >= 19968 && e2 <= 42124 || e2 >= 42128 && e2 <= 42182 || e2 >= 43360 && e2 <= 43388 || e2 >= 44032 && e2 <= 55203 || e2 >= 63744 && e2 <= 64255 || e2 >= 65040 && e2 <= 65049 || e2 >= 65072 && e2 <= 65106 || e2 >= 65108 && e2 <= 65126 || e2 >= 65128 && e2 <= 65131 || e2 >= 94176 && e2 <= 94180 || e2 === 94192 || e2 === 94193 || e2 >= 94208 && e2 <= 100343 || e2 >= 100352 && e2 <= 101589 || e2 >= 101632 && e2 <= 101640 || e2 >= 110576 && e2 <= 110579 || e2 >= 110581 && e2 <= 110587 || e2 === 110589 || e2 === 110590 || e2 >= 110592 && e2 <= 110882 || e2 === 110898 || e2 >= 110928 && e2 <= 110930 || e2 === 110933 || e2 >= 110948 && e2 <= 110951 || e2 >= 110960 && e2 <= 111355 || e2 === 126980 || e2 === 127183 || e2 === 127374 || e2 >= 127377 && e2 <= 127386 || e2 >= 127488 && e2 <= 127490 || e2 >= 127504 && e2 <= 127547 || e2 >= 127552 && e2 <= 127560 || e2 === 127568 || e2 === 127569 || e2 >= 127584 && e2 <= 127589 || e2 >= 127744 && e2 <= 127776 || e2 >= 127789 && e2 <= 127797 || e2 >= 127799 && e2 <= 127868 || e2 >= 127870 && e2 <= 127891 || e2 >= 127904 && e2 <= 127946 || e2 >= 127951 && e2 <= 127955 || e2 >= 127968 && e2 <= 127984 || e2 === 127988 || e2 >= 127992 && e2 <= 128062 || e2 === 128064 || e2 >= 128066 && e2 <= 128252 || e2 >= 128255 && e2 <= 128317 || e2 >= 128331 && e2 <= 128334 || e2 >= 128336 && e2 <= 128359 || e2 === 128378 || e2 === 128405 || e2 === 128406 || e2 === 128420 || e2 >= 128507 && e2 <= 128591 || e2 >= 128640 && e2 <= 128709 || e2 === 128716 || e2 >= 128720 && e2 <= 128722 || e2 >= 128725 && e2 <= 128727 || e2 >= 128732 && e2 <= 128735 || e2 === 128747 || e2 === 128748 || e2 >= 128756 && e2 <= 128764 || e2 >= 128992 && e2 <= 129003 || e2 === 129008 || e2 >= 129292 && e2 <= 129338 || e2 >= 129340 && e2 <= 129349 || e2 >= 129351 && e2 <= 129535 || e2 >= 129648 && e2 <= 129660 || e2 >= 129664 && e2 <= 129672 || e2 >= 129680 && e2 <= 129725 || e2 >= 129727 && e2 <= 129733 || e2 >= 129742 && e2 <= 129755 || e2 >= 129760 && e2 <= 129768 || e2 >= 129776 && e2 <= 129784 || e2 >= 131072 && e2 <= 196605 || e2 >= 196608 && e2 <= 262141;
      }
      var $s2 = (e2) => !(Hs2(e2) || Vs2(e2));
      var za = /[^\x20-\x7F]/u;
      function Qa(e2) {
        if (!e2)
          return 0;
        if (!za.test(e2))
          return e2.length;
        e2 = e2.replace(Ys2(), "  ");
        let t2 = 0;
        for (let r2 of e2) {
          let n2 = r2.codePointAt(0);
          n2 <= 31 || n2 >= 127 && n2 <= 159 || n2 >= 768 && n2 <= 879 || (t2 += $s2(n2) ? 1 : 2);
        }
        return t2;
      }
      var et2 = Qa;
      function Tr2(e2) {
        return (t2, r2, n2) => {
          let s2 = !!(n2 != null && n2.backwards);
          if (r2 === false)
            return false;
          let { length: u2 } = t2, i2 = r2;
          for (; i2 >= 0 && i2 < u2; ) {
            let a2 = t2.charAt(i2);
            if (e2 instanceof RegExp) {
              if (!e2.test(a2))
                return i2;
            } else if (!e2.includes(a2))
              return i2;
            s2 ? i2-- : i2++;
          }
          return i2 === -1 || i2 === u2 ? i2 : false;
        };
      }
      var Bm = Tr2(/\s/u), Ge3 = Tr2(" 	"), Ks = Tr2(",; 	"), zs2 = Tr2(/[^\n\r]/u);
      function Za(e2, t2, r2) {
        let n2 = !!(r2 != null && r2.backwards);
        if (t2 === false)
          return false;
        let s2 = e2.charAt(t2);
        if (n2) {
          if (e2.charAt(t2 - 1) === "\r" && s2 === `
`)
            return t2 - 2;
          if (s2 === `
` || s2 === "\r" || s2 === "\u2028" || s2 === "\u2029")
            return t2 - 1;
        } else {
          if (s2 === "\r" && e2.charAt(t2 + 1) === `
`)
            return t2 + 2;
          if (s2 === `
` || s2 === "\r" || s2 === "\u2028" || s2 === "\u2029")
            return t2 + 1;
        }
        return t2;
      }
      var Ue2 = Za;
      function eo2(e2, t2, r2 = {}) {
        let n2 = Ge3(e2, r2.backwards ? t2 - 1 : t2, r2), s2 = Ue2(e2, n2, r2);
        return n2 !== s2;
      }
      var te2 = eo2;
      function to2(e2, t2) {
        if (t2 === false)
          return false;
        if (e2.charAt(t2) === "/" && e2.charAt(t2 + 1) === "*") {
          for (let r2 = t2 + 2; r2 < e2.length; ++r2)
            if (e2.charAt(r2) === "*" && e2.charAt(r2 + 1) === "/")
              return r2 + 2;
        }
        return t2;
      }
      var Lt2 = to2;
      function ro2(e2, t2) {
        return t2 === false ? false : e2.charAt(t2) === "/" && e2.charAt(t2 + 1) === "/" ? zs2(e2, t2) : t2;
      }
      var wt3 = ro2;
      function no2(e2, t2) {
        let r2 = null, n2 = t2;
        for (; n2 !== r2; )
          r2 = n2, n2 = Ks(e2, n2), n2 = Lt2(e2, n2), n2 = Ge3(e2, n2);
        return n2 = wt3(e2, n2), n2 = Ue2(e2, n2), n2 !== false && te2(e2, n2);
      }
      var Ot2 = no2;
      function so2(e2) {
        return Array.isArray(e2) && e2.length > 0;
      }
      var w2 = so2;
      var dr3 = "'", Qs2 = '"';
      function uo2(e2, t2) {
        let r2 = t2 === true || t2 === dr3 ? dr3 : Qs2, n2 = r2 === dr3 ? Qs2 : dr3, s2 = 0, u2 = 0;
        for (let i2 of e2)
          i2 === r2 ? s2++ : i2 === n2 && u2++;
        return s2 > u2 ? n2 : r2;
      }
      var xr3 = uo2;
      function io2(e2, t2, r2) {
        let n2 = t2 === '"' ? "'" : '"', u2 = N2(false, e2, /\\(.)|(["'])/gsu, (i2, a2, o2) => a2 === n2 ? a2 : o2 === t2 ? "\\" + o2 : o2 || (r2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(a2) ? a2 : "\\" + a2));
        return t2 + u2 + t2;
      }
      var Zs = io2;
      function ao2(e2, t2) {
        let r2 = e2.slice(1, -1), n2 = t2.parser === "json" || t2.parser === "jsonc" || t2.parser === "json5" && t2.quoteProps === "preserve" && !t2.singleQuote ? '"' : t2.__isInHtmlAttribute ? "'" : xr3(r2, t2.singleQuote);
        return Zs(r2, n2, !(t2.parser === "css" || t2.parser === "less" || t2.parser === "scss" || t2.__embeddedInHtml));
      }
      var tt2 = ao2;
      function R3(e2) {
        var n2, s2, u2;
        let t2 = ((n2 = e2.range) == null ? void 0 : n2[0]) ?? e2.start, r2 = (u2 = ((s2 = e2.declaration) == null ? void 0 : s2.decorators) ?? e2.decorators) == null ? void 0 : u2[0];
        return r2 ? Math.min(R3(r2), t2) : t2;
      }
      function k(e2) {
        var t2;
        return ((t2 = e2.range) == null ? void 0 : t2[1]) ?? e2.end;
      }
      function ht3(e2, t2) {
        let r2 = R3(e2);
        return Number.isInteger(r2) && r2 === R3(t2);
      }
      function oo2(e2, t2) {
        let r2 = k(e2);
        return Number.isInteger(r2) && r2 === k(t2);
      }
      function eu2(e2, t2) {
        return ht3(e2, t2) && oo2(e2, t2);
      }
      var Qt2 = null;
      function Zt(e2) {
        if (Qt2 !== null && typeof Qt2.property) {
          let t2 = Qt2;
          return Qt2 = Zt.prototype = null, t2;
        }
        return Qt2 = Zt.prototype = e2 ?? /* @__PURE__ */ Object.create(null), new Zt();
      }
      var po2 = 10;
      for (let e2 = 0; e2 <= po2; e2++)
        Zt();
      function Ln(e2) {
        return Zt(e2);
      }
      function co2(e2, t2 = "type") {
        Ln(e2);
        function r2(n2) {
          let s2 = n2[t2], u2 = e2[s2];
          if (!Array.isArray(u2))
            throw Object.assign(new Error(`Missing visitor keys for '${s2}'.`), { node: n2 });
          return u2;
        }
        return r2;
      }
      var hr2 = co2;
      var tu2 = { ArrayExpression: ["elements"], AssignmentExpression: ["left", "right"], BinaryExpression: ["left", "right"], InterpreterDirective: [], Directive: ["value"], DirectiveLiteral: [], BlockStatement: ["directives", "body"], BreakStatement: ["label"], CallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], CatchClause: ["param", "body"], ConditionalExpression: ["test", "consequent", "alternate"], ContinueStatement: ["label"], DebuggerStatement: [], DoWhileStatement: ["test", "body"], EmptyStatement: [], ExpressionStatement: ["expression"], File: ["program"], ForInStatement: ["left", "right", "body"], ForStatement: ["init", "test", "update", "body"], FunctionDeclaration: ["id", "params", "body", "returnType", "typeParameters", "predicate"], FunctionExpression: ["id", "params", "body", "returnType", "typeParameters"], Identifier: ["typeAnnotation", "decorators"], IfStatement: ["test", "consequent", "alternate"], LabeledStatement: ["label", "body"], StringLiteral: [], NumericLiteral: [], NullLiteral: [], BooleanLiteral: [], RegExpLiteral: [], LogicalExpression: ["left", "right"], MemberExpression: ["object", "property"], NewExpression: ["callee", "arguments", "typeParameters", "typeArguments"], Program: ["directives", "body"], ObjectExpression: ["properties"], ObjectMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectProperty: ["key", "value", "decorators"], RestElement: ["argument", "typeAnnotation", "decorators"], ReturnStatement: ["argument"], SequenceExpression: ["expressions"], ParenthesizedExpression: ["expression"], SwitchCase: ["test", "consequent"], SwitchStatement: ["discriminant", "cases"], ThisExpression: [], ThrowStatement: ["argument"], TryStatement: ["block", "handler", "finalizer"], UnaryExpression: ["argument"], UpdateExpression: ["argument"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id", "init"], WhileStatement: ["test", "body"], WithStatement: ["object", "body"], AssignmentPattern: ["left", "right", "decorators", "typeAnnotation"], ArrayPattern: ["elements", "typeAnnotation", "decorators"], ArrowFunctionExpression: ["params", "body", "returnType", "typeParameters", "predicate"], ClassBody: ["body"], ClassExpression: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ClassDeclaration: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ExportAllDeclaration: ["source", "attributes", "exported"], ExportDefaultDeclaration: ["declaration"], ExportNamedDeclaration: ["declaration", "specifiers", "source", "attributes"], ExportSpecifier: ["local", "exported"], ForOfStatement: ["left", "right", "body"], ImportDeclaration: ["specifiers", "source", "attributes"], ImportDefaultSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportSpecifier: ["local", "imported"], ImportExpression: ["source", "options", "attributes"], MetaProperty: ["meta", "property"], ClassMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectPattern: ["properties", "typeAnnotation", "decorators"], SpreadElement: ["argument"], Super: [], TaggedTemplateExpression: ["tag", "quasi", "typeParameters", "typeArguments"], TemplateElement: [], TemplateLiteral: ["quasis", "expressions"], YieldExpression: ["argument"], AwaitExpression: ["argument"], Import: [], BigIntLiteral: [], ExportNamespaceSpecifier: ["exported"], OptionalMemberExpression: ["object", "property"], OptionalCallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], ClassProperty: ["key", "value", "typeAnnotation", "decorators", "variance"], ClassAccessorProperty: ["key", "value", "typeAnnotation", "decorators"], ClassPrivateProperty: ["key", "value", "decorators", "typeAnnotation", "variance"], ClassPrivateMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], PrivateName: ["id"], StaticBlock: ["body"], AnyTypeAnnotation: [], ArrayTypeAnnotation: ["elementType"], BooleanTypeAnnotation: [], BooleanLiteralTypeAnnotation: [], NullLiteralTypeAnnotation: [], ClassImplements: ["id", "typeParameters"], DeclareClass: ["id", "typeParameters", "extends", "mixins", "implements", "body"], DeclareFunction: ["id", "predicate"], DeclareInterface: ["id", "typeParameters", "extends", "body"], DeclareModule: ["id", "body"], DeclareModuleExports: ["typeAnnotation"], DeclareTypeAlias: ["id", "typeParameters", "right"], DeclareOpaqueType: ["id", "typeParameters", "supertype"], DeclareVariable: ["id"], DeclareExportDeclaration: ["declaration", "specifiers", "source"], DeclareExportAllDeclaration: ["source"], DeclaredPredicate: ["value"], ExistsTypeAnnotation: [], FunctionTypeAnnotation: ["typeParameters", "params", "rest", "returnType", "this"], FunctionTypeParam: ["name", "typeAnnotation"], GenericTypeAnnotation: ["id", "typeParameters"], InferredPredicate: [], InterfaceExtends: ["id", "typeParameters"], InterfaceDeclaration: ["id", "typeParameters", "extends", "body"], InterfaceTypeAnnotation: ["extends", "body"], IntersectionTypeAnnotation: ["types"], MixedTypeAnnotation: [], EmptyTypeAnnotation: [], NullableTypeAnnotation: ["typeAnnotation"], NumberLiteralTypeAnnotation: [], NumberTypeAnnotation: [], ObjectTypeAnnotation: ["properties", "indexers", "callProperties", "internalSlots"], ObjectTypeInternalSlot: ["id", "value"], ObjectTypeCallProperty: ["value"], ObjectTypeIndexer: ["id", "key", "value", "variance"], ObjectTypeProperty: ["key", "value", "variance"], ObjectTypeSpreadProperty: ["argument"], OpaqueType: ["id", "typeParameters", "supertype", "impltype"], QualifiedTypeIdentifier: ["id", "qualification"], StringLiteralTypeAnnotation: [], StringTypeAnnotation: [], SymbolTypeAnnotation: [], ThisTypeAnnotation: [], TupleTypeAnnotation: ["types", "elementTypes"], TypeofTypeAnnotation: ["argument", "typeArguments"], TypeAlias: ["id", "typeParameters", "right"], TypeAnnotation: ["typeAnnotation"], TypeCastExpression: ["expression", "typeAnnotation"], TypeParameter: ["bound", "default", "variance"], TypeParameterDeclaration: ["params"], TypeParameterInstantiation: ["params"], UnionTypeAnnotation: ["types"], Variance: [], VoidTypeAnnotation: [], EnumDeclaration: ["id", "body"], EnumBooleanBody: ["members"], EnumNumberBody: ["members"], EnumStringBody: ["members"], EnumSymbolBody: ["members"], EnumBooleanMember: ["id", "init"], EnumNumberMember: ["id", "init"], EnumStringMember: ["id", "init"], EnumDefaultedMember: ["id"], IndexedAccessType: ["objectType", "indexType"], OptionalIndexedAccessType: ["objectType", "indexType"], JSXAttribute: ["name", "value"], JSXClosingElement: ["name"], JSXElement: ["openingElement", "children", "closingElement"], JSXEmptyExpression: [], JSXExpressionContainer: ["expression"], JSXSpreadChild: ["expression"], JSXIdentifier: [], JSXMemberExpression: ["object", "property"], JSXNamespacedName: ["namespace", "name"], JSXOpeningElement: ["name", "attributes", "typeArguments", "typeParameters"], JSXSpreadAttribute: ["argument"], JSXText: [], JSXFragment: ["openingFragment", "children", "closingFragment"], JSXOpeningFragment: [], JSXClosingFragment: [], Noop: [], Placeholder: [], V8IntrinsicIdentifier: [], ArgumentPlaceholder: [], BindExpression: ["object", "callee"], ImportAttribute: ["key", "value"], Decorator: ["expression"], DoExpression: ["body"], ExportDefaultSpecifier: ["exported"], RecordExpression: ["properties"], TupleExpression: ["elements"], DecimalLiteral: [], ModuleExpression: ["body"], TopicReference: [], PipelineTopicExpression: ["expression"], PipelineBareFunction: ["callee"], PipelinePrimaryTopicReference: [], TSParameterProperty: ["parameter", "decorators"], TSDeclareFunction: ["id", "typeParameters", "params", "returnType", "body"], TSDeclareMethod: ["decorators", "key", "typeParameters", "params", "returnType"], TSQualifiedName: ["left", "right"], TSCallSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSPropertySignature: ["key", "typeAnnotation"], TSMethodSignature: ["key", "typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSIndexSignature: ["parameters", "typeAnnotation"], TSAnyKeyword: [], TSBooleanKeyword: [], TSBigIntKeyword: [], TSIntrinsicKeyword: [], TSNeverKeyword: [], TSNullKeyword: [], TSNumberKeyword: [], TSObjectKeyword: [], TSStringKeyword: [], TSSymbolKeyword: [], TSUndefinedKeyword: [], TSUnknownKeyword: [], TSVoidKeyword: [], TSThisType: [], TSFunctionType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructorType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSTypeReference: ["typeName", "typeParameters", "typeArguments"], TSTypePredicate: ["parameterName", "typeAnnotation"], TSTypeQuery: ["exprName", "typeParameters", "typeArguments"], TSTypeLiteral: ["members"], TSArrayType: ["elementType"], TSTupleType: ["elementTypes"], TSOptionalType: ["typeAnnotation"], TSRestType: ["typeAnnotation"], TSNamedTupleMember: ["label", "elementType"], TSUnionType: ["types"], TSIntersectionType: ["types"], TSConditionalType: ["checkType", "extendsType", "trueType", "falseType"], TSInferType: ["typeParameter"], TSParenthesizedType: ["typeAnnotation"], TSTypeOperator: ["typeAnnotation"], TSIndexedAccessType: ["objectType", "indexType"], TSMappedType: ["typeParameter", "typeAnnotation", "nameType"], TSLiteralType: ["literal"], TSExpressionWithTypeArguments: ["expression", "typeParameters"], TSInterfaceDeclaration: ["id", "typeParameters", "extends", "body"], TSInterfaceBody: ["body"], TSTypeAliasDeclaration: ["id", "typeParameters", "typeAnnotation"], TSInstantiationExpression: ["expression", "typeParameters", "typeArguments"], TSAsExpression: ["expression", "typeAnnotation"], TSSatisfiesExpression: ["expression", "typeAnnotation"], TSTypeAssertion: ["typeAnnotation", "expression"], TSEnumDeclaration: ["id", "members"], TSEnumMember: ["id", "initializer"], TSModuleDeclaration: ["id", "body"], TSModuleBlock: ["body"], TSImportType: ["argument", "qualifier", "typeParameters", "typeArguments"], TSImportEqualsDeclaration: ["id", "moduleReference"], TSExternalModuleReference: ["expression"], TSNonNullExpression: ["expression"], TSExportAssignment: ["expression"], TSNamespaceExportDeclaration: ["id"], TSTypeAnnotation: ["typeAnnotation"], TSTypeParameterInstantiation: ["params"], TSTypeParameterDeclaration: ["params"], TSTypeParameter: ["constraint", "default", "name"], ChainExpression: ["expression"], ExperimentalRestProperty: ["argument"], ExperimentalSpreadProperty: ["argument"], Literal: [], MethodDefinition: ["decorators", "key", "value"], PrivateIdentifier: [], Property: ["key", "value"], PropertyDefinition: ["decorators", "key", "typeAnnotation", "value", "variance"], AccessorProperty: ["decorators", "key", "typeAnnotation", "value"], TSAbstractAccessorProperty: ["decorators", "key", "typeAnnotation"], TSAbstractKeyword: [], TSAbstractMethodDefinition: ["key", "value"], TSAbstractPropertyDefinition: ["decorators", "key", "typeAnnotation"], TSAsyncKeyword: [], TSClassImplements: ["expression", "typeArguments", "typeParameters"], TSDeclareKeyword: [], TSEmptyBodyFunctionExpression: ["id", "typeParameters", "params", "returnType"], TSEnumBody: ["members"], TSExportKeyword: [], TSInterfaceHeritage: ["expression", "typeArguments", "typeParameters"], TSPrivateKeyword: [], TSProtectedKeyword: [], TSPublicKeyword: [], TSReadonlyKeyword: [], TSStaticKeyword: [], TSTemplateLiteralType: ["quasis", "types"], AsConstExpression: ["expression"], AsExpression: ["expression", "typeAnnotation"], BigIntLiteralTypeAnnotation: [], BigIntTypeAnnotation: [], ComponentDeclaration: ["id", "params", "body", "typeParameters", "rendersType"], ComponentParameter: ["name", "local"], ComponentTypeAnnotation: ["params", "rest", "typeParameters", "rendersType"], ComponentTypeParameter: ["name", "typeAnnotation"], ConditionalTypeAnnotation: ["checkType", "extendsType", "trueType", "falseType"], DeclareComponent: ["id", "params", "rest", "typeParameters", "rendersType"], DeclareEnum: ["id", "body"], DeclareHook: ["id"], DeclareNamespace: ["id", "body"], EnumBigIntBody: ["members"], EnumBigIntMember: ["id", "init"], HookDeclaration: ["id", "params", "body", "typeParameters", "returnType"], HookTypeAnnotation: ["params", "returnType", "rest", "typeParameters"], InferTypeAnnotation: ["typeParameter"], KeyofTypeAnnotation: ["argument"], ObjectTypeMappedTypeProperty: ["keyTparam", "propType", "sourceType", "variance"], QualifiedTypeofIdentifier: ["qualification", "id"], TupleTypeLabeledElement: ["label", "elementType", "variance"], TupleTypeSpreadElement: ["label", "typeAnnotation"], TypeOperator: ["typeAnnotation"], TypePredicate: ["parameterName", "typeAnnotation", "asserts"], NGRoot: ["node"], NGPipeExpression: ["left", "right", "arguments"], NGChainedExpression: ["expressions"], NGEmptyExpression: [], NGMicrosyntax: ["body"], NGMicrosyntaxKey: [], NGMicrosyntaxExpression: ["expression", "alias"], NGMicrosyntaxKeyedExpression: ["key", "expression"], NGMicrosyntaxLet: ["key", "value"], NGMicrosyntaxAs: ["key", "alias"], JsExpressionRoot: ["node"], JsonRoot: ["node"], TSJSDocAllType: [], TSJSDocUnknownType: [], TSJSDocNullableType: ["typeAnnotation"], TSJSDocNonNullableType: ["typeAnnotation"], NeverTypeAnnotation: [], UndefinedTypeAnnotation: [], UnknownTypeAnnotation: [], SatisfiesExpression: ["expression", "typeAnnotation"] };
      var lo2 = hr2(tu2), gr3 = lo2;
      function mo2(e2) {
        let t2 = new Set(e2);
        return (r2) => t2.has(r2 == null ? void 0 : r2.type);
      }
      var v2 = mo2;
      var yo2 = v2(["Block", "CommentBlock", "MultiLine"]), re3 = yo2;
      var Do2 = v2(["AnyTypeAnnotation", "ThisTypeAnnotation", "NumberTypeAnnotation", "VoidTypeAnnotation", "BooleanTypeAnnotation", "BigIntTypeAnnotation", "SymbolTypeAnnotation", "StringTypeAnnotation", "NeverTypeAnnotation", "UndefinedTypeAnnotation", "UnknownTypeAnnotation", "EmptyTypeAnnotation", "MixedTypeAnnotation"]), Sr2 = Do2;
      function fo2(e2, t2) {
        let r2 = t2.split(".");
        for (let n2 = r2.length - 1; n2 >= 0; n2--) {
          let s2 = r2[n2];
          if (n2 === 0)
            return e2.type === "Identifier" && e2.name === s2;
          if (e2.type !== "MemberExpression" || e2.optional || e2.computed || e2.property.type !== "Identifier" || e2.property.name !== s2)
            return false;
          e2 = e2.object;
        }
      }
      function Eo2(e2, t2) {
        return t2.some((r2) => fo2(e2, r2));
      }
      var ru2 = Eo2;
      function Fo2({ type: e2 }) {
        return e2.startsWith("TS") && e2.endsWith("Keyword");
      }
      var Br2 = Fo2;
      function tr2(e2, t2) {
        return t2(e2) || Xs2(e2, { getVisitorKeys: gr3, predicate: t2 });
      }
      function jt2(e2) {
        return e2.type === "AssignmentExpression" || e2.type === "BinaryExpression" || e2.type === "LogicalExpression" || e2.type === "NGPipeExpression" || e2.type === "ConditionalExpression" || L3(e2) || q2(e2) || e2.type === "SequenceExpression" || e2.type === "TaggedTemplateExpression" || e2.type === "BindExpression" || e2.type === "UpdateExpression" && !e2.prefix || Te2(e2) || e2.type === "TSNonNullExpression" || e2.type === "ChainExpression";
      }
      function uu2(e2) {
        return e2.expressions ? e2.expressions[0] : e2.left ?? e2.test ?? e2.callee ?? e2.object ?? e2.tag ?? e2.argument ?? e2.expression;
      }
      function Pr2(e2) {
        if (e2.expressions)
          return ["expressions", 0];
        if (e2.left)
          return ["left"];
        if (e2.test)
          return ["test"];
        if (e2.object)
          return ["object"];
        if (e2.callee)
          return ["callee"];
        if (e2.tag)
          return ["tag"];
        if (e2.argument)
          return ["argument"];
        if (e2.expression)
          return ["expression"];
        throw new Error("Unexpected node has no left side.");
      }
      var vt2 = v2(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose", "Hashbang", "InterpreterDirective"]), iu2 = v2(["ExportDefaultDeclaration", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration", "DeclareExportAllDeclaration"]), U2 = v2(["ArrayExpression", "TupleExpression"]), se2 = v2(["ObjectExpression", "RecordExpression"]);
      function au2(e2) {
        return e2.type === "LogicalExpression" && e2.operator === "??";
      }
      function Ce3(e2) {
        return e2.type === "NumericLiteral" || e2.type === "Literal" && typeof e2.value == "number";
      }
      function vn3(e2) {
        return e2.type === "UnaryExpression" && (e2.operator === "+" || e2.operator === "-") && Ce3(e2.argument);
      }
      function Q3(e2) {
        return !!(e2 && (e2.type === "StringLiteral" || e2.type === "Literal" && typeof e2.value == "string"));
      }
      function Mn2(e2) {
        return e2.type === "RegExpLiteral" || e2.type === "Literal" && !!e2.regex;
      }
      var kr3 = v2(["Literal", "BooleanLiteral", "BigIntLiteral", "DecimalLiteral", "DirectiveLiteral", "NullLiteral", "NumericLiteral", "RegExpLiteral", "StringLiteral"]), Co = v2(["Identifier", "ThisExpression", "Super", "PrivateName", "PrivateIdentifier", "Import"]), we3 = v2(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]), _t2 = v2(["FunctionExpression", "ArrowFunctionExpression"]);
      function Ao2(e2) {
        return e2.type === "FunctionExpression" || e2.type === "ArrowFunctionExpression" && e2.body.type === "BlockStatement";
      }
      function wn3(e2) {
        return L3(e2) && e2.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(e2.callee.name);
      }
      var X3 = v2(["JSXElement", "JSXFragment"]);
      function gt2(e2) {
        return e2.method && e2.kind === "init" || e2.kind === "get" || e2.kind === "set";
      }
      function Ir2(e2) {
        return (e2.type === "ObjectTypeProperty" || e2.type === "ObjectTypeInternalSlot") && !e2.static && !e2.method && e2.kind !== "get" && e2.kind !== "set" && e2.value.type === "FunctionTypeAnnotation";
      }
      function ou3(e2) {
        return (e2.type === "TypeAnnotation" || e2.type === "TSTypeAnnotation") && e2.typeAnnotation.type === "FunctionTypeAnnotation" && !e2.static && !ht3(e2, e2.typeAnnotation);
      }
      var De3 = v2(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
      function Ft3(e2) {
        return q2(e2) || e2.type === "BindExpression" && !!e2.object;
      }
      var To = v2(["TSThisType", "NullLiteralTypeAnnotation", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType"]);
      function Mt2(e2) {
        return Br2(e2) || Sr2(e2) || To(e2) || (e2.type === "GenericTypeAnnotation" || e2.type === "TSTypeReference") && !e2.typeParameters && !e2.typeArguments;
      }
      function xo2(e2) {
        return e2.type === "Identifier" && (e2.name === "beforeEach" || e2.name === "beforeAll" || e2.name === "afterEach" || e2.name === "afterAll");
      }
      var ho2 = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];
      function go2(e2) {
        return ru2(e2, ho2);
      }
      function St3(e2, t2) {
        if ((e2 == null ? void 0 : e2.type) !== "CallExpression" || e2.optional)
          return false;
        let r2 = oe3(e2);
        if (r2.length === 1) {
          if (wn3(e2) && St3(t2))
            return _t2(r2[0]);
          if (xo2(e2.callee))
            return wn3(r2[0]);
        } else if ((r2.length === 2 || r2.length === 3) && (r2[0].type === "TemplateLiteral" || Q3(r2[0])) && go2(e2.callee))
          return r2[2] && !Ce3(r2[2]) ? false : (r2.length === 2 ? _t2(r2[1]) : Ao2(r2[1]) && K2(r2[1]).length <= 1) || wn3(r2[1]);
        return false;
      }
      var pu3 = (e2) => (t2) => ((t2 == null ? void 0 : t2.type) === "ChainExpression" && (t2 = t2.expression), e2(t2)), L3 = pu3(v2(["CallExpression", "OptionalCallExpression"])), q2 = pu3(v2(["MemberExpression", "OptionalMemberExpression"]));
      function Rn2(e2, t2 = 5) {
        return cu2(e2, t2) <= t2;
      }
      function cu2(e2, t2) {
        let r2 = 0;
        for (let n2 in e2) {
          let s2 = e2[n2];
          if (s2 && typeof s2 == "object" && typeof s2.type == "string" && (r2++, r2 += cu2(s2, t2 - r2)), r2 > t2)
            return r2;
        }
        return r2;
      }
      var So = 0.25;
      function rr2(e2, t2) {
        let { printWidth: r2 } = t2;
        if (d2(e2))
          return false;
        let n2 = r2 * So;
        if (e2.type === "ThisExpression" || e2.type === "Identifier" && e2.name.length <= n2 || vn3(e2) && !d2(e2.argument))
          return true;
        let s2 = e2.type === "Literal" && "regex" in e2 && e2.regex.pattern || e2.type === "RegExpLiteral" && e2.pattern;
        return s2 ? s2.length <= n2 : Q3(e2) ? tt2(fe2(e2), t2).length <= n2 : e2.type === "TemplateLiteral" ? e2.expressions.length === 0 && e2.quasis[0].value.raw.length <= n2 && !e2.quasis[0].value.raw.includes(`
`) : e2.type === "UnaryExpression" ? rr2(e2.argument, { printWidth: r2 }) : e2.type === "CallExpression" && e2.arguments.length === 0 && e2.callee.type === "Identifier" ? e2.callee.name.length <= n2 - 2 : kr3(e2);
      }
      function Oe3(e2, t2) {
        return X3(t2) ? Bt2(t2) : d2(t2, g2.Leading, (r2) => te2(e2, k(r2)));
      }
      function nu2(e2) {
        return e2.quasis.some((t2) => t2.value.raw.includes(`
`));
      }
      function Lr3(e2, t2) {
        return (e2.type === "TemplateLiteral" && nu2(e2) || e2.type === "TaggedTemplateExpression" && nu2(e2.quasi)) && !te2(t2, R3(e2), { backwards: true });
      }
      function wr2(e2) {
        if (!d2(e2))
          return false;
        let t2 = O2(false, ct3(e2, g2.Dangling), -1);
        return t2 && !re3(t2);
      }
      function lu3(e2) {
        if (e2.length <= 1)
          return false;
        let t2 = 0;
        for (let r2 of e2)
          if (_t2(r2)) {
            if (t2 += 1, t2 > 1)
              return true;
          } else if (L3(r2)) {
            for (let n2 of oe3(r2))
              if (_t2(n2))
                return true;
          }
        return false;
      }
      function Or2(e2) {
        let { node: t2, parent: r2, key: n2 } = e2;
        return n2 === "callee" && L3(t2) && L3(r2) && r2.arguments.length > 0 && t2.arguments.length > r2.arguments.length;
      }
      var Bo3 = /* @__PURE__ */ new Set(["!", "-", "+", "~"]);
      function be3(e2, t2 = 2) {
        if (t2 <= 0)
          return false;
        if (e2.type === "ChainExpression" || e2.type === "TSNonNullExpression")
          return be3(e2.expression, t2);
        let r2 = (n2) => be3(n2, t2 - 1);
        if (Mn2(e2))
          return et2(e2.pattern ?? e2.regex.pattern) <= 5;
        if (kr3(e2) || Co(e2) || e2.type === "ArgumentPlaceholder")
          return true;
        if (e2.type === "TemplateLiteral")
          return e2.quasis.every((n2) => !n2.value.raw.includes(`
`)) && e2.expressions.every(r2);
        if (se2(e2))
          return e2.properties.every((n2) => !n2.computed && (n2.shorthand || n2.value && r2(n2.value)));
        if (U2(e2))
          return e2.elements.every((n2) => n2 === null || r2(n2));
        if (lt3(e2)) {
          if (e2.type === "ImportExpression" || be3(e2.callee, t2)) {
            let n2 = oe3(e2);
            return n2.length <= t2 && n2.every(r2);
          }
          return false;
        }
        return q2(e2) ? be3(e2.object, t2) && be3(e2.property, t2) : e2.type === "UnaryExpression" && Bo3.has(e2.operator) || e2.type === "UpdateExpression" ? be3(e2.argument, t2) : false;
      }
      function fe2(e2) {
        var t2;
        return ((t2 = e2.extra) == null ? void 0 : t2.raw) ?? e2.raw;
      }
      function mu2(e2) {
        return e2;
      }
      function ae2(e2, t2 = "es5") {
        return e2.trailingComma === "es5" && t2 === "es5" || e2.trailingComma === "all" && (t2 === "all" || t2 === "es5");
      }
      function ie2(e2, t2) {
        switch (e2.type) {
          case "BinaryExpression":
          case "LogicalExpression":
          case "AssignmentExpression":
          case "NGPipeExpression":
            return ie2(e2.left, t2);
          case "MemberExpression":
          case "OptionalMemberExpression":
            return ie2(e2.object, t2);
          case "TaggedTemplateExpression":
            return e2.tag.type === "FunctionExpression" ? false : ie2(e2.tag, t2);
          case "CallExpression":
          case "OptionalCallExpression":
            return e2.callee.type === "FunctionExpression" ? false : ie2(e2.callee, t2);
          case "ConditionalExpression":
            return ie2(e2.test, t2);
          case "UpdateExpression":
            return !e2.prefix && ie2(e2.argument, t2);
          case "BindExpression":
            return e2.object && ie2(e2.object, t2);
          case "SequenceExpression":
            return ie2(e2.expressions[0], t2);
          case "ChainExpression":
          case "TSSatisfiesExpression":
          case "TSAsExpression":
          case "TSNonNullExpression":
          case "AsExpression":
          case "AsConstExpression":
          case "SatisfiesExpression":
            return ie2(e2.expression, t2);
          default:
            return t2(e2);
        }
      }
      var su3 = { "==": true, "!=": true, "===": true, "!==": true }, br3 = { "*": true, "/": true, "%": true }, jn = { ">>": true, ">>>": true, "<<": true };
      function nr2(e2, t2) {
        return !(er2(t2) !== er2(e2) || e2 === "**" || su3[e2] && su3[t2] || t2 === "%" && br3[e2] || e2 === "%" && br3[t2] || t2 !== e2 && br3[t2] && br3[e2] || jn[e2] && jn[t2]);
      }
      var bo = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap((e2, t2) => e2.map((r2) => [r2, t2])));
      function er2(e2) {
        return bo.get(e2);
      }
      function yu2(e2) {
        return !!jn[e2] || e2 === "|" || e2 === "^" || e2 === "&";
      }
      function Du2(e2) {
        var r2;
        if (e2.rest)
          return true;
        let t2 = K2(e2);
        return ((r2 = O2(false, t2, -1)) == null ? void 0 : r2.type) === "RestElement";
      }
      var On2 = /* @__PURE__ */ new WeakMap();
      function K2(e2) {
        if (On2.has(e2))
          return On2.get(e2);
        let t2 = [];
        return e2.this && t2.push(e2.this), Array.isArray(e2.parameters) ? t2.push(...e2.parameters) : Array.isArray(e2.params) && t2.push(...e2.params), e2.rest && t2.push(e2.rest), On2.set(e2, t2), t2;
      }
      function fu2(e2, t2) {
        let { node: r2 } = e2, n2 = 0, s2 = (u2) => t2(u2, n2++);
        r2.this && e2.call(s2, "this"), Array.isArray(r2.parameters) ? e2.each(s2, "parameters") : Array.isArray(r2.params) && e2.each(s2, "params"), r2.rest && e2.call(s2, "rest");
      }
      var _n2 = /* @__PURE__ */ new WeakMap();
      function oe3(e2) {
        if (_n2.has(e2))
          return _n2.get(e2);
        if (e2.type === "ChainExpression")
          return oe3(e2.expression);
        let t2 = e2.arguments;
        return e2.type === "ImportExpression" && (t2 = [e2.source], e2.attributes && t2.push(e2.attributes), e2.options && t2.push(e2.options)), _n2.set(e2, t2), t2;
      }
      function Rt2(e2, t2) {
        let { node: r2 } = e2;
        if (r2.type === "ChainExpression")
          return e2.call(() => Rt2(e2, t2), "expression");
        r2.type === "ImportExpression" ? (e2.call((n2) => t2(n2, 0), "source"), r2.attributes && e2.call((n2) => t2(n2, 1), "attributes"), r2.options && e2.call((n2) => t2(n2, 1), "options")) : e2.each(t2, "arguments");
      }
      function Jn2(e2, t2) {
        let r2 = [];
        if (e2.type === "ChainExpression" && (e2 = e2.expression, r2.push("expression")), e2.type === "ImportExpression") {
          if (t2 === 0 || t2 === (e2.attributes || e2.options ? -2 : -1))
            return [...r2, "source"];
          if (e2.attributes && (t2 === 1 || t2 === -1))
            return [...r2, "attributes"];
          if (e2.options && (t2 === 1 || t2 === -1))
            return [...r2, "options"];
          throw new RangeError("Invalid argument index");
        }
        if (t2 < 0 && (t2 = e2.arguments.length + t2), t2 < 0 || t2 >= e2.arguments.length)
          throw new RangeError("Invalid argument index");
        return [...r2, "arguments", t2];
      }
      function sr3(e2) {
        return e2.value.trim() === "prettier-ignore" && !e2.unignore;
      }
      function Bt2(e2) {
        return (e2 == null ? void 0 : e2.prettierIgnore) || d2(e2, g2.PrettierIgnore);
      }
      var g2 = { Leading: 2, Trailing: 4, Dangling: 8, Block: 16, Line: 32, PrettierIgnore: 64, First: 128, Last: 256 }, Eu2 = (e2, t2) => {
        if (typeof e2 == "function" && (t2 = e2, e2 = 0), e2 || t2)
          return (r2, n2, s2) => !(e2 & g2.Leading && !r2.leading || e2 & g2.Trailing && !r2.trailing || e2 & g2.Dangling && (r2.leading || r2.trailing) || e2 & g2.Block && !re3(r2) || e2 & g2.Line && !vt2(r2) || e2 & g2.First && n2 !== 0 || e2 & g2.Last && n2 !== s2.length - 1 || e2 & g2.PrettierIgnore && !sr3(r2) || t2 && !t2(r2));
      };
      function d2(e2, t2, r2) {
        if (!w2(e2 == null ? void 0 : e2.comments))
          return false;
        let n2 = Eu2(t2, r2);
        return n2 ? e2.comments.some(n2) : true;
      }
      function ct3(e2, t2, r2) {
        if (!Array.isArray(e2 == null ? void 0 : e2.comments))
          return [];
        let n2 = Eu2(t2, r2);
        return n2 ? e2.comments.filter(n2) : e2.comments;
      }
      var pe2 = (e2, { originalText: t2 }) => Ot2(t2, k(e2));
      function lt3(e2) {
        return L3(e2) || e2.type === "NewExpression" || e2.type === "ImportExpression";
      }
      function Ae3(e2) {
        return e2 && (e2.type === "ObjectProperty" || e2.type === "Property" && !gt2(e2));
      }
      var Te2 = v2(["TSAsExpression", "TSSatisfiesExpression", "AsExpression", "AsConstExpression", "SatisfiesExpression"]), Ne2 = v2(["UnionTypeAnnotation", "TSUnionType"]), _r3 = v2(["IntersectionTypeAnnotation", "TSIntersectionType"]);
      var Po2 = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), Jt2 = (e2) => {
        for (let t2 of e2.quasis)
          delete t2.value;
      };
      function Fu2(e2, t2, r2) {
        var s2, u2;
        if (e2.type === "Program" && delete t2.sourceType, (e2.type === "BigIntLiteral" || e2.type === "BigIntLiteralTypeAnnotation") && e2.value && (t2.value = e2.value.toLowerCase()), (e2.type === "BigIntLiteral" || e2.type === "Literal") && e2.bigint && (t2.bigint = e2.bigint.toLowerCase()), e2.type === "DecimalLiteral" && (t2.value = Number(e2.value)), e2.type === "Literal" && t2.decimal && (t2.decimal = Number(e2.decimal)), e2.type === "EmptyStatement" || e2.type === "JSXText" || e2.type === "JSXExpressionContainer" && (e2.expression.type === "Literal" || e2.expression.type === "StringLiteral") && e2.expression.value === " ")
          return null;
        if ((e2.type === "Property" || e2.type === "ObjectProperty" || e2.type === "MethodDefinition" || e2.type === "ClassProperty" || e2.type === "ClassMethod" || e2.type === "PropertyDefinition" || e2.type === "TSDeclareMethod" || e2.type === "TSPropertySignature" || e2.type === "ObjectTypeProperty" || e2.type === "ImportAttribute") && e2.key && !e2.computed) {
          let { key: i2 } = e2;
          Q3(i2) || Ce3(i2) ? t2.key = String(i2.value) : i2.type === "Identifier" && (t2.key = i2.name);
        }
        if (e2.type === "JSXElement" && e2.openingElement.name.name === "style" && e2.openingElement.attributes.some((i2) => i2.type === "JSXAttribute" && i2.name.name === "jsx"))
          for (let { type: i2, expression: a2 } of t2.children)
            i2 === "JSXExpressionContainer" && a2.type === "TemplateLiteral" && Jt2(a2);
        e2.type === "JSXAttribute" && e2.name.name === "css" && e2.value.type === "JSXExpressionContainer" && e2.value.expression.type === "TemplateLiteral" && Jt2(t2.value.expression), e2.type === "JSXAttribute" && ((s2 = e2.value) == null ? void 0 : s2.type) === "Literal" && /["']|&quot;|&apos;/u.test(e2.value.value) && (t2.value.value = N2(false, e2.value.value, /["']|&quot;|&apos;/gu, '"'));
        let n2 = e2.expression || e2.callee;
        if (e2.type === "Decorator" && n2.type === "CallExpression" && n2.callee.name === "Component" && n2.arguments.length === 1) {
          let i2 = e2.expression.arguments[0].properties;
          for (let [a2, o2] of t2.expression.arguments[0].properties.entries())
            switch (i2[a2].key.name) {
              case "styles":
                U2(o2.value) && Jt2(o2.value.elements[0]);
                break;
              case "template":
                o2.value.type === "TemplateLiteral" && Jt2(o2.value);
                break;
            }
        }
        e2.type === "TaggedTemplateExpression" && (e2.tag.type === "MemberExpression" || e2.tag.type === "Identifier" && (e2.tag.name === "gql" || e2.tag.name === "graphql" || e2.tag.name === "css" || e2.tag.name === "md" || e2.tag.name === "markdown" || e2.tag.name === "html") || e2.tag.type === "CallExpression") && Jt2(t2.quasi), e2.type === "TemplateLiteral" && ((u2 = e2.leadingComments) != null && u2.some((a2) => re3(a2) && ["GraphQL", "HTML"].some((o2) => a2.value === ` ${o2} `)) || r2.type === "CallExpression" && r2.callee.name === "graphql" || !e2.leadingComments) && Jt2(t2), e2.type === "ChainExpression" && e2.expression.type === "TSNonNullExpression" && (t2.type = "TSNonNullExpression", t2.expression.type = "ChainExpression"), e2.type === "TSMappedType" && (delete t2.key, delete t2.constraint), e2.type === "TSEnumDeclaration" && delete t2.body;
      }
      Fu2.ignoredProperties = Po2;
      var Cu3 = Fu2;
      var rt3 = "string", _e3 = "array", nt3 = "cursor", Xe2 = "indent", Ye2 = "align", st3 = "trim", le2 = "group", Pe3 = "fill", xe3 = "if-break", He2 = "indent-if-break", Ve2 = "line-suffix", $e3 = "line-suffix-boundary", me2 = "line", je2 = "label", ve3 = "break-parent", jr3 = /* @__PURE__ */ new Set([nt3, Xe2, Ye2, st3, le2, Pe3, xe3, He2, Ve2, $e3, me2, je2, ve3]);
      function ko2(e2) {
        if (typeof e2 == "string")
          return rt3;
        if (Array.isArray(e2))
          return _e3;
        if (!e2)
          return;
        let { type: t2 } = e2;
        if (jr3.has(t2))
          return t2;
      }
      var ut3 = ko2;
      var Io2 = (e2) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(e2);
      function Lo2(e2) {
        let t2 = e2 === null ? "null" : typeof e2;
        if (t2 !== "string" && t2 !== "object")
          return `Unexpected doc '${t2}', 
Expected it to be 'string' or 'object'.`;
        if (ut3(e2))
          throw new Error("doc is valid.");
        let r2 = Object.prototype.toString.call(e2);
        if (r2 !== "[object Object]")
          return `Unexpected doc '${r2}'.`;
        let n2 = Io2([...jr3].map((s2) => `'${s2}'`));
        return `Unexpected doc.type '${e2.type}'.
Expected it to be ${n2}.`;
      }
      var qn2 = class extends Error {
        constructor(t2) {
          super(Lo2(t2));
          __publicField(this, "name", "InvalidDocError");
          this.doc = t2;
        }
      }, Ct = qn2;
      var Au2 = {};
      function wo2(e2, t2, r2, n2) {
        let s2 = [e2];
        for (; s2.length > 0; ) {
          let u2 = s2.pop();
          if (u2 === Au2) {
            r2(s2.pop());
            continue;
          }
          r2 && s2.push(u2, Au2);
          let i2 = ut3(u2);
          if (!i2)
            throw new Ct(u2);
          if ((t2 == null ? void 0 : t2(u2)) !== false)
            switch (i2) {
              case _e3:
              case Pe3: {
                let a2 = i2 === _e3 ? u2 : u2.parts;
                for (let o2 = a2.length, c2 = o2 - 1; c2 >= 0; --c2)
                  s2.push(a2[c2]);
                break;
              }
              case xe3:
                s2.push(u2.flatContents, u2.breakContents);
                break;
              case le2:
                if (n2 && u2.expandedStates)
                  for (let a2 = u2.expandedStates.length, o2 = a2 - 1; o2 >= 0; --o2)
                    s2.push(u2.expandedStates[o2]);
                else
                  s2.push(u2.contents);
                break;
              case Ye2:
              case Xe2:
              case He2:
              case je2:
              case Ve2:
                s2.push(u2.contents);
                break;
              case rt3:
              case nt3:
              case st3:
              case $e3:
              case me2:
              case ve3:
                break;
              default:
                throw new Ct(u2);
            }
        }
      }
      var Wn2 = wo2;
      var Tu2 = () => {
      }, Ke3 = Tu2, vr3 = Tu2;
      function f2(e2) {
        return Ke3(e2), { type: Xe2, contents: e2 };
      }
      function he3(e2, t2) {
        return Ke3(t2), { type: Ye2, contents: t2, n: e2 };
      }
      function l2(e2, t2 = {}) {
        return Ke3(e2), vr3(t2.expandedStates, true), { type: le2, id: t2.id, contents: e2, break: !!t2.shouldBreak, expandedStates: t2.expandedStates };
      }
      function du3(e2) {
        return he3(Number.NEGATIVE_INFINITY, e2);
      }
      function Mr2(e2) {
        return he3(-1, e2);
      }
      function ze2(e2, t2) {
        return l2(e2[0], { ...t2, expandedStates: e2 });
      }
      function qt2(e2) {
        return vr3(e2), { type: Pe3, parts: e2 };
      }
      function b3(e2, t2 = "", r2 = {}) {
        return Ke3(e2), t2 !== "" && Ke3(t2), { type: xe3, breakContents: e2, flatContents: t2, groupId: r2.groupId };
      }
      function At3(e2, t2) {
        return Ke3(e2), { type: He2, contents: e2, groupId: t2.groupId, negate: t2.negate };
      }
      function Gn3(e2) {
        return Ke3(e2), { type: Ve2, contents: e2 };
      }
      var ke3 = { type: $e3 }, Ee2 = { type: ve3 };
      var Un3 = { type: me2, hard: true }, Oo = { type: me2, hard: true, literal: true }, x2 = { type: me2 }, E2 = { type: me2, soft: true }, F = [Un3, Ee2], Rr2 = [Oo, Ee2], Nn2 = { type: nt3 };
      function P2(e2, t2) {
        Ke3(e2), vr3(t2);
        let r2 = [];
        for (let n2 = 0; n2 < t2.length; n2++)
          n2 !== 0 && r2.push(e2), r2.push(t2[n2]);
        return r2;
      }
      function xu2(e2, t2, r2) {
        Ke3(e2);
        let n2 = e2;
        if (t2 > 0) {
          for (let s2 = 0; s2 < Math.floor(t2 / r2); ++s2)
            n2 = f2(n2);
          n2 = he3(t2 % r2, n2), n2 = he3(Number.NEGATIVE_INFINITY, n2);
        }
        return n2;
      }
      function it3(e2, t2) {
        return Ke3(t2), e2 ? { type: je2, label: e2, contents: t2 } : t2;
      }
      function mt3(e2, t2) {
        if (typeof e2 == "string")
          return t2(e2);
        let r2 = /* @__PURE__ */ new Map();
        return n2(e2);
        function n2(u2) {
          if (r2.has(u2))
            return r2.get(u2);
          let i2 = s2(u2);
          return r2.set(u2, i2), i2;
        }
        function s2(u2) {
          switch (ut3(u2)) {
            case _e3:
              return t2(u2.map(n2));
            case Pe3:
              return t2({ ...u2, parts: u2.parts.map(n2) });
            case xe3:
              return t2({ ...u2, breakContents: n2(u2.breakContents), flatContents: n2(u2.flatContents) });
            case le2: {
              let { expandedStates: i2, contents: a2 } = u2;
              return i2 ? (i2 = i2.map(n2), a2 = i2[0]) : a2 = n2(a2), t2({ ...u2, contents: a2, expandedStates: i2 });
            }
            case Ye2:
            case Xe2:
            case He2:
            case je2:
            case Ve2:
              return t2({ ...u2, contents: n2(u2.contents) });
            case rt3:
            case nt3:
            case st3:
            case $e3:
            case me2:
            case ve3:
              return t2(u2);
            default:
              throw new Ct(u2);
          }
        }
      }
      function gu2(e2, t2, r2) {
        let n2 = r2, s2 = false;
        function u2(i2) {
          if (s2)
            return false;
          let a2 = t2(i2);
          a2 !== void 0 && (s2 = true, n2 = a2);
        }
        return Wn2(e2, u2), n2;
      }
      function _o2(e2) {
        if (e2.type === le2 && e2.break || e2.type === me2 && e2.hard || e2.type === ve3)
          return true;
      }
      function ne3(e2) {
        return gu2(e2, _o2, false);
      }
      function hu2(e2) {
        if (e2.length > 0) {
          let t2 = O2(false, e2, -1);
          !t2.expandedStates && !t2.break && (t2.break = "propagated");
        }
        return null;
      }
      function Su3(e2) {
        let t2 = /* @__PURE__ */ new Set(), r2 = [];
        function n2(u2) {
          if (u2.type === ve3 && hu2(r2), u2.type === le2) {
            if (r2.push(u2), t2.has(u2))
              return false;
            t2.add(u2);
          }
        }
        function s2(u2) {
          u2.type === le2 && r2.pop().break && hu2(r2);
        }
        Wn2(e2, n2, s2, true);
      }
      function jo2(e2) {
        return e2.type === me2 && !e2.hard ? e2.soft ? "" : " " : e2.type === xe3 ? e2.flatContents : e2;
      }
      function ur3(e2) {
        return mt3(e2, jo2);
      }
      function vo(e2) {
        switch (ut3(e2)) {
          case Pe3:
            if (e2.parts.every((t2) => t2 === ""))
              return "";
            break;
          case le2:
            if (!e2.contents && !e2.id && !e2.break && !e2.expandedStates)
              return "";
            if (e2.contents.type === le2 && e2.contents.id === e2.id && e2.contents.break === e2.break && e2.contents.expandedStates === e2.expandedStates)
              return e2.contents;
            break;
          case Ye2:
          case Xe2:
          case He2:
          case Ve2:
            if (!e2.contents)
              return "";
            break;
          case xe3:
            if (!e2.flatContents && !e2.breakContents)
              return "";
            break;
          case _e3: {
            let t2 = [];
            for (let r2 of e2) {
              if (!r2)
                continue;
              let [n2, ...s2] = Array.isArray(r2) ? r2 : [r2];
              typeof n2 == "string" && typeof O2(false, t2, -1) == "string" ? t2[t2.length - 1] += n2 : t2.push(n2), t2.push(...s2);
            }
            return t2.length === 0 ? "" : t2.length === 1 ? t2[0] : t2;
          }
          case rt3:
          case nt3:
          case st3:
          case $e3:
          case me2:
          case je2:
          case ve3:
            break;
          default:
            throw new Ct(e2);
        }
        return e2;
      }
      function Wt2(e2) {
        return mt3(e2, (t2) => vo(t2));
      }
      function Ie3(e2, t2 = Rr2) {
        return mt3(e2, (r2) => typeof r2 == "string" ? P2(t2, r2.split(`
`)) : r2);
      }
      function Mo2(e2) {
        if (e2.type === me2)
          return true;
      }
      function Bu3(e2) {
        return gu2(e2, Mo2, false);
      }
      function ir3(e2, t2) {
        return e2.type === je2 ? { ...e2, contents: t2(e2.contents) } : t2(e2);
      }
      function Ro3(e2) {
        let t2 = `*${e2.value}*`.split(`
`);
        return t2.length > 1 && t2.every((r2) => r2.trimStart()[0] === "*");
      }
      var bu2 = Ro3;
      function Pu2(e2, t2) {
        let r2 = e2.node;
        if (vt2(r2))
          return t2.originalText.slice(R3(r2), k(r2)).trimEnd();
        if (re3(r2))
          return bu2(r2) ? Jo2(r2) : ["/*", Ie3(r2.value), "*/"];
        throw new Error("Not a comment: " + JSON.stringify(r2));
      }
      function Jo2(e2) {
        let t2 = e2.value.split(`
`);
        return ["/*", P2(F, t2.map((r2, n2) => n2 === 0 ? r2.trimEnd() : " " + (n2 < t2.length - 1 ? r2.trim() : r2.trimStart()))), "*/"];
      }
      var zn3 = {};
      Ar3(zn3, { endOfLine: () => Yo2, ownLine: () => Xo2, remaining: () => Ho2 });
      function qo2(e2) {
        let t2 = e2.type || e2.kind || "(unknown type)", r2 = String(e2.name || e2.id && (typeof e2.id == "object" ? e2.id.name : e2.id) || e2.key && (typeof e2.key == "object" ? e2.key.name : e2.key) || e2.value && (typeof e2.value == "object" ? "" : String(e2.value)) || e2.operator || "");
        return r2.length > 20 && (r2 = r2.slice(0, 19) + "â€¦"), t2 + (r2 ? " " + r2 : "");
      }
      function Xn2(e2, t2) {
        (e2.comments ?? (e2.comments = [])).push(t2), t2.printed = false, t2.nodeDescription = qo2(e2);
      }
      function ce3(e2, t2) {
        t2.leading = true, t2.trailing = false, Xn2(e2, t2);
      }
      function Le3(e2, t2, r2) {
        t2.leading = false, t2.trailing = false, r2 && (t2.marker = r2), Xn2(e2, t2);
      }
      function z3(e2, t2) {
        t2.leading = false, t2.trailing = true, Xn2(e2, t2);
      }
      function Wo2(e2, t2) {
        let r2 = null, n2 = t2;
        for (; n2 !== r2; )
          r2 = n2, n2 = Ge3(e2, n2), n2 = Lt2(e2, n2), n2 = wt3(e2, n2), n2 = Ue2(e2, n2);
        return n2;
      }
      var yt2 = Wo2;
      function Go2(e2, t2) {
        let r2 = yt2(e2, t2);
        return r2 === false ? "" : e2.charAt(r2);
      }
      var ge2 = Go2;
      function Uo2(e2, t2, r2) {
        for (let n2 = t2; n2 < r2; ++n2)
          if (e2.charAt(n2) === `
`)
            return true;
        return false;
      }
      var de2 = Uo2;
      function No(e2) {
        return re3(e2) && e2.value[0] === "*" && /@(?:type|satisfies)\b/u.test(e2.value);
      }
      var ku2 = No;
      function Xo2(e2) {
        return [Mu3, Lu3, _u2, sp, $o2, Hn, Vn3, Iu2, wu2, op, ip, Kn3, vu2, pp, Ou2, ju3, $n3, Ko3, Fp].some((t2) => t2(e2));
      }
      function Yo2(e2) {
        return [Vo2, _u2, Lu3, vu2, Hn, Vn3, Iu2, wu2, ju3, up, ap, Kn3, mp, $n3, fp, Ep2].some((t2) => t2(e2));
      }
      function Ho2(e2) {
        return [Mu3, Hn, Vn3, zo, np, Ou2, Kn3, rp, tp, Dp2, $n3, yp].some((t2) => t2(e2));
      }
      function bt2(e2, t2) {
        let r2 = (e2.body || e2.properties).find(({ type: n2 }) => n2 !== "EmptyStatement");
        r2 ? ce3(r2, t2) : Le3(e2, t2);
      }
      function Yn2(e2, t2) {
        e2.type === "BlockStatement" ? bt2(e2, t2) : ce3(e2, t2);
      }
      function Vo2({ comment: e2, followingNode: t2 }) {
        return t2 && ku2(e2) ? (ce3(t2, e2), true) : false;
      }
      function Hn({ comment: e2, precedingNode: t2, enclosingNode: r2, followingNode: n2, text: s2 }) {
        if ((r2 == null ? void 0 : r2.type) !== "IfStatement" || !n2)
          return false;
        if (ge2(s2, k(e2)) === ")")
          return z3(t2, e2), true;
        if (t2 === r2.consequent && n2 === r2.alternate) {
          if (t2.type === "BlockStatement")
            z3(t2, e2);
          else {
            let i2 = vt2(e2) || e2.loc.start.line === e2.loc.end.line, a2 = e2.loc.start.line === t2.loc.start.line;
            i2 && a2 ? z3(t2, e2) : Le3(r2, e2);
          }
          return true;
        }
        return n2.type === "BlockStatement" ? (bt2(n2, e2), true) : n2.type === "IfStatement" ? (Yn2(n2.consequent, e2), true) : r2.consequent === n2 ? (ce3(n2, e2), true) : false;
      }
      function Vn3({ comment: e2, precedingNode: t2, enclosingNode: r2, followingNode: n2, text: s2 }) {
        return (r2 == null ? void 0 : r2.type) !== "WhileStatement" || !n2 ? false : ge2(s2, k(e2)) === ")" ? (z3(t2, e2), true) : n2.type === "BlockStatement" ? (bt2(n2, e2), true) : r2.body === n2 ? (ce3(n2, e2), true) : false;
      }
      function Iu2({ comment: e2, precedingNode: t2, enclosingNode: r2, followingNode: n2 }) {
        return (r2 == null ? void 0 : r2.type) !== "TryStatement" && (r2 == null ? void 0 : r2.type) !== "CatchClause" || !n2 ? false : r2.type === "CatchClause" && t2 ? (z3(t2, e2), true) : n2.type === "BlockStatement" ? (bt2(n2, e2), true) : n2.type === "TryStatement" ? (Yn2(n2.finalizer, e2), true) : n2.type === "CatchClause" ? (Yn2(n2.body, e2), true) : false;
      }
      function $o2({ comment: e2, enclosingNode: t2, followingNode: r2 }) {
        return q2(t2) && (r2 == null ? void 0 : r2.type) === "Identifier" ? (ce3(t2, e2), true) : false;
      }
      function Ko3({ comment: e2, enclosingNode: t2, followingNode: r2, options: n2 }) {
        return !n2.experimentalTernaries || !((t2 == null ? void 0 : t2.type) === "ConditionalExpression" || (t2 == null ? void 0 : t2.type) === "ConditionalTypeAnnotation" || (t2 == null ? void 0 : t2.type) === "TSConditionalType") ? false : (r2 == null ? void 0 : r2.type) === "ConditionalExpression" || (r2 == null ? void 0 : r2.type) === "ConditionalTypeAnnotation" || (r2 == null ? void 0 : r2.type) === "TSConditionalType" ? (Le3(t2, e2), true) : false;
      }
      function Lu3({ comment: e2, precedingNode: t2, enclosingNode: r2, followingNode: n2, text: s2, options: u2 }) {
        let i2 = t2 && !de2(s2, k(t2), R3(e2));
        return (!t2 || !i2) && ((r2 == null ? void 0 : r2.type) === "ConditionalExpression" || (r2 == null ? void 0 : r2.type) === "ConditionalTypeAnnotation" || (r2 == null ? void 0 : r2.type) === "TSConditionalType") && n2 ? u2.experimentalTernaries && r2.alternate === n2 && !(re3(e2) && !de2(u2.originalText, R3(e2), k(e2))) ? (Le3(r2, e2), true) : (ce3(n2, e2), true) : false;
      }
      function zo({ comment: e2, precedingNode: t2, enclosingNode: r2 }) {
        return Ae3(r2) && r2.shorthand && r2.key === t2 && r2.value.type === "AssignmentPattern" ? (z3(r2.value.left, e2), true) : false;
      }
      var Qo2 = /* @__PURE__ */ new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
      function wu2({ comment: e2, precedingNode: t2, enclosingNode: r2, followingNode: n2 }) {
        if (Qo2.has(r2 == null ? void 0 : r2.type)) {
          if (w2(r2.decorators) && (n2 == null ? void 0 : n2.type) !== "Decorator")
            return z3(O2(false, r2.decorators, -1), e2), true;
          if (r2.body && n2 === r2.body)
            return bt2(r2.body, e2), true;
          if (n2) {
            if (r2.superClass && n2 === r2.superClass && t2 && (t2 === r2.id || t2 === r2.typeParameters))
              return z3(t2, e2), true;
            for (let s2 of ["implements", "extends", "mixins"])
              if (r2[s2] && n2 === r2[s2][0])
                return t2 && (t2 === r2.id || t2 === r2.typeParameters || t2 === r2.superClass) ? z3(t2, e2) : Le3(r2, e2, s2), true;
          }
        }
        return false;
      }
      var Zo2 = /* @__PURE__ */ new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty"]);
      function Ou2({ comment: e2, precedingNode: t2, enclosingNode: r2, text: n2 }) {
        return r2 && t2 && ge2(n2, k(e2)) === "(" && (r2.type === "Property" || r2.type === "TSDeclareMethod" || r2.type === "TSAbstractMethodDefinition") && t2.type === "Identifier" && r2.key === t2 && ge2(n2, k(t2)) !== ":" ? (z3(t2, e2), true) : (t2 == null ? void 0 : t2.type) === "Decorator" && Zo2.has(r2 == null ? void 0 : r2.type) ? (z3(t2, e2), true) : false;
      }
      var ep = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);
      function tp({ comment: e2, precedingNode: t2, enclosingNode: r2, text: n2 }) {
        return ge2(n2, k(e2)) !== "(" ? false : t2 && ep.has(r2 == null ? void 0 : r2.type) ? (z3(t2, e2), true) : false;
      }
      function rp({ comment: e2, enclosingNode: t2, text: r2 }) {
        if ((t2 == null ? void 0 : t2.type) !== "ArrowFunctionExpression")
          return false;
        let n2 = yt2(r2, k(e2));
        return n2 !== false && r2.slice(n2, n2 + 2) === "=>" ? (Le3(t2, e2), true) : false;
      }
      function np({ comment: e2, enclosingNode: t2, text: r2 }) {
        return ge2(r2, k(e2)) !== ")" ? false : t2 && (Ru2(t2) && K2(t2).length === 0 || lt3(t2) && oe3(t2).length === 0) ? (Le3(t2, e2), true) : ((t2 == null ? void 0 : t2.type) === "MethodDefinition" || (t2 == null ? void 0 : t2.type) === "TSAbstractMethodDefinition") && K2(t2.value).length === 0 ? (Le3(t2.value, e2), true) : false;
      }
      function sp({ comment: e2, precedingNode: t2, enclosingNode: r2, followingNode: n2, text: s2 }) {
        return (t2 == null ? void 0 : t2.type) === "ComponentTypeParameter" && ((r2 == null ? void 0 : r2.type) === "DeclareComponent" || (r2 == null ? void 0 : r2.type) === "ComponentTypeAnnotation") && (n2 == null ? void 0 : n2.type) !== "ComponentTypeParameter" ? (z3(t2, e2), true) : ((t2 == null ? void 0 : t2.type) === "ComponentParameter" || (t2 == null ? void 0 : t2.type) === "RestElement") && (r2 == null ? void 0 : r2.type) === "ComponentDeclaration" && ge2(s2, k(e2)) === ")" ? (z3(t2, e2), true) : false;
      }
      function _u2({ comment: e2, precedingNode: t2, enclosingNode: r2, followingNode: n2, text: s2 }) {
        return (t2 == null ? void 0 : t2.type) === "FunctionTypeParam" && (r2 == null ? void 0 : r2.type) === "FunctionTypeAnnotation" && (n2 == null ? void 0 : n2.type) !== "FunctionTypeParam" ? (z3(t2, e2), true) : ((t2 == null ? void 0 : t2.type) === "Identifier" || (t2 == null ? void 0 : t2.type) === "AssignmentPattern" || (t2 == null ? void 0 : t2.type) === "ObjectPattern" || (t2 == null ? void 0 : t2.type) === "ArrayPattern" || (t2 == null ? void 0 : t2.type) === "RestElement" || (t2 == null ? void 0 : t2.type) === "TSParameterProperty") && Ru2(r2) && ge2(s2, k(e2)) === ")" ? (z3(t2, e2), true) : !re3(e2) && ((r2 == null ? void 0 : r2.type) === "FunctionDeclaration" || (r2 == null ? void 0 : r2.type) === "FunctionExpression" || (r2 == null ? void 0 : r2.type) === "ObjectMethod") && (n2 == null ? void 0 : n2.type) === "BlockStatement" && r2.body === n2 && yt2(s2, k(e2)) === R3(n2) ? (bt2(n2, e2), true) : false;
      }
      function ju3({ comment: e2, enclosingNode: t2 }) {
        return (t2 == null ? void 0 : t2.type) === "LabeledStatement" ? (ce3(t2, e2), true) : false;
      }
      function $n3({ comment: e2, enclosingNode: t2 }) {
        return ((t2 == null ? void 0 : t2.type) === "ContinueStatement" || (t2 == null ? void 0 : t2.type) === "BreakStatement") && !t2.label ? (z3(t2, e2), true) : false;
      }
      function up({ comment: e2, precedingNode: t2, enclosingNode: r2 }) {
        return L3(r2) && t2 && r2.callee === t2 && r2.arguments.length > 0 ? (ce3(r2.arguments[0], e2), true) : false;
      }
      function ip({ comment: e2, precedingNode: t2, enclosingNode: r2, followingNode: n2 }) {
        return Ne2(r2) ? (sr3(e2) && (n2.prettierIgnore = true, e2.unignore = true), t2 ? (z3(t2, e2), true) : false) : (Ne2(n2) && sr3(e2) && (n2.types[0].prettierIgnore = true, e2.unignore = true), false);
      }
      function ap({ comment: e2, enclosingNode: t2 }) {
        return Ae3(t2) ? (ce3(t2, e2), true) : false;
      }
      function Kn3({ comment: e2, enclosingNode: t2, ast: r2, isLastComment: n2 }) {
        var s2;
        return ((s2 = r2 == null ? void 0 : r2.body) == null ? void 0 : s2.length) === 0 ? (n2 ? Le3(r2, e2) : ce3(r2, e2), true) : (t2 == null ? void 0 : t2.type) === "Program" && t2.body.length === 0 && !w2(t2.directives) ? (n2 ? Le3(t2, e2) : ce3(t2, e2), true) : false;
      }
      function op({ comment: e2, enclosingNode: t2 }) {
        return (t2 == null ? void 0 : t2.type) === "ForInStatement" || (t2 == null ? void 0 : t2.type) === "ForOfStatement" ? (ce3(t2, e2), true) : false;
      }
      function vu2({ comment: e2, precedingNode: t2, enclosingNode: r2, text: n2 }) {
        if ((r2 == null ? void 0 : r2.type) === "ImportSpecifier" || (r2 == null ? void 0 : r2.type) === "ExportSpecifier")
          return ce3(r2, e2), true;
        let s2 = (t2 == null ? void 0 : t2.type) === "ImportSpecifier" && (r2 == null ? void 0 : r2.type) === "ImportDeclaration", u2 = (t2 == null ? void 0 : t2.type) === "ExportSpecifier" && (r2 == null ? void 0 : r2.type) === "ExportNamedDeclaration";
        return (s2 || u2) && te2(n2, k(e2)) ? (z3(t2, e2), true) : false;
      }
      function pp({ comment: e2, enclosingNode: t2 }) {
        return (t2 == null ? void 0 : t2.type) === "AssignmentPattern" ? (ce3(t2, e2), true) : false;
      }
      var cp = /* @__PURE__ */ new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]), lp = /* @__PURE__ */ new Set(["ObjectExpression", "RecordExpression", "ArrayExpression", "TupleExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);
      function mp({ comment: e2, enclosingNode: t2, followingNode: r2 }) {
        return cp.has(t2 == null ? void 0 : t2.type) && r2 && (lp.has(r2.type) || re3(e2)) ? (ce3(r2, e2), true) : false;
      }
      function yp({ comment: e2, enclosingNode: t2, followingNode: r2, text: n2 }) {
        return !r2 && ((t2 == null ? void 0 : t2.type) === "TSMethodSignature" || (t2 == null ? void 0 : t2.type) === "TSDeclareFunction" || (t2 == null ? void 0 : t2.type) === "TSAbstractMethodDefinition") && ge2(n2, k(e2)) === ";" ? (z3(t2, e2), true) : false;
      }
      function Mu3({ comment: e2, enclosingNode: t2, followingNode: r2 }) {
        if (sr3(e2) && (t2 == null ? void 0 : t2.type) === "TSMappedType" && (r2 == null ? void 0 : r2.type) === "TSTypeParameter" && r2.constraint)
          return t2.prettierIgnore = true, e2.unignore = true, true;
      }
      function Dp2({ comment: e2, precedingNode: t2, enclosingNode: r2, followingNode: n2 }) {
        return (r2 == null ? void 0 : r2.type) !== "TSMappedType" ? false : (n2 == null ? void 0 : n2.type) === "TSTypeParameter" && n2.name ? (ce3(n2.name, e2), true) : (t2 == null ? void 0 : t2.type) === "TSTypeParameter" && t2.constraint ? (z3(t2.constraint, e2), true) : false;
      }
      function fp({ comment: e2, enclosingNode: t2, followingNode: r2 }) {
        return !t2 || t2.type !== "SwitchCase" || t2.test || !r2 || r2 !== t2.consequent[0] ? false : (r2.type === "BlockStatement" && vt2(e2) ? bt2(r2, e2) : Le3(t2, e2), true);
      }
      function Ep2({ comment: e2, precedingNode: t2, enclosingNode: r2, followingNode: n2 }) {
        return Ne2(t2) && ((r2.type === "TSArrayType" || r2.type === "ArrayTypeAnnotation") && !n2 || _r3(r2)) ? (z3(O2(false, t2.types, -1), e2), true) : false;
      }
      function Fp({ comment: e2, enclosingNode: t2, precedingNode: r2, followingNode: n2 }) {
        if (((t2 == null ? void 0 : t2.type) === "ObjectPattern" || (t2 == null ? void 0 : t2.type) === "ArrayPattern") && (n2 == null ? void 0 : n2.type) === "TSTypeAnnotation")
          return r2 ? z3(r2, e2) : Le3(t2, e2), true;
      }
      var Ru2 = v2(["ArrowFunctionExpression", "FunctionExpression", "FunctionDeclaration", "ObjectMethod", "ClassMethod", "TSDeclareFunction", "TSCallSignatureDeclaration", "TSConstructSignatureDeclaration", "TSMethodSignature", "TSConstructorType", "TSFunctionType", "TSDeclareMethod"]);
      var Cp2 = /* @__PURE__ */ new Set(["EmptyStatement", "TemplateElement", "Import", "TSEmptyBodyFunctionExpression", "ChainExpression"]);
      function Ap2(e2) {
        return !Cp2.has(e2.type);
      }
      function Tp2(e2, t2) {
        var r2;
        if ((t2.parser === "typescript" || t2.parser === "flow" || t2.parser === "acorn" || t2.parser === "espree" || t2.parser === "meriyah" || t2.parser === "__babel_estree") && e2.type === "MethodDefinition" && ((r2 = e2.value) == null ? void 0 : r2.type) === "FunctionExpression" && K2(e2.value).length === 0 && !e2.value.returnType && !w2(e2.value.typeParameters) && e2.value.body)
          return [...e2.decorators || [], e2.key, e2.value.body];
      }
      function Qn3(e2) {
        let { node: t2, parent: r2 } = e2;
        return (X3(t2) || r2 && (r2.type === "JSXSpreadAttribute" || r2.type === "JSXSpreadChild" || Ne2(r2) || (r2.type === "ClassDeclaration" || r2.type === "ClassExpression") && r2.superClass === t2)) && (!Bt2(t2) || Ne2(r2));
      }
      function dp(e2, { parser: t2 }) {
        if (t2 === "flow" || t2 === "babel-flow")
          return e2 = N2(false, e2, /[\s(]/gu, ""), e2 === "" || e2 === "/*" || e2 === "/*::";
      }
      function Ju3(e2) {
        switch (e2) {
          case "cr":
            return "\r";
          case "crlf":
            return `\r
`;
          default:
            return `
`;
        }
      }
      var Se3 = Symbol("MODE_BREAK"), at3 = Symbol("MODE_FLAT"), ar3 = Symbol("cursor");
      function qu3() {
        return { value: "", length: 0, queue: [] };
      }
      function xp2(e2, t2) {
        return Zn3(e2, { type: "indent" }, t2);
      }
      function hp2(e2, t2, r2) {
        return t2 === Number.NEGATIVE_INFINITY ? e2.root || qu3() : t2 < 0 ? Zn3(e2, { type: "dedent" }, r2) : t2 ? t2.type === "root" ? { ...e2, root: e2 } : Zn3(e2, { type: typeof t2 == "string" ? "stringAlign" : "numberAlign", n: t2 }, r2) : e2;
      }
      function Zn3(e2, t2, r2) {
        let n2 = t2.type === "dedent" ? e2.queue.slice(0, -1) : [...e2.queue, t2], s2 = "", u2 = 0, i2 = 0, a2 = 0;
        for (let p2 of n2)
          switch (p2.type) {
            case "indent":
              m(), r2.useTabs ? o2(1) : c2(r2.tabWidth);
              break;
            case "stringAlign":
              m(), s2 += p2.n, u2 += p2.n.length;
              break;
            case "numberAlign":
              i2 += 1, a2 += p2.n;
              break;
            default:
              throw new Error(`Unexpected type '${p2.type}'`);
          }
        return y3(), { ...e2, value: s2, length: u2, queue: n2 };
        function o2(p2) {
          s2 += "	".repeat(p2), u2 += r2.tabWidth * p2;
        }
        function c2(p2) {
          s2 += " ".repeat(p2), u2 += p2;
        }
        function m() {
          r2.useTabs ? D() : y3();
        }
        function D() {
          i2 > 0 && o2(i2), C();
        }
        function y3() {
          a2 > 0 && c2(a2), C();
        }
        function C() {
          i2 = 0, a2 = 0;
        }
      }
      function es(e2) {
        let t2 = 0, r2 = 0, n2 = e2.length;
        e:
          for (; n2--; ) {
            let s2 = e2[n2];
            if (s2 === ar3) {
              r2++;
              continue;
            }
            for (let u2 = s2.length - 1; u2 >= 0; u2--) {
              let i2 = s2[u2];
              if (i2 === " " || i2 === "	")
                t2++;
              else {
                e2[n2] = s2.slice(0, u2 + 1);
                break e;
              }
            }
          }
        if (t2 > 0 || r2 > 0)
          for (e2.length = n2 + 1; r2-- > 0; )
            e2.push(ar3);
        return t2;
      }
      function Jr2(e2, t2, r2, n2, s2, u2) {
        if (r2 === Number.POSITIVE_INFINITY)
          return true;
        let i2 = t2.length, a2 = [e2], o2 = [];
        for (; r2 >= 0; ) {
          if (a2.length === 0) {
            if (i2 === 0)
              return true;
            a2.push(t2[--i2]);
            continue;
          }
          let { mode: c2, doc: m } = a2.pop(), D = ut3(m);
          switch (D) {
            case rt3:
              o2.push(m), r2 -= et2(m);
              break;
            case _e3:
            case Pe3: {
              let y3 = D === _e3 ? m : m.parts;
              for (let C = y3.length - 1; C >= 0; C--)
                a2.push({ mode: c2, doc: y3[C] });
              break;
            }
            case Xe2:
            case Ye2:
            case He2:
            case je2:
              a2.push({ mode: c2, doc: m.contents });
              break;
            case st3:
              r2 += es(o2);
              break;
            case le2: {
              if (u2 && m.break)
                return false;
              let y3 = m.break ? Se3 : c2, C = m.expandedStates && y3 === Se3 ? O2(false, m.expandedStates, -1) : m.contents;
              a2.push({ mode: y3, doc: C });
              break;
            }
            case xe3: {
              let C = (m.groupId ? s2[m.groupId] || at3 : c2) === Se3 ? m.breakContents : m.flatContents;
              C && a2.push({ mode: c2, doc: C });
              break;
            }
            case me2:
              if (c2 === Se3 || m.hard)
                return true;
              m.soft || (o2.push(" "), r2--);
              break;
            case Ve2:
              n2 = true;
              break;
            case $e3:
              if (n2)
                return false;
              break;
          }
        }
        return false;
      }
      function ts(e2, t2) {
        let r2 = {}, n2 = t2.printWidth, s2 = Ju3(t2.endOfLine), u2 = 0, i2 = [{ ind: qu3(), mode: Se3, doc: e2 }], a2 = [], o2 = false, c2 = [], m = 0;
        for (Su3(e2); i2.length > 0; ) {
          let { ind: y3, mode: C, doc: p2 } = i2.pop();
          switch (ut3(p2)) {
            case rt3: {
              let A = s2 !== `
` ? N2(false, p2, `
`, s2) : p2;
              a2.push(A), i2.length > 0 && (u2 += et2(A));
              break;
            }
            case _e3:
              for (let A = p2.length - 1; A >= 0; A--)
                i2.push({ ind: y3, mode: C, doc: p2[A] });
              break;
            case nt3:
              if (m >= 2)
                throw new Error("There are too many 'cursor' in doc.");
              a2.push(ar3), m++;
              break;
            case Xe2:
              i2.push({ ind: xp2(y3, t2), mode: C, doc: p2.contents });
              break;
            case Ye2:
              i2.push({ ind: hp2(y3, p2.n, t2), mode: C, doc: p2.contents });
              break;
            case st3:
              u2 -= es(a2);
              break;
            case le2:
              switch (C) {
                case at3:
                  if (!o2) {
                    i2.push({ ind: y3, mode: p2.break ? Se3 : at3, doc: p2.contents });
                    break;
                  }
                case Se3: {
                  o2 = false;
                  let A = { ind: y3, mode: at3, doc: p2.contents }, T3 = n2 - u2, S3 = c2.length > 0;
                  if (!p2.break && Jr2(A, i2, T3, S3, r2))
                    i2.push(A);
                  else if (p2.expandedStates) {
                    let B2 = O2(false, p2.expandedStates, -1);
                    if (p2.break) {
                      i2.push({ ind: y3, mode: Se3, doc: B2 });
                      break;
                    } else
                      for (let _3 = 1; _3 < p2.expandedStates.length + 1; _3++)
                        if (_3 >= p2.expandedStates.length) {
                          i2.push({ ind: y3, mode: Se3, doc: B2 });
                          break;
                        } else {
                          let J3 = p2.expandedStates[_3], j2 = { ind: y3, mode: at3, doc: J3 };
                          if (Jr2(j2, i2, T3, S3, r2)) {
                            i2.push(j2);
                            break;
                          }
                        }
                  } else
                    i2.push({ ind: y3, mode: Se3, doc: p2.contents });
                  break;
                }
              }
              p2.id && (r2[p2.id] = O2(false, i2, -1).mode);
              break;
            case Pe3: {
              let A = n2 - u2, { parts: T3 } = p2;
              if (T3.length === 0)
                break;
              let [S3, B2] = T3, _3 = { ind: y3, mode: at3, doc: S3 }, J3 = { ind: y3, mode: Se3, doc: S3 }, j2 = Jr2(_3, [], A, c2.length > 0, r2, true);
              if (T3.length === 1) {
                j2 ? i2.push(_3) : i2.push(J3);
                break;
              }
              let h2 = { ind: y3, mode: at3, doc: B2 }, W2 = { ind: y3, mode: Se3, doc: B2 };
              if (T3.length === 2) {
                j2 ? i2.push(h2, _3) : i2.push(W2, J3);
                break;
              }
              T3.splice(0, 2);
              let Fe3 = { ind: y3, mode: C, doc: qt2(T3) }, H3 = T3[0];
              Jr2({ ind: y3, mode: at3, doc: [S3, B2, H3] }, [], A, c2.length > 0, r2, true) ? i2.push(Fe3, h2, _3) : j2 ? i2.push(Fe3, W2, _3) : i2.push(Fe3, W2, J3);
              break;
            }
            case xe3:
            case He2: {
              let A = p2.groupId ? r2[p2.groupId] : C;
              if (A === Se3) {
                let T3 = p2.type === xe3 ? p2.breakContents : p2.negate ? p2.contents : f2(p2.contents);
                T3 && i2.push({ ind: y3, mode: C, doc: T3 });
              }
              if (A === at3) {
                let T3 = p2.type === xe3 ? p2.flatContents : p2.negate ? f2(p2.contents) : p2.contents;
                T3 && i2.push({ ind: y3, mode: C, doc: T3 });
              }
              break;
            }
            case Ve2:
              c2.push({ ind: y3, mode: C, doc: p2.contents });
              break;
            case $e3:
              c2.length > 0 && i2.push({ ind: y3, mode: C, doc: Un3 });
              break;
            case me2:
              switch (C) {
                case at3:
                  if (p2.hard)
                    o2 = true;
                  else {
                    p2.soft || (a2.push(" "), u2 += 1);
                    break;
                  }
                case Se3:
                  if (c2.length > 0) {
                    i2.push({ ind: y3, mode: C, doc: p2 }, ...c2.reverse()), c2.length = 0;
                    break;
                  }
                  p2.literal ? y3.root ? (a2.push(s2, y3.root.value), u2 = y3.root.length) : (a2.push(s2), u2 = 0) : (u2 -= es(a2), a2.push(s2 + y3.value), u2 = y3.length);
                  break;
              }
              break;
            case je2:
              i2.push({ ind: y3, mode: C, doc: p2.contents });
              break;
            case ve3:
              break;
            default:
              throw new Ct(p2);
          }
          i2.length === 0 && c2.length > 0 && (i2.push(...c2.reverse()), c2.length = 0);
        }
        let D = a2.indexOf(ar3);
        if (D !== -1) {
          let y3 = a2.indexOf(ar3, D + 1), C = a2.slice(0, D).join(""), p2 = a2.slice(D + 1, y3).join(""), A = a2.slice(y3 + 1).join("");
          return { formatted: C + p2 + A, cursorNodeStart: C.length, cursorNodeText: p2 };
        }
        return { formatted: a2.join("") };
      }
      function gp(e2, t2, r2 = 0) {
        let n2 = 0;
        for (let s2 = r2; s2 < e2.length; ++s2)
          e2[s2] === "	" ? n2 = n2 + t2 - n2 % t2 : n2++;
        return n2;
      }
      var Wu3 = gp;
      function Sp2(e2, t2) {
        let r2 = e2.lastIndexOf(`
`);
        return r2 === -1 ? 0 : Wu3(e2.slice(r2 + 1).match(/^[\t ]*/u)[0], t2);
      }
      var Gu3 = Sp2;
      function qr2(e2, t2, r2) {
        let { node: n2 } = e2;
        if (n2.type === "TemplateLiteral" && Pp2(e2)) {
          let c2 = Bp(e2, r2, t2);
          if (c2)
            return c2;
        }
        let u2 = "expressions";
        n2.type === "TSTemplateLiteralType" && (u2 = "types");
        let i2 = [], a2 = e2.map(t2, u2);
        i2.push(ke3, "`");
        let o2 = 0;
        return e2.each(({ index: c2, node: m }) => {
          if (i2.push(t2()), m.tail)
            return;
          let { tabWidth: D } = r2, y3 = m.value.raw, C = y3.includes(`
`) ? Gu3(y3, D) : o2;
          o2 = C;
          let p2 = a2[c2], A = n2[u2][c2], T3 = de2(r2.originalText, k(m), R3(n2.quasis[c2 + 1]));
          if (!T3) {
            let B2 = ts(p2, { ...r2, printWidth: Number.POSITIVE_INFINITY }).formatted;
            B2.includes(`
`) ? T3 = true : p2 = B2;
          }
          T3 && (d2(A) || A.type === "Identifier" || q2(A) || A.type === "ConditionalExpression" || A.type === "SequenceExpression" || Te2(A) || De3(A)) && (p2 = [f2([E2, p2]), E2]);
          let S3 = C === 0 && y3.endsWith(`
`) ? he3(Number.NEGATIVE_INFINITY, p2) : xu2(p2, C, D);
          i2.push(l2(["${", S3, ke3, "}"]));
        }, "quasis"), i2.push("`"), i2;
      }
      function Uu3(e2, t2) {
        let r2 = t2("quasi");
        return it3(r2.label && { tagged: true, ...r2.label }, [t2("tag"), t2(e2.node.typeArguments ? "typeArguments" : "typeParameters"), ke3, r2]);
      }
      function Bp(e2, t2, r2) {
        let { node: n2 } = e2, s2 = n2.quasis[0].value.raw.trim().split(/\s*\|\s*/u);
        if (s2.length > 1 || s2.some((u2) => u2.length > 0)) {
          t2.__inJestEach = true;
          let u2 = e2.map(r2, "expressions");
          t2.__inJestEach = false;
          let i2 = [], a2 = u2.map((y3) => "${" + ts(y3, { ...t2, printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" }).formatted + "}"), o2 = [{ hasLineBreak: false, cells: [] }];
          for (let y3 = 1; y3 < n2.quasis.length; y3++) {
            let C = O2(false, o2, -1), p2 = a2[y3 - 1];
            C.cells.push(p2), p2.includes(`
`) && (C.hasLineBreak = true), n2.quasis[y3].value.raw.includes(`
`) && o2.push({ hasLineBreak: false, cells: [] });
          }
          let c2 = Math.max(s2.length, ...o2.map((y3) => y3.cells.length)), m = Array.from({ length: c2 }).fill(0), D = [{ cells: s2 }, ...o2.filter((y3) => y3.cells.length > 0)];
          for (let { cells: y3 } of D.filter((C) => !C.hasLineBreak))
            for (let [C, p2] of y3.entries())
              m[C] = Math.max(m[C], et2(p2));
          return i2.push(ke3, "`", f2([F, P2(F, D.map((y3) => P2(" | ", y3.cells.map((C, p2) => y3.hasLineBreak ? C : C + " ".repeat(m[p2] - et2(C))))))]), F, "`"), i2;
        }
      }
      function bp2(e2, t2) {
        let { node: r2 } = e2, n2 = t2();
        return d2(r2) && (n2 = l2([f2([E2, n2]), E2])), ["${", n2, ke3, "}"];
      }
      function Gt2(e2, t2) {
        return e2.map((r2) => bp2(r2, t2), "expressions");
      }
      function Wr2(e2, t2) {
        return mt3(e2, (r2) => typeof r2 == "string" ? t2 ? N2(false, r2, /(\\*)`/gu, "$1$1\\`") : rs(r2) : r2);
      }
      function rs(e2) {
        return N2(false, e2, /([\\`]|\$\{)/gu, String.raw`\$1`);
      }
      function Pp2({ node: e2, parent: t2 }) {
        let r2 = /^[fx]?(?:describe|it|test)$/u;
        return t2.type === "TaggedTemplateExpression" && t2.quasi === e2 && t2.tag.type === "MemberExpression" && t2.tag.property.type === "Identifier" && t2.tag.property.name === "each" && (t2.tag.object.type === "Identifier" && r2.test(t2.tag.object.name) || t2.tag.object.type === "MemberExpression" && t2.tag.object.property.type === "Identifier" && (t2.tag.object.property.name === "only" || t2.tag.object.property.name === "skip") && t2.tag.object.object.type === "Identifier" && r2.test(t2.tag.object.object.name));
      }
      var ss = [(e2, t2) => e2.type === "ObjectExpression" && t2 === "properties", (e2, t2) => e2.type === "CallExpression" && e2.callee.type === "Identifier" && e2.callee.name === "Component" && t2 === "arguments", (e2, t2) => e2.type === "Decorator" && t2 === "expression"];
      function Nu2(e2) {
        let t2 = (n2) => n2.type === "TemplateLiteral", r2 = (n2, s2) => Ae3(n2) && !n2.computed && n2.key.type === "Identifier" && n2.key.name === "styles" && s2 === "value";
        return e2.match(t2, (n2, s2) => U2(n2) && s2 === "elements", r2, ...ss) || e2.match(t2, r2, ...ss);
      }
      function Xu3(e2) {
        return e2.match((t2) => t2.type === "TemplateLiteral", (t2, r2) => Ae3(t2) && !t2.computed && t2.key.type === "Identifier" && t2.key.name === "template" && r2 === "value", ...ss);
      }
      function ns(e2, t2) {
        return d2(e2, g2.Block | g2.Leading, ({ value: r2 }) => r2 === ` ${t2} `);
      }
      function Gr3({ node: e2, parent: t2 }, r2) {
        return ns(e2, r2) || kp2(t2) && ns(t2, r2) || t2.type === "ExpressionStatement" && ns(t2, r2);
      }
      function kp2(e2) {
        return e2.type === "AsConstExpression" || e2.type === "TSAsExpression" && e2.typeAnnotation.type === "TSTypeReference" && e2.typeAnnotation.typeName.type === "Identifier" && e2.typeAnnotation.typeName.name === "const";
      }
      async function Ip2(e2, t2, r2) {
        let { node: n2 } = r2, s2 = n2.quasis.map((m) => m.value.raw), u2 = 0, i2 = s2.reduce((m, D, y3) => y3 === 0 ? D : m + "@prettier-placeholder-" + u2++ + "-id" + D, ""), a2 = await e2(i2, { parser: "scss" }), o2 = Gt2(r2, t2), c2 = Lp(a2, o2);
        if (!c2)
          throw new Error("Couldn't insert all the expressions");
        return ["`", f2([F, c2]), E2, "`"];
      }
      function Lp(e2, t2) {
        if (!w2(t2))
          return e2;
        let r2 = 0, n2 = mt3(Wt2(e2), (s2) => typeof s2 != "string" || !s2.includes("@prettier-placeholder") ? s2 : s2.split(/@prettier-placeholder-(\d+)-id/u).map((u2, i2) => i2 % 2 === 0 ? Ie3(u2) : (r2++, t2[u2])));
        return t2.length === r2 ? n2 : null;
      }
      function wp2({ node: e2, parent: t2, grandparent: r2 }) {
        return r2 && e2.quasis && t2.type === "JSXExpressionContainer" && r2.type === "JSXElement" && r2.openingElement.name.name === "style" && r2.openingElement.attributes.some((n2) => n2.type === "JSXAttribute" && n2.name.name === "jsx") || (t2 == null ? void 0 : t2.type) === "TaggedTemplateExpression" && t2.tag.type === "Identifier" && t2.tag.name === "css" || (t2 == null ? void 0 : t2.type) === "TaggedTemplateExpression" && t2.tag.type === "MemberExpression" && t2.tag.object.name === "css" && (t2.tag.property.name === "global" || t2.tag.property.name === "resolve");
      }
      function Ur2(e2) {
        return e2.type === "Identifier" && e2.name === "styled";
      }
      function Yu3(e2) {
        return /^[A-Z]/u.test(e2.object.name) && e2.property.name === "extend";
      }
      function Op2({ parent: e2 }) {
        if (!e2 || e2.type !== "TaggedTemplateExpression")
          return false;
        let t2 = e2.tag.type === "ParenthesizedExpression" ? e2.tag.expression : e2.tag;
        switch (t2.type) {
          case "MemberExpression":
            return Ur2(t2.object) || Yu3(t2);
          case "CallExpression":
            return Ur2(t2.callee) || t2.callee.type === "MemberExpression" && (t2.callee.object.type === "MemberExpression" && (Ur2(t2.callee.object.object) || Yu3(t2.callee.object)) || t2.callee.object.type === "CallExpression" && Ur2(t2.callee.object.callee));
          case "Identifier":
            return t2.name === "css";
          default:
            return false;
        }
      }
      function _p2({ parent: e2, grandparent: t2 }) {
        return (t2 == null ? void 0 : t2.type) === "JSXAttribute" && e2.type === "JSXExpressionContainer" && t2.name.type === "JSXIdentifier" && t2.name.name === "css";
      }
      function jp2(e2) {
        if (wp2(e2) || Op2(e2) || _p2(e2) || Nu2(e2))
          return Ip2;
      }
      var Hu3 = jp2;
      async function vp2(e2, t2, r2) {
        let { node: n2 } = r2, s2 = n2.quasis.length, u2 = Gt2(r2, t2), i2 = [];
        for (let a2 = 0; a2 < s2; a2++) {
          let o2 = n2.quasis[a2], c2 = a2 === 0, m = a2 === s2 - 1, D = o2.value.cooked, y3 = D.split(`
`), C = y3.length, p2 = u2[a2], A = C > 2 && y3[0].trim() === "" && y3[1].trim() === "", T3 = C > 2 && y3[C - 1].trim() === "" && y3[C - 2].trim() === "", S3 = y3.every((_3) => /^\s*(?:#[^\n\r]*)?$/u.test(_3));
          if (!m && /#[^\n\r]*$/u.test(y3[C - 1]))
            return null;
          let B2 = null;
          S3 ? B2 = Mp(y3) : B2 = await e2(D, { parser: "graphql" }), B2 ? (B2 = Wr2(B2, false), !c2 && A && i2.push(""), i2.push(B2), !m && T3 && i2.push("")) : !c2 && !m && A && i2.push(""), p2 && i2.push(p2);
        }
        return ["`", f2([F, P2(F, i2)]), F, "`"];
      }
      function Mp(e2) {
        let t2 = [], r2 = false, n2 = e2.map((s2) => s2.trim());
        for (let [s2, u2] of n2.entries())
          u2 !== "" && (n2[s2 - 1] === "" && r2 ? t2.push([F, u2]) : t2.push(u2), r2 = true);
        return t2.length === 0 ? null : P2(F, t2);
      }
      function Rp({ node: e2, parent: t2 }) {
        return Gr3({ node: e2, parent: t2 }, "GraphQL") || t2 && (t2.type === "TaggedTemplateExpression" && (t2.tag.type === "MemberExpression" && t2.tag.object.name === "graphql" && t2.tag.property.name === "experimental" || t2.tag.type === "Identifier" && (t2.tag.name === "gql" || t2.tag.name === "graphql")) || t2.type === "CallExpression" && t2.callee.type === "Identifier" && t2.callee.name === "graphql");
      }
      function Jp(e2) {
        if (Rp(e2))
          return vp2;
      }
      var Vu3 = Jp;
      var us = 0;
      async function $u3(e2, t2, r2, n2, s2) {
        let { node: u2 } = n2, i2 = us;
        us = us + 1 >>> 0;
        let a2 = (S3) => `PRETTIER_HTML_PLACEHOLDER_${S3}_${i2}_IN_JS`, o2 = u2.quasis.map((S3, B2, _3) => B2 === _3.length - 1 ? S3.value.cooked : S3.value.cooked + a2(B2)).join(""), c2 = Gt2(n2, r2), m = new RegExp(a2(String.raw`(\d+)`), "gu"), D = 0, y3 = await t2(o2, { parser: e2, __onHtmlRoot(S3) {
          D = S3.children.length;
        } }), C = mt3(y3, (S3) => {
          if (typeof S3 != "string")
            return S3;
          let B2 = [], _3 = S3.split(m);
          for (let J3 = 0; J3 < _3.length; J3++) {
            let j2 = _3[J3];
            if (J3 % 2 === 0) {
              j2 && (j2 = rs(j2), s2.__embeddedInHtml && (j2 = N2(false, j2, /<\/(?=script\b)/giu, String.raw`<\/`)), B2.push(j2));
              continue;
            }
            let h2 = Number(j2);
            B2.push(c2[h2]);
          }
          return B2;
        }), p2 = /^\s/u.test(o2) ? " " : "", A = /\s$/u.test(o2) ? " " : "", T3 = s2.htmlWhitespaceSensitivity === "ignore" ? F : p2 && A ? x2 : null;
        return T3 ? l2(["`", f2([T3, l2(C)]), T3, "`"]) : it3({ hug: false }, l2(["`", p2, D > 1 ? f2(l2(C)) : l2(C), A, "`"]));
      }
      function qp(e2) {
        return Gr3(e2, "HTML") || e2.match((t2) => t2.type === "TemplateLiteral", (t2, r2) => t2.type === "TaggedTemplateExpression" && t2.tag.type === "Identifier" && t2.tag.name === "html" && r2 === "quasi");
      }
      var Wp = $u3.bind(void 0, "html"), Gp = $u3.bind(void 0, "angular");
      function Up(e2) {
        if (qp(e2))
          return Wp;
        if (Xu3(e2))
          return Gp;
      }
      var Ku3 = Up;
      async function Np(e2, t2, r2) {
        let { node: n2 } = r2, s2 = N2(false, n2.quasis[0].value.raw, /((?:\\\\)*)\\`/gu, (o2, c2) => "\\".repeat(c2.length / 2) + "`"), u2 = Xp(s2), i2 = u2 !== "";
        i2 && (s2 = N2(false, s2, new RegExp(`^${u2}`, "gmu"), ""));
        let a2 = Wr2(await e2(s2, { parser: "markdown", __inJsTemplate: true }), true);
        return ["`", i2 ? f2([E2, a2]) : [Rr2, du3(a2)], E2, "`"];
      }
      function Xp(e2) {
        let t2 = e2.match(/^([^\S\n]*)\S/mu);
        return t2 === null ? "" : t2[1];
      }
      function Yp(e2) {
        if (Hp(e2))
          return Np;
      }
      function Hp({ node: e2, parent: t2 }) {
        return (t2 == null ? void 0 : t2.type) === "TaggedTemplateExpression" && e2.quasis.length === 1 && t2.tag.type === "Identifier" && (t2.tag.name === "md" || t2.tag.name === "markdown");
      }
      var zu3 = Yp;
      function Vp(e2) {
        let { node: t2 } = e2;
        if (t2.type !== "TemplateLiteral" || $p(t2))
          return;
        let r2;
        for (let n2 of [Hu3, Vu3, Ku3, zu3])
          if (r2 = n2(e2), !!r2)
            return t2.quasis.length === 1 && t2.quasis[0].value.raw.trim() === "" ? "``" : async (...s2) => {
              let u2 = await r2(...s2);
              return u2 && it3({ embed: true, ...u2.label }, u2);
            };
      }
      function $p({ quasis: e2 }) {
        return e2.some(({ value: { cooked: t2 } }) => t2 === null);
      }
      var Qu3 = Vp;
      var Kp = /\*\/$/, zp = /^\/\*\*?/, ri3 = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, Qp = /(^|\s+)\/\/([^\n\r]*)/g, Zu3 = /^(\r?\n)+/, Zp = /(?:^|\r?\n) *(@[^\n\r]*?) *\r?\n *(?![^\n\r@]*\/\/[^]*)([^\s@][^\n\r@]+?) *\r?\n/g, ei3 = /(?:^|\r?\n) *@(\S+) *([^\n\r]*)/g, ec = /(\r?\n|^) *\* ?/g, ni2 = [];
      function si2(e2) {
        let t2 = e2.match(ri3);
        return t2 ? t2[0].trimStart() : "";
      }
      function ui2(e2) {
        let t2 = e2.match(ri3), r2 = t2 == null ? void 0 : t2[0];
        return r2 == null ? e2 : e2.slice(r2.length);
      }
      function ii2(e2) {
        let t2 = `
`;
        e2 = N2(false, e2.replace(zp, "").replace(Kp, ""), ec, "$1");
        let r2 = "";
        for (; r2 !== e2; )
          r2 = e2, e2 = N2(false, e2, Zp, `${t2}$1 $2${t2}`);
        e2 = e2.replace(Zu3, "").trimEnd();
        let n2 = /* @__PURE__ */ Object.create(null), s2 = N2(false, e2, ei3, "").replace(Zu3, "").trimEnd(), u2;
        for (; u2 = ei3.exec(e2); ) {
          let i2 = N2(false, u2[2], Qp, "");
          if (typeof n2[u2[1]] == "string" || Array.isArray(n2[u2[1]])) {
            let a2 = n2[u2[1]];
            n2[u2[1]] = [...ni2, ...Array.isArray(a2) ? a2 : [a2], i2];
          } else
            n2[u2[1]] = i2;
        }
        return { comments: s2, pragmas: n2 };
      }
      function ai2({ comments: e2 = "", pragmas: t2 = {} }) {
        let r2 = `
`, n2 = "/**", s2 = " *", u2 = " */", i2 = Object.keys(t2), a2 = i2.flatMap((c2) => ti2(c2, t2[c2])).map((c2) => `${s2} ${c2}${r2}`).join("");
        if (!e2) {
          if (i2.length === 0)
            return "";
          if (i2.length === 1 && !Array.isArray(t2[i2[0]])) {
            let c2 = t2[i2[0]];
            return `${n2} ${ti2(i2[0], c2)[0]}${u2}`;
          }
        }
        let o2 = e2.split(r2).map((c2) => `${s2} ${c2}`).join(r2) + r2;
        return n2 + r2 + (e2 ? o2 : "") + (e2 && i2.length > 0 ? s2 + r2 : "") + a2 + u2;
      }
      function ti2(e2, t2) {
        return [...ni2, ...Array.isArray(t2) ? t2 : [t2]].map((r2) => `@${e2} ${r2}`.trim());
      }
      function tc2(e2) {
        if (!e2.startsWith("#!"))
          return "";
        let t2 = e2.indexOf(`
`);
        return t2 === -1 ? e2 : e2.slice(0, t2);
      }
      var oi2 = tc2;
      function rc(e2) {
        let t2 = oi2(e2);
        t2 && (e2 = e2.slice(t2.length + 1));
        let r2 = si2(e2), { pragmas: n2, comments: s2 } = ii2(r2);
        return { shebang: t2, text: e2, pragmas: n2, comments: s2 };
      }
      function pi3(e2) {
        let { shebang: t2, text: r2, pragmas: n2, comments: s2 } = rc(e2), u2 = ui2(r2), i2 = ai2({ pragmas: { format: "", ...n2 }, comments: s2.trimStart() });
        return (t2 ? `${t2}
` : "") + i2 + (u2.startsWith(`
`) ? `
` : `

`) + u2;
      }
      function nc(e2, t2) {
        let { originalText: r2, [Symbol.for("comments")]: n2, locStart: s2, locEnd: u2, [Symbol.for("printedComments")]: i2 } = t2, { node: a2 } = e2, o2 = s2(a2), c2 = u2(a2);
        for (let m of n2)
          s2(m) >= o2 && u2(m) <= c2 && i2.add(m);
        return r2.slice(o2, c2);
      }
      var ci3 = nc;
      function is(e2, t2) {
        var u2, i2, a2, o2, c2, m, D, y3, C;
        if (e2.isRoot)
          return false;
        let { node: r2, key: n2, parent: s2 } = e2;
        if (t2.__isInHtmlInterpolation && !t2.bracketSpacing && ac2(r2) && or3(e2))
          return true;
        if (sc2(r2))
          return false;
        if (r2.type === "Identifier") {
          if ((u2 = r2.extra) != null && u2.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/u.test(r2.name) || n2 === "left" && (r2.name === "async" && !s2.await || r2.name === "let") && s2.type === "ForOfStatement")
            return true;
          if (r2.name === "let") {
            let p2 = (i2 = e2.findAncestor((A) => A.type === "ForOfStatement")) == null ? void 0 : i2.left;
            if (p2 && ie2(p2, (A) => A === r2))
              return true;
          }
          if (n2 === "object" && r2.name === "let" && s2.type === "MemberExpression" && s2.computed && !s2.optional) {
            let p2 = e2.findAncestor((T3) => T3.type === "ExpressionStatement" || T3.type === "ForStatement" || T3.type === "ForInStatement"), A = p2 ? p2.type === "ExpressionStatement" ? p2.expression : p2.type === "ForStatement" ? p2.init : p2.left : void 0;
            if (A && ie2(A, (T3) => T3 === r2))
              return true;
          }
          if (n2 === "expression")
            switch (r2.name) {
              case "await":
              case "interface":
              case "module":
              case "using":
              case "yield":
              case "let":
              case "component":
              case "hook":
              case "type": {
                let p2 = e2.findAncestor((A) => !Te2(A));
                if (p2 !== s2 && p2.type === "ExpressionStatement")
                  return true;
              }
            }
          return false;
        }
        if (r2.type === "ObjectExpression" || r2.type === "FunctionExpression" || r2.type === "ClassExpression" || r2.type === "DoExpression") {
          let p2 = (a2 = e2.findAncestor((A) => A.type === "ExpressionStatement")) == null ? void 0 : a2.expression;
          if (p2 && ie2(p2, (A) => A === r2))
            return true;
        }
        if (r2.type === "ObjectExpression") {
          let p2 = (o2 = e2.findAncestor((A) => A.type === "ArrowFunctionExpression")) == null ? void 0 : o2.body;
          if (p2 && p2.type !== "SequenceExpression" && p2.type !== "AssignmentExpression" && ie2(p2, (A) => A === r2))
            return true;
        }
        switch (s2.type) {
          case "ParenthesizedExpression":
            return false;
          case "ClassDeclaration":
          case "ClassExpression":
            if (n2 === "superClass" && (r2.type === "ArrowFunctionExpression" || r2.type === "AssignmentExpression" || r2.type === "AwaitExpression" || r2.type === "BinaryExpression" || r2.type === "ConditionalExpression" || r2.type === "LogicalExpression" || r2.type === "NewExpression" || r2.type === "ObjectExpression" || r2.type === "SequenceExpression" || r2.type === "TaggedTemplateExpression" || r2.type === "UnaryExpression" || r2.type === "UpdateExpression" || r2.type === "YieldExpression" || r2.type === "TSNonNullExpression" || r2.type === "ClassExpression" && w2(r2.decorators)))
              return true;
            break;
          case "ExportDefaultDeclaration":
            return li3(e2, t2) || r2.type === "SequenceExpression";
          case "Decorator":
            if (n2 === "expression" && !pc2(r2))
              return true;
            break;
          case "TypeAnnotation":
            if (e2.match(void 0, void 0, (p2, A) => A === "returnType" && p2.type === "ArrowFunctionExpression") && ic(r2))
              return true;
            break;
          case "BinaryExpression":
            if (n2 === "left" && (s2.operator === "in" || s2.operator === "instanceof") && r2.type === "UnaryExpression")
              return true;
            break;
          case "VariableDeclarator":
            if (n2 === "init" && e2.match(void 0, void 0, (p2, A) => A === "declarations" && p2.type === "VariableDeclaration", (p2, A) => A === "left" && p2.type === "ForInStatement"))
              return true;
            break;
        }
        switch (r2.type) {
          case "UpdateExpression":
            if (s2.type === "UnaryExpression")
              return r2.prefix && (r2.operator === "++" && s2.operator === "+" || r2.operator === "--" && s2.operator === "-");
          case "UnaryExpression":
            switch (s2.type) {
              case "UnaryExpression":
                return r2.operator === s2.operator && (r2.operator === "+" || r2.operator === "-");
              case "BindExpression":
                return true;
              case "MemberExpression":
              case "OptionalMemberExpression":
                return n2 === "object";
              case "TaggedTemplateExpression":
                return true;
              case "NewExpression":
              case "CallExpression":
              case "OptionalCallExpression":
                return n2 === "callee";
              case "BinaryExpression":
                return n2 === "left" && s2.operator === "**";
              case "TSNonNullExpression":
                return true;
              default:
                return false;
            }
          case "BinaryExpression":
            if (s2.type === "UpdateExpression" || r2.operator === "in" && uc2(e2))
              return true;
            if (r2.operator === "|>" && ((c2 = r2.extra) != null && c2.parenthesized)) {
              let p2 = e2.grandparent;
              if (p2.type === "BinaryExpression" && p2.operator === "|>")
                return true;
            }
          case "TSTypeAssertion":
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "AsExpression":
          case "AsConstExpression":
          case "SatisfiesExpression":
          case "LogicalExpression":
            switch (s2.type) {
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "AsExpression":
              case "AsConstExpression":
              case "SatisfiesExpression":
                return !Te2(r2);
              case "ConditionalExpression":
                return Te2(r2) || au2(r2);
              case "CallExpression":
              case "NewExpression":
              case "OptionalCallExpression":
                return n2 === "callee";
              case "ClassExpression":
              case "ClassDeclaration":
                return n2 === "superClass";
              case "TSTypeAssertion":
              case "TaggedTemplateExpression":
              case "UnaryExpression":
              case "JSXSpreadAttribute":
              case "SpreadElement":
              case "BindExpression":
              case "AwaitExpression":
              case "TSNonNullExpression":
              case "UpdateExpression":
                return true;
              case "MemberExpression":
              case "OptionalMemberExpression":
                return n2 === "object";
              case "AssignmentExpression":
              case "AssignmentPattern":
                return n2 === "left" && (r2.type === "TSTypeAssertion" || Te2(r2));
              case "LogicalExpression":
                if (r2.type === "LogicalExpression")
                  return s2.operator !== r2.operator;
              case "BinaryExpression": {
                let { operator: p2, type: A } = r2;
                if (!p2 && A !== "TSTypeAssertion")
                  return true;
                let T3 = er2(p2), S3 = s2.operator, B2 = er2(S3);
                return B2 > T3 || n2 === "right" && B2 === T3 || B2 === T3 && !nr2(S3, p2) ? true : B2 < T3 && p2 === "%" ? S3 === "+" || S3 === "-" : !!yu2(S3);
              }
              default:
                return false;
            }
          case "SequenceExpression":
            switch (s2.type) {
              case "ReturnStatement":
                return false;
              case "ForStatement":
                return false;
              case "ExpressionStatement":
                return n2 !== "expression";
              case "ArrowFunctionExpression":
                return n2 !== "body";
              default:
                return true;
            }
          case "YieldExpression":
            if (s2.type === "AwaitExpression" || s2.type === "TSTypeAssertion")
              return true;
          case "AwaitExpression":
            switch (s2.type) {
              case "TaggedTemplateExpression":
              case "UnaryExpression":
              case "LogicalExpression":
              case "SpreadElement":
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSNonNullExpression":
              case "AsExpression":
              case "AsConstExpression":
              case "SatisfiesExpression":
              case "BindExpression":
                return true;
              case "MemberExpression":
              case "OptionalMemberExpression":
                return n2 === "object";
              case "NewExpression":
              case "CallExpression":
              case "OptionalCallExpression":
                return n2 === "callee";
              case "ConditionalExpression":
                return n2 === "test";
              case "BinaryExpression":
                return !(!r2.argument && s2.operator === "|>");
              default:
                return false;
            }
          case "TSFunctionType":
            if (e2.match((p2) => p2.type === "TSFunctionType", (p2, A) => A === "typeAnnotation" && p2.type === "TSTypeAnnotation", (p2, A) => A === "returnType" && p2.type === "ArrowFunctionExpression"))
              return true;
          case "TSConditionalType":
          case "TSConstructorType":
            if (n2 === "extendsType" && s2.type === "TSConditionalType") {
              if (r2.type === "TSConditionalType")
                return true;
              let { typeAnnotation: p2 } = r2.returnType || r2.typeAnnotation;
              if (p2.type === "TSTypePredicate" && p2.typeAnnotation && (p2 = p2.typeAnnotation.typeAnnotation), p2.type === "TSInferType" && p2.typeParameter.constraint)
                return true;
            }
            if (n2 === "checkType" && s2.type === "TSConditionalType")
              return true;
          case "TSUnionType":
          case "TSIntersectionType":
            if ((s2.type === "TSUnionType" || s2.type === "TSIntersectionType") && s2.types.length > 1 && (!r2.types || r2.types.length > 1))
              return true;
          case "TSInferType":
            if (r2.type === "TSInferType") {
              if (s2.type === "TSRestType")
                return false;
              if (n2 === "types" && (s2.type === "TSUnionType" || s2.type === "TSIntersectionType") && r2.typeParameter.type === "TSTypeParameter" && r2.typeParameter.constraint)
                return true;
            }
          case "TSTypeOperator":
            return s2.type === "TSArrayType" || s2.type === "TSOptionalType" || s2.type === "TSRestType" || n2 === "objectType" && s2.type === "TSIndexedAccessType" || s2.type === "TSTypeOperator" || s2.type === "TSTypeAnnotation" && e2.grandparent.type.startsWith("TSJSDoc");
          case "TSTypeQuery":
            return n2 === "objectType" && s2.type === "TSIndexedAccessType" || n2 === "elementType" && s2.type === "TSArrayType";
          case "TypeOperator":
            return s2.type === "ArrayTypeAnnotation" || s2.type === "NullableTypeAnnotation" || n2 === "objectType" && (s2.type === "IndexedAccessType" || s2.type === "OptionalIndexedAccessType") || s2.type === "TypeOperator";
          case "TypeofTypeAnnotation":
            return n2 === "objectType" && (s2.type === "IndexedAccessType" || s2.type === "OptionalIndexedAccessType") || n2 === "elementType" && s2.type === "ArrayTypeAnnotation";
          case "ArrayTypeAnnotation":
            return s2.type === "NullableTypeAnnotation";
          case "IntersectionTypeAnnotation":
          case "UnionTypeAnnotation":
            return s2.type === "TypeOperator" || s2.type === "ArrayTypeAnnotation" || s2.type === "NullableTypeAnnotation" || s2.type === "IntersectionTypeAnnotation" || s2.type === "UnionTypeAnnotation" || n2 === "objectType" && (s2.type === "IndexedAccessType" || s2.type === "OptionalIndexedAccessType");
          case "InferTypeAnnotation":
          case "NullableTypeAnnotation":
            return s2.type === "ArrayTypeAnnotation" || n2 === "objectType" && (s2.type === "IndexedAccessType" || s2.type === "OptionalIndexedAccessType");
          case "ComponentTypeAnnotation":
          case "FunctionTypeAnnotation": {
            if (r2.type === "ComponentTypeAnnotation" && (r2.rendersType === null || r2.rendersType === void 0))
              return false;
            if (e2.match(void 0, (A, T3) => T3 === "typeAnnotation" && A.type === "TypeAnnotation", (A, T3) => T3 === "returnType" && A.type === "ArrowFunctionExpression") || e2.match(void 0, (A, T3) => T3 === "typeAnnotation" && A.type === "TypePredicate", (A, T3) => T3 === "typeAnnotation" && A.type === "TypeAnnotation", (A, T3) => T3 === "returnType" && A.type === "ArrowFunctionExpression"))
              return true;
            let p2 = s2.type === "NullableTypeAnnotation" ? e2.grandparent : s2;
            return p2.type === "UnionTypeAnnotation" || p2.type === "IntersectionTypeAnnotation" || p2.type === "ArrayTypeAnnotation" || n2 === "objectType" && (p2.type === "IndexedAccessType" || p2.type === "OptionalIndexedAccessType") || n2 === "checkType" && s2.type === "ConditionalTypeAnnotation" || n2 === "extendsType" && s2.type === "ConditionalTypeAnnotation" && ((m = r2.returnType) == null ? void 0 : m.type) === "InferTypeAnnotation" && ((D = r2.returnType) == null ? void 0 : D.typeParameter.bound) || p2.type === "NullableTypeAnnotation" || s2.type === "FunctionTypeParam" && s2.name === null && K2(r2).some((A) => {
              var T3;
              return ((T3 = A.typeAnnotation) == null ? void 0 : T3.type) === "NullableTypeAnnotation";
            });
          }
          case "ConditionalTypeAnnotation":
            if (n2 === "extendsType" && s2.type === "ConditionalTypeAnnotation" && r2.type === "ConditionalTypeAnnotation" || n2 === "checkType" && s2.type === "ConditionalTypeAnnotation")
              return true;
          case "OptionalIndexedAccessType":
            return n2 === "objectType" && s2.type === "IndexedAccessType";
          case "StringLiteral":
          case "NumericLiteral":
          case "Literal":
            if (typeof r2.value == "string" && s2.type === "ExpressionStatement" && !s2.directive) {
              let p2 = e2.grandparent;
              return p2.type === "Program" || p2.type === "BlockStatement";
            }
            return n2 === "object" && s2.type === "MemberExpression" && typeof r2.value == "number";
          case "AssignmentExpression": {
            let p2 = e2.grandparent;
            return n2 === "body" && s2.type === "ArrowFunctionExpression" ? true : n2 === "key" && (s2.type === "ClassProperty" || s2.type === "PropertyDefinition") && s2.computed || (n2 === "init" || n2 === "update") && s2.type === "ForStatement" ? false : s2.type === "ExpressionStatement" ? r2.left.type === "ObjectPattern" : !(n2 === "key" && s2.type === "TSPropertySignature" || s2.type === "AssignmentExpression" || s2.type === "SequenceExpression" && p2.type === "ForStatement" && (p2.init === s2 || p2.update === s2) || n2 === "value" && s2.type === "Property" && p2.type === "ObjectPattern" && p2.properties.includes(s2) || s2.type === "NGChainedExpression");
          }
          case "ConditionalExpression":
            switch (s2.type) {
              case "TaggedTemplateExpression":
              case "UnaryExpression":
              case "SpreadElement":
              case "BinaryExpression":
              case "LogicalExpression":
              case "NGPipeExpression":
              case "ExportDefaultDeclaration":
              case "AwaitExpression":
              case "JSXSpreadAttribute":
              case "TSTypeAssertion":
              case "TypeCastExpression":
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "AsExpression":
              case "AsConstExpression":
              case "SatisfiesExpression":
              case "TSNonNullExpression":
                return true;
              case "NewExpression":
              case "CallExpression":
              case "OptionalCallExpression":
                return n2 === "callee";
              case "ConditionalExpression":
                return t2.experimentalTernaries ? false : n2 === "test";
              case "MemberExpression":
              case "OptionalMemberExpression":
                return n2 === "object";
              default:
                return false;
            }
          case "FunctionExpression":
            switch (s2.type) {
              case "NewExpression":
              case "CallExpression":
              case "OptionalCallExpression":
                return n2 === "callee";
              case "TaggedTemplateExpression":
                return true;
              default:
                return false;
            }
          case "ArrowFunctionExpression":
            switch (s2.type) {
              case "BinaryExpression":
                return s2.operator !== "|>" || ((y3 = r2.extra) == null ? void 0 : y3.parenthesized);
              case "NewExpression":
              case "CallExpression":
              case "OptionalCallExpression":
                return n2 === "callee";
              case "MemberExpression":
              case "OptionalMemberExpression":
                return n2 === "object";
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "AsExpression":
              case "AsConstExpression":
              case "SatisfiesExpression":
              case "TSNonNullExpression":
              case "BindExpression":
              case "TaggedTemplateExpression":
              case "UnaryExpression":
              case "LogicalExpression":
              case "AwaitExpression":
              case "TSTypeAssertion":
                return true;
              case "ConditionalExpression":
                return n2 === "test";
              default:
                return false;
            }
          case "ClassExpression":
            switch (s2.type) {
              case "NewExpression":
                return n2 === "callee";
              default:
                return false;
            }
          case "OptionalMemberExpression":
          case "OptionalCallExpression":
          case "CallExpression":
          case "MemberExpression":
            if (oc2(e2))
              return true;
          case "TaggedTemplateExpression":
          case "TSNonNullExpression":
            if (n2 === "callee" && (s2.type === "BindExpression" || s2.type === "NewExpression")) {
              let p2 = r2;
              for (; p2; )
                switch (p2.type) {
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                  case "BindExpression":
                    p2 = p2.object;
                    break;
                  case "TaggedTemplateExpression":
                    p2 = p2.tag;
                    break;
                  case "TSNonNullExpression":
                    p2 = p2.expression;
                    break;
                  default:
                    return false;
                }
            }
            return false;
          case "BindExpression":
            return n2 === "callee" && (s2.type === "BindExpression" || s2.type === "NewExpression") || n2 === "object" && q2(s2);
          case "NGPipeExpression":
            return !(s2.type === "NGRoot" || s2.type === "NGMicrosyntaxExpression" || s2.type === "ObjectProperty" && !((C = r2.extra) != null && C.parenthesized) || U2(s2) || n2 === "arguments" && L3(s2) || n2 === "right" && s2.type === "NGPipeExpression" || n2 === "property" && s2.type === "MemberExpression" || s2.type === "AssignmentExpression");
          case "JSXFragment":
          case "JSXElement":
            return n2 === "callee" || n2 === "left" && s2.type === "BinaryExpression" && s2.operator === "<" || !U2(s2) && s2.type !== "ArrowFunctionExpression" && s2.type !== "AssignmentExpression" && s2.type !== "AssignmentPattern" && s2.type !== "BinaryExpression" && s2.type !== "NewExpression" && s2.type !== "ConditionalExpression" && s2.type !== "ExpressionStatement" && s2.type !== "JsExpressionRoot" && s2.type !== "JSXAttribute" && s2.type !== "JSXElement" && s2.type !== "JSXExpressionContainer" && s2.type !== "JSXFragment" && s2.type !== "LogicalExpression" && !L3(s2) && !Ae3(s2) && s2.type !== "ReturnStatement" && s2.type !== "ThrowStatement" && s2.type !== "TypeCastExpression" && s2.type !== "VariableDeclarator" && s2.type !== "YieldExpression";
          case "TSInstantiationExpression":
            return n2 === "object" && q2(s2);
        }
        return false;
      }
      var sc2 = v2(["BlockStatement", "BreakStatement", "ComponentDeclaration", "ClassBody", "ClassDeclaration", "ClassMethod", "ClassProperty", "PropertyDefinition", "ClassPrivateProperty", "ContinueStatement", "DebuggerStatement", "DeclareComponent", "DeclareClass", "DeclareExportAllDeclaration", "DeclareExportDeclaration", "DeclareFunction", "DeclareHook", "DeclareInterface", "DeclareModule", "DeclareModuleExports", "DeclareNamespace", "DeclareVariable", "DeclareEnum", "DoWhileStatement", "EnumDeclaration", "ExportAllDeclaration", "ExportDefaultDeclaration", "ExportNamedDeclaration", "ExpressionStatement", "ForInStatement", "ForOfStatement", "ForStatement", "FunctionDeclaration", "HookDeclaration", "IfStatement", "ImportDeclaration", "InterfaceDeclaration", "LabeledStatement", "MethodDefinition", "ReturnStatement", "SwitchStatement", "ThrowStatement", "TryStatement", "TSDeclareFunction", "TSEnumDeclaration", "TSImportEqualsDeclaration", "TSInterfaceDeclaration", "TSModuleDeclaration", "TSNamespaceExportDeclaration", "TypeAlias", "VariableDeclaration", "WhileStatement", "WithStatement"]);
      function uc2(e2) {
        let t2 = 0, { node: r2 } = e2;
        for (; r2; ) {
          let n2 = e2.getParentNode(t2++);
          if ((n2 == null ? void 0 : n2.type) === "ForStatement" && n2.init === r2)
            return true;
          r2 = n2;
        }
        return false;
      }
      function ic(e2) {
        return tr2(e2, (t2) => t2.type === "ObjectTypeAnnotation" && tr2(t2, (r2) => r2.type === "FunctionTypeAnnotation"));
      }
      function ac2(e2) {
        return se2(e2);
      }
      function or3(e2) {
        let { parent: t2, key: r2 } = e2;
        switch (t2.type) {
          case "NGPipeExpression":
            if (r2 === "arguments" && e2.isLast)
              return e2.callParent(or3);
            break;
          case "ObjectProperty":
            if (r2 === "value")
              return e2.callParent(() => e2.key === "properties" && e2.isLast);
            break;
          case "BinaryExpression":
          case "LogicalExpression":
            if (r2 === "right")
              return e2.callParent(or3);
            break;
          case "ConditionalExpression":
            if (r2 === "alternate")
              return e2.callParent(or3);
            break;
          case "UnaryExpression":
            if (t2.prefix)
              return e2.callParent(or3);
            break;
        }
        return false;
      }
      function li3(e2, t2) {
        let { node: r2, parent: n2 } = e2;
        return r2.type === "FunctionExpression" || r2.type === "ClassExpression" ? n2.type === "ExportDefaultDeclaration" || !is(e2, t2) : !jt2(r2) || n2.type !== "ExportDefaultDeclaration" && is(e2, t2) ? false : e2.call(() => li3(e2, t2), ...Pr2(r2));
      }
      function oc2(e2) {
        let { node: t2, parent: r2, grandparent: n2, key: s2 } = e2;
        return !!((t2.type === "OptionalMemberExpression" || t2.type === "OptionalCallExpression") && (s2 === "object" && r2.type === "MemberExpression" || s2 === "callee" && (r2.type === "CallExpression" || r2.type === "NewExpression") || r2.type === "TSNonNullExpression" && n2.type === "MemberExpression" && n2.object === r2) || e2.match(() => t2.type === "CallExpression" || t2.type === "MemberExpression", (u2, i2) => i2 === "expression" && u2.type === "ChainExpression") && (e2.match(void 0, void 0, (u2, i2) => i2 === "callee" && (u2.type === "CallExpression" && !u2.optional || u2.type === "NewExpression") || i2 === "object" && u2.type === "MemberExpression" && !u2.optional) || e2.match(void 0, void 0, (u2, i2) => i2 === "expression" && u2.type === "TSNonNullExpression", (u2, i2) => i2 === "object" && u2.type === "MemberExpression")) || e2.match(() => t2.type === "CallExpression" || t2.type === "MemberExpression", (u2, i2) => i2 === "expression" && u2.type === "TSNonNullExpression", (u2, i2) => i2 === "expression" && u2.type === "ChainExpression", (u2, i2) => i2 === "object" && u2.type === "MemberExpression"));
      }
      function as(e2) {
        return e2.type === "Identifier" ? true : q2(e2) ? !e2.computed && !e2.optional && e2.property.type === "Identifier" && as(e2.object) : false;
      }
      function pc2(e2) {
        return e2.type === "ChainExpression" && (e2 = e2.expression), as(e2) || L3(e2) && !e2.optional && as(e2.callee);
      }
      var Be3 = is;
      function cc2(e2, t2) {
        let r2 = t2 - 1;
        r2 = Ge3(e2, r2, { backwards: true }), r2 = Ue2(e2, r2, { backwards: true }), r2 = Ge3(e2, r2, { backwards: true });
        let n2 = Ue2(e2, r2, { backwards: true });
        return r2 !== n2;
      }
      var mi = cc2;
      var lc2 = () => true;
      function os(e2, t2) {
        let r2 = e2.node;
        return r2.printed = true, t2.printer.printComment(e2, t2);
      }
      function mc2(e2, t2) {
        var m;
        let r2 = e2.node, n2 = [os(e2, t2)], { printer: s2, originalText: u2, locStart: i2, locEnd: a2 } = t2;
        if ((m = s2.isBlockComment) == null ? void 0 : m.call(s2, r2)) {
          let D = te2(u2, a2(r2)) ? te2(u2, i2(r2), { backwards: true }) ? F : x2 : " ";
          n2.push(D);
        } else
          n2.push(F);
        let c2 = Ue2(u2, Ge3(u2, a2(r2)));
        return c2 !== false && te2(u2, c2) && n2.push(F), n2;
      }
      function yc2(e2, t2, r2) {
        var c2;
        let n2 = e2.node, s2 = os(e2, t2), { printer: u2, originalText: i2, locStart: a2 } = t2, o2 = (c2 = u2.isBlockComment) == null ? void 0 : c2.call(u2, n2);
        if (r2 != null && r2.hasLineSuffix && !(r2 != null && r2.isBlock) || te2(i2, a2(n2), { backwards: true })) {
          let m = mi(i2, a2(n2));
          return { doc: Gn3([F, m ? F : "", s2]), isBlock: o2, hasLineSuffix: true };
        }
        return !o2 || r2 != null && r2.hasLineSuffix ? { doc: [Gn3([" ", s2]), Ee2], isBlock: o2, hasLineSuffix: true } : { doc: [" ", s2], isBlock: o2, hasLineSuffix: false };
      }
      function M3(e2, t2, r2 = {}) {
        let { node: n2 } = e2;
        if (!w2(n2 == null ? void 0 : n2.comments))
          return "";
        let { indent: s2 = false, marker: u2, filter: i2 = lc2 } = r2, a2 = [];
        if (e2.each(({ node: c2 }) => {
          c2.leading || c2.trailing || c2.marker !== u2 || !i2(c2) || a2.push(os(e2, t2));
        }, "comments"), a2.length === 0)
          return "";
        let o2 = P2(F, a2);
        return s2 ? f2([F, o2]) : o2;
      }
      function ps(e2, t2) {
        let r2 = e2.node;
        if (!r2)
          return {};
        let n2 = t2[Symbol.for("printedComments")];
        if ((r2.comments || []).filter((o2) => !n2.has(o2)).length === 0)
          return { leading: "", trailing: "" };
        let u2 = [], i2 = [], a2;
        return e2.each(() => {
          let o2 = e2.node;
          if (n2 != null && n2.has(o2))
            return;
          let { leading: c2, trailing: m } = o2;
          c2 ? u2.push(mc2(e2, t2)) : m && (a2 = yc2(e2, t2, a2), i2.push(a2.doc));
        }, "comments"), { leading: u2, trailing: i2 };
      }
      function ye(e2, t2, r2) {
        let { leading: n2, trailing: s2 } = ps(e2, r2);
        return !n2 && !s2 ? t2 : ir3(t2, (u2) => [n2, u2, s2]);
      }
      var cs = class extends Error {
        constructor(t2, r2, n2 = "type") {
          super(`Unexpected ${r2} node ${n2}: ${JSON.stringify(t2[n2])}.`);
          __publicField(this, "name", "UnexpectedNodeError");
          this.node = t2;
        }
      }, Me3 = cs;
      function ls(e2) {
        if (typeof e2 != "string")
          throw new TypeError("Expected a string");
        return e2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
      }
      var Re3, ms = class {
        constructor(t2) {
          Ws2(this, Re3);
          Gs2(this, Re3, new Set(t2));
        }
        getLeadingWhitespaceCount(t2) {
          let r2 = pt3(this, Re3), n2 = 0;
          for (let s2 = 0; s2 < t2.length && r2.has(t2.charAt(s2)); s2++)
            n2++;
          return n2;
        }
        getTrailingWhitespaceCount(t2) {
          let r2 = pt3(this, Re3), n2 = 0;
          for (let s2 = t2.length - 1; s2 >= 0 && r2.has(t2.charAt(s2)); s2--)
            n2++;
          return n2;
        }
        getLeadingWhitespace(t2) {
          let r2 = this.getLeadingWhitespaceCount(t2);
          return t2.slice(0, r2);
        }
        getTrailingWhitespace(t2) {
          let r2 = this.getTrailingWhitespaceCount(t2);
          return t2.slice(t2.length - r2);
        }
        hasLeadingWhitespace(t2) {
          return pt3(this, Re3).has(t2.charAt(0));
        }
        hasTrailingWhitespace(t2) {
          return pt3(this, Re3).has(O2(false, t2, -1));
        }
        trimStart(t2) {
          let r2 = this.getLeadingWhitespaceCount(t2);
          return t2.slice(r2);
        }
        trimEnd(t2) {
          let r2 = this.getTrailingWhitespaceCount(t2);
          return t2.slice(0, t2.length - r2);
        }
        trim(t2) {
          return this.trimEnd(this.trimStart(t2));
        }
        split(t2, r2 = false) {
          let n2 = `[${ls([...pt3(this, Re3)].join(""))}]+`, s2 = new RegExp(r2 ? `(${n2})` : n2, "u");
          return t2.split(s2);
        }
        hasWhitespaceCharacter(t2) {
          let r2 = pt3(this, Re3);
          return Array.prototype.some.call(t2, (n2) => r2.has(n2));
        }
        hasNonWhitespaceCharacter(t2) {
          let r2 = pt3(this, Re3);
          return Array.prototype.some.call(t2, (n2) => !r2.has(n2));
        }
        isWhitespaceOnly(t2) {
          let r2 = pt3(this, Re3);
          return Array.prototype.every.call(t2, (n2) => r2.has(n2));
        }
      };
      Re3 = /* @__PURE__ */ new WeakMap();
      var yi = ms;
      var Nr3 = new yi(` 
\r	`), ys = (e2) => e2 === "" || e2 === x2 || e2 === F || e2 === E2;
      function Dc2(e2, t2, r2) {
        var _3, J3, j2;
        let { node: n2 } = e2;
        if (n2.type === "JSXElement" && Pc(n2))
          return [r2("openingElement"), r2("closingElement")];
        let s2 = n2.type === "JSXElement" ? r2("openingElement") : r2("openingFragment"), u2 = n2.type === "JSXElement" ? r2("closingElement") : r2("closingFragment");
        if (n2.children.length === 1 && n2.children[0].type === "JSXExpressionContainer" && (n2.children[0].expression.type === "TemplateLiteral" || n2.children[0].expression.type === "TaggedTemplateExpression"))
          return [s2, ...e2.map(r2, "children"), u2];
        n2.children = n2.children.map((h2) => kc2(h2) ? { type: "JSXText", value: " ", raw: " " } : h2);
        let i2 = n2.children.some(X3), a2 = n2.children.filter((h2) => h2.type === "JSXExpressionContainer").length > 1, o2 = n2.type === "JSXElement" && n2.openingElement.attributes.length > 1, c2 = ne3(s2) || i2 || o2 || a2, m = e2.parent.rootMarker === "mdx", D = t2.singleQuote ? "{' '}" : '{" "}', y3 = m ? " " : b3([D, E2], " "), C = ((J3 = (_3 = n2.openingElement) == null ? void 0 : _3.name) == null ? void 0 : J3.name) === "fbt", p2 = fc2(e2, t2, r2, y3, C), A = n2.children.some((h2) => pr3(h2));
        for (let h2 = p2.length - 2; h2 >= 0; h2--) {
          let W2 = p2[h2] === "" && p2[h2 + 1] === "", Fe3 = p2[h2] === F && p2[h2 + 1] === "" && p2[h2 + 2] === F, H3 = (p2[h2] === E2 || p2[h2] === F) && p2[h2 + 1] === "" && p2[h2 + 2] === y3, ue2 = p2[h2] === y3 && p2[h2 + 1] === "" && (p2[h2 + 2] === E2 || p2[h2 + 2] === F), Z3 = p2[h2] === y3 && p2[h2 + 1] === "" && p2[h2 + 2] === y3, It2 = p2[h2] === E2 && p2[h2 + 1] === "" && p2[h2 + 2] === F || p2[h2] === F && p2[h2 + 1] === "" && p2[h2 + 2] === E2;
          Fe3 && A || W2 || H3 || Z3 || It2 ? p2.splice(h2, 2) : ue2 && p2.splice(h2 + 1, 2);
        }
        for (; p2.length > 0 && ys(O2(false, p2, -1)); )
          p2.pop();
        for (; p2.length > 1 && ys(p2[0]) && ys(p2[1]); )
          p2.shift(), p2.shift();
        let T3 = [];
        for (let [h2, W2] of p2.entries()) {
          if (W2 === y3) {
            if (h2 === 1 && p2[h2 - 1] === "") {
              if (p2.length === 2) {
                T3.push(D);
                continue;
              }
              T3.push([D, F]);
              continue;
            } else if (h2 === p2.length - 1) {
              T3.push(D);
              continue;
            } else if (p2[h2 - 1] === "" && p2[h2 - 2] === F) {
              T3.push(D);
              continue;
            }
          }
          T3.push(W2), ne3(W2) && (c2 = true);
        }
        let S3 = A ? qt2(T3) : l2(T3, { shouldBreak: true });
        if (((j2 = t2.cursorNode) == null ? void 0 : j2.type) === "JSXText" && n2.children.includes(t2.cursorNode) && (S3 = [Nn2, S3, Nn2]), m)
          return S3;
        let B2 = l2([s2, f2([F, S3]), F, u2]);
        return c2 ? B2 : ze2([l2([s2, ...p2, u2]), B2]);
      }
      function fc2(e2, t2, r2, n2, s2) {
        let u2 = [];
        return e2.each(({ node: i2, next: a2 }) => {
          if (i2.type === "JSXText") {
            let o2 = fe2(i2);
            if (pr3(i2)) {
              let c2 = Nr3.split(o2, true);
              c2[0] === "" && (u2.push(""), c2.shift(), /\n/u.test(c2[0]) ? u2.push(fi2(s2, c2[1], i2, a2)) : u2.push(n2), c2.shift());
              let m;
              if (O2(false, c2, -1) === "" && (c2.pop(), m = c2.pop()), c2.length === 0)
                return;
              for (let [D, y3] of c2.entries())
                D % 2 === 1 ? u2.push(x2) : u2.push(y3);
              m !== void 0 ? /\n/u.test(m) ? u2.push(fi2(s2, O2(false, u2, -1), i2, a2)) : u2.push(n2) : u2.push(Di2(s2, O2(false, u2, -1), i2, a2));
            } else
              /\n/u.test(o2) ? o2.match(/\n/gu).length > 1 && u2.push("", F) : u2.push("", n2);
          } else {
            let o2 = r2();
            if (u2.push(o2), a2 && pr3(a2)) {
              let m = Nr3.trim(fe2(a2)), [D] = Nr3.split(m);
              u2.push(Di2(s2, D, i2, a2));
            } else
              u2.push(F);
          }
        }, "children"), u2;
      }
      function Di2(e2, t2, r2, n2) {
        return e2 ? "" : r2.type === "JSXElement" && !r2.closingElement || (n2 == null ? void 0 : n2.type) === "JSXElement" && !n2.closingElement ? t2.length === 1 ? E2 : F : E2;
      }
      function fi2(e2, t2, r2, n2) {
        return e2 ? F : t2.length === 1 ? r2.type === "JSXElement" && !r2.closingElement || (n2 == null ? void 0 : n2.type) === "JSXElement" && !n2.closingElement ? F : E2 : F;
      }
      var Ec = /* @__PURE__ */ new Set(["ArrayExpression", "TupleExpression", "JSXAttribute", "JSXElement", "JSXExpressionContainer", "JSXFragment", "ExpressionStatement", "CallExpression", "OptionalCallExpression", "ConditionalExpression", "JsExpressionRoot"]);
      function Fc(e2, t2, r2) {
        let { parent: n2 } = e2;
        if (Ec.has(n2.type))
          return t2;
        let s2 = e2.match(void 0, (i2) => i2.type === "ArrowFunctionExpression", L3, (i2) => i2.type === "JSXExpressionContainer"), u2 = Be3(e2, r2);
        return l2([u2 ? "" : b3("("), f2([E2, t2]), E2, u2 ? "" : b3(")")], { shouldBreak: s2 });
      }
      function Cc(e2, t2, r2) {
        let { node: n2 } = e2, s2 = [];
        if (s2.push(r2("name")), n2.value) {
          let u2;
          if (Q3(n2.value)) {
            let i2 = fe2(n2.value), a2 = N2(false, N2(false, i2.slice(1, -1), "&apos;", "'"), "&quot;", '"'), o2 = xr3(a2, t2.jsxSingleQuote);
            a2 = o2 === '"' ? N2(false, a2, '"', "&quot;") : N2(false, a2, "'", "&apos;"), u2 = e2.call(() => ye(e2, Ie3(o2 + a2 + o2), t2), "value");
          } else
            u2 = r2("value");
          s2.push("=", u2);
        }
        return s2;
      }
      function Ac(e2, t2, r2) {
        let { node: n2 } = e2, s2 = (u2, i2) => u2.type === "JSXEmptyExpression" || !d2(u2) && (U2(u2) || se2(u2) || u2.type === "ArrowFunctionExpression" || u2.type === "AwaitExpression" && (s2(u2.argument, u2) || u2.argument.type === "JSXElement") || L3(u2) || u2.type === "ChainExpression" && L3(u2.expression) || u2.type === "FunctionExpression" || u2.type === "TemplateLiteral" || u2.type === "TaggedTemplateExpression" || u2.type === "DoExpression" || X3(i2) && (u2.type === "ConditionalExpression" || De3(u2)));
        return s2(n2.expression, e2.parent) ? l2(["{", r2("expression"), ke3, "}"]) : l2(["{", f2([E2, r2("expression")]), E2, ke3, "}"]);
      }
      function Tc(e2, t2, r2) {
        var a2, o2;
        let { node: n2 } = e2, s2 = d2(n2.name) || d2(n2.typeParameters) || d2(n2.typeArguments);
        if (n2.selfClosing && n2.attributes.length === 0 && !s2)
          return ["<", r2("name"), n2.typeArguments ? r2("typeArguments") : r2("typeParameters"), " />"];
        if (((a2 = n2.attributes) == null ? void 0 : a2.length) === 1 && Q3(n2.attributes[0].value) && !n2.attributes[0].value.value.includes(`
`) && !s2 && !d2(n2.attributes[0]))
          return l2(["<", r2("name"), n2.typeArguments ? r2("typeArguments") : r2("typeParameters"), " ", ...e2.map(r2, "attributes"), n2.selfClosing ? " />" : ">"]);
        let u2 = (o2 = n2.attributes) == null ? void 0 : o2.some((c2) => Q3(c2.value) && c2.value.value.includes(`
`)), i2 = t2.singleAttributePerLine && n2.attributes.length > 1 ? F : x2;
        return l2(["<", r2("name"), n2.typeArguments ? r2("typeArguments") : r2("typeParameters"), f2(e2.map(() => [i2, r2()], "attributes")), ...dc2(n2, t2, s2)], { shouldBreak: u2 });
      }
      function dc2(e2, t2, r2) {
        return e2.selfClosing ? [x2, "/>"] : xc(e2, t2, r2) ? [">"] : [E2, ">"];
      }
      function xc(e2, t2, r2) {
        let n2 = e2.attributes.length > 0 && d2(O2(false, e2.attributes, -1), g2.Trailing);
        return e2.attributes.length === 0 && !r2 || (t2.bracketSameLine || t2.jsxBracketSameLine) && (!r2 || e2.attributes.length > 0) && !n2;
      }
      function hc2(e2, t2, r2) {
        let { node: n2 } = e2, s2 = [];
        s2.push("</");
        let u2 = r2("name");
        return d2(n2.name, g2.Leading | g2.Line) ? s2.push(f2([F, u2]), F) : d2(n2.name, g2.Leading | g2.Block) ? s2.push(" ", u2) : s2.push(u2), s2.push(">"), s2;
      }
      function gc2(e2, t2) {
        let { node: r2 } = e2, n2 = d2(r2), s2 = d2(r2, g2.Line), u2 = r2.type === "JSXOpeningFragment";
        return [u2 ? "<" : "</", f2([s2 ? F : n2 && !u2 ? " " : "", M3(e2, t2)]), s2 ? F : "", ">"];
      }
      function Sc2(e2, t2, r2) {
        let n2 = ye(e2, Dc2(e2, t2, r2), t2);
        return Fc(e2, n2, t2);
      }
      function Bc(e2, t2) {
        let { node: r2 } = e2, n2 = d2(r2, g2.Line);
        return [M3(e2, t2, { indent: n2 }), n2 ? F : ""];
      }
      function bc2(e2, t2, r2) {
        let { node: n2 } = e2;
        return ["{", e2.call(({ node: s2 }) => {
          let u2 = ["...", r2()];
          return !d2(s2) || !Qn3(e2) ? u2 : [f2([E2, ye(e2, u2, t2)]), E2];
        }, n2.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
      }
      function Ei(e2, t2, r2) {
        let { node: n2 } = e2;
        if (n2.type.startsWith("JSX"))
          switch (n2.type) {
            case "JSXAttribute":
              return Cc(e2, t2, r2);
            case "JSXIdentifier":
              return n2.name;
            case "JSXNamespacedName":
              return P2(":", [r2("namespace"), r2("name")]);
            case "JSXMemberExpression":
              return P2(".", [r2("object"), r2("property")]);
            case "JSXSpreadAttribute":
            case "JSXSpreadChild":
              return bc2(e2, t2, r2);
            case "JSXExpressionContainer":
              return Ac(e2, t2, r2);
            case "JSXFragment":
            case "JSXElement":
              return Sc2(e2, t2, r2);
            case "JSXOpeningElement":
              return Tc(e2, t2, r2);
            case "JSXClosingElement":
              return hc2(e2, t2, r2);
            case "JSXOpeningFragment":
            case "JSXClosingFragment":
              return gc2(e2, t2);
            case "JSXEmptyExpression":
              return Bc(e2, t2);
            case "JSXText":
              throw new Error("JSXText should be handled by JSXElement");
            default:
              throw new Me3(n2, "JSX");
          }
      }
      function Pc(e2) {
        if (e2.children.length === 0)
          return true;
        if (e2.children.length > 1)
          return false;
        let t2 = e2.children[0];
        return t2.type === "JSXText" && !pr3(t2);
      }
      function pr3(e2) {
        return e2.type === "JSXText" && (Nr3.hasNonWhitespaceCharacter(fe2(e2)) || !/\n/u.test(fe2(e2)));
      }
      function kc2(e2) {
        return e2.type === "JSXExpressionContainer" && Q3(e2.expression) && e2.expression.value === " " && !d2(e2.expression);
      }
      function Fi(e2) {
        let { node: t2, parent: r2 } = e2;
        if (!X3(t2) || !X3(r2))
          return false;
        let { index: n2, siblings: s2 } = e2, u2;
        for (let i2 = n2; i2 > 0; i2--) {
          let a2 = s2[i2 - 1];
          if (!(a2.type === "JSXText" && !pr3(a2))) {
            u2 = a2;
            break;
          }
        }
        return (u2 == null ? void 0 : u2.type) === "JSXExpressionContainer" && u2.expression.type === "JSXEmptyExpression" && Bt2(u2.expression);
      }
      function Ic(e2) {
        return Bt2(e2.node) || Fi(e2);
      }
      var Xr2 = Ic;
      var Lc = 0;
      function Yr3(e2, t2, r2) {
        var J3;
        let { node: n2, parent: s2, grandparent: u2, key: i2 } = e2, a2 = i2 !== "body" && (s2.type === "IfStatement" || s2.type === "WhileStatement" || s2.type === "SwitchStatement" || s2.type === "DoWhileStatement"), o2 = n2.operator === "|>" && ((J3 = e2.root.extra) == null ? void 0 : J3.__isUsingHackPipeline), c2 = Ds2(e2, r2, t2, false, a2);
        if (a2)
          return c2;
        if (o2)
          return l2(c2);
        if (L3(s2) && s2.callee === n2 || s2.type === "UnaryExpression" || q2(s2) && !s2.computed)
          return l2([f2([E2, ...c2]), E2]);
        let m = s2.type === "ReturnStatement" || s2.type === "ThrowStatement" || s2.type === "JSXExpressionContainer" && u2.type === "JSXAttribute" || n2.operator !== "|" && s2.type === "JsExpressionRoot" || n2.type !== "NGPipeExpression" && (s2.type === "NGRoot" && t2.parser === "__ng_binding" || s2.type === "NGMicrosyntaxExpression" && u2.type === "NGMicrosyntax" && u2.body.length === 1) || n2 === s2.body && s2.type === "ArrowFunctionExpression" || n2 !== s2.body && s2.type === "ForStatement" || s2.type === "ConditionalExpression" && u2.type !== "ReturnStatement" && u2.type !== "ThrowStatement" && !L3(u2) || s2.type === "TemplateLiteral", D = s2.type === "AssignmentExpression" || s2.type === "VariableDeclarator" || s2.type === "ClassProperty" || s2.type === "PropertyDefinition" || s2.type === "TSAbstractPropertyDefinition" || s2.type === "ClassPrivateProperty" || Ae3(s2), y3 = De3(n2.left) && nr2(n2.operator, n2.left.operator);
        if (m || Ut2(n2) && !y3 || !Ut2(n2) && D)
          return l2(c2);
        if (c2.length === 0)
          return "";
        let C = X3(n2.right), p2 = c2.findIndex((j2) => typeof j2 != "string" && !Array.isArray(j2) && j2.type === le2), A = c2.slice(0, p2 === -1 ? 1 : p2 + 1), T3 = c2.slice(A.length, C ? -1 : void 0), S3 = Symbol("logicalChain-" + ++Lc), B2 = l2([...A, f2(T3)], { id: S3 });
        if (!C)
          return B2;
        let _3 = O2(false, c2, -1);
        return l2([B2, At3(_3, { groupId: S3 })]);
      }
      function Ds2(e2, t2, r2, n2, s2) {
        var A;
        let { node: u2 } = e2;
        if (!De3(u2))
          return [l2(t2())];
        let i2 = [];
        nr2(u2.operator, u2.left.operator) ? i2 = e2.call((T3) => Ds2(T3, t2, r2, true, s2), "left") : i2.push(l2(t2("left")));
        let a2 = Ut2(u2), o2 = (u2.operator === "|>" || u2.type === "NGPipeExpression" || wc2(e2, r2)) && !Oe3(r2.originalText, u2.right), c2 = u2.type === "NGPipeExpression" ? "|" : u2.operator, m = u2.type === "NGPipeExpression" && u2.arguments.length > 0 ? l2(f2([E2, ": ", P2([x2, ": "], e2.map(() => he3(2, l2(t2())), "arguments"))])) : "", D;
        if (a2)
          D = [c2, " ", t2("right"), m];
        else {
          let S3 = c2 === "|>" && ((A = e2.root.extra) == null ? void 0 : A.__isUsingHackPipeline) ? e2.call((B2) => Ds2(B2, t2, r2, true, s2), "right") : t2("right");
          D = [o2 ? x2 : "", c2, o2 ? " " : x2, S3, m];
        }
        let { parent: y3 } = e2, C = d2(u2.left, g2.Trailing | g2.Line), p2 = C || !(s2 && u2.type === "LogicalExpression") && y3.type !== u2.type && u2.left.type !== u2.type && u2.right.type !== u2.type;
        if (i2.push(o2 ? "" : " ", p2 ? l2(D, { shouldBreak: C }) : D), n2 && d2(u2)) {
          let T3 = Wt2(ye(e2, i2, r2));
          return T3.type === Pe3 ? T3.parts : Array.isArray(T3) ? T3 : [T3];
        }
        return i2;
      }
      function Ut2(e2) {
        return e2.type !== "LogicalExpression" ? false : !!(se2(e2.right) && e2.right.properties.length > 0 || U2(e2.right) && e2.right.elements.length > 0 || X3(e2.right));
      }
      var Ci = (e2) => e2.type === "BinaryExpression" && e2.operator === "|";
      function wc2(e2, t2) {
        return (t2.parser === "__vue_expression" || t2.parser === "__vue_ts_expression") && Ci(e2.node) && !e2.hasAncestor((r2) => !Ci(r2) && r2.type !== "JsExpressionRoot");
      }
      function Ti2(e2, t2, r2) {
        let { node: n2 } = e2;
        if (n2.type.startsWith("NG"))
          switch (n2.type) {
            case "NGRoot":
              return [r2("node"), d2(n2.node) ? " //" + ct3(n2.node)[0].value.trimEnd() : ""];
            case "NGPipeExpression":
              return Yr3(e2, t2, r2);
            case "NGChainedExpression":
              return l2(P2([";", x2], e2.map(() => _c(e2) ? r2() : ["(", r2(), ")"], "expressions")));
            case "NGEmptyExpression":
              return "";
            case "NGMicrosyntax":
              return e2.map(() => [e2.isFirst ? "" : Ai2(e2) ? " " : [";", x2], r2()], "body");
            case "NGMicrosyntaxKey":
              return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/iu.test(n2.name) ? n2.name : JSON.stringify(n2.name);
            case "NGMicrosyntaxExpression":
              return [r2("expression"), n2.alias === null ? "" : [" as ", r2("alias")]];
            case "NGMicrosyntaxKeyedExpression": {
              let { index: s2, parent: u2 } = e2, i2 = Ai2(e2) || (s2 === 1 && (n2.key.name === "then" || n2.key.name === "else" || n2.key.name === "as") || (s2 === 2 || s2 === 3) && (n2.key.name === "else" && u2.body[s2 - 1].type === "NGMicrosyntaxKeyedExpression" && u2.body[s2 - 1].key.name === "then" || n2.key.name === "track")) && u2.body[0].type === "NGMicrosyntaxExpression";
              return [r2("key"), i2 ? " " : ": ", r2("expression")];
            }
            case "NGMicrosyntaxLet":
              return ["let ", r2("key"), n2.value === null ? "" : [" = ", r2("value")]];
            case "NGMicrosyntaxAs":
              return [r2("key"), " as ", r2("alias")];
            default:
              throw new Me3(n2, "Angular");
          }
      }
      function Ai2({ node: e2, index: t2 }) {
        return e2.type === "NGMicrosyntaxKeyedExpression" && e2.key.name === "of" && t2 === 1;
      }
      var Oc2 = v2(["CallExpression", "OptionalCallExpression", "AssignmentExpression"]);
      function _c({ node: e2 }) {
        return tr2(e2, Oc2);
      }
      function fs(e2, t2, r2) {
        let { node: n2 } = e2;
        return l2([P2(x2, e2.map(r2, "decorators")), hi3(n2, t2) ? F : x2]);
      }
      function di2(e2, t2, r2) {
        return gi(e2.node) ? [P2(F, e2.map(r2, "declaration", "decorators")), F] : "";
      }
      function xi(e2, t2, r2) {
        let { node: n2, parent: s2 } = e2, { decorators: u2 } = n2;
        if (!w2(u2) || gi(s2) || Xr2(e2))
          return "";
        let i2 = n2.type === "ClassExpression" || n2.type === "ClassDeclaration" || hi3(n2, t2);
        return [e2.key === "declaration" && iu2(s2) ? F : i2 ? Ee2 : "", P2(x2, e2.map(r2, "decorators")), x2];
      }
      function hi3(e2, t2) {
        return e2.decorators.some((r2) => te2(t2.originalText, k(r2)));
      }
      function gi(e2) {
        var r2;
        if (e2.type !== "ExportDefaultDeclaration" && e2.type !== "ExportNamedDeclaration" && e2.type !== "DeclareExportDeclaration")
          return false;
        let t2 = (r2 = e2.declaration) == null ? void 0 : r2.decorators;
        return w2(t2) && ht3(e2, t2[0]);
      }
      var Dt2 = class extends Error {
        constructor() {
          super(...arguments);
          __publicField(this, "name", "ArgExpansionBailout");
        }
      };
      function jc2(e2, t2, r2) {
        let { node: n2 } = e2, s2 = oe3(n2);
        if (s2.length === 0)
          return ["(", M3(e2, t2), ")"];
        let u2 = s2.length - 1;
        if (Rc(s2)) {
          let y3 = ["("];
          return Rt2(e2, (C, p2) => {
            y3.push(r2()), p2 !== u2 && y3.push(", ");
          }), y3.push(")"), y3;
        }
        let i2 = false, a2 = [];
        Rt2(e2, ({ node: y3 }, C) => {
          let p2 = r2();
          C === u2 || (pe2(y3, t2) ? (i2 = true, p2 = [p2, ",", F, F]) : p2 = [p2, ",", x2]), a2.push(p2);
        });
        let o2 = n2.type === "ImportExpression" || n2.callee.type === "Import", c2 = !t2.parser.startsWith("__ng_") && !o2 && ae2(t2, "all") ? "," : "";
        function m() {
          return l2(["(", f2([x2, ...a2]), c2, x2, ")"], { shouldBreak: true });
        }
        if (i2 || e2.parent.type !== "Decorator" && lu3(s2))
          return m();
        if (Mc(s2)) {
          let y3 = a2.slice(1);
          if (y3.some(ne3))
            return m();
          let C;
          try {
            C = r2(Jn2(n2, 0), { expandFirstArg: true });
          } catch (p2) {
            if (p2 instanceof Dt2)
              return m();
            throw p2;
          }
          return ne3(C) ? [Ee2, ze2([["(", l2(C, { shouldBreak: true }), ", ", ...y3, ")"], m()])] : ze2([["(", C, ", ", ...y3, ")"], ["(", l2(C, { shouldBreak: true }), ", ", ...y3, ")"], m()]);
        }
        if (vc2(s2, a2, t2)) {
          let y3 = a2.slice(0, -1);
          if (y3.some(ne3))
            return m();
          let C;
          try {
            C = r2(Jn2(n2, -1), { expandLastArg: true });
          } catch (p2) {
            if (p2 instanceof Dt2)
              return m();
            throw p2;
          }
          return ne3(C) ? [Ee2, ze2([["(", ...y3, l2(C, { shouldBreak: true }), ")"], m()])] : ze2([["(", ...y3, C, ")"], ["(", ...y3, l2(C, { shouldBreak: true }), ")"], m()]);
        }
        let D = ["(", f2([E2, ...a2]), b3(c2), E2, ")"];
        return Or2(e2) ? D : l2(D, { shouldBreak: a2.some(ne3) || i2 });
      }
      function cr3(e2, t2 = false) {
        return se2(e2) && (e2.properties.length > 0 || d2(e2)) || U2(e2) && (e2.elements.length > 0 || d2(e2)) || e2.type === "TSTypeAssertion" && cr3(e2.expression) || Te2(e2) && cr3(e2.expression) || e2.type === "FunctionExpression" || e2.type === "ArrowFunctionExpression" && (!e2.returnType || !e2.returnType.typeAnnotation || e2.returnType.typeAnnotation.type !== "TSTypeReference" || Jc(e2.body)) && (e2.body.type === "BlockStatement" || e2.body.type === "ArrowFunctionExpression" && cr3(e2.body, true) || se2(e2.body) || U2(e2.body) || !t2 && (L3(e2.body) || e2.body.type === "ConditionalExpression") || X3(e2.body)) || e2.type === "DoExpression" || e2.type === "ModuleExpression";
      }
      function vc2(e2, t2, r2) {
        var u2, i2;
        let n2 = O2(false, e2, -1);
        if (e2.length === 1) {
          let a2 = O2(false, t2, -1);
          if ((u2 = a2.label) != null && u2.embed && ((i2 = a2.label) == null ? void 0 : i2.hug) !== false)
            return true;
        }
        let s2 = O2(false, e2, -2);
        return !d2(n2, g2.Leading) && !d2(n2, g2.Trailing) && cr3(n2) && (!s2 || s2.type !== n2.type) && (e2.length !== 2 || s2.type !== "ArrowFunctionExpression" || !U2(n2)) && !(e2.length > 1 && Es2(n2, r2));
      }
      function Mc(e2) {
        if (e2.length !== 2)
          return false;
        let [t2, r2] = e2;
        return t2.type === "ModuleExpression" && qc(r2) ? true : !d2(t2) && (t2.type === "FunctionExpression" || t2.type === "ArrowFunctionExpression" && t2.body.type === "BlockStatement") && r2.type !== "FunctionExpression" && r2.type !== "ArrowFunctionExpression" && r2.type !== "ConditionalExpression" && Bi2(r2) && !cr3(r2);
      }
      function Bi2(e2) {
        if (e2.type === "ParenthesizedExpression")
          return Bi2(e2.expression);
        if (Te2(e2) || e2.type === "TypeCastExpression") {
          let { typeAnnotation: t2 } = e2;
          if (t2.type === "TypeAnnotation" && (t2 = t2.typeAnnotation), t2.type === "TSArrayType" && (t2 = t2.elementType, t2.type === "TSArrayType" && (t2 = t2.elementType)), t2.type === "GenericTypeAnnotation" || t2.type === "TSTypeReference") {
            let r2 = t2.typeArguments ?? t2.typeParameters;
            (r2 == null ? void 0 : r2.params.length) === 1 && (t2 = r2.params[0]);
          }
          return Mt2(t2) && be3(e2.expression, 1);
        }
        return lt3(e2) && oe3(e2).length > 1 ? false : De3(e2) ? be3(e2.left, 1) && be3(e2.right, 1) : Mn2(e2) || be3(e2);
      }
      function Rc(e2) {
        return e2.length === 2 ? Si2(e2, 0) : e2.length === 3 ? e2[0].type === "Identifier" && Si2(e2, 1) : false;
      }
      function Si2(e2, t2) {
        let r2 = e2[t2], n2 = e2[t2 + 1];
        return r2.type === "ArrowFunctionExpression" && K2(r2).length === 0 && r2.body.type === "BlockStatement" && n2.type === "ArrayExpression" && !e2.some((s2) => d2(s2));
      }
      function Jc(e2) {
        return e2.type === "BlockStatement" && (e2.body.some((t2) => t2.type !== "EmptyStatement") || d2(e2, g2.Dangling));
      }
      function qc(e2) {
        return e2.type === "ObjectExpression" && e2.properties.length === 1 && Ae3(e2.properties[0]) && e2.properties[0].key.type === "Identifier" && e2.properties[0].key.name === "type" && Q3(e2.properties[0].value) && e2.properties[0].value.value === "module";
      }
      var lr3 = jc2;
      var Wc2 = (e2) => ((e2.type === "ChainExpression" || e2.type === "TSNonNullExpression") && (e2 = e2.expression), L3(e2) && oe3(e2).length > 0);
      function bi(e2, t2, r2) {
        var c2;
        let n2 = r2("object"), s2 = Fs2(e2, t2, r2), { node: u2 } = e2, i2 = e2.findAncestor((m) => !(q2(m) || m.type === "TSNonNullExpression")), a2 = e2.findAncestor((m) => !(m.type === "ChainExpression" || m.type === "TSNonNullExpression")), o2 = i2 && (i2.type === "NewExpression" || i2.type === "BindExpression" || i2.type === "AssignmentExpression" && i2.left.type !== "Identifier") || u2.computed || u2.object.type === "Identifier" && u2.property.type === "Identifier" && !q2(a2) || (a2.type === "AssignmentExpression" || a2.type === "VariableDeclarator") && (Wc2(u2.object) || ((c2 = n2.label) == null ? void 0 : c2.memberChain));
        return it3(n2.label, [n2, o2 ? s2 : l2(f2([E2, s2]))]);
      }
      function Fs2(e2, t2, r2) {
        let n2 = r2("property"), { node: s2 } = e2, u2 = V2(e2);
        return s2.computed ? !s2.property || Ce3(s2.property) ? [u2, "[", n2, "]"] : l2([u2, "[", f2([E2, n2]), E2, "]"]) : [u2, ".", n2];
      }
      function Pi(e2, t2, r2) {
        if (e2.node.type === "ChainExpression")
          return e2.call(() => Pi(e2, t2, r2), "expression");
        let { parent: n2 } = e2, s2 = !n2 || n2.type === "ExpressionStatement", u2 = [];
        function i2(I2) {
          let { originalText: G3 } = t2, ee3 = yt2(G3, k(I2));
          return G3.charAt(ee3) === ")" ? ee3 !== false && Ot2(G3, ee3 + 1) : pe2(I2, t2);
        }
        function a2(I2) {
          let { node: G3 } = I2;
          if (G3.type === "ChainExpression")
            return I2.call(() => a2(I2), "expression");
          if (L3(G3) && (Ft3(G3.callee) || L3(G3.callee))) {
            let ee3 = i2(G3);
            u2.unshift({ node: G3, hasTrailingEmptyLine: ee3, printed: [ye(I2, [V2(I2), Qe3(I2, t2, r2), lr3(I2, t2, r2)], t2), ee3 ? F : ""] }), I2.call((qe2) => a2(qe2), "callee");
          } else
            Ft3(G3) ? (u2.unshift({ node: G3, needsParens: Be3(I2, t2), printed: ye(I2, q2(G3) ? Fs2(I2, t2, r2) : Hr3(I2, t2, r2), t2) }), I2.call((ee3) => a2(ee3), "object")) : G3.type === "TSNonNullExpression" ? (u2.unshift({ node: G3, printed: ye(I2, "!", t2) }), I2.call((ee3) => a2(ee3), "expression")) : u2.unshift({ node: G3, printed: r2() });
        }
        let { node: o2 } = e2;
        u2.unshift({ node: o2, printed: [V2(e2), Qe3(e2, t2, r2), lr3(e2, t2, r2)] }), o2.callee && e2.call((I2) => a2(I2), "callee");
        let c2 = [], m = [u2[0]], D = 1;
        for (; D < u2.length && (u2[D].node.type === "TSNonNullExpression" || L3(u2[D].node) || q2(u2[D].node) && u2[D].node.computed && Ce3(u2[D].node.property)); ++D)
          m.push(u2[D]);
        if (!L3(u2[0].node))
          for (; D + 1 < u2.length && (Ft3(u2[D].node) && Ft3(u2[D + 1].node)); ++D)
            m.push(u2[D]);
        c2.push(m), m = [];
        let y3 = false;
        for (; D < u2.length; ++D) {
          if (y3 && Ft3(u2[D].node)) {
            if (u2[D].node.computed && Ce3(u2[D].node.property)) {
              m.push(u2[D]);
              continue;
            }
            c2.push(m), m = [], y3 = false;
          }
          (L3(u2[D].node) || u2[D].node.type === "ImportExpression") && (y3 = true), m.push(u2[D]), d2(u2[D].node, g2.Trailing) && (c2.push(m), m = [], y3 = false);
        }
        m.length > 0 && c2.push(m);
        function C(I2) {
          return /^[A-Z]|^[$_]+$/u.test(I2);
        }
        function p2(I2) {
          return I2.length <= t2.tabWidth;
        }
        function A(I2) {
          var qe2;
          let G3 = (qe2 = I2[1][0]) == null ? void 0 : qe2.node.computed;
          if (I2[0].length === 1) {
            let xt3 = I2[0][0].node;
            return xt3.type === "ThisExpression" || xt3.type === "Identifier" && (C(xt3.name) || s2 && p2(xt3.name) || G3);
          }
          let ee3 = O2(false, I2[0], -1).node;
          return q2(ee3) && ee3.property.type === "Identifier" && (C(ee3.property.name) || G3);
        }
        let T3 = c2.length >= 2 && !d2(c2[1][0].node) && A(c2);
        function S3(I2) {
          let G3 = I2.map((ee3) => ee3.printed);
          return I2.length > 0 && O2(false, I2, -1).needsParens ? ["(", ...G3, ")"] : G3;
        }
        function B2(I2) {
          return I2.length === 0 ? "" : f2([F, P2(F, I2.map(S3))]);
        }
        let _3 = c2.map(S3), J3 = _3, j2 = T3 ? 3 : 2, h2 = c2.flat(), W2 = h2.slice(1, -1).some((I2) => d2(I2.node, g2.Leading)) || h2.slice(0, -1).some((I2) => d2(I2.node, g2.Trailing)) || c2[j2] && d2(c2[j2][0].node, g2.Leading);
        if (c2.length <= j2 && !W2 && !c2.some((I2) => O2(false, I2, -1).hasTrailingEmptyLine))
          return Or2(e2) ? J3 : l2(J3);
        let Fe3 = O2(false, c2[T3 ? 1 : 0], -1).node, H3 = !L3(Fe3) && i2(Fe3), ue2 = [S3(c2[0]), T3 ? c2.slice(1, 2).map(S3) : "", H3 ? F : "", B2(c2.slice(T3 ? 2 : 1))], Z3 = u2.map(({ node: I2 }) => I2).filter(L3);
        function It2() {
          let I2 = O2(false, O2(false, c2, -1), -1).node, G3 = O2(false, _3, -1);
          return L3(I2) && ne3(G3) && Z3.slice(0, -1).some((ee3) => ee3.arguments.some(_t2));
        }
        let $t2;
        return W2 || Z3.length > 2 && Z3.some((I2) => !I2.arguments.every((G3) => be3(G3))) || _3.slice(0, -1).some(ne3) || It2() ? $t2 = l2(ue2) : $t2 = [ne3(J3) || H3 ? Ee2 : "", ze2([J3, ue2])], it3({ memberChain: true }, $t2);
      }
      var ki = Pi;
      function Vr2(e2, t2, r2) {
        var m;
        let { node: n2 } = e2, s2 = n2.type === "NewExpression", u2 = n2.type === "ImportExpression", i2 = V2(e2), a2 = oe3(n2), o2 = a2.length === 1 && Lr3(a2[0], t2.originalText);
        if (o2 || Gc2(e2) || St3(n2, e2.parent)) {
          let D = [];
          if (Rt2(e2, () => {
            D.push(r2());
          }), !(o2 && ((m = D[0].label) != null && m.embed)))
            return [s2 ? "new " : "", Ii2(e2, r2), i2, Qe3(e2, t2, r2), "(", P2(", ", D), ")"];
        }
        if (!u2 && !s2 && Ft3(n2.callee) && !e2.call((D) => Be3(D, t2), "callee", ...n2.callee.type === "ChainExpression" ? ["expression"] : []))
          return ki(e2, t2, r2);
        let c2 = [s2 ? "new " : "", Ii2(e2, r2), i2, Qe3(e2, t2, r2), lr3(e2, t2, r2)];
        return u2 || L3(n2.callee) ? l2(c2) : c2;
      }
      function Ii2(e2, t2) {
        let { node: r2 } = e2;
        return r2.type === "ImportExpression" ? `import${r2.phase ? `.${r2.phase}` : ""}` : t2("callee");
      }
      function Gc2(e2) {
        let { node: t2 } = e2;
        if (t2.type !== "CallExpression" || t2.optional || t2.callee.type !== "Identifier")
          return false;
        let r2 = oe3(t2);
        return t2.callee.name === "require" ? r2.length === 1 && Q3(r2[0]) || r2.length > 1 : t2.callee.name === "define" && e2.parent.type === "ExpressionStatement" ? r2.length === 1 || r2.length === 2 && r2[0].type === "ArrayExpression" || r2.length === 3 && Q3(r2[0]) && r2[1].type === "ArrayExpression" : false;
      }
      function Tt2(e2, t2, r2, n2, s2, u2) {
        let i2 = Uc(e2, t2, r2, n2, u2), a2 = u2 ? r2(u2, { assignmentLayout: i2 }) : "";
        switch (i2) {
          case "break-after-operator":
            return l2([l2(n2), s2, l2(f2([x2, a2]))]);
          case "never-break-after-operator":
            return l2([l2(n2), s2, " ", a2]);
          case "fluid": {
            let o2 = Symbol("assignment");
            return l2([l2(n2), s2, l2(f2(x2), { id: o2 }), ke3, At3(a2, { groupId: o2 })]);
          }
          case "break-lhs":
            return l2([n2, s2, " ", l2(a2)]);
          case "chain":
            return [l2(n2), s2, x2, a2];
          case "chain-tail":
            return [l2(n2), s2, f2([x2, a2])];
          case "chain-tail-arrow-chain":
            return [l2(n2), s2, a2];
          case "only-left":
            return n2;
        }
      }
      function wi(e2, t2, r2) {
        let { node: n2 } = e2;
        return Tt2(e2, t2, r2, r2("left"), [" ", n2.operator], "right");
      }
      function Oi2(e2, t2, r2) {
        return Tt2(e2, t2, r2, r2("id"), " =", "init");
      }
      function Uc(e2, t2, r2, n2, s2) {
        let { node: u2 } = e2, i2 = u2[s2];
        if (!i2)
          return "only-left";
        let a2 = !$r3(i2);
        if (e2.match($r3, _i, (y3) => !a2 || y3.type !== "ExpressionStatement" && y3.type !== "VariableDeclaration"))
          return a2 ? i2.type === "ArrowFunctionExpression" && i2.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
        if (!a2 && $r3(i2.right) || Oe3(t2.originalText, i2))
          return "break-after-operator";
        if (u2.type === "ImportAttribute" || i2.type === "CallExpression" && i2.callee.name === "require" || t2.parser === "json5" || t2.parser === "jsonc" || t2.parser === "json")
          return "never-break-after-operator";
        let m = Bu3(n2);
        if (Xc(u2) || $c2(u2) || Cs2(u2) && m)
          return "break-lhs";
        let D = zc(u2, n2, t2);
        return e2.call(() => Nc(e2, t2, r2, D), s2) ? "break-after-operator" : Yc(u2) ? "break-lhs" : !m && (D || i2.type === "TemplateLiteral" || i2.type === "TaggedTemplateExpression" || i2.type === "BooleanLiteral" || Ce3(i2) || i2.type === "ClassExpression") ? "never-break-after-operator" : "fluid";
      }
      function Nc(e2, t2, r2, n2) {
        let s2 = e2.node;
        if (De3(s2) && !Ut2(s2))
          return true;
        switch (s2.type) {
          case "StringLiteralTypeAnnotation":
          case "SequenceExpression":
            return true;
          case "TSConditionalType":
          case "ConditionalTypeAnnotation":
            if (!t2.experimentalTernaries && !el2(s2))
              break;
            return true;
          case "ConditionalExpression": {
            if (!t2.experimentalTernaries) {
              let { test: c2 } = s2;
              return De3(c2) && !Ut2(c2);
            }
            let { consequent: a2, alternate: o2 } = s2;
            return a2.type === "ConditionalExpression" || o2.type === "ConditionalExpression";
          }
          case "ClassExpression":
            return w2(s2.decorators);
        }
        if (n2)
          return false;
        let u2 = s2, i2 = [];
        for (; ; )
          if (u2.type === "UnaryExpression" || u2.type === "AwaitExpression" || u2.type === "YieldExpression" && u2.argument !== null)
            u2 = u2.argument, i2.push("argument");
          else if (u2.type === "TSNonNullExpression")
            u2 = u2.expression, i2.push("expression");
          else
            break;
        return !!(Q3(u2) || e2.call(() => ji(e2, t2, r2), ...i2));
      }
      function Xc(e2) {
        if (_i(e2)) {
          let t2 = e2.left || e2.id;
          return t2.type === "ObjectPattern" && t2.properties.length > 2 && t2.properties.some((r2) => {
            var n2;
            return Ae3(r2) && (!r2.shorthand || ((n2 = r2.value) == null ? void 0 : n2.type) === "AssignmentPattern");
          });
        }
        return false;
      }
      function $r3(e2) {
        return e2.type === "AssignmentExpression";
      }
      function _i(e2) {
        return $r3(e2) || e2.type === "VariableDeclarator";
      }
      function Yc(e2) {
        let t2 = Vc(e2);
        if (w2(t2)) {
          let r2 = e2.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
          if (t2.length > 1 && t2.some((n2) => n2[r2] || n2.default))
            return true;
        }
        return false;
      }
      var Hc2 = v2(["TSTypeAliasDeclaration", "TypeAlias"]);
      function Vc(e2) {
        var t2;
        if (Hc2(e2))
          return (t2 = e2.typeParameters) == null ? void 0 : t2.params;
      }
      function $c2(e2) {
        if (e2.type !== "VariableDeclarator")
          return false;
        let { typeAnnotation: t2 } = e2.id;
        if (!t2 || !t2.typeAnnotation)
          return false;
        let r2 = Li2(t2.typeAnnotation);
        return w2(r2) && r2.length > 1 && r2.some((n2) => w2(Li2(n2)) || n2.type === "TSConditionalType");
      }
      function Cs2(e2) {
        var t2;
        return e2.type === "VariableDeclarator" && ((t2 = e2.init) == null ? void 0 : t2.type) === "ArrowFunctionExpression";
      }
      var Kc = v2(["TSTypeReference", "GenericTypeAnnotation"]);
      function Li2(e2) {
        var t2;
        if (Kc(e2))
          return (t2 = e2.typeArguments ?? e2.typeParameters) == null ? void 0 : t2.params;
      }
      function ji(e2, t2, r2, n2 = false) {
        var i2;
        let { node: s2 } = e2, u2 = () => ji(e2, t2, r2, true);
        if (s2.type === "ChainExpression" || s2.type === "TSNonNullExpression")
          return e2.call(u2, "expression");
        if (L3(s2)) {
          if ((i2 = Vr2(e2, t2, r2).label) != null && i2.memberChain)
            return false;
          let o2 = oe3(s2);
          return !(o2.length === 0 || o2.length === 1 && rr2(o2[0], t2)) || Qc(s2, r2) ? false : e2.call(u2, "callee");
        }
        return q2(s2) ? e2.call(u2, "object") : n2 && (s2.type === "Identifier" || s2.type === "ThisExpression");
      }
      function zc(e2, t2, r2) {
        return Ae3(e2) ? (t2 = Wt2(t2), typeof t2 == "string" && et2(t2) < r2.tabWidth + 3) : false;
      }
      function Qc(e2, t2) {
        let r2 = Zc(e2);
        if (w2(r2)) {
          if (r2.length > 1)
            return true;
          if (r2.length === 1) {
            let s2 = r2[0];
            if (Ne2(s2) || _r3(s2) || s2.type === "TSTypeLiteral" || s2.type === "ObjectTypeAnnotation")
              return true;
          }
          let n2 = e2.typeParameters ? "typeParameters" : "typeArguments";
          if (ne3(t2(n2)))
            return true;
        }
        return false;
      }
      function Zc(e2) {
        var t2;
        return (t2 = e2.typeParameters ?? e2.typeArguments) == null ? void 0 : t2.params;
      }
      function el2(e2) {
        function t2(r2) {
          switch (r2.type) {
            case "FunctionTypeAnnotation":
            case "GenericTypeAnnotation":
            case "TSFunctionType":
              return !!r2.typeParameters;
            case "TSTypeReference":
              return !!(r2.typeArguments ?? r2.typeParameters);
            default:
              return false;
          }
        }
        return t2(e2.checkType) || t2(e2.extendsType);
      }
      function Je2(e2, t2, r2, n2, s2) {
        let u2 = e2.node, i2 = K2(u2), a2 = s2 ? Qe3(e2, r2, t2) : "";
        if (i2.length === 0)
          return [a2, "(", M3(e2, r2, { filter: (p2) => ge2(r2.originalText, k(p2)) === ")" }), ")"];
        let { parent: o2 } = e2, c2 = St3(o2), m = As2(u2), D = [];
        if (fu2(e2, (p2, A) => {
          let T3 = A === i2.length - 1;
          T3 && u2.rest && D.push("..."), D.push(t2()), !T3 && (D.push(","), c2 || m ? D.push(" ") : pe2(i2[A], r2) ? D.push(F, F) : D.push(x2));
        }), n2 && !rl2(e2)) {
          if (ne3(a2) || ne3(D))
            throw new Dt2();
          return l2([ur3(a2), "(", ur3(D), ")"]);
        }
        let y3 = i2.every((p2) => !w2(p2.decorators));
        return m && y3 ? [a2, "(", ...D, ")"] : c2 ? [a2, "(", ...D, ")"] : (Ir2(o2) || ou3(o2) || o2.type === "TypeAlias" || o2.type === "UnionTypeAnnotation" || o2.type === "IntersectionTypeAnnotation" || o2.type === "FunctionTypeAnnotation" && o2.returnType === u2) && i2.length === 1 && i2[0].name === null && u2.this !== i2[0] && i2[0].typeAnnotation && u2.typeParameters === null && Mt2(i2[0].typeAnnotation) && !u2.rest ? r2.arrowParens === "always" || u2.type === "HookTypeAnnotation" ? ["(", ...D, ")"] : D : [a2, "(", f2([E2, ...D]), b3(!Du2(u2) && ae2(r2, "all") ? "," : ""), E2, ")"];
      }
      function As2(e2) {
        if (!e2)
          return false;
        let t2 = K2(e2);
        if (t2.length !== 1)
          return false;
        let [r2] = t2;
        return !d2(r2) && (r2.type === "ObjectPattern" || r2.type === "ArrayPattern" || r2.type === "Identifier" && r2.typeAnnotation && (r2.typeAnnotation.type === "TypeAnnotation" || r2.typeAnnotation.type === "TSTypeAnnotation") && we3(r2.typeAnnotation.typeAnnotation) || r2.type === "FunctionTypeParam" && we3(r2.typeAnnotation) && r2 !== e2.rest || r2.type === "AssignmentPattern" && (r2.left.type === "ObjectPattern" || r2.left.type === "ArrayPattern") && (r2.right.type === "Identifier" || se2(r2.right) && r2.right.properties.length === 0 || U2(r2.right) && r2.right.elements.length === 0));
      }
      function tl(e2) {
        let t2;
        return e2.returnType ? (t2 = e2.returnType, t2.typeAnnotation && (t2 = t2.typeAnnotation)) : e2.typeAnnotation && (t2 = e2.typeAnnotation), t2;
      }
      function ot3(e2, t2) {
        var s2;
        let r2 = tl(e2);
        if (!r2)
          return false;
        let n2 = (s2 = e2.typeParameters) == null ? void 0 : s2.params;
        if (n2) {
          if (n2.length > 1)
            return false;
          if (n2.length === 1) {
            let u2 = n2[0];
            if (u2.constraint || u2.default)
              return false;
          }
        }
        return K2(e2).length === 1 && (we3(r2) || ne3(t2));
      }
      function rl2(e2) {
        return e2.match((t2) => t2.type === "ArrowFunctionExpression" && t2.body.type === "BlockStatement", (t2, r2) => {
          if (t2.type === "CallExpression" && r2 === "arguments" && t2.arguments.length === 1 && t2.callee.type === "CallExpression") {
            let n2 = t2.callee.callee;
            return n2.type === "Identifier" || n2.type === "MemberExpression" && !n2.computed && n2.object.type === "Identifier" && n2.property.type === "Identifier";
          }
          return false;
        }, (t2, r2) => t2.type === "VariableDeclarator" && r2 === "init" || t2.type === "ExportDefaultDeclaration" && r2 === "declaration" || t2.type === "TSExportAssignment" && r2 === "expression" || t2.type === "AssignmentExpression" && r2 === "right" && t2.left.type === "MemberExpression" && t2.left.object.type === "Identifier" && t2.left.object.name === "module" && t2.left.property.type === "Identifier" && t2.left.property.name === "exports", (t2) => t2.type !== "VariableDeclaration" || t2.kind === "const" && t2.declarations.length === 1);
      }
      function vi2(e2) {
        let t2 = K2(e2);
        return t2.length > 1 && t2.some((r2) => r2.type === "TSParameterProperty");
      }
      var nl = v2(["VoidTypeAnnotation", "TSVoidKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword"]), sl = v2(["ObjectTypeAnnotation", "TSTypeLiteral", "GenericTypeAnnotation", "TSTypeReference"]);
      function ul(e2) {
        let { types: t2 } = e2;
        if (t2.some((n2) => d2(n2)))
          return false;
        let r2 = t2.find((n2) => sl(n2));
        return r2 ? t2.every((n2) => n2 === r2 || nl(n2)) : false;
      }
      function Ts2(e2) {
        return Mt2(e2) || we3(e2) ? true : Ne2(e2) ? ul(e2) : false;
      }
      function Mi2(e2, t2, r2) {
        let n2 = t2.semi ? ";" : "", { node: s2 } = e2, u2 = [$2(e2), "opaque type ", r2("id"), r2("typeParameters")];
        return s2.supertype && u2.push(": ", r2("supertype")), s2.impltype && u2.push(" = ", r2("impltype")), u2.push(n2), u2;
      }
      function Kr2(e2, t2, r2) {
        let n2 = t2.semi ? ";" : "", { node: s2 } = e2, u2 = [$2(e2)];
        u2.push("type ", r2("id"), r2("typeParameters"));
        let i2 = s2.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
        return [Tt2(e2, t2, r2, u2, " =", i2), n2];
      }
      function zr2(e2, t2, r2) {
        let n2 = false;
        return l2(e2.map(({ isFirst: s2, previous: u2, node: i2, index: a2 }) => {
          let o2 = r2();
          if (s2)
            return o2;
          let c2 = we3(i2), m = we3(u2);
          return m && c2 ? [" & ", n2 ? f2(o2) : o2] : !m && !c2 ? f2([" &", x2, o2]) : (a2 > 1 && (n2 = true), [" & ", a2 > 1 ? f2(o2) : o2]);
        }, "types"));
      }
      function Qr2(e2, t2, r2) {
        let { node: n2 } = e2, { parent: s2 } = e2, u2 = s2.type !== "TypeParameterInstantiation" && (s2.type !== "TSConditionalType" || !t2.experimentalTernaries) && (s2.type !== "ConditionalTypeAnnotation" || !t2.experimentalTernaries) && s2.type !== "TSTypeParameterInstantiation" && s2.type !== "GenericTypeAnnotation" && s2.type !== "TSTypeReference" && s2.type !== "TSTypeAssertion" && s2.type !== "TupleTypeAnnotation" && s2.type !== "TSTupleType" && !(s2.type === "FunctionTypeParam" && !s2.name && e2.grandparent.this !== s2) && !((s2.type === "TypeAlias" || s2.type === "VariableDeclarator" || s2.type === "TSTypeAliasDeclaration") && Oe3(t2.originalText, n2)), i2 = Ts2(n2), a2 = e2.map((m) => {
          let D = r2();
          return i2 || (D = he3(2, D)), ye(m, D, t2);
        }, "types");
        if (i2)
          return P2(" | ", a2);
        let o2 = u2 && !Oe3(t2.originalText, n2), c2 = [b3([o2 ? x2 : "", "| "]), P2([x2, "| "], a2)];
        return Be3(e2, t2) ? l2([f2(c2), E2]) : (s2.type === "TupleTypeAnnotation" || s2.type === "TSTupleType") && s2[s2.type === "TupleTypeAnnotation" && s2.types ? "types" : "elementTypes"].length > 1 ? l2([f2([b3(["(", E2]), c2]), E2, b3(")")]) : l2(u2 ? f2(c2) : c2);
      }
      function il(e2) {
        var n2;
        let { node: t2, parent: r2 } = e2;
        return t2.type === "FunctionTypeAnnotation" && (Ir2(r2) || !((r2.type === "ObjectTypeProperty" || r2.type === "ObjectTypeInternalSlot") && !r2.variance && !r2.optional && ht3(r2, t2) || r2.type === "ObjectTypeCallProperty" || ((n2 = e2.getParentNode(2)) == null ? void 0 : n2.type) === "DeclareFunction"));
      }
      function Zr2(e2, t2, r2) {
        let { node: n2 } = e2, s2 = [Nt2(e2)];
        (n2.type === "TSConstructorType" || n2.type === "TSConstructSignatureDeclaration") && s2.push("new ");
        let u2 = Je2(e2, r2, t2, false, true), i2 = [];
        return n2.type === "FunctionTypeAnnotation" ? i2.push(il(e2) ? " => " : ": ", r2("returnType")) : i2.push(Y2(e2, r2, n2.returnType ? "returnType" : "typeAnnotation")), ot3(n2, i2) && (u2 = l2(u2)), s2.push(u2, i2), l2(s2);
      }
      function en3(e2, t2, r2) {
        return [r2("objectType"), V2(e2), "[", r2("indexType"), "]"];
      }
      function tn3(e2, t2, r2) {
        return ["infer ", r2("typeParameter")];
      }
      function ds(e2, t2, r2) {
        let { node: n2 } = e2;
        return [n2.postfix ? "" : r2, Y2(e2, t2), n2.postfix ? r2 : ""];
      }
      function rn3(e2, t2, r2) {
        let { node: n2 } = e2;
        return ["...", ...n2.type === "TupleTypeSpreadElement" && n2.label ? [r2("label"), ": "] : [], r2("typeAnnotation")];
      }
      function nn3(e2, t2, r2) {
        let { node: n2 } = e2;
        return [n2.variance ? r2("variance") : "", r2("label"), n2.optional ? "?" : "", ": ", r2("elementType")];
      }
      var al = /* @__PURE__ */ new WeakSet();
      function Y2(e2, t2, r2 = "typeAnnotation") {
        let { node: { [r2]: n2 } } = e2;
        if (!n2)
          return "";
        let s2 = false;
        if (n2.type === "TSTypeAnnotation" || n2.type === "TypeAnnotation") {
          let u2 = e2.call(Ri, r2);
          (u2 === "=>" || u2 === ":" && d2(n2, g2.Leading)) && (s2 = true), al.add(n2);
        }
        return s2 ? [" ", t2(r2)] : t2(r2);
      }
      var Ri = (e2) => e2.match((t2) => t2.type === "TSTypeAnnotation", (t2, r2) => (r2 === "returnType" || r2 === "typeAnnotation") && (t2.type === "TSFunctionType" || t2.type === "TSConstructorType")) ? "=>" : e2.match((t2) => t2.type === "TSTypeAnnotation", (t2, r2) => r2 === "typeAnnotation" && (t2.type === "TSJSDocNullableType" || t2.type === "TSJSDocNonNullableType" || t2.type === "TSTypePredicate")) || e2.match((t2) => t2.type === "TypeAnnotation", (t2, r2) => r2 === "typeAnnotation" && t2.type === "Identifier", (t2, r2) => r2 === "id" && t2.type === "DeclareFunction") || e2.match((t2) => t2.type === "TypeAnnotation", (t2, r2) => r2 === "typeAnnotation" && t2.type === "Identifier", (t2, r2) => r2 === "id" && t2.type === "DeclareHook") || e2.match((t2) => t2.type === "TypeAnnotation", (t2, r2) => r2 === "bound" && t2.type === "TypeParameter" && t2.usesExtendsBound) ? "" : ":";
      function sn2(e2, t2, r2) {
        let n2 = Ri(e2);
        return n2 ? [n2, " ", r2("typeAnnotation")] : r2("typeAnnotation");
      }
      function un3(e2) {
        return [e2("elementType"), "[]"];
      }
      function an3({ node: e2 }, t2) {
        let r2 = e2.type === "TSTypeQuery" ? "exprName" : "argument", n2 = e2.type === "TypeofTypeAnnotation" || e2.typeArguments ? "typeArguments" : "typeParameters";
        return ["typeof ", t2(r2), t2(n2)];
      }
      function on2(e2, t2) {
        let { node: r2 } = e2;
        return [r2.type === "TSTypePredicate" && r2.asserts ? "asserts " : r2.type === "TypePredicate" && r2.kind ? `${r2.kind} ` : "", t2("parameterName"), r2.typeAnnotation ? [" is ", Y2(e2, t2)] : ""];
      }
      function V2(e2) {
        let { node: t2 } = e2;
        return !t2.optional || t2.type === "Identifier" && t2 === e2.parent.key ? "" : L3(t2) || q2(t2) && t2.computed || t2.type === "OptionalIndexedAccessType" ? "?." : "?";
      }
      function pn3(e2) {
        return e2.node.definite || e2.match(void 0, (t2, r2) => r2 === "id" && t2.type === "VariableDeclarator" && t2.definite) ? "!" : "";
      }
      var ol = /* @__PURE__ */ new Set(["DeclareClass", "DeclareComponent", "DeclareFunction", "DeclareHook", "DeclareVariable", "DeclareExportDeclaration", "DeclareExportAllDeclaration", "DeclareOpaqueType", "DeclareTypeAlias", "DeclareEnum", "DeclareInterface"]);
      function $2(e2) {
        let { node: t2 } = e2;
        return t2.declare || ol.has(t2.type) && e2.parent.type !== "DeclareExportDeclaration" ? "declare " : "";
      }
      var pl2 = /* @__PURE__ */ new Set(["TSAbstractMethodDefinition", "TSAbstractPropertyDefinition", "TSAbstractAccessorProperty"]);
      function Nt2({ node: e2 }) {
        return e2.abstract || pl2.has(e2.type) ? "abstract " : "";
      }
      function Qe3(e2, t2, r2) {
        let n2 = e2.node;
        return n2.typeArguments ? r2("typeArguments") : n2.typeParameters ? r2("typeParameters") : "";
      }
      function Hr3(e2, t2, r2) {
        return ["::", r2("callee")];
      }
      function ft2(e2, t2, r2) {
        return e2.type === "EmptyStatement" ? ";" : e2.type === "BlockStatement" || r2 ? [" ", t2] : f2([x2, t2]);
      }
      function cn3(e2, t2) {
        return ["...", t2("argument"), Y2(e2, t2)];
      }
      function Xt(e2) {
        return e2.accessibility ? e2.accessibility + " " : "";
      }
      function cl(e2, t2, r2, n2) {
        let { node: s2 } = e2, u2 = s2.inexact ? "..." : "";
        return d2(s2, g2.Dangling) ? l2([r2, u2, M3(e2, t2, { indent: true }), E2, n2]) : [r2, u2, n2];
      }
      function Yt2(e2, t2, r2) {
        let { node: n2 } = e2, s2 = [], u2 = n2.type === "TupleExpression" ? "#[" : "[", i2 = "]", a2 = n2.type === "TupleTypeAnnotation" && n2.types ? "types" : n2.type === "TSTupleType" || n2.type === "TupleTypeAnnotation" ? "elementTypes" : "elements", o2 = n2[a2];
        if (o2.length === 0)
          s2.push(cl(e2, t2, u2, i2));
        else {
          let c2 = O2(false, o2, -1), m = (c2 == null ? void 0 : c2.type) !== "RestElement" && !n2.inexact, D = c2 === null, y3 = Symbol("array"), C = !t2.__inJestEach && o2.length > 1 && o2.every((T3, S3, B2) => {
            let _3 = T3 == null ? void 0 : T3.type;
            if (!U2(T3) && !se2(T3))
              return false;
            let J3 = B2[S3 + 1];
            if (J3 && _3 !== J3.type)
              return false;
            let j2 = U2(T3) ? "elements" : "properties";
            return T3[j2] && T3[j2].length > 1;
          }), p2 = Es2(n2, t2), A = m ? D ? "," : ae2(t2) ? p2 ? b3(",", "", { groupId: y3 }) : b3(",") : "" : "";
          s2.push(l2([u2, f2([E2, p2 ? ml(e2, t2, r2, A) : [ll(e2, t2, a2, n2.inexact, r2), A], M3(e2, t2)]), E2, i2], { shouldBreak: C, id: y3 }));
        }
        return s2.push(V2(e2), Y2(e2, r2)), s2;
      }
      function Es2(e2, t2) {
        return U2(e2) && e2.elements.length > 1 && e2.elements.every((r2) => r2 && (Ce3(r2) || vn3(r2) && !d2(r2.argument)) && !d2(r2, g2.Trailing | g2.Line, (n2) => !te2(t2.originalText, R3(n2), { backwards: true })));
      }
      function Ji({ node: e2 }, { originalText: t2 }) {
        let r2 = (s2) => Lt2(t2, wt3(t2, s2)), n2 = (s2) => t2[s2] === "," ? s2 : n2(r2(s2 + 1));
        return Ot2(t2, n2(k(e2)));
      }
      function ll(e2, t2, r2, n2, s2) {
        let u2 = [];
        return e2.each(({ node: i2, isLast: a2 }) => {
          u2.push(i2 ? l2(s2()) : ""), (!a2 || n2) && u2.push([",", x2, i2 && Ji(e2, t2) ? E2 : ""]);
        }, r2), n2 && u2.push("..."), u2;
      }
      function ml(e2, t2, r2, n2) {
        let s2 = [];
        return e2.each(({ isLast: u2, next: i2 }) => {
          s2.push([r2(), u2 ? n2 : ","]), u2 || s2.push(Ji(e2, t2) ? [F, F] : d2(i2, g2.Leading | g2.Line) ? F : x2);
        }, "elements"), qt2(s2);
      }
      var qi2 = new Proxy(() => {
      }, { get: () => qi2 }), ln3 = qi2;
      var yl = /^[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC][\$0-9A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]*$/, Dl = (e2) => yl.test(e2), Wi = Dl;
      function fl(e2) {
        return e2.length === 1 ? e2 : e2.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(?=\d)/u, "$1$2").replace(/^([+-]?[\d.]+)e[+-]?0+$/u, "$1").replace(/^([+-])?\./u, "$10.").replace(/(\.\d+?)0+(?=e|$)/u, "$1").replace(/\.(?=e|$)/u, "");
      }
      var Ze2 = fl;
      var mn3 = /* @__PURE__ */ new WeakMap();
      function Ui(e2) {
        return /^(?:\d+|\d+\.\d+)$/u.test(e2);
      }
      function Gi(e2, t2) {
        return t2.parser === "json" || t2.parser === "jsonc" || !Q3(e2.key) || tt2(fe2(e2.key), t2).slice(1, -1) !== e2.key.value ? false : !!(Wi(e2.key.value) && !(t2.parser === "babel-ts" && e2.type === "ClassProperty" || t2.parser === "typescript" && e2.type === "PropertyDefinition") || Ui(e2.key.value) && String(Number(e2.key.value)) === e2.key.value && e2.type !== "ImportAttribute" && (t2.parser === "babel" || t2.parser === "acorn" || t2.parser === "espree" || t2.parser === "meriyah" || t2.parser === "__babel_estree"));
      }
      function El(e2, t2) {
        let { key: r2 } = e2.node;
        return (r2.type === "Identifier" || Ce3(r2) && Ui(Ze2(fe2(r2))) && String(r2.value) === Ze2(fe2(r2)) && !(t2.parser === "typescript" || t2.parser === "babel-ts")) && (t2.parser === "json" || t2.parser === "jsonc" || t2.quoteProps === "consistent" && mn3.get(e2.parent));
      }
      function Et3(e2, t2, r2) {
        let { node: n2 } = e2;
        if (n2.computed)
          return ["[", r2("key"), "]"];
        let { parent: s2 } = e2, { key: u2 } = n2;
        if (t2.quoteProps === "consistent" && !mn3.has(s2)) {
          let i2 = e2.siblings.some((a2) => !a2.computed && Q3(a2.key) && !Gi(a2, t2));
          mn3.set(s2, i2);
        }
        if (El(e2, t2)) {
          let i2 = tt2(JSON.stringify(u2.type === "Identifier" ? u2.name : u2.value.toString()), t2);
          return e2.call((a2) => ye(a2, i2, t2), "key");
        }
        return Gi(n2, t2) && (t2.quoteProps === "as-needed" || t2.quoteProps === "consistent" && !mn3.get(s2)) ? e2.call((i2) => ye(i2, /^\d/u.test(u2.value) ? Ze2(u2.value) : u2.value, t2), "key") : r2("key");
      }
      function yn3(e2, t2, r2) {
        let { node: n2 } = e2;
        return n2.shorthand ? r2("value") : Tt2(e2, t2, r2, Et3(e2, t2, r2), ":", "value");
      }
      var Fl = ({ node: e2, key: t2, parent: r2 }) => t2 === "value" && e2.type === "FunctionExpression" && (r2.type === "ObjectMethod" || r2.type === "ClassMethod" || r2.type === "ClassPrivateMethod" || r2.type === "MethodDefinition" || r2.type === "TSAbstractMethodDefinition" || r2.type === "TSDeclareMethod" || r2.type === "Property" && gt2(r2));
      function Dn2(e2, t2, r2, n2) {
        if (Fl(e2))
          return fn3(e2, r2, t2);
        let { node: s2 } = e2, u2 = false;
        if ((s2.type === "FunctionDeclaration" || s2.type === "FunctionExpression") && (n2 != null && n2.expandLastArg)) {
          let { parent: m } = e2;
          L3(m) && (oe3(m).length > 1 || K2(s2).every((D) => D.type === "Identifier" && !D.typeAnnotation)) && (u2 = true);
        }
        let i2 = [$2(e2), s2.async ? "async " : "", `function${s2.generator ? "*" : ""} `, s2.id ? t2("id") : ""], a2 = Je2(e2, t2, r2, u2), o2 = Ht2(e2, t2), c2 = ot3(s2, o2);
        return i2.push(Qe3(e2, r2, t2), l2([c2 ? l2(a2) : a2, o2]), s2.body ? " " : "", t2("body")), r2.semi && (s2.declare || !s2.body) && i2.push(";"), i2;
      }
      function mr2(e2, t2, r2) {
        let { node: n2 } = e2, { kind: s2 } = n2, u2 = n2.value || n2, i2 = [];
        return !s2 || s2 === "init" || s2 === "method" || s2 === "constructor" ? u2.async && i2.push("async ") : (ln3.ok(s2 === "get" || s2 === "set"), i2.push(s2, " ")), u2.generator && i2.push("*"), i2.push(Et3(e2, t2, r2), n2.optional || n2.key.optional ? "?" : "", n2 === u2 ? fn3(e2, t2, r2) : r2("value")), i2;
      }
      function fn3(e2, t2, r2) {
        let { node: n2 } = e2, s2 = Je2(e2, r2, t2), u2 = Ht2(e2, r2), i2 = vi2(n2), a2 = ot3(n2, u2), o2 = [Qe3(e2, t2, r2), l2([i2 ? l2(s2, { shouldBreak: true }) : a2 ? l2(s2) : s2, u2])];
        return n2.body ? o2.push(" ", r2("body")) : o2.push(t2.semi ? ";" : ""), o2;
      }
      function Cl(e2) {
        let t2 = K2(e2);
        return t2.length === 1 && !e2.typeParameters && !d2(e2, g2.Dangling) && t2[0].type === "Identifier" && !t2[0].typeAnnotation && !d2(t2[0]) && !t2[0].optional && !e2.predicate && !e2.returnType;
      }
      function En2(e2, t2) {
        if (t2.arrowParens === "always")
          return false;
        if (t2.arrowParens === "avoid") {
          let { node: r2 } = e2;
          return Cl(r2);
        }
        return false;
      }
      function Ht2(e2, t2) {
        let { node: r2 } = e2, s2 = [Y2(e2, t2, "returnType")];
        return r2.predicate && s2.push(t2("predicate")), s2;
      }
      function Ni(e2, t2, r2) {
        let { node: n2 } = e2, s2 = t2.semi ? ";" : "", u2 = [];
        if (n2.argument) {
          let o2 = r2("argument");
          Al(t2, n2.argument) ? o2 = ["(", f2([F, o2]), F, ")"] : (De3(n2.argument) || n2.argument.type === "SequenceExpression" || t2.experimentalTernaries && n2.argument.type === "ConditionalExpression" && (n2.argument.consequent.type === "ConditionalExpression" || n2.argument.alternate.type === "ConditionalExpression")) && (o2 = l2([b3("("), f2([E2, o2]), E2, b3(")")])), u2.push(" ", o2);
        }
        let i2 = d2(n2, g2.Dangling), a2 = s2 && i2 && d2(n2, g2.Last | g2.Line);
        return a2 && u2.push(s2), i2 && u2.push(" ", M3(e2, t2)), a2 || u2.push(s2), u2;
      }
      function Xi2(e2, t2, r2) {
        return ["return", Ni(e2, t2, r2)];
      }
      function Yi2(e2, t2, r2) {
        return ["throw", Ni(e2, t2, r2)];
      }
      function Al(e2, t2) {
        if (Oe3(e2.originalText, t2) || d2(t2, g2.Leading, (r2) => de2(e2.originalText, R3(r2), k(r2))) && !X3(t2))
          return true;
        if (jt2(t2)) {
          let r2 = t2, n2;
          for (; n2 = uu2(r2); )
            if (r2 = n2, Oe3(e2.originalText, r2))
              return true;
        }
        return false;
      }
      var xs = /* @__PURE__ */ new WeakMap();
      function Hi(e2) {
        return xs.has(e2) || xs.set(e2, e2.type === "ConditionalExpression" && !ie2(e2, (t2) => t2.type === "ObjectExpression")), xs.get(e2);
      }
      var Vi = (e2) => e2.type === "SequenceExpression";
      function $i(e2, t2, r2, n2 = {}) {
        let s2 = [], u2, i2 = [], a2 = false, o2 = !n2.expandLastArg && e2.node.body.type === "ArrowFunctionExpression", c2;
        (function T3() {
          let { node: S3 } = e2, B2 = Tl(e2, t2, r2, n2);
          if (s2.length === 0)
            s2.push(B2);
          else {
            let { leading: _3, trailing: J3 } = ps(e2, t2);
            s2.push([_3, B2]), i2.unshift(J3);
          }
          o2 && (a2 || (a2 = S3.returnType && K2(S3).length > 0 || S3.typeParameters || K2(S3).some((_3) => _3.type !== "Identifier"))), !o2 || S3.body.type !== "ArrowFunctionExpression" ? (u2 = r2("body", n2), c2 = S3.body) : e2.call(T3, "body");
        })();
        let m = !Oe3(t2.originalText, c2) && (Vi(c2) || dl(c2, u2, t2) || !a2 && Hi(c2)), D = e2.key === "callee" && lt3(e2.parent), y3 = Symbol("arrow-chain"), C = xl(e2, n2, { signatureDocs: s2, shouldBreak: a2 }), p2, A = false;
        return o2 && (D || n2.assignmentLayout) && (A = true, p2 = n2.assignmentLayout === "chain-tail-arrow-chain" || D && !m), u2 = hl2(e2, t2, n2, { bodyDoc: u2, bodyComments: i2, functionBody: c2, shouldPutBodyOnSameLine: m }), l2([l2(A ? f2([E2, C]) : C, { shouldBreak: p2, id: y3 }), " =>", o2 ? At3(u2, { groupId: y3 }) : l2(u2), o2 && D ? b3(E2, "", { groupId: y3 }) : ""]);
      }
      function Tl(e2, t2, r2, n2) {
        let { node: s2 } = e2, u2 = [];
        if (s2.async && u2.push("async "), En2(e2, t2))
          u2.push(r2(["params", 0]));
        else {
          let a2 = n2.expandLastArg || n2.expandFirstArg, o2 = Ht2(e2, r2);
          if (a2) {
            if (ne3(o2))
              throw new Dt2();
            o2 = l2(ur3(o2));
          }
          u2.push(l2([Je2(e2, r2, t2, a2, true), o2]));
        }
        let i2 = M3(e2, t2, { filter(a2) {
          let o2 = yt2(t2.originalText, k(a2));
          return o2 !== false && t2.originalText.slice(o2, o2 + 2) === "=>";
        } });
        return i2 && u2.push(" ", i2), u2;
      }
      function dl(e2, t2, r2) {
        var n2, s2;
        return U2(e2) || se2(e2) || e2.type === "ArrowFunctionExpression" || e2.type === "DoExpression" || e2.type === "BlockStatement" || X3(e2) || ((n2 = t2.label) == null ? void 0 : n2.hug) !== false && (((s2 = t2.label) == null ? void 0 : s2.embed) || Lr3(e2, r2.originalText));
      }
      function xl(e2, t2, { signatureDocs: r2, shouldBreak: n2 }) {
        if (r2.length === 1)
          return r2[0];
        let { parent: s2, key: u2 } = e2;
        return u2 !== "callee" && lt3(s2) || De3(s2) ? l2([r2[0], " =>", f2([x2, P2([" =>", x2], r2.slice(1))])], { shouldBreak: n2 }) : u2 === "callee" && lt3(s2) || t2.assignmentLayout ? l2(P2([" =>", x2], r2), { shouldBreak: n2 }) : l2(f2(P2([" =>", x2], r2)), { shouldBreak: n2 });
      }
      function hl2(e2, t2, r2, { bodyDoc: n2, bodyComments: s2, functionBody: u2, shouldPutBodyOnSameLine: i2 }) {
        let { node: a2, parent: o2 } = e2, c2 = r2.expandLastArg && ae2(t2, "all") ? b3(",") : "", m = (r2.expandLastArg || o2.type === "JSXExpressionContainer") && !d2(a2) ? E2 : "";
        return i2 && Hi(u2) ? [" ", l2([b3("", "("), f2([E2, n2]), b3("", ")"), c2, m]), s2] : (Vi(u2) && (n2 = l2(["(", f2([E2, n2]), E2, ")"])), i2 ? [" ", n2, s2] : [f2([x2, n2, s2]), c2, m]);
      }
      var gl2 = (e2, t2, r2) => {
        if (!(e2 && t2 == null)) {
          if (t2.findLast)
            return t2.findLast(r2);
          for (let n2 = t2.length - 1; n2 >= 0; n2--) {
            let s2 = t2[n2];
            if (r2(s2, n2, t2))
              return s2;
          }
        }
      }, Ki2 = gl2;
      function yr3(e2, t2, r2, n2) {
        let { node: s2 } = e2, u2 = [], i2 = Ki2(false, s2[n2], (a2) => a2.type !== "EmptyStatement");
        return e2.each(({ node: a2 }) => {
          a2.type !== "EmptyStatement" && (u2.push(r2()), a2 !== i2 && (u2.push(F), pe2(a2, t2) && u2.push(F)));
        }, n2), u2;
      }
      function Fn2(e2, t2, r2) {
        let n2 = Sl(e2, t2, r2), { node: s2, parent: u2 } = e2;
        if (s2.type === "Program" && (u2 == null ? void 0 : u2.type) !== "ModuleExpression")
          return n2 ? [n2, F] : "";
        let i2 = [];
        if (s2.type === "StaticBlock" && i2.push("static "), i2.push("{"), n2)
          i2.push(f2([F, n2]), F);
        else {
          let a2 = e2.grandparent;
          u2.type === "ArrowFunctionExpression" || u2.type === "FunctionExpression" || u2.type === "FunctionDeclaration" || u2.type === "ComponentDeclaration" || u2.type === "HookDeclaration" || u2.type === "ObjectMethod" || u2.type === "ClassMethod" || u2.type === "ClassPrivateMethod" || u2.type === "ForStatement" || u2.type === "WhileStatement" || u2.type === "DoWhileStatement" || u2.type === "DoExpression" || u2.type === "ModuleExpression" || u2.type === "CatchClause" && !a2.finalizer || u2.type === "TSModuleDeclaration" || s2.type === "StaticBlock" || i2.push(F);
        }
        return i2.push("}"), i2;
      }
      function Sl(e2, t2, r2) {
        let { node: n2 } = e2, s2 = w2(n2.directives), u2 = n2.body.some((o2) => o2.type !== "EmptyStatement"), i2 = d2(n2, g2.Dangling);
        if (!s2 && !u2 && !i2)
          return "";
        let a2 = [];
        return s2 && (a2.push(yr3(e2, t2, r2, "directives")), (u2 || i2) && (a2.push(F), pe2(O2(false, n2.directives, -1), t2) && a2.push(F))), u2 && a2.push(yr3(e2, t2, r2, "body")), i2 && a2.push(M3(e2, t2)), a2;
      }
      function Bl(e2) {
        let t2 = /* @__PURE__ */ new WeakMap();
        return function(r2) {
          return t2.has(r2) || t2.set(r2, Symbol(e2)), t2.get(r2);
        };
      }
      var Cn2 = Bl;
      function bl(e2) {
        switch (e2) {
          case null:
            return "";
          case "PlusOptional":
            return "+?";
          case "MinusOptional":
            return "-?";
          case "Optional":
            return "?";
        }
      }
      function zi(e2, t2, r2) {
        let { node: n2 } = e2;
        return l2([n2.variance ? r2("variance") : "", "[", f2([r2("keyTparam"), " in ", r2("sourceType")]), "]", bl(n2.optional), ": ", r2("propType")]);
      }
      function hs(e2, t2) {
        return e2 === "+" || e2 === "-" ? e2 + t2 : t2;
      }
      function Qi2(e2, t2, r2) {
        let { node: n2 } = e2, s2 = de2(t2.originalText, R3(n2), R3(n2.typeParameter));
        return l2(["{", f2([t2.bracketSpacing ? x2 : E2, l2([r2("typeParameter"), n2.optional ? hs(n2.optional, "?") : "", n2.typeAnnotation ? ": " : "", r2("typeAnnotation")]), t2.semi ? b3(";") : ""]), M3(e2, t2), t2.bracketSpacing ? x2 : E2, "}"], { shouldBreak: s2 });
      }
      var Dr2 = Cn2("typeParameters");
      function Pl(e2, t2, r2) {
        let { node: n2 } = e2;
        return K2(n2).length === 1 && n2.type.startsWith("TS") && !n2[r2][0].constraint && e2.parent.type === "ArrowFunctionExpression" && !(t2.filepath && /\.ts$/u.test(t2.filepath));
      }
      function Pt2(e2, t2, r2, n2) {
        let { node: s2 } = e2;
        if (!s2[n2])
          return "";
        if (!Array.isArray(s2[n2]))
          return r2(n2);
        let u2 = St3(e2.grandparent), i2 = e2.match((c2) => !(c2[n2].length === 1 && we3(c2[n2][0])), void 0, (c2, m) => m === "typeAnnotation", (c2) => c2.type === "Identifier", Cs2);
        if (s2[n2].length === 0 || !i2 && (u2 || s2[n2].length === 1 && (s2[n2][0].type === "NullableTypeAnnotation" || Ts2(s2[n2][0]))))
          return ["<", P2(", ", e2.map(r2, n2)), kl(e2, t2), ">"];
        let o2 = s2.type === "TSTypeParameterInstantiation" ? "" : Pl(e2, t2, n2) ? "," : ae2(t2) ? b3(",") : "";
        return l2(["<", f2([E2, P2([",", x2], e2.map(r2, n2))]), o2, E2, ">"], { id: Dr2(s2) });
      }
      function kl(e2, t2) {
        let { node: r2 } = e2;
        if (!d2(r2, g2.Dangling))
          return "";
        let n2 = !d2(r2, g2.Line), s2 = M3(e2, t2, { indent: !n2 });
        return n2 ? s2 : [s2, F];
      }
      function An2(e2, t2, r2) {
        let { node: n2, parent: s2 } = e2, u2 = [n2.type === "TSTypeParameter" && n2.const ? "const " : ""], i2 = n2.type === "TSTypeParameter" ? r2("name") : n2.name;
        if (s2.type === "TSMappedType")
          return s2.readonly && u2.push(hs(s2.readonly, "readonly"), " "), u2.push("[", i2), n2.constraint && u2.push(" in ", r2("constraint")), s2.nameType && u2.push(" as ", e2.callParent(() => r2("nameType"))), u2.push("]"), u2;
        if (n2.variance && u2.push(r2("variance")), n2.in && u2.push("in "), n2.out && u2.push("out "), u2.push(i2), n2.bound && (n2.usesExtendsBound && u2.push(" extends "), u2.push(Y2(e2, r2, "bound"))), n2.constraint) {
          let a2 = Symbol("constraint");
          u2.push(" extends", l2(f2(x2), { id: a2 }), ke3, At3(r2("constraint"), { groupId: a2 }));
        }
        return n2.default && u2.push(" = ", r2("default")), l2(u2);
      }
      var Zi = v2(["ClassProperty", "PropertyDefinition", "ClassPrivateProperty", "ClassAccessorProperty", "AccessorProperty", "TSAbstractPropertyDefinition", "TSAbstractAccessorProperty"]);
      function Tn3(e2, t2, r2) {
        let { node: n2 } = e2, s2 = [$2(e2), Nt2(e2), "class"], u2 = d2(n2.id, g2.Trailing) || d2(n2.typeParameters, g2.Trailing) || d2(n2.superClass) || w2(n2.extends) || w2(n2.mixins) || w2(n2.implements), i2 = [], a2 = [];
        if (n2.id && i2.push(" ", r2("id")), i2.push(r2("typeParameters")), n2.superClass) {
          let o2 = [Ll(e2, t2, r2), r2(n2.superTypeArguments ? "superTypeArguments" : "superTypeParameters")], c2 = e2.call((m) => ["extends ", ye(m, o2, t2)], "superClass");
          u2 ? a2.push(x2, l2(c2)) : a2.push(" ", c2);
        } else
          a2.push(gs(e2, t2, r2, "extends"));
        if (a2.push(gs(e2, t2, r2, "mixins"), gs(e2, t2, r2, "implements")), u2) {
          let o2;
          ta(n2) ? o2 = [...i2, f2(a2)] : o2 = f2([...i2, a2]), s2.push(l2(o2, { id: ea(n2) }));
        } else
          s2.push(...i2, ...a2);
        return s2.push(" ", r2("body")), s2;
      }
      var ea = Cn2("heritageGroup");
      function Ss2(e2) {
        return b3(F, "", { groupId: ea(e2) });
      }
      function Il(e2) {
        return ["extends", "mixins", "implements"].reduce((t2, r2) => t2 + (Array.isArray(e2[r2]) ? e2[r2].length : 0), e2.superClass ? 1 : 0) > 1;
      }
      function ta(e2) {
        return e2.typeParameters && !d2(e2.typeParameters, g2.Trailing | g2.Line) && !Il(e2);
      }
      function gs(e2, t2, r2, n2) {
        let { node: s2 } = e2;
        if (!w2(s2[n2]))
          return "";
        let u2 = M3(e2, t2, { marker: n2 });
        return [ta(s2) ? b3(" ", x2, { groupId: Dr2(s2.typeParameters) }) : x2, u2, u2 && F, n2, l2(f2([x2, P2([",", x2], e2.map(r2, n2))]))];
      }
      function Ll(e2, t2, r2) {
        let n2 = r2("superClass"), { parent: s2 } = e2;
        return s2.type === "AssignmentExpression" ? l2(b3(["(", f2([E2, n2]), E2, ")"], n2)) : n2;
      }
      function dn3(e2, t2, r2) {
        let { node: n2 } = e2, s2 = [];
        return w2(n2.decorators) && s2.push(fs(e2, t2, r2)), s2.push(Xt(n2)), n2.static && s2.push("static "), s2.push(Nt2(e2)), n2.override && s2.push("override "), s2.push(mr2(e2, t2, r2)), s2;
      }
      function xn3(e2, t2, r2) {
        let { node: n2 } = e2, s2 = [], u2 = t2.semi ? ";" : "";
        w2(n2.decorators) && s2.push(fs(e2, t2, r2)), s2.push(Xt(n2), $2(e2)), n2.static && s2.push("static "), s2.push(Nt2(e2)), n2.override && s2.push("override "), n2.readonly && s2.push("readonly "), n2.variance && s2.push(r2("variance")), (n2.type === "ClassAccessorProperty" || n2.type === "AccessorProperty" || n2.type === "TSAbstractAccessorProperty") && s2.push("accessor "), s2.push(Et3(e2, t2, r2), V2(e2), pn3(e2), Y2(e2, r2));
        let i2 = n2.type === "TSAbstractPropertyDefinition" || n2.type === "TSAbstractAccessorProperty";
        return [Tt2(e2, t2, r2, s2, " =", i2 ? void 0 : "value"), u2];
      }
      function ra(e2, t2, r2) {
        let { node: n2 } = e2, s2 = [];
        return e2.each(({ node: u2, next: i2, isLast: a2 }) => {
          s2.push(r2()), !t2.semi && Zi(u2) && wl(u2, i2) && s2.push(";"), a2 || (s2.push(F), pe2(u2, t2) && s2.push(F));
        }, "body"), d2(n2, g2.Dangling) && s2.push(M3(e2, t2)), [w2(n2.body) ? Ss2(e2.parent) : "", "{", s2.length > 0 ? [f2([F, s2]), F] : "", "}"];
      }
      function wl(e2, t2) {
        var s2;
        let { type: r2, name: n2 } = e2.key;
        if (!e2.computed && r2 === "Identifier" && (n2 === "static" || n2 === "get" || n2 === "set") && !e2.value && !e2.typeAnnotation)
          return true;
        if (!t2 || t2.static || t2.accessibility || t2.readonly)
          return false;
        if (!t2.computed) {
          let u2 = (s2 = t2.key) == null ? void 0 : s2.name;
          if (u2 === "in" || u2 === "instanceof")
            return true;
        }
        if (Zi(t2) && t2.variance && !t2.static && !t2.declare)
          return true;
        switch (t2.type) {
          case "ClassProperty":
          case "PropertyDefinition":
          case "TSAbstractPropertyDefinition":
            return t2.computed;
          case "MethodDefinition":
          case "TSAbstractMethodDefinition":
          case "ClassMethod":
          case "ClassPrivateMethod": {
            if ((t2.value ? t2.value.async : t2.async) || t2.kind === "get" || t2.kind === "set")
              return false;
            let i2 = t2.value ? t2.value.generator : t2.generator;
            return !!(t2.computed || i2);
          }
          case "TSIndexSignature":
            return true;
        }
        return false;
      }
      function na(e2, t2) {
        if (t2.semi || Bs2(e2, t2) || Ps2(e2, t2))
          return false;
        let { node: r2, key: n2, parent: s2 } = e2;
        return !!(r2.type === "ExpressionStatement" && (n2 === "body" && (s2.type === "Program" || s2.type === "BlockStatement" || s2.type === "StaticBlock" || s2.type === "TSModuleBlock") || n2 === "consequent" && s2.type === "SwitchCase") && e2.call(() => sa2(e2, t2), "expression"));
      }
      function sa2(e2, t2) {
        let { node: r2 } = e2;
        switch (r2.type) {
          case "ParenthesizedExpression":
          case "TypeCastExpression":
          case "ArrayExpression":
          case "ArrayPattern":
          case "TemplateLiteral":
          case "TemplateElement":
          case "RegExpLiteral":
            return true;
          case "ArrowFunctionExpression":
            if (!En2(e2, t2))
              return true;
            break;
          case "UnaryExpression": {
            let { prefix: n2, operator: s2 } = r2;
            if (n2 && (s2 === "+" || s2 === "-"))
              return true;
            break;
          }
          case "BindExpression":
            if (!r2.object)
              return true;
            break;
          case "Literal":
            if (r2.regex)
              return true;
            break;
          default:
            if (X3(r2))
              return true;
        }
        return Be3(e2, t2) ? true : jt2(r2) ? e2.call(() => sa2(e2, t2), ...Pr2(r2)) : false;
      }
      function Bs2({ node: e2, parent: t2 }, r2) {
        return (r2.parentParser === "markdown" || r2.parentParser === "mdx") && e2.type === "ExpressionStatement" && X3(e2.expression) && t2.type === "Program" && t2.body.length === 1;
      }
      function bs2(e2) {
        switch (e2.type) {
          case "MemberExpression":
            switch (e2.property.type) {
              case "Identifier":
              case "NumericLiteral":
              case "StringLiteral":
                return bs2(e2.object);
            }
            return false;
          case "Identifier":
            return true;
          default:
            return false;
        }
      }
      function Ps2({ node: e2, parent: t2 }, r2) {
        return (r2.parser === "__vue_event_binding" || r2.parser === "__vue_ts_event_binding") && e2.type === "ExpressionStatement" && t2.type === "Program" && t2.body.length === 1;
      }
      function ua2(e2, t2, r2) {
        let n2 = [r2("expression")];
        return Ps2(e2, t2) ? bs2(e2.node.expression) && n2.push(";") : Bs2(e2, t2) || t2.semi && n2.push(";"), n2;
      }
      function ia(e2, t2, r2) {
        if (t2.__isVueBindings || t2.__isVueForBindingLeft) {
          let n2 = e2.map(r2, "program", "body", 0, "params");
          if (n2.length === 1)
            return n2[0];
          let s2 = P2([",", x2], n2);
          return t2.__isVueForBindingLeft ? ["(", f2([E2, l2(s2)]), E2, ")"] : s2;
        }
        if (t2.__isEmbeddedTypescriptGenericParameters) {
          let n2 = e2.map(r2, "program", "body", 0, "typeParameters", "params");
          return P2([",", x2], n2);
        }
      }
      function pa2(e2, t2) {
        let { node: r2 } = e2;
        switch (r2.type) {
          case "RegExpLiteral":
            return aa2(r2);
          case "BigIntLiteral":
            return hn3(r2.extra.raw);
          case "NumericLiteral":
            return Ze2(r2.extra.raw);
          case "StringLiteral":
            return Ie3(tt2(r2.extra.raw, t2));
          case "NullLiteral":
            return "null";
          case "BooleanLiteral":
            return String(r2.value);
          case "DecimalLiteral":
            return Ze2(r2.value) + "m";
          case "DirectiveLiteral":
            return oa2(r2.extra.raw, t2);
          case "Literal": {
            if (r2.regex)
              return aa2(r2.regex);
            if (r2.bigint)
              return hn3(r2.raw);
            if (r2.decimal)
              return Ze2(r2.decimal) + "m";
            let { value: n2 } = r2;
            return typeof n2 == "number" ? Ze2(r2.raw) : typeof n2 == "string" ? Ol(e2) ? oa2(r2.raw, t2) : Ie3(tt2(r2.raw, t2)) : String(n2);
          }
        }
      }
      function Ol(e2) {
        if (e2.key !== "expression")
          return;
        let { parent: t2 } = e2;
        return t2.type === "ExpressionStatement" && t2.directive;
      }
      function hn3(e2) {
        return e2.toLowerCase();
      }
      function aa2({ pattern: e2, flags: t2 }) {
        return t2 = [...t2].sort().join(""), `/${e2}/${t2}`;
      }
      function oa2(e2, t2) {
        let r2 = e2.slice(1, -1);
        if (r2.includes('"') || r2.includes("'"))
          return e2;
        let n2 = t2.singleQuote ? "'" : '"';
        return n2 + r2 + n2;
      }
      function _l(e2, t2, r2) {
        let n2 = e2.originalText.slice(t2, r2);
        for (let s2 of e2[Symbol.for("comments")]) {
          let u2 = R3(s2);
          if (u2 > r2)
            break;
          let i2 = k(s2);
          if (i2 < t2)
            continue;
          let a2 = i2 - u2;
          n2 = n2.slice(0, u2 - t2) + " ".repeat(a2) + n2.slice(i2 - t2);
        }
        return n2;
      }
      var fr3 = _l;
      function ca2(e2, t2, r2) {
        let { node: n2 } = e2;
        return ["import", n2.module ? " module" : "", n2.phase ? ` ${n2.phase}` : "", Is2(n2), ya(e2, t2, r2), ma2(e2, t2, r2), fa2(e2, t2, r2), t2.semi ? ";" : ""];
      }
      var la2 = (e2) => e2.type === "ExportDefaultDeclaration" || e2.type === "DeclareExportDeclaration" && e2.default;
      function gn3(e2, t2, r2) {
        let { node: n2 } = e2, s2 = [di2(e2, t2, r2), $2(e2), "export", la2(n2) ? " default" : ""], { declaration: u2, exported: i2 } = n2;
        return d2(n2, g2.Dangling) && (s2.push(" ", M3(e2, t2)), wr2(n2) && s2.push(F)), u2 ? s2.push(" ", r2("declaration")) : (s2.push(Ml(n2)), n2.type === "ExportAllDeclaration" || n2.type === "DeclareExportAllDeclaration" ? (s2.push(" *"), i2 && s2.push(" as ", r2("exported"))) : s2.push(ya(e2, t2, r2)), s2.push(ma2(e2, t2, r2), fa2(e2, t2, r2))), s2.push(vl(n2, t2)), s2;
      }
      var jl = v2(["ClassDeclaration", "ComponentDeclaration", "FunctionDeclaration", "TSInterfaceDeclaration", "DeclareClass", "DeclareComponent", "DeclareFunction", "DeclareHook", "HookDeclaration", "TSDeclareFunction", "EnumDeclaration"]);
      function vl(e2, t2) {
        return t2.semi && (!e2.declaration || la2(e2) && !jl(e2.declaration)) ? ";" : "";
      }
      function ks2(e2, t2 = true) {
        return e2 && e2 !== "value" ? `${t2 ? " " : ""}${e2}${t2 ? "" : " "}` : "";
      }
      function Is2(e2, t2) {
        return ks2(e2.importKind, t2);
      }
      function Ml(e2) {
        return ks2(e2.exportKind);
      }
      function ma2(e2, t2, r2) {
        let { node: n2 } = e2;
        if (!n2.source)
          return "";
        let s2 = [];
        return Da2(n2, t2) && s2.push(" from"), s2.push(" ", r2("source")), s2;
      }
      function ya(e2, t2, r2) {
        let { node: n2 } = e2;
        if (!Da2(n2, t2))
          return "";
        let s2 = [" "];
        if (w2(n2.specifiers)) {
          let u2 = [], i2 = [];
          e2.each(() => {
            let a2 = e2.node.type;
            if (a2 === "ExportNamespaceSpecifier" || a2 === "ExportDefaultSpecifier" || a2 === "ImportNamespaceSpecifier" || a2 === "ImportDefaultSpecifier")
              u2.push(r2());
            else if (a2 === "ExportSpecifier" || a2 === "ImportSpecifier")
              i2.push(r2());
            else
              throw new Me3(n2, "specifier");
          }, "specifiers"), s2.push(P2(", ", u2)), i2.length > 0 && (u2.length > 0 && s2.push(", "), i2.length > 1 || u2.length > 0 || n2.specifiers.some((o2) => d2(o2)) ? s2.push(l2(["{", f2([t2.bracketSpacing ? x2 : E2, P2([",", x2], i2)]), b3(ae2(t2) ? "," : ""), t2.bracketSpacing ? x2 : E2, "}"])) : s2.push(["{", t2.bracketSpacing ? " " : "", ...i2, t2.bracketSpacing ? " " : "", "}"]));
        } else
          s2.push("{}");
        return s2;
      }
      function Da2(e2, t2) {
        return e2.type !== "ImportDeclaration" || w2(e2.specifiers) || e2.importKind === "type" ? true : fr3(t2, R3(e2), R3(e2.source)).trimEnd().endsWith("from");
      }
      function Rl(e2, t2) {
        var n2, s2;
        if ((n2 = e2.extra) != null && n2.deprecatedAssertSyntax)
          return "assert";
        let r2 = fr3(t2, k(e2.source), (s2 = e2.attributes) != null && s2[0] ? R3(e2.attributes[0]) : k(e2)).trimStart();
        return r2.startsWith("assert") ? "assert" : r2.startsWith("with") || w2(e2.attributes) ? "with" : void 0;
      }
      function fa2(e2, t2, r2) {
        let { node: n2 } = e2;
        if (!n2.source)
          return "";
        let s2 = Rl(n2, t2);
        if (!s2)
          return "";
        let u2 = [` ${s2} {`];
        return w2(n2.attributes) && (t2.bracketSpacing && u2.push(" "), u2.push(P2(", ", e2.map(r2, "attributes"))), t2.bracketSpacing && u2.push(" ")), u2.push("}"), u2;
      }
      function Ea2(e2, t2, r2) {
        let { node: n2 } = e2, { type: s2 } = n2, u2 = s2.startsWith("Import"), i2 = u2 ? "imported" : "local", a2 = u2 ? "local" : "exported", o2 = n2[i2], c2 = n2[a2], m = "", D = "";
        return s2 === "ExportNamespaceSpecifier" || s2 === "ImportNamespaceSpecifier" ? m = "*" : o2 && (m = r2(i2)), c2 && !Jl(n2) && (D = r2(a2)), [ks2(s2 === "ImportSpecifier" ? n2.importKind : n2.exportKind, false), m, m && D ? " as " : "", D];
      }
      function Jl(e2) {
        if (e2.type !== "ImportSpecifier" && e2.type !== "ExportSpecifier")
          return false;
        let { local: t2, [e2.type === "ImportSpecifier" ? "imported" : "exported"]: r2 } = e2;
        if (t2.type !== r2.type || !eu2(t2, r2))
          return false;
        if (Q3(t2))
          return t2.value === r2.value && fe2(t2) === fe2(r2);
        switch (t2.type) {
          case "Identifier":
            return t2.name === r2.name;
          default:
            return false;
        }
      }
      function dt3(e2, t2, r2) {
        var j2;
        let n2 = t2.semi ? ";" : "", { node: s2 } = e2, u2 = s2.type === "ObjectTypeAnnotation", i2 = s2.type === "TSEnumDeclaration" || s2.type === "EnumBooleanBody" || s2.type === "EnumNumberBody" || s2.type === "EnumBigIntBody" || s2.type === "EnumStringBody" || s2.type === "EnumSymbolBody", a2 = [s2.type === "TSTypeLiteral" || i2 ? "members" : s2.type === "TSInterfaceBody" ? "body" : "properties"];
        u2 && a2.push("indexers", "callProperties", "internalSlots");
        let o2 = a2.flatMap((h2) => e2.map(({ node: W2 }) => ({ node: W2, printed: r2(), loc: R3(W2) }), h2));
        a2.length > 1 && o2.sort((h2, W2) => h2.loc - W2.loc);
        let { parent: c2, key: m } = e2, D = u2 && m === "body" && (c2.type === "InterfaceDeclaration" || c2.type === "DeclareInterface" || c2.type === "DeclareClass"), y3 = s2.type === "TSInterfaceBody" || i2 || D || s2.type === "ObjectPattern" && c2.type !== "FunctionDeclaration" && c2.type !== "FunctionExpression" && c2.type !== "ArrowFunctionExpression" && c2.type !== "ObjectMethod" && c2.type !== "ClassMethod" && c2.type !== "ClassPrivateMethod" && c2.type !== "AssignmentPattern" && c2.type !== "CatchClause" && s2.properties.some((h2) => h2.value && (h2.value.type === "ObjectPattern" || h2.value.type === "ArrayPattern")) || s2.type !== "ObjectPattern" && o2.length > 0 && de2(t2.originalText, R3(s2), o2[0].loc), C = D ? ";" : s2.type === "TSInterfaceBody" || s2.type === "TSTypeLiteral" ? b3(n2, ";") : ",", p2 = s2.type === "RecordExpression" ? "#{" : s2.exact ? "{|" : "{", A = s2.exact ? "|}" : "}", T3 = [], S3 = o2.map((h2) => {
          let W2 = [...T3, l2(h2.printed)];
          return T3 = [C, x2], (h2.node.type === "TSPropertySignature" || h2.node.type === "TSMethodSignature" || h2.node.type === "TSConstructSignatureDeclaration" || h2.node.type === "TSCallSignatureDeclaration") && d2(h2.node, g2.PrettierIgnore) && T3.shift(), pe2(h2.node, t2) && T3.push(F), W2;
        });
        if (s2.inexact || s2.hasUnknownMembers) {
          let h2;
          if (d2(s2, g2.Dangling)) {
            let W2 = d2(s2, g2.Line);
            h2 = [M3(e2, t2), W2 || te2(t2.originalText, k(O2(false, ct3(s2), -1))) ? F : x2, "..."];
          } else
            h2 = ["..."];
          S3.push([...T3, ...h2]);
        }
        let B2 = (j2 = O2(false, o2, -1)) == null ? void 0 : j2.node, _3 = !(s2.inexact || s2.hasUnknownMembers || B2 && (B2.type === "RestElement" || (B2.type === "TSPropertySignature" || B2.type === "TSCallSignatureDeclaration" || B2.type === "TSMethodSignature" || B2.type === "TSConstructSignatureDeclaration") && d2(B2, g2.PrettierIgnore))), J3;
        if (S3.length === 0) {
          if (!d2(s2, g2.Dangling))
            return [p2, A, Y2(e2, r2)];
          J3 = l2([p2, M3(e2, t2, { indent: true }), E2, A, V2(e2), Y2(e2, r2)]);
        } else
          J3 = [D && w2(s2.properties) ? Ss2(c2) : "", p2, f2([t2.bracketSpacing ? x2 : E2, ...S3]), b3(_3 && (C !== "," || ae2(t2)) ? C : ""), t2.bracketSpacing ? x2 : E2, A, V2(e2), Y2(e2, r2)];
        return e2.match((h2) => h2.type === "ObjectPattern" && !w2(h2.decorators), Ls) || we3(s2) && (e2.match(void 0, (h2, W2) => W2 === "typeAnnotation", (h2, W2) => W2 === "typeAnnotation", Ls) || e2.match(void 0, (h2, W2) => h2.type === "FunctionTypeParam" && W2 === "typeAnnotation", Ls)) || !y3 && e2.match((h2) => h2.type === "ObjectPattern", (h2) => h2.type === "AssignmentExpression" || h2.type === "VariableDeclarator") ? J3 : l2(J3, { shouldBreak: y3 });
      }
      function Ls(e2, t2) {
        return (t2 === "params" || t2 === "parameters" || t2 === "this" || t2 === "rest") && As2(e2);
      }
      function ql(e2) {
        let t2 = [e2];
        for (let r2 = 0; r2 < t2.length; r2++) {
          let n2 = t2[r2];
          for (let s2 of ["test", "consequent", "alternate"]) {
            let u2 = n2[s2];
            if (X3(u2))
              return true;
            u2.type === "ConditionalExpression" && t2.push(u2);
          }
        }
        return false;
      }
      function Wl(e2, t2, r2) {
        let { node: n2 } = e2, s2 = n2.type === "ConditionalExpression", u2 = s2 ? "alternate" : "falseType", { parent: i2 } = e2, a2 = s2 ? r2("test") : [r2("checkType"), " ", "extends", " ", r2("extendsType")];
        return i2.type === n2.type && i2[u2] === n2 ? he3(2, a2) : a2;
      }
      var Gl = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"], ["AwaitExpression", "argument"]]);
      function Ul2(e2) {
        let { node: t2 } = e2;
        if (t2.type !== "ConditionalExpression")
          return false;
        let r2, n2 = t2;
        for (let s2 = 0; !r2; s2++) {
          let u2 = e2.getParentNode(s2);
          if (u2.type === "ChainExpression" && u2.expression === n2 || L3(u2) && u2.callee === n2 || q2(u2) && u2.object === n2 || u2.type === "TSNonNullExpression" && u2.expression === n2) {
            n2 = u2;
            continue;
          }
          u2.type === "NewExpression" && u2.callee === n2 || Te2(u2) && u2.expression === n2 ? (r2 = e2.getParentNode(s2 + 1), n2 = u2) : r2 = u2;
        }
        return n2 === t2 ? false : r2[Gl.get(r2.type)] === n2;
      }
      function Fa2(e2, t2, r2) {
        let { node: n2 } = e2, s2 = n2.type === "ConditionalExpression", u2 = s2 ? "consequent" : "trueType", i2 = s2 ? "alternate" : "falseType", a2 = s2 ? ["test"] : ["checkType", "extendsType"], o2 = n2[u2], c2 = n2[i2], m = [], D = false, { parent: y3 } = e2, C = y3.type === n2.type && a2.some((H3) => y3[H3] === n2), p2 = y3.type === n2.type && !C, A, T3, S3 = 0;
        do
          T3 = A || n2, A = e2.getParentNode(S3), S3++;
        while (A && A.type === n2.type && a2.every((H3) => A[H3] !== T3));
        let B2 = A || y3, _3 = T3;
        if (s2 && (X3(n2[a2[0]]) || X3(o2) || X3(c2) || ql(_3))) {
          D = true, p2 = true;
          let H3 = (Z3) => [b3("("), f2([E2, Z3]), E2, b3(")")], ue2 = (Z3) => Z3.type === "NullLiteral" || Z3.type === "Literal" && Z3.value === null || Z3.type === "Identifier" && Z3.name === "undefined";
          m.push(" ? ", ue2(o2) ? r2(u2) : H3(r2(u2)), " : ", c2.type === n2.type || ue2(c2) ? r2(i2) : H3(r2(i2)));
        } else {
          let H3 = (Z3) => t2.useTabs ? f2(r2(Z3)) : he3(2, r2(Z3)), ue2 = [x2, "? ", o2.type === n2.type ? b3("", "(") : "", H3(u2), o2.type === n2.type ? b3("", ")") : "", x2, ": ", H3(i2)];
          m.push(y3.type !== n2.type || y3[i2] === n2 || C ? ue2 : t2.useTabs ? Mr2(f2(ue2)) : he3(Math.max(0, t2.tabWidth - 2), ue2));
        }
        let J3 = [u2, i2, ...a2].some((H3) => d2(n2[H3], (ue2) => re3(ue2) && de2(t2.originalText, R3(ue2), k(ue2)))), j2 = (H3) => y3 === B2 ? l2(H3, { shouldBreak: J3 }) : J3 ? [H3, Ee2] : H3, h2 = !D && (q2(y3) || y3.type === "NGPipeExpression" && y3.left === n2) && !y3.computed, W2 = Ul2(e2), Fe3 = j2([Wl(e2, t2, r2), p2 ? m : f2(m), s2 && h2 && !W2 ? E2 : ""]);
        return C || W2 ? l2([f2([E2, Fe3]), E2]) : Fe3;
      }
      function Nl(e2, t2) {
        return (q2(t2) || t2.type === "NGPipeExpression" && t2.left === e2) && !t2.computed;
      }
      function Xl2(e2, t2, r2, n2) {
        return [...e2.map((u2) => ct3(u2)), ct3(t2), ct3(r2)].flat().some((u2) => re3(u2) && de2(n2.originalText, R3(u2), k(u2)));
      }
      var Yl2 = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"], ["AwaitExpression", "argument"]]);
      function Hl(e2) {
        let { node: t2 } = e2;
        if (t2.type !== "ConditionalExpression")
          return false;
        let r2, n2 = t2;
        for (let s2 = 0; !r2; s2++) {
          let u2 = e2.getParentNode(s2);
          if (u2.type === "ChainExpression" && u2.expression === n2 || L3(u2) && u2.callee === n2 || q2(u2) && u2.object === n2 || u2.type === "TSNonNullExpression" && u2.expression === n2) {
            n2 = u2;
            continue;
          }
          u2.type === "NewExpression" && u2.callee === n2 || Te2(u2) && u2.expression === n2 ? (r2 = e2.getParentNode(s2 + 1), n2 = u2) : r2 = u2;
        }
        return n2 === t2 ? false : r2[Yl2.get(r2.type)] === n2;
      }
      var ws = (e2) => [b3("("), f2([E2, e2]), E2, b3(")")];
      function Vt2(e2, t2, r2, n2) {
        if (!t2.experimentalTernaries)
          return Fa2(e2, t2, r2);
        let { node: s2 } = e2, u2 = s2.type === "ConditionalExpression", i2 = s2.type === "TSConditionalType" || s2.type === "ConditionalTypeAnnotation", a2 = u2 ? "consequent" : "trueType", o2 = u2 ? "alternate" : "falseType", c2 = u2 ? ["test"] : ["checkType", "extendsType"], m = s2[a2], D = s2[o2], y3 = c2.map((We2) => s2[We2]), { parent: C } = e2, p2 = C.type === s2.type, A = p2 && c2.some((We2) => C[We2] === s2), T3 = p2 && C[o2] === s2, S3 = m.type === s2.type, B2 = D.type === s2.type, _3 = B2 || T3, J3 = t2.tabWidth > 2 || t2.useTabs, j2, h2, W2 = 0;
        do
          h2 = j2 || s2, j2 = e2.getParentNode(W2), W2++;
        while (j2 && j2.type === s2.type && c2.every((We2) => j2[We2] !== h2));
        let Fe3 = j2 || C, H3 = n2 && n2.assignmentLayout && n2.assignmentLayout !== "break-after-operator" && (C.type === "AssignmentExpression" || C.type === "VariableDeclarator" || C.type === "ClassProperty" || C.type === "PropertyDefinition" || C.type === "ClassPrivateProperty" || C.type === "ObjectProperty" || C.type === "Property"), ue2 = (C.type === "ReturnStatement" || C.type === "ThrowStatement") && !(S3 || B2), Z3 = u2 && Fe3.type === "JSXExpressionContainer" && e2.grandparent.type !== "JSXAttribute", It2 = Hl(e2), $t2 = Nl(s2, C), I2 = i2 && Be3(e2, t2), G3 = J3 ? t2.useTabs ? "	" : " ".repeat(t2.tabWidth - 1) : "", ee3 = Xl2(y3, m, D, t2) || S3 || B2, qe2 = !_3 && !p2 && !i2 && (Z3 ? m.type === "NullLiteral" || m.type === "Literal" && m.value === null : rr2(m, t2) && Rn2(s2.test, 3)), xt3 = _3 || T3 || i2 && !p2 || p2 && u2 && Rn2(s2.test, 1) || qe2, js2 = [];
        !S3 && d2(m, g2.Dangling) && e2.call((We2) => {
          js2.push(M3(We2, t2), F);
        }, "consequent");
        let Kt2 = [];
        d2(s2.test, g2.Dangling) && e2.call((We2) => {
          Kt2.push(M3(We2, t2));
        }, "test"), !B2 && d2(D, g2.Dangling) && e2.call((We2) => {
          Kt2.push(M3(We2, t2));
        }, "alternate"), d2(s2, g2.Dangling) && Kt2.push(M3(e2, t2));
        let vs = Symbol("test"), Ma2 = Symbol("consequent"), Fr2 = Symbol("test-and-consequent"), Ra2 = u2 ? [ws(r2("test")), s2.test.type === "ConditionalExpression" ? Ee2 : ""] : [r2("checkType"), " ", "extends", " ", s2.extendsType.type === "TSConditionalType" || s2.extendsType.type === "ConditionalTypeAnnotation" || s2.extendsType.type === "TSMappedType" ? r2("extendsType") : l2(ws(r2("extendsType")))], Ms2 = l2([Ra2, " ?"], { id: vs }), Ja2 = r2(a2), Cr2 = f2([S3 || Z3 && (X3(m) || p2 || _3) ? F : x2, js2, Ja2]), qa = xt3 ? l2([Ms2, _3 ? Cr2 : b3(Cr2, l2(Cr2, { id: Ma2 }), { groupId: vs })], { id: Fr2 }) : [Ms2, Cr2], kn3 = r2(o2), Rs2 = qe2 ? b3(kn3, Mr2(ws(kn3)), { groupId: Fr2 }) : kn3, zt2 = [qa, Kt2.length > 0 ? [f2([F, Kt2]), F] : B2 ? F : qe2 ? b3(x2, " ", { groupId: Fr2 }) : x2, ":", B2 ? " " : J3 ? xt3 ? b3(G3, b3(_3 || qe2 ? " " : G3, " "), { groupId: Fr2 }) : b3(G3, " ") : " ", B2 ? Rs2 : l2([f2(Rs2), Z3 && !qe2 ? E2 : ""]), $t2 && !It2 ? E2 : "", ee3 ? Ee2 : ""];
        return H3 && !ee3 ? l2(f2([E2, l2(zt2)])) : H3 || ue2 ? l2(f2(zt2)) : It2 || i2 && A ? l2([f2([E2, zt2]), I2 ? E2 : ""]) : C === Fe3 ? l2(zt2) : zt2;
      }
      function Ca(e2, t2, r2, n2) {
        let { node: s2 } = e2;
        if (kr3(s2))
          return pa2(e2, t2);
        let u2 = t2.semi ? ";" : "", i2 = [];
        switch (s2.type) {
          case "JsExpressionRoot":
            return r2("node");
          case "JsonRoot":
            return [r2("node"), F];
          case "File":
            return ia(e2, t2, r2) ?? r2("program");
          case "EmptyStatement":
            return "";
          case "ExpressionStatement":
            return ua2(e2, t2, r2);
          case "ChainExpression":
            return r2("expression");
          case "ParenthesizedExpression":
            return !d2(s2.expression) && (se2(s2.expression) || U2(s2.expression)) ? ["(", r2("expression"), ")"] : l2(["(", f2([E2, r2("expression")]), E2, ")"]);
          case "AssignmentExpression":
            return wi(e2, t2, r2);
          case "VariableDeclarator":
            return Oi2(e2, t2, r2);
          case "BinaryExpression":
          case "LogicalExpression":
            return Yr3(e2, t2, r2);
          case "AssignmentPattern":
            return [r2("left"), " = ", r2("right")];
          case "OptionalMemberExpression":
          case "MemberExpression":
            return bi(e2, t2, r2);
          case "MetaProperty":
            return [r2("meta"), ".", r2("property")];
          case "BindExpression":
            return s2.object && i2.push(r2("object")), i2.push(l2(f2([E2, Hr3(e2, t2, r2)]))), i2;
          case "Identifier":
            return [s2.name, V2(e2), pn3(e2), Y2(e2, r2)];
          case "V8IntrinsicIdentifier":
            return ["%", s2.name];
          case "SpreadElement":
          case "SpreadElementPattern":
          case "SpreadPropertyPattern":
          case "RestElement":
            return cn3(e2, r2);
          case "FunctionDeclaration":
          case "FunctionExpression":
            return Dn2(e2, r2, t2, n2);
          case "ArrowFunctionExpression":
            return $i(e2, t2, r2, n2);
          case "YieldExpression":
            return i2.push("yield"), s2.delegate && i2.push("*"), s2.argument && i2.push(" ", r2("argument")), i2;
          case "AwaitExpression":
            if (i2.push("await"), s2.argument) {
              i2.push(" ", r2("argument"));
              let { parent: a2 } = e2;
              if (L3(a2) && a2.callee === s2 || q2(a2) && a2.object === s2) {
                i2 = [f2([E2, ...i2]), E2];
                let o2 = e2.findAncestor((c2) => c2.type === "AwaitExpression" || c2.type === "BlockStatement");
                if ((o2 == null ? void 0 : o2.type) !== "AwaitExpression" || !ie2(o2.argument, (c2) => c2 === s2))
                  return l2(i2);
              }
            }
            return i2;
          case "ExportDefaultDeclaration":
          case "ExportNamedDeclaration":
          case "ExportAllDeclaration":
            return gn3(e2, t2, r2);
          case "ImportDeclaration":
            return ca2(e2, t2, r2);
          case "ImportSpecifier":
          case "ExportSpecifier":
          case "ImportNamespaceSpecifier":
          case "ExportNamespaceSpecifier":
          case "ImportDefaultSpecifier":
          case "ExportDefaultSpecifier":
            return Ea2(e2, t2, r2);
          case "ImportAttribute":
            return yn3(e2, t2, r2);
          case "Import":
            return "import";
          case "Program":
          case "BlockStatement":
          case "StaticBlock":
            return Fn2(e2, t2, r2);
          case "ClassBody":
            return ra(e2, t2, r2);
          case "ThrowStatement":
            return Yi2(e2, t2, r2);
          case "ReturnStatement":
            return Xi2(e2, t2, r2);
          case "NewExpression":
          case "ImportExpression":
          case "OptionalCallExpression":
          case "CallExpression":
            return Vr2(e2, t2, r2);
          case "ObjectExpression":
          case "ObjectPattern":
          case "RecordExpression":
            return dt3(e2, t2, r2);
          case "Property":
            return gt2(s2) ? mr2(e2, t2, r2) : yn3(e2, t2, r2);
          case "ObjectProperty":
            return yn3(e2, t2, r2);
          case "ObjectMethod":
            return mr2(e2, t2, r2);
          case "Decorator":
            return ["@", r2("expression")];
          case "ArrayExpression":
          case "ArrayPattern":
          case "TupleExpression":
            return Yt2(e2, t2, r2);
          case "SequenceExpression": {
            let { parent: a2 } = e2;
            if (a2.type === "ExpressionStatement" || a2.type === "ForStatement") {
              let o2 = [];
              return e2.each(({ isFirst: c2 }) => {
                c2 ? o2.push(r2()) : o2.push(",", f2([x2, r2()]));
              }, "expressions"), l2(o2);
            }
            return l2(P2([",", x2], e2.map(r2, "expressions")));
          }
          case "ThisExpression":
            return "this";
          case "Super":
            return "super";
          case "Directive":
            return [r2("value"), u2];
          case "UnaryExpression":
            return i2.push(s2.operator), /[a-z]$/u.test(s2.operator) && i2.push(" "), d2(s2.argument) ? i2.push(l2(["(", f2([E2, r2("argument")]), E2, ")"])) : i2.push(r2("argument")), i2;
          case "UpdateExpression":
            return [s2.prefix ? s2.operator : "", r2("argument"), s2.prefix ? "" : s2.operator];
          case "ConditionalExpression":
            return Vt2(e2, t2, r2, n2);
          case "VariableDeclaration": {
            let a2 = e2.map(r2, "declarations"), o2 = e2.parent, c2 = o2.type === "ForStatement" || o2.type === "ForInStatement" || o2.type === "ForOfStatement", m = s2.declarations.some((y3) => y3.init), D;
            return a2.length === 1 && !d2(s2.declarations[0]) ? D = a2[0] : a2.length > 0 && (D = f2(a2[0])), i2 = [$2(e2), s2.kind, D ? [" ", D] : "", f2(a2.slice(1).map((y3) => [",", m && !c2 ? F : x2, y3]))], c2 && o2.body !== s2 || i2.push(u2), l2(i2);
          }
          case "WithStatement":
            return l2(["with (", r2("object"), ")", ft2(s2.body, r2("body"))]);
          case "IfStatement": {
            let a2 = ft2(s2.consequent, r2("consequent")), o2 = l2(["if (", l2([f2([E2, r2("test")]), E2]), ")", a2]);
            if (i2.push(o2), s2.alternate) {
              let c2 = d2(s2.consequent, g2.Trailing | g2.Line) || wr2(s2), m = s2.consequent.type === "BlockStatement" && !c2;
              i2.push(m ? " " : F), d2(s2, g2.Dangling) && i2.push(M3(e2, t2), c2 ? F : " "), i2.push("else", l2(ft2(s2.alternate, r2("alternate"), s2.alternate.type === "IfStatement")));
            }
            return i2;
          }
          case "ForStatement": {
            let a2 = ft2(s2.body, r2("body")), o2 = M3(e2, t2), c2 = o2 ? [o2, E2] : "";
            return !s2.init && !s2.test && !s2.update ? [c2, l2(["for (;;)", a2])] : [c2, l2(["for (", l2([f2([E2, r2("init"), ";", x2, r2("test"), ";", x2, r2("update")]), E2]), ")", a2])];
          }
          case "WhileStatement":
            return l2(["while (", l2([f2([E2, r2("test")]), E2]), ")", ft2(s2.body, r2("body"))]);
          case "ForInStatement":
            return l2(["for (", r2("left"), " in ", r2("right"), ")", ft2(s2.body, r2("body"))]);
          case "ForOfStatement":
            return l2(["for", s2.await ? " await" : "", " (", r2("left"), " of ", r2("right"), ")", ft2(s2.body, r2("body"))]);
          case "DoWhileStatement": {
            let a2 = ft2(s2.body, r2("body"));
            return i2 = [l2(["do", a2])], s2.body.type === "BlockStatement" ? i2.push(" ") : i2.push(F), i2.push("while (", l2([f2([E2, r2("test")]), E2]), ")", u2), i2;
          }
          case "DoExpression":
            return [s2.async ? "async " : "", "do ", r2("body")];
          case "BreakStatement":
          case "ContinueStatement":
            return i2.push(s2.type === "BreakStatement" ? "break" : "continue"), s2.label && i2.push(" ", r2("label")), i2.push(u2), i2;
          case "LabeledStatement":
            return s2.body.type === "EmptyStatement" ? [r2("label"), ":;"] : [r2("label"), ": ", r2("body")];
          case "TryStatement":
            return ["try ", r2("block"), s2.handler ? [" ", r2("handler")] : "", s2.finalizer ? [" finally ", r2("finalizer")] : ""];
          case "CatchClause":
            if (s2.param) {
              let a2 = d2(s2.param, (c2) => !re3(c2) || c2.leading && te2(t2.originalText, k(c2)) || c2.trailing && te2(t2.originalText, R3(c2), { backwards: true })), o2 = r2("param");
              return ["catch ", a2 ? ["(", f2([E2, o2]), E2, ") "] : ["(", o2, ") "], r2("body")];
            }
            return ["catch ", r2("body")];
          case "SwitchStatement":
            return [l2(["switch (", f2([E2, r2("discriminant")]), E2, ")"]), " {", s2.cases.length > 0 ? f2([F, P2(F, e2.map(({ node: a2, isLast: o2 }) => [r2(), !o2 && pe2(a2, t2) ? F : ""], "cases"))]) : "", F, "}"];
          case "SwitchCase": {
            s2.test ? i2.push("case ", r2("test"), ":") : i2.push("default:"), d2(s2, g2.Dangling) && i2.push(" ", M3(e2, t2));
            let a2 = s2.consequent.filter((o2) => o2.type !== "EmptyStatement");
            if (a2.length > 0) {
              let o2 = yr3(e2, t2, r2, "consequent");
              i2.push(a2.length === 1 && a2[0].type === "BlockStatement" ? [" ", o2] : f2([F, o2]));
            }
            return i2;
          }
          case "DebuggerStatement":
            return ["debugger", u2];
          case "ClassDeclaration":
          case "ClassExpression":
            return Tn3(e2, t2, r2);
          case "ClassMethod":
          case "ClassPrivateMethod":
          case "MethodDefinition":
            return dn3(e2, t2, r2);
          case "ClassProperty":
          case "PropertyDefinition":
          case "ClassPrivateProperty":
          case "ClassAccessorProperty":
          case "AccessorProperty":
            return xn3(e2, t2, r2);
          case "TemplateElement":
            return Ie3(s2.value.raw);
          case "TemplateLiteral":
            return qr2(e2, r2, t2);
          case "TaggedTemplateExpression":
            return Uu3(e2, r2);
          case "PrivateIdentifier":
            return ["#", s2.name];
          case "PrivateName":
            return ["#", r2("id")];
          case "TopicReference":
            return "%";
          case "ArgumentPlaceholder":
            return "?";
          case "ModuleExpression":
            return ["module ", r2("body")];
          case "InterpreterDirective":
          default:
            throw new Me3(s2, "ESTree");
        }
      }
      function Sn3(e2, t2, r2) {
        let { parent: n2, node: s2, key: u2 } = e2, i2 = [r2("expression")];
        switch (s2.type) {
          case "AsConstExpression":
            i2.push(" as const");
            break;
          case "AsExpression":
          case "TSAsExpression":
            i2.push(" as ", r2("typeAnnotation"));
            break;
          case "SatisfiesExpression":
          case "TSSatisfiesExpression":
            i2.push(" satisfies ", r2("typeAnnotation"));
            break;
        }
        return u2 === "callee" && L3(n2) || u2 === "object" && q2(n2) ? l2([f2([E2, ...i2]), E2]) : i2;
      }
      function Aa(e2, t2, r2) {
        let { node: n2 } = e2, s2 = [$2(e2), "component"];
        n2.id && s2.push(" ", r2("id")), s2.push(r2("typeParameters"));
        let u2 = Vl(e2, r2, t2);
        return n2.rendersType ? s2.push(l2([u2, " ", r2("rendersType")])) : s2.push(l2([u2])), n2.body && s2.push(" ", r2("body")), t2.semi && n2.type === "DeclareComponent" && s2.push(";"), s2;
      }
      function Vl(e2, t2, r2) {
        let { node: n2 } = e2, s2 = n2.params;
        if (n2.rest && (s2 = [...s2, n2.rest]), s2.length === 0)
          return ["(", M3(e2, r2, { filter: (i2) => ge2(r2.originalText, k(i2)) === ")" }), ")"];
        let u2 = [];
        return Kl(e2, (i2, a2) => {
          let o2 = a2 === s2.length - 1;
          o2 && n2.rest && u2.push("..."), u2.push(t2()), !o2 && (u2.push(","), pe2(s2[a2], r2) ? u2.push(F, F) : u2.push(x2));
        }), ["(", f2([E2, ...u2]), b3(ae2(r2, "all") && !$l(n2, s2) ? "," : ""), E2, ")"];
      }
      function $l(e2, t2) {
        var r2;
        return e2.rest || ((r2 = O2(false, t2, -1)) == null ? void 0 : r2.type) === "RestElement";
      }
      function Kl(e2, t2) {
        let { node: r2 } = e2, n2 = 0, s2 = (u2) => t2(u2, n2++);
        e2.each(s2, "params"), r2.rest && e2.call(s2, "rest");
      }
      function Ta(e2, t2, r2) {
        let { node: n2 } = e2;
        return n2.shorthand ? r2("local") : [r2("name"), " as ", r2("local")];
      }
      function da2(e2, t2, r2) {
        let { node: n2 } = e2, s2 = [];
        return n2.name && s2.push(r2("name"), n2.optional ? "?: " : ": "), s2.push(r2("typeAnnotation")), s2;
      }
      function xa2(e2, t2, r2) {
        return dt3(e2, r2, t2);
      }
      function Bn3(e2, t2) {
        let { node: r2 } = e2, n2 = t2("id");
        r2.computed && (n2 = ["[", n2, "]"]);
        let s2 = "";
        return r2.initializer && (s2 = t2("initializer")), r2.init && (s2 = t2("init")), s2 ? [n2, " = ", s2] : n2;
      }
      function ha2(e2, t2, r2) {
        let { node: n2 } = e2, s2;
        if (n2.type === "EnumSymbolBody" || n2.explicitType)
          switch (n2.type) {
            case "EnumBooleanBody":
              s2 = "boolean";
              break;
            case "EnumNumberBody":
              s2 = "number";
              break;
            case "EnumBigIntBody":
              s2 = "bigint";
              break;
            case "EnumStringBody":
              s2 = "string";
              break;
            case "EnumSymbolBody":
              s2 = "symbol";
              break;
          }
        return [s2 ? `of ${s2} ` : "", xa2(e2, t2, r2)];
      }
      function bn3(e2, t2, r2) {
        let { node: n2 } = e2;
        return [$2(e2), n2.const ? "const " : "", "enum ", t2("id"), " ", n2.type === "TSEnumDeclaration" ? xa2(e2, t2, r2) : t2("body")];
      }
      function Sa2(e2, t2, r2) {
        let { node: n2 } = e2, s2 = ["hook"];
        n2.id && s2.push(" ", r2("id"));
        let u2 = Je2(e2, r2, t2, false, true), i2 = Ht2(e2, r2), a2 = ot3(n2, i2);
        return s2.push(l2([a2 ? l2(u2) : u2, i2]), n2.body ? " " : "", r2("body")), s2;
      }
      function Ba(e2, t2, r2) {
        let { node: n2 } = e2, s2 = [$2(e2), "hook"];
        return n2.id && s2.push(" ", r2("id")), t2.semi && s2.push(";"), s2;
      }
      function ga2(e2) {
        var r2;
        let { node: t2 } = e2;
        return t2.type === "HookTypeAnnotation" && ((r2 = e2.getParentNode(2)) == null ? void 0 : r2.type) === "DeclareHook";
      }
      function ba2(e2, t2, r2) {
        let { node: n2 } = e2, s2 = [];
        s2.push(ga2(e2) ? "" : "hook ");
        let u2 = Je2(e2, r2, t2, false, true), i2 = [];
        return i2.push(ga2(e2) ? ": " : " => ", r2("returnType")), ot3(n2, i2) && (u2 = l2(u2)), s2.push(u2, i2), l2(s2);
      }
      function Pn3(e2, t2, r2) {
        let { node: n2 } = e2, s2 = [$2(e2), "interface"], u2 = [], i2 = [];
        n2.type !== "InterfaceTypeAnnotation" && u2.push(" ", r2("id"), r2("typeParameters"));
        let a2 = n2.typeParameters && !d2(n2.typeParameters, g2.Trailing | g2.Line);
        return w2(n2.extends) && i2.push(a2 ? b3(" ", x2, { groupId: Dr2(n2.typeParameters) }) : x2, "extends ", (n2.extends.length === 1 ? mu2 : f2)(P2([",", x2], e2.map(r2, "extends")))), d2(n2.id, g2.Trailing) || w2(n2.extends) ? a2 ? s2.push(l2([...u2, f2(i2)])) : s2.push(l2(f2([...u2, ...i2]))) : s2.push(...u2, ...i2), s2.push(" ", r2("body")), l2(s2);
      }
      function Pa(e2, t2, r2) {
        let { node: n2 } = e2;
        if (Sr2(n2))
          return n2.type.slice(0, -14).toLowerCase();
        let s2 = t2.semi ? ";" : "";
        switch (n2.type) {
          case "ComponentDeclaration":
          case "DeclareComponent":
          case "ComponentTypeAnnotation":
            return Aa(e2, t2, r2);
          case "ComponentParameter":
            return Ta(e2, t2, r2);
          case "ComponentTypeParameter":
            return da2(e2, t2, r2);
          case "HookDeclaration":
            return Sa2(e2, t2, r2);
          case "DeclareHook":
            return Ba(e2, t2, r2);
          case "HookTypeAnnotation":
            return ba2(e2, t2, r2);
          case "DeclareClass":
            return Tn3(e2, t2, r2);
          case "DeclareFunction":
            return [$2(e2), "function ", r2("id"), r2("predicate"), s2];
          case "DeclareModule":
            return ["declare module ", r2("id"), " ", r2("body")];
          case "DeclareModuleExports":
            return ["declare module.exports", Y2(e2, r2), s2];
          case "DeclareNamespace":
            return ["declare namespace ", r2("id"), " ", r2("body")];
          case "DeclareVariable":
            return [$2(e2), n2.kind ?? "var", " ", r2("id"), s2];
          case "DeclareExportDeclaration":
          case "DeclareExportAllDeclaration":
            return gn3(e2, t2, r2);
          case "DeclareOpaqueType":
          case "OpaqueType":
            return Mi2(e2, t2, r2);
          case "DeclareTypeAlias":
          case "TypeAlias":
            return Kr2(e2, t2, r2);
          case "IntersectionTypeAnnotation":
            return zr2(e2, t2, r2);
          case "UnionTypeAnnotation":
            return Qr2(e2, t2, r2);
          case "ConditionalTypeAnnotation":
            return Vt2(e2, t2, r2);
          case "InferTypeAnnotation":
            return tn3(e2, t2, r2);
          case "FunctionTypeAnnotation":
            return Zr2(e2, t2, r2);
          case "TupleTypeAnnotation":
            return Yt2(e2, t2, r2);
          case "TupleTypeLabeledElement":
            return nn3(e2, t2, r2);
          case "TupleTypeSpreadElement":
            return rn3(e2, t2, r2);
          case "GenericTypeAnnotation":
            return [r2("id"), Pt2(e2, t2, r2, "typeParameters")];
          case "IndexedAccessType":
          case "OptionalIndexedAccessType":
            return en3(e2, t2, r2);
          case "TypeAnnotation":
            return sn2(e2, t2, r2);
          case "TypeParameter":
            return An2(e2, t2, r2);
          case "TypeofTypeAnnotation":
            return an3(e2, r2);
          case "ExistsTypeAnnotation":
            return "*";
          case "ArrayTypeAnnotation":
            return un3(r2);
          case "DeclareEnum":
          case "EnumDeclaration":
            return bn3(e2, r2, t2);
          case "EnumBooleanBody":
          case "EnumNumberBody":
          case "EnumBigIntBody":
          case "EnumStringBody":
          case "EnumSymbolBody":
            return ha2(e2, r2, t2);
          case "EnumBooleanMember":
          case "EnumNumberMember":
          case "EnumBigIntMember":
          case "EnumStringMember":
          case "EnumDefaultedMember":
            return Bn3(e2, r2);
          case "FunctionTypeParam": {
            let u2 = n2.name ? r2("name") : e2.parent.this === n2 ? "this" : "";
            return [u2, V2(e2), u2 ? ": " : "", r2("typeAnnotation")];
          }
          case "DeclareInterface":
          case "InterfaceDeclaration":
          case "InterfaceTypeAnnotation":
            return Pn3(e2, t2, r2);
          case "ClassImplements":
          case "InterfaceExtends":
            return [r2("id"), r2("typeParameters")];
          case "NullableTypeAnnotation":
            return ["?", r2("typeAnnotation")];
          case "Variance": {
            let { kind: u2 } = n2;
            return ln3.ok(u2 === "plus" || u2 === "minus"), u2 === "plus" ? "+" : "-";
          }
          case "KeyofTypeAnnotation":
            return ["keyof ", r2("argument")];
          case "ObjectTypeCallProperty":
            return [n2.static ? "static " : "", r2("value")];
          case "ObjectTypeMappedTypeProperty":
            return zi(e2, t2, r2);
          case "ObjectTypeIndexer":
            return [n2.static ? "static " : "", n2.variance ? r2("variance") : "", "[", r2("id"), n2.id ? ": " : "", r2("key"), "]: ", r2("value")];
          case "ObjectTypeProperty": {
            let u2 = "";
            return n2.proto ? u2 = "proto " : n2.static && (u2 = "static "), [u2, n2.kind !== "init" ? n2.kind + " " : "", n2.variance ? r2("variance") : "", Et3(e2, t2, r2), V2(e2), gt2(n2) ? "" : ": ", r2("value")];
          }
          case "ObjectTypeAnnotation":
            return dt3(e2, t2, r2);
          case "ObjectTypeInternalSlot":
            return [n2.static ? "static " : "", "[[", r2("id"), "]]", V2(e2), n2.method ? "" : ": ", r2("value")];
          case "ObjectTypeSpreadProperty":
            return cn3(e2, r2);
          case "QualifiedTypeofIdentifier":
          case "QualifiedTypeIdentifier":
            return [r2("qualification"), ".", r2("id")];
          case "NullLiteralTypeAnnotation":
            return "null";
          case "BooleanLiteralTypeAnnotation":
            return String(n2.value);
          case "StringLiteralTypeAnnotation":
            return Ie3(tt2(fe2(n2), t2));
          case "NumberLiteralTypeAnnotation":
            return Ze2(n2.raw ?? n2.extra.raw);
          case "BigIntLiteralTypeAnnotation":
            return hn3(n2.raw ?? n2.extra.raw);
          case "TypeCastExpression":
            return ["(", r2("expression"), Y2(e2, r2), ")"];
          case "TypePredicate":
            return on2(e2, r2);
          case "TypeOperator":
            return [n2.operator, " ", r2("typeAnnotation")];
          case "TypeParameterDeclaration":
          case "TypeParameterInstantiation":
            return Pt2(e2, t2, r2, "params");
          case "InferredPredicate":
          case "DeclaredPredicate":
            return [e2.key === "predicate" && e2.parent.type !== "DeclareFunction" && !e2.parent.returnType ? ": " : " ", "%checks", ...n2.type === "DeclaredPredicate" ? ["(", r2("value"), ")"] : []];
          case "AsExpression":
          case "AsConstExpression":
          case "SatisfiesExpression":
            return Sn3(e2, t2, r2);
        }
      }
      function ka2(e2, t2, r2) {
        var i2;
        let { node: n2 } = e2;
        if (!n2.type.startsWith("TS"))
          return;
        if (Br2(n2))
          return n2.type.slice(2, -7).toLowerCase();
        let s2 = t2.semi ? ";" : "", u2 = [];
        switch (n2.type) {
          case "TSThisType":
            return "this";
          case "TSTypeAssertion": {
            let a2 = !(U2(n2.expression) || se2(n2.expression)), o2 = l2(["<", f2([E2, r2("typeAnnotation")]), E2, ">"]), c2 = [b3("("), f2([E2, r2("expression")]), E2, b3(")")];
            return a2 ? ze2([[o2, r2("expression")], [o2, l2(c2, { shouldBreak: true })], [o2, r2("expression")]]) : l2([o2, r2("expression")]);
          }
          case "TSDeclareFunction":
            return Dn2(e2, r2, t2);
          case "TSExportAssignment":
            return ["export = ", r2("expression"), s2];
          case "TSModuleBlock":
            return Fn2(e2, t2, r2);
          case "TSInterfaceBody":
          case "TSTypeLiteral":
            return dt3(e2, t2, r2);
          case "TSTypeAliasDeclaration":
            return Kr2(e2, t2, r2);
          case "TSQualifiedName":
            return [r2("left"), ".", r2("right")];
          case "TSAbstractMethodDefinition":
          case "TSDeclareMethod":
            return dn3(e2, t2, r2);
          case "TSAbstractAccessorProperty":
          case "TSAbstractPropertyDefinition":
            return xn3(e2, t2, r2);
          case "TSInterfaceHeritage":
          case "TSClassImplements":
          case "TSExpressionWithTypeArguments":
          case "TSInstantiationExpression":
            return [r2("expression"), r2(n2.typeArguments ? "typeArguments" : "typeParameters")];
          case "TSTemplateLiteralType":
            return qr2(e2, r2, t2);
          case "TSNamedTupleMember":
            return nn3(e2, t2, r2);
          case "TSRestType":
            return rn3(e2, t2, r2);
          case "TSOptionalType":
            return [r2("typeAnnotation"), "?"];
          case "TSInterfaceDeclaration":
            return Pn3(e2, t2, r2);
          case "TSTypeParameterDeclaration":
          case "TSTypeParameterInstantiation":
            return Pt2(e2, t2, r2, "params");
          case "TSTypeParameter":
            return An2(e2, t2, r2);
          case "TSAsExpression":
          case "TSSatisfiesExpression":
            return Sn3(e2, t2, r2);
          case "TSArrayType":
            return un3(r2);
          case "TSPropertySignature":
            return [n2.readonly ? "readonly " : "", Et3(e2, t2, r2), V2(e2), Y2(e2, r2)];
          case "TSParameterProperty":
            return [Xt(n2), n2.static ? "static " : "", n2.override ? "override " : "", n2.readonly ? "readonly " : "", r2("parameter")];
          case "TSTypeQuery":
            return an3(e2, r2);
          case "TSIndexSignature": {
            let a2 = n2.parameters.length > 1 ? b3(ae2(t2) ? "," : "") : "", o2 = l2([f2([E2, P2([", ", E2], e2.map(r2, "parameters"))]), a2, E2]), c2 = e2.parent.type === "ClassBody" && e2.key === "body";
            return [c2 && n2.static ? "static " : "", n2.readonly ? "readonly " : "", "[", n2.parameters ? o2 : "", "]", Y2(e2, r2), c2 ? s2 : ""];
          }
          case "TSTypePredicate":
            return on2(e2, r2);
          case "TSNonNullExpression":
            return [r2("expression"), "!"];
          case "TSImportType":
            return [n2.isTypeOf ? "typeof " : "", "import(", r2("argument"), ")", n2.qualifier ? [".", r2("qualifier")] : "", Pt2(e2, t2, r2, n2.typeArguments ? "typeArguments" : "typeParameters")];
          case "TSLiteralType":
            return r2("literal");
          case "TSIndexedAccessType":
            return en3(e2, t2, r2);
          case "TSTypeOperator":
            return [n2.operator, " ", r2("typeAnnotation")];
          case "TSMappedType":
            return Qi2(e2, t2, r2);
          case "TSMethodSignature": {
            let a2 = n2.kind && n2.kind !== "method" ? `${n2.kind} ` : "";
            u2.push(Xt(n2), a2, n2.computed ? "[" : "", r2("key"), n2.computed ? "]" : "", V2(e2));
            let o2 = Je2(e2, r2, t2, false, true), c2 = n2.returnType ? "returnType" : "typeAnnotation", m = n2[c2], D = m ? Y2(e2, r2, c2) : "", y3 = ot3(n2, D);
            return u2.push(y3 ? l2(o2) : o2), m && u2.push(l2(D)), l2(u2);
          }
          case "TSNamespaceExportDeclaration":
            return ["export as namespace ", r2("id"), t2.semi ? ";" : ""];
          case "TSEnumDeclaration":
            return bn3(e2, r2, t2);
          case "TSEnumMember":
            return Bn3(e2, r2);
          case "TSImportEqualsDeclaration":
            return [n2.isExport ? "export " : "", "import ", Is2(n2, false), r2("id"), " = ", r2("moduleReference"), t2.semi ? ";" : ""];
          case "TSExternalModuleReference":
            return ["require(", r2("expression"), ")"];
          case "TSModuleDeclaration": {
            let { parent: a2 } = e2, o2 = a2.type === "TSModuleDeclaration", c2 = ((i2 = n2.body) == null ? void 0 : i2.type) === "TSModuleDeclaration";
            if (o2)
              u2.push(".");
            else if (u2.push($2(e2)), !(n2.kind === "global" || n2.global)) {
              let D = n2.kind ?? (Q3(n2.id) || fr3(t2, R3(n2), R3(n2.id)).trim().endsWith("module") ? "module" : "namespace");
              u2.push(D, " ");
            }
            return u2.push(r2("id")), c2 ? u2.push(r2("body")) : n2.body ? u2.push(" ", l2(r2("body"))) : u2.push(s2), u2;
          }
          case "TSConditionalType":
            return Vt2(e2, t2, r2);
          case "TSInferType":
            return tn3(e2, t2, r2);
          case "TSIntersectionType":
            return zr2(e2, t2, r2);
          case "TSUnionType":
            return Qr2(e2, t2, r2);
          case "TSFunctionType":
          case "TSCallSignatureDeclaration":
          case "TSConstructorType":
          case "TSConstructSignatureDeclaration":
            return Zr2(e2, t2, r2);
          case "TSTupleType":
            return Yt2(e2, t2, r2);
          case "TSTypeReference":
            return [r2("typeName"), Pt2(e2, t2, r2, n2.typeArguments ? "typeArguments" : "typeParameters")];
          case "TSTypeAnnotation":
            return sn2(e2, t2, r2);
          case "TSEmptyBodyFunctionExpression":
            return fn3(e2, t2, r2);
          case "TSJSDocAllType":
            return "*";
          case "TSJSDocUnknownType":
            return "?";
          case "TSJSDocNullableType":
            return ds(e2, r2, "?");
          case "TSJSDocNonNullableType":
            return ds(e2, r2, "!");
          case "TSParenthesizedType":
          default:
            throw new Me3(n2, "TypeScript");
        }
      }
      function zl(e2, t2, r2, n2) {
        if (Xr2(e2))
          return ci3(e2, t2);
        for (let s2 of [Ti2, Ei, Pa, ka2, Ca]) {
          let u2 = s2(e2, t2, r2, n2);
          if (u2 !== void 0)
            return u2;
        }
      }
      var Ql = v2(["ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "ClassPrivateProperty", "MethodDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod"]);
      function Zl(e2, t2, r2, n2) {
        var D;
        e2.isRoot && ((D = t2.__onHtmlBindingRoot) == null || D.call(t2, e2.node, t2));
        let s2 = zl(e2, t2, r2, n2);
        if (!s2)
          return "";
        let { node: u2 } = e2;
        if (Ql(u2))
          return s2;
        let i2 = w2(u2.decorators), a2 = xi(e2, t2, r2), o2 = u2.type === "ClassExpression";
        if (i2 && !o2)
          return ir3(s2, (y3) => l2([a2, y3]));
        let c2 = Be3(e2, t2), m = na(e2, t2);
        return !a2 && !c2 && !m ? s2 : ir3(s2, (y3) => [m ? ";" : "", c2 ? "(" : "", c2 && o2 && i2 ? [f2([x2, a2, y3]), x2] : [a2, y3], c2 ? ")" : ""]);
      }
      var Ia2 = Zl;
      var em = { avoidAstMutation: true };
      var La = [{ linguistLanguageId: 174, name: "JSON.stringify", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".importmap"], filenames: ["package.json", "package-lock.json", "composer.json"], parsers: ["json-stringify"], vscodeLanguageIds: ["json"] }, { linguistLanguageId: 174, name: "JSON", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".all-contributorsrc", ".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "flake.lock", "mcmod.info", ".babelrc", ".jscsrc", ".jshintrc", ".jslintrc", ".swcrc"], parsers: ["json"], vscodeLanguageIds: ["json"] }, { linguistLanguageId: 423, name: "JSON with Comments", type: "data", color: "#292929", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".code-snippets", ".code-workspace", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [], parsers: ["jsonc"], vscodeLanguageIds: ["jsonc"] }, { linguistLanguageId: 175, name: "JSON5", type: "data", color: "#267CB9", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", parsers: ["json5"], vscodeLanguageIds: ["json5"] }];
      var _s2 = {};
      Ar3(_s2, { getVisitorKeys: () => Oa, massageAstNode: () => ja, print: () => nm });
      var tm = { JsonRoot: ["node"], ArrayExpression: ["elements"], ObjectExpression: ["properties"], ObjectProperty: ["key", "value"], UnaryExpression: ["argument"], NullLiteral: [], BooleanLiteral: [], StringLiteral: [], NumericLiteral: [], Identifier: [], TemplateLiteral: ["quasis"], TemplateElement: [] }, wa2 = tm;
      var rm = hr2(wa2), Oa = rm;
      function nm(e2, t2, r2) {
        let { node: n2 } = e2;
        switch (n2.type) {
          case "JsonRoot":
            return [r2("node"), F];
          case "ArrayExpression": {
            if (n2.elements.length === 0)
              return "[]";
            let s2 = e2.map(() => e2.node === null ? "null" : r2(), "elements");
            return ["[", f2([F, P2([",", F], s2)]), F, "]"];
          }
          case "ObjectExpression":
            return n2.properties.length === 0 ? "{}" : ["{", f2([F, P2([",", F], e2.map(r2, "properties"))]), F, "}"];
          case "ObjectProperty":
            return [r2("key"), ": ", r2("value")];
          case "UnaryExpression":
            return [n2.operator === "+" ? "" : n2.operator, r2("argument")];
          case "NullLiteral":
            return "null";
          case "BooleanLiteral":
            return n2.value ? "true" : "false";
          case "StringLiteral":
            return JSON.stringify(n2.value);
          case "NumericLiteral":
            return _a(e2) ? JSON.stringify(String(n2.value)) : JSON.stringify(n2.value);
          case "Identifier":
            return _a(e2) ? JSON.stringify(n2.name) : n2.name;
          case "TemplateLiteral":
            return r2(["quasis", 0]);
          case "TemplateElement":
            return JSON.stringify(n2.value.cooked);
          default:
            throw new Me3(n2, "JSON");
        }
      }
      function _a(e2) {
        return e2.key === "key" && e2.parent.type === "ObjectProperty";
      }
      var sm = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
      function ja(e2, t2) {
        let { type: r2 } = e2;
        if (r2 === "ObjectProperty") {
          let { key: n2 } = e2;
          n2.type === "Identifier" ? t2.key = { type: "StringLiteral", value: n2.name } : n2.type === "NumericLiteral" && (t2.key = { type: "StringLiteral", value: String(n2.value) });
          return;
        }
        if (r2 === "UnaryExpression" && e2.operator === "+")
          return t2.argument;
        if (r2 === "ArrayExpression") {
          for (let [n2, s2] of e2.elements.entries())
            s2 === null && t2.elements.splice(n2, 0, { type: "NullLiteral" });
          return;
        }
        if (r2 === "TemplateLiteral")
          return { type: "StringLiteral", value: e2.quasis[0].value.cooked };
      }
      ja.ignoredProperties = sm;
      var Er2 = { bracketSpacing: { category: "Common", type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { category: "Common", type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap prose.", choices: [{ value: "always", description: "Wrap prose if it exceeds the print width." }, { value: "never", description: "Do not wrap prose." }, { value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { category: "Common", type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { category: "Common", type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
      var kt3 = "JavaScript", um = { arrowParens: { category: kt3, type: "choice", default: "always", description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: Er2.bracketSameLine, bracketSpacing: Er2.bracketSpacing, jsxBracketSameLine: { category: kt3, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { category: kt3, type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, experimentalTernaries: { category: kt3, type: "boolean", default: false, description: "Use curious ternaries, with the question mark after the condition.", oppositeDescription: "Default behavior of ternaries; keep question marks on the same line as the consequent." }, singleQuote: Er2.singleQuote, jsxSingleQuote: { category: kt3, type: "boolean", default: false, description: "Use single quotes in JSX." }, quoteProps: { category: kt3, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { category: kt3, type: "choice", default: "all", description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "all", description: "Trailing commas wherever possible (including function arguments)." }, { value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }] }, singleAttributePerLine: Er2.singleAttributePerLine }, va2 = um;
      var im = { estree: Os2, "estree-json": _s2 }, am = [...Us2, ...La];
      return Xa(om);
    });
  }
});

// node_modules/@react-three/uikit/dist/font.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);

// node_modules/@pmndrs/uikit/dist/properties/alias.js
var borderAliases = {
  borderWidth: ["borderBottomWidth", "borderTopWidth", "borderLeftWidth", "borderRightWidth"],
  borderXWidth: ["borderLeftWidth", "borderRightWidth"],
  borderYWidth: ["borderTopWidth", "borderBottomWidth"]
};
var flexAliases = {
  ...borderAliases,
  inset: ["positionTop", "positionLeft", "positionRight", "positionBottom"],
  padding: ["paddingBottom", "paddingTop", "paddingLeft", "paddingRight"],
  paddingX: ["paddingLeft", "paddingRight"],
  paddingY: ["paddingTop", "paddingBottom"],
  margin: ["marginBottom", "marginTop", "marginLeft", "marginRight"],
  marginX: ["marginLeft", "marginRight"],
  marginY: ["marginTop", "marginBottom"],
  gap: ["gapRow", "gapColumn"]
};
var panelAliases = {
  borderRadius: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"],
  borderTopRadius: ["borderTopLeftRadius", "borderTopRightRadius"],
  borderLeftRadius: ["borderTopLeftRadius", "borderBottomLeftRadius"],
  borderRightRadius: ["borderTopRightRadius", "borderBottomRightRadius"],
  borderBottomRadius: ["borderBottomLeftRadius", "borderBottomRightRadius"]
};
var scrollbarAliases = {
  scrollbarBorderRadius: [
    "scrollbarBorderTopLeftRadius",
    "scrollbarBorderTopRightRadius",
    "scrollbarBorderBottomLeftRadius",
    "scrollbarBorderBottomRightRadius"
  ],
  scrollbarBorderTopRadius: ["scrollbarBorderTopLeftRadius", "scrollbarBorderTopRightRadius"],
  scrollbarBorderLeftRadius: ["scrollbarBorderTopLeftRadius", "scrollbarBorderBottomLeftRadius"],
  scrollbarBorderRightRadius: ["scrollbarBorderTopRightRadius", "scrollbarBorderBottomRightRadius"],
  scrollbarBorderBottomRadius: ["scrollbarBorderBottomLeftRadius", "scrollbarBorderBottomRightRadius"],
  scrollbarBorderWidth: [
    "scrollbarBorderBottomWidth",
    "scrollbarBorderTopWidth",
    "scrollbarBorderLeftWidth",
    "scrollbarBorderRightWidth"
  ],
  scrollbarBorderXWidth: ["scrollbarBorderLeftWidth", "scrollbarBorderRightWidth"],
  scrollbarBorderYWidth: ["scrollbarBorderTopWidth", "scrollbarBorderBottomWidth"]
};
var caretAliases = {
  caretBorderRadius: [
    "caretBorderTopLeftRadius",
    "caretBorderTopRightRadius",
    "caretBorderBottomLeftRadius",
    "caretBorderBottomRightRadius"
  ],
  caretBorderTopRadius: ["caretBorderTopLeftRadius", "caretBorderTopRightRadius"],
  caretBorderLeftRadius: ["caretBorderTopLeftRadius", "caretBorderBottomLeftRadius"],
  caretBorderRightRadius: ["caretBorderTopRightRadius", "caretBorderBottomRightRadius"],
  caretBorderBottomRadius: ["caretBorderBottomLeftRadius", "caretBorderBottomRightRadius"],
  caretBorderWidth: ["caretBorderBottomWidth", "caretBorderTopWidth", "caretBorderLeftWidth", "caretBorderRightWidth"],
  caretBorderXWidth: ["caretBorderLeftWidth", "caretBorderRightWidth"],
  caretBorderYWidth: ["caretBorderTopWidth", "caretBorderBottomWidth"]
};
var selectionAliases = {
  selectionBorderRadius: [
    "selectionBorderTopLeftRadius",
    "selectionBorderTopRightRadius",
    "selectionBorderBottomLeftRadius",
    "selectionBorderBottomRightRadius"
  ],
  selectionBorderTopRadius: ["selectionBorderTopLeftRadius", "selectionBorderTopRightRadius"],
  selectionBorderLeftRadius: ["selectionBorderTopLeftRadius", "selectionBorderBottomLeftRadius"],
  selectionBorderRightRadius: ["selectionBorderTopRightRadius", "selectionBorderBottomRightRadius"],
  selectionBorderBottomRadius: ["selectionBorderBottomLeftRadius", "selectionBorderBottomRightRadius"],
  selectionBorderWidth: [
    "selectionBorderBottomWidth",
    "selectionBorderTopWidth",
    "selectionBorderLeftWidth",
    "selectionBorderRightWidth"
  ],
  selectionBorderXWidth: ["selectionBorderLeftWidth", "selectionBorderRightWidth"],
  selectionBorderYWidth: ["selectionBorderTopWidth", "selectionBorderBottomWidth"]
};
var transformAliases = {
  transformScale: ["transformScaleX", "transformScaleY", "transformScaleZ"]
};
var allAliases = Object.assign({}, flexAliases, panelAliases, scrollbarAliases, transformAliases, caretAliases, selectionAliases);

// node_modules/@preact/signals-core/dist/signals-core.module.js
var i = Symbol.for("preact-signals");
function t() {
  if (!(s > 1)) {
    var i2, t2 = false;
    while (void 0 !== h) {
      var r2 = h;
      h = void 0;
      f++;
      while (void 0 !== r2) {
        var o2 = r2.o;
        r2.o = void 0;
        r2.f &= -3;
        if (!(8 & r2.f) && c(r2))
          try {
            r2.c();
          } catch (r3) {
            if (!t2) {
              i2 = r3;
              t2 = true;
            }
          }
        r2 = o2;
      }
    }
    f = 0;
    s--;
    if (t2)
      throw i2;
  } else
    s--;
}
function r(i2) {
  if (s > 0)
    return i2();
  s++;
  try {
    return i2();
  } finally {
    t();
  }
}
var o = void 0;
function n(i2) {
  var t2 = o;
  o = void 0;
  try {
    return i2();
  } finally {
    o = t2;
  }
}
var h = void 0;
var s = 0;
var f = 0;
var v = 0;
function e(i2) {
  if (void 0 !== o) {
    var t2 = i2.n;
    if (void 0 === t2 || t2.t !== o) {
      t2 = { i: 0, S: i2, p: o.s, n: void 0, t: o, e: void 0, x: void 0, r: t2 };
      if (void 0 !== o.s)
        o.s.n = t2;
      o.s = t2;
      i2.n = t2;
      if (32 & o.f)
        i2.S(t2);
      return t2;
    } else if (-1 === t2.i) {
      t2.i = 0;
      if (void 0 !== t2.n) {
        t2.n.p = t2.p;
        if (void 0 !== t2.p)
          t2.p.n = t2.n;
        t2.p = o.s;
        t2.n = void 0;
        o.s.n = t2;
        o.s = t2;
      }
      return t2;
    }
  }
}
function u(i2) {
  this.v = i2;
  this.i = 0;
  this.n = void 0;
  this.t = void 0;
}
u.prototype.brand = i;
u.prototype.h = function() {
  return true;
};
u.prototype.S = function(i2) {
  if (this.t !== i2 && void 0 === i2.e) {
    i2.x = this.t;
    if (void 0 !== this.t)
      this.t.e = i2;
    this.t = i2;
  }
};
u.prototype.U = function(i2) {
  if (void 0 !== this.t) {
    var t2 = i2.e, r2 = i2.x;
    if (void 0 !== t2) {
      t2.x = r2;
      i2.e = void 0;
    }
    if (void 0 !== r2) {
      r2.e = t2;
      i2.x = void 0;
    }
    if (i2 === this.t)
      this.t = r2;
  }
};
u.prototype.subscribe = function(i2) {
  var t2 = this;
  return E(function() {
    var r2 = t2.value, n2 = o;
    o = void 0;
    try {
      i2(r2);
    } finally {
      o = n2;
    }
  });
};
u.prototype.valueOf = function() {
  return this.value;
};
u.prototype.toString = function() {
  return this.value + "";
};
u.prototype.toJSON = function() {
  return this.value;
};
u.prototype.peek = function() {
  var i2 = o;
  o = void 0;
  try {
    return this.value;
  } finally {
    o = i2;
  }
};
Object.defineProperty(u.prototype, "value", { get: function() {
  var i2 = e(this);
  if (void 0 !== i2)
    i2.i = this.i;
  return this.v;
}, set: function(i2) {
  if (i2 !== this.v) {
    if (f > 100)
      throw new Error("Cycle detected");
    this.v = i2;
    this.i++;
    v++;
    s++;
    try {
      for (var r2 = this.t; void 0 !== r2; r2 = r2.x)
        r2.t.N();
    } finally {
      t();
    }
  }
} });
function d(i2) {
  return new u(i2);
}
function c(i2) {
  for (var t2 = i2.s; void 0 !== t2; t2 = t2.n)
    if (t2.S.i !== t2.i || !t2.S.h() || t2.S.i !== t2.i)
      return true;
  return false;
}
function a(i2) {
  for (var t2 = i2.s; void 0 !== t2; t2 = t2.n) {
    var r2 = t2.S.n;
    if (void 0 !== r2)
      t2.r = r2;
    t2.S.n = t2;
    t2.i = -1;
    if (void 0 === t2.n) {
      i2.s = t2;
      break;
    }
  }
}
function l(i2) {
  var t2 = i2.s, r2 = void 0;
  while (void 0 !== t2) {
    var o2 = t2.p;
    if (-1 === t2.i) {
      t2.S.U(t2);
      if (void 0 !== o2)
        o2.n = t2.n;
      if (void 0 !== t2.n)
        t2.n.p = o2;
    } else
      r2 = t2;
    t2.S.n = t2.r;
    if (void 0 !== t2.r)
      t2.r = void 0;
    t2 = o2;
  }
  i2.s = r2;
}
function y(i2) {
  u.call(this, void 0);
  this.x = i2;
  this.s = void 0;
  this.g = v - 1;
  this.f = 4;
}
(y.prototype = new u()).h = function() {
  this.f &= -3;
  if (1 & this.f)
    return false;
  if (32 == (36 & this.f))
    return true;
  this.f &= -5;
  if (this.g === v)
    return true;
  this.g = v;
  this.f |= 1;
  if (this.i > 0 && !c(this)) {
    this.f &= -2;
    return true;
  }
  var i2 = o;
  try {
    a(this);
    o = this;
    var t2 = this.x();
    if (16 & this.f || this.v !== t2 || 0 === this.i) {
      this.v = t2;
      this.f &= -17;
      this.i++;
    }
  } catch (i3) {
    this.v = i3;
    this.f |= 16;
    this.i++;
  }
  o = i2;
  l(this);
  this.f &= -2;
  return true;
};
y.prototype.S = function(i2) {
  if (void 0 === this.t) {
    this.f |= 36;
    for (var t2 = this.s; void 0 !== t2; t2 = t2.n)
      t2.S.S(t2);
  }
  u.prototype.S.call(this, i2);
};
y.prototype.U = function(i2) {
  if (void 0 !== this.t) {
    u.prototype.U.call(this, i2);
    if (void 0 === this.t) {
      this.f &= -33;
      for (var t2 = this.s; void 0 !== t2; t2 = t2.n)
        t2.S.U(t2);
    }
  }
};
y.prototype.N = function() {
  if (!(2 & this.f)) {
    this.f |= 6;
    for (var i2 = this.t; void 0 !== i2; i2 = i2.x)
      i2.t.N();
  }
};
Object.defineProperty(y.prototype, "value", { get: function() {
  if (1 & this.f)
    throw new Error("Cycle detected");
  var i2 = e(this);
  this.h();
  if (void 0 !== i2)
    i2.i = this.i;
  if (16 & this.f)
    throw this.v;
  return this.v;
} });
function w(i2) {
  return new y(i2);
}
function _(i2) {
  var r2 = i2.u;
  i2.u = void 0;
  if ("function" == typeof r2) {
    s++;
    var n2 = o;
    o = void 0;
    try {
      r2();
    } catch (t2) {
      i2.f &= -2;
      i2.f |= 8;
      g(i2);
      throw t2;
    } finally {
      o = n2;
      t();
    }
  }
}
function g(i2) {
  for (var t2 = i2.s; void 0 !== t2; t2 = t2.n)
    t2.S.U(t2);
  i2.x = void 0;
  i2.s = void 0;
  _(i2);
}
function p(i2) {
  if (o !== this)
    throw new Error("Out-of-order effect");
  l(this);
  o = i2;
  this.f &= -2;
  if (8 & this.f)
    g(this);
  t();
}
function b(i2) {
  this.x = i2;
  this.u = void 0;
  this.s = void 0;
  this.o = void 0;
  this.f = 32;
}
b.prototype.c = function() {
  var i2 = this.S();
  try {
    if (8 & this.f)
      return;
    if (void 0 === this.x)
      return;
    var t2 = this.x();
    if ("function" == typeof t2)
      this.u = t2;
  } finally {
    i2();
  }
};
b.prototype.S = function() {
  if (1 & this.f)
    throw new Error("Cycle detected");
  this.f |= 1;
  this.f &= -9;
  _(this);
  a(this);
  s++;
  var i2 = o;
  o = this;
  return p.bind(this, i2);
};
b.prototype.N = function() {
  if (!(2 & this.f)) {
    this.f |= 2;
    this.o = h;
    h = this;
  }
};
b.prototype.d = function() {
  this.f |= 8;
  if (!(1 & this.f))
    g(this);
};
function E(i2) {
  var t2 = new b(i2);
  try {
    t2.c();
  } catch (i3) {
    t2.d();
    throw i3;
  }
  return t2.d.bind(t2);
}

// node_modules/@pmndrs/uikit/dist/utils.js
var percentageRegex = /(-?\d+(?:\.\d+)?)%/;
function unsubscribeSubscriptions(subscriptions) {
  const length = subscriptions.length;
  for (let i2 = 0; i2 < length; i2++) {
    subscriptions[i2]();
  }
  subscriptions.length = 0;
}
function initialize(inits, subscriptions) {
  const length = inits.length;
  for (let i2 = 0; i2 < length; i2++) {
    const unsubscribe = inits[i2](subscriptions);
    if (Array.isArray(unsubscribe)) {
      continue;
    }
    subscriptions.push(unsubscribe);
  }
}
var alignmentXMap = { left: 0.5, center: 0, middle: 0, right: -0.5 };
var alignmentYMap = { top: -0.5, center: 0, middle: 0, bottom: 0.5 };
var alignmentZMap = { back: -0.5, center: 0, middle: 0, front: 0.5 };
function fitNormalizedContentInside(offsetTarget, scaleTarget, size, paddingInset, borderInset, pixelSize, aspectRatio) {
  if (size.value == null || paddingInset.value == null || borderInset.value == null) {
    return;
  }
  const [width, height] = size.value;
  const [pTop, pRight, pBottom, pLeft] = paddingInset.value;
  const [bTop, bRight, bBottom, bLeft] = borderInset.value;
  const topInset = pTop + bTop;
  const rightInset = pRight + bRight;
  const bottomInset = pBottom + bBottom;
  const leftInset = pLeft + bLeft;
  offsetTarget.set((leftInset - rightInset) * 0.5 * pixelSize, (bottomInset - topInset) * 0.5 * pixelSize, 0);
  const innerWidth = width - leftInset - rightInset;
  const innerHeight = height - topInset - bottomInset;
  const flexRatio = innerWidth / innerHeight;
  if (flexRatio > aspectRatio) {
    scaleTarget.setScalar(innerHeight * pixelSize);
    return;
  }
  scaleTarget.setScalar(innerWidth * pixelSize / aspectRatio);
}
function readReactive(value) {
  return value instanceof u ? value.value : value;
}
function createConditionalPropertyTranslator(condition) {
  const signalMap2 = /* @__PURE__ */ new Map();
  return (properties, merged) => {
    if (typeof properties != "object") {
      throw new Error(`Invalid properties "${properties}"`);
    }
    for (const key in properties) {
      const value = properties[key];
      if (value === void 0) {
        return;
      }
      let result = signalMap2.get(value);
      if (result == null) {
        signalMap2.set(value, result = w(() => condition() ? readReactive(value) : void 0));
      }
      merged.add(key, result);
    }
  };
}
function computedBorderInset(propertiesSignal, keys) {
  const sizes = keys.map((key) => computedInheritableProperty(propertiesSignal, key, 0));
  return w(() => sizes.map((size) => size.value));
}

// node_modules/@pmndrs/uikit/dist/properties/utils.js
function computedInheritableProperty(propertiesSignal, key, defaultValue) {
  return w(() => propertiesSignal.value.read(key, defaultValue));
}
function computedNonInheritableProperty(style, properties, key, defaultValue) {
  return w(() => {
    var _a, _b;
    return readReactive((_a = style.value) == null ? void 0 : _a[key]) ?? readReactive((_b = properties.value) == null ? void 0 : _b[key]) ?? defaultValue;
  });
}

// node_modules/@pmndrs/uikit/dist/properties/default.js
function traverseProperties(style, properties, defaultProperties, fn3) {
  if (defaultProperties != null) {
    traverseClasses(defaultProperties.classes, fn3);
    fn3(defaultProperties);
  }
  if (properties != null) {
    traverseClasses(properties.classes, fn3);
    fn3(properties);
  }
  if (style != null) {
    traverseClasses(style.classes, fn3);
    fn3(style);
  }
}
function traverseClasses(classes, fn3) {
  if (classes == null) {
    return;
  }
  if (!Array.isArray(classes)) {
    fn3(classes);
    return;
  }
  const classesLength = classes.length;
  for (let i2 = 0; i2 < classesLength; i2++) {
    fn3(classes[i2]);
  }
  return;
}

// node_modules/@pmndrs/uikit/dist/properties/immediate.js
function setupImmediateProperties(propertiesSignal, activeSignal, hasProperty, setProperty, subscriptions) {
  let active = false;
  let currentProperties;
  let propertySubscriptions = {};
  subscriptions.push(E(() => {
    const newProperties = propertiesSignal.value;
    if (active) {
      applyProperties(hasProperty, newProperties, currentProperties, propertySubscriptions, setProperty);
    }
    currentProperties = newProperties;
  }), E(() => {
    active = activeSignal.value;
    if (!active) {
      return;
    }
    if (currentProperties == null) {
      return;
    }
    applyProperties(hasProperty, currentProperties, void 0, propertySubscriptions, setProperty);
    return () => {
      unsubscribeProperties(propertySubscriptions);
      propertySubscriptions = {};
    };
  }));
}
function applyProperties(hasProperty, currentProperties, oldProperties, subscriptions, setProperty) {
  const onNew = (key) => (
    //subscribe and write property
    subscriptions[key] = E(() => setProperty(key, currentProperties.read(key, void 0)))
  );
  const onDelete = (key) => {
    var _a;
    (_a = subscriptions[key]) == null ? void 0 : _a.call(subscriptions);
    delete subscriptions[key];
    if (oldProperties.read(key, void 0) === void 0) {
      return;
    }
    setProperty(key, void 0);
  };
  const onChange = (key) => {
    var _a;
    (_a = subscriptions[key]) == null ? void 0 : _a.call(subscriptions);
    onNew(key);
  };
  n(() => currentProperties.filterCompare(hasProperty, oldProperties, onNew, onChange, onDelete));
}
function unsubscribeProperties(subscriptions) {
  for (const key in subscriptions) {
    subscriptions[key]();
  }
}

// node_modules/@pmndrs/uikit/dist/properties/merged.js
var MergedProperties = class {
  constructor(preTransformers) {
    __publicField(this, "preTransformers");
    __publicField(this, "propertyMap", /* @__PURE__ */ new Map());
    this.preTransformers = preTransformers;
  }
  add(key, value) {
    var _a;
    if (value === void 0) {
      return;
    }
    const transform = (_a = this.preTransformers) == null ? void 0 : _a[key];
    if (transform != null) {
      transform(value, this);
      return;
    }
    const aliases = allAliases[key];
    if (aliases == null) {
      this.addToMap(key, value);
      return;
    }
    const length = aliases.length;
    for (let i2 = 0; i2 < length; i2++) {
      this.addToMap(aliases[i2], value);
    }
  }
  addToMap(key, value) {
    let entry = this.propertyMap.get(key);
    if (entry == null) {
      this.propertyMap.set(key, entry = []);
    }
    if (!(value instanceof u)) {
      entry.length = 0;
    }
    entry.push(value);
  }
  /**
   * @returns undefined if the property doesn't exist
   */
  read(key, defaultValue) {
    const entry = this.propertyMap.get(key);
    if (entry == null) {
      return defaultValue;
    }
    const length = entry.length;
    for (let i2 = length - 1; i2 >= 0; i2--) {
      const value = entry[i2];
      const result = value instanceof u ? value.value : value;
      if (result === void 0) {
        continue;
      }
      return result;
    }
    return defaultValue;
  }
  filterCompare(filter, old, onNew, onChange, onDelete) {
    for (const key of this.propertyMap.keys()) {
      if (!filter(key)) {
        continue;
      }
      if (old == null) {
        onNew(key);
        continue;
      }
      const oldEntry = old.propertyMap.get(key);
      if (oldEntry == null) {
        onNew(key);
        continue;
      }
      const thisEntry = this.propertyMap.get(key);
      if (shallodwEqual(oldEntry, thisEntry)) {
        continue;
      }
      onChange(key);
    }
    if (old == null) {
      return;
    }
    for (const key of old.propertyMap.keys()) {
      if (!filter(key)) {
        continue;
      }
      if (this.propertyMap.has(key)) {
        continue;
      }
      onDelete(key);
    }
  }
  isEqual(otherMap, key) {
    const entry1 = this.propertyMap.get(key);
    const entry2 = otherMap.propertyMap.get(key);
    if (entry1 == null || entry2 == null) {
      return entry1 === entry2;
    }
    return shallodwEqual(entry1, entry2);
  }
  addAll(style, properties, defaultProperties, postTransformers) {
    traverseProperties(style, properties, defaultProperties, (p2) => {
      for (const key in p2) {
        this.add(key, p2[key]);
      }
      for (const key in postTransformers) {
        const property = p2[key];
        if (property == null) {
          continue;
        }
        postTransformers[key](property, this);
      }
    });
  }
};
function shallodwEqual(a1, a2) {
  const length = a1.length;
  if (length != a2.length) {
    return false;
  }
  for (let i2 = 0; i2 < length; i2++) {
    if (a1[i2] != a2[i2]) {
      return false;
    }
  }
  return true;
}

// node_modules/@pmndrs/uikit/dist/order.js
var cameraDistanceKey = Symbol("camera-distance-key");
var orderInfoKey = Symbol("order-info-key");
function reversePainterSortStable(a2, b3) {
  if (a2.groupOrder !== b3.groupOrder) {
    return a2.groupOrder - b3.groupOrder;
  }
  if (a2.renderOrder !== b3.renderOrder) {
    return a2.renderOrder - b3.renderOrder;
  }
  const aDistanceRef = a2.object[cameraDistanceKey];
  const bDistanceRef = b3.object[cameraDistanceKey];
  if (aDistanceRef == null || bDistanceRef == null) {
    return a2.z !== b3.z ? b3.z - a2.z : a2.id - b3.id;
  }
  if (aDistanceRef === bDistanceRef) {
    return compareOrderInfo(a2.object[orderInfoKey].value, b3.object[orderInfoKey].value);
  }
  return bDistanceRef.cameraDistance - aDistanceRef.cameraDistance;
}
var ElementType = {
  Panel: 0,
  //render first
  Image: 1,
  Object: 2,
  Custom: 3,
  Svg: 4,
  Text: 5
  //render last
};
function compareOrderInfo(o1, o2) {
  if (o1 == null || o2 == null) {
    return 0;
  }
  let dif = o1.majorIndex - o2.majorIndex;
  if (dif != 0) {
    return dif;
  }
  dif = o1.elementType - o2.elementType;
  if (dif != 0) {
    return dif;
  }
  return o1.minorIndex - o2.minorIndex;
}
function computedOrderInfo(propertiesSignal, type, instancedGroupDependencies, parentOrderInfoSignal) {
  const zIndexOffset = propertiesSignal == null ? void 0 : computedInheritableProperty(propertiesSignal, "zIndexOffset", void 0);
  return w(() => {
    let parentOrderInfo;
    if (parentOrderInfoSignal == null) {
      parentOrderInfo = void 0;
    } else if (parentOrderInfoSignal.value == null) {
      return void 0;
    } else {
      parentOrderInfo = parentOrderInfoSignal.value;
    }
    const offset = zIndexOffset == null ? void 0 : zIndexOffset.value;
    const majorOffset = typeof offset === "number" ? offset : (offset == null ? void 0 : offset.major) ?? 0;
    const minorOffset = typeof offset === "number" ? 0 : (offset == null ? void 0 : offset.minor) ?? 0;
    let majorIndex;
    let minorIndex;
    if (parentOrderInfo == null) {
      majorIndex = 0;
      minorIndex = 0;
    } else if (type > parentOrderInfo.elementType) {
      majorIndex = parentOrderInfo.majorIndex;
      minorIndex = 0;
    } else if (type != parentOrderInfo.elementType || !shallowEqualRecord(readReactive(instancedGroupDependencies), readReactive(parentOrderInfo.instancedGroupDependencies))) {
      majorIndex = parentOrderInfo.majorIndex + 1;
      minorIndex = 0;
    } else {
      majorIndex = parentOrderInfo.majorIndex;
      minorIndex = parentOrderInfo.minorIndex + 1;
    }
    if (majorOffset > 0) {
      majorIndex += majorOffset;
      minorIndex = 0;
    }
    minorIndex += minorOffset;
    return {
      instancedGroupDependencies,
      elementType: type,
      majorIndex,
      minorIndex
    };
  });
}
function shallowEqualRecord(r1, r2) {
  if (r1 === r2) {
    return true;
  }
  if (r1 == null || r2 == null) {
    return false;
  }
  let i2 = 0;
  for (const key in r1) {
    if (r1[key] != r2[key]) {
      return false;
    }
    ++i2;
  }
  return i2 === Object.keys(r2).length;
}
function setupRenderOrder(result, rootCameraDistance, orderInfo) {
  ;
  result[cameraDistanceKey] = rootCameraDistance;
  result[orderInfoKey] = orderInfo;
  return result;
}

// node_modules/@pmndrs/uikit/dist/listeners.js
function setupLayoutListeners(l1, l2, size, initializers) {
  initializers.push(() => E(() => {
    var _a, _b, _c, _d;
    const s2 = size.value;
    if (s2 == null) {
      return;
    }
    (_b = (_a = l1.peek()) == null ? void 0 : _a.onSizeChange) == null ? void 0 : _b.call(_a, ...s2);
    (_d = (_c = l2.peek()) == null ? void 0 : _c.onSizeChange) == null ? void 0 : _d.call(_c, ...s2);
  }));
}
function setupClippedListeners(l1, l2, isClippedSignal, initializers) {
  let first = true;
  initializers.push(() => E(() => {
    var _a, _b, _c, _d;
    const isClipped = isClippedSignal.value;
    if (first) {
      first = false;
      return;
    }
    (_b = (_a = l1.peek()) == null ? void 0 : _a.onIsClippedChange) == null ? void 0 : _b.call(_a, isClipped);
    (_d = (_c = l2.peek()) == null ? void 0 : _c.onIsClippedChange) == null ? void 0 : _d.call(_c, isClipped);
  }));
}

// node_modules/@pmndrs/uikit/dist/transform.js
var tHelper = new Vector3();
var sHelper = new Vector3();
var originVector = new Vector3();
var matrixHelper = new Matrix4();
var eulerHelper = new Euler();
var quaternionHelper = new Quaternion();
var toRad = Math.PI / 180;
function toQuaternion([x2, y3, z3]) {
  return quaternionHelper.setFromEuler(eulerHelper.set(x2 * toRad, y3 * toRad, z3 * toRad));
}
var defaultTransformOriginX = "center";
var defaultTransformOriginY = "center";
function computedTransformMatrix(propertiesSignal, { relativeCenter, size }, pixelSizeSignal) {
  const tTX = computedInheritableProperty(propertiesSignal, "transformTranslateX", 0);
  const tTY = computedInheritableProperty(propertiesSignal, "transformTranslateY", 0);
  const tTZ = computedInheritableProperty(propertiesSignal, "transformTranslateZ", 0);
  const tRX = computedInheritableProperty(propertiesSignal, "transformRotateX", 0);
  const tRY = computedInheritableProperty(propertiesSignal, "transformRotateY", 0);
  const tRZ = computedInheritableProperty(propertiesSignal, "transformRotateZ", 0);
  const tSX = computedInheritableProperty(propertiesSignal, "transformScaleX", 1);
  const tSY = computedInheritableProperty(propertiesSignal, "transformScaleY", 1);
  const tSZ = computedInheritableProperty(propertiesSignal, "transformScaleZ", 1);
  const tOX = computedInheritableProperty(propertiesSignal, "transformOriginX", defaultTransformOriginX);
  const tOY = computedInheritableProperty(propertiesSignal, "transformOriginY", defaultTransformOriginY);
  return w(() => {
    if (relativeCenter.value == null) {
      return void 0;
    }
    const [x2, y3] = relativeCenter.value;
    const pixelSize = pixelSizeSignal.value;
    const result = new Matrix4().makeTranslation(x2 * pixelSize, y3 * pixelSize, 0);
    let originCenter = true;
    if (tOX.value != "center" || tOY.value != "center") {
      if (size.value == null) {
        return void 0;
      }
      const [width, height] = size.value;
      originCenter = false;
      originVector.set(-alignmentXMap[tOX.value] * width * pixelSize, -alignmentYMap[tOY.value] * height * pixelSize, 0);
      result.multiply(matrixHelper.makeTranslation(originVector));
      originVector.negate();
    }
    const r2 = [tRX.value, tRY.value, tRZ.value];
    const t2 = [translateToNumber(tTX.value, size, 0), -translateToNumber(tTY.value, size, 1), tTZ.value];
    const s2 = [scaleToNumber(tSX.value), scaleToNumber(tSY.value), scaleToNumber(tSZ.value)];
    if (t2.some((v2) => v2 != 0) || r2.some((v2) => v2 != 0) || s2.some((v2) => v2 != 1)) {
      result.multiply(matrixHelper.compose(tHelper.fromArray(t2).multiplyScalar(pixelSize), toQuaternion(r2), sHelper.fromArray(s2)));
    }
    if (!originCenter) {
      result.multiply(matrixHelper.makeTranslation(originVector));
    }
    return result;
  });
}
function scaleToNumber(scale) {
  if (typeof scale === "number") {
    return scale;
  }
  const result = percentageRegex.exec(scale);
  if (result == null) {
    throw new Error(`invalid value "${scale}", expected number of percentage`);
  }
  return parseFloat(result[1]) / 100;
}
function translateToNumber(translate, size, sizeIndex) {
  var _a;
  if (typeof translate === "number") {
    return translate;
  }
  const result = percentageRegex.exec(translate);
  if (result == null) {
    throw new Error(`invalid value "${translate}", expected number of percentage`);
  }
  const sizeOnAxis = ((_a = size.value) == null ? void 0 : _a[sizeIndex]) ?? 0;
  return sizeOnAxis * parseFloat(result[1]) / 100;
}
function applyTransform(root, object, transformMatrix, initializers) {
  initializers.push(() => E(() => {
    var _a, _b;
    if (transformMatrix.value == null) {
      (_a = object.current) == null ? void 0 : _a.matrix.elements.fill(0);
      return;
    }
    (_b = object.current) == null ? void 0 : _b.matrix.copy(transformMatrix.value);
    root.requestRender();
  }));
}

// node_modules/yoga-layout/dist/binaries/yoga-wasm-base64-esm.js
var loadYoga = (() => {
  var _scriptDir = import.meta.url;
  return function(loadYoga3) {
    loadYoga3 = loadYoga3 || {};
    var h2;
    h2 || (h2 = typeof loadYoga3 !== "undefined" ? loadYoga3 : {});
    var aa2, ca2;
    h2.ready = new Promise(function(a2, b3) {
      aa2 = a2;
      ca2 = b3;
    });
    var da2 = Object.assign({}, h2), q2 = "";
    "undefined" != typeof document && document.currentScript && (q2 = document.currentScript.src);
    _scriptDir && (q2 = _scriptDir);
    0 !== q2.indexOf("blob:") ? q2 = q2.substr(0, q2.replace(/[?#].*/, "").lastIndexOf("/") + 1) : q2 = "";
    var ea = h2.print || console.log.bind(console), v2 = h2.printErr || console.warn.bind(console);
    Object.assign(h2, da2);
    da2 = null;
    var w2;
    h2.wasmBinary && (w2 = h2.wasmBinary);
    var noExitRuntime = h2.noExitRuntime || true;
    "object" != typeof WebAssembly && x2("no native wasm support detected");
    var fa2, ha2 = false;
    function z3(a2, b3, c2) {
      c2 = b3 + c2;
      for (var d2 = ""; !(b3 >= c2); ) {
        var e2 = a2[b3++];
        if (!e2)
          break;
        if (e2 & 128) {
          var f2 = a2[b3++] & 63;
          if (192 == (e2 & 224))
            d2 += String.fromCharCode((e2 & 31) << 6 | f2);
          else {
            var g2 = a2[b3++] & 63;
            e2 = 224 == (e2 & 240) ? (e2 & 15) << 12 | f2 << 6 | g2 : (e2 & 7) << 18 | f2 << 12 | g2 << 6 | a2[b3++] & 63;
            65536 > e2 ? d2 += String.fromCharCode(e2) : (e2 -= 65536, d2 += String.fromCharCode(55296 | e2 >> 10, 56320 | e2 & 1023));
          }
        } else
          d2 += String.fromCharCode(e2);
      }
      return d2;
    }
    var ia, ja, A, C, ka2, D, E2, la2, ma2;
    function na() {
      var a2 = fa2.buffer;
      ia = a2;
      h2.HEAP8 = ja = new Int8Array(a2);
      h2.HEAP16 = C = new Int16Array(a2);
      h2.HEAP32 = D = new Int32Array(a2);
      h2.HEAPU8 = A = new Uint8Array(a2);
      h2.HEAPU16 = ka2 = new Uint16Array(a2);
      h2.HEAPU32 = E2 = new Uint32Array(a2);
      h2.HEAPF32 = la2 = new Float32Array(a2);
      h2.HEAPF64 = ma2 = new Float64Array(a2);
    }
    var oa2, pa2 = [], qa = [], ra = [];
    function sa2() {
      var a2 = h2.preRun.shift();
      pa2.unshift(a2);
    }
    var F = 0, ta = null, G3 = null;
    function x2(a2) {
      if (h2.onAbort)
        h2.onAbort(a2);
      a2 = "Aborted(" + a2 + ")";
      v2(a2);
      ha2 = true;
      a2 = new WebAssembly.RuntimeError(a2 + ". Build with -sASSERTIONS for more info.");
      ca2(a2);
      throw a2;
    }
    function ua2(a2) {
      return a2.startsWith("data:application/octet-stream;base64,");
    }
    var H3;
    H3 = "data:application/octet-stream;base64,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KgIIIgcgAioCACIGXARAIAcgB1sEQCACLQAEIQIMAgsgBiAGXCEECyACLQAEIQIgBEUNACADLQAMIAJB/wFxRg0BCyAFIAEgBiACEDQDQCAALQAAIgFBBHENASAAIAFBBHI6AAAgACgCECIBBEAgACABEQAACyAAQYCAgP4HNgKcASAAKALcAyIADQALCyADQRBqJAALHAAgACABQQggAqcgAkIgiKcgA6cgA0IgiKcQFQsFABBQAAvOAQIDfwJ9IwBBEGsiAyQAQQEhBCADQQhqIABB/ABqIgUgACABQQF0akHEAGoiAS8BABAfAkACQCADKgIIIgcgAioCACIGXARAIAcgB1sEQCACLQAEIQIMAgsgBiAGXCEECyACLQAEIQIgBEUNACADLQAMIAJB/wFxRg0BCyAFIAEgBiACEDQDQCAALQAAIgFBBHENASAAIAFBBHI6AAAgACgCECIBBEAgACABEQAACyAAQYCAgP4HNgKcASAAKALcAyIADQALCyADQRBqJAALOQAgAEUEQEEADwsCfyABQYB/cUGAvwNGIAFB/wBNckUEQEHIO0EZNgIAQX8MAQsgACABOgAAQQELC8QCAAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAFBCWsOEgAKCwwKCwIDBAUMCwwMCgsHCAkLIAIgAigCACIBQQRqNgIAIAAgASgCADYCAA8LAAsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsACyACIAIoAgBBB2pBeHEiAUEIajYCACAAIAErAwA5AwAPCyAAIAIgAxECAAsPCyACIAIoAgAiAUEEajYCACAAIAE0AgA3AwAPCyACIAIoAgAiAUEEajYCACAAIAE1AgA3AwAPCyACIAIoAgBBB2pBeHEiAUEIajYCACAAIAEpAwA3AwALXQEEfyAAKAIAIQIDQCACLAAAIgMQTwRAQX8hBCAAIAJBAWoiAjYCACABQcyZs+YATQR/QX8gA0EwayIDIAFBCmwiBGogAyAEQf////8Hc0obBSAECyEBDAELCyABC6oUAhJ/AX4jAEHQAGsiCCQAIAggATYCTCAIQTdq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AkAgBkL///////////8AgyIEQoCAgICAgMCAPH0gBEKAgICAgIDA/8MAfVQEQCAGQgSGIANCPIiEIQQgA0L//////////w+DIgNCgYCAgICAgIAIWgRAIARCgYCAgICAgIDAAHwhAgwCCyAEQoCAgICAgICAQH0hAiADQoCAgICAgICACFINASACIARCAYN8IQIMAQsgA1AgBEKAgICAgIDA//8AVCAEQoCAgICAgMD//wBRG0UEQCAGQgSGIANCPIiEQv////////8Dg0KAgICAgICA/P8AhCECDAELQoCAgICAgID4/wAhAiAEQv///////7//wwBWDQBCACECIARCMIinIgBBkfcASQ0AIAMhAiAGQv///////z+DQoCAgICAgMAAhCIFIQcCQCAAQYH3AGsiAUHAAHEEQCACIAFBQGqthiEHQgAhAgwBCyABRQ0AIAcgAa0iBIYgAkHAACABa62IhCEHIAIgBIYhAgsgCCACNwMQIAggBzcDGAJAQYH4ACAAayIAQcAAcQRAIAUgAEFAaq2IIQNCACEFDAELIABFDQAgBUHAACAAa62GIAMgAK0iAoiEIQMgBSACiCEFCyAIIAM3AwAgCCAFNwMIIAgpAwhCBIYgCCkDACIDQjyIhCECIAgpAxAgCCkDGIRCAFKtIANC//////////8Pg4QiA0KBgICAgICAgAhaBEAgAkIBfCECDAELIANCgICAgICAgIAIUg0AIAJCAYMgAnwhAgsgCEEgaiQAIAkgAiAGQoCAgICAgICAgH+DhL85AwALmRgDEn8BfAN+IwBBsARrIgwkACAMQQA2AiwCQCABvSIZQgBTBEBBASERQZkJIRMgAZoiAb0hGQwBCyAEQYAQcQRAQQEhEUGcCSETDAELQZ8JQZoJIARBAXEiERshEyARRSEVCwJAIBlCgICAgICAgPj/AINCgICAgICAgPj/AFEEQCAAQSAgAiARQQNqIgMgBEH//3txECsgACATIBEQKSAAQd0VQbIeIAVBIHEiBRtBtxpBth4gBRsgASABYhtBAxApIABBICACIAMgBEGAwABzECsgAyACIAIgA0gbIQoMAQsgDEEQaiESAkACfwJAIAEgDEEsahCDASIBIAGgIgFEAAAAAAAAAABiBEAgDCAMKAIsIgZBAWs2AiwgBUEgciIOQeEARw0BDAMLIAVB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NwMIIAALDABBMBAeQQBBMBAwCzcBAX8gASAAKAIEIgNBAXVqIQEgACgCACEAIAEgAiADQQFxBH8gASgCACAAaigCAAUgAAsRGwALBQBBijsLIQAgACABKAIAIAEgASwAC0EASBtBhzsgAigCABAQNgIACyoBAX9BDBAeIgFBADoABCABIAAoAgA2AgggAEEANgIAIAFBqCc2AgAgAQsFAEGHOwsFAEGEOwshACAAIAEoAgAgASABLAALQQBIG0HwOiACKAIAEBA2AgAL2AEBBH8jAEEgayIDJAAgASgCACIEQfD///8HSQRAAkACQCAEQQtPBEAgBEEPckEBaiIFEB4hBiADIAVBgICAgHhyNgIQIAMgBjYCCCADIAQ2AgwgBCAGaiEFDAELIAMgBDoAEyADQQhqIgYgBGohBSAERQ0BCyAGIAFBBGogBBAsGgsgBUEAOgAAIAMgAjYCACADQRhqIANBCGogAyAAEQMAIAMoAhgQHSADKAIYIgAQBiADKAIAEAYgAywAE0EASARAIAMoAggQKAsgA0EgaiQAIAAPCxACAAsqAQF/QQwQHiIBQQA6AAQgASAAKAIANgIIIABBADYCACABQbAmNgIAIAELBQBB8DoLaQECfyMAQRBrIgYkACABIAAoAgQiB0EBdWohASAAKAIAIQAgBiABIAIgAyAEIAUgB0EBcQR/IAEoAgAgAGooAgAFIAALERAAQRAQHiIAIAYpAwg3AwggACAGKQMANwMAIAZBEGokACAACwUAQew6Cx0AIAAoAgAiACAALQAAQfcBcUEIQQAgARtyOgAAC6oBAgJ/AX0jAEEQayICJAAgACgCACEAIAFB/wFxIgNBBkkEQAJ/AkACQAJAIANBBGsOAgABAgsgAEHQA2ogAC0AhANBA3FBAkYNAhogAEHIA2oMAgsgAEHIA2ogAC0AhANBA3FBAkYNARogAEHQA2oMAQsgACABQf8BcUECdGpByANqCyoCACEEIAJBEGokACAEuw8LIAJB7hA2AgAgAEEFQa4lIAIQLhAnAAuqAQICfwF9IwBBEGsiAiQAIAAoAgAhACABQf8BcSIDQQZJBEACfwJAAkACQCADQQRrDgIAAQILIABBwANqIAAtAIQDQQNxQQJGDQIaIABBuANqDAILIABBuANqIAAtAIQDQQNxQQJGDQEaIABBwANqDAEL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IAMQUwsgAEGYAWogAUGYAWpByAIQLBogACgC4AMiAwRAIAAgAzYC5AMgAxAoCyAAIAEoAuADNgLgAyAAIAEoAuQDNgLkAyAAIAEoAugDNgLoAyABQQA2AugDIAFCADcC4AMgACABKQL0AzcC9AMgACABKQLsAzcC7AMgACABKAL8AzYC/AMgASgClAEhACABQQA2ApQBIAAEQCAAEFMLIAJBoARqJAAPCyACQcYcNgIQIABBBUGuJSACQRBqEC4QJwALIAJB5hE2AgAgAEEFQa4lIAIQLhAnAAsLtyYiAEGACAvZHU9ubHkgbGVhZiBub2RlcyB3aXRoIGN1c3RvbSBtZWFzdXJlIGZ1bmN0aW9ucyBzaG91bGQgbWFudWFsbHkgbWFyayB0aGVtc2VsdmVzIGFzIGRpcnR5AGlzRGlydHkAbWFya0RpcnR5AGRlc3Ryb3kAc2V0RGlzcGxheQBnZXREaXNwbGF5AHNldEZsZXgALSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweABzZXRGbGV4R3JvdwBnZXRGbGV4R3JvdwBzZXRPdmVyZmxvdwBnZXRPdmVyZmxvdwBoYXNOZXdMYXlvdXQAY2FsY3VsYXRlTGF5b3V0AGdldENvbXB1dGVkTGF5b3V0AHVuc2lnbmVkIHNob3J0AGdldENoaWxkQ291bnQAdW5zaWduZWQgaW50AHNldEp1c3RpZnlDb250ZW50AGdldEp1c3RpZnlDb250ZW50AGF2YWlsYWJsZUhlaWdodCBpcyBpbmRlZmluaXRlIHNvIGhlaWdodFNpemluZ01vZGUgbXVzdCBiZSBTaXppbmdNb2RlOjpNYXhDb250ZW50AGF2YWlsYWJsZVdpZHRoIGlzIGluZGVmaW5pdGUgc28gd2lkdGhTaXppbmdNb2RlIG11c3QgYmUgU2l6aW5nTW9kZTo6TWF4Q29udGVudABzZXRBbGlnbkNvbnRlbnQAZ2V0QWxpZ25Db250ZW50AGdldFBhcmVudABpbXBsZW1lbnQAc2V0TWF4SGVpZ2h0UGVyY2VudABzZXRIZWlnaHRQZXJjZW50AHNldE1pbkhlaWdodFBlcmNlbnQAc2V0RmxleEJhc2lzUGVyY2VudABzZXRHYXBQZXJjZW50AHNldFBvc2l0aW9uUGVyY2VudABzZXRNYXJnaW5QZXJjZW50AHNldE1heFdpZHRoUGVyY2VudABzZXRXaWR0aFBlcmNlbnQAc2V0TWluV2lkdGhQZXJjZW50AHNldFBhZGRpbmdQZXJjZW50AGhhbmRsZS50eXBlKCkgPT0gU3R5bGVWYWx1ZUhhbmRsZTo6VHlwZTo6UG9pbnQgfHwgaGFuZGxlLnR5cGUoKSA9PSBTdHlsZVZhbHVlSGFuZGxlOjpUeXBlOjpQZXJjZW50AGNyZWF0ZURlZmF1bHQAdW5pdAByaWdodABoZWlnaHQAc2V0TWF4SGVpZ2h0AGdldE1heEhlaWdodABzZXRIZWlnaHQAZ2V0SGVpZ2h0AHNldE1pbkhlaWdodABnZXRNaW5IZWlnaHQAZ2V0Q29tcHV0ZWRIZWlnaHQAZ2V0Q29tcHV0ZWRSaWdodABsZWZ0AGdldENvbXB1dGVkTGVmdAByZXNldABfX2Rlc3RydWN0AGZsb2F0AHVpbnQ2NF90AHVzZVdlYkRlZmF1bHRzAHNldFVzZVdlYkRlZmF1bHRzAHNldEFsaWduSXRlbXMAZ2V0QWxpZ25JdGVtcwBzZXRGbGV4QmFzaXMAZ2V0RmxleEJhc2lzAENhbm5vdCBnZXQgbGF5b3V0IHByb3BlcnRpZXMgb2YgbXVsdGktZWRnZSBzaG9ydGhhbmRzAHNldFBvaW50U2NhbGVGYWN0b3IATWVhc3VyZUNhbGxiYWNrV3JhcHBlcgBEaXJ0aWVkQ2FsbGJhY2tXcmFwcGVyAENhbm5vdCByZXNldCBhIG5vZGUgc3RpbGwgYXR0YWNoZWQgdG8gYSBvd25lcgBzZXRCb3JkZXIAZ2V0Qm9yZGVyAGdldENvbXB1dGVkQm9yZGVyAGdldE51bWJlcgBoYW5kbGUudHlwZSgpID09IFN0eWxlVmFsdWVIYW5kbGU6OlR5cGU6Ok51bWJlcgB1bnNpZ25lZCBjaGFyAHRvcABnZXRDb21wdXRlZFRvcABzZXRGbGV4V3JhcABnZXRGbGV4V3JhcABzZXRHYXAAZ2V0R2FwACVwAHNldEhlaWdodEF1dG8Ac2V0RmxleEJhc2lzQXV0bwBzZXRNYXJnaW5BdXRvAHNldFdpZHRoQXV0bwBTY2FsZSBmYWN0b3Igc2hvdWxkIG5vdCBiZSBsZXNzIHRoYW4gemVybwBzZXRBc3BlY3RSYXRpbwBnZXRBc3BlY3RSYXRpbwBzZXRQb3NpdGlvbgBnZXRQb3NpdGlvbgBub3RpZnlPbkRlc3RydWN0aW9uAHNldEZsZXhEaXJlY3Rpb24AZ2V0RmxleERpcmVjdGlvbgBzZXREaXJlY3Rpb24AZ2V0RGlyZWN0aW9uAHNldE1hcmdpbgBnZXRNYXJnaW4AZ2V0Q29tcHV0ZWRNYXJnaW4AbWFya0xheW91dFNlZW4AbmFuAGJvdHRvbQBnZXRDb21wdXRlZEJvdHRvbQBib29sAGVtc2NyaXB0ZW46OnZhbABzZXRGbGV4U2hyaW5rAGdldEZsZXhTaHJpbmsAc2V0QWx3YXlzRm9ybXNDb250YWluaW5nQmxvY2sATWVhc3VyZUNhbGxiYWNrAERpcnRpZWRDYWxsYmFjawBnZXRMZW5ndGgAd2lkdGgAc2V0TWF4V2lkdGgAZ2V0TWF4V2lkdGgAc2V0V2lkdGgAZ2V0V2lkdGgAc2V0TWluV2lkdGgAZ2V0TWluV2lkdGgAZ2V0Q29tcHV0ZWRXaWR0aABwdXNoAC9ob21lL3J1bm5lci93b3JrL3lvZ2EveW9nYS9qYXZhc2NyaXB0Ly4uL3lvZ2Evc3R5bGUvU21hbGxWYWx1ZUJ1ZmZlci5oAC9ob21lL3J1bm5lci93b3JrL3lvZ2EveW9nYS9qYXZhc2NyaXB0Ly4uL3lvZ2Evc3R5bGUvU3R5bGVWYWx1ZVBvb2wuaAB1bnNpZ25lZCBsb25nAHN0ZDo6d3N0cmluZwBzdGQ6OnN0cmluZwBzdGQ6OnUxNnN0cmluZwBzdGQ6OnUzMnN0cmluZwBzZXRQYWRkaW5nAGdldFBhZGRpbmcAZ2V0Q29tcHV0ZWRQYWRkaW5nAFRyaWVkIHRvIGNvbnN0cnVjdCBZR05vZGUgd2l0aCBudWxsIGNvbmZpZwBBdHRlbXB0aW5nIHRvIGNvbnN0cnVjdCBOb2RlIHdpdGggbnVsbCBjb25maWcAY3JlYXRlV2l0aENvbmZpZwBpbmYAc2V0QWxpZ25TZWxmAGdldEFsaWduU2VsZgBTaXplAHZhbHVlAFZhbHVlAGNyZWF0ZQBtZWFzdXJlAHNldFBvc2l0aW9uVHlwZQBnZXRQb3NpdGlvblR5cGUAaXNSZWZlcmVuY2VCYXNlbGluZQBzZXRJc1JlZmVyZW5jZUJhc2VsaW5lAGNvcHlTdHlsZQBkb3VibGUATm9kZQBleHRlbmQAaW5zZXJ0Q2hpbGQAZ2V0Q2hpbGQAcmVtb3ZlQ2hpbGQAdm9pZABzZXRFeHBlcmltZW50YWxGZWF0dXJlRW5hYmxlZABpc0V4cGVyaW1lbnRhbEZlYXR1cmVFbmFibGVkAGRpcnRpZWQAQ2Fubm90IHJlc2V0IGEgbm9kZSB3aGljaCBzdGlsbCBoYXMgY2hpbGRyZW4gYXR0YWNoZWQAdW5zZXRNZWFzdXJlRnVuYwB1bnNldERpcnRpZWRGdW5jAHNldEVycmF0YQBnZXRFcnJhdGEATWVhc3VyZSBmdW5jdGlvbiByZXR1cm5lZCBhbiBpbnZhbGlkIGRpbWVuc2lvbiB0byBZb2dhOiBbd2lkdGg9JWYsIGhlaWdodD0lZl0ARXhwZWN0IGN1c3RvbSBiYXNlbGluZSBmdW5jdGlvbiB0byBub3QgcmV0dXJuIE5hTgBOQU4ASU5GAGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGZsb2F0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4Ac3RkOjpiYXNpY19zdHJpbmc8dW5zaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2ln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";
    if (!ua2(H3)) {
      var va2 = H3;
      H3 = h2.locateFile ? h2.locateFile(va2, q2) : q2 + va2;
    }
    function wa2() {
      var a2 = H3;
      try {
        if (a2 == H3 && w2)
          return new Uint8Array(w2);
        if (ua2(a2))
          try {
            var b3 = xa2(a2.slice(37)), c2 = new Uint8Array(b3.length);
            for (a2 = 0; a2 < b3.length; ++a2)
              c2[a2] = b3.charCodeAt(a2);
            var d2 = c2;
          } catch (f2) {
            throw Error("Converting base64 string to bytes failed.");
          }
        else
          d2 = void 0;
        var e2 = d2;
        if (e2)
          return e2;
        throw "both async and sync fetching of the wasm failed";
      } catch (f2) {
        x2(f2);
      }
    }
    function ya() {
      return w2 || "function" != typeof fetch ? Promise.resolve().then(function() {
        return wa2();
      }) : fetch(H3, { credentials: "same-origin" }).then(function(a2) {
        if (!a2.ok)
          throw "failed to load wasm binary file at '" + H3 + "'";
        return a2.arrayBuffer();
      }).catch(function() {
        return wa2();
      });
    }
    function za(a2) {
      for (; 0 < a2.length; )
        a2.shift()(h2);
    }
    function Aa(a2) {
      if (void 0 === a2)
        return "_unknown";
      a2 = a2.replace(/[^a-zA-Z0-9_]/g, "$");
      var b3 = a2.charCodeAt(0);
      return 48 <= b3 && 57 >= b3 ? "_" + a2 : a2;
    }
    function Ba(a2, b3) {
      a2 = Aa(a2);
      return function() {
        return b3.apply(this, arguments);
      };
    }
    var J3 = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }], Ca = [];
    function Da2(a2) {
      var b3 = Error, c2 = Ba(a2, function(d2) {
        this.name = a2;
        this.message = d2;
        d2 = Error(d2).stack;
        void 0 !== d2 && (this.stack = this.toString() + "\n" + d2.replace(/^Error(:[^\n]*)?\n/, ""));
      });
      c2.prototype = Object.create(b3.prototype);
      c2.prototype.constructor = c2;
      c2.prototype.toString = function() {
        return void 0 === this.message ? this.name : this.name + ": " + this.message;
      };
      return c2;
    }
    var K2 = void 0;
    function L3(a2) {
      throw new K2(a2);
    }
    var M3 = (a2) => {
      a2 || L3("Cannot use deleted val. handle = " + a2);
      return J3[a2].value;
    }, Ea2 = (a2) => {
      switch (a2) {
        case void 0:
          return 1;
        case null:
          return 2;
        case true:
          return 3;
        case false:
          return 4;
        default:
          var b3 = Ca.length ? Ca.pop() : J3.length;
          J3[b3] = { ga: 1, value: a2 };
          return b3;
      }
    }, Fa2 = void 0, Ga = void 0;
    function N2(a2) {
      for (var b3 = ""; A[a2]; )
        b3 += Ga[A[a2++]];
      return b3;
    }
    var O2 = [];
    function Ha() {
      for (; O2.length; ) {
        var a2 = O2.pop();
        a2.M.$ = false;
        a2["delete"]();
      }
    }
    var P2 = void 0, Q3 = {};
    function Ia2(a2, b3) {
      for (void 0 === b3 && L3("ptr should not be undefined"); a2.R; )
        b3 = a2.ba(b3), a2 = a2.R;
      return b3;
    }
    var R3 = {};
    function Ja2(a2) {
      a2 = Ka(a2);
      var b3 = N2(a2);
      S3(a2);
      return b3;
    }
    function La(a2, b3) {
      var c2 = R3[a2];
      void 0 === c2 && L3(b3 + " has unknown type " + Ja2(a2));
      return c2;
    }
    function Ma2() {
    }
    var Na2 = false;
    function Oa(a2) {
      --a2.count.value;
      0 === a2.count.value && (a2.T ? a2.U.W(a2.T) : a2.P.N.W(a2.O));
    }
    function Pa(a2, b3, c2) {
      if (b3 === c2)
        return a2;
      if (void 0 === c2.R)
        return null;
      a2 = Pa(a2, b3, c2.R);
      return null === a2 ? null : c2.na(a2);
    }
    var Qa = {};
    function Ra2(a2, b3) {
      b3 = Ia2(a2, b3);
      return Q3[b3];
    }
    var Sa2 = void 0;
    function Ta(a2) {
      throw new Sa2(a2);
    }
    function Ua2(a2, b3) {
      b3.P && b3.O || Ta("makeClassHandle requires ptr and ptrType");
      !!b3.U !== !!b3.T && Ta("Both smartPtrType and smartPtr must be specified");
      b3.count = { value: 1 };
      return T3(Object.create(a2, { M: { value: b3 } }));
    }
    function T3(a2) {
      if ("undefined" === typeof FinalizationRegistry)
        return T3 = (b3) => b3, a2;
      Na2 = new FinalizationRegistry((b3) => {
        Oa(b3.M);
      });
      T3 = (b3) => {
        var c2 = b3.M;
        c2.T && Na2.register(b3, { M: c2 }, b3);
        return b3;
      };
      Ma2 = (b3) => {
        Na2.unregister(b3);
      };
      return T3(a2);
    }
    var Va = {};
    function Wa(a2) {
      for (; a2.length; ) {
        var b3 = a2.pop();
        a2.pop()(b3);
      }
    }
    function Xa(a2) {
      return this.fromWireType(D[a2 >> 2]);
    }
    var U2 = {}, Ya = {};
    function V2(a2, b3, c2) {
      function d2(k) {
        k = c2(k);
        k.length !== a2.length && Ta("Mismatched type converter count");
        for (var m = 0; m < a2.length; ++m)
          W2(a2[m], k[m]);
      }
      a2.forEach(function(k) {
        Ya[k] = b3;
      });
      var e2 = Array(b3.length), f2 = [], g2 = 0;
      b3.forEach((k, m) => {
        R3.hasOwnProperty(k) ? e2[m] = R3[k] : (f2.push(k), U2.hasOwnProperty(k) || (U2[k] = []), U2[k].push(() => {
          e2[m] = R3[k];
          ++g2;
          g2 === f2.length && d2(e2);
        }));
      });
      0 === f2.length && d2(e2);
    }
    function Za(a2) {
      switch (a2) {
        case 1:
          return 0;
        case 2:
          return 1;
        case 4:
          return 2;
        case 8:
          return 3;
        default:
          throw new TypeError("Unknown type size: " + a2);
      }
    }
    function W2(a2, b3, c2 = {}) {
      if (!("argPackAdvance" in b3))
        throw new TypeError("registerType registeredInstance requires argPackAdvance");
      var d2 = b3.name;
      a2 || L3('type "' + d2 + '" must have a positive integer typeid pointer');
      if (R3.hasOwnProperty(a2)) {
        if (c2.ua)
          return;
        L3("Cannot register type '" + d2 + "' twice");
      }
      R3[a2] = b3;
      delete Ya[a2];
      U2.hasOwnProperty(a2) && (b3 = U2[a2], delete U2[a2], b3.forEach((e2) => e2()));
    }
    function $a2(a2) {
      L3(a2.M.P.N.name + " instance already deleted");
    }
    function X3() {
    }
    function ab2(a2, b3, c2) {
      if (void 0 === a2[b3].S) {
        var d2 = a2[b3];
        a2[b3] = function() {
          a2[b3].S.hasOwnProperty(arguments.length) || L3("Function '" + c2 + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + a2[b3].S + ")!");
          return a2[b3].S[arguments.length].apply(this, arguments);
        };
        a2[b3].S = [];
        a2[b3].S[d2.Z] = d2;
      }
    }
    function bb(a2, b3) {
      h2.hasOwnProperty(a2) ? (L3("Cannot register public name '" + a2 + "' twice"), ab2(h2, a2, a2), h2.hasOwnProperty(void 0) && L3("Cannot register multiple overloads of a function with the same number of arguments (undefined)!"), h2[a2].S[void 0] = b3) : h2[a2] = b3;
    }
    function cb(a2, b3, c2, d2, e2, f2, g2, k) {
      this.name = a2;
      this.constructor = b3;
      this.X = c2;
      this.W = d2;
      this.R = e2;
      this.pa = f2;
      this.ba = g2;
      this.na = k;
      this.ja = [];
    }
    function db(a2, b3, c2) {
      for (; b3 !== c2; )
        b3.ba || L3("Expected null or instance of " + c2.name + ", got an instance of " + b3.name), a2 = b3.ba(a2), b3 = b3.R;
      return a2;
    }
    function eb(a2, b3) {
      if (null === b3)
        return this.ea && L3("null is not a valid " + this.name), 0;
      b3.M || L3('Cannot pass "' + fb(b3) + '" as a ' + this.name);
      b3.M.O || L3("Cannot pass deleted object as a pointer of type " + this.name);
      return db(b3.M.O, b3.M.P.N, this.N);
    }
    function gb(a2, b3) {
      if (null === b3) {
        this.ea && L3("null is not a valid " + this.name);
        if (this.da) {
          var c2 = this.fa();
          null !== a2 && a2.push(this.W, c2);
          return c2;
        }
        return 0;
      }
      b3.M || L3('Cannot pass "' + fb(b3) + '" as a ' + this.name);
      b3.M.O || L3("Cannot pass deleted object as a pointer of type " + this.name);
      !this.ca && b3.M.P.ca && L3("Cannot convert argument of type " + (b3.M.U ? b3.M.U.name : b3.M.P.name) + " to parameter type " + this.name);
      c2 = db(b3.M.O, b3.M.P.N, this.N);
      if (this.da)
        switch (void 0 === b3.M.T && L3("Passing raw pointer to smart pointer is illegal"), this.Ba) {
          case 0:
            b3.M.U === this ? c2 = b3.M.T : L3("Cannot convert argument of type " + (b3.M.U ? b3.M.U.name : b3.M.P.name) + " to parameter type " + this.name);
            break;
          case 1:
            c2 = b3.M.T;
            break;
          case 2:
            if (b3.M.U === this)
              c2 = b3.M.T;
            else {
              var d2 = b3.clone();
              c2 = this.xa(c2, Ea2(function() {
                d2["delete"]();
              }));
              null !== a2 && a2.push(this.W, c2);
            }
            break;
          default:
            L3("Unsupporting sharing policy");
        }
      return c2;
    }
    function hb(a2, b3) {
      if (null === b3)
        return this.ea && L3("null is not a valid " + this.name), 0;
      b3.M || L3('Cannot pass "' + fb(b3) + '" as a ' + this.name);
      b3.M.O || L3("Cannot pass deleted object as a pointer of type " + this.name);
      b3.M.P.ca && L3("Cannot convert argument of type " + b3.M.P.name + " to parameter type " + this.name);
      return db(b3.M.O, b3.M.P.N, this.N);
    }
    function Y2(a2, b3, c2, d2) {
      this.name = a2;
      this.N = b3;
      this.ea = c2;
      this.ca = d2;
      this.da = false;
      this.W = this.xa = this.fa = this.ka = this.Ba = this.wa = void 0;
      void 0 !== b3.R ? this.toWireType = gb : (this.toWireType = d2 ? eb : hb, this.V = null);
    }
    function ib(a2, b3) {
      h2.hasOwnProperty(a2) || Ta("Replacing nonexistant public symbol");
      h2[a2] = b3;
      h2[a2].Z = void 0;
    }
    function jb(a2, b3) {
      var c2 = [];
      return function() {
        c2.length = 0;
        Object.assign(c2, arguments);
        if (a2.includes("j")) {
          var d2 = h2["dynCall_" + a2];
          d2 = c2 && c2.length ? d2.apply(null, [b3].concat(c2)) : d2.call(null, b3);
        } else
          d2 = oa2.get(b3).apply(null, c2);
        return d2;
      };
    }
    function Z3(a2, b3) {
      a2 = N2(a2);
      var c2 = a2.includes("j") ? jb(a2, b3) : oa2.get(b3);
      "function" != typeof c2 && L3("unknown function pointer with signature " + a2 + ": " + b3);
      return c2;
    }
    var mb = void 0;
    function nb(a2, b3) {
      function c2(f2) {
        e2[f2] || R3[f2] || (Ya[f2] ? Ya[f2].forEach(c2) : (d2.push(f2), e2[f2] = true));
      }
      var d2 = [], e2 = {};
      b3.forEach(c2);
      throw new mb(a2 + ": " + d2.map(Ja2).join([", "]));
    }
    function ob(a2, b3, c2, d2, e2) {
      var f2 = b3.length;
      2 > f2 && L3("argTypes array size mismatch! Must at least get return value and 'this' types!");
      var g2 = null !== b3[1] && null !== c2, k = false;
      for (c2 = 1; c2 < b3.length; ++c2)
        if (null !== b3[c2] && void 0 === b3[c2].V) {
          k = true;
          break;
        }
      var m = "void" !== b3[0].name, l2 = f2 - 2, n2 = Array(l2), p2 = [], r2 = [];
      return function() {
        arguments.length !== l2 && L3("function " + a2 + " called with " + arguments.length + " arguments, expected " + l2 + " args!");
        r2.length = 0;
        p2.length = g2 ? 2 : 1;
        p2[0] = e2;
        if (g2) {
          var u2 = b3[1].toWireType(r2, this);
          p2[1] = u2;
        }
        for (var t2 = 0; t2 < l2; ++t2)
          n2[t2] = b3[t2 + 2].toWireType(r2, arguments[t2]), p2.push(n2[t2]);
        t2 = d2.apply(null, p2);
        if (k)
          Wa(r2);
        else
          for (var y3 = g2 ? 1 : 2; y3 < b3.length; y3++) {
            var B2 = 1 === y3 ? u2 : n2[y3 - 2];
            null !== b3[y3].V && b3[y3].V(B2);
          }
        u2 = m ? b3[0].fromWireType(t2) : void 0;
        return u2;
      };
    }
    function pb(a2, b3) {
      for (var c2 = [], d2 = 0; d2 < a2; d2++)
        c2.push(E2[b3 + 4 * d2 >> 2]);
      return c2;
    }
    function qb(a2) {
      4 < a2 && 0 === --J3[a2].ga && (J3[a2] = void 0, Ca.push(a2));
    }
    function fb(a2) {
      if (null === a2)
        return "null";
      var b3 = typeof a2;
      return "object" === b3 || "array" === b3 || "function" === b3 ? a2.toString() : "" + a2;
    }
    function rb(a2, b3) {
      switch (b3) {
        case 2:
          return function(c2) {
            return this.fromWireType(la2[c2 >> 2]);
          };
        case 3:
          return function(c2) {
            return this.fromWireType(ma2[c2 >> 3]);
          };
        default:
          throw new TypeError("Unknown float type: " + a2);
      }
    }
    function sb2(a2, b3, c2) {
      switch (b3) {
        case 0:
          return c2 ? function(d2) {
            return ja[d2];
          } : function(d2) {
            return A[d2];
          };
        case 1:
          return c2 ? function(d2) {
            return C[d2 >> 1];
          } : function(d2) {
            return ka2[d2 >> 1];
          };
        case 2:
          return c2 ? function(d2) {
            return D[d2 >> 2];
          } : function(d2) {
            return E2[d2 >> 2];
          };
        default:
          throw new TypeError("Unknown integer type: " + a2);
      }
    }
    function tb(a2, b3) {
      for (var c2 = "", d2 = 0; !(d2 >= b3 / 2); ++d2) {
        var e2 = C[a2 + 2 * d2 >> 1];
        if (0 == e2)
          break;
        c2 += String.fromCharCode(e2);
      }
      return c2;
    }
    function ub(a2, b3, c2) {
      void 0 === c2 && (c2 = 2147483647);
      if (2 > c2)
        return 0;
      c2 -= 2;
      var d2 = b3;
      c2 = c2 < 2 * a2.length ? c2 / 2 : a2.length;
      for (var e2 = 0; e2 < c2; ++e2)
        C[b3 >> 1] = a2.charCodeAt(e2), b3 += 2;
      C[b3 >> 1] = 0;
      return b3 - d2;
    }
    function vb(a2) {
      return 2 * a2.length;
    }
    function wb(a2, b3) {
      for (var c2 = 0, d2 = ""; !(c2 >= b3 / 4); ) {
        var e2 = D[a2 + 4 * c2 >> 2];
        if (0 == e2)
          break;
        ++c2;
        65536 <= e2 ? (e2 -= 65536, d2 += String.fromCharCode(55296 | e2 >> 10, 56320 | e2 & 1023)) : d2 += String.fromCharCode(e2);
      }
      return d2;
    }
    function xb(a2, b3, c2) {
      void 0 === c2 && (c2 = 2147483647);
      if (4 > c2)
        return 0;
      var d2 = b3;
      c2 = d2 + c2 - 4;
      for (var e2 = 0; e2 < a2.length; ++e2) {
        var f2 = a2.charCodeAt(e2);
        if (55296 <= f2 && 57343 >= f2) {
          var g2 = a2.charCodeAt(++e2);
          f2 = 65536 + ((f2 & 1023) << 10) | g2 & 1023;
        }
        D[b3 >> 2] = f2;
        b3 += 4;
        if (b3 + 4 > c2)
          break;
      }
      D[b3 >> 2] = 0;
      return b3 - d2;
    }
    function yb(a2) {
      for (var b3 = 0, c2 = 0; c2 < a2.length; ++c2) {
        var d2 = a2.charCodeAt(c2);
        55296 <= d2 && 57343 >= d2 && ++c2;
        b3 += 4;
      }
      return b3;
    }
    var zb = {};
    function Ab(a2) {
      var b3 = zb[a2];
      return void 0 === b3 ? N2(a2) : b3;
    }
    var Bb = [];
    function Cb(a2) {
      var b3 = Bb.length;
      Bb.push(a2);
      return b3;
    }
    function Db(a2, b3) {
      for (var c2 = Array(a2), d2 = 0; d2 < a2; ++d2)
        c2[d2] = La(E2[b3 + 4 * d2 >> 2], "parameter " + d2);
      return c2;
    }
    var Eb = [], Fb = [null, [], []];
    K2 = h2.BindingError = Da2("BindingError");
    h2.count_emval_handles = function() {
      for (var a2 = 0, b3 = 5; b3 < J3.length; ++b3)
        void 0 !== J3[b3] && ++a2;
      return a2;
    };
    h2.get_first_emval = function() {
      for (var a2 = 5; a2 < J3.length; ++a2)
        if (void 0 !== J3[a2])
          return J3[a2];
      return null;
    };
    Fa2 = h2.PureVirtualError = Da2("PureVirtualError");
    for (var Gb = Array(256), Hb = 0; 256 > Hb; ++Hb)
      Gb[Hb] = String.fromCharCode(Hb);
    Ga = Gb;
    h2.getInheritedInstanceCount = function() {
      return Object.keys(Q3).length;
    };
    h2.getLiveInheritedInstances = function() {
      var a2 = [], b3;
      for (b3 in Q3)
        Q3.hasOwnProperty(b3) && a2.push(Q3[b3]);
      return a2;
    };
    h2.flushPendingDeletes = Ha;
    h2.setDelayFunction = function(a2) {
      P2 = a2;
      O2.length && P2 && P2(Ha);
    };
    Sa2 = h2.InternalError = Da2("InternalError");
    X3.prototype.isAliasOf = function(a2) {
      if (!(this instanceof X3 && a2 instanceof X3))
        return false;
      var b3 = this.M.P.N, c2 = this.M.O, d2 = a2.M.P.N;
      for (a2 = a2.M.O; b3.R; )
        c2 = b3.ba(c2), b3 = b3.R;
      for (; d2.R; )
        a2 = d2.ba(a2), d2 = d2.R;
      return b3 === d2 && c2 === a2;
    };
    X3.prototype.clone = function() {
      this.M.O || $a2(this);
      if (this.M.aa)
        return this.M.count.value += 1, this;
      var a2 = T3, b3 = Object, c2 = b3.create, d2 = Object.getPrototypeOf(this), e2 = this.M;
      a2 = a2(c2.call(b3, d2, { M: { value: { count: e2.count, $: e2.$, aa: e2.aa, O: e2.O, P: e2.P, T: e2.T, U: e2.U } } }));
      a2.M.count.value += 1;
      a2.M.$ = false;
      return a2;
    };
    X3.prototype["delete"] = function() {
      this.M.O || $a2(this);
      this.M.$ && !this.M.aa && L3("Object already scheduled for deletion");
      Ma2(this);
      Oa(this.M);
      this.M.aa || (this.M.T = void 0, this.M.O = void 0);
    };
    X3.prototype.isDeleted = function() {
      return !this.M.O;
    };
    X3.prototype.deleteLater = function() {
      this.M.O || $a2(this);
      this.M.$ && !this.M.aa && L3("Object already scheduled for deletion");
      O2.push(this);
      1 === O2.length && P2 && P2(Ha);
      this.M.$ = true;
      return this;
    };
    Y2.prototype.qa = function(a2) {
      this.ka && (a2 = this.ka(a2));
      return a2;
    };
    Y2.prototype.ha = function(a2) {
      this.W && this.W(a2);
    };
    Y2.prototype.argPackAdvance = 8;
    Y2.prototype.readValueFromPointer = Xa;
    Y2.prototype.deleteObject = function(a2) {
      if (null !== a2)
        a2["delete"]();
    };
    Y2.prototype.fromWireType = function(a2) {
      function b3() {
        return this.da ? Ua2(this.N.X, { P: this.wa, O: c2, U: this, T: a2 }) : Ua2(this.N.X, { P: this, O: a2 });
      }
      var c2 = this.qa(a2);
      if (!c2)
        return this.ha(a2), null;
      var d2 = Ra2(this.N, c2);
      if (void 0 !== d2) {
        if (0 === d2.M.count.value)
          return d2.M.O = c2, d2.M.T = a2, d2.clone();
        d2 = d2.clone();
        this.ha(a2);
        return d2;
      }
      d2 = this.N.pa(c2);
      d2 = Qa[d2];
      if (!d2)
        return b3.call(this);
      d2 = this.ca ? d2.la : d2.pointerType;
      var e2 = Pa(c2, this.N, d2.N);
      return null === e2 ? b3.call(this) : this.da ? Ua2(d2.N.X, { P: d2, O: e2, U: this, T: a2 }) : Ua2(d2.N.X, { P: d2, O: e2 });
    };
    mb = h2.UnboundTypeError = Da2("UnboundTypeError");
    var xa2 = "function" == typeof atob ? atob : function(a2) {
      var b3 = "", c2 = 0;
      a2 = a2.replace(/[^A-Za-z0-9\+\/=]/g, "");
      do {
        var d2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a2.charAt(c2++));
        var e2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a2.charAt(c2++));
        var f2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a2.charAt(c2++));
        var g2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a2.charAt(c2++));
        d2 = d2 << 2 | e2 >> 4;
        e2 = (e2 & 15) << 4 | f2 >> 2;
        var k = (f2 & 3) << 6 | g2;
        b3 += String.fromCharCode(d2);
        64 !== f2 && (b3 += String.fromCharCode(e2));
        64 !== g2 && (b3 += String.fromCharCode(k));
      } while (c2 < a2.length);
      return b3;
    }, Jb = {
      l: function(a2, b3, c2, d2) {
        x2("Assertion failed: " + (a2 ? z3(A, a2) : "") + ", at: " + [b3 ? b3 ? z3(A, b3) : "" : "unknown filename", c2, d2 ? d2 ? z3(A, d2) : "" : "unknown function"]);
      },
      q: function(a2, b3, c2) {
        a2 = N2(a2);
        b3 = La(b3, "wrapper");
        c2 = M3(c2);
        var d2 = [].slice, e2 = b3.N, f2 = e2.X, g2 = e2.R.X, k = e2.R.constructor;
        a2 = Ba(a2, function() {
          e2.R.ja.forEach((function(l2) {
            if (this[l2] === g2[l2])
              throw new Fa2("Pure virtual function " + l2 + " must be implemented in JavaScript");
          }).bind(this));
          Object.defineProperty(this, "__parent", { value: f2 });
          this.__construct.apply(this, d2.call(arguments));
        });
        f2.__construct = function() {
          this === f2 && L3("Pass correct 'this' to __construct");
          var l2 = k.implement.apply(void 0, [this].concat(d2.call(arguments)));
          Ma2(l2);
          var n2 = l2.M;
          l2.notifyOnDestruction();
          n2.aa = true;
          Object.defineProperties(this, { M: { value: n2 } });
          T3(this);
          l2 = n2.O;
          l2 = Ia2(e2, l2);
          Q3.hasOwnProperty(l2) ? L3("Tried to register registered instance: " + l2) : Q3[l2] = this;
        };
        f2.__destruct = function() {
          this === f2 && L3("Pass correct 'this' to __destruct");
          Ma2(this);
          var l2 = this.M.O;
          l2 = Ia2(e2, l2);
          Q3.hasOwnProperty(l2) ? delete Q3[l2] : L3("Tried to unregister unregistered instance: " + l2);
        };
        a2.prototype = Object.create(f2);
        for (var m in c2)
          a2.prototype[m] = c2[m];
        return Ea2(a2);
      },
      j: function(a2) {
        var b3 = Va[a2];
        delete Va[a2];
        var c2 = b3.fa, d2 = b3.W, e2 = b3.ia, f2 = e2.map((g2) => g2.ta).concat(e2.map((g2) => g2.za));
        V2([a2], f2, (g2) => {
          var k = {};
          e2.forEach((m, l2) => {
            var n2 = g2[l2], p2 = m.ra, r2 = m.sa, u2 = g2[l2 + e2.length], t2 = m.ya, y3 = m.Aa;
            k[m.oa] = { read: (B2) => n2.fromWireType(p2(r2, B2)), write: (B2, ba2) => {
              var I2 = [];
              t2(
                y3,
                B2,
                u2.toWireType(I2, ba2)
              );
              Wa(I2);
            } };
          });
          return [{ name: b3.name, fromWireType: function(m) {
            var l2 = {}, n2;
            for (n2 in k)
              l2[n2] = k[n2].read(m);
            d2(m);
            return l2;
          }, toWireType: function(m, l2) {
            for (var n2 in k)
              if (!(n2 in l2))
                throw new TypeError('Missing field:  "' + n2 + '"');
            var p2 = c2();
            for (n2 in k)
              k[n2].write(p2, l2[n2]);
            null !== m && m.push(d2, p2);
            return p2;
          }, argPackAdvance: 8, readValueFromPointer: Xa, V: d2 }];
        });
      },
      v: function() {
      },
      B: function(a2, b3, c2, d2, e2) {
        var f2 = Za(c2);
        b3 = N2(b3);
        W2(a2, {
          name: b3,
          fromWireType: function(g2) {
            return !!g2;
          },
          toWireType: function(g2, k) {
            return k ? d2 : e2;
          },
          argPackAdvance: 8,
          readValueFromPointer: function(g2) {
            if (1 === c2)
              var k = ja;
            else if (2 === c2)
              k = C;
            else if (4 === c2)
              k = D;
            else
              throw new TypeError("Unknown boolean type size: " + b3);
            return this.fromWireType(k[g2 >> f2]);
          },
          V: null
        });
      },
      f: function(a2, b3, c2, d2, e2, f2, g2, k, m, l2, n2, p2, r2) {
        n2 = N2(n2);
        f2 = Z3(e2, f2);
        k && (k = Z3(g2, k));
        l2 && (l2 = Z3(m, l2));
        r2 = Z3(p2, r2);
        var u2 = Aa(n2);
        bb(u2, function() {
          nb("Cannot construct " + n2 + " due to unbound types", [d2]);
        });
        V2([a2, b3, c2], d2 ? [d2] : [], function(t2) {
          t2 = t2[0];
          if (d2) {
            var y3 = t2.N;
            var B2 = y3.X;
          } else
            B2 = X3.prototype;
          t2 = Ba(u2, function() {
            if (Object.getPrototypeOf(this) !== ba2)
              throw new K2("Use 'new' to construct " + n2);
            if (void 0 === I2.Y)
              throw new K2(n2 + " has no accessible constructor");
            var kb = I2.Y[arguments.length];
            if (void 0 === kb)
              throw new K2("Tried to invoke ctor of " + n2 + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(I2.Y).toString() + ") parameters instead!");
            return kb.apply(this, arguments);
          });
          var ba2 = Object.create(B2, { constructor: { value: t2 } });
          t2.prototype = ba2;
          var I2 = new cb(n2, t2, ba2, r2, y3, f2, k, l2);
          y3 = new Y2(n2, I2, true, false);
          B2 = new Y2(n2 + "*", I2, false, false);
          var lb = new Y2(n2 + " const*", I2, false, true);
          Qa[a2] = {
            pointerType: B2,
            la: lb
          };
          ib(u2, t2);
          return [y3, B2, lb];
        });
      },
      d: function(a2, b3, c2, d2, e2, f2, g2) {
        var k = pb(c2, d2);
        b3 = N2(b3);
        f2 = Z3(e2, f2);
        V2([], [a2], function(m) {
          function l2() {
            nb("Cannot call " + n2 + " due to unbound types", k);
          }
          m = m[0];
          var n2 = m.name + "." + b3;
          b3.startsWith("@@") && (b3 = Symbol[b3.substring(2)]);
          var p2 = m.N.constructor;
          void 0 === p2[b3] ? (l2.Z = c2 - 1, p2[b3] = l2) : (ab2(p2, b3, n2), p2[b3].S[c2 - 1] = l2);
          V2([], k, function(r2) {
            r2 = ob(n2, [r2[0], null].concat(r2.slice(1)), null, f2, g2);
            void 0 === p2[b3].S ? (r2.Z = c2 - 1, p2[b3] = r2) : p2[b3].S[c2 - 1] = r2;
            return [];
          });
          return [];
        });
      },
      p: function(a2, b3, c2, d2, e2, f2) {
        0 < b3 || x2();
        var g2 = pb(
          b3,
          c2
        );
        e2 = Z3(d2, e2);
        V2([], [a2], function(k) {
          k = k[0];
          var m = "constructor " + k.name;
          void 0 === k.N.Y && (k.N.Y = []);
          if (void 0 !== k.N.Y[b3 - 1])
            throw new K2("Cannot register multiple constructors with identical number of parameters (" + (b3 - 1) + ") for class '" + k.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
          k.N.Y[b3 - 1] = () => {
            nb("Cannot construct " + k.name + " due to unbound types", g2);
          };
          V2([], g2, function(l2) {
            l2.splice(1, 0, null);
            k.N.Y[b3 - 1] = ob(m, l2, null, e2, f2);
            return [];
          });
          return [];
        });
      },
      a: function(a2, b3, c2, d2, e2, f2, g2, k) {
        var m = pb(c2, d2);
        b3 = N2(b3);
        f2 = Z3(e2, f2);
        V2([], [a2], function(l2) {
          function n2() {
            nb("Cannot call " + p2 + " due to unbound types", m);
          }
          l2 = l2[0];
          var p2 = l2.name + "." + b3;
          b3.startsWith("@@") && (b3 = Symbol[b3.substring(2)]);
          k && l2.N.ja.push(b3);
          var r2 = l2.N.X, u2 = r2[b3];
          void 0 === u2 || void 0 === u2.S && u2.className !== l2.name && u2.Z === c2 - 2 ? (n2.Z = c2 - 2, n2.className = l2.name, r2[b3] = n2) : (ab2(r2, b3, p2), r2[b3].S[c2 - 2] = n2);
          V2([], m, function(t2) {
            t2 = ob(p2, t2, l2, f2, g2);
            void 0 === r2[b3].S ? (t2.Z = c2 - 2, r2[b3] = t2) : r2[b3].S[c2 - 2] = t2;
            return [];
          });
          return [];
        });
      },
      A: function(a2, b3) {
        b3 = N2(b3);
        W2(
          a2,
          { name: b3, fromWireType: function(c2) {
            var d2 = M3(c2);
            qb(c2);
            return d2;
          }, toWireType: function(c2, d2) {
            return Ea2(d2);
          }, argPackAdvance: 8, readValueFromPointer: Xa, V: null }
        );
      },
      n: function(a2, b3, c2) {
        c2 = Za(c2);
        b3 = N2(b3);
        W2(a2, { name: b3, fromWireType: function(d2) {
          return d2;
        }, toWireType: function(d2, e2) {
          return e2;
        }, argPackAdvance: 8, readValueFromPointer: rb(b3, c2), V: null });
      },
      e: function(a2, b3, c2, d2, e2) {
        b3 = N2(b3);
        -1 === e2 && (e2 = 4294967295);
        e2 = Za(c2);
        var f2 = (k) => k;
        if (0 === d2) {
          var g2 = 32 - 8 * c2;
          f2 = (k) => k << g2 >>> g2;
        }
        c2 = b3.includes("unsigned") ? function(k, m) {
          return m >>> 0;
        } : function(k, m) {
          return m;
        };
        W2(a2, { name: b3, fromWireType: f2, toWireType: c2, argPackAdvance: 8, readValueFromPointer: sb2(b3, e2, 0 !== d2), V: null });
      },
      b: function(a2, b3, c2) {
        function d2(f2) {
          f2 >>= 2;
          var g2 = E2;
          return new e2(ia, g2[f2 + 1], g2[f2]);
        }
        var e2 = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][b3];
        c2 = N2(c2);
        W2(a2, { name: c2, fromWireType: d2, argPackAdvance: 8, readValueFromPointer: d2 }, { ua: true });
      },
      o: function(a2, b3) {
        b3 = N2(b3);
        var c2 = "std::string" === b3;
        W2(a2, { name: b3, fromWireType: function(d2) {
          var e2 = E2[d2 >> 2], f2 = d2 + 4;
          if (c2)
            for (var g2 = f2, k = 0; k <= e2; ++k) {
              var m = f2 + k;
              if (k == e2 || 0 == A[m]) {
                g2 = g2 ? z3(A, g2, m - g2) : "";
                if (void 0 === l2)
                  var l2 = g2;
                else
                  l2 += String.fromCharCode(0), l2 += g2;
                g2 = m + 1;
              }
            }
          else {
            l2 = Array(e2);
            for (k = 0; k < e2; ++k)
              l2[k] = String.fromCharCode(A[f2 + k]);
            l2 = l2.join("");
          }
          S3(d2);
          return l2;
        }, toWireType: function(d2, e2) {
          e2 instanceof ArrayBuffer && (e2 = new Uint8Array(e2));
          var f2, g2 = "string" == typeof e2;
          g2 || e2 instanceof Uint8Array || e2 instanceof Uint8ClampedArray || e2 instanceof Int8Array || L3("Cannot pass non-string to std::string");
          if (c2 && g2) {
            var k = 0;
            for (f2 = 0; f2 < e2.length; ++f2) {
              var m = e2.charCodeAt(f2);
              127 >= m ? k++ : 2047 >= m ? k += 2 : 55296 <= m && 57343 >= m ? (k += 4, ++f2) : k += 3;
            }
            f2 = k;
          } else
            f2 = e2.length;
          k = Ib(4 + f2 + 1);
          m = k + 4;
          E2[k >> 2] = f2;
          if (c2 && g2) {
            if (g2 = m, m = f2 + 1, f2 = A, 0 < m) {
              m = g2 + m - 1;
              for (var l2 = 0; l2 < e2.length; ++l2) {
                var n2 = e2.charCodeAt(l2);
                if (55296 <= n2 && 57343 >= n2) {
                  var p2 = e2.charCodeAt(++l2);
                  n2 = 65536 + ((n2 & 1023) << 10) | p2 & 1023;
                }
                if (127 >= n2) {
                  if (g2 >= m)
                    break;
                  f2[g2++] = n2;
                } else {
                  if (2047 >= n2) {
                    if (g2 + 1 >= m)
                      break;
                    f2[g2++] = 192 | n2 >> 6;
                  } else {
                    if (65535 >= n2) {
                      if (g2 + 2 >= m)
                        break;
                      f2[g2++] = 224 | n2 >> 12;
                    } else {
                      if (g2 + 3 >= m)
                        break;
                      f2[g2++] = 240 | n2 >> 18;
                      f2[g2++] = 128 | n2 >> 12 & 63;
                    }
                    f2[g2++] = 128 | n2 >> 6 & 63;
                  }
                  f2[g2++] = 128 | n2 & 63;
                }
              }
              f2[g2] = 0;
            }
          } else if (g2)
            for (g2 = 0; g2 < f2; ++g2)
              l2 = e2.charCodeAt(g2), 255 < l2 && (S3(m), L3("String has UTF-16 code units that do not fit in 8 bits")), A[m + g2] = l2;
          else
            for (g2 = 0; g2 < f2; ++g2)
              A[m + g2] = e2[g2];
          null !== d2 && d2.push(S3, k);
          return k;
        }, argPackAdvance: 8, readValueFromPointer: Xa, V: function(d2) {
          S3(d2);
        } });
      },
      i: function(a2, b3, c2) {
        c2 = N2(c2);
        if (2 === b3) {
          var d2 = tb;
          var e2 = ub;
          var f2 = vb;
          var g2 = () => ka2;
          var k = 1;
        } else
          4 === b3 && (d2 = wb, e2 = xb, f2 = yb, g2 = () => E2, k = 2);
        W2(a2, { name: c2, fromWireType: function(m) {
          for (var l2 = E2[m >> 2], n2 = g2(), p2, r2 = m + 4, u2 = 0; u2 <= l2; ++u2) {
            var t2 = m + 4 + u2 * b3;
            if (u2 == l2 || 0 == n2[t2 >> k])
              r2 = d2(r2, t2 - r2), void 0 === p2 ? p2 = r2 : (p2 += String.fromCharCode(0), p2 += r2), r2 = t2 + b3;
          }
          S3(m);
          return p2;
        }, toWireType: function(m, l2) {
          "string" != typeof l2 && L3("Cannot pass non-string to C++ string type " + c2);
          var n2 = f2(l2), p2 = Ib(4 + n2 + b3);
          E2[p2 >> 2] = n2 >> k;
          e2(l2, p2 + 4, n2 + b3);
          null !== m && m.push(S3, p2);
          return p2;
        }, argPackAdvance: 8, readValueFromPointer: Xa, V: function(m) {
          S3(m);
        } });
      },
      k: function(a2, b3, c2, d2, e2, f2) {
        Va[a2] = { name: N2(b3), fa: Z3(c2, d2), W: Z3(e2, f2), ia: [] };
      },
      h: function(a2, b3, c2, d2, e2, f2, g2, k, m, l2) {
        Va[a2].ia.push({ oa: N2(b3), ta: c2, ra: Z3(d2, e2), sa: f2, za: g2, ya: Z3(k, m), Aa: l2 });
      },
      C: function(a2, b3) {
        b3 = N2(b3);
        W2(a2, {
          va: true,
          name: b3,
          argPackAdvance: 0,
          fromWireType: function() {
          },
          toWireType: function() {
          }
        });
      },
      s: function(a2, b3, c2, d2, e2) {
        a2 = Bb[a2];
        b3 = M3(b3);
        c2 = Ab(c2);
        var f2 = [];
        E2[d2 >> 2] = Ea2(f2);
        return a2(b3, c2, f2, e2);
      },
      t: function(a2, b3, c2, d2) {
        a2 = Bb[a2];
        b3 = M3(b3);
        c2 = Ab(c2);
        a2(b3, c2, null, d2);
      },
      g: qb,
      m: function(a2, b3) {
        var c2 = Db(a2, b3), d2 = c2[0];
        b3 = d2.name + "_$" + c2.slice(1).map(function(g2) {
          return g2.name;
        }).join("_") + "$";
        var e2 = Eb[b3];
        if (void 0 !== e2)
          return e2;
        var f2 = Array(a2 - 1);
        e2 = Cb((g2, k, m, l2) => {
          for (var n2 = 0, p2 = 0; p2 < a2 - 1; ++p2)
            f2[p2] = c2[p2 + 1].readValueFromPointer(l2 + n2), n2 += c2[p2 + 1].argPackAdvance;
          g2 = g2[k].apply(
            g2,
            f2
          );
          for (p2 = 0; p2 < a2 - 1; ++p2)
            c2[p2 + 1].ma && c2[p2 + 1].ma(f2[p2]);
          if (!d2.va)
            return d2.toWireType(m, g2);
        });
        return Eb[b3] = e2;
      },
      D: function(a2) {
        4 < a2 && (J3[a2].ga += 1);
      },
      r: function(a2) {
        var b3 = M3(a2);
        Wa(b3);
        qb(a2);
      },
      c: function() {
        x2("");
      },
      x: function(a2, b3, c2) {
        A.copyWithin(a2, b3, b3 + c2);
      },
      w: function(a2) {
        var b3 = A.length;
        a2 >>>= 0;
        if (2147483648 < a2)
          return false;
        for (var c2 = 1; 4 >= c2; c2 *= 2) {
          var d2 = b3 * (1 + 0.2 / c2);
          d2 = Math.min(d2, a2 + 100663296);
          var e2 = Math;
          d2 = Math.max(a2, d2);
          e2 = e2.min.call(e2, 2147483648, d2 + (65536 - d2 % 65536) % 65536);
          a: {
            try {
              fa2.grow(e2 - ia.byteLength + 65535 >>> 16);
              na();
              var f2 = 1;
              break a;
            } catch (g2) {
            }
            f2 = void 0;
          }
          if (f2)
            return true;
        }
        return false;
      },
      z: function() {
        return 52;
      },
      u: function() {
        return 70;
      },
      y: function(a2, b3, c2, d2) {
        for (var e2 = 0, f2 = 0; f2 < c2; f2++) {
          var g2 = E2[b3 >> 2], k = E2[b3 + 4 >> 2];
          b3 += 8;
          for (var m = 0; m < k; m++) {
            var l2 = A[g2 + m], n2 = Fb[a2];
            0 === l2 || 10 === l2 ? ((1 === a2 ? ea : v2)(z3(n2, 0)), n2.length = 0) : n2.push(l2);
          }
          e2 += k;
        }
        E2[d2 >> 2] = e2;
        return 0;
      }
    };
    (function() {
      function a2(e2) {
        h2.asm = e2.exports;
        fa2 = h2.asm.E;
        na();
        oa2 = h2.asm.J;
        qa.unshift(h2.asm.F);
        F--;
        h2.monitorRunDependencies && h2.monitorRunDependencies(F);
        0 == F && (null !== ta && (clearInterval(ta), ta = null), G3 && (e2 = G3, G3 = null, e2()));
      }
      function b3(e2) {
        a2(e2.instance);
      }
      function c2(e2) {
        return ya().then(function(f2) {
          return WebAssembly.instantiate(f2, d2);
        }).then(function(f2) {
          return f2;
        }).then(e2, function(f2) {
          v2("failed to asynchronously prepare wasm: " + f2);
          x2(f2);
        });
      }
      var d2 = { a: Jb };
      F++;
      h2.monitorRunDependencies && h2.monitorRunDependencies(F);
      if (h2.instantiateWasm)
        try {
          return h2.instantiateWasm(
            d2,
            a2
          );
        } catch (e2) {
          v2("Module.instantiateWasm callback failed with error: " + e2), ca2(e2);
        }
      (function() {
        return w2 || "function" != typeof WebAssembly.instantiateStreaming || ua2(H3) || "function" != typeof fetch ? c2(b3) : fetch(H3, { credentials: "same-origin" }).then(function(e2) {
          return WebAssembly.instantiateStreaming(e2, d2).then(b3, function(f2) {
            v2("wasm streaming compile failed: " + f2);
            v2("falling back to ArrayBuffer instantiation");
            return c2(b3);
          });
        });
      })().catch(ca2);
      return {};
    })();
    h2.___wasm_call_ctors = function() {
      return (h2.___wasm_call_ctors = h2.asm.F).apply(null, arguments);
    };
    var Ka = h2.___getTypeName = function() {
      return (Ka = h2.___getTypeName = h2.asm.G).apply(null, arguments);
    };
    h2.__embind_initialize_bindings = function() {
      return (h2.__embind_initialize_bindings = h2.asm.H).apply(null, arguments);
    };
    var Ib = h2._malloc = function() {
      return (Ib = h2._malloc = h2.asm.I).apply(null, arguments);
    }, S3 = h2._free = function() {
      return (S3 = h2._free = h2.asm.K).apply(null, arguments);
    };
    h2.dynCall_jiji = function() {
      return (h2.dynCall_jiji = h2.asm.L).apply(null, arguments);
    };
    var Kb2;
    G3 = function Lb() {
      Kb2 || Mb();
      Kb2 || (G3 = Lb);
    };
    function Mb() {
      function a2() {
        if (!Kb2 && (Kb2 = true, h2.calledRun = true, !ha2)) {
          za(qa);
          aa2(h2);
          if (h2.onRuntimeInitialized)
            h2.onRuntimeInitialized();
          if (h2.postRun)
            for ("function" == typeof h2.postRun && (h2.postRun = [h2.postRun]); h2.postRun.length; ) {
              var b3 = h2.postRun.shift();
              ra.unshift(b3);
            }
          za(ra);
        }
      }
      if (!(0 < F)) {
        if (h2.preRun)
          for ("function" == typeof h2.preRun && (h2.preRun = [h2.preRun]); h2.preRun.length; )
            sa2();
        za(pa2);
        0 < F || (h2.setStatus ? (h2.setStatus("Running..."), setTimeout(function() {
          setTimeout(function() {
            h2.setStatus("");
          }, 1);
          a2();
        }, 1)) : a2());
      }
    }
    if (h2.preInit)
      for ("function" == typeof h2.preInit && (h2.preInit = [h2.preInit]); 0 < h2.preInit.length; )
        h2.preInit.pop()();
    Mb();
    return loadYoga3.ready;
  };
})();
var yoga_wasm_base64_esm_default = loadYoga;

// node_modules/yoga-layout/dist/src/generated/YGEnums.js
var Align = function(Align2) {
  Align2[Align2["Auto"] = 0] = "Auto";
  Align2[Align2["FlexStart"] = 1] = "FlexStart";
  Align2[Align2["Center"] = 2] = "Center";
  Align2[Align2["FlexEnd"] = 3] = "FlexEnd";
  Align2[Align2["Stretch"] = 4] = "Stretch";
  Align2[Align2["Baseline"] = 5] = "Baseline";
  Align2[Align2["SpaceBetween"] = 6] = "SpaceBetween";
  Align2[Align2["SpaceAround"] = 7] = "SpaceAround";
  Align2[Align2["SpaceEvenly"] = 8] = "SpaceEvenly";
  return Align2;
}({});
var Dimension = function(Dimension2) {
  Dimension2[Dimension2["Width"] = 0] = "Width";
  Dimension2[Dimension2["Height"] = 1] = "Height";
  return Dimension2;
}({});
var Direction = function(Direction2) {
  Direction2[Direction2["Inherit"] = 0] = "Inherit";
  Direction2[Direction2["LTR"] = 1] = "LTR";
  Direction2[Direction2["RTL"] = 2] = "RTL";
  return Direction2;
}({});
var Display = function(Display2) {
  Display2[Display2["Flex"] = 0] = "Flex";
  Display2[Display2["None"] = 1] = "None";
  return Display2;
}({});
var Edge = function(Edge2) {
  Edge2[Edge2["Left"] = 0] = "Left";
  Edge2[Edge2["Top"] = 1] = "Top";
  Edge2[Edge2["Right"] = 2] = "Right";
  Edge2[Edge2["Bottom"] = 3] = "Bottom";
  Edge2[Edge2["Start"] = 4] = "Start";
  Edge2[Edge2["End"] = 5] = "End";
  Edge2[Edge2["Horizontal"] = 6] = "Horizontal";
  Edge2[Edge2["Vertical"] = 7] = "Vertical";
  Edge2[Edge2["All"] = 8] = "All";
  return Edge2;
}({});
var Errata = function(Errata2) {
  Errata2[Errata2["None"] = 0] = "None";
  Errata2[Errata2["StretchFlexBasis"] = 1] = "StretchFlexBasis";
  Errata2[Errata2["AbsolutePositioningIncorrect"] = 2] = "AbsolutePositioningIncorrect";
  Errata2[Errata2["AbsolutePercentAgainstInnerSize"] = 4] = "AbsolutePercentAgainstInnerSize";
  Errata2[Errata2["All"] = 2147483647] = "All";
  Errata2[Errata2["Classic"] = 2147483646] = "Classic";
  return Errata2;
}({});
var ExperimentalFeature = function(ExperimentalFeature2) {
  ExperimentalFeature2[ExperimentalFeature2["WebFlexBasis"] = 0] = "WebFlexBasis";
  return ExperimentalFeature2;
}({});
var FlexDirection = function(FlexDirection2) {
  FlexDirection2[FlexDirection2["Column"] = 0] = "Column";
  FlexDirection2[FlexDirection2["ColumnReverse"] = 1] = "ColumnReverse";
  FlexDirection2[FlexDirection2["Row"] = 2] = "Row";
  FlexDirection2[FlexDirection2["RowReverse"] = 3] = "RowReverse";
  return FlexDirection2;
}({});
var Gutter = function(Gutter2) {
  Gutter2[Gutter2["Column"] = 0] = "Column";
  Gutter2[Gutter2["Row"] = 1] = "Row";
  Gutter2[Gutter2["All"] = 2] = "All";
  return Gutter2;
}({});
var Justify = function(Justify2) {
  Justify2[Justify2["FlexStart"] = 0] = "FlexStart";
  Justify2[Justify2["Center"] = 1] = "Center";
  Justify2[Justify2["FlexEnd"] = 2] = "FlexEnd";
  Justify2[Justify2["SpaceBetween"] = 3] = "SpaceBetween";
  Justify2[Justify2["SpaceAround"] = 4] = "SpaceAround";
  Justify2[Justify2["SpaceEvenly"] = 5] = "SpaceEvenly";
  return Justify2;
}({});
var LogLevel = function(LogLevel2) {
  LogLevel2[LogLevel2["Error"] = 0] = "Error";
  LogLevel2[LogLevel2["Warn"] = 1] = "Warn";
  LogLevel2[LogLevel2["Info"] = 2] = "Info";
  LogLevel2[LogLevel2["Debug"] = 3] = "Debug";
  LogLevel2[LogLevel2["Verbose"] = 4] = "Verbose";
  LogLevel2[LogLevel2["Fatal"] = 5] = "Fatal";
  return LogLevel2;
}({});
var MeasureMode = function(MeasureMode2) {
  MeasureMode2[MeasureMode2["Undefined"] = 0] = "Undefined";
  MeasureMode2[MeasureMode2["Exactly"] = 1] = "Exactly";
  MeasureMode2[MeasureMode2["AtMost"] = 2] = "AtMost";
  return MeasureMode2;
}({});
var NodeType = function(NodeType2) {
  NodeType2[NodeType2["Default"] = 0] = "Default";
  NodeType2[NodeType2["Text"] = 1] = "Text";
  return NodeType2;
}({});
var Overflow = function(Overflow2) {
  Overflow2[Overflow2["Visible"] = 0] = "Visible";
  Overflow2[Overflow2["Hidden"] = 1] = "Hidden";
  Overflow2[Overflow2["Scroll"] = 2] = "Scroll";
  return Overflow2;
}({});
var PositionType = function(PositionType2) {
  PositionType2[PositionType2["Static"] = 0] = "Static";
  PositionType2[PositionType2["Relative"] = 1] = "Relative";
  PositionType2[PositionType2["Absolute"] = 2] = "Absolute";
  return PositionType2;
}({});
var Unit = function(Unit2) {
  Unit2[Unit2["Undefined"] = 0] = "Undefined";
  Unit2[Unit2["Point"] = 1] = "Point";
  Unit2[Unit2["Percent"] = 2] = "Percent";
  Unit2[Unit2["Auto"] = 3] = "Auto";
  return Unit2;
}({});
var Wrap = function(Wrap2) {
  Wrap2[Wrap2["NoWrap"] = 0] = "NoWrap";
  Wrap2[Wrap2["Wrap"] = 1] = "Wrap";
  Wrap2[Wrap2["WrapReverse"] = 2] = "WrapReverse";
  return Wrap2;
}({});
var constants = {
  ALIGN_AUTO: Align.Auto,
  ALIGN_FLEX_START: Align.FlexStart,
  ALIGN_CENTER: Align.Center,
  ALIGN_FLEX_END: Align.FlexEnd,
  ALIGN_STRETCH: Align.Stretch,
  ALIGN_BASELINE: Align.Baseline,
  ALIGN_SPACE_BETWEEN: Align.SpaceBetween,
  ALIGN_SPACE_AROUND: Align.SpaceAround,
  ALIGN_SPACE_EVENLY: Align.SpaceEvenly,
  DIMENSION_WIDTH: Dimension.Width,
  DIMENSION_HEIGHT: Dimension.Height,
  DIRECTION_INHERIT: Direction.Inherit,
  DIRECTION_LTR: Direction.LTR,
  DIRECTION_RTL: Direction.RTL,
  DISPLAY_FLEX: Display.Flex,
  DISPLAY_NONE: Display.None,
  EDGE_LEFT: Edge.Left,
  EDGE_TOP: Edge.Top,
  EDGE_RIGHT: Edge.Right,
  EDGE_BOTTOM: Edge.Bottom,
  EDGE_START: Edge.Start,
  EDGE_END: Edge.End,
  EDGE_HORIZONTAL: Edge.Horizontal,
  EDGE_VERTICAL: Edge.Vertical,
  EDGE_ALL: Edge.All,
  ERRATA_NONE: Errata.None,
  ERRATA_STRETCH_FLEX_BASIS: Errata.StretchFlexBasis,
  ERRATA_ABSOLUTE_POSITIONING_INCORRECT: Errata.AbsolutePositioningIncorrect,
  ERRATA_ABSOLUTE_PERCENT_AGAINST_INNER_SIZE: Errata.AbsolutePercentAgainstInnerSize,
  ERRATA_ALL: Errata.All,
  ERRATA_CLASSIC: Errata.Classic,
  EXPERIMENTAL_FEATURE_WEB_FLEX_BASIS: ExperimentalFeature.WebFlexBasis,
  FLEX_DIRECTION_COLUMN: FlexDirection.Column,
  FLEX_DIRECTION_COLUMN_REVERSE: FlexDirection.ColumnReverse,
  FLEX_DIRECTION_ROW: FlexDirection.Row,
  FLEX_DIRECTION_ROW_REVERSE: FlexDirection.RowReverse,
  GUTTER_COLUMN: Gutter.Column,
  GUTTER_ROW: Gutter.Row,
  GUTTER_ALL: Gutter.All,
  JUSTIFY_FLEX_START: Justify.FlexStart,
  JUSTIFY_CENTER: Justify.Center,
  JUSTIFY_FLEX_END: Justify.FlexEnd,
  JUSTIFY_SPACE_BETWEEN: Justify.SpaceBetween,
  JUSTIFY_SPACE_AROUND: Justify.SpaceAround,
  JUSTIFY_SPACE_EVENLY: Justify.SpaceEvenly,
  LOG_LEVEL_ERROR: LogLevel.Error,
  LOG_LEVEL_WARN: LogLevel.Warn,
  LOG_LEVEL_INFO: LogLevel.Info,
  LOG_LEVEL_DEBUG: LogLevel.Debug,
  LOG_LEVEL_VERBOSE: LogLevel.Verbose,
  LOG_LEVEL_FATAL: LogLevel.Fatal,
  MEASURE_MODE_UNDEFINED: MeasureMode.Undefined,
  MEASURE_MODE_EXACTLY: MeasureMode.Exactly,
  MEASURE_MODE_AT_MOST: MeasureMode.AtMost,
  NODE_TYPE_DEFAULT: NodeType.Default,
  NODE_TYPE_TEXT: NodeType.Text,
  OVERFLOW_VISIBLE: Overflow.Visible,
  OVERFLOW_HIDDEN: Overflow.Hidden,
  OVERFLOW_SCROLL: Overflow.Scroll,
  POSITION_TYPE_STATIC: PositionType.Static,
  POSITION_TYPE_RELATIVE: PositionType.Relative,
  POSITION_TYPE_ABSOLUTE: PositionType.Absolute,
  UNIT_UNDEFINED: Unit.Undefined,
  UNIT_POINT: Unit.Point,
  UNIT_PERCENT: Unit.Percent,
  UNIT_AUTO: Unit.Auto,
  WRAP_NO_WRAP: Wrap.NoWrap,
  WRAP_WRAP: Wrap.Wrap,
  WRAP_WRAP_REVERSE: Wrap.WrapReverse
};
var YGEnums_default = constants;

// node_modules/yoga-layout/dist/src/wrapAssembly.js
function wrapAssembly(lib) {
  function patch(prototype, name, fn3) {
    const original = prototype[name];
    prototype[name] = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return fn3.call(this, original, ...args);
    };
  }
  for (const fnName of ["setPosition", "setMargin", "setFlexBasis", "setWidth", "setHeight", "setMinWidth", "setMinHeight", "setMaxWidth", "setMaxHeight", "setPadding", "setGap"]) {
    const methods = {
      [Unit.Point]: lib.Node.prototype[fnName],
      [Unit.Percent]: lib.Node.prototype[`${fnName}Percent`],
      [Unit.Auto]: lib.Node.prototype[`${fnName}Auto`]
    };
    patch(lib.Node.prototype, fnName, function(original) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      const value = args.pop();
      let unit, asNumber;
      if (value === "auto") {
        unit = Unit.Auto;
        asNumber = void 0;
      } else if (typeof value === "object") {
        unit = value.unit;
        asNumber = value.valueOf();
      } else {
        unit = typeof value === "string" && value.endsWith("%") ? Unit.Percent : Unit.Point;
        asNumber = parseFloat(value);
        if (value !== void 0 && !Number.isNaN(value) && Number.isNaN(asNumber)) {
          throw new Error(`Invalid value ${value} for ${fnName}`);
        }
      }
      if (!methods[unit])
        throw new Error(`Failed to execute "${fnName}": Unsupported unit '${value}'`);
      if (asNumber !== void 0) {
        return methods[unit].call(this, ...args, asNumber);
      } else {
        return methods[unit].call(this, ...args);
      }
    });
  }
  function wrapMeasureFunction(measureFunction) {
    return lib.MeasureCallback.implement({
      measure: function() {
        const {
          width,
          height
        } = measureFunction(...arguments);
        return {
          width: width ?? NaN,
          height: height ?? NaN
        };
      }
    });
  }
  patch(lib.Node.prototype, "setMeasureFunc", function(original, measureFunc) {
    if (measureFunc) {
      return original.call(this, wrapMeasureFunction(measureFunc));
    } else {
      return this.unsetMeasureFunc();
    }
  });
  function wrapDirtiedFunc(dirtiedFunction) {
    return lib.DirtiedCallback.implement({
      dirtied: dirtiedFunction
    });
  }
  patch(lib.Node.prototype, "setDirtiedFunc", function(original, dirtiedFunc) {
    original.call(this, wrapDirtiedFunc(dirtiedFunc));
  });
  patch(lib.Config.prototype, "free", function() {
    lib.Config.destroy(this);
  });
  patch(lib.Node, "create", (_3, config) => {
    return config ? lib.Node.createWithConfig(config) : lib.Node.createDefault();
  });
  patch(lib.Node.prototype, "free", function() {
    lib.Node.destroy(this);
  });
  patch(lib.Node.prototype, "freeRecursive", function() {
    for (let t2 = 0, T3 = this.getChildCount(); t2 < T3; ++t2) {
      this.getChild(0).freeRecursive();
    }
    this.free();
  });
  patch(lib.Node.prototype, "calculateLayout", function(original) {
    let width = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : NaN;
    let height = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NaN;
    let direction = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Direction.LTR;
    return original.call(this, width, height, direction);
  });
  return {
    Config: lib.Config,
    Node: lib.Node,
    ...YGEnums_default
  };
}

// node_modules/yoga-layout/dist/src/load.js
async function loadYoga2() {
  return wrapAssembly(await yoga_wasm_base64_esm_default());
}

// node_modules/@pmndrs/uikit/dist/clipping.js
var dotLt45deg = Math.cos(45 / 180 * Math.PI);
var helperPlanes = [new Plane(), new Plane(), new Plane(), new Plane()];
var positionHelper = new Vector3();
var ClippingRect = class {
  constructor(globalMatrix, centerX, centerY, width, height) {
    __publicField(this, "planes");
    __publicField(this, "facePlane");
    __publicField(this, "originalCenter");
    this.originalCenter = new Vector3(centerX, centerY, 0).applyMatrix4(globalMatrix);
    this.facePlane = new Plane(new Vector3(0, 0, 1), 0).applyMatrix4(globalMatrix);
    const halfWidth = width / 2;
    const halfHeight = height / 2;
    const top = centerY + halfHeight;
    const right = centerX + halfWidth;
    const bottom = -centerY + halfHeight;
    const left = -centerX + halfWidth;
    this.planes = [
      new Plane(new Vector3(0, -1, 0), bottom).applyMatrix4(globalMatrix),
      new Plane(new Vector3(-1, 0, 0), left).applyMatrix4(globalMatrix),
      new Plane(new Vector3(0, 1, 0), top).applyMatrix4(globalMatrix),
      new Plane(new Vector3(1, 0, 0), right).applyMatrix4(globalMatrix)
    ];
  }
  min({ planes }) {
    for (let i2 = 0; i2 < 4; i2++) {
      const p1 = this.facePlane;
      const p2 = planes[i2];
      const n1n2DotProduct = p1.normal.dot(p2.normal);
      if (Math.abs(n1n2DotProduct) > 0.99) {
        return this;
      }
      const helperPlane = helperPlanes[i2];
      if (Math.abs(n1n2DotProduct) < 0.01) {
        helperPlane.copy(p2);
        continue;
      }
      helperPlane.normal.crossVectors(p1.normal, p2.normal).normalize().cross(p1.normal).negate();
      const divisor = 1 - n1n2DotProduct * n1n2DotProduct;
      const c1 = (p1.constant - p2.constant * n1n2DotProduct) / divisor;
      const c2 = (p2.constant - p1.constant * n1n2DotProduct) / divisor;
      positionHelper.copy(p1.normal).multiplyScalar(c1).addScaledVector(p2.normal, c2);
      helperPlane.constant = -positionHelper.dot(helperPlane.normal);
    }
    let indexOffset = 0;
    const firstPlaneNormal = this.planes[0].normal;
    while (helperPlanes[indexOffset].normal.dot(firstPlaneNormal) > dotLt45deg) {
      break;
    }
    for (let i2 = 0; i2 < 4; i2++) {
      const plane = this.planes[i2];
      const otherPlaneIndex = (i2 + indexOffset) % 4;
      if (helperPlanes[otherPlaneIndex].distanceToPoint(this.originalCenter) < plane.distanceToPoint(this.originalCenter)) {
        plane.copy(planes[otherPlaneIndex]);
      }
    }
    return this;
  }
  toArray(array, offset) {
    for (let i2 = 0; i2 < 4; i2++) {
      const { normal, constant } = this.planes[i2];
      normal.toArray(array, offset);
      array[offset + 3] = constant;
      offset += 4;
    }
  }
};
var helperPoints = [new Vector3(), new Vector3(), new Vector3(), new Vector3()];
var multiplier = [
  [-0.5, -0.5],
  [0.5, -0.5],
  [0.5, 0.5],
  [-0.5, 0.5]
];
function computedIsClipped(parentClippingRect, globalMatrix, size, pixelSizeSignal) {
  return w(() => {
    if (size.value == null) {
      return true;
    }
    const global2 = globalMatrix.value;
    const rect = parentClippingRect == null ? void 0 : parentClippingRect.value;
    if (rect == null || global2 == null) {
      return false;
    }
    const [width, height] = size.value;
    const pixelSize = pixelSizeSignal.value;
    for (let i2 = 0; i2 < 4; i2++) {
      const [mx2, my] = multiplier[i2];
      helperPoints[i2].set(mx2 * pixelSize * width, my * pixelSize * height, 0).applyMatrix4(global2);
    }
    const { planes } = rect;
    let allOutside;
    for (let planeIndex = 0; planeIndex < 4; planeIndex++) {
      const clippingPlane = planes[planeIndex];
      allOutside = true;
      for (let pointIndex = 0; pointIndex < 4; pointIndex++) {
        const point = helperPoints[pointIndex];
        if (clippingPlane.distanceToPoint(point) >= 0) {
          allOutside = false;
        }
      }
      if (allOutside) {
        return true;
      }
    }
    return false;
  });
}
function computedClippingRect(globalMatrix, { overflow, borderInset, size }, pixelSizeSignal, parentClippingRect) {
  return w(() => {
    const global2 = globalMatrix.value;
    if (global2 == null || overflow.value === Overflow.Visible) {
      return parentClippingRect == null ? void 0 : parentClippingRect.value;
    }
    if (size.value == null || borderInset.value == null) {
      return void 0;
    }
    const [width, height] = size.value;
    const [top, right, bottom, left] = borderInset.value;
    const pixelSize = pixelSizeSignal.value;
    const rect = new ClippingRect(global2, (right - left) * pixelSize / 2, (top - bottom) * pixelSize / 2, (width - left - right) * pixelSize, (height - top - bottom) * pixelSize);
    if ((parentClippingRect == null ? void 0 : parentClippingRect.value) != null) {
      rect.min(parentClippingRect.value);
    }
    return rect;
  });
}
var NoClippingPlane = new Plane(new Vector3(-1, 0, 0), Number.MAX_SAFE_INTEGER);
var defaultClippingData = new Float32Array(16);
for (let i2 = 0; i2 < 4; i2++) {
  NoClippingPlane.normal.toArray(defaultClippingData, i2 * 4);
  defaultClippingData[i2 * 4 + 3] = NoClippingPlane.constant;
}
function createGlobalClippingPlanes(root, clippingRect, initializers) {
  const planes = [new Plane(), new Plane(), new Plane(), new Plane()];
  const updateClippingPlanes = () => {
    var _a;
    if (root.object.current == null) {
      return;
    }
    const localPlanes = (_a = clippingRect == null ? void 0 : clippingRect.value) == null ? void 0 : _a.planes;
    if (localPlanes == null) {
      for (let i2 = 0; i2 < 4; i2++) {
        planes[i2].copy(NoClippingPlane);
      }
      return;
    }
    for (let i2 = 0; i2 < 4; i2++) {
      planes[i2].copy(localPlanes[i2]).applyMatrix4(root.object.current.matrixWorld);
    }
  };
  initializers.push(() => {
    root.onFrameSet.add(updateClippingPlanes);
    return () => root.onFrameSet.delete(updateClippingPlanes);
  });
  return planes;
}

// node_modules/@pmndrs/uikit/dist/allocation/sorted-buckets.js
function assureBucketExists(buckets, bucketIndex) {
  while (bucketIndex >= buckets.length) {
    let offset = 0;
    let missingSpace = 0;
    if (buckets.length > 0) {
      const prevBucket = buckets[buckets.length - 1];
      offset += prevBucket.offset + prevBucket.elements.length;
      missingSpace = Math.min(0, prevBucket.missingSpace);
      prevBucket.missingSpace -= missingSpace;
    }
    buckets.push({
      add: [],
      missingSpace,
      offset,
      elements: []
    });
  }
}
function resizeSortedBucketsSpace(buckets, oldSize, newSize) {
  assureBucketExists(buckets, 0);
  const lastBucket = buckets[buckets.length - 1];
  lastBucket.missingSpace += oldSize - newSize;
}
function addToSortedBuckets(buckets, bucketIndex, element, activateElement) {
  assureBucketExists(buckets, bucketIndex);
  const bucket = buckets[bucketIndex];
  bucket.missingSpace += 1;
  if (bucket.missingSpace <= 0) {
    activateElement(element, bucket, bucket.elements.length);
    bucket.elements.push(element);
    return false;
  }
  bucket.add.push(element);
  return true;
}
function removeFromSortedBuckets(buckets, bucketIndex, element, elementIndex, activateElement, clearBufferAt, setElementIndex, bufferCopyWithin) {
  if (bucketIndex >= buckets.length) {
    throw new Error(`no bucket at index ${bucketIndex}`);
  }
  const bucket = buckets[bucketIndex];
  bucket.missingSpace -= 1;
  const addIndex = bucket.add.indexOf(element);
  if (addIndex != -1) {
    bucket.add.splice(addIndex, 1);
    return false;
  }
  if (elementIndex == null || elementIndex >= bucket.elements.length) {
    throw new Error(`no element at index ${elementIndex}`);
  }
  if (bucket.add.length > 0) {
    const newElement = bucket.add.shift();
    bucket.elements[elementIndex] = newElement;
    activateElement(newElement, bucket, elementIndex);
    return false;
  }
  const offset = bucket.offset;
  const lastIndexInBucket = bucket.elements.length - 1;
  if (lastIndexInBucket != elementIndex) {
    const startIndex = offset + lastIndexInBucket;
    const targetIndex = offset + elementIndex;
    bufferCopyWithin(targetIndex, startIndex, startIndex + 1);
    const swapElement = bucket.elements[lastIndexInBucket];
    bucket.elements[elementIndex] = swapElement;
    setElementIndex(swapElement, elementIndex);
  }
  clearBufferAt(offset + lastIndexInBucket);
  bucket.elements.length -= 1;
  if (bucketIndex < buckets.length - 1) {
    return true;
  }
  let currentBucket = bucket;
  while (currentBucket.elements.length === 0 && currentBucket.add.length == 0 && bucketIndex > 0) {
    const prevBucket = buckets[bucketIndex - 1];
    prevBucket.missingSpace += currentBucket.missingSpace;
    currentBucket = buckets[--bucketIndex];
  }
  buckets.length = bucketIndex + 1;
  return false;
}
function updateSortedBucketsAllocation(buckets, activateElement, bufferCopyWithin) {
  let bucketsLength = buckets.length;
  let lastBucketWithElements = -1;
  for (let i2 = 0; i2 < bucketsLength; i2++) {
    const bucket = buckets[i2];
    if (bucket.elements.length + bucket.add.length > 0) {
      lastBucketWithElements = i2;
    }
    const lastBucket = i2 === bucketsLength - 1;
    if (!lastBucket && bucket.missingSpace === 0) {
      continue;
    }
    const hasSpace = bucket.missingSpace < 0;
    for (let ii2 = i2 - 1; ii2 >= 0; ii2--) {
      const otherBucket = buckets[ii2];
      if (otherBucket.missingSpace === 0) {
        continue;
      }
      const otherHasSpace = otherBucket.missingSpace < 0;
      if (otherHasSpace && (lastBucket || hasSpace)) {
        shiftLeft(buckets, bufferCopyWithin, ii2, i2, Math.abs(otherBucket.missingSpace));
        continue;
      }
      if (!hasSpace && !otherHasSpace) {
        continue;
      }
      const shiftBy = Math.min(Math.abs(otherBucket.missingSpace), Math.abs(bucket.missingSpace));
      if (hasSpace) {
        shiftRight(buckets, bufferCopyWithin, ii2, i2, shiftBy);
      } else {
        shiftLeft(buckets, bufferCopyWithin, ii2, i2, shiftBy);
      }
    }
  }
  const newLastBucket = buckets[lastBucketWithElements];
  for (let i2 = lastBucketWithElements + 1; i2 < bucketsLength; i2++) {
    newLastBucket.missingSpace += buckets[i2].missingSpace;
  }
  bucketsLength = buckets.length = lastBucketWithElements + 1;
  for (let i2 = 0; i2 < bucketsLength; i2++) {
    const bucket = buckets[i2];
    const { elements, add } = bucket;
    const addLength = add.length;
    for (let ii2 = 0; ii2 < addLength; ii2++) {
      const element = add[ii2];
      activateElement(element, bucket, elements.length);
      elements.push(element);
    }
    add.length = 0;
  }
}
function shiftLeft(buckets, bufferCopyWithin, startIndexIncl, endIndexIncl, shiftBy) {
  const endBucket = buckets[endIndexIncl];
  const startIndex = buckets[startIndexIncl + 1].offset;
  bufferCopyWithin(startIndex - shiftBy, startIndex, endBucket.offset + endBucket.elements.length);
  const startBucket = buckets[startIndexIncl];
  startBucket.missingSpace += shiftBy;
  endBucket.missingSpace -= shiftBy;
  for (let i2 = startIndexIncl + 1; i2 <= endIndexIncl; i2++) {
    buckets[i2].offset -= shiftBy;
  }
}
function shiftRight(buckets, bufferCopyWithin, startIndexIncl, endIndexIncl, shiftBy) {
  const endBucket = buckets[endIndexIncl];
  const startIndex = buckets[startIndexIncl + 1].offset;
  bufferCopyWithin(startIndex + shiftBy, startIndex, endBucket.offset + endBucket.elements.length);
  const startBucket = buckets[startIndexIncl];
  startBucket.missingSpace -= shiftBy;
  endBucket.missingSpace += shiftBy;
  for (let i2 = startIndexIncl + 1; i2 <= endIndexIncl; i2++) {
    buckets[i2].offset += shiftBy;
  }
}

// node_modules/@pmndrs/uikit/dist/flex/setter.js
function convertEnum(lut, input, defaultValue) {
  if (input == null) {
    return defaultValue;
  }
  const resolvedValue = lut[input];
  if (resolvedValue == null) {
    throw new Error(`unexpected value ${input}, expected ${Object.keys(lut).join(", ")}`);
  }
  return resolvedValue;
}
var POSITION_TYPE_LUT = {
  "static": 0,
  "relative": 1,
  "absolute": 2
};
var ALIGN_LUT = {
  "auto": 0,
  "flex-start": 1,
  "center": 2,
  "flex-end": 3,
  "stretch": 4,
  "baseline": 5,
  "space-between": 6,
  "space-around": 7,
  "space-evenly": 8
};
var FLEX_DIRECTION_LUT = {
  "column": 0,
  "column-reverse": 1,
  "row": 2,
  "row-reverse": 3
};
var WRAP_LUT = {
  "no-wrap": 0,
  "wrap": 1,
  "wrap-reverse": 2
};
var JUSTIFY_LUT = {
  "flex-start": 0,
  "center": 1,
  "flex-end": 2,
  "space-between": 3,
  "space-around": 4,
  "space-evenly": 5
};
var OVERFLOW_LUT = {
  "visible": 0,
  "hidden": 1,
  "scroll": 2
};
var DISPLAY_LUT = {
  "flex": 0,
  "none": 1
};
var setter = {
  positionType: (node, input) => node.setPositionType(convertEnum(POSITION_TYPE_LUT, input, 1)),
  positionTop: (node, input) => node.setPosition(1, input ?? NaN),
  positionLeft: (node, input) => node.setPosition(0, input ?? NaN),
  positionRight: (node, input) => node.setPosition(2, input ?? NaN),
  positionBottom: (node, input) => node.setPosition(3, input ?? NaN),
  alignContent: (node, input) => node.setAlignContent(convertEnum(ALIGN_LUT, input, 4)),
  alignItems: (node, input) => node.setAlignItems(convertEnum(ALIGN_LUT, input, 4)),
  alignSelf: (node, input) => node.setAlignSelf(convertEnum(ALIGN_LUT, input, 0)),
  flexDirection: (node, input) => node.setFlexDirection(convertEnum(FLEX_DIRECTION_LUT, input, 2)),
  flexWrap: (node, input) => node.setFlexWrap(convertEnum(WRAP_LUT, input, 0)),
  justifyContent: (node, input) => node.setJustifyContent(convertEnum(JUSTIFY_LUT, input, 0)),
  marginTop: (node, input) => node.setMargin(1, input ?? NaN),
  marginLeft: (node, input) => node.setMargin(0, input ?? NaN),
  marginRight: (node, input) => node.setMargin(2, input ?? NaN),
  marginBottom: (node, input) => node.setMargin(3, input ?? NaN),
  flexBasis: (node, input) => node.setFlexBasis(input ?? NaN),
  flexGrow: (node, input) => node.setFlexGrow(input ?? 0),
  flexShrink: (node, input) => node.setFlexShrink(input ?? 1),
  width: (node, input) => node.setWidth(input ?? NaN),
  height: (node, input) => node.setHeight(input ?? NaN),
  minWidth: (node, input) => node.setMinWidth(input ?? NaN),
  minHeight: (node, input) => node.setMinHeight(input ?? NaN),
  maxWidth: (node, input) => node.setMaxWidth(input ?? NaN),
  maxHeight: (node, input) => node.setMaxHeight(input ?? NaN),
  aspectRatio: (node, input) => node.setAspectRatio(input ?? NaN),
  borderTopWidth: (node, input) => node.setBorder(1, input ?? NaN),
  borderLeftWidth: (node, input) => node.setBorder(0, input ?? NaN),
  borderRightWidth: (node, input) => node.setBorder(2, input ?? NaN),
  borderBottomWidth: (node, input) => node.setBorder(3, input ?? NaN),
  overflow: (node, input) => node.setOverflow(convertEnum(OVERFLOW_LUT, input, 0)),
  display: (node, input) => node.setDisplay(convertEnum(DISPLAY_LUT, input, 0)),
  paddingTop: (node, input) => node.setPadding(1, input ?? NaN),
  paddingLeft: (node, input) => node.setPadding(0, input ?? NaN),
  paddingRight: (node, input) => node.setPadding(2, input ?? NaN),
  paddingBottom: (node, input) => node.setPadding(3, input ?? NaN),
  gapRow: (node, input) => node.setGap(1, input ?? NaN),
  gapColumn: (node, input) => node.setGap(0, input ?? NaN)
};

// node_modules/@pmndrs/uikit/dist/flex/yoga.js
var PointScaleFactor = 100;
function createDefaultConfig(Config) {
  const config = Config.create();
  config.setUseWebDefaults(true);
  config.setPointScaleFactor(PointScaleFactor);
  config.setExperimentalFeatureEnabled(ExperimentalFeature.WebFlexBasis, true);
  return config;
}
var create2 = d(void 0);
loadYoga2().then(({ Node: Node2, Config }) => {
  const config = createDefaultConfig(Config);
  create2.value = () => Node2.create(config);
}).catch(console.error);
var createYogaNode = () => {
  var _a;
  return (_a = create2.value) == null ? void 0 : _a.call(create2);
};

// node_modules/@pmndrs/uikit/dist/flex/node.js
function hasImmediateProperty(key) {
  if (key === "measureFunc") {
    return true;
  }
  return key in setter;
}
function createFlexNodeState() {
  const scrollable = d([false, false]);
  return {
    size: d(void 0),
    relativeCenter: d(void 0),
    borderInset: d(void 0),
    overflow: d(Overflow.Visible),
    displayed: d(false),
    scrollable,
    paddingInset: d(void 0),
    maxScrollPosition: d([void 0, void 0])
  };
}
var FlexNode = class {
  constructor(state, propertiesSignal, requestCalculateLayout, object, objectVisibileDefault, subscriptions) {
    __publicField(this, "state");
    __publicField(this, "propertiesSignal");
    __publicField(this, "requestCalculateLayout");
    __publicField(this, "object");
    __publicField(this, "objectVisibileDefault");
    __publicField(this, "children", []);
    __publicField(this, "yogaNode");
    __publicField(this, "layoutChangeListeners", /* @__PURE__ */ new Set());
    __publicField(this, "customLayouting");
    __publicField(this, "active", d(false));
    __publicField(this, "objectVisible", false);
    this.state = state;
    this.propertiesSignal = propertiesSignal;
    this.requestCalculateLayout = requestCalculateLayout;
    this.object = object;
    this.objectVisibileDefault = objectVisibileDefault;
    subscriptions.push(E(() => {
      const yogaNode = createYogaNode();
      if (yogaNode == null) {
        return;
      }
      this.yogaNode = yogaNode;
      this.active.value = true;
      this.updateMeasureFunction();
      return () => {
        var _a, _b, _c;
        (_b = (_a = this.yogaNode) == null ? void 0 : _a.getParent()) == null ? void 0 : _b.removeChild(this.yogaNode);
        (_c = this.yogaNode) == null ? void 0 : _c.free();
      };
    }));
    setupImmediateProperties(propertiesSignal, this.active, hasImmediateProperty, (key, value) => {
      setter[key](this.yogaNode, value);
      this.requestCalculateLayout();
    }, subscriptions);
  }
  setCustomLayouting(layouting) {
    this.customLayouting = layouting;
    this.updateMeasureFunction();
  }
  updateMeasureFunction() {
    if (this.customLayouting == null || !this.active.value) {
      return;
    }
    setMeasureFunc(this.yogaNode, this.customLayouting.measure);
    this.requestCalculateLayout();
  }
  /**
   * use requestCalculateLayout instead
   */
  calculateLayout() {
    if (this.yogaNode == null) {
      return;
    }
    this.commit(this.yogaNode.getFlexDirection());
    this.yogaNode.calculateLayout(void 0, void 0);
    r(() => this.updateMeasurements(true, void 0, void 0));
  }
  addChild(node) {
    this.children.push(node);
    this.requestCalculateLayout();
  }
  removeChild(node) {
    const i2 = this.children.indexOf(node);
    if (i2 === -1) {
      return;
    }
    this.children.splice(i2, 1);
    this.requestCalculateLayout();
  }
  commit(parentDirection) {
    var _a;
    if (this.yogaNode == null) {
      throw new Error(`commit cannot be called without a yoga node`);
    }
    const parentDirectionVertical = parentDirection === FlexDirection.Column || parentDirection === FlexDirection.ColumnReverse;
    const properties = this.propertiesSignal.peek();
    if (this.customLayouting != null && n(() => properties.read(parentDirectionVertical ? "minHeight" : "minWidth", void 0)) === void 0) {
      this.yogaNode[parentDirectionVertical ? "setMinHeight" : "setMinWidth"](parentDirectionVertical ? this.customLayouting.minHeight : this.customLayouting.minWidth);
    }
    if (n(() => properties.read("flexShrink", void 0)) == null) {
      const hasHeight = n(() => properties.read("height", void 0)) != null;
      this.yogaNode.setFlexShrink(hasHeight && parentDirectionVertical ? 0 : void 0);
    }
    let groupChildren;
    this.children.sort((child1, child2) => {
      var _a2, _b;
      groupChildren ?? (groupChildren = (_b = (_a2 = child1.object.current) == null ? void 0 : _a2.parent) == null ? void 0 : _b.children);
      if (groupChildren == null) {
        return 0;
      }
      const group1 = child1.object.current;
      const group2 = child2.object.current;
      if (group1 == null || group2 == null) {
        return 0;
      }
      const i1 = groupChildren.indexOf(group1);
      if (i1 === -1) {
        throw new Error(`parent mismatch`);
      }
      const i22 = groupChildren.indexOf(group2);
      if (i22 === -1) {
        throw new Error(`parent mismatch`);
      }
      return i1 - i22;
    });
    let i2 = 0;
    let oldChildNode = this.yogaNode.getChild(i2);
    let correctChild = this.children[i2];
    while (correctChild != null || oldChildNode != null) {
      if (correctChild != null && oldChildNode != null && yogaNodeEqual(oldChildNode, assertNodeNotNull(correctChild.yogaNode))) {
        correctChild = this.children[++i2];
        oldChildNode = this.yogaNode.getChild(i2);
        continue;
      }
      if (oldChildNode != null) {
        this.yogaNode.removeChild(oldChildNode);
      }
      if (correctChild != null) {
        const node = assertNodeNotNull(correctChild.yogaNode);
        (_a = node.getParent()) == null ? void 0 : _a.removeChild(node);
        this.yogaNode.insertChild(node, i2);
        correctChild = this.children[++i2];
      }
      oldChildNode = this.yogaNode.getChild(i2);
    }
    const childrenLength = this.children.length;
    for (let i3 = 0; i3 < childrenLength; i3++) {
      this.children[i3].commit(this.yogaNode.getFlexDirection());
    }
    this.objectVisible = this.objectVisibileDefault || this.children.some((child) => child.objectVisible);
    if (this.object.current != null) {
      this.object.current.visible = this.objectVisible;
    }
  }
  updateMeasurements(displayed, parentWidth, parentHeight) {
    if (this.yogaNode == null) {
      throw new Error(`update measurements cannot be called without a yoga node`);
    }
    this.state.overflow.value = this.yogaNode.getOverflow();
    displayed && (displayed = this.yogaNode.getDisplay() === Display.Flex);
    this.state.displayed.value = displayed;
    const width = this.yogaNode.getComputedWidth();
    const height = this.yogaNode.getComputedHeight();
    updateVector2Signal(this.state.size, width, height);
    parentWidth ?? (parentWidth = width);
    parentHeight ?? (parentHeight = height);
    const x2 = this.yogaNode.getComputedLeft();
    const y3 = this.yogaNode.getComputedTop();
    const relativeCenterX = x2 + width * 0.5 - parentWidth * 0.5;
    const relativeCenterY = -(y3 + height * 0.5 - parentHeight * 0.5);
    updateVector2Signal(this.state.relativeCenter, relativeCenterX, relativeCenterY);
    const paddingTop = this.yogaNode.getComputedPadding(Edge.Top);
    const paddingLeft = this.yogaNode.getComputedPadding(Edge.Left);
    const paddingRight = this.yogaNode.getComputedPadding(Edge.Right);
    const paddingBottom = this.yogaNode.getComputedPadding(Edge.Bottom);
    updateInsetSignal(this.state.paddingInset, paddingTop, paddingRight, paddingBottom, paddingLeft);
    const borderTop = this.yogaNode.getComputedBorder(Edge.Top);
    const borderRight = this.yogaNode.getComputedBorder(Edge.Right);
    const borderBottom = this.yogaNode.getComputedBorder(Edge.Bottom);
    const borderLeft = this.yogaNode.getComputedBorder(Edge.Left);
    updateInsetSignal(this.state.borderInset, borderTop, borderRight, borderBottom, borderLeft);
    for (const layoutChangeListener of this.layoutChangeListeners) {
      layoutChangeListener();
    }
    const childrenLength = this.children.length;
    let maxContentWidth = 0;
    let maxContentHeight = 0;
    for (let i2 = 0; i2 < childrenLength; i2++) {
      const [contentWidth, contentHeight] = this.children[i2].updateMeasurements(displayed, width, height);
      maxContentWidth = Math.max(maxContentWidth, contentWidth);
      maxContentHeight = Math.max(maxContentHeight, contentHeight);
    }
    maxContentWidth -= borderLeft;
    maxContentHeight -= borderTop;
    if (this.state.overflow.value === Overflow.Scroll) {
      maxContentWidth += paddingRight;
      maxContentHeight += paddingLeft;
      const widthWithoutBorder = width - borderLeft - borderRight;
      const heightWithoutBorder = height - borderTop - borderBottom;
      const maxScrollX = maxContentWidth - widthWithoutBorder;
      const maxScrollY = maxContentHeight - heightWithoutBorder;
      const xScrollable = maxScrollX > 0.5;
      const yScrollable = maxScrollY > 0.5;
      updateVector2Signal(this.state.maxScrollPosition, xScrollable ? maxScrollX : void 0, yScrollable ? maxScrollY : void 0);
      updateVector2Signal(this.state.scrollable, xScrollable, yScrollable);
    } else {
      updateVector2Signal(this.state.maxScrollPosition, void 0, void 0);
      updateVector2Signal(this.state.scrollable, false, false);
    }
    const overflowVisible = this.state.overflow.value === Overflow.Visible;
    return [
      x2 + Math.max(width, overflowVisible ? maxContentWidth : 0),
      y3 + Math.max(height, overflowVisible ? maxContentHeight : 0)
    ];
  }
  addLayoutChangeListener(listener) {
    this.layoutChangeListeners.add(listener);
    return () => void this.layoutChangeListeners.delete(listener);
  }
};
function setMeasureFunc(node, func) {
  if (func == null) {
    node.setMeasureFunc(null);
    return;
  }
  node.setMeasureFunc((width, wMode, height, hMode) => {
    const result = func(width, wMode, height, hMode);
    return {
      width: Math.ceil(result.width * PointScaleFactor + 1) / PointScaleFactor,
      height: Math.ceil(result.height * PointScaleFactor + 1) / PointScaleFactor
    };
  });
  node.markDirty();
}
function updateVector2Signal(signal, x2, y3) {
  if (signal.value != null) {
    const [oldX, oldY] = signal.value;
    if (oldX === x2 && oldY === y3) {
      return;
    }
  }
  signal.value = [x2, y3];
}
function updateInsetSignal(signal, top, right, bottom, left) {
  if (signal.value != null) {
    const [oldTop, oldRight, oldBottom, oldLeft] = signal.value;
    if (oldTop == top && oldRight == right && oldBottom == bottom && oldLeft == left) {
      return;
    }
  }
  signal.value = [top, right, bottom, left];
}
function assertNodeNotNull(val) {
  if (val == null) {
    throw new Error(`commit cannot be called with a children that miss a yoga node`);
  }
  return val;
}
function yogaNodeEqual(n1, n2) {
  return n1["M"]["O"] === n2["M"]["O"];
}

// node_modules/@pmndrs/uikit/dist/active.js
function addActiveHandlers(target, style, properties, defaultProperties, activeSignal) {
  let activePropertiesExist = false;
  traverseProperties(style, defaultProperties, properties, (p2) => {
    if ("active" in p2) {
      activePropertiesExist = true;
    }
  });
  if (!activePropertiesExist && (style == null ? void 0 : style.onActiveChange) == null && (properties == null ? void 0 : properties.onActiveChange) == null) {
    activeSignal.value.length = 0;
    return;
  }
  const onLeave = ({ pointerId }) => {
    var _a, _b;
    activeSignal.value = activeSignal.value.filter((id) => id != pointerId);
    if (activeSignal.value.length > 0) {
      return;
    }
    (_a = properties == null ? void 0 : properties.onActiveChange) == null ? void 0 : _a.call(properties, false);
    (_b = style == null ? void 0 : style.onActiveChange) == null ? void 0 : _b.call(style, false);
  };
  addHandler("onPointerDown", target, ({ pointerId }) => {
    var _a, _b;
    activeSignal.value = [pointerId, ...activeSignal.value];
    if (activeSignal.value.length != 1) {
      return;
    }
    (_a = properties == null ? void 0 : properties.onActiveChange) == null ? void 0 : _a.call(properties, true);
    (_b = style == null ? void 0 : style.onActiveChange) == null ? void 0 : _b.call(style, true);
  });
  addHandler("onPointerUp", target, onLeave);
  addHandler("onPointerLeave", target, onLeave);
}
function createActivePropertyTransfomers(activeSignal) {
  return {
    active: createConditionalPropertyTranslator(() => activeSignal.value.length > 0)
  };
}

// node_modules/@pmndrs/uikit/dist/components/utils.js
function disposeGroup(object) {
  object == null ? void 0 : object.traverse((mesh) => {
    if (!(mesh instanceof Mesh)) {
      return;
    }
    if (mesh.material instanceof Material) {
      mesh.material.dispose();
    }
    if (mesh.geometry instanceof BufferGeometry) {
      mesh.geometry.dispose();
    }
  });
}
function computedGlobalMatrix(parentMatrix, localMatrix) {
  return w(() => {
    const local = localMatrix.value;
    const parent = parentMatrix.value;
    if (local == null || parent == null) {
      return void 0;
    }
    return parent.clone().multiply(local);
  });
}
function computedIsVisible(flexState, isClipped, mergedProperties) {
  return w(() => flexState.displayed.value && (isClipped == null || !(isClipped == null ? void 0 : isClipped.value)) && mergedProperties.value.read("visibility", "visible") === "visible");
}
function loadResourceWithParams(target, fn3, cleanup, initializers, param, ...additionals) {
  initializers.push((subscriptions) => {
    if (!(param instanceof u)) {
      let canceled = false;
      fn3(param, ...additionals).then((value) => canceled ? void 0 : target.value = value);
      subscriptions.push(() => canceled = true);
      return subscriptions;
    }
    subscriptions.push(E(() => {
      let canceled = false;
      fn3(param.value, ...additionals).then((value) => canceled ? void 0 : target.value = value).catch(console.error);
      return () => canceled = true;
    }));
    if (cleanup != null) {
      subscriptions.push(() => {
        const { value } = target;
        if (value == null) {
          return;
        }
        cleanup(value);
      });
    }
    return subscriptions;
  });
}
function createNode(target, state, parentContext, mergedProperties, object, objectVisibleDefault, initializers) {
  initializers.push((subscriptions) => {
    const node = new FlexNode(state, mergedProperties, parentContext.root.requestCalculateLayout, object, objectVisibleDefault, subscriptions);
    if (target != null) {
      target.value = node;
    }
    subscriptions.push(E(() => {
      const parentNode = parentContext.node.value;
      if (parentNode == null) {
        return;
      }
      parentNode.addChild(node);
      return () => parentNode.removeChild(node);
    }));
    return subscriptions;
  });
}
var signalMap = /* @__PURE__ */ new Map();
var keepAspectRatioPropertyTransformer = {
  keepAspectRatio: (value, target) => {
    let signal = signalMap.get(value);
    if (signal == null) {
      signalMap.set(value, signal = w(() => readReactive(value) === false ? null : void 0));
    }
    target.add("aspectRatio", signal);
  }
};
function computedHandlers(style, properties, defaultProperties, hoveredSignal, activeSignal, dynamicHandlers, defaultCursor) {
  return w(() => {
    const handlers = {};
    addHandlers(handlers, dynamicHandlers == null ? void 0 : dynamicHandlers.value);
    addHoverHandlers(handlers, style.value, properties.value, defaultProperties.value, hoveredSignal, defaultCursor);
    addActiveHandlers(handlers, style.value, properties.value, defaultProperties.value, activeSignal);
    return handlers;
  });
}
function addHandlers(target, handlers) {
  for (const key in handlers) {
    addHandler(key, target, handlers[key]);
  }
}
function addHandler(key, target, handler) {
  if (handler == null) {
    return;
  }
  const existingHandler = target[key];
  if (existingHandler == null) {
    target[key] = handler;
    return;
  }
  target[key] = (e2) => {
    existingHandler(e2);
    if ("stopped" in e2 && e2.stopped) {
      return;
    }
    handler(e2);
  };
}
function computedMergedProperties(style, properties, defaultProperties, postTransformers, preTransformers, onInit) {
  return w(() => {
    const merged = new MergedProperties(preTransformers);
    onInit == null ? void 0 : onInit(merged);
    merged.addAll(style.value, properties.value, defaultProperties.value, postTransformers);
    return merged;
  });
}
var colorHelper = new Color();
function applyAppearancePropertiesToGroup(propertiesSignal, group, initializers, root) {
  const color = computedInheritableProperty(propertiesSignal, "color", void 0);
  const opacity = computedInheritableProperty(propertiesSignal, "opacity", 1);
  initializers.push(() => E(() => {
    var _a;
    let c2;
    if (Array.isArray(color.value)) {
      c2 = colorHelper.setRGB(...color.value);
    } else if (color.value != null) {
      c2 = colorHelper.set(color.value);
    }
    (_a = readReactive(group)) == null ? void 0 : _a.traverse((mesh) => {
      if (!(mesh instanceof Mesh)) {
        return;
      }
      mesh.renderOrder = root.renderOrder.value;
      const material = mesh.material;
      material.color.copy(c2 ?? mesh.userData.color);
      material.opacity = opacity.value;
      material.depthTest = root.depthTest.value;
    });
  }));
}

// node_modules/@pmndrs/uikit/dist/panel/instanced-panel.js
function createInstancedPanel(propertiesSignal, orderInfo, panelGroupDependencies, panelGroupManager, matrix, size, offset, borderInset, clippingRect, isVisible, materialConfig, subscriptions) {
  subscriptions.push(E(() => {
    if (orderInfo.value == null) {
      return;
    }
    const innerSubscriptions = [];
    const group = panelGroupManager.getGroup(orderInfo.value.majorIndex, panelGroupDependencies == null ? void 0 : panelGroupDependencies.value);
    new InstancedPanel(propertiesSignal, group, orderInfo.value.minorIndex, matrix, size, offset, borderInset, clippingRect, isVisible, materialConfig, innerSubscriptions);
    return () => unsubscribeSubscriptions(innerSubscriptions);
  }));
  return subscriptions;
}
var matrixHelper1 = new Matrix4();
var matrixHelper2 = new Matrix4();
var InstancedPanel = class {
  constructor(propertiesSignal, group, minorIndex, matrix, size, offset, borderInset, clippingRect, isVisible, materialConfig, subscriptions) {
    __publicField(this, "group");
    __publicField(this, "minorIndex");
    __publicField(this, "matrix");
    __publicField(this, "size");
    __publicField(this, "offset");
    __publicField(this, "borderInset");
    __publicField(this, "clippingRect");
    __publicField(this, "materialConfig");
    __publicField(this, "indexInBucket");
    __publicField(this, "bucket");
    __publicField(this, "unsubscribeList", []);
    __publicField(this, "insertedIntoGroup", false);
    __publicField(this, "active", d(false));
    this.group = group;
    this.minorIndex = minorIndex;
    this.matrix = matrix;
    this.size = size;
    this.offset = offset;
    this.borderInset = borderInset;
    this.clippingRect = clippingRect;
    this.materialConfig = materialConfig;
    const setters = materialConfig.setters;
    setupImmediateProperties(propertiesSignal, this.active, materialConfig.hasProperty, (key, value) => {
      const index = this.getIndexInBuffer();
      if (index == null) {
        return;
      }
      const { instanceData, instanceDataOnUpdate: instanceDataAddUpdateRange, root } = this.group;
      setters[key](instanceData.array, instanceData.itemSize * index, value, size, instanceDataAddUpdateRange);
      root.requestRender();
    }, subscriptions);
    const isPanelVisible = materialConfig.computedIsVisibile(propertiesSignal, borderInset, size, isVisible);
    subscriptions.push(E(() => {
      if (isPanelVisible.value) {
        this.requestShow();
        return;
      }
      this.hide();
    }), () => this.hide());
  }
  setIndexInBucket(index) {
    this.indexInBucket = index;
  }
  getIndexInBuffer() {
    if (this.bucket == null || this.indexInBucket == null) {
      return void 0;
    }
    return this.bucket.offset + this.indexInBucket;
  }
  activate(bucket, index) {
    this.bucket = bucket;
    this.indexInBucket = index;
    this.active.value = true;
    this.unsubscribeList.push(E(() => {
      if (this.matrix.value == null || this.size.value == null) {
        return;
      }
      const index2 = this.getIndexInBuffer();
      if (index2 == null) {
        return;
      }
      const arrayIndex = index2 * 16;
      const [width, height] = this.size.value;
      const pixelSize = this.group.pixelSize.value;
      matrixHelper1.makeScale(width * pixelSize, height * pixelSize, 1);
      if (this.offset != null) {
        const [x2, y3] = this.offset.value;
        matrixHelper1.premultiply(matrixHelper2.makeTranslation(x2 * pixelSize, y3 * pixelSize, 0));
      }
      matrixHelper1.premultiply(this.matrix.value);
      const { instanceMatrix, root } = this.group;
      matrixHelper1.toArray(instanceMatrix.array, arrayIndex);
      instanceMatrix.addUpdateRange(arrayIndex, 16);
      instanceMatrix.needsUpdate = true;
      root.requestRender();
    }), E(() => {
      const index2 = this.getIndexInBuffer();
      if (index2 == null || this.size.value == null) {
        return;
      }
      const [width, height] = this.size.value;
      const { instanceData, root } = this.group;
      const { array } = instanceData;
      const bufferIndex = index2 * 16 + 13;
      array[bufferIndex] = width;
      array[bufferIndex + 1] = height;
      instanceData.addUpdateRange(bufferIndex, 2);
      instanceData.needsUpdate = true;
      root.requestRender();
    }), E(() => {
      const index2 = this.getIndexInBuffer();
      if (index2 == null || this.borderInset.value == null) {
        return;
      }
      const { instanceData, root } = this.group;
      const offset = index2 * 16 + 0;
      instanceData.array.set(this.borderInset.value, offset);
      instanceData.addUpdateRange(offset, 4);
      instanceData.needsUpdate = true;
      root.requestRender();
    }), E(() => {
      var _a;
      const index2 = this.getIndexInBuffer();
      if (index2 == null) {
        return;
      }
      const { instanceClipping, root } = this.group;
      const offset = index2 * 16;
      const clipping = (_a = this.clippingRect) == null ? void 0 : _a.value;
      if (clipping != null) {
        clipping.toArray(instanceClipping.array, offset);
      } else {
        instanceClipping.array.set(defaultClippingData, offset);
      }
      instanceClipping.addUpdateRange(offset, 16);
      instanceClipping.needsUpdate = true;
      root.requestRender();
    }));
  }
  requestShow() {
    if (this.insertedIntoGroup) {
      return;
    }
    this.insertedIntoGroup = true;
    this.group.insert(this.minorIndex, this);
  }
  hide() {
    if (!this.insertedIntoGroup) {
      return;
    }
    this.active.value = false;
    this.group.delete(this.minorIndex, this.indexInBucket, this);
    this.insertedIntoGroup = false;
    this.bucket = void 0;
    this.indexInBucket = void 0;
    const unsubscribeListLength = this.unsubscribeList.length;
    for (let i2 = 0; i2 < unsubscribeListLength; i2++) {
      this.unsubscribeList[i2]();
    }
    this.unsubscribeList.length = 0;
  }
};

// node_modules/@pmndrs/uikit/dist/panel/utils.js
function createPanelGeometry() {
  const geometry = new PlaneGeometry();
  const position = geometry.getAttribute("position");
  const array = new Float32Array(4 * position.count);
  const tangent = [1, 0, 0, 1];
  for (let i2 = 0; i2 < array.length; i2++) {
    array[i2] = tangent[i2 % 4];
  }
  geometry.setAttribute("tangent", new BufferAttribute(array, 4));
  return geometry;
}
function setComponentInFloat(from, index, value) {
  const x2 = Math.pow(50, index);
  const currentValue = Math.floor(from / x2) % 50;
  return from + (value - currentValue) * x2;
}
var panelGeometry = createPanelGeometry();
function setBorderRadius(data, indexInData, indexInFloat, value, height) {
  data[indexInData] = setComponentInFloat(data[indexInData], indexInFloat, clamp(Math.ceil((value ?? 0) / height * 100), 0, 49));
}

// node_modules/@pmndrs/uikit/dist/panel/panel-material.js
var noColor = new Color(-1, -1, -1);
var defaultDefaults = {
  backgroundColor: noColor,
  backgroundOpacity: -1,
  borderColor: 16777215,
  borderBottomLeftRadius: 0,
  borderTopLeftRadius: 0,
  borderBottomRightRadius: 0,
  borderTopRightRadius: 0,
  borderBend: 0,
  borderOpacity: 1
};
var defaultPanelMaterialConfig;
function getDefaultPanelMaterialConfig() {
  if (defaultPanelMaterialConfig == null) {
    const defaultPanelMaterialKeys = {};
    for (const key in defaultDefaults) {
      defaultPanelMaterialKeys[key] = key;
    }
    defaultPanelMaterialConfig = createPanelMaterialConfig(defaultPanelMaterialKeys);
  }
  return defaultPanelMaterialConfig;
}
function createPanelMaterialConfig(keys, overrideDefaults) {
  const defaults = { ...defaultDefaults, ...overrideDefaults };
  const setters = {};
  for (const key in keys) {
    const fn3 = materialSetters[key];
    const defaultValue = defaults[key];
    setters[keys[key]] = (data, offset, value, size, onUpdate) => fn3(data, offset, value ?? defaultValue, size, onUpdate);
  }
  const defaultData = new Float32Array(16);
  writeColor(defaultData, 4, defaults.backgroundColor, void 0);
  writeColor(defaultData, 8, defaults.borderColor, void 0);
  defaultData[11] = defaults.borderBend;
  defaultData[12] = defaults.borderOpacity;
  defaultData[15] = defaults.backgroundOpacity;
  return {
    hasProperty: (key) => key in setters,
    defaultData,
    setters,
    computedIsVisibile: (propertiesSignal, borderInset, size, isVisible) => {
      return w(() => {
        if (borderInset.value == null || size.value == null) {
          return true;
        }
        const borderOpacity = keys.borderOpacity == null ? defaults.borderOpacity : propertiesSignal.value.read(keys.borderOpacity, defaults.borderOpacity);
        const backgroundOpacity = keys.backgroundOpacity == null ? defaults.backgroundOpacity : propertiesSignal.value.read(keys.backgroundOpacity, defaults.backgroundOpacity);
        const backgroundColor = keys.backgroundColor == null ? defaults.backgroundColor : propertiesSignal.value.read(keys.backgroundColor, defaults.backgroundColor);
        const borderVisible = borderInset.value.some((s2) => s2 > 0) && borderOpacity > 0;
        const [width, height] = size.value;
        const backgroundVisible = width > 0 && height > 0 && (backgroundOpacity === -1 || backgroundOpacity > 0) && backgroundColor != noColor;
        if (!backgroundVisible && !borderVisible) {
          return false;
        }
        return isVisible.value;
      });
    }
  };
}
var materialSetters = {
  //0-3 = borderSizes
  //4-6 = background color
  backgroundColor: (d2, o2, p2, _3, u2) => writeColor(d2, o2 + 4, p2, u2),
  //7 = border radiuses
  borderBottomLeftRadius: (d2, o2, p2, { value: s2 }, u2) => s2 != null && writeBorderRadius(d2, o2 + 7, 0, p2, s2[1], u2),
  borderBottomRightRadius: (d2, o2, p2, { value: s2 }, u2) => s2 != null && writeBorderRadius(d2, o2 + 7, 1, p2, s2[1], u2),
  borderTopRightRadius: (d2, o2, p2, { value: s2 }, u2) => s2 != null && writeBorderRadius(d2, o2 + 7, 2, p2, s2[1], u2),
  borderTopLeftRadius: (d2, o2, p2, { value: s2 }, u2) => s2 != null && writeBorderRadius(d2, o2 + 7, 3, p2, s2[1], u2),
  //8 - 10 = border color
  borderColor: (d2, o2, p2, _3, u2) => writeColor(d2, o2 + 8, p2, u2),
  //11
  borderBend: (d2, o2, p2, _3, u2) => writeComponent(d2, o2 + 11, p2, u2),
  //12
  borderOpacity: (d2, o2, p2, _3, u2) => writeComponent(d2, o2 + 12, p2, u2),
  //13 = width
  //14 = height
  //15
  backgroundOpacity: (d2, o2, p2, _3, u2) => writeComponent(d2, o2 + 15, p2, u2)
};
function writeBorderRadius(data, offset, indexInFloat, value, height, onUpdate) {
  setBorderRadius(data, offset, indexInFloat, value, height);
  onUpdate == null ? void 0 : onUpdate(offset, 1);
}
function writeComponent(data, offset, value, onUpdate) {
  data[offset] = value;
  onUpdate == null ? void 0 : onUpdate(offset, 1);
}
var colorHelper2 = new Color();
function writeColor(target, offset, color, onUpdate) {
  if (Array.isArray(color)) {
    target.set(color, offset);
  } else {
    colorHelper2.set(color).toArray(target, offset);
  }
  onUpdate == null ? void 0 : onUpdate(offset, 3);
}
function createPanelMaterial(MaterialClass, info) {
  const material = new MaterialClass();
  if (material.defines == null) {
    material.defines = {};
  }
  material.side = FrontSide;
  material.clipShadows = true;
  material.transparent = true;
  material.toneMapped = false;
  material.depthWrite = false;
  material.shadowSide = FrontSide;
  material.defines.USE_UV = "";
  material.defines.USE_TANGENT = "";
  const superOnBeforeCompile = material.onBeforeCompile;
  material.onBeforeCompile = (parameters, renderer) => {
    superOnBeforeCompile.call(material, parameters, renderer);
    if (info.type === "normal") {
      parameters.uniforms.data = { value: info.data };
    }
    compilePanelMaterial(parameters, info.type === "instanced");
  };
  return material;
}
var PanelDistanceMaterial = class extends MeshDistanceMaterial {
  constructor(info) {
    super();
    __publicField(this, "info");
    this.info = info;
    if (this.defines == null) {
      this.defines = {};
    }
    this.defines.USE_UV = "";
    this.clipShadows = true;
  }
  onBeforeCompile(parameters, renderer) {
    super.onBeforeCompile(parameters, renderer);
    if (this.info.type === "normal") {
      parameters.uniforms.data = { value: this.info.data };
    }
    compilePanelDepthMaterial(parameters, this.info.type === "instanced");
  }
};
var PanelDepthMaterial = class extends MeshDepthMaterial {
  constructor(info) {
    super({ depthPacking: RGBADepthPacking });
    __publicField(this, "info");
    this.info = info;
    if (this.defines == null) {
      this.defines = {};
    }
    this.defines.USE_UV = "";
    this.clipShadows = true;
  }
  onBeforeCompile(parameters, renderer) {
    super.onBeforeCompile(parameters, renderer);
    if (this.info.type === "normal") {
      parameters.uniforms.data = { value: this.info.data };
    }
    compilePanelDepthMaterial(parameters, this.info.type === "instanced");
  }
};
var instancedPanelDepthMaterial = new PanelDepthMaterial({ type: "instanced" });
var instancedPanelDistanceMaterial = new PanelDistanceMaterial({ type: "instanced" });
function compilePanelDepthMaterial(parameters, instanced) {
  compilePanelClippingMaterial(parameters, instanced);
  parameters.fragmentShader = parameters.fragmentShader.replace("#include <clipping_planes_fragment>", `#include <clipping_planes_fragment>
    ${getFargmentOpacityCode(instanced, void 0)}
    `);
}
function compilePanelClippingMaterial(parameters, instanced) {
  parameters.vertexShader = parameters.vertexShader.replace("#include <common>", ` #include <common>
      out vec4 borderRadius;
      ${instanced ? "" : "uniform highp mat4 data;"}`);
  parameters.vertexShader = parameters.vertexShader.replace("#include <uv_vertex>", ` #include <uv_vertex>
      highp int packedBorderRadius = int(data[1].w);
      borderRadius = vec4(
        packedBorderRadius / 125000 % 50,
        packedBorderRadius / 2500 % 50,
        packedBorderRadius / 50 % 50,
        packedBorderRadius % 50
      ) * vec4(0.5 / 50.0);`);
  if (instanced) {
    parameters.vertexShader = parameters.vertexShader.replace("#include <common>", ` #include <common>
        attribute highp mat4 aData;
        attribute mat4 aClipping;
        out mat4 data;
        out mat4 clipping;
        out vec3 localPosition;`);
    parameters.vertexShader = parameters.vertexShader.replace("#include <uv_vertex>", ` #include <uv_vertex>
        data = aData;
        clipping = aClipping;
        localPosition = (instanceMatrix * vec4(position, 1.0)).xyz;`);
  }
  parameters.fragmentShader = `${instanced ? "in" : "uniform"} highp mat4 data;
    in vec4 borderRadius;
    ${instanced ? `
    in vec3 localPosition;
    in mat4 clipping;
    ` : ""}

    float min4 (vec4 v) {
        return min(min(min(v.x,v.y),v.z),v.w);
    }
    float max4 (vec4 v) {
        return max(max(max(v.x,v.y),v.z),v.w);
    }
    vec2 radiusDistance(float radius, vec2 outside, vec2 border, vec2 borderSize) {
        vec2 outerRadiusXX = vec2(radius, radius);
        vec2 innerRadiusXX = outerRadiusXX - borderSize;
        vec2 radiusWeightUnnormalized = abs(innerRadiusXX - border);
        vec2 radiusWeight = radiusWeightUnnormalized / vec2(radiusWeightUnnormalized.x + radiusWeightUnnormalized.y);
        return vec2(
            radius - distance(outside, outerRadiusXX),
            dot(radiusWeight, innerRadiusXX) - distance(border, innerRadiusXX)
        );
    }
    ` + parameters.fragmentShader;
  parameters.fragmentShader = parameters.fragmentShader.replace("#include <clipping_planes_fragment>", ` ${instanced ? `
        vec4 plane;
        float distanceToPlane, distanceGradient;
        float clipOpacity = 1.0;

        for(int i = 0; i < 4; i++) {
          plane = clipping[ i ];
          distanceToPlane = - dot( -localPosition, plane.xyz ) + plane.w;
          distanceGradient = fwidth( distanceToPlane ) / 2.0;
          clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
    
          if ( clipOpacity < 0.01 ) discard;
        }
        ` : ""}
        vec4 absoluteBorderSize = data[0];
        vec3 backgroundColor = data[1].xyz;
        vec3 borderColor = data[2].xyz;
        float borderBend = data[2].w;
        float borderOpacity = data[3].x;
        float width = data[3].y;
        float height = data[3].z;
        float backgroundOpacity = data[3].w;
        float ratio = width / height;
        vec4 relative = vec4(height, height, height, height);
        vec4 borderSize = absoluteBorderSize / relative;
        vec4 v_outsideDistance = vec4(1.0 - vUv.y, (1.0 - vUv.x) * ratio, vUv.y, vUv.x * ratio);
        vec4 v_borderDistance = v_outsideDistance - borderSize;
  
        vec2 distance = vec2(min4(v_outsideDistance), min4(v_borderDistance));
        vec4 negateBorderDistance = vec4(1.0) - v_borderDistance;
        float maxWeight = max4(negateBorderDistance);
        vec4 borderWeight = step(maxWeight, negateBorderDistance);
  
        vec4 insideBorder;
  
        if(all(lessThan(v_outsideDistance.xw, borderRadius.xx))) {
            distance = radiusDistance(borderRadius.x, v_outsideDistance.xw, v_borderDistance.xw, borderSize.xw);
            
            float tmp = borderRadius.x - borderSize.w;
            vec2 xIntersection = vec2(tmp, tmp / ratio);
            tmp = borderRadius.x - borderSize.x;
            vec2 yIntersection = vec2(tmp * ratio, tmp);
            vec2 lineIntersection = min(xIntersection, yIntersection);
  
            insideBorder.yz = vec2(0.0);
            insideBorder.xw = max(vec2(0.0), lineIntersection - v_borderDistance.xw);
  
        } else if(all(lessThan(v_outsideDistance.xy, borderRadius.yy))) {
            distance = radiusDistance(borderRadius.y, v_outsideDistance.xy, v_borderDistance.xy, borderSize.xy);
  
            float tmp = borderRadius.y - borderSize.y;
            vec2 xIntersection = vec2(tmp, tmp / ratio);
            tmp = borderRadius.y - borderSize.x;
            vec2 yIntersection = vec2(tmp * ratio, tmp);
            vec2 lineIntersection = min(xIntersection, yIntersection);
  
            insideBorder.zw = vec2(0.0);
            insideBorder.xy = max(vec2(0.0), lineIntersection - v_borderDistance.xy);
  
        } else if(all(lessThan(v_outsideDistance.zy, borderRadius.zz))) {
            distance = radiusDistance(borderRadius.z, v_outsideDistance.zy, v_borderDistance.zy, borderSize.zy);
  
            float tmp = borderRadius.z - borderSize.y;
            vec2 xIntersection = vec2(tmp, tmp / ratio);
            tmp = borderRadius.z - borderSize.z;
            vec2 yIntersection = vec2(tmp * ratio, tmp);
            vec2 lineIntersection = min(xIntersection, yIntersection);
  
            insideBorder.xw = vec2(0.0);
            insideBorder.zy =max(vec2(0.0), lineIntersection - v_borderDistance.zy);
  
        } else if(all(lessThan(v_outsideDistance.zw, borderRadius.ww))) {
            distance = radiusDistance(borderRadius.w, v_outsideDistance.zw, v_borderDistance.zw, borderSize.zw);
  
            float tmp = borderRadius.w - borderSize.w;
            vec2 xIntersection = vec2(tmp, tmp / ratio);
            tmp = borderRadius.w - borderSize.z;
            vec2 yIntersection = vec2(tmp * ratio, tmp);
            vec2 lineIntersection = min(xIntersection, yIntersection);
  
            insideBorder.xy = vec2(0.0);
            insideBorder.zw = max(vec2(0.0), lineIntersection - v_borderDistance.zw);
  
        }
  
        if(insideBorder.x + insideBorder.y + insideBorder.z + insideBorder.w > 0.0) {
          borderWeight = normalize(insideBorder);
        }
  
        #include <clipping_planes_fragment>`);
}
function getFargmentOpacityCode(instanced, existingOpacity) {
  return `float ddx = fwidth(distance.x);
  float outer = smoothstep(-ddx, ddx, distance.x);

  float ddy = fwidth(distance.y);
  float inner = smoothstep(-ddy, ddy, distance.y);

  float transition = 1.0 - step(0.1, outer - inner) * (1.0 - inner);

  if(backgroundColor.r < 0.0 && backgroundOpacity >= 0.0) {
    backgroundColor = vec3(1.0);
  }
  if(backgroundOpacity < 0.0) {
    backgroundOpacity = backgroundColor.r >= 0.0 ? 1.0 : 0.0;
  }

  if(backgroundOpacity < 0.0) {
    backgroundOpacity = 0.0;
  }

  borderOpacity = min(backgroundOpacity + data[3].x, 1.0);
  borderColor = mix(backgroundColor, data[2].xyz, data[3].x / borderOpacity);
        

  float outOpacity = ${instanced ? "clipOpacity * " : ""} outer * mix(borderOpacity, ${existingOpacity == null ? "" : `${existingOpacity} *`} backgroundOpacity, transition);

  if(outOpacity < 0.01) {
    discard;
  }`;
}
function compilePanelMaterial(parameters, instanced) {
  compilePanelClippingMaterial(parameters, instanced);
  parameters.fragmentShader = parameters.fragmentShader.replace("#include <color_fragment>", ` #include <color_fragment>
      ${getFargmentOpacityCode(instanced, "diffuseColor.a")}
      diffuseColor.rgb = mix(borderColor, diffuseColor.rgb * backgroundColor, transition);
      diffuseColor.a = outOpacity;
      `);
  parameters.fragmentShader = parameters.fragmentShader.replace("#include <normal_fragment_maps>", ` #include <normal_fragment_maps>
      vec3 b = normalize(vBitangent);
      vec3 t = normalize(vTangent);
      mat4 directions = mat4(vec4(b, 1.0), vec4(t, 1.0), vec4(-b, 1.0), vec4(-t, 1.0));
      float currentBorderSize = distance.x - distance.y;
      float outsideNormalWeight = currentBorderSize < 0.00001 ? 0.0 : max(0.0, -distance.y / currentBorderSize) * borderBend;
      vec3 outsideNormal = (borderWeight * transpose(directions)).xyz;
      normal = normalize(outsideNormalWeight * outsideNormal + (1.0 - outsideNormalWeight) * normal);
    `);
}

// node_modules/@pmndrs/uikit/dist/panel/interaction-panel-mesh.js
var planeHelper = new Plane();
var vectorHelper = new Vector3();
var sides = [
  //left
  new Plane().setFromNormalAndCoplanarPoint(new Vector3(1, 0, 0), new Vector3(-0.5, 0, 0)),
  //right
  new Plane().setFromNormalAndCoplanarPoint(new Vector3(-1, 0, 0), new Vector3(0.5, 0, 0)),
  //bottom
  new Plane().setFromNormalAndCoplanarPoint(new Vector3(0, 1, 0), new Vector3(0, -0.5, 0)),
  //top
  new Plane().setFromNormalAndCoplanarPoint(new Vector3(0, -1, 0), new Vector3(0, 0.5, 0))
];
var distancesHelper = [0, 0, 0, 0];
var scaleHelper = new Vector3();
function isSingularMatrix(matrix) {
  scaleHelper.setFromMatrixScale(matrix);
  return scaleHelper.x === 0 || scaleHelper.y === 0 || scaleHelper.z === 0;
}
function makePanelSpherecast(mesh) {
  return (sphere, intersects) => {
    const matrixWorld = mesh.matrixWorld;
    if (isSingularMatrix(matrixWorld)) {
      return;
    }
    planeHelper.constant = 0;
    planeHelper.normal.set(0, 0, 1);
    planeHelper.applyMatrix4(matrixWorld);
    planeHelper.projectPoint(sphere.center, vectorHelper);
    if (vectorHelper.distanceToSquared(sphere.center) > sphere.radius * sphere.radius) {
      return;
    }
    for (let i2 = 0; i2 < 4; i2++) {
      const side = sides[i2];
      planeHelper.copy(side).applyMatrix4(matrixWorld);
      let distance2 = planeHelper.distanceToPoint(vectorHelper);
      if (distance2 < 0) {
        if (Math.abs(distance2) > sphere.radius) {
          return;
        }
        planeHelper.projectPoint(vectorHelper, vectorHelper);
        distance2 = 0;
      }
      distancesHelper[i2] = distance2;
    }
    const distance = sphere.center.distanceTo(vectorHelper);
    if (distance > sphere.radius) {
      return;
    }
    intersects.push({
      distance,
      object: mesh,
      point: vectorHelper.clone(),
      uv: new Vector2(distancesHelper[0] / (distancesHelper[0] + distancesHelper[1]), distancesHelper[3] / (distancesHelper[2] + distancesHelper[3])),
      normal: new Vector3(0, 0, 1)
    });
  };
}
function makePanelRaycast(mesh) {
  return (raycaster, intersects) => {
    const matrixWorld = mesh.matrixWorld;
    if (isSingularMatrix(matrixWorld)) {
      return;
    }
    planeHelper.constant = 0;
    planeHelper.normal.set(0, 0, 1);
    planeHelper.applyMatrix4(matrixWorld);
    if (planeHelper.distanceToPoint(raycaster.ray.origin) <= 0 || raycaster.ray.intersectPlane(planeHelper, vectorHelper) == null) {
      return;
    }
    for (let i2 = 0; i2 < 4; i2++) {
      const side = sides[i2];
      planeHelper.copy(side).applyMatrix4(matrixWorld);
      if ((distancesHelper[i2] = planeHelper.distanceToPoint(vectorHelper)) < 0) {
        return;
      }
    }
    intersects.push({
      distance: vectorHelper.distanceTo(raycaster.ray.origin),
      object: mesh,
      point: vectorHelper.clone(),
      uv: new Vector2(distancesHelper[0] / (distancesHelper[0] + distancesHelper[1]), distancesHelper[3] / (distancesHelper[2] + distancesHelper[3])),
      normal: new Vector3(0, 0, 1)
    });
  };
}
function makeClippedCast(mesh, fn3, rootObject, clippingRect, orderInfo) {
  return (raycaster, intersects) => {
    var _a;
    const obj = rootObject instanceof Object3D ? rootObject : rootObject.current;
    if (obj == null || orderInfo.value == null) {
      return;
    }
    const { majorIndex, minorIndex, elementType } = orderInfo.value;
    const oldLength = intersects.length;
    fn3.call(mesh, raycaster, intersects);
    const clippingPlanes = (_a = clippingRect == null ? void 0 : clippingRect.value) == null ? void 0 : _a.planes;
    const outerMatrixWorld = obj.matrixWorld;
    outer:
      for (let i2 = intersects.length - 1; i2 >= oldLength; i2--) {
        const intersection = intersects[i2];
        intersection.distance -= majorIndex * 0.01 + elementType * 1e-3 + //1-10
        minorIndex * 1e-5;
        if (clippingPlanes == null) {
          continue;
        }
        for (let ii2 = 0; ii2 < 4; ii2++) {
          planeHelper.copy(clippingPlanes[ii2]).applyMatrix4(outerMatrixWorld);
          if (planeHelper.distanceToPoint(intersection.point) < 0) {
            intersects.splice(i2, 1);
            continue outer;
          }
        }
      }
  };
}

// node_modules/@pmndrs/uikit/dist/panel/instanced-panel-mesh.js
function createInteractionPanel(orderInfo, rootContext, parentClippingRect, size, initializers) {
  const panel = new Mesh(panelGeometry);
  panel.matrixAutoUpdate = false;
  panel.raycast = makeClippedCast(panel, makePanelRaycast(panel), rootContext.object, parentClippingRect, orderInfo);
  panel.spherecast = makeClippedCast(panel, makePanelSpherecast(panel), rootContext.object, parentClippingRect, orderInfo);
  panel.visible = false;
  initializers.push(() => E(() => {
    if (size.value == null) {
      return;
    }
    const [width, height] = size.value;
    const pixelSize = rootContext.pixelSize.value;
    panel.scale.set(width * pixelSize, height * pixelSize, 1);
    panel.updateMatrix();
  }));
  return panel;
}
var InstancedPanelMesh = class extends Mesh {
  constructor(instanceMatrix, instanceData, instanceClipping) {
    const panelGeometry2 = createPanelGeometry();
    super(panelGeometry2);
    __publicField(this, "instanceMatrix");
    __publicField(this, "count", 0);
    __publicField(this, "isInstancedMesh", true);
    __publicField(this, "instanceColor", null);
    __publicField(this, "morphTexture", null);
    __publicField(this, "boundingBox", new Box3());
    __publicField(this, "boundingSphere", new Sphere());
    this.instanceMatrix = instanceMatrix;
    this.frustumCulled = false;
    panelGeometry2.attributes.aData = instanceData;
    panelGeometry2.attributes.aClipping = instanceClipping;
    this.customDepthMaterial = instancedPanelDepthMaterial;
    this.customDistanceMaterial = instancedPanelDistanceMaterial;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  copy() {
    throw new Error("copy not implemented");
  }
  //functions not needed because intersection (and morphing) is intenionally disabled
  computeBoundingBox() {
  }
  computeBoundingSphere() {
  }
  updateMorphTargets() {
  }
  raycast() {
  }
  spherecast() {
  }
};

// node_modules/@pmndrs/uikit/dist/panel/instanced-panel-group.js
function computedPanelGroupDependencies(propertiesSignal) {
  const panelMaterialClass = computedInheritableProperty(propertiesSignal, "panelMaterialClass", MeshBasicMaterial);
  const castShadow = computedInheritableProperty(propertiesSignal, "castShadow", false);
  const receiveShadow = computedInheritableProperty(propertiesSignal, "receiveShadow", false);
  return w(() => ({
    panelMaterialClass: panelMaterialClass.value,
    castShadow: castShadow.value,
    receiveShadow: receiveShadow.value
  }));
}
var defaultPanelDependencies = {
  panelMaterialClass: MeshBasicMaterial,
  castShadow: false,
  receiveShadow: false
};
var PanelGroupManager = class {
  constructor(renderOrder, depthTest, pixelSize, root, object, initializers) {
    __publicField(this, "renderOrder");
    __publicField(this, "depthTest");
    __publicField(this, "pixelSize");
    __publicField(this, "root");
    __publicField(this, "object");
    __publicField(this, "map", /* @__PURE__ */ new Map());
    this.renderOrder = renderOrder;
    this.depthTest = depthTest;
    this.pixelSize = pixelSize;
    this.root = root;
    this.object = object;
    initializers.push(() => {
      const onFrame = () => this.traverse((group) => group.onFrame());
      root.onFrameSet.add(onFrame);
      return () => root.onFrameSet.delete(onFrame);
    }, () => () => this.traverse((group) => group.destroy()), () => E(() => {
      const ro2 = renderOrder.value;
      this.traverse((group) => group.setRenderOrder(ro2));
      this.root.requestRender();
    }), () => E(() => {
      const dt3 = depthTest.value;
      this.traverse((group) => group.setDepthTest(dt3));
      this.root.requestRender();
    }));
  }
  traverse(fn3) {
    for (const groups of this.map.values()) {
      for (const group of groups.values()) {
        fn3(group);
      }
    }
  }
  getGroup(majorIndex, { panelMaterialClass, receiveShadow, castShadow } = defaultPanelDependencies) {
    let groups = this.map.get(panelMaterialClass);
    if (groups == null) {
      this.map.set(panelMaterialClass, groups = /* @__PURE__ */ new Map());
    }
    const key = (majorIndex << 2) + ((receiveShadow ? 1 : 0) << 1) + (castShadow ? 1 : 0);
    let panelGroup = groups.get(key);
    if (panelGroup == null) {
      groups.set(key, panelGroup = new InstancedPanelGroup(this.renderOrder.peek(), this.depthTest.peek(), this.object, panelMaterialClass, this.pixelSize, this.root, {
        elementType: ElementType.Panel,
        majorIndex,
        minorIndex: 0
      }, receiveShadow, castShadow));
    }
    return panelGroup;
  }
};
var nextFrame = Symbol("nextFrame");
var InstancedPanelGroup = class {
  constructor(renderOrder, depthTest, object, materialClass, pixelSize, root, orderInfo, meshReceiveShadow, meshCastShadow) {
    __publicField(this, "renderOrder");
    __publicField(this, "object");
    __publicField(this, "pixelSize");
    __publicField(this, "root");
    __publicField(this, "orderInfo");
    __publicField(this, "meshReceiveShadow");
    __publicField(this, "meshCastShadow");
    __publicField(this, "mesh");
    __publicField(this, "instanceMatrix");
    __publicField(this, "instanceData");
    __publicField(this, "instanceClipping");
    __publicField(this, "instanceMaterial");
    __publicField(this, "buckets", []);
    __publicField(this, "elementCount", 0);
    __publicField(this, "bufferElementSize", 0);
    __publicField(this, "instanceDataOnUpdate");
    __publicField(this, "nextUpdateTime");
    __publicField(this, "nextUpdateTimeoutRef");
    __publicField(this, "activateElement", (element, bucket, indexInBucket) => {
      const index = bucket.offset + indexInBucket;
      this.instanceData.set(element.materialConfig.defaultData, 16 * index);
      this.instanceData.addUpdateRange(16 * index, 16);
      this.instanceData.needsUpdate = true;
      element.activate(bucket, indexInBucket);
    });
    __publicField(this, "setElementIndex", (element, index) => {
      element.setIndexInBucket(index);
    });
    __publicField(this, "bufferCopyWithin", (targetIndex, startIndex, endIndex) => {
      copyWithinAttribute(this.instanceMatrix, targetIndex, startIndex, endIndex);
      copyWithinAttribute(this.instanceData, targetIndex, startIndex, endIndex);
      copyWithinAttribute(this.instanceClipping, targetIndex, startIndex, endIndex);
    });
    __publicField(this, "clearBufferAt", (index) => {
      const bufferOffset = index * 16;
      this.instanceMatrix.array.fill(0, bufferOffset, bufferOffset + 16);
      this.instanceMatrix.addUpdateRange(bufferOffset, 16);
      this.instanceMatrix.needsUpdate = true;
    });
    this.renderOrder = renderOrder;
    this.object = object;
    this.pixelSize = pixelSize;
    this.root = root;
    this.orderInfo = orderInfo;
    this.meshReceiveShadow = meshReceiveShadow;
    this.meshCastShadow = meshCastShadow;
    this.instanceMaterial = createPanelMaterial(materialClass, { type: "instanced" });
    this.instanceMaterial.depthTest = depthTest;
  }
  updateCount() {
    const lastBucket = this.buckets[this.buckets.length - 1];
    const count = lastBucket.offset + lastBucket.elements.length;
    if (this.mesh == null) {
      return;
    }
    this.mesh.count = count;
    this.mesh.visible = count > 0;
    this.root.requestRender();
  }
  requestUpdate(time) {
    if (this.nextUpdateTime == nextFrame) {
      return;
    }
    const forTime = performance.now() + time;
    if (this.nextUpdateTime != null && this.nextUpdateTime < forTime) {
      return;
    }
    this.nextUpdateTime = forTime;
    clearTimeout(this.nextUpdateTimeoutRef);
    this.nextUpdateTimeoutRef = setTimeout(this.requestUpdateNextFrame.bind(this), time);
  }
  requestUpdateNextFrame() {
    this.nextUpdateTime = nextFrame;
    clearTimeout(this.nextUpdateTimeoutRef);
    this.nextUpdateTimeoutRef = void 0;
    this.root.requestRender();
  }
  setDepthTest(depthTest) {
    this.instanceMaterial.depthTest = depthTest;
  }
  setRenderOrder(renderOrder) {
    this.renderOrder = renderOrder;
    if (this.mesh == null) {
      return;
    }
    this.mesh.renderOrder = renderOrder;
  }
  insert(bucketIndex, panel) {
    this.elementCount += 1;
    if (!addToSortedBuckets(this.buckets, bucketIndex, panel, this.activateElement)) {
      this.updateCount();
      return;
    }
    this.requestUpdateNextFrame();
  }
  delete(bucketIndex, elementIndex, panel) {
    this.elementCount -= 1;
    if (!removeFromSortedBuckets(this.buckets, bucketIndex, panel, elementIndex, this.activateElement, this.clearBufferAt, this.setElementIndex, this.bufferCopyWithin)) {
      this.updateCount();
      return;
    }
    this.requestUpdate(1e3);
  }
  onFrame() {
    if (this.nextUpdateTime != nextFrame) {
      return;
    }
    this.nextUpdateTime = void 0;
    this.update();
  }
  update() {
    if (this.elementCount === 0) {
      if (this.mesh != null) {
        this.mesh.visible = false;
      }
      return;
    }
    if (this.elementCount > this.bufferElementSize) {
      this.resize();
    } else if (this.elementCount <= this.bufferElementSize / 3) {
      this.resize();
    }
    updateSortedBucketsAllocation(this.buckets, this.activateElement, this.bufferCopyWithin);
    this.mesh.count = this.elementCount;
    this.mesh.visible = true;
  }
  resize() {
    var _a, _b;
    const oldBufferSize = this.bufferElementSize;
    this.bufferElementSize = Math.ceil(this.elementCount * 1.5);
    if (this.mesh != null) {
      this.mesh.dispose();
      (_a = this.object.current) == null ? void 0 : _a.remove(this.mesh);
    }
    resizeSortedBucketsSpace(this.buckets, oldBufferSize, this.bufferElementSize);
    const matrixArray = new Float32Array(this.bufferElementSize * 16);
    if (this.instanceMatrix != null) {
      matrixArray.set(this.instanceMatrix.array.subarray(0, matrixArray.length));
    }
    this.instanceMatrix = new InstancedBufferAttribute(matrixArray, 16, false);
    this.instanceMatrix.setUsage(DynamicDrawUsage);
    const dataArray = new Float32Array(this.bufferElementSize * 16);
    if (this.instanceData != null) {
      dataArray.set(this.instanceData.array.subarray(0, dataArray.length));
    }
    this.instanceData = new InstancedBufferAttribute(dataArray, 16, false);
    this.instanceDataOnUpdate = (start, count) => {
      this.instanceData.addUpdateRange(start, count);
      this.instanceData.needsUpdate = true;
    };
    this.instanceData.setUsage(DynamicDrawUsage);
    const clippingArray = new Float32Array(this.bufferElementSize * 16);
    if (this.instanceClipping != null) {
      clippingArray.set(this.instanceClipping.array.subarray(0, clippingArray.length));
    }
    this.instanceClipping = new InstancedBufferAttribute(clippingArray, 16, false);
    this.instanceClipping.setUsage(DynamicDrawUsage);
    this.mesh = new InstancedPanelMesh(this.instanceMatrix, this.instanceData, this.instanceClipping);
    this.mesh.renderOrder = this.renderOrder;
    setupRenderOrder(this.mesh, this.root, { value: this.orderInfo });
    this.mesh.material = this.instanceMaterial;
    this.mesh.receiveShadow = this.meshReceiveShadow;
    this.mesh.castShadow = this.meshCastShadow;
    (_b = this.object.current) == null ? void 0 : _b.add(this.mesh);
  }
  destroy() {
    clearTimeout(this.nextUpdateTimeoutRef);
  }
};
function copyWithinAttribute(attribute, targetIndex, startIndex, endIndex) {
  const itemSize = attribute.itemSize;
  const start = startIndex * itemSize;
  const end = endIndex * itemSize;
  const target = targetIndex * itemSize;
  attribute.array.copyWithin(target, start, end);
  const count = end - start;
  attribute.addUpdateRange(start, count);
  attribute.addUpdateRange(target, count);
  attribute.needsUpdate = true;
}

// node_modules/@pmndrs/uikit/dist/scroll.js
var distanceHelper = new Vector3();
var localPointHelper = new Vector3();
function createScrollPosition() {
  return d([0, 0]);
}
function computedGlobalScrollMatrix(scrollPosition, globalMatrix, pixelSizeSignal) {
  return w(() => {
    const global2 = globalMatrix.value;
    if (global2 == null) {
      return void 0;
    }
    const [scrollX, scrollY] = scrollPosition.value;
    const pixelSize = pixelSizeSignal.value;
    return new Matrix4().makeTranslation(-scrollX * pixelSize, scrollY * pixelSize, 0).premultiply(global2);
  });
}
function applyScrollPosition(object, scrollPosition, pixelSizeSignal, initializers) {
  return initializers.push(() => E(() => {
    var _a, _b;
    const [scrollX, scrollY] = scrollPosition.value;
    const pixelSize = pixelSizeSignal.value;
    (_a = object.current) == null ? void 0 : _a.position.set(-scrollX * pixelSize, scrollY * pixelSize, 0);
    (_b = object.current) == null ? void 0 : _b.updateMatrix();
  }));
}
function computedAnyAncestorScrollable(scrollable, anyAncestorScrollable) {
  return w(() => {
    const [ancestorX, ancestorY] = (anyAncestorScrollable == null ? void 0 : anyAncestorScrollable.value) ?? [false, false];
    const [x2, y3] = scrollable.value;
    return [ancestorX || x2, ancestorY || y3];
  });
}
function computedScrollHandlers(scrollPosition, anyAncestorScrollable, { scrollable, maxScrollPosition }, object, interactionPanel, listeners, root, initializers) {
  const isScrollable = w(() => {
    var _a;
    return ((_a = scrollable.value) == null ? void 0 : _a.some((scrollable2) => scrollable2)) ?? false;
  });
  const downPointerMap = /* @__PURE__ */ new Map();
  const scrollVelocity = new Vector2();
  const scroll = (event, deltaX, deltaY, deltaTime, enableRubberBand) => {
    var _a, _b;
    if (scrollPosition.value == null) {
      return;
    }
    const [wasScrolledX, wasScrolledY] = event == null ? [false, false] : getWasScrolled(event.nativeEvent);
    if (wasScrolledX) {
      deltaX = 0;
    }
    if (wasScrolledY) {
      deltaY = 0;
    }
    const [x2, y3] = scrollPosition.value;
    const [maxX, maxY] = maxScrollPosition.value;
    let [newX, newY] = scrollPosition.value;
    const [ancestorScrollableX, ancestorScrollableY] = (anyAncestorScrollable == null ? void 0 : anyAncestorScrollable.value) ?? [false, false];
    newX = computeScroll(x2, maxX, deltaX, enableRubberBand && !ancestorScrollableX);
    newY = computeScroll(y3, maxY, deltaY, enableRubberBand && !ancestorScrollableY);
    if (deltaTime != null && deltaTime > 0) {
      scrollVelocity.set(deltaX, deltaY).divideScalar(deltaTime);
    }
    if (event != null) {
      setWasScrolled(event.nativeEvent, wasScrolledX || Math.min(x2, (maxX ?? 0) - x2) > 5, wasScrolledY || Math.min(y3, (maxY ?? 0) - y3) > 5);
    }
    const preventScroll = (_b = (_a = listeners.peek()) == null ? void 0 : _a.onScroll) == null ? void 0 : _b.call(_a, newX, newY, scrollPosition, event);
    if (preventScroll === false || x2 === newX && y3 === newY) {
      return;
    }
    scrollPosition.value = [newX, newY];
  };
  const onFrame = (delta) => {
    if (downPointerMap.size > 0 || scrollPosition.value == null) {
      return;
    }
    let deltaX = 0;
    let deltaY = 0;
    const [x2, y3] = scrollPosition.value;
    const [maxX, maxY] = maxScrollPosition.value;
    const outsideDistanceX = outsideDistance(x2, 0, maxX ?? 0);
    const outsideDistanceY = outsideDistance(y3, 0, maxY ?? 0);
    if (Math.abs(outsideDistanceX) > 1 || Math.abs(outsideDistanceY) > 1) {
      root.requestFrame();
    }
    deltaX += outsideDistanceX * -0.3;
    deltaY += outsideDistanceY * -0.3;
    deltaX += scrollVelocity.x * delta;
    deltaY += scrollVelocity.y * delta;
    scrollVelocity.multiplyScalar(0.9);
    if (Math.abs(scrollVelocity.x) < 10) {
      scrollVelocity.x = 0;
    } else {
      root.requestFrame();
    }
    if (Math.abs(scrollVelocity.y) < 10) {
      scrollVelocity.y = 0;
    } else {
      root.requestFrame();
    }
    if (deltaX === 0 && deltaY === 0) {
      return;
    }
    scroll(void 0, deltaX, deltaY, void 0, true);
  };
  initializers.push(() => E(() => {
    if (!isScrollable.value) {
      return;
    }
    root.onFrameSet.add(onFrame);
    return () => root.onFrameSet.delete(onFrame);
  }));
  return w(() => {
    if (!isScrollable.value) {
      return void 0;
    }
    const onPointerFinish = ({ pointerId }) => {
      if (!downPointerMap.delete(pointerId) || downPointerMap.size > 0 || scrollPosition.value == null) {
        return;
      }
      root.requestRender();
    };
    return {
      onPointerDown: ({ pointerId, point }) => {
        let interaction = downPointerMap.get(pointerId);
        if (interaction == null) {
          downPointerMap.set(pointerId, interaction = { timestamp: 0, point: new Vector3() });
        }
        interaction.timestamp = performance.now() / 1e3;
        object.current.worldToLocal(interaction.point.copy(point));
      },
      onPointerUp: onPointerFinish,
      onPointerLeave: onPointerFinish,
      onPointerCancel: onPointerFinish,
      onPointerMove: (event) => {
        const prevInteraction = downPointerMap.get(event.pointerId);
        if (prevInteraction == null) {
          return;
        }
        object.current.worldToLocal(localPointHelper.copy(event.point));
        distanceHelper.copy(localPointHelper).sub(prevInteraction.point).divideScalar(root.pixelSize.peek());
        const timestamp = performance.now() / 1e3;
        const deltaTime = timestamp - prevInteraction.timestamp;
        prevInteraction.point.copy(localPointHelper);
        prevInteraction.timestamp = timestamp;
        if (event.defaultPrevented) {
          return;
        }
        scroll(event, -distanceHelper.x, distanceHelper.y, deltaTime, true);
      },
      onWheel: (event) => {
        if (event.defaultPrevented) {
          return;
        }
        const { nativeEvent } = event;
        scroll(event, nativeEvent.deltaX, nativeEvent.deltaY, void 0, false);
      }
    };
  });
}
var wasScrolledSymbol = Symbol("was-scrolled");
function getWasScrolled(event) {
  return event[wasScrolledSymbol] ?? [false, false];
}
function setWasScrolled(event, x2, y3) {
  event[wasScrolledSymbol] = [x2, y3];
}
function computeScroll(position, maxPosition, delta, enableRubberBand) {
  if (delta === 0) {
    return position;
  }
  const outside = outsideDistance(position, 0, maxPosition ?? 0);
  if (sign(delta) === sign(outside)) {
    delta *= Math.max(0, 1 - Math.abs(outside) / 100);
  }
  let newPosition = position + delta;
  if (enableRubberBand && maxPosition != null) {
    return newPosition;
  }
  return clamp(newPosition, 0, maxPosition ?? 0);
}
function sign(value) {
  return value >= 0;
}
function outsideDistance(value, min, max) {
  if (value < min) {
    return value - min;
  }
  if (value > max) {
    return value - max;
  }
  return 0;
}
var scrollbarBorderPropertyKeys = [
  "scrollbarBorderLeftWidth",
  "scrollbarBorderRightWidth",
  "scrollbarBorderTopWidth",
  "scrollbarBorderBottomWidth"
];
function createScrollbars(propertiesSignal, scrollPosition, flexState, globalMatrix, isVisible, parentClippingRect, orderInfo, panelGroupManager, initializers) {
  const scrollbarOrderInfo = computedOrderInfo(void 0, ElementType.Panel, defaultPanelDependencies, orderInfo);
  const scrollbarWidth = computedInheritableProperty(propertiesSignal, "scrollbarWidth", 10);
  const borderInset = computedBorderInset(propertiesSignal, scrollbarBorderPropertyKeys);
  createScrollbar(propertiesSignal, 0, scrollPosition, flexState, globalMatrix, isVisible, parentClippingRect, scrollbarOrderInfo, panelGroupManager, scrollbarWidth, borderInset, initializers);
  createScrollbar(propertiesSignal, 1, scrollPosition, flexState, globalMatrix, isVisible, parentClippingRect, scrollbarOrderInfo, panelGroupManager, scrollbarWidth, borderInset, initializers);
}
var scrollbarMaterialConfig;
function getScrollbarMaterialConfig() {
  scrollbarMaterialConfig ?? (scrollbarMaterialConfig = createPanelMaterialConfig({
    backgroundColor: "scrollbarColor",
    borderBottomLeftRadius: "scrollbarBorderBottomLeftRadius",
    borderBottomRightRadius: "scrollbarBorderBottomRightRadius",
    borderTopRightRadius: "scrollbarBorderTopRightRadius",
    borderTopLeftRadius: "scrollbarBorderTopLeftRadius",
    borderColor: "scrollbarBorderColor",
    borderBend: "scrollbarBorderBend",
    borderOpacity: "scrollbarBorderOpacity",
    backgroundOpacity: "scrollbarOpacity"
  }, {
    backgroundColor: 16777215,
    backgroundOpacity: 1
  }));
  return scrollbarMaterialConfig;
}
function createScrollbar(propertiesSignal, mainIndex, scrollPosition, flexState, globalMatrix, isVisible, parentClippingRect, orderInfo, panelGroupManager, scrollbarWidth, borderSize, initializers) {
  const scrollbarTransformation = w(() => computeScrollbarTransformation(mainIndex, scrollbarWidth.value, flexState.size.value, flexState.maxScrollPosition.value, flexState.borderInset.value, scrollPosition.value));
  const scrollbarPosition = w(() => {
    var _a;
    return ((_a = scrollbarTransformation.value) == null ? void 0 : _a.slice(0, 2)) ?? [0, 0];
  });
  const scrollbarSize = w(() => {
    var _a;
    return ((_a = scrollbarTransformation.value) == null ? void 0 : _a.slice(2, 4)) ?? [0, 0];
  });
  initializers.push((subscriptions) => createInstancedPanel(propertiesSignal, orderInfo, void 0, panelGroupManager, globalMatrix, scrollbarSize, scrollbarPosition, borderSize, parentClippingRect, isVisible, getScrollbarMaterialConfig(), subscriptions));
}
function computeScrollbarTransformation(mainIndex, otherScrollbarSize, size, maxScrollbarPosition, borderInset, scrollPosition) {
  if (size == null || borderInset == null || scrollPosition == null) {
    return void 0;
  }
  const maxMainScrollbarPosition = maxScrollbarPosition[mainIndex];
  if (maxMainScrollbarPosition == null) {
    return void 0;
  }
  const result = [0, 0, 0, 0];
  const invertedIndex = 1 - mainIndex;
  const mainSizeWithoutBorder = size[mainIndex] - borderInset[invertedIndex] - borderInset[invertedIndex + 2];
  const mainScrollbarSize = Math.max(otherScrollbarSize, mainSizeWithoutBorder * mainSizeWithoutBorder / (maxMainScrollbarPosition + mainSizeWithoutBorder));
  const maxScrollbarDistancance = mainSizeWithoutBorder - mainScrollbarSize;
  const mainScrollPosition = scrollPosition[mainIndex];
  result[mainIndex] = size[mainIndex] * 0.5 - mainScrollbarSize * 0.5 - borderInset[(mainIndex + 3) % 4] - maxScrollbarDistancance * clamp(mainScrollPosition / maxMainScrollbarPosition, 0, 1);
  result[invertedIndex] = size[invertedIndex] * 0.5 - otherScrollbarSize * 0.5 - borderInset[invertedIndex + 1];
  if (mainIndex === 0) {
    result[0] *= -1;
    result[1] *= -1;
  }
  result[mainIndex + 2] = mainScrollbarSize;
  result[invertedIndex + 2] = otherScrollbarSize;
  return result;
}

// node_modules/@pmndrs/uikit/dist/text/render/instanced-glyph-mesh.js
var InstancedGlyphMesh = class extends Mesh {
  constructor(instanceMatrix, instanceRGBA, instanceUV, instanceClipping, material) {
    const planeGeometry = new PlaneGeometry();
    planeGeometry.translate(0.5, -0.5, 0);
    super(planeGeometry, material);
    __publicField(this, "instanceMatrix");
    __publicField(this, "instanceRGBA");
    __publicField(this, "instanceUV");
    __publicField(this, "instanceClipping");
    __publicField(this, "count", 0);
    __publicField(this, "isInstancedMesh", true);
    __publicField(this, "instanceColor", null);
    __publicField(this, "morphTexture", null);
    __publicField(this, "boundingBox", new Box3());
    __publicField(this, "boundingSphere", new Sphere());
    this.instanceMatrix = instanceMatrix;
    this.instanceRGBA = instanceRGBA;
    this.instanceUV = instanceUV;
    this.instanceClipping = instanceClipping;
    planeGeometry.attributes.instanceUVOffset = instanceUV;
    planeGeometry.attributes.instanceRGBA = instanceRGBA;
    planeGeometry.attributes.instanceClipping = instanceClipping;
    this.frustumCulled = false;
  }
  copy() {
    throw new Error("copy not implemented");
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  //functions not needed because intersection (and morphing) is intenionally disabled
  computeBoundingBox() {
  }
  computeBoundingSphere() {
  }
  updateMorphTargets() {
  }
  raycast() {
  }
  spherecast() {
  }
};

// node_modules/@pmndrs/uikit/dist/text/render/instanced-gylph-material.js
var InstancedGlyphMaterial = class extends MeshBasicMaterial {
  constructor(font) {
    super({
      transparent: true,
      depthWrite: false,
      toneMapped: false
    });
    this.onBeforeCompile = (parameters) => {
      parameters.uniforms.fontPage = { value: font.page };
      parameters.uniforms.pageSize = { value: [font.pageWidth, font.pageHeight] };
      parameters.uniforms.distanceRange = { value: font.distanceRange };
      parameters.uniforms.v_weight = { value: 0.3 };
      parameters.vertexShader = `attribute vec4 instanceUVOffset;
        varying vec2 fontUv;
        attribute vec4 instanceRGBA;
        varying vec4 rgba;
        attribute mat4 instanceClipping;
        varying mat4 clipping;
        varying vec3 localPosition;
        ` + parameters.vertexShader;
      parameters.vertexShader = parameters.vertexShader.replace("#include <uv_vertex>", `#include <uv_vertex>
            fontUv = instanceUVOffset.xy + uv * instanceUVOffset.zw;
            rgba = instanceRGBA;
            clipping = instanceClipping;
            localPosition = (instanceMatrix * vec4(position, 1.0)).xyz;`);
      parameters.fragmentShader = `uniform sampler2D fontPage;
            uniform vec2 pageSize;
            uniform int distanceRange;
            uniform float v_weight;
        varying vec2 fontUv;
        varying vec4 rgba;
        varying mat4 clipping; 
        varying vec3 localPosition;
        float median(float r, float g, float b) {
            return max(min(r, g), min(max(r, g), b));
        }
        float getDistance() {
            vec3 msdf = texture(fontPage, fontUv).rgb;
            return median(msdf.r, msdf.g, msdf.b);
        }
        ` + parameters.fragmentShader;
      parameters.fragmentShader = parameters.fragmentShader.replace("#include <map_fragment>", ` #include <map_fragment>
          vec4 plane;
          float distanceToPlane, distanceGradient;
          float clipOpacity = 1.0;
          for(int i = 0; i < 4; i++) {
            plane = clipping[ i ];
            distanceToPlane = - dot( -localPosition, plane.xyz ) + plane.w;
            distanceGradient = fwidth( distanceToPlane ) / 2.0;
            clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
      
            if ( clipOpacity == 0.0 ) discard;
          }
          vec2 dxdy = fwidth(fontUv) * pageSize;
          float dist = getDistance() + min(float(v_weight), 0.5 - 1.0 / float(distanceRange)) - 0.5;
          float multiplier = clamp(dist * float(distanceRange) / length(dxdy) + 0.5, 0.0, 1.0);
          if(multiplier <= 0.5) {
              discard;
          }
          diffuseColor.a *= clipOpacity * min((multiplier - 0.5) / 0.5, 1.0);
          diffuseColor *= rgba;
            `);
    };
  }
};

// node_modules/@pmndrs/uikit/dist/text/render/instanced-glyph-group.js
var GlyphGroupManager = class {
  constructor(renderOrder, depthTest, pixelSize, root, object, initializers) {
    __publicField(this, "renderOrder");
    __publicField(this, "depthTest");
    __publicField(this, "pixelSize");
    __publicField(this, "root");
    __publicField(this, "object");
    __publicField(this, "map", /* @__PURE__ */ new Map());
    this.renderOrder = renderOrder;
    this.depthTest = depthTest;
    this.pixelSize = pixelSize;
    this.root = root;
    this.object = object;
    initializers.push(() => {
      const onFrame = (delta) => this.traverse((group) => group.onFrame(delta));
      root.onFrameSet.add(onFrame);
      return () => root.onFrameSet.delete(onFrame);
    }, () => E(() => {
      const ro2 = renderOrder.value;
      this.traverse((group) => group.setRenderOrder(ro2));
    }), () => E(() => {
      const dt3 = depthTest.value;
      this.traverse((group) => group.setDepthTest(dt3));
    }));
  }
  traverse(fn3) {
    for (const groups of this.map.values()) {
      for (const group of groups.values()) {
        fn3(group);
      }
    }
  }
  getGroup(majorIndex, font) {
    let groups = this.map.get(font);
    if (groups == null) {
      this.map.set(font, groups = /* @__PURE__ */ new Map());
    }
    let glyphGroup = groups == null ? void 0 : groups.get(majorIndex);
    if (glyphGroup == null) {
      groups.set(majorIndex, glyphGroup = new InstancedGlyphGroup(this.renderOrder.peek(), this.depthTest.peek(), this.object, font, this.pixelSize, this.root, {
        majorIndex,
        elementType: ElementType.Text,
        minorIndex: 0
      }));
    }
    return glyphGroup;
  }
};
var InstancedGlyphGroup = class {
  constructor(renderOrder, depthTest, object, font, pixelSize, root, orderInfo) {
    __publicField(this, "renderOrder");
    __publicField(this, "object");
    __publicField(this, "pixelSize");
    __publicField(this, "root");
    __publicField(this, "orderInfo");
    __publicField(this, "instanceMatrix");
    __publicField(this, "instanceUV");
    __publicField(this, "instanceRGBA");
    __publicField(this, "instanceClipping");
    __publicField(this, "glyphs", []);
    __publicField(this, "requestedGlyphs", []);
    __publicField(this, "holeIndicies", []);
    __publicField(this, "mesh");
    __publicField(this, "instanceMaterial");
    __publicField(this, "timeTillDecimate");
    this.renderOrder = renderOrder;
    this.object = object;
    this.pixelSize = pixelSize;
    this.root = root;
    this.orderInfo = orderInfo;
    this.instanceMaterial = new InstancedGlyphMaterial(font);
    this.instanceMaterial.depthTest = depthTest;
  }
  setDepthTest(depthTest) {
    this.instanceMaterial.depthTest = depthTest;
    this.root.requestRender();
  }
  setRenderOrder(renderOrder) {
    this.renderOrder = renderOrder;
    if (this.mesh == null) {
      return;
    }
    this.mesh.renderOrder = renderOrder;
    this.root.requestRender();
  }
  requestActivate(glyph) {
    const holeIndex = this.holeIndicies.shift();
    this.root.requestRender();
    if (holeIndex != null) {
      this.glyphs[holeIndex] = glyph;
      glyph.activate(holeIndex);
      return;
    }
    if (this.mesh == null || this.mesh.count >= this.instanceMatrix.count) {
      this.requestedGlyphs.push(glyph);
      return;
    }
    const index = this.mesh.count;
    this.glyphs[index] = glyph;
    glyph.activate(index);
    this.mesh.count += 1;
    return;
  }
  delete(glyph) {
    if (glyph.index == null) {
      const indexInRequested = this.requestedGlyphs.indexOf(glyph);
      if (indexInRequested === -1) {
        return;
      }
      this.requestedGlyphs.splice(indexInRequested, 1);
      return;
    }
    this.root.requestRender();
    const replacement = this.requestedGlyphs.shift();
    if (replacement != null) {
      replacement.activate(glyph.index);
      this.glyphs[glyph.index] = replacement;
      glyph.index = void 0;
      return;
    }
    if (glyph.index === this.glyphs.length - 1) {
      this.glyphs.length -= 1;
      this.mesh.count -= 1;
      glyph.index = void 0;
      return;
    }
    const bufferOffset = glyph.index * 16;
    this.instanceMatrix.array.fill(0, bufferOffset, bufferOffset + 16);
    this.instanceMatrix.addUpdateRange(bufferOffset, 16);
    this.instanceMatrix.needsUpdate = true;
    this.holeIndicies.push(glyph.index);
    this.glyphs[glyph.index] = void 0;
    glyph.index = void 0;
  }
  onFrame(delta) {
    var _a;
    const requiredSize = this.glyphs.length - this.holeIndicies.length + this.requestedGlyphs.length;
    if (this.mesh != null) {
      this.mesh.visible = requiredSize > 0;
    }
    if (requiredSize === 0) {
      return;
    }
    const availableSize = ((_a = this.instanceMatrix) == null ? void 0 : _a.count) ?? 0;
    if (requiredSize < availableSize / 3) {
      this.timeTillDecimate ?? (this.timeTillDecimate = 1);
    } else {
      this.timeTillDecimate = void 0;
    }
    if (this.timeTillDecimate != null) {
      this.timeTillDecimate -= delta;
    }
    if ((this.timeTillDecimate == null || this.timeTillDecimate > 0) && requiredSize <= availableSize) {
      return;
    }
    this.timeTillDecimate = void 0;
    this.resize(requiredSize);
    const indexOffset = this.mesh.count;
    const requestedGlyphsLength = this.requestedGlyphs.length;
    for (let i2 = 0; i2 < requestedGlyphsLength; i2++) {
      const glyph = this.requestedGlyphs[i2];
      glyph.activate(indexOffset + i2);
      this.glyphs[indexOffset + i2] = glyph;
    }
    this.mesh.count += requestedGlyphsLength;
    this.mesh.visible = true;
    this.requestedGlyphs.length = 0;
  }
  resize(neededSize) {
    var _a, _b;
    const newSize = Math.ceil(neededSize * 1.5);
    const matrixArray = new Float32Array(newSize * 16);
    const uvArray = new Float32Array(newSize * 4);
    const rgbaArray = new Float32Array(newSize * 4);
    const clippingArray = new Float32Array(newSize * 16);
    this.instanceMatrix = new InstancedBufferAttribute(matrixArray, 16, false);
    this.instanceMatrix.setUsage(DynamicDrawUsage);
    this.instanceUV = new InstancedBufferAttribute(uvArray, 4, false);
    this.instanceUV.setUsage(DynamicDrawUsage);
    this.instanceRGBA = new InstancedBufferAttribute(rgbaArray, 4, false);
    this.instanceRGBA.setUsage(DynamicDrawUsage);
    this.instanceClipping = new InstancedBufferAttribute(clippingArray, 16, false);
    this.instanceClipping.setUsage(DynamicDrawUsage);
    const oldMesh = this.mesh;
    this.mesh = new InstancedGlyphMesh(this.instanceMatrix, this.instanceRGBA, this.instanceUV, this.instanceClipping, this.instanceMaterial);
    this.mesh.renderOrder = this.renderOrder;
    if (oldMesh != null) {
      this.holeIndicies.sort((i1, i22) => i1 - i22);
      const holesLength = this.holeIndicies.length;
      let afterPrevHoleIndex = 0;
      let i2 = 0;
      while (i2 < holesLength) {
        const holeIndex = this.holeIndicies[i2];
        copyBuffer(afterPrevHoleIndex - i2, afterPrevHoleIndex, holeIndex, oldMesh, this.mesh);
        afterPrevHoleIndex = holeIndex + 1;
        this.glyphs.splice(holeIndex - i2, 1);
        i2++;
      }
      copyBuffer(afterPrevHoleIndex - i2, afterPrevHoleIndex, oldMesh.count, oldMesh, this.mesh);
      if (this.holeIndicies.length > 0) {
        for (let i3 = this.holeIndicies[0]; i3 < this.glyphs.length; i3++) {
          this.glyphs[i3].setIndex(i3);
        }
      }
      this.holeIndicies.length = 0;
      (_a = this.object.current) == null ? void 0 : _a.remove(oldMesh);
      oldMesh.dispose();
    }
    setupRenderOrder(this.mesh, this.root, { value: this.orderInfo });
    this.mesh.count = this.glyphs.length;
    (_b = this.object.current) == null ? void 0 : _b.add(this.mesh);
  }
};
function copyBuffer(target, start, end, oldMesh, newMesh) {
  copy(target, start, end, oldMesh.instanceMatrix.array, newMesh.instanceMatrix.array, 16);
  copy(target, start, end, oldMesh.instanceUV.array, newMesh.instanceUV.array, 4);
  copy(target, start, end, oldMesh.instanceRGBA.array, newMesh.instanceRGBA.array, 4);
  copy(target, start, end, oldMesh.instanceClipping.array, newMesh.instanceClipping.array, 16);
}
function copy(target, start, end, from, to2, itemSize) {
  if (start === end) {
    return;
  }
  const targetIndex = target * itemSize;
  const startIndex = start * itemSize;
  const endIndex = end * itemSize;
  to2.set(from.subarray(startIndex, endIndex), targetIndex);
}

// node_modules/@pmndrs/uikit/dist/responsive.js
var breakPoints = {
  sm: 640,
  md: 768,
  lg: 1024,
  xl: 1280,
  "2xl": 1536
};
var breakPointKeys = Object.keys(breakPoints);
var breakPointKeysLength = breakPointKeys.length;
function createResponsivePropertyTransformers(rootSize) {
  const transformers = {};
  for (let i2 = 0; i2 < breakPointKeysLength; i2++) {
    const key = breakPointKeys[i2];
    transformers[key] = createConditionalPropertyTranslator(() => {
      var _a;
      return (((_a = rootSize.value) == null ? void 0 : _a[0]) ?? 0) > breakPoints[key];
    });
  }
  return transformers;
}

// node_modules/@pmndrs/uikit/dist/dark.js
var queryList = typeof matchMedia === "undefined" ? void 0 : matchMedia == null ? void 0 : matchMedia("(prefers-color-scheme: dark)");
var symstemIsDarkMode = d((queryList == null ? void 0 : queryList.matches) ?? false);
queryList == null ? void 0 : queryList.addEventListener("change", (event) => symstemIsDarkMode.value = event.matches);
var preferredColorScheme = d("system");
var isDarkMode = w(() => {
  switch (preferredColorScheme.value) {
    case "system":
      return symstemIsDarkMode.value;
    case "dark":
      return true;
    case "light":
      return false;
  }
});
function setPreferredColorScheme(scheme) {
  preferredColorScheme.value = scheme;
}
function getPreferredColorScheme() {
  return preferredColorScheme.peek();
}
var darkPropertyTransformers = {
  dark: createConditionalPropertyTranslator(() => isDarkMode.value)
};
function basedOnPreferredColorScheme({ dark, light }) {
  const result = {};
  for (const key in dark) {
    result[key] = w(() => isDarkMode.value ? dark[key] : light[key]);
  }
  return result;
}

// node_modules/@pmndrs/uikit/dist/components/root.js
var DEFAULT_PIXEL_SIZE = 0.01;
var vectorHelper2 = new Vector3();
var planeHelper2 = new Plane();
var identityMatrix = d(new Matrix4());
function createRoot(pixelSize, style, properties, defaultProperties, object, childrenContainer, getCamera, renderer, onFrameSet, requestRender = () => {
}, requestFrame = () => {
}) {
  const rootSize = d([0, 0]);
  const hoveredSignal = d([]);
  const activeSignal = d([]);
  const initializers = [];
  setupCursorCleanup(hoveredSignal, initializers);
  const mergedProperties = computedMergedProperties(style, properties, defaultProperties, {
    ...darkPropertyTransformers,
    ...createResponsivePropertyTransformers(rootSize),
    ...createHoverPropertyTransformers(hoveredSignal),
    ...createActivePropertyTransfomers(activeSignal)
  }, {
    ...createSizeTranslator(pixelSize, "sizeX", "width"),
    ...createSizeTranslator(pixelSize, "sizeY", "height")
  });
  const renderOrder = computedInheritableProperty(mergedProperties, "renderOrder", 0);
  const depthTest = computedInheritableProperty(mergedProperties, "depthTest", true);
  const ctx = {
    cameraDistance: 0,
    onFrameSet,
    requestRender,
    requestFrame,
    pixelSize
  };
  const node = d(void 0);
  const requestCalculateLayout = createDeferredRequestLayoutCalculation(ctx, node, initializers);
  const flexState = createFlexNodeState();
  initializers.push((subscriptions) => {
    const newNode = new FlexNode(flexState, mergedProperties, requestCalculateLayout, object, true, subscriptions);
    node.value = newNode;
    return subscriptions;
  });
  const transformMatrix = computedTransformMatrix(mergedProperties, flexState, pixelSize);
  const rootMatrix = computedRootMatrix(mergedProperties, transformMatrix, flexState.size, pixelSize);
  applyTransform(ctx, object, rootMatrix, initializers);
  const groupDeps = computedPanelGroupDependencies(mergedProperties);
  const orderInfo = computedOrderInfo(void 0, ElementType.Panel, groupDeps, void 0);
  const panelGroupManager = new PanelGroupManager(renderOrder, depthTest, pixelSize, ctx, object, initializers);
  const onCameraDistanceFrame = () => {
    if (object.current == null) {
      ctx.cameraDistance = 0;
      return;
    }
    planeHelper2.normal.set(0, 0, 1);
    planeHelper2.constant = 0;
    planeHelper2.applyMatrix4(object.current.matrixWorld);
    vectorHelper2.setFromMatrixPosition(getCamera().matrixWorld);
    ctx.cameraDistance = planeHelper2.distanceToPoint(vectorHelper2);
  };
  initializers.push(() => {
    onFrameSet.add(onCameraDistanceFrame);
    return () => onFrameSet.delete(onCameraDistanceFrame);
  });
  const isVisible = computedIsVisible(flexState, void 0, mergedProperties);
  initializers.push((subscriptions) => createInstancedPanel(mergedProperties, orderInfo, groupDeps, panelGroupManager, identityMatrix, flexState.size, void 0, flexState.borderInset, void 0, isVisible, getDefaultPanelMaterialConfig(), subscriptions));
  const scrollPosition = createScrollPosition();
  applyScrollPosition(childrenContainer, scrollPosition, pixelSize, initializers);
  const childrenMatrix = computedGlobalScrollMatrix(scrollPosition, identityMatrix, pixelSize);
  createScrollbars(mergedProperties, scrollPosition, flexState, identityMatrix, isVisible, void 0, orderInfo, panelGroupManager, initializers);
  setupLayoutListeners(style, properties, flexState.size, initializers);
  const gylphGroupManager = new GlyphGroupManager(renderOrder, depthTest, pixelSize, ctx, object, initializers);
  const rootCtx = Object.assign(ctx, {
    requestFrame,
    scrollPosition,
    requestCalculateLayout,
    cameraDistance: 0,
    gylphGroupManager,
    object,
    panelGroupManager,
    pixelSize,
    renderOrder,
    depthTest,
    renderer,
    size: flexState.size
  });
  const interactionPanel = createInteractionPanel(orderInfo, rootCtx, void 0, flexState.size, initializers);
  const scrollHandlers = computedScrollHandlers(scrollPosition, void 0, flexState, object, interactionPanel, properties, ctx, initializers);
  return Object.assign(flexState, {
    scrollPosition,
    mergedProperties,
    anyAncestorScrollable: flexState.scrollable,
    clippingRect: computedClippingRect(identityMatrix, flexState, pixelSize, void 0),
    childrenMatrix,
    node,
    orderInfo,
    initializers,
    interactionPanel,
    handlers: computedHandlers(style, properties, defaultProperties, hoveredSignal, activeSignal, scrollHandlers),
    root: rootCtx
  });
}
function createDeferredRequestLayoutCalculation(root, nodeSignal, initializers) {
  let requested = false;
  const onFrame = () => {
    const node = nodeSignal.peek();
    if (!requested || node == null) {
      return;
    }
    requested = false;
    node.calculateLayout();
  };
  initializers.push(() => {
    root.onFrameSet.add(onFrame);
    return () => root.onFrameSet.delete(onFrame);
  });
  return () => {
    requested = true;
    root.requestRender();
  };
}
function createSizeTranslator(pixelSize, key, to2) {
  const map = /* @__PURE__ */ new Map();
  return {
    [key]: (value, target) => {
      let entry = map.get(value);
      if (entry == null) {
        map.set(value, entry = w(() => {
          const s2 = readReactive(value);
          if (s2 == null) {
            return void 0;
          }
          return s2 / pixelSize.value;
        }));
      }
      target.add(to2, entry);
    }
  };
}
var matrixHelper3 = new Matrix4();
var defaultAnchorX = "center";
var defaultAnchorY = "center";
function computedRootMatrix(propertiesSignal, matrix, size, pixelSize) {
  const anchorX = computedInheritableProperty(propertiesSignal, "anchorX", defaultAnchorX);
  const anchorY = computedInheritableProperty(propertiesSignal, "anchorY", defaultAnchorY);
  return w(() => {
    var _a;
    if (size.value == null) {
      return void 0;
    }
    const [width, height] = size.value;
    return (_a = matrix.value) == null ? void 0 : _a.clone().premultiply(matrixHelper3.makeTranslation(alignmentXMap[anchorX.value] * width * pixelSize.value, alignmentYMap[anchorY.value] * height * pixelSize.value, 0));
  });
}

// node_modules/@pmndrs/uikit/dist/components/container.js
function createContainer(parentContext, style, properties, defaultProperties, object, childrenContainer) {
  const node = d(void 0);
  const flexState = createFlexNodeState();
  const hoveredSignal = d([]);
  const activeSignal = d([]);
  const initializers = [];
  setupCursorCleanup(hoveredSignal, initializers);
  const mergedProperties = computedMergedProperties(style, properties, defaultProperties, {
    ...darkPropertyTransformers,
    ...createResponsivePropertyTransformers(parentContext.root.size),
    ...createHoverPropertyTransformers(hoveredSignal),
    ...createActivePropertyTransfomers(activeSignal)
  });
  createNode(node, flexState, parentContext, mergedProperties, object, false, initializers);
  const transformMatrix = computedTransformMatrix(mergedProperties, flexState, parentContext.root.pixelSize);
  applyTransform(parentContext.root, object, transformMatrix, initializers);
  const globalMatrix = computedGlobalMatrix(parentContext.childrenMatrix, transformMatrix);
  const isClipped = computedIsClipped(parentContext.clippingRect, globalMatrix, flexState.size, parentContext.root.pixelSize);
  const isVisible = computedIsVisible(flexState, isClipped, mergedProperties);
  const groupDeps = computedPanelGroupDependencies(mergedProperties);
  const orderInfo = computedOrderInfo(mergedProperties, ElementType.Panel, groupDeps, parentContext.orderInfo);
  initializers.push((subscriptions) => createInstancedPanel(mergedProperties, orderInfo, groupDeps, parentContext.root.panelGroupManager, globalMatrix, flexState.size, void 0, flexState.borderInset, parentContext.clippingRect, isVisible, getDefaultPanelMaterialConfig(), subscriptions));
  const scrollPosition = createScrollPosition();
  applyScrollPosition(childrenContainer, scrollPosition, parentContext.root.pixelSize, initializers);
  const childrenMatrix = computedGlobalScrollMatrix(scrollPosition, globalMatrix, parentContext.root.pixelSize);
  createScrollbars(mergedProperties, scrollPosition, flexState, globalMatrix, isVisible, parentContext.clippingRect, orderInfo, parentContext.root.panelGroupManager, initializers);
  const interactionPanel = createInteractionPanel(orderInfo, parentContext.root, parentContext.clippingRect, flexState.size, initializers);
  const scrollHandlers = computedScrollHandlers(scrollPosition, parentContext.anyAncestorScrollable, flexState, object, interactionPanel, properties, parentContext.root, initializers);
  setupLayoutListeners(style, properties, flexState.size, initializers);
  setupClippedListeners(style, properties, isClipped, initializers);
  return Object.assign(flexState, {
    isClipped,
    mergedProperties,
    anyAncestorScrollable: computedAnyAncestorScrollable(flexState.scrollable, parentContext.anyAncestorScrollable),
    clippingRect: computedClippingRect(globalMatrix, flexState, parentContext.root.pixelSize, parentContext.clippingRect),
    childrenMatrix,
    node,
    orderInfo,
    root: parentContext.root,
    scrollPosition,
    interactionPanel,
    handlers: computedHandlers(style, properties, defaultProperties, hoveredSignal, activeSignal, scrollHandlers),
    initializers
  });
}

// node_modules/@pmndrs/uikit/dist/components/image.js
var defaultImageFit = "fill";
function createImage(parentContext, style, properties, defaultProperties, object, childrenContainer) {
  const initializers = [];
  const texture = d(void 0);
  const hoveredSignal = d([]);
  const activeSignal = d([]);
  setupCursorCleanup(hoveredSignal, initializers);
  const src = w(() => {
    var _a, _b;
    return readReactive((_a = style.value) == null ? void 0 : _a.src) ?? readReactive((_b = properties.value) == null ? void 0 : _b.src);
  });
  loadResourceWithParams(texture, loadTextureImpl, cleanupTexture, initializers, src);
  const textureAspectRatio = w(() => {
    const tex = texture.value;
    if (tex == null) {
      return void 0;
    }
    const image = tex.source.data;
    return image.width / image.height;
  });
  const mergedProperties = computedMergedProperties(style, properties, defaultProperties, {
    ...darkPropertyTransformers,
    ...createResponsivePropertyTransformers(parentContext.root.size),
    ...createHoverPropertyTransformers(hoveredSignal),
    ...createActivePropertyTransfomers(activeSignal)
  }, keepAspectRatioPropertyTransformer, (m) => m.add("aspectRatio", textureAspectRatio));
  const node = d(void 0);
  const flexState = createFlexNodeState();
  createNode(node, flexState, parentContext, mergedProperties, object, true, initializers);
  const transformMatrix = computedTransformMatrix(mergedProperties, flexState, parentContext.root.pixelSize);
  applyTransform(parentContext.root, object, transformMatrix, initializers);
  const globalMatrix = computedGlobalMatrix(parentContext.childrenMatrix, transformMatrix);
  const isClipped = computedIsClipped(parentContext.clippingRect, globalMatrix, flexState.size, parentContext.root.pixelSize);
  const isHidden = w(() => isClipped.value || texture.value == null);
  const isVisible = computedIsVisible(flexState, isHidden, mergedProperties);
  const orderInfo = computedOrderInfo(mergedProperties, ElementType.Image, void 0, parentContext.orderInfo);
  const scrollPosition = createScrollPosition();
  applyScrollPosition(childrenContainer, scrollPosition, parentContext.root.pixelSize, initializers);
  const childrenMatrix = computedGlobalScrollMatrix(scrollPosition, globalMatrix, parentContext.root.pixelSize);
  createScrollbars(mergedProperties, scrollPosition, flexState, globalMatrix, isVisible, parentContext.clippingRect, orderInfo, parentContext.root.panelGroupManager, initializers);
  const interactionPanel = createImageMesh(mergedProperties, texture, parentContext, flexState, orderInfo, parentContext.root, isVisible, initializers);
  const scrollHandlers = computedScrollHandlers(scrollPosition, parentContext.anyAncestorScrollable, flexState, object, interactionPanel, properties, parentContext.root, initializers);
  setupLayoutListeners(style, properties, flexState.size, initializers);
  setupClippedListeners(style, properties, isClipped, initializers);
  return Object.assign(flexState, {
    scrollPosition,
    isClipped,
    mergedProperties,
    anyAncestorScrollable: computedAnyAncestorScrollable(flexState.scrollable, parentContext.anyAncestorScrollable),
    initializers,
    handlers: computedHandlers(style, properties, defaultProperties, hoveredSignal, activeSignal, scrollHandlers),
    interactionPanel,
    clippingRect: computedClippingRect(globalMatrix, flexState, parentContext.root.pixelSize, parentContext.clippingRect),
    childrenMatrix,
    node,
    orderInfo,
    root: parentContext.root
  });
}
var imageMaterialConfig;
function getImageMaterialConfig() {
  imageMaterialConfig ?? (imageMaterialConfig = createPanelMaterialConfig({
    borderBend: "borderBend",
    borderBottomLeftRadius: "borderBottomLeftRadius",
    borderBottomRightRadius: "borderBottomRightRadius",
    borderColor: "borderColor",
    borderOpacity: "borderOpacity",
    borderTopLeftRadius: "borderTopLeftRadius",
    borderTopRightRadius: "borderTopRightRadius",
    backgroundOpacity: "opacity"
  }, {
    backgroundColor: 16777215
  }));
  return imageMaterialConfig;
}
function createImageMesh(propertiesSignal, textureSignal, parentContext, flexState, orderInfo, root, isVisible, initializers) {
  const mesh = new Mesh(panelGeometry);
  mesh.matrixAutoUpdate = false;
  const clippingPlanes = createGlobalClippingPlanes(root, parentContext.clippingRect, initializers);
  const isMeshVisible = getImageMaterialConfig().computedIsVisibile(propertiesSignal, flexState.borderInset, flexState.size, isVisible);
  setupImageMaterials(propertiesSignal, mesh, flexState.size, flexState.borderInset, isMeshVisible, clippingPlanes, root, initializers);
  mesh.raycast = makeClippedCast(mesh, makePanelRaycast(mesh), root.object, parentContext.clippingRect, orderInfo);
  mesh.spherecast = makeClippedCast(mesh, makePanelSpherecast(mesh), root.object, parentContext.clippingRect, orderInfo);
  setupRenderOrder(mesh, root, orderInfo);
  const objectFit = computedInheritableProperty(propertiesSignal, "objectFit", defaultImageFit);
  initializers.push(() => E(() => {
    const texture = textureSignal.value;
    if (texture == null || flexState.size.value == null || flexState.borderInset.value == null) {
      return;
    }
    texture.matrix.identity();
    root.requestRender();
    if (objectFit.value === "fill" || texture == null) {
      transformInsideBorder(flexState.borderInset, flexState.size, texture);
      return;
    }
    const { width: textureWidth, height: textureHeight } = texture.source.data;
    const textureRatio = textureWidth / textureHeight;
    const [width, height] = flexState.size.value;
    const [top, right, bottom, left] = flexState.borderInset.value;
    const boundsRatioValue = (width - left - right) / (height - top - bottom);
    if (textureRatio > boundsRatioValue) {
      texture.matrix.translate(-(0.5 * (boundsRatioValue - textureRatio)) / boundsRatioValue, 0).scale(boundsRatioValue / textureRatio, 1);
    } else {
      texture.matrix.translate(0, -(0.5 * (textureRatio - boundsRatioValue)) / textureRatio).scale(1, textureRatio / boundsRatioValue);
    }
    transformInsideBorder(flexState.borderInset, flexState.size, texture);
  }));
  initializers.push(() => E(() => {
    mesh.visible = isMeshVisible.value;
    parentContext.root.requestRender();
  }));
  initializers.push(() => E(() => {
    const map = textureSignal.value ?? null;
    if (mesh.material.map === map) {
      return;
    }
    mesh.material.map = map;
    mesh.material.needsUpdate = true;
    parentContext.root.requestRender();
  }), () => E(() => {
    if (flexState.size.value == null) {
      return;
    }
    const [width, height] = flexState.size.value;
    const pixelSize = parentContext.root.pixelSize.value;
    mesh.scale.set(width * pixelSize, height * pixelSize, 1);
    mesh.updateMatrix();
    parentContext.root.requestRender();
  }));
  return mesh;
}
function transformInsideBorder(borderInset, size, texture) {
  if (size.value == null || borderInset.value == null) {
    return;
  }
  const [outerWidth, outerHeight] = size.value;
  const [top, right, bottom, left] = borderInset.value;
  const width = outerWidth - left - right;
  const height = outerHeight - top - bottom;
  texture.matrix.translate(-1 + (left + width) / outerWidth, -1 + (top + height) / outerHeight).scale(outerWidth / width, outerHeight / height);
}
var textureLoader = new TextureLoader();
function cleanupTexture(texture) {
  if ((texture == null ? void 0 : texture.disposable) === true) {
    texture.dispose();
  }
}
async function loadTextureImpl(src) {
  if (src == null) {
    return Promise.resolve(void 0);
  }
  if (src instanceof Texture) {
    return Promise.resolve(src);
  }
  try {
    const texture = await textureLoader.loadAsync(src);
    texture.colorSpace = SRGBColorSpace;
    texture.matrixAutoUpdate = false;
    return Object.assign(texture, { disposable: true });
  } catch (error) {
    console.error(error);
    return void 0;
  }
}
function setupImageMaterials(propertiesSignal, target, size, borderInset, isVisible, clippingPlanes, root, initializers) {
  const data = new Float32Array(16);
  const info = { data, type: "normal" };
  target.customDepthMaterial = new PanelDepthMaterial(info);
  target.customDistanceMaterial = new PanelDistanceMaterial(info);
  target.customDepthMaterial.clippingPlanes = clippingPlanes;
  target.customDistanceMaterial.clippingPlanes = clippingPlanes;
  const panelMaterialClass = computedInheritableProperty(propertiesSignal, "panelMaterialClass", MeshBasicMaterial);
  initializers.push((subscriptions) => {
    subscriptions.push(E(() => {
      const material = createPanelMaterial(panelMaterialClass.value, info);
      material.clippingPlanes = clippingPlanes;
      target.material = material;
      return E(() => {
        material.depthTest = root.depthTest.value;
        root.requestRender();
      });
    }), E(() => {
      target.renderOrder = root.renderOrder.value;
      root.requestRender();
    }), E(() => {
      target.castShadow = propertiesSignal.value.read("castShadow", false);
      root.requestRender();
    }), E(() => {
      target.receiveShadow = propertiesSignal.value.read("receiveShadow", false);
      root.requestRender();
    }));
    return subscriptions;
  });
  const imageMaterialConfig2 = getImageMaterialConfig();
  const internalSubscriptions = [];
  initializers.push(() => E(() => {
    if (!isVisible.value) {
      return;
    }
    data.set(imageMaterialConfig2.defaultData);
    internalSubscriptions.push(E(() => size.value != null && data.set(size.value, 13)), E(() => borderInset.value != null && data.set(borderInset.value, 0)));
    root.requestRender();
    return () => unsubscribeSubscriptions(internalSubscriptions);
  }));
  const setters = imageMaterialConfig2.setters;
  initializers.push((subscriptions) => {
    setupImmediateProperties(propertiesSignal, isVisible, imageMaterialConfig2.hasProperty, (key, value) => {
      setters[key](data, 0, value, size, void 0);
      root.requestRender();
    }, subscriptions);
    return subscriptions;
  });
}

// node_modules/@pmndrs/uikit/dist/text/utils.js
function getGlyphOffsetX(font, fontSize, glyphInfo, prevGlyphId) {
  const kerning = prevGlyphId == null ? 0 : font.getKerning(prevGlyphId, glyphInfo.id);
  return (kerning + glyphInfo.xoffset) * fontSize;
}
function lineHeightToAbsolute(lineHeight, fontSize) {
  if (typeof lineHeight === "number") {
    return lineHeight;
  }
  const result = percentageRegex.exec(lineHeight);
  if (result == null) {
    throw new Error(`invalid line height "${lineHeight}"`);
  }
  return fontSize * parseFloat(result[1]) / 100;
}
function getGlyphOffsetY(fontSize, lineHeight, glyphInfo) {
  return ((glyphInfo == null ? void 0 : glyphInfo.yoffset) ?? 0) * fontSize + (lineHeightToAbsolute(lineHeight, fontSize) - fontSize) / 2;
}
function getOffsetToNextGlyph(fontSize, glyphInfo, letterSpacing) {
  return glyphInfo.xadvance * fontSize + letterSpacing;
}
function getOffsetToNextLine(lineHeight, fontSize) {
  return lineHeightToAbsolute(lineHeight, fontSize);
}
function getGlyphLayoutHeight(linesAmount, { lineHeight, fontSize }) {
  return Math.max(linesAmount, 1) * lineHeightToAbsolute(lineHeight, fontSize);
}

// node_modules/@pmndrs/uikit/dist/text/wrapper/breakall-wrapper.js
var BreakallWrapper = ({ text, fontSize, font, letterSpacing }, availableWidth, charIndex, target) => {
  charIndex = skipWhitespace(text, charIndex);
  const firstIndex = charIndex;
  target.charIndexOffset = firstIndex;
  target.nonWhitespaceCharLength = 0;
  target.charLength = 0;
  target.nonWhitespaceWidth = 0;
  target.whitespacesBetween = 0;
  let position = 0;
  let whitespaces = 0;
  for (; charIndex < text.length; charIndex++) {
    const char = text[charIndex];
    if (char === "\n") {
      target.charLength = charIndex - firstIndex + 1;
      return;
    }
    position += getOffsetToNextGlyph(fontSize, font.getGlyphInfo(char), letterSpacing);
    if (char === " ") {
      whitespaces += 1;
      continue;
    }
    if (target.nonWhitespaceWidth > 0 && availableWidth != null && position > availableWidth) {
      break;
    }
    target.nonWhitespaceCharLength = charIndex - firstIndex + 1;
    target.nonWhitespaceWidth = position;
    target.whitespacesBetween = whitespaces;
  }
  target.charLength = charIndex - firstIndex;
};

// node_modules/@pmndrs/uikit/dist/text/wrapper/nowrap-wrapper.js
var NowrapWrapper = ({ text, fontSize, font, letterSpacing }, _3, charIndex, target) => {
  charIndex = skipWhitespace(text, charIndex);
  const firstIndex = charIndex;
  target.charIndexOffset = firstIndex;
  target.nonWhitespaceCharLength = 0;
  target.charLength = 0;
  target.nonWhitespaceWidth = 0;
  target.whitespacesBetween = 0;
  let position = 0;
  let whitespaces = 0;
  for (; charIndex < text.length; charIndex++) {
    const char = text[charIndex];
    if (char === "\n") {
      target.charLength = charIndex - firstIndex + 1;
      return;
    }
    position += getOffsetToNextGlyph(fontSize, font.getGlyphInfo(char), letterSpacing);
    if (char === " ") {
      whitespaces += 1;
      continue;
    }
    target.nonWhitespaceWidth = position;
    target.whitespacesBetween = whitespaces;
    target.nonWhitespaceCharLength = charIndex - firstIndex + 1;
  }
  target.charLength = charIndex - firstIndex;
};

// node_modules/@pmndrs/uikit/dist/text/wrapper/word-wrapper.js
var WordWrapper = ({ text, fontSize, font, letterSpacing }, availableWidth, charIndex, target) => {
  charIndex = skipWhitespace(text, charIndex);
  const firstIndex = charIndex;
  target.charIndexOffset = firstIndex;
  target.nonWhitespaceCharLength = 0;
  target.charLength = 0;
  target.nonWhitespaceWidth = 0;
  target.whitespacesBetween = 0;
  let position = 0;
  let whitespaces = 0;
  for (; charIndex < text.length; charIndex++) {
    const char = text[charIndex];
    if (char === "\n") {
      target.charLength = charIndex - firstIndex + 1;
      break;
    }
    position += getOffsetToNextGlyph(fontSize, font.getGlyphInfo(char), letterSpacing);
    if (char === " ") {
      whitespaces += 1;
      target.charLength = charIndex - firstIndex + 1;
      continue;
    }
    if (target.nonWhitespaceWidth > 0 && availableWidth != null && position > availableWidth) {
      break;
    }
    const nextChar = text[charIndex + 1];
    if (nextChar === " " || nextChar === "\n" || nextChar == null) {
      target.charLength = charIndex - firstIndex + 1;
      target.nonWhitespaceCharLength = target.charLength;
      target.nonWhitespaceWidth = position;
      target.whitespacesBetween = whitespaces;
    }
  }
};

// node_modules/@pmndrs/uikit/dist/text/wrapper/index.js
function skipWhitespace(text, index) {
  const textLength = text.length;
  while (text[index] === " " && index < textLength) {
    index++;
  }
  return index;
}

// node_modules/@pmndrs/uikit/dist/text/cache.js
var fontCache = /* @__PURE__ */ new Map();
var textureLoader2 = new TextureLoader();
function loadCachedFont(url, renderer, onLoad) {
  let entry = fontCache.get(url);
  if (entry instanceof Set) {
    entry.add(onLoad);
    return;
  }
  if (entry != null) {
    onLoad(entry);
    return;
  }
  const set = /* @__PURE__ */ new Set();
  set.add(onLoad);
  fontCache.set(url, set);
  loadFont(url, renderer).then((font) => {
    for (const fn3 of set) {
      fn3(font);
    }
    fontCache.set(url, font);
  }).catch(console.error);
}
async function loadFont(url, renderer) {
  const info = await (await fetch(url)).json();
  if (info.pages.length !== 1) {
    throw new Error("only supporting exactly 1 page");
  }
  const page = await textureLoader2.loadAsync(new URL(info.pages[0], new URL(url, window.location.href)).href);
  page.anisotropy = renderer.capabilities.getMaxAnisotropy();
  page.flipY = false;
  return new Font(info, page);
}

// node_modules/@pmndrs/uikit/dist/text/font.js
var fontWeightNames = {
  thin: 100,
  "extra-light": 200,
  light: 300,
  normal: 400,
  medium: 500,
  "semi-bold": 600,
  bold: 700,
  "extra-bold": 800,
  black: 900,
  "extra-black": 950
};
var defaultFontFamilyUrls = {
  inter: {
    light: "https://pmndrs.github.io/uikit/fonts/inter-light.json",
    normal: "https://pmndrs.github.io/uikit/fonts/inter-normal.json",
    medium: "https://pmndrs.github.io/uikit/fonts/inter-medium.json",
    "semi-bold": "https://pmndrs.github.io/uikit/fonts/inter-semi-bold.json",
    bold: "https://pmndrs.github.io/uikit/fonts/inter-bold.json"
  }
};
function computedFont(properties, fontFamiliesSignal, renderer, initializers) {
  const result = d(void 0);
  const fontFamily = computedInheritableProperty(properties, "fontFamily", void 0);
  const fontWeight = computedInheritableProperty(properties, "fontWeight", "normal");
  initializers.push(() => E(() => {
    const fontFamilies = (fontFamiliesSignal == null ? void 0 : fontFamiliesSignal.value) ?? defaultFontFamilyUrls;
    let resolvedFontFamily = fontFamily.value;
    if (resolvedFontFamily == null) {
      resolvedFontFamily = Object.keys(fontFamilies)[0];
    }
    const url = getMatchingFontUrl(fontFamilies[resolvedFontFamily], typeof fontWeight.value === "string" ? fontWeightNames[fontWeight.value] : fontWeight.value);
    let canceled = false;
    loadCachedFont(url, renderer, (font) => canceled ? void 0 : result.value = font);
    return () => canceled = true;
  }));
  return result;
}
function getMatchingFontUrl(fontFamily, weight) {
  let distance = Infinity;
  let result;
  for (const fontWeight in fontFamily) {
    const d2 = Math.abs(weight - getWeightNumber(fontWeight));
    if (d2 === 0) {
      return fontFamily[fontWeight];
    }
    if (d2 < distance) {
      distance = d2;
      result = fontFamily[fontWeight];
    }
  }
  if (result == null) {
    throw new Error(`font family has no entries ${fontFamily}`);
  }
  return result;
}
function getWeightNumber(value) {
  if (value in fontWeightNames) {
    return fontWeightNames[value];
  }
  const number = parseFloat(value);
  if (isNaN(number)) {
    throw new Error(`invalid font weight "${value}"`);
  }
  return number;
}
var Font = class {
  constructor(info, page) {
    __publicField(this, "page");
    __publicField(this, "glyphInfoMap", /* @__PURE__ */ new Map());
    __publicField(this, "kerningMap", /* @__PURE__ */ new Map());
    __publicField(this, "questionmarkGlyphInfo");
    //needed in the shader:
    __publicField(this, "pageWidth");
    __publicField(this, "pageHeight");
    __publicField(this, "distanceRange");
    this.page = page;
    const { scaleW, scaleH, lineHeight } = info.common;
    this.pageWidth = scaleW;
    this.pageHeight = scaleH;
    this.distanceRange = info.distanceField.distanceRange;
    const { size } = info.info;
    for (const glyph of info.chars) {
      glyph.uvX = glyph.x / scaleW;
      glyph.uvY = glyph.y / scaleH;
      glyph.uvWidth = glyph.width / scaleW;
      glyph.uvHeight = glyph.height / scaleH;
      glyph.width /= size;
      glyph.height /= size;
      glyph.xadvance /= size;
      glyph.xoffset /= size;
      glyph.yoffset -= lineHeight - size;
      glyph.yoffset /= size;
      this.glyphInfoMap.set(glyph.char, glyph);
    }
    for (const { first, second, amount } of info.kernings) {
      this.kerningMap.set(`${first}/${second}`, amount / size);
    }
    const questionmarkGlyphInfo = this.glyphInfoMap.get("?");
    if (questionmarkGlyphInfo == null) {
      throw new Error("missing '?' glyph in font");
    }
    this.questionmarkGlyphInfo = questionmarkGlyphInfo;
  }
  getGlyphInfo(char) {
    return this.glyphInfoMap.get(char) ?? (char == "\n" ? this.glyphInfoMap.get(" ") : this.questionmarkGlyphInfo) ?? this.questionmarkGlyphInfo;
  }
  getKerning(firstId, secondId) {
    return this.kerningMap.get(`${firstId}/${secondId}`) ?? 0;
  }
};
function glyphIntoToUV(info, target, offset) {
  target[offset + 0] = info.uvX;
  target[offset + 1] = info.uvY + info.uvHeight;
  target[offset + 2] = info.uvWidth;
  target[offset + 3] = -info.uvHeight;
}

// node_modules/@pmndrs/uikit/dist/text/layout.js
function computedCustomLayouting(properties, fontSignal, textSignal, propertiesRef, defaultWordBreak) {
  const fontSize = computedInheritableProperty(properties, "fontSize", 16);
  const letterSpacing = computedInheritableProperty(properties, "letterSpacing", 0);
  const lineHeight = computedInheritableProperty(properties, "lineHeight", "120%");
  const wordBreak = computedInheritableProperty(properties, "wordBreak", defaultWordBreak);
  return w(() => {
    const font = fontSignal.value;
    if (font == null) {
      return void 0;
    }
    const text = textSignal.value;
    const layoutProperties = {
      font,
      fontSize: fontSize.value,
      letterSpacing: letterSpacing.value,
      lineHeight: lineHeight.value,
      text: Array.isArray(text) ? text.map((t2) => readReactive(t2)).join("") : readReactive(text),
      wordBreak: wordBreak.value
    };
    propertiesRef.current = layoutProperties;
    const { width: minWidth } = measureGlyphLayout(layoutProperties, 0);
    const { height: minHeight } = measureGlyphLayout(layoutProperties, void 0);
    return {
      minHeight,
      minWidth,
      measure: (width, widthMode) => measureGlyphLayout(layoutProperties, widthMode === MeasureMode.Undefined ? void 0 : width)
    };
  });
}
var wrappers = {
  "keep-all": NowrapWrapper,
  "break-all": BreakallWrapper,
  "break-word": WordWrapper
};
var lineHelper = {};
function measureGlyphLayout(properties, availableWidth) {
  const wrapper = wrappers[properties.wordBreak];
  const text = properties.text;
  let width = 0;
  let lines = 0;
  let charIndex = 0;
  while (charIndex < text.length) {
    wrapper(properties, availableWidth, charIndex, lineHelper);
    width = Math.max(width, lineHelper.nonWhitespaceWidth);
    lines += 1;
    charIndex = lineHelper.charLength + lineHelper.charIndexOffset;
  }
  if (text[text.length - 1] === "\n") {
    lines += 1;
  }
  return { width, height: getGlyphLayoutHeight(lines, properties) };
}
function buildGlyphLayout(properties, availableWidth, availableHeight) {
  const lines = [];
  const wrapper = wrappers[properties.wordBreak];
  const text = properties.text;
  let charIndex = 0;
  while (charIndex < text.length) {
    const line = {};
    wrapper(properties, availableWidth, charIndex, line);
    lines.push(line);
    charIndex = line.charLength + line.charIndexOffset;
  }
  if (lines.length === 0 || text[text.length - 1] === "\n") {
    lines.push({
      charLength: 0,
      nonWhitespaceWidth: 0,
      whitespacesBetween: 0,
      charIndexOffset: text.length,
      nonWhitespaceCharLength: 0
    });
  }
  return {
    lines,
    availableHeight,
    availableWidth,
    ...properties
  };
}

// node_modules/@pmndrs/uikit/dist/text/render/instanced-glyph.js
var helperMatrix1 = new Matrix4();
var helperMatrix2 = new Matrix4();
function computedGylphGroupDependencies(fontSignal) {
  return w(() => ({ font: fontSignal.value }));
}
var InstancedGlyph = class {
  constructor(group, baseMatrix, color, opacity, clippingRect) {
    __publicField(this, "group");
    __publicField(this, "baseMatrix");
    __publicField(this, "color");
    __publicField(this, "opacity");
    __publicField(this, "clippingRect");
    __publicField(this, "index");
    __publicField(this, "hidden", true);
    __publicField(this, "glyphInfo");
    __publicField(this, "x", 0);
    __publicField(this, "y", 0);
    __publicField(this, "fontSize", 0);
    __publicField(this, "pixelSize", 0);
    this.group = group;
    this.baseMatrix = baseMatrix;
    this.color = color;
    this.opacity = opacity;
    this.clippingRect = clippingRect;
  }
  getX(widthMultiplier) {
    if (this.glyphInfo == null) {
      return this.x;
    }
    return this.x + widthMultiplier * this.glyphInfo.width * this.fontSize;
  }
  show() {
    if (!this.hidden) {
      return;
    }
    this.hidden = false;
    this.group.requestActivate(this);
  }
  hide() {
    if (this.hidden) {
      return;
    }
    this.hidden = true;
    this.group.delete(this);
  }
  activate(index) {
    this.index = index;
    this.writeUpdatedMatrix();
    this.writeUV();
    this.updateColor(this.color);
    this.updateOpacity(this.opacity);
    this.updateClippingRect(this.clippingRect);
  }
  setIndex(index) {
    this.index = index;
  }
  updateClippingRect(clippingRect) {
    this.clippingRect = clippingRect;
    if (this.index == null) {
      return;
    }
    const offset = this.index * 16;
    const { instanceClipping, root } = this.group;
    if (this.clippingRect == null) {
      instanceClipping.set(defaultClippingData, offset);
    } else {
      this.clippingRect.toArray(instanceClipping.array, offset);
    }
    instanceClipping.addUpdateRange(offset, 16);
    instanceClipping.needsUpdate = true;
    root.requestRender();
  }
  updateColor(color) {
    this.color = color;
    if (this.index == null) {
      return;
    }
    const { instanceRGBA, root } = this.group;
    const offset = instanceRGBA.itemSize * this.index;
    writeColor(instanceRGBA.array, offset, color, void 0);
    instanceRGBA.addUpdateRange(offset, 3);
    instanceRGBA.needsUpdate = true;
    root.requestRender();
  }
  updateOpacity(opacity) {
    this.opacity = opacity;
    if (this.index == null) {
      return;
    }
    const { instanceRGBA, root } = this.group;
    const bufferIndex = this.index * 4 + 3;
    instanceRGBA.array[bufferIndex] = opacity;
    instanceRGBA.addUpdateRange(bufferIndex, 1);
    instanceRGBA.needsUpdate = true;
    root.requestRender();
  }
  updateGlyphAndTransformation(glyphInfo, x2, y3, fontSize, pixelSize) {
    if (this.glyphInfo === glyphInfo && this.x === x2 && this.y === y3 && this.fontSize === fontSize && this.pixelSize === pixelSize) {
      return;
    }
    if (this.glyphInfo != glyphInfo) {
      this.glyphInfo = glyphInfo;
      this.writeUV();
    }
    this.x = x2;
    this.y = y3;
    this.fontSize = fontSize;
    this.pixelSize = pixelSize;
    this.writeUpdatedMatrix();
  }
  updateBaseMatrix(baseMatrix) {
    if (this.baseMatrix === baseMatrix) {
      return;
    }
    this.baseMatrix = baseMatrix;
    this.writeUpdatedMatrix();
  }
  writeUV() {
    if (this.index == null || this.glyphInfo == null) {
      return;
    }
    const offset = this.index * 4;
    const { instanceUV, root } = this.group;
    glyphIntoToUV(this.glyphInfo, instanceUV.array, offset);
    instanceUV.addUpdateRange(offset, 4);
    instanceUV.needsUpdate = true;
    root.requestRender();
  }
  writeUpdatedMatrix() {
    if (this.index == null || this.glyphInfo == null || this.baseMatrix == null) {
      return;
    }
    const offset = this.index * 16;
    const { instanceMatrix, root } = this.group;
    instanceMatrix.addUpdateRange(offset, 16);
    helperMatrix1.makeTranslation(this.x * this.pixelSize, this.y * this.pixelSize, 0).multiply(helperMatrix2.makeScale(this.fontSize * this.glyphInfo.width * this.pixelSize, this.fontSize * this.glyphInfo.height * this.pixelSize, 1)).premultiply(this.baseMatrix);
    helperMatrix1.toArray(instanceMatrix.array, offset);
    instanceMatrix.needsUpdate = true;
    root.requestRender();
  }
};

// node_modules/@pmndrs/uikit/dist/text/render/instanced-text.js
var defaultVerticalAlign = "middle";
var defaulttextAlign = "left";
function createInstancedText(properties, textSignal, matrix, nodeSignal, flexState, isVisible, parentClippingRect, orderInfo, fontSignal, glyphGroupManager, selectionRange, selectionBoxes, caretPosition, instancedTextRef, initializers, defaultWordBreak) {
  let layoutPropertiesRef = { current: void 0 };
  const customLayouting = computedCustomLayouting(properties, fontSignal, textSignal, layoutPropertiesRef, defaultWordBreak);
  const verticalAlign = computedInheritableProperty(properties, "verticalAlign", defaultVerticalAlign);
  const textAlign = computedInheritableProperty(properties, "textAlign", defaulttextAlign);
  const color = computedInheritableProperty(properties, "color", 0);
  const opacity = computedInheritableProperty(properties, "opacity", 1);
  const layoutSignal = d(void 0);
  initializers.push(() => E(() => {
    var _a;
    return (_a = nodeSignal.value) == null ? void 0 : _a.addLayoutChangeListener(() => {
      const layoutProperties = layoutPropertiesRef.current;
      const { size: { value: size }, paddingInset: { value: paddingInset }, borderInset: { value: borderInset } } = flexState;
      if (layoutProperties == null || size == null || paddingInset == null || borderInset == null) {
        return;
      }
      const [width, height] = size;
      const [pTop, pRight, pBottom, pLeft] = paddingInset;
      const [bTop, bRight, bBottom, bLeft] = borderInset;
      const actualWidth = width - pRight - pLeft - bRight - bLeft;
      const actualheight = height - pTop - pBottom - bTop - bBottom;
      layoutSignal.value = buildGlyphLayout(layoutProperties, actualWidth, actualheight);
    });
  }), () => E(() => {
    const font = fontSignal.value;
    if (font == null || orderInfo.value == null) {
      return;
    }
    const instancedText = new InstancedText(glyphGroupManager.getGroup(orderInfo.value.majorIndex, font), textAlign, verticalAlign, color, opacity, layoutSignal, matrix, isVisible, parentClippingRect, selectionRange, selectionBoxes, caretPosition);
    if (instancedTextRef != null) {
      instancedTextRef.current = instancedText;
    }
    return () => instancedText.destroy();
  }));
  return customLayouting;
}
var noSelectionBoxes = [];
var InstancedText = class {
  constructor(group, textAlign, verticalAlign, color, opacity, layoutSignal, matrix, isVisible, parentClippingRect, selectionRange, selectionBoxes, caretPosition) {
    __publicField(this, "group");
    __publicField(this, "textAlign");
    __publicField(this, "verticalAlign");
    __publicField(this, "color");
    __publicField(this, "opacity");
    __publicField(this, "layoutSignal");
    __publicField(this, "matrix");
    __publicField(this, "parentClippingRect");
    __publicField(this, "selectionRange");
    __publicField(this, "selectionBoxes");
    __publicField(this, "caretPosition");
    __publicField(this, "glyphLines", []);
    __publicField(this, "lastLayout");
    __publicField(this, "unsubscribeInitialList", []);
    __publicField(this, "unsubscribeShowList", []);
    this.group = group;
    this.textAlign = textAlign;
    this.verticalAlign = verticalAlign;
    this.color = color;
    this.opacity = opacity;
    this.layoutSignal = layoutSignal;
    this.matrix = matrix;
    this.parentClippingRect = parentClippingRect;
    this.selectionRange = selectionRange;
    this.selectionBoxes = selectionBoxes;
    this.caretPosition = caretPosition;
    this.unsubscribeInitialList = [
      E(() => {
        if (!isVisible.value || opacity.value < 0.01) {
          this.hide();
          return;
        }
        this.show();
      }),
      E(() => this.updateSelectionBoxes(this.lastLayout, selectionRange == null ? void 0 : selectionRange.value, verticalAlign.peek(), textAlign.peek()))
    ];
  }
  getCharIndex(x2, y3) {
    const layout = this.lastLayout;
    if (layout == null) {
      return 0;
    }
    y3 -= -getYOffset(layout, this.verticalAlign.peek());
    const lineIndex = Math.floor(y3 / -getOffsetToNextLine(layout.lineHeight, layout.fontSize));
    const lines = layout.lines;
    if (lineIndex < 0 || lines.length === 0) {
      return 0;
    }
    if (lineIndex >= lines.length) {
      const lastLine = lines[lines.length - 1];
      return lastLine.charIndexOffset + lastLine.charLength + 1;
    }
    const line = lines[lineIndex];
    const whitespaceWidth = layout.font.getGlyphInfo(" ").xadvance * layout.fontSize;
    const glyphs = this.glyphLines[lineIndex];
    let glyphsLength = glyphs.length;
    for (let i2 = 0; i2 < glyphsLength; i2++) {
      const entry = glyphs[i2];
      if (x2 < this.getGlyphX(entry, 0.5, whitespaceWidth) + layout.availableWidth / 2) {
        return i2 + line.charIndexOffset;
      }
    }
    return line.charIndexOffset + line.charLength + 1;
  }
  updateSelectionBoxes(layout, range, verticalAlign, textAlign) {
    if (this.caretPosition == null || this.selectionBoxes == null) {
      return;
    }
    if (range == null || layout == null || layout.lines.length === 0) {
      this.caretPosition.value = void 0;
      this.selectionBoxes.value = noSelectionBoxes;
      return;
    }
    const whitespaceWidth = layout.font.getGlyphInfo(" ").xadvance * layout.fontSize;
    const [startCharIndexIncl, endCharIndexExcl] = range;
    if (endCharIndexExcl <= startCharIndexIncl) {
      const { lineIndex, x: x2 } = this.getGlyphLineAndX(layout, endCharIndexExcl, true, whitespaceWidth, textAlign);
      const y3 = -(getYOffset(layout, verticalAlign) - layout.availableHeight / 2 + lineIndex * getOffsetToNextLine(layout.lineHeight, layout.fontSize) + getGlyphOffsetY(layout.fontSize, layout.lineHeight));
      this.caretPosition.value = [x2, y3 - layout.fontSize / 2, layout.fontSize];
      this.selectionBoxes.value = [];
      return;
    }
    this.caretPosition.value = void 0;
    const start = this.getGlyphLineAndX(layout, startCharIndexIncl, true, whitespaceWidth, textAlign);
    const end = this.getGlyphLineAndX(layout, endCharIndexExcl - 1, false, whitespaceWidth, textAlign);
    if (start.lineIndex === end.lineIndex) {
      this.selectionBoxes.value = [
        this.computeSelectionBox(start.lineIndex, start.x, end.x, layout, verticalAlign, whitespaceWidth)
      ];
      return;
    }
    const newSelectionBoxes = [
      this.computeSelectionBox(start.lineIndex, start.x, void 0, layout, verticalAlign, whitespaceWidth)
    ];
    for (let i2 = start.lineIndex + 1; i2 < end.lineIndex; i2++) {
      newSelectionBoxes.push(this.computeSelectionBox(i2, void 0, void 0, layout, verticalAlign, whitespaceWidth));
    }
    newSelectionBoxes.push(this.computeSelectionBox(end.lineIndex, void 0, end.x, layout, verticalAlign, whitespaceWidth));
    this.selectionBoxes.value = newSelectionBoxes;
  }
  computeSelectionBox(lineIndex, startX, endX, layout, verticalAlign, whitespaceWidth) {
    const lineGlyphs = this.glyphLines[lineIndex];
    if (startX == null) {
      startX = this.getGlyphX(lineGlyphs[0], 0, whitespaceWidth);
    }
    if (endX == null) {
      endX = this.getGlyphX(lineGlyphs[lineGlyphs.length - 1], 1, whitespaceWidth);
    }
    const height = getOffsetToNextLine(layout.lineHeight, layout.fontSize);
    const y3 = -(getYOffset(layout, verticalAlign) - layout.availableHeight / 2 + lineIndex * height);
    const width = endX - startX;
    return { position: [startX + width / 2, y3 - height / 2], size: [width, height] };
  }
  getGlyphLineAndX({ lines, availableWidth }, charIndex, start, whitespaceWidth, textAlign) {
    const linesLength = lines.length;
    for (let lineIndex = 0; lineIndex < linesLength; lineIndex++) {
      const line = lines[lineIndex];
      if (charIndex >= line.charIndexOffset + line.charLength) {
        continue;
      }
      const glyphEntry = this.glyphLines[lineIndex][Math.max(charIndex - line.charIndexOffset, 0)];
      return { lineIndex, x: this.getGlyphX(glyphEntry, start ? 0 : 1, whitespaceWidth) };
    }
    const lastLine = lines[linesLength - 1];
    if (lastLine.charLength === 0) {
      return {
        lineIndex: linesLength - 1,
        x: getXOffset(availableWidth, lastLine.nonWhitespaceWidth, textAlign) - availableWidth / 2
      };
    }
    const lastGlyphEntry = this.glyphLines[linesLength - 1][lastLine.charLength - 1];
    return { lineIndex: linesLength - 1, x: this.getGlyphX(lastGlyphEntry, 1, whitespaceWidth) };
  }
  getGlyphX(entry, widthMultiplier, whitespaceWidth) {
    if (typeof entry === "number") {
      return entry + widthMultiplier * whitespaceWidth;
    }
    return entry.getX(widthMultiplier);
  }
  show() {
    if (this.unsubscribeShowList.length > 0) {
      return;
    }
    traverseGlyphs(this.glyphLines, (glyph) => glyph.show());
    this.unsubscribeShowList.push(E(() => {
      const matrix = this.matrix.value;
      if (matrix == null) {
        return;
      }
      traverseGlyphs(this.glyphLines, (glyph) => glyph.updateBaseMatrix(matrix));
    }), E(() => {
      var _a;
      const clippingRect = (_a = this.parentClippingRect) == null ? void 0 : _a.value;
      traverseGlyphs(this.glyphLines, (glyph) => glyph.updateClippingRect(clippingRect));
    }), E(() => {
      const color = this.color.value;
      traverseGlyphs(this.glyphLines, (glyph) => glyph.updateColor(color));
    }), E(() => {
      const opacity = this.opacity.value;
      traverseGlyphs(this.glyphLines, (glyph) => glyph.updateOpacity(opacity));
    }), E(() => {
      var _a, _b;
      const layout = this.layoutSignal.value;
      if (layout == null) {
        return;
      }
      const { text, font, lines, letterSpacing = 0, fontSize = 16, lineHeight = 1.2, availableWidth } = layout;
      let y3 = getYOffset(layout, this.verticalAlign.value) - layout.availableHeight / 2;
      const linesLength = lines.length;
      const pixelSize = this.group.pixelSize.value;
      for (let lineIndex = 0; lineIndex < linesLength; lineIndex++) {
        if (lineIndex === this.glyphLines.length) {
          this.glyphLines.push([]);
        }
        const { whitespacesBetween, nonWhitespaceWidth, charIndexOffset: firstNonWhitespaceCharIndex, nonWhitespaceCharLength, charLength } = lines[lineIndex];
        let offsetPerWhitespace = this.textAlign.value === "block" ? (availableWidth - nonWhitespaceWidth) / whitespacesBetween : 0;
        let x2 = getXOffset(availableWidth, nonWhitespaceWidth, this.textAlign.value) - availableWidth / 2;
        let prevGlyphId;
        const glyphs = this.glyphLines[lineIndex];
        for (let charIndex = firstNonWhitespaceCharIndex; charIndex < firstNonWhitespaceCharIndex + charLength; charIndex++) {
          const glyphIndex = charIndex - firstNonWhitespaceCharIndex;
          const char = text[charIndex];
          const glyphInfo = font.getGlyphInfo(char);
          if (char === " " || charIndex > nonWhitespaceCharLength + firstNonWhitespaceCharIndex) {
            prevGlyphId = glyphInfo.id;
            const xPosition = x2 + getGlyphOffsetX(font, fontSize, glyphInfo, prevGlyphId);
            if (typeof glyphs[glyphIndex] === "number") {
              glyphs[glyphIndex] = x2;
            } else {
              glyphs.splice(glyphIndex, 0, xPosition);
            }
            x2 += offsetPerWhitespace + getOffsetToNextGlyph(fontSize, glyphInfo, letterSpacing);
            continue;
          }
          let glyphOrNumber = glyphs[glyphIndex];
          while (glyphIndex < glyphs.length && typeof glyphOrNumber == "number") {
            glyphs.splice(glyphIndex, 1);
            glyphOrNumber = glyphs[glyphIndex];
          }
          let glyph = glyphOrNumber;
          if (glyph == null) {
            glyphs[glyphIndex] = glyph = new InstancedGlyph(this.group, this.matrix.peek(), this.color.peek(), this.opacity.peek(), (_a = this.parentClippingRect) == null ? void 0 : _a.peek());
          }
          glyph.updateGlyphAndTransformation(glyphInfo, x2 + getGlyphOffsetX(font, fontSize, glyphInfo, prevGlyphId), -(y3 + getGlyphOffsetY(fontSize, lineHeight, glyphInfo)), fontSize, pixelSize);
          glyph.show();
          prevGlyphId = glyphInfo.id;
          x2 += getOffsetToNextGlyph(fontSize, glyphInfo, letterSpacing);
        }
        y3 += getOffsetToNextLine(lineHeight, fontSize);
        const glyphsLength = glyphs.length;
        const newGlyphsLength = charLength;
        for (let ii2 = newGlyphsLength; ii2 < glyphsLength; ii2++) {
          const glyph = glyphs[ii2];
          if (typeof glyph === "number") {
            continue;
          }
          glyph.hide();
        }
        glyphs.length = newGlyphsLength;
      }
      traverseGlyphs(this.glyphLines, (glyph) => glyph.hide(), linesLength);
      this.glyphLines.length = linesLength;
      this.lastLayout = layout;
      this.updateSelectionBoxes(layout, (_b = this.selectionRange) == null ? void 0 : _b.peek(), this.verticalAlign.value, this.textAlign.value);
    }));
  }
  hide() {
    const unsubscribeListLength = this.unsubscribeShowList.length;
    if (unsubscribeListLength === 0) {
      return;
    }
    for (let i2 = 0; i2 < unsubscribeListLength; i2++) {
      this.unsubscribeShowList[i2]();
    }
    this.unsubscribeShowList.length = 0;
    traverseGlyphs(this.glyphLines, (glyph) => glyph.hide());
  }
  destroy() {
    this.hide();
    this.glyphLines.length = 0;
    const length = this.unsubscribeInitialList.length;
    for (let i2 = 0; i2 < length; i2++) {
      this.unsubscribeInitialList[i2]();
    }
  }
};
function getXOffset(availableWidth, nonWhitespaceWidth, textAlign) {
  switch (textAlign) {
    case "right":
      return availableWidth - nonWhitespaceWidth;
    case "center":
      return (availableWidth - nonWhitespaceWidth) / 2;
    default:
      return 0;
  }
}
function getYOffset(layout, verticalAlign) {
  switch (verticalAlign) {
    case "center":
    case "middle":
      return (layout.availableHeight - getGlyphLayoutHeight(layout.lines.length, layout)) / 2;
    case "bottom":
      return layout.availableHeight - getGlyphLayoutHeight(layout.lines.length, layout);
    default:
      return 0;
  }
}
function traverseGlyphs(glyphLines, fn3, offset = 0) {
  const glyphLinesLength = glyphLines.length;
  for (let i2 = offset; i2 < glyphLinesLength; i2++) {
    const glyphs = glyphLines[i2];
    const glyphsLength = glyphs.length;
    for (let ii2 = 0; ii2 < glyphsLength; ii2++) {
      const glyph = glyphs[ii2];
      if (typeof glyph == "number") {
        continue;
      }
      fn3(glyph);
    }
  }
}

// node_modules/@pmndrs/uikit/dist/components/text.js
function createText(parentContext, textSignal, fontFamilies, style, properties, defaultProperties, object) {
  const hoveredSignal = d([]);
  const activeSignal = d([]);
  const initializers = [];
  setupCursorCleanup(hoveredSignal, initializers);
  const mergedProperties = computedMergedProperties(style, properties, defaultProperties, {
    ...darkPropertyTransformers,
    ...createResponsivePropertyTransformers(parentContext.root.size),
    ...createHoverPropertyTransformers(hoveredSignal),
    ...createActivePropertyTransfomers(activeSignal)
  });
  const nodeSignal = d(void 0);
  const flexState = createFlexNodeState();
  createNode(nodeSignal, flexState, parentContext, mergedProperties, object, false, initializers);
  const transformMatrix = computedTransformMatrix(mergedProperties, flexState, parentContext.root.pixelSize);
  applyTransform(parentContext.root, object, transformMatrix, initializers);
  const globalMatrix = computedGlobalMatrix(parentContext.childrenMatrix, transformMatrix);
  const isClipped = computedIsClipped(parentContext.clippingRect, globalMatrix, flexState.size, parentContext.root.pixelSize);
  const isVisible = computedIsVisible(flexState, isClipped, mergedProperties);
  const groupDeps = computedPanelGroupDependencies(mergedProperties);
  const backgroundOrderInfo = computedOrderInfo(mergedProperties, ElementType.Panel, groupDeps, parentContext.orderInfo);
  initializers.push((subscriptions) => createInstancedPanel(mergedProperties, backgroundOrderInfo, groupDeps, parentContext.root.panelGroupManager, globalMatrix, flexState.size, void 0, flexState.borderInset, parentContext.clippingRect, isVisible, getDefaultPanelMaterialConfig(), subscriptions));
  const fontSignal = computedFont(mergedProperties, fontFamilies, parentContext.root.renderer, initializers);
  const orderInfo = computedOrderInfo(void 0, ElementType.Text, computedGylphGroupDependencies(fontSignal), backgroundOrderInfo);
  const customLayouting = createInstancedText(mergedProperties, textSignal, globalMatrix, nodeSignal, flexState, isVisible, parentContext.clippingRect, orderInfo, fontSignal, parentContext.root.gylphGroupManager, void 0, void 0, void 0, void 0, initializers, "break-word");
  initializers.push(() => E(() => {
    var _a;
    return (_a = nodeSignal.value) == null ? void 0 : _a.setCustomLayouting(customLayouting.value);
  }));
  setupLayoutListeners(style, properties, flexState.size, initializers);
  setupClippedListeners(style, properties, isClipped, initializers);
  return Object.assign(flexState, {
    isClipped,
    mergedProperties,
    interactionPanel: createInteractionPanel(backgroundOrderInfo, parentContext.root, parentContext.clippingRect, flexState.size, initializers),
    handlers: computedHandlers(style, properties, defaultProperties, hoveredSignal, activeSignal),
    initializers
  });
}

// node_modules/three/examples/jsm/loaders/SVGLoader.js
var COLOR_SPACE_SVG = SRGBColorSpace;
var SVGLoader = class _SVGLoader extends Loader {
  constructor(manager) {
    super(manager);
    this.defaultDPI = 90;
    this.defaultUnit = "px";
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader3 = new FileLoader(scope.manager);
    loader3.setPath(scope.path);
    loader3.setRequestHeader(scope.requestHeader);
    loader3.setWithCredentials(scope.withCredentials);
    loader3.load(url, function(text) {
      try {
        onLoad(scope.parse(text));
      } catch (e2) {
        if (onError) {
          onError(e2);
        } else {
          console.error(e2);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(text) {
    const scope = this;
    function parseNode(node, style) {
      if (node.nodeType !== 1)
        return;
      const transform = getNodeTransform(node);
      let isDefsNode = false;
      let path = null;
      switch (node.nodeName) {
        case "svg":
          style = parseStyle(node, style);
          break;
        case "style":
          parseCSSStylesheet(node);
          break;
        case "g":
          style = parseStyle(node, style);
          break;
        case "path":
          style = parseStyle(node, style);
          if (node.hasAttribute("d"))
            path = parsePathNode(node);
          break;
        case "rect":
          style = parseStyle(node, style);
          path = parseRectNode(node);
          break;
        case "polygon":
          style = parseStyle(node, style);
          path = parsePolygonNode(node);
          break;
        case "polyline":
          style = parseStyle(node, style);
          path = parsePolylineNode(node);
          break;
        case "circle":
          style = parseStyle(node, style);
          path = parseCircleNode(node);
          break;
        case "ellipse":
          style = parseStyle(node, style);
          path = parseEllipseNode(node);
          break;
        case "line":
          style = parseStyle(node, style);
          path = parseLineNode(node);
          break;
        case "defs":
          isDefsNode = true;
          break;
        case "use":
          style = parseStyle(node, style);
          const href = node.getAttributeNS("http://www.w3.org/1999/xlink", "href") || "";
          const usedNodeId = href.substring(1);
          const usedNode = node.viewportElement.getElementById(usedNodeId);
          if (usedNode) {
            parseNode(usedNode, style);
          } else {
            console.warn("SVGLoader: 'use node' references non-existent node id: " + usedNodeId);
          }
          break;
        default:
      }
      if (path) {
        if (style.fill !== void 0 && style.fill !== "none") {
          path.color.setStyle(style.fill, COLOR_SPACE_SVG);
        }
        transformPath(path, currentTransform);
        paths.push(path);
        path.userData = { node, style };
      }
      const childNodes = node.childNodes;
      for (let i2 = 0; i2 < childNodes.length; i2++) {
        const node2 = childNodes[i2];
        if (isDefsNode && node2.nodeName !== "style" && node2.nodeName !== "defs") {
          continue;
        }
        parseNode(node2, style);
      }
      if (transform) {
        transformStack.pop();
        if (transformStack.length > 0) {
          currentTransform.copy(transformStack[transformStack.length - 1]);
        } else {
          currentTransform.identity();
        }
      }
    }
    function parsePathNode(node) {
      const path = new ShapePath();
      const point = new Vector2();
      const control = new Vector2();
      const firstPoint = new Vector2();
      let isFirstPoint = true;
      let doSetFirstPoint = false;
      const d2 = node.getAttribute("d");
      if (d2 === "" || d2 === "none")
        return null;
      const commands = d2.match(/[a-df-z][^a-df-z]*/ig);
      for (let i2 = 0, l2 = commands.length; i2 < l2; i2++) {
        const command = commands[i2];
        const type = command.charAt(0);
        const data2 = command.slice(1).trim();
        if (isFirstPoint === true) {
          doSetFirstPoint = true;
          isFirstPoint = false;
        }
        let numbers;
        switch (type) {
          case "M":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2 += 2) {
              point.x = numbers[j2 + 0];
              point.y = numbers[j2 + 1];
              control.x = point.x;
              control.y = point.y;
              if (j2 === 0) {
                path.moveTo(point.x, point.y);
              } else {
                path.lineTo(point.x, point.y);
              }
              if (j2 === 0)
                firstPoint.copy(point);
            }
            break;
          case "H":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2++) {
              point.x = numbers[j2];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "V":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2++) {
              point.y = numbers[j2];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "L":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2 += 2) {
              point.x = numbers[j2 + 0];
              point.y = numbers[j2 + 1];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "C":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2 += 6) {
              path.bezierCurveTo(
                numbers[j2 + 0],
                numbers[j2 + 1],
                numbers[j2 + 2],
                numbers[j2 + 3],
                numbers[j2 + 4],
                numbers[j2 + 5]
              );
              control.x = numbers[j2 + 2];
              control.y = numbers[j2 + 3];
              point.x = numbers[j2 + 4];
              point.y = numbers[j2 + 5];
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "S":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2 += 4) {
              path.bezierCurveTo(
                getReflection(point.x, control.x),
                getReflection(point.y, control.y),
                numbers[j2 + 0],
                numbers[j2 + 1],
                numbers[j2 + 2],
                numbers[j2 + 3]
              );
              control.x = numbers[j2 + 0];
              control.y = numbers[j2 + 1];
              point.x = numbers[j2 + 2];
              point.y = numbers[j2 + 3];
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "Q":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2 += 4) {
              path.quadraticCurveTo(
                numbers[j2 + 0],
                numbers[j2 + 1],
                numbers[j2 + 2],
                numbers[j2 + 3]
              );
              control.x = numbers[j2 + 0];
              control.y = numbers[j2 + 1];
              point.x = numbers[j2 + 2];
              point.y = numbers[j2 + 3];
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "T":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2 += 2) {
              const rx2 = getReflection(point.x, control.x);
              const ry = getReflection(point.y, control.y);
              path.quadraticCurveTo(
                rx2,
                ry,
                numbers[j2 + 0],
                numbers[j2 + 1]
              );
              control.x = rx2;
              control.y = ry;
              point.x = numbers[j2 + 0];
              point.y = numbers[j2 + 1];
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "A":
            numbers = parseFloats(data2, [3, 4], 7);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2 += 7) {
              if (numbers[j2 + 5] == point.x && numbers[j2 + 6] == point.y)
                continue;
              const start = point.clone();
              point.x = numbers[j2 + 5];
              point.y = numbers[j2 + 6];
              control.x = point.x;
              control.y = point.y;
              parseArcCommand(
                path,
                numbers[j2],
                numbers[j2 + 1],
                numbers[j2 + 2],
                numbers[j2 + 3],
                numbers[j2 + 4],
                start,
                point
              );
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "m":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2 += 2) {
              point.x += numbers[j2 + 0];
              point.y += numbers[j2 + 1];
              control.x = point.x;
              control.y = point.y;
              if (j2 === 0) {
                path.moveTo(point.x, point.y);
              } else {
                path.lineTo(point.x, point.y);
              }
              if (j2 === 0)
                firstPoint.copy(point);
            }
            break;
          case "h":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2++) {
              point.x += numbers[j2];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "v":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2++) {
              point.y += numbers[j2];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "l":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2 += 2) {
              point.x += numbers[j2 + 0];
              point.y += numbers[j2 + 1];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "c":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2 += 6) {
              path.bezierCurveTo(
                point.x + numbers[j2 + 0],
                point.y + numbers[j2 + 1],
                point.x + numbers[j2 + 2],
                point.y + numbers[j2 + 3],
                point.x + numbers[j2 + 4],
                point.y + numbers[j2 + 5]
              );
              control.x = point.x + numbers[j2 + 2];
              control.y = point.y + numbers[j2 + 3];
              point.x += numbers[j2 + 4];
              point.y += numbers[j2 + 5];
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "s":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2 += 4) {
              path.bezierCurveTo(
                getReflection(point.x, control.x),
                getReflection(point.y, control.y),
                point.x + numbers[j2 + 0],
                point.y + numbers[j2 + 1],
                point.x + numbers[j2 + 2],
                point.y + numbers[j2 + 3]
              );
              control.x = point.x + numbers[j2 + 0];
              control.y = point.y + numbers[j2 + 1];
              point.x += numbers[j2 + 2];
              point.y += numbers[j2 + 3];
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "q":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2 += 4) {
              path.quadraticCurveTo(
                point.x + numbers[j2 + 0],
                point.y + numbers[j2 + 1],
                point.x + numbers[j2 + 2],
                point.y + numbers[j2 + 3]
              );
              control.x = point.x + numbers[j2 + 0];
              control.y = point.y + numbers[j2 + 1];
              point.x += numbers[j2 + 2];
              point.y += numbers[j2 + 3];
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "t":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2 += 2) {
              const rx2 = getReflection(point.x, control.x);
              const ry = getReflection(point.y, control.y);
              path.quadraticCurveTo(
                rx2,
                ry,
                point.x + numbers[j2 + 0],
                point.y + numbers[j2 + 1]
              );
              control.x = rx2;
              control.y = ry;
              point.x = point.x + numbers[j2 + 0];
              point.y = point.y + numbers[j2 + 1];
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "a":
            numbers = parseFloats(data2, [3, 4], 7);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2 += 7) {
              if (numbers[j2 + 5] == 0 && numbers[j2 + 6] == 0)
                continue;
              const start = point.clone();
              point.x += numbers[j2 + 5];
              point.y += numbers[j2 + 6];
              control.x = point.x;
              control.y = point.y;
              parseArcCommand(
                path,
                numbers[j2],
                numbers[j2 + 1],
                numbers[j2 + 2],
                numbers[j2 + 3],
                numbers[j2 + 4],
                start,
                point
              );
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "Z":
          case "z":
            path.currentPath.autoClose = true;
            if (path.currentPath.curves.length > 0) {
              point.copy(firstPoint);
              path.currentPath.currentPoint.copy(point);
              isFirstPoint = true;
            }
            break;
          default:
            console.warn(command);
        }
        doSetFirstPoint = false;
      }
      return path;
    }
    function parseCSSStylesheet(node) {
      if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length)
        return;
      for (let i2 = 0; i2 < node.sheet.cssRules.length; i2++) {
        const stylesheet = node.sheet.cssRules[i2];
        if (stylesheet.type !== 1)
          continue;
        const selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map((i3) => i3.trim());
        for (let j2 = 0; j2 < selectorList.length; j2++) {
          const definitions = Object.fromEntries(
            Object.entries(stylesheet.style).filter(([, v2]) => v2 !== "")
          );
          stylesheets[selectorList[j2]] = Object.assign(
            stylesheets[selectorList[j2]] || {},
            definitions
          );
        }
      }
    }
    function parseArcCommand(path, rx2, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {
      if (rx2 == 0 || ry == 0) {
        path.lineTo(end.x, end.y);
        return;
      }
      x_axis_rotation = x_axis_rotation * Math.PI / 180;
      rx2 = Math.abs(rx2);
      ry = Math.abs(ry);
      const dx2 = (start.x - end.x) / 2;
      const dy2 = (start.y - end.y) / 2;
      const x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;
      const y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2;
      let rxs = rx2 * rx2;
      let rys = ry * ry;
      const x1ps = x1p * x1p;
      const y1ps = y1p * y1p;
      const cr3 = x1ps / rxs + y1ps / rys;
      if (cr3 > 1) {
        const s2 = Math.sqrt(cr3);
        rx2 = s2 * rx2;
        ry = s2 * ry;
        rxs = rx2 * rx2;
        rys = ry * ry;
      }
      const dq = rxs * y1ps + rys * x1ps;
      const pq = (rxs * rys - dq) / dq;
      let q2 = Math.sqrt(Math.max(0, pq));
      if (large_arc_flag === sweep_flag)
        q2 = -q2;
      const cxp = q2 * rx2 * y1p / ry;
      const cyp = -q2 * ry * x1p / rx2;
      const cx2 = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;
      const cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2;
      const theta = svgAngle(1, 0, (x1p - cxp) / rx2, (y1p - cyp) / ry);
      const delta = svgAngle((x1p - cxp) / rx2, (y1p - cyp) / ry, (-x1p - cxp) / rx2, (-y1p - cyp) / ry) % (Math.PI * 2);
      path.currentPath.absellipse(cx2, cy, rx2, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);
    }
    function svgAngle(ux2, uy, vx2, vy) {
      const dot = ux2 * vx2 + uy * vy;
      const len = Math.sqrt(ux2 * ux2 + uy * uy) * Math.sqrt(vx2 * vx2 + vy * vy);
      let ang = Math.acos(Math.max(-1, Math.min(1, dot / len)));
      if (ux2 * vy - uy * vx2 < 0)
        ang = -ang;
      return ang;
    }
    function parseRectNode(node) {
      const x2 = parseFloatWithUnits(node.getAttribute("x") || 0);
      const y3 = parseFloatWithUnits(node.getAttribute("y") || 0);
      const rx2 = parseFloatWithUnits(node.getAttribute("rx") || node.getAttribute("ry") || 0);
      const ry = parseFloatWithUnits(node.getAttribute("ry") || node.getAttribute("rx") || 0);
      const w2 = parseFloatWithUnits(node.getAttribute("width"));
      const h2 = parseFloatWithUnits(node.getAttribute("height"));
      const bci = 1 - 0.551915024494;
      const path = new ShapePath();
      path.moveTo(x2 + rx2, y3);
      path.lineTo(x2 + w2 - rx2, y3);
      if (rx2 !== 0 || ry !== 0) {
        path.bezierCurveTo(
          x2 + w2 - rx2 * bci,
          y3,
          x2 + w2,
          y3 + ry * bci,
          x2 + w2,
          y3 + ry
        );
      }
      path.lineTo(x2 + w2, y3 + h2 - ry);
      if (rx2 !== 0 || ry !== 0) {
        path.bezierCurveTo(
          x2 + w2,
          y3 + h2 - ry * bci,
          x2 + w2 - rx2 * bci,
          y3 + h2,
          x2 + w2 - rx2,
          y3 + h2
        );
      }
      path.lineTo(x2 + rx2, y3 + h2);
      if (rx2 !== 0 || ry !== 0) {
        path.bezierCurveTo(
          x2 + rx2 * bci,
          y3 + h2,
          x2,
          y3 + h2 - ry * bci,
          x2,
          y3 + h2 - ry
        );
      }
      path.lineTo(x2, y3 + ry);
      if (rx2 !== 0 || ry !== 0) {
        path.bezierCurveTo(x2, y3 + ry * bci, x2 + rx2 * bci, y3, x2 + rx2, y3);
      }
      return path;
    }
    function parsePolygonNode(node) {
      function iterator(match, a2, b3) {
        const x2 = parseFloatWithUnits(a2);
        const y3 = parseFloatWithUnits(b3);
        if (index === 0) {
          path.moveTo(x2, y3);
        } else {
          path.lineTo(x2, y3);
        }
        index++;
      }
      const regex = /([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g;
      const path = new ShapePath();
      let index = 0;
      node.getAttribute("points").replace(regex, iterator);
      path.currentPath.autoClose = true;
      return path;
    }
    function parsePolylineNode(node) {
      function iterator(match, a2, b3) {
        const x2 = parseFloatWithUnits(a2);
        const y3 = parseFloatWithUnits(b3);
        if (index === 0) {
          path.moveTo(x2, y3);
        } else {
          path.lineTo(x2, y3);
        }
        index++;
      }
      const regex = /([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g;
      const path = new ShapePath();
      let index = 0;
      node.getAttribute("points").replace(regex, iterator);
      path.currentPath.autoClose = false;
      return path;
    }
    function parseCircleNode(node) {
      const x2 = parseFloatWithUnits(node.getAttribute("cx") || 0);
      const y3 = parseFloatWithUnits(node.getAttribute("cy") || 0);
      const r2 = parseFloatWithUnits(node.getAttribute("r") || 0);
      const subpath = new Path();
      subpath.absarc(x2, y3, r2, 0, Math.PI * 2);
      const path = new ShapePath();
      path.subPaths.push(subpath);
      return path;
    }
    function parseEllipseNode(node) {
      const x2 = parseFloatWithUnits(node.getAttribute("cx") || 0);
      const y3 = parseFloatWithUnits(node.getAttribute("cy") || 0);
      const rx2 = parseFloatWithUnits(node.getAttribute("rx") || 0);
      const ry = parseFloatWithUnits(node.getAttribute("ry") || 0);
      const subpath = new Path();
      subpath.absellipse(x2, y3, rx2, ry, 0, Math.PI * 2);
      const path = new ShapePath();
      path.subPaths.push(subpath);
      return path;
    }
    function parseLineNode(node) {
      const x1 = parseFloatWithUnits(node.getAttribute("x1") || 0);
      const y1 = parseFloatWithUnits(node.getAttribute("y1") || 0);
      const x2 = parseFloatWithUnits(node.getAttribute("x2") || 0);
      const y22 = parseFloatWithUnits(node.getAttribute("y2") || 0);
      const path = new ShapePath();
      path.moveTo(x1, y1);
      path.lineTo(x2, y22);
      path.currentPath.autoClose = false;
      return path;
    }
    function parseStyle(node, style) {
      style = Object.assign({}, style);
      let stylesheetStyles = {};
      if (node.hasAttribute("class")) {
        const classSelectors = node.getAttribute("class").split(/\s/).filter(Boolean).map((i2) => i2.trim());
        for (let i2 = 0; i2 < classSelectors.length; i2++) {
          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets["." + classSelectors[i2]]);
        }
      }
      if (node.hasAttribute("id")) {
        stylesheetStyles = Object.assign(stylesheetStyles, stylesheets["#" + node.getAttribute("id")]);
      }
      function addStyle(svgName, jsName, adjustFunction) {
        if (adjustFunction === void 0)
          adjustFunction = function copy2(v2) {
            if (v2.startsWith("url"))
              console.warn("SVGLoader: url access in attributes is not implemented.");
            return v2;
          };
        if (node.hasAttribute(svgName))
          style[jsName] = adjustFunction(node.getAttribute(svgName));
        if (stylesheetStyles[svgName])
          style[jsName] = adjustFunction(stylesheetStyles[svgName]);
        if (node.style && node.style[svgName] !== "")
          style[jsName] = adjustFunction(node.style[svgName]);
      }
      function clamp2(v2) {
        return Math.max(0, Math.min(1, parseFloatWithUnits(v2)));
      }
      function positive(v2) {
        return Math.max(0, parseFloatWithUnits(v2));
      }
      addStyle("fill", "fill");
      addStyle("fill-opacity", "fillOpacity", clamp2);
      addStyle("fill-rule", "fillRule");
      addStyle("opacity", "opacity", clamp2);
      addStyle("stroke", "stroke");
      addStyle("stroke-opacity", "strokeOpacity", clamp2);
      addStyle("stroke-width", "strokeWidth", positive);
      addStyle("stroke-linejoin", "strokeLineJoin");
      addStyle("stroke-linecap", "strokeLineCap");
      addStyle("stroke-miterlimit", "strokeMiterLimit", positive);
      addStyle("visibility", "visibility");
      return style;
    }
    function getReflection(a2, b3) {
      return a2 - (b3 - a2);
    }
    function parseFloats(input, flags, stride) {
      if (typeof input !== "string") {
        throw new TypeError("Invalid input: " + typeof input);
      }
      const RE = {
        SEPARATOR: /[ \t\r\n\,.\-+]/,
        WHITESPACE: /[ \t\r\n]/,
        DIGIT: /[\d]/,
        SIGN: /[-+]/,
        POINT: /\./,
        COMMA: /,/,
        EXP: /e/i,
        FLAGS: /[01]/
      };
      const SEP = 0;
      const INT = 1;
      const FLOAT = 2;
      const EXP = 3;
      let state = SEP;
      let seenComma = true;
      let number = "", exponent = "";
      const result = [];
      function throwSyntaxError(current2, i2, partial) {
        const error = new SyntaxError('Unexpected character "' + current2 + '" at index ' + i2 + ".");
        error.partial = partial;
        throw error;
      }
      function newNumber() {
        if (number !== "") {
          if (exponent === "")
            result.push(Number(number));
          else
            result.push(Number(number) * Math.pow(10, Number(exponent)));
        }
        number = "";
        exponent = "";
      }
      let current;
      const length = input.length;
      for (let i2 = 0; i2 < length; i2++) {
        current = input[i2];
        if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {
          state = INT;
          number = current;
          newNumber();
          continue;
        }
        if (state === SEP) {
          if (RE.WHITESPACE.test(current)) {
            continue;
          }
          if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {
            state = INT;
            number = current;
            continue;
          }
          if (RE.POINT.test(current)) {
            state = FLOAT;
            number = current;
            continue;
          }
          if (RE.COMMA.test(current)) {
            if (seenComma) {
              throwSyntaxError(current, i2, result);
            }
            seenComma = true;
          }
        }
        if (state === INT) {
          if (RE.DIGIT.test(current)) {
            number += current;
            continue;
          }
          if (RE.POINT.test(current)) {
            number += current;
            state = FLOAT;
            continue;
          }
          if (RE.EXP.test(current)) {
            state = EXP;
            continue;
          }
          if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {
            throwSyntaxError(current, i2, result);
          }
        }
        if (state === FLOAT) {
          if (RE.DIGIT.test(current)) {
            number += current;
            continue;
          }
          if (RE.EXP.test(current)) {
            state = EXP;
            continue;
          }
          if (RE.POINT.test(current) && number[number.length - 1] === ".") {
            throwSyntaxError(current, i2, result);
          }
        }
        if (state === EXP) {
          if (RE.DIGIT.test(current)) {
            exponent += current;
            continue;
          }
          if (RE.SIGN.test(current)) {
            if (exponent === "") {
              exponent += current;
              continue;
            }
            if (exponent.length === 1 && RE.SIGN.test(exponent)) {
              throwSyntaxError(current, i2, result);
            }
          }
        }
        if (RE.WHITESPACE.test(current)) {
          newNumber();
          state = SEP;
          seenComma = false;
        } else if (RE.COMMA.test(current)) {
          newNumber();
          state = SEP;
          seenComma = true;
        } else if (RE.SIGN.test(current)) {
          newNumber();
          state = INT;
          number = current;
        } else if (RE.POINT.test(current)) {
          newNumber();
          state = FLOAT;
          number = current;
        } else {
          throwSyntaxError(current, i2, result);
        }
      }
      newNumber();
      return result;
    }
    const units = ["mm", "cm", "in", "pt", "pc", "px"];
    const unitConversion = {
      "mm": {
        "mm": 1,
        "cm": 0.1,
        "in": 1 / 25.4,
        "pt": 72 / 25.4,
        "pc": 6 / 25.4,
        "px": -1
      },
      "cm": {
        "mm": 10,
        "cm": 1,
        "in": 1 / 2.54,
        "pt": 72 / 2.54,
        "pc": 6 / 2.54,
        "px": -1
      },
      "in": {
        "mm": 25.4,
        "cm": 2.54,
        "in": 1,
        "pt": 72,
        "pc": 6,
        "px": -1
      },
      "pt": {
        "mm": 25.4 / 72,
        "cm": 2.54 / 72,
        "in": 1 / 72,
        "pt": 1,
        "pc": 6 / 72,
        "px": -1
      },
      "pc": {
        "mm": 25.4 / 6,
        "cm": 2.54 / 6,
        "in": 1 / 6,
        "pt": 72 / 6,
        "pc": 1,
        "px": -1
      },
      "px": {
        "px": 1
      }
    };
    function parseFloatWithUnits(string) {
      let theUnit = "px";
      if (typeof string === "string" || string instanceof String) {
        for (let i2 = 0, n2 = units.length; i2 < n2; i2++) {
          const u2 = units[i2];
          if (string.endsWith(u2)) {
            theUnit = u2;
            string = string.substring(0, string.length - u2.length);
            break;
          }
        }
      }
      let scale = void 0;
      if (theUnit === "px" && scope.defaultUnit !== "px") {
        scale = unitConversion["in"][scope.defaultUnit] / scope.defaultDPI;
      } else {
        scale = unitConversion[theUnit][scope.defaultUnit];
        if (scale < 0) {
          scale = unitConversion[theUnit]["in"] * scope.defaultDPI;
        }
      }
      return scale * parseFloat(string);
    }
    function getNodeTransform(node) {
      if (!(node.hasAttribute("transform") || node.nodeName === "use" && (node.hasAttribute("x") || node.hasAttribute("y")))) {
        return null;
      }
      const transform = parseNodeTransform(node);
      if (transformStack.length > 0) {
        transform.premultiply(transformStack[transformStack.length - 1]);
      }
      currentTransform.copy(transform);
      transformStack.push(transform);
      return transform;
    }
    function parseNodeTransform(node) {
      const transform = new Matrix3();
      const currentTransform2 = tempTransform0;
      if (node.nodeName === "use" && (node.hasAttribute("x") || node.hasAttribute("y"))) {
        const tx2 = parseFloatWithUnits(node.getAttribute("x"));
        const ty = parseFloatWithUnits(node.getAttribute("y"));
        transform.translate(tx2, ty);
      }
      if (node.hasAttribute("transform")) {
        const transformsTexts = node.getAttribute("transform").split(")");
        for (let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {
          const transformText = transformsTexts[tIndex].trim();
          if (transformText === "")
            continue;
          const openParPos = transformText.indexOf("(");
          const closeParPos = transformText.length;
          if (openParPos > 0 && openParPos < closeParPos) {
            const transformType = transformText.slice(0, openParPos);
            const array = parseFloats(transformText.slice(openParPos + 1));
            currentTransform2.identity();
            switch (transformType) {
              case "translate":
                if (array.length >= 1) {
                  const tx2 = array[0];
                  let ty = 0;
                  if (array.length >= 2) {
                    ty = array[1];
                  }
                  currentTransform2.translate(tx2, ty);
                }
                break;
              case "rotate":
                if (array.length >= 1) {
                  let angle = 0;
                  let cx2 = 0;
                  let cy = 0;
                  angle = array[0] * Math.PI / 180;
                  if (array.length >= 3) {
                    cx2 = array[1];
                    cy = array[2];
                  }
                  tempTransform1.makeTranslation(-cx2, -cy);
                  tempTransform2.makeRotation(angle);
                  tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);
                  tempTransform1.makeTranslation(cx2, cy);
                  currentTransform2.multiplyMatrices(tempTransform1, tempTransform3);
                }
                break;
              case "scale":
                if (array.length >= 1) {
                  const scaleX = array[0];
                  let scaleY = scaleX;
                  if (array.length >= 2) {
                    scaleY = array[1];
                  }
                  currentTransform2.scale(scaleX, scaleY);
                }
                break;
              case "skewX":
                if (array.length === 1) {
                  currentTransform2.set(
                    1,
                    Math.tan(array[0] * Math.PI / 180),
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1
                  );
                }
                break;
              case "skewY":
                if (array.length === 1) {
                  currentTransform2.set(
                    1,
                    0,
                    0,
                    Math.tan(array[0] * Math.PI / 180),
                    1,
                    0,
                    0,
                    0,
                    1
                  );
                }
                break;
              case "matrix":
                if (array.length === 6) {
                  currentTransform2.set(
                    array[0],
                    array[2],
                    array[4],
                    array[1],
                    array[3],
                    array[5],
                    0,
                    0,
                    1
                  );
                }
                break;
            }
          }
          transform.premultiply(currentTransform2);
        }
      }
      return transform;
    }
    function transformPath(path, m) {
      function transfVec2(v2) {
        tempV3.set(v2.x, v2.y, 1).applyMatrix3(m);
        v2.set(tempV3.x, tempV3.y);
      }
      function transfEllipseGeneric(curve) {
        const a2 = curve.xRadius;
        const b3 = curve.yRadius;
        const cosTheta = Math.cos(curve.aRotation);
        const sinTheta = Math.sin(curve.aRotation);
        const v1 = new Vector3(a2 * cosTheta, a2 * sinTheta, 0);
        const v2 = new Vector3(-b3 * sinTheta, b3 * cosTheta, 0);
        const f1 = v1.applyMatrix3(m);
        const f2 = v2.applyMatrix3(m);
        const mF = tempTransform0.set(
          f1.x,
          f2.x,
          0,
          f1.y,
          f2.y,
          0,
          0,
          0,
          1
        );
        const mFInv = tempTransform1.copy(mF).invert();
        const mFInvT = tempTransform2.copy(mFInv).transpose();
        const mQ = mFInvT.multiply(mFInv);
        const mQe = mQ.elements;
        const ed = eigenDecomposition(mQe[0], mQe[1], mQe[4]);
        const rt1sqrt = Math.sqrt(ed.rt1);
        const rt2sqrt = Math.sqrt(ed.rt2);
        curve.xRadius = 1 / rt1sqrt;
        curve.yRadius = 1 / rt2sqrt;
        curve.aRotation = Math.atan2(ed.sn, ed.cs);
        const isFullEllipse = (curve.aEndAngle - curve.aStartAngle) % (2 * Math.PI) < Number.EPSILON;
        if (!isFullEllipse) {
          const mDsqrt = tempTransform1.set(
            rt1sqrt,
            0,
            0,
            0,
            rt2sqrt,
            0,
            0,
            0,
            1
          );
          const mRT = tempTransform2.set(
            ed.cs,
            ed.sn,
            0,
            -ed.sn,
            ed.cs,
            0,
            0,
            0,
            1
          );
          const mDRF = mDsqrt.multiply(mRT).multiply(mF);
          const transformAngle = (phi) => {
            const { x: cosR, y: sinR } = new Vector3(Math.cos(phi), Math.sin(phi), 0).applyMatrix3(mDRF);
            return Math.atan2(sinR, cosR);
          };
          curve.aStartAngle = transformAngle(curve.aStartAngle);
          curve.aEndAngle = transformAngle(curve.aEndAngle);
          if (isTransformFlipped(m)) {
            curve.aClockwise = !curve.aClockwise;
          }
        }
      }
      function transfEllipseNoSkew(curve) {
        const sx2 = getTransformScaleX(m);
        const sy = getTransformScaleY(m);
        curve.xRadius *= sx2;
        curve.yRadius *= sy;
        const theta = sx2 > Number.EPSILON ? Math.atan2(m.elements[1], m.elements[0]) : Math.atan2(-m.elements[3], m.elements[4]);
        curve.aRotation += theta;
        if (isTransformFlipped(m)) {
          curve.aStartAngle *= -1;
          curve.aEndAngle *= -1;
          curve.aClockwise = !curve.aClockwise;
        }
      }
      const subPaths = path.subPaths;
      for (let i2 = 0, n2 = subPaths.length; i2 < n2; i2++) {
        const subPath = subPaths[i2];
        const curves = subPath.curves;
        for (let j2 = 0; j2 < curves.length; j2++) {
          const curve = curves[j2];
          if (curve.isLineCurve) {
            transfVec2(curve.v1);
            transfVec2(curve.v2);
          } else if (curve.isCubicBezierCurve) {
            transfVec2(curve.v0);
            transfVec2(curve.v1);
            transfVec2(curve.v2);
            transfVec2(curve.v3);
          } else if (curve.isQuadraticBezierCurve) {
            transfVec2(curve.v0);
            transfVec2(curve.v1);
            transfVec2(curve.v2);
          } else if (curve.isEllipseCurve) {
            tempV2.set(curve.aX, curve.aY);
            transfVec2(tempV2);
            curve.aX = tempV2.x;
            curve.aY = tempV2.y;
            if (isTransformSkewed(m)) {
              transfEllipseGeneric(curve);
            } else {
              transfEllipseNoSkew(curve);
            }
          }
        }
      }
    }
    function isTransformFlipped(m) {
      const te2 = m.elements;
      return te2[0] * te2[4] - te2[1] * te2[3] < 0;
    }
    function isTransformSkewed(m) {
      const te2 = m.elements;
      const basisDot = te2[0] * te2[3] + te2[1] * te2[4];
      if (basisDot === 0)
        return false;
      const sx2 = getTransformScaleX(m);
      const sy = getTransformScaleY(m);
      return Math.abs(basisDot / (sx2 * sy)) > Number.EPSILON;
    }
    function getTransformScaleX(m) {
      const te2 = m.elements;
      return Math.sqrt(te2[0] * te2[0] + te2[1] * te2[1]);
    }
    function getTransformScaleY(m) {
      const te2 = m.elements;
      return Math.sqrt(te2[3] * te2[3] + te2[4] * te2[4]);
    }
    function eigenDecomposition(A, B2, C) {
      let rt1, rt22, cs, sn2, t2;
      const sm = A + C;
      const df2 = A - C;
      const rt3 = Math.sqrt(df2 * df2 + 4 * B2 * B2);
      if (sm > 0) {
        rt1 = 0.5 * (sm + rt3);
        t2 = 1 / rt1;
        rt22 = A * t2 * C - B2 * t2 * B2;
      } else if (sm < 0) {
        rt22 = 0.5 * (sm - rt3);
      } else {
        rt1 = 0.5 * rt3;
        rt22 = -0.5 * rt3;
      }
      if (df2 > 0) {
        cs = df2 + rt3;
      } else {
        cs = df2 - rt3;
      }
      if (Math.abs(cs) > 2 * Math.abs(B2)) {
        t2 = -2 * B2 / cs;
        sn2 = 1 / Math.sqrt(1 + t2 * t2);
        cs = t2 * sn2;
      } else if (Math.abs(B2) === 0) {
        cs = 1;
        sn2 = 0;
      } else {
        t2 = -0.5 * cs / B2;
        cs = 1 / Math.sqrt(1 + t2 * t2);
        sn2 = t2 * cs;
      }
      if (df2 > 0) {
        t2 = cs;
        cs = -sn2;
        sn2 = t2;
      }
      return { rt1, rt2: rt22, cs, sn: sn2 };
    }
    const paths = [];
    const stylesheets = {};
    const transformStack = [];
    const tempTransform0 = new Matrix3();
    const tempTransform1 = new Matrix3();
    const tempTransform2 = new Matrix3();
    const tempTransform3 = new Matrix3();
    const tempV2 = new Vector2();
    const tempV3 = new Vector3();
    const currentTransform = new Matrix3();
    const xml = new DOMParser().parseFromString(text, "image/svg+xml");
    parseNode(xml.documentElement, {
      fill: "#000",
      fillOpacity: 1,
      strokeOpacity: 1,
      strokeWidth: 1,
      strokeLineJoin: "miter",
      strokeLineCap: "butt",
      strokeMiterLimit: 4
    });
    const data = { paths, xml: xml.documentElement };
    return data;
  }
  static createShapes(shapePath) {
    const BIGNUMBER = 999999999;
    const IntersectionLocationType = {
      ORIGIN: 0,
      DESTINATION: 1,
      BETWEEN: 2,
      LEFT: 3,
      RIGHT: 4,
      BEHIND: 5,
      BEYOND: 6
    };
    const classifyResult = {
      loc: IntersectionLocationType.ORIGIN,
      t: 0
    };
    function findEdgeIntersection(a0, a1, b0, b1) {
      const x1 = a0.x;
      const x2 = a1.x;
      const x3 = b0.x;
      const x4 = b1.x;
      const y1 = a0.y;
      const y22 = a1.y;
      const y3 = b0.y;
      const y4 = b1.y;
      const nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
      const nom2 = (x2 - x1) * (y1 - y3) - (y22 - y1) * (x1 - x3);
      const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y22 - y1);
      const t1 = nom1 / denom;
      const t2 = nom2 / denom;
      if (denom === 0 && nom1 !== 0 || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {
        return null;
      } else if (nom1 === 0 && denom === 0) {
        for (let i2 = 0; i2 < 2; i2++) {
          classifyPoint(i2 === 0 ? b0 : b1, a0, a1);
          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {
            const point = i2 === 0 ? b0 : b1;
            return { x: point.x, y: point.y, t: classifyResult.t };
          } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {
            const x5 = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10);
            const y5 = +(y1 + classifyResult.t * (y22 - y1)).toPrecision(10);
            return { x: x5, y: y5, t: classifyResult.t };
          }
        }
        return null;
      } else {
        for (let i2 = 0; i2 < 2; i2++) {
          classifyPoint(i2 === 0 ? b0 : b1, a0, a1);
          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {
            const point = i2 === 0 ? b0 : b1;
            return { x: point.x, y: point.y, t: classifyResult.t };
          }
        }
        const x5 = +(x1 + t1 * (x2 - x1)).toPrecision(10);
        const y5 = +(y1 + t1 * (y22 - y1)).toPrecision(10);
        return { x: x5, y: y5, t: t1 };
      }
    }
    function classifyPoint(p2, edgeStart, edgeEnd) {
      const ax2 = edgeEnd.x - edgeStart.x;
      const ay = edgeEnd.y - edgeStart.y;
      const bx2 = p2.x - edgeStart.x;
      const by = p2.y - edgeStart.y;
      const sa2 = ax2 * by - bx2 * ay;
      if (p2.x === edgeStart.x && p2.y === edgeStart.y) {
        classifyResult.loc = IntersectionLocationType.ORIGIN;
        classifyResult.t = 0;
        return;
      }
      if (p2.x === edgeEnd.x && p2.y === edgeEnd.y) {
        classifyResult.loc = IntersectionLocationType.DESTINATION;
        classifyResult.t = 1;
        return;
      }
      if (sa2 < -Number.EPSILON) {
        classifyResult.loc = IntersectionLocationType.LEFT;
        return;
      }
      if (sa2 > Number.EPSILON) {
        classifyResult.loc = IntersectionLocationType.RIGHT;
        return;
      }
      if (ax2 * bx2 < 0 || ay * by < 0) {
        classifyResult.loc = IntersectionLocationType.BEHIND;
        return;
      }
      if (Math.sqrt(ax2 * ax2 + ay * ay) < Math.sqrt(bx2 * bx2 + by * by)) {
        classifyResult.loc = IntersectionLocationType.BEYOND;
        return;
      }
      let t2;
      if (ax2 !== 0) {
        t2 = bx2 / ax2;
      } else {
        t2 = by / ay;
      }
      classifyResult.loc = IntersectionLocationType.BETWEEN;
      classifyResult.t = t2;
    }
    function getIntersections(path1, path2) {
      const intersectionsRaw = [];
      const intersections = [];
      for (let index = 1; index < path1.length; index++) {
        const path1EdgeStart = path1[index - 1];
        const path1EdgeEnd = path1[index];
        for (let index2 = 1; index2 < path2.length; index2++) {
          const path2EdgeStart = path2[index2 - 1];
          const path2EdgeEnd = path2[index2];
          const intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd);
          if (intersection !== null && intersectionsRaw.find((i2) => i2.t <= intersection.t + Number.EPSILON && i2.t >= intersection.t - Number.EPSILON) === void 0) {
            intersectionsRaw.push(intersection);
            intersections.push(new Vector2(intersection.x, intersection.y));
          }
        }
      }
      return intersections;
    }
    function getScanlineIntersections(scanline, boundingBox, paths) {
      const center = new Vector2();
      boundingBox.getCenter(center);
      const allIntersections = [];
      paths.forEach((path) => {
        if (path.boundingBox.containsPoint(center)) {
          const intersections = getIntersections(scanline, path.points);
          intersections.forEach((p2) => {
            allIntersections.push({ identifier: path.identifier, isCW: path.isCW, point: p2 });
          });
        }
      });
      allIntersections.sort((i1, i2) => {
        return i1.point.x - i2.point.x;
      });
      return allIntersections;
    }
    function isHoleTo(simplePath, allPaths, scanlineMinX2, scanlineMaxX2, _fillRule) {
      if (_fillRule === null || _fillRule === void 0 || _fillRule === "") {
        _fillRule = "nonzero";
      }
      const centerBoundingBox = new Vector2();
      simplePath.boundingBox.getCenter(centerBoundingBox);
      const scanline = [new Vector2(scanlineMinX2, centerBoundingBox.y), new Vector2(scanlineMaxX2, centerBoundingBox.y)];
      const scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths);
      scanlineIntersections.sort((i1, i22) => {
        return i1.point.x - i22.point.x;
      });
      const baseIntersections = [];
      const otherIntersections = [];
      scanlineIntersections.forEach((i3) => {
        if (i3.identifier === simplePath.identifier) {
          baseIntersections.push(i3);
        } else {
          otherIntersections.push(i3);
        }
      });
      const firstXOfPath = baseIntersections[0].point.x;
      const stack = [];
      let i2 = 0;
      while (i2 < otherIntersections.length && otherIntersections[i2].point.x < firstXOfPath) {
        if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i2].identifier) {
          stack.pop();
        } else {
          stack.push(otherIntersections[i2].identifier);
        }
        i2++;
      }
      stack.push(simplePath.identifier);
      if (_fillRule === "evenodd") {
        const isHole = stack.length % 2 === 0 ? true : false;
        const isHoleFor = stack[stack.length - 2];
        return { identifier: simplePath.identifier, isHole, for: isHoleFor };
      } else if (_fillRule === "nonzero") {
        let isHole = true;
        let isHoleFor = null;
        let lastCWValue = null;
        for (let i3 = 0; i3 < stack.length; i3++) {
          const identifier = stack[i3];
          if (isHole) {
            lastCWValue = allPaths[identifier].isCW;
            isHole = false;
            isHoleFor = identifier;
          } else if (lastCWValue !== allPaths[identifier].isCW) {
            lastCWValue = allPaths[identifier].isCW;
            isHole = true;
          }
        }
        return { identifier: simplePath.identifier, isHole, for: isHoleFor };
      } else {
        console.warn('fill-rule: "' + _fillRule + '" is currently not implemented.');
      }
    }
    let scanlineMinX = BIGNUMBER;
    let scanlineMaxX = -BIGNUMBER;
    let simplePaths = shapePath.subPaths.map((p2) => {
      const points = p2.getPoints();
      let maxY = -BIGNUMBER;
      let minY = BIGNUMBER;
      let maxX = -BIGNUMBER;
      let minX = BIGNUMBER;
      for (let i2 = 0; i2 < points.length; i2++) {
        const p3 = points[i2];
        if (p3.y > maxY) {
          maxY = p3.y;
        }
        if (p3.y < minY) {
          minY = p3.y;
        }
        if (p3.x > maxX) {
          maxX = p3.x;
        }
        if (p3.x < minX) {
          minX = p3.x;
        }
      }
      if (scanlineMaxX <= maxX) {
        scanlineMaxX = maxX + 1;
      }
      if (scanlineMinX >= minX) {
        scanlineMinX = minX - 1;
      }
      return { curves: p2.curves, points, isCW: ShapeUtils.isClockWise(points), identifier: -1, boundingBox: new Box2(new Vector2(minX, minY), new Vector2(maxX, maxY)) };
    });
    simplePaths = simplePaths.filter((sp) => sp.points.length > 1);
    for (let identifier = 0; identifier < simplePaths.length; identifier++) {
      simplePaths[identifier].identifier = identifier;
    }
    const isAHole = simplePaths.map((p2) => isHoleTo(p2, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData ? shapePath.userData.style.fillRule : void 0));
    const shapesToReturn = [];
    simplePaths.forEach((p2) => {
      const amIAHole = isAHole[p2.identifier];
      if (!amIAHole.isHole) {
        const shape = new Shape();
        shape.curves = p2.curves;
        const holes = isAHole.filter((h2) => h2.isHole && h2.for === p2.identifier);
        holes.forEach((h2) => {
          const hole = simplePaths[h2.identifier];
          const path = new Path();
          path.curves = hole.curves;
          shape.holes.push(path);
        });
        shapesToReturn.push(shape);
      }
    });
    return shapesToReturn;
  }
  static getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {
    width = width !== void 0 ? width : 1;
    color = color !== void 0 ? color : "#000";
    lineJoin = lineJoin !== void 0 ? lineJoin : "miter";
    lineCap = lineCap !== void 0 ? lineCap : "butt";
    miterLimit = miterLimit !== void 0 ? miterLimit : 4;
    return {
      strokeColor: color,
      strokeWidth: width,
      strokeLineJoin: lineJoin,
      strokeLineCap: lineCap,
      strokeMiterLimit: miterLimit
    };
  }
  static pointsToStroke(points, style, arcDivisions, minDistance) {
    const vertices = [];
    const normals = [];
    const uvs = [];
    if (_SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {
      return null;
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    geometry.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    return geometry;
  }
  static pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {
    const tempV2_1 = new Vector2();
    const tempV2_2 = new Vector2();
    const tempV2_3 = new Vector2();
    const tempV2_4 = new Vector2();
    const tempV2_5 = new Vector2();
    const tempV2_6 = new Vector2();
    const tempV2_7 = new Vector2();
    const lastPointL = new Vector2();
    const lastPointR = new Vector2();
    const point0L = new Vector2();
    const point0R = new Vector2();
    const currentPointL = new Vector2();
    const currentPointR = new Vector2();
    const nextPointL = new Vector2();
    const nextPointR = new Vector2();
    const innerPoint = new Vector2();
    const outerPoint = new Vector2();
    arcDivisions = arcDivisions !== void 0 ? arcDivisions : 12;
    minDistance = minDistance !== void 0 ? minDistance : 1e-3;
    vertexOffset = vertexOffset !== void 0 ? vertexOffset : 0;
    points = removeDuplicatedPoints(points);
    const numPoints = points.length;
    if (numPoints < 2)
      return 0;
    const isClosed = points[0].equals(points[numPoints - 1]);
    let currentPoint;
    let previousPoint = points[0];
    let nextPoint;
    const strokeWidth2 = style.strokeWidth / 2;
    const deltaU = 1 / (numPoints - 1);
    let u0 = 0, u1;
    let innerSideModified;
    let joinIsOnLeftSide;
    let isMiter;
    let initialJoinIsOnLeftSide = false;
    let numVertices = 0;
    let currentCoordinate = vertexOffset * 3;
    let currentCoordinateUV = vertexOffset * 2;
    getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);
    lastPointL.copy(points[0]).sub(tempV2_1);
    lastPointR.copy(points[0]).add(tempV2_1);
    point0L.copy(lastPointL);
    point0R.copy(lastPointR);
    for (let iPoint = 1; iPoint < numPoints; iPoint++) {
      currentPoint = points[iPoint];
      if (iPoint === numPoints - 1) {
        if (isClosed) {
          nextPoint = points[1];
        } else
          nextPoint = void 0;
      } else {
        nextPoint = points[iPoint + 1];
      }
      const normal1 = tempV2_1;
      getNormal(previousPoint, currentPoint, normal1);
      tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);
      currentPointL.copy(currentPoint).sub(tempV2_3);
      currentPointR.copy(currentPoint).add(tempV2_3);
      u1 = u0 + deltaU;
      innerSideModified = false;
      if (nextPoint !== void 0) {
        getNormal(currentPoint, nextPoint, tempV2_2);
        tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);
        nextPointL.copy(currentPoint).sub(tempV2_3);
        nextPointR.copy(currentPoint).add(tempV2_3);
        joinIsOnLeftSide = true;
        tempV2_3.subVectors(nextPoint, previousPoint);
        if (normal1.dot(tempV2_3) < 0) {
          joinIsOnLeftSide = false;
        }
        if (iPoint === 1)
          initialJoinIsOnLeftSide = joinIsOnLeftSide;
        tempV2_3.subVectors(nextPoint, currentPoint);
        tempV2_3.normalize();
        const dot = Math.abs(normal1.dot(tempV2_3));
        if (dot > Number.EPSILON) {
          const miterSide = strokeWidth2 / dot;
          tempV2_3.multiplyScalar(-miterSide);
          tempV2_4.subVectors(currentPoint, previousPoint);
          tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);
          innerPoint.copy(tempV2_5).negate();
          const miterLength2 = tempV2_5.length();
          const segmentLengthPrev = tempV2_4.length();
          tempV2_4.divideScalar(segmentLengthPrev);
          tempV2_6.subVectors(nextPoint, currentPoint);
          const segmentLengthNext = tempV2_6.length();
          tempV2_6.divideScalar(segmentLengthNext);
          if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {
            innerSideModified = true;
          }
          outerPoint.copy(tempV2_5).add(currentPoint);
          innerPoint.add(currentPoint);
          isMiter = false;
          if (innerSideModified) {
            if (joinIsOnLeftSide) {
              nextPointR.copy(innerPoint);
              currentPointR.copy(innerPoint);
            } else {
              nextPointL.copy(innerPoint);
              currentPointL.copy(innerPoint);
            }
          } else {
            makeSegmentTriangles();
          }
          switch (style.strokeLineJoin) {
            case "bevel":
              makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);
              break;
            case "round":
              createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);
              if (joinIsOnLeftSide) {
                makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);
              } else {
                makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);
              }
              break;
            case "miter":
            case "miter-clip":
            default:
              const miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;
              if (miterFraction < 1) {
                if (style.strokeLineJoin !== "miter-clip") {
                  makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);
                  break;
                } else {
                  createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);
                  if (joinIsOnLeftSide) {
                    tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);
                    tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);
                    addVertex(currentPointL, u1, 0);
                    addVertex(tempV2_6, u1, 0);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(tempV2_6, u1, 0);
                    addVertex(tempV2_7, u1, 0);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(tempV2_7, u1, 0);
                    addVertex(nextPointL, u1, 0);
                  } else {
                    tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);
                    tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);
                    addVertex(currentPointR, u1, 1);
                    addVertex(tempV2_6, u1, 1);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(tempV2_6, u1, 1);
                    addVertex(tempV2_7, u1, 1);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(tempV2_7, u1, 1);
                    addVertex(nextPointR, u1, 1);
                  }
                }
              } else {
                if (innerSideModified) {
                  if (joinIsOnLeftSide) {
                    addVertex(lastPointR, u0, 1);
                    addVertex(lastPointL, u0, 0);
                    addVertex(outerPoint, u1, 0);
                    addVertex(lastPointR, u0, 1);
                    addVertex(outerPoint, u1, 0);
                    addVertex(innerPoint, u1, 1);
                  } else {
                    addVertex(lastPointR, u0, 1);
                    addVertex(lastPointL, u0, 0);
                    addVertex(outerPoint, u1, 1);
                    addVertex(lastPointL, u0, 0);
                    addVertex(innerPoint, u1, 0);
                    addVertex(outerPoint, u1, 1);
                  }
                  if (joinIsOnLeftSide) {
                    nextPointL.copy(outerPoint);
                  } else {
                    nextPointR.copy(outerPoint);
                  }
                } else {
                  if (joinIsOnLeftSide) {
                    addVertex(currentPointL, u1, 0);
                    addVertex(outerPoint, u1, 0);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(outerPoint, u1, 0);
                    addVertex(nextPointL, u1, 0);
                  } else {
                    addVertex(currentPointR, u1, 1);
                    addVertex(outerPoint, u1, 1);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(outerPoint, u1, 1);
                    addVertex(nextPointR, u1, 1);
                  }
                }
                isMiter = true;
              }
              break;
          }
        } else {
          makeSegmentTriangles();
        }
      } else {
        makeSegmentTriangles();
      }
      if (!isClosed && iPoint === numPoints - 1) {
        addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);
      }
      u0 = u1;
      previousPoint = currentPoint;
      lastPointL.copy(nextPointL);
      lastPointR.copy(nextPointR);
    }
    if (!isClosed) {
      addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);
    } else if (innerSideModified && vertices) {
      let lastOuter = outerPoint;
      let lastInner = innerPoint;
      if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {
        lastOuter = innerPoint;
        lastInner = outerPoint;
      }
      if (joinIsOnLeftSide) {
        if (isMiter || initialJoinIsOnLeftSide) {
          lastInner.toArray(vertices, 0 * 3);
          lastInner.toArray(vertices, 3 * 3);
          if (isMiter) {
            lastOuter.toArray(vertices, 1 * 3);
          }
        }
      } else {
        if (isMiter || !initialJoinIsOnLeftSide) {
          lastInner.toArray(vertices, 1 * 3);
          lastInner.toArray(vertices, 3 * 3);
          if (isMiter) {
            lastOuter.toArray(vertices, 0 * 3);
          }
        }
      }
    }
    return numVertices;
    function getNormal(p1, p2, result) {
      result.subVectors(p2, p1);
      return result.set(-result.y, result.x).normalize();
    }
    function addVertex(position, u2, v2) {
      if (vertices) {
        vertices[currentCoordinate] = position.x;
        vertices[currentCoordinate + 1] = position.y;
        vertices[currentCoordinate + 2] = 0;
        if (normals) {
          normals[currentCoordinate] = 0;
          normals[currentCoordinate + 1] = 0;
          normals[currentCoordinate + 2] = 1;
        }
        currentCoordinate += 3;
        if (uvs) {
          uvs[currentCoordinateUV] = u2;
          uvs[currentCoordinateUV + 1] = v2;
          currentCoordinateUV += 2;
        }
      }
      numVertices += 3;
    }
    function makeCircularSector(center, p1, p2, u2, v2) {
      tempV2_1.copy(p1).sub(center).normalize();
      tempV2_2.copy(p2).sub(center).normalize();
      let angle = Math.PI;
      const dot = tempV2_1.dot(tempV2_2);
      if (Math.abs(dot) < 1)
        angle = Math.abs(Math.acos(dot));
      angle /= arcDivisions;
      tempV2_3.copy(p1);
      for (let i2 = 0, il = arcDivisions - 1; i2 < il; i2++) {
        tempV2_4.copy(tempV2_3).rotateAround(center, angle);
        addVertex(tempV2_3, u2, v2);
        addVertex(tempV2_4, u2, v2);
        addVertex(center, u2, 0.5);
        tempV2_3.copy(tempV2_4);
      }
      addVertex(tempV2_4, u2, v2);
      addVertex(p2, u2, v2);
      addVertex(center, u2, 0.5);
    }
    function makeSegmentTriangles() {
      addVertex(lastPointR, u0, 1);
      addVertex(lastPointL, u0, 0);
      addVertex(currentPointL, u1, 0);
      addVertex(lastPointR, u0, 1);
      addVertex(currentPointL, u1, 0);
      addVertex(currentPointR, u1, 1);
    }
    function makeSegmentWithBevelJoin(joinIsOnLeftSide2, innerSideModified2, u2) {
      if (innerSideModified2) {
        if (joinIsOnLeftSide2) {
          addVertex(lastPointR, u0, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(currentPointL, u1, 0);
          addVertex(lastPointR, u0, 1);
          addVertex(currentPointL, u1, 0);
          addVertex(innerPoint, u1, 1);
          addVertex(currentPointL, u2, 0);
          addVertex(nextPointL, u2, 0);
          addVertex(innerPoint, u2, 0.5);
        } else {
          addVertex(lastPointR, u0, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(currentPointR, u1, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(innerPoint, u1, 0);
          addVertex(currentPointR, u1, 1);
          addVertex(currentPointR, u2, 1);
          addVertex(innerPoint, u2, 0);
          addVertex(nextPointR, u2, 1);
        }
      } else {
        if (joinIsOnLeftSide2) {
          addVertex(currentPointL, u2, 0);
          addVertex(nextPointL, u2, 0);
          addVertex(currentPoint, u2, 0.5);
        } else {
          addVertex(currentPointR, u2, 1);
          addVertex(nextPointR, u2, 0);
          addVertex(currentPoint, u2, 0.5);
        }
      }
    }
    function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide2, innerSideModified2) {
      if (innerSideModified2) {
        if (joinIsOnLeftSide2) {
          addVertex(lastPointR, u0, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(currentPointL, u1, 0);
          addVertex(lastPointR, u0, 1);
          addVertex(currentPointL, u1, 0);
          addVertex(innerPoint, u1, 1);
          addVertex(currentPointL, u0, 0);
          addVertex(currentPoint, u1, 0.5);
          addVertex(innerPoint, u1, 1);
          addVertex(currentPoint, u1, 0.5);
          addVertex(nextPointL, u0, 0);
          addVertex(innerPoint, u1, 1);
        } else {
          addVertex(lastPointR, u0, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(currentPointR, u1, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(innerPoint, u1, 0);
          addVertex(currentPointR, u1, 1);
          addVertex(currentPointR, u0, 1);
          addVertex(innerPoint, u1, 0);
          addVertex(currentPoint, u1, 0.5);
          addVertex(currentPoint, u1, 0.5);
          addVertex(innerPoint, u1, 0);
          addVertex(nextPointR, u0, 1);
        }
      }
    }
    function addCapGeometry(center, p1, p2, joinIsOnLeftSide2, start, u2) {
      switch (style.strokeLineCap) {
        case "round":
          if (start) {
            makeCircularSector(center, p2, p1, u2, 0.5);
          } else {
            makeCircularSector(center, p1, p2, u2, 0.5);
          }
          break;
        case "square":
          if (start) {
            tempV2_1.subVectors(p1, center);
            tempV2_2.set(tempV2_1.y, -tempV2_1.x);
            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);
            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);
            if (joinIsOnLeftSide2) {
              tempV2_3.toArray(vertices, 1 * 3);
              tempV2_4.toArray(vertices, 0 * 3);
              tempV2_4.toArray(vertices, 3 * 3);
            } else {
              tempV2_3.toArray(vertices, 1 * 3);
              uvs[3 * 2 + 1] === 1 ? tempV2_4.toArray(vertices, 3 * 3) : tempV2_3.toArray(vertices, 3 * 3);
              tempV2_4.toArray(vertices, 0 * 3);
            }
          } else {
            tempV2_1.subVectors(p2, center);
            tempV2_2.set(tempV2_1.y, -tempV2_1.x);
            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);
            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);
            const vl = vertices.length;
            if (joinIsOnLeftSide2) {
              tempV2_3.toArray(vertices, vl - 1 * 3);
              tempV2_4.toArray(vertices, vl - 2 * 3);
              tempV2_4.toArray(vertices, vl - 4 * 3);
            } else {
              tempV2_4.toArray(vertices, vl - 2 * 3);
              tempV2_3.toArray(vertices, vl - 1 * 3);
              tempV2_4.toArray(vertices, vl - 4 * 3);
            }
          }
          break;
        case "butt":
        default:
          break;
      }
    }
    function removeDuplicatedPoints(points2) {
      let dupPoints = false;
      for (let i2 = 1, n2 = points2.length - 1; i2 < n2; i2++) {
        if (points2[i2].distanceTo(points2[i2 + 1]) < minDistance) {
          dupPoints = true;
          break;
        }
      }
      if (!dupPoints)
        return points2;
      const newPoints = [];
      newPoints.push(points2[0]);
      for (let i2 = 1, n2 = points2.length - 1; i2 < n2; i2++) {
        if (points2[i2].distanceTo(points2[i2 + 1]) >= minDistance) {
          newPoints.push(points2[i2]);
        }
      }
      newPoints.push(points2[points2.length - 1]);
      return newPoints;
    }
  }
};

// node_modules/@pmndrs/uikit/dist/components/svg.js
function createSvg(parentContext, style, properties, defaultProperties, object, childrenContainer) {
  const initializers = [];
  const hoveredSignal = d([]);
  const activeSignal = d([]);
  setupCursorCleanup(hoveredSignal, initializers);
  const aspectRatio = d(void 0);
  const mergedProperties = computedMergedProperties(style, properties, defaultProperties, {
    ...darkPropertyTransformers,
    ...createResponsivePropertyTransformers(parentContext.root.size),
    ...createHoverPropertyTransformers(hoveredSignal),
    ...createActivePropertyTransfomers(activeSignal)
  }, keepAspectRatioPropertyTransformer, (m) => m.add("aspectRatio", aspectRatio));
  const node = d(void 0);
  const flexState = createFlexNodeState();
  createNode(node, flexState, parentContext, mergedProperties, object, true, initializers);
  const transformMatrix = computedTransformMatrix(mergedProperties, flexState, parentContext.root.pixelSize);
  applyTransform(parentContext.root, object, transformMatrix, initializers);
  const globalMatrix = computedGlobalMatrix(parentContext.childrenMatrix, transformMatrix);
  const isClipped = computedIsClipped(parentContext.clippingRect, globalMatrix, flexState.size, parentContext.root.pixelSize);
  const isVisible = computedIsVisible(flexState, isClipped, mergedProperties);
  const groupDeps = computedPanelGroupDependencies(mergedProperties);
  const backgroundOrderInfo = computedOrderInfo(mergedProperties, ElementType.Panel, groupDeps, parentContext.orderInfo);
  initializers.push((subscriptions) => createInstancedPanel(mergedProperties, backgroundOrderInfo, groupDeps, parentContext.root.panelGroupManager, globalMatrix, flexState.size, void 0, flexState.borderInset, parentContext.clippingRect, isVisible, getDefaultPanelMaterialConfig(), subscriptions));
  const orderInfo = computedOrderInfo(void 0, ElementType.Svg, void 0, backgroundOrderInfo);
  const src = w(() => {
    var _a, _b;
    return readReactive((_a = style.value) == null ? void 0 : _a.src) ?? readReactive((_b = properties.value) == null ? void 0 : _b.src);
  });
  const svgObject = d(void 0);
  const clippingPlanes = createGlobalClippingPlanes(parentContext.root, parentContext.clippingRect, initializers);
  loadResourceWithParams(svgObject, loadSvg, disposeGroup, initializers, src, parentContext.root, clippingPlanes, parentContext.clippingRect, orderInfo, aspectRatio);
  applyAppearancePropertiesToGroup(mergedProperties, svgObject, initializers, parentContext.root);
  const centerGroup = createCenterGroup(parentContext.root, flexState, svgObject, aspectRatio, isVisible, initializers);
  const scrollPosition = createScrollPosition();
  applyScrollPosition(childrenContainer, scrollPosition, parentContext.root.pixelSize, initializers);
  const childrenMatrix = computedGlobalScrollMatrix(scrollPosition, globalMatrix, parentContext.root.pixelSize);
  createScrollbars(mergedProperties, scrollPosition, flexState, globalMatrix, isVisible, parentContext.clippingRect, orderInfo, parentContext.root.panelGroupManager, initializers);
  const interactionPanel = createInteractionPanel(orderInfo, parentContext.root, parentContext.clippingRect, flexState.size, initializers);
  const scrollHandlers = computedScrollHandlers(scrollPosition, parentContext.anyAncestorScrollable, flexState, object, interactionPanel, properties, parentContext.root, initializers);
  setupLayoutListeners(style, properties, flexState.size, initializers);
  setupClippedListeners(style, properties, isClipped, initializers);
  return Object.assign(flexState, {
    scrollPosition,
    isClipped,
    mergedProperties,
    anyAncestorScrollable: computedAnyAncestorScrollable(flexState.scrollable, parentContext.anyAncestorScrollable),
    clippingRect: computedClippingRect(globalMatrix, flexState, parentContext.root.pixelSize, parentContext.clippingRect),
    childrenMatrix,
    node,
    orderInfo,
    root: parentContext.root,
    initializers,
    centerGroup,
    handlers: computedHandlers(style, properties, defaultProperties, hoveredSignal, activeSignal, scrollHandlers),
    interactionPanel
  });
}
function createCenterGroup(root, flexState, svgObject, aspectRatio, isVisible, initializers) {
  const centerGroup = new Group();
  centerGroup.matrixAutoUpdate = false;
  initializers.push(() => E(() => {
    fitNormalizedContentInside(centerGroup.position, centerGroup.scale, flexState.size, flexState.paddingInset, flexState.borderInset, root.pixelSize.value, aspectRatio.value ?? 1);
    centerGroup.updateMatrix();
    root.requestRender();
  }), () => E(() => {
    const object = svgObject.value;
    if (object == null) {
      return;
    }
    centerGroup.add(object);
    root.requestRender();
    return () => {
      centerGroup.remove(object);
      root.requestRender();
    };
  }), () => E(() => {
    void (centerGroup.visible = svgObject.value != null && isVisible.value);
    root.requestRender();
  }));
  return centerGroup;
}
var loader = new SVGLoader();
var box3Helper = new Box3();
var vectorHelper3 = new Vector3();
var svgCache = /* @__PURE__ */ new Map();
async function loadSvg(url, root, clippingPlanes, clippedRect, orderInfo, aspectRatio) {
  if (url == null) {
    return void 0;
  }
  const object = new Group();
  object.matrixAutoUpdate = false;
  let result = svgCache.get(url);
  if (result == null) {
    svgCache.set(url, result = await loader.loadAsync(url));
  }
  box3Helper.makeEmpty();
  for (const path of result.paths) {
    const shapes = SVGLoader.createShapes(path);
    const material = new MeshBasicMaterial();
    material.transparent = true;
    material.depthWrite = false;
    material.toneMapped = false;
    material.clippingPlanes = clippingPlanes;
    for (const shape of shapes) {
      const geometry = new ShapeGeometry(shape);
      geometry.computeBoundingBox();
      box3Helper.union(geometry.boundingBox);
      const mesh = new Mesh(geometry, material);
      mesh.matrixAutoUpdate = false;
      mesh.raycast = makeClippedCast(mesh, mesh.raycast, root.object, clippedRect, orderInfo);
      setupRenderOrder(mesh, root, orderInfo);
      mesh.userData.color = path.color;
      mesh.scale.y = -1;
      mesh.updateMatrix();
      object.add(mesh);
    }
  }
  box3Helper.getSize(vectorHelper3);
  aspectRatio.value = vectorHelper3.x / vectorHelper3.y;
  const scale = 1 / vectorHelper3.y;
  object.scale.set(1, 1, 1).multiplyScalar(scale);
  box3Helper.getCenter(vectorHelper3);
  vectorHelper3.y *= -1;
  object.position.copy(vectorHelper3).negate().multiplyScalar(scale);
  object.updateMatrix();
  return object;
}

// node_modules/@pmndrs/uikit/dist/components/icon.js
function createIcon(parentContext, text, svgWidth, svgHeight, style, properties, defaultProperties, object) {
  const initializers = [];
  const hoveredSignal = d([]);
  const activeSignal = d([]);
  setupCursorCleanup(hoveredSignal, initializers);
  const mergedProperties = computedMergedProperties(style, properties, defaultProperties, {
    ...darkPropertyTransformers,
    ...createResponsivePropertyTransformers(parentContext.root.size),
    ...createHoverPropertyTransformers(hoveredSignal),
    ...createActivePropertyTransfomers(activeSignal)
  }, keepAspectRatioPropertyTransformer, (m) => {
    m.add("aspectRatio", svgWidth / svgHeight);
    m.add("width", svgWidth);
    m.add("height", svgHeight);
  });
  const flexState = createFlexNodeState();
  createNode(void 0, flexState, parentContext, mergedProperties, object, true, initializers);
  const transformMatrix = computedTransformMatrix(mergedProperties, flexState, parentContext.root.pixelSize);
  applyTransform(parentContext.root, object, transformMatrix, initializers);
  const globalMatrix = computedGlobalMatrix(parentContext.childrenMatrix, transformMatrix);
  const isClipped = computedIsClipped(parentContext.clippingRect, globalMatrix, flexState.size, parentContext.root.pixelSize);
  const isVisible = computedIsVisible(flexState, isClipped, mergedProperties);
  const groupDeps = computedPanelGroupDependencies(mergedProperties);
  const backgroundOrderInfo = computedOrderInfo(mergedProperties, ElementType.Panel, groupDeps, parentContext.orderInfo);
  initializers.push((subscriptions) => createInstancedPanel(mergedProperties, backgroundOrderInfo, groupDeps, parentContext.root.panelGroupManager, globalMatrix, flexState.size, void 0, flexState.borderInset, parentContext.clippingRect, isVisible, getDefaultPanelMaterialConfig(), subscriptions));
  const orderInfo = computedOrderInfo(void 0, ElementType.Svg, void 0, backgroundOrderInfo);
  const clippingPlanes = createGlobalClippingPlanes(parentContext.root, parentContext.clippingRect, initializers);
  const iconGroup = createIconGroup(mergedProperties, text, svgWidth, svgHeight, parentContext, orderInfo, flexState, isVisible, clippingPlanes, initializers);
  setupLayoutListeners(style, properties, flexState.size, initializers);
  setupClippedListeners(style, properties, isClipped, initializers);
  return Object.assign(flexState, {
    isClipped,
    mergedProperties,
    initializers,
    iconGroup,
    handlers: computedHandlers(style, properties, defaultProperties, hoveredSignal, activeSignal),
    interactionPanel: createInteractionPanel(orderInfo, parentContext.root, parentContext.clippingRect, flexState.size, initializers)
  });
}
var loader2 = new SVGLoader();
function createIconGroup(propertiesSignal, text, svgWidth, svgHeight, parentContext, orderInfo, flexState, isVisible, clippingPlanes, initializers) {
  const group = new Group();
  group.matrixAutoUpdate = false;
  const result = loader2.parse(text);
  for (const path of result.paths) {
    const shapes = SVGLoader.createShapes(path);
    const material = new MeshBasicMaterial();
    material.transparent = true;
    material.depthWrite = false;
    material.toneMapped = false;
    material.clippingPlanes = clippingPlanes;
    for (const shape of shapes) {
      const geometry = new ShapeGeometry(shape);
      geometry.computeBoundingBox();
      const mesh = new Mesh(geometry, material);
      mesh.matrixAutoUpdate = false;
      mesh.raycast = makeClippedCast(mesh, mesh.raycast, parentContext.root.object, parentContext.clippingRect, orderInfo);
      setupRenderOrder(mesh, parentContext.root, orderInfo);
      mesh.userData.color = path.color;
      mesh.scale.y = -1;
      mesh.updateMatrix();
      group.add(mesh);
    }
  }
  const aspectRatio = svgWidth / svgHeight;
  initializers.push(() => E(() => {
    fitNormalizedContentInside(group.position, group.scale, flexState.size, flexState.paddingInset, flexState.borderInset, parentContext.root.pixelSize.value, aspectRatio);
    group.position.x -= group.scale.x * aspectRatio / 2;
    group.position.y += group.scale.x / 2;
    group.scale.divideScalar(svgHeight);
    group.updateMatrix();
    parentContext.root.requestRender();
  }), () => E(() => {
    group.visible = isVisible.value;
    parentContext.root.requestRender();
  }));
  applyAppearancePropertiesToGroup(propertiesSignal, group, initializers, parentContext.root);
  return group;
}

// node_modules/@pmndrs/uikit/dist/caret.js
var caretBorderKeys = [
  "caretBorderRightWidth",
  "caretBorderTopWidth",
  "caretBorderLeftWidth",
  "caretBorderBottomWidth"
];
var caretMaterialConfig;
function getCaretMaterialConfig() {
  caretMaterialConfig ?? (caretMaterialConfig = createPanelMaterialConfig({
    backgroundColor: "caretColor",
    backgroundOpacity: "caretOpacity",
    borderBend: "caretBorderBend",
    borderBottomLeftRadius: "caretBorderBottomLeftRadius",
    borderBottomRightRadius: "caretBorderBottomRightRadius",
    borderColor: "caretBorderColor",
    borderOpacity: "caretBorderOpacity",
    borderTopLeftRadius: "caretBorderTopLeftRadius",
    borderTopRightRadius: "caretBorderTopRightRadius"
  }, {
    backgroundColor: 0,
    backgroundOpacity: 1
  }));
  return caretMaterialConfig;
}
function createCaret(propertiesSignal, matrix, caretPosition, isVisible, parentOrderInfo, parentClippingRect, panelGroupManager, initializers) {
  const orderInfo = computedOrderInfo(void 0, ElementType.Panel, defaultPanelDependencies, parentOrderInfo);
  const blinkingCaretPosition = d(void 0);
  initializers.push(() => E(() => {
    const pos = caretPosition.value;
    if (pos == null) {
      blinkingCaretPosition.value = void 0;
    }
    blinkingCaretPosition.value = pos;
    const ref = setInterval(() => blinkingCaretPosition.value = blinkingCaretPosition.peek() == null ? pos : void 0, 500);
    return () => clearInterval(ref);
  }));
  const borderInset = computedBorderInset(propertiesSignal, caretBorderKeys);
  const caretWidth = computedInheritableProperty(propertiesSignal, "caretWidth", 1.5);
  initializers.push((subscriptions) => createInstancedPanel(propertiesSignal, orderInfo, void 0, panelGroupManager, matrix, w(() => {
    const size = blinkingCaretPosition.value;
    if (size == null) {
      return [0, 0];
    }
    return [caretWidth.value, size[2]];
  }), w(() => {
    const position = blinkingCaretPosition.value;
    if (position == null) {
      return [0, 0];
    }
    return [position[0] - caretWidth.value / 2, position[1]];
  }), borderInset, parentClippingRect, isVisible, getCaretMaterialConfig(), subscriptions));
}

// node_modules/@pmndrs/uikit/dist/selection.js
var selectionBorderKeys = [
  "selectionBorderRightWidth",
  "selectionBorderTopWidth",
  "selectionBorderLeftWidth",
  "selectionBorderBottomWidth"
];
var selectionMaterialConfig;
function getSelectionMaterialConfig() {
  selectionMaterialConfig ?? (selectionMaterialConfig = createPanelMaterialConfig({
    backgroundColor: "selectionColor",
    backgroundOpacity: "selectionOpacity",
    borderBend: "selectionBorderBend",
    borderBottomLeftRadius: "selectionBorderBottomLeftRadius",
    borderBottomRightRadius: "selectionBorderBottomRightRadius",
    borderColor: "selectionBorderColor",
    borderOpacity: "selectionBorderOpacity",
    borderTopLeftRadius: "selectionBorderTopLeftRadius",
    borderTopRightRadius: "selectionBorderTopRightRadius"
  }, {
    backgroundColor: 11851775,
    backgroundOpacity: 1
  }));
  return selectionMaterialConfig;
}
function createSelection(propertiesSignal, matrix, selectionBoxes, isVisible, prevOrderInfo, parentClippingRect, panelGroupManager, initializers) {
  const panels = [];
  const orderInfo = computedOrderInfo(void 0, ElementType.Panel, defaultPanelDependencies, prevOrderInfo);
  const borderInset = computedBorderInset(propertiesSignal, selectionBorderKeys);
  initializers.push(() => E(() => {
    const selections = selectionBoxes.value;
    const selectionsLength = selections.length;
    for (let i2 = 0; i2 < selectionsLength; i2++) {
      let panelData = panels[i2];
      if (panelData == null) {
        const size = d([0, 0]);
        const offset = d([0, 0]);
        const panelSubscriptions = [];
        createInstancedPanel(propertiesSignal, orderInfo, void 0, panelGroupManager, matrix, size, offset, borderInset, parentClippingRect, isVisible, getSelectionMaterialConfig(), panelSubscriptions);
        panels[i2] = panelData = {
          panelSubscriptions,
          offset,
          size
        };
      }
      const selection = selections[i2];
      panelData.size.value = selection.size;
      panelData.offset.value = selection.position;
    }
    const panelsLength = panels.length;
    for (let i2 = selectionsLength; i2 < panelsLength; i2++) {
      unsubscribeSubscriptions(panels[i2].panelSubscriptions);
    }
    panels.length = selectionsLength;
  }), () => () => {
    const panelsLength = panels.length;
    for (let i2 = 0; i2 < panelsLength; i2++) {
      unsubscribeSubscriptions(panels[i2].panelSubscriptions);
    }
  });
  return orderInfo;
}

// node_modules/@pmndrs/uikit/dist/focus.js
function createFocusPropertyTransformers(hasFocusSignal) {
  return {
    focus: createConditionalPropertyTranslator(() => hasFocusSignal.value)
  };
}

// node_modules/@pmndrs/uikit/dist/components/input.js
var cancelSet = /* @__PURE__ */ new Set();
function cancelBlur(event) {
  cancelSet.add(event);
}
var canvasInputProps = {
  onPointerDown: (e2) => {
    if (!(document.activeElement instanceof HTMLElement)) {
      return;
    }
    if (!cancelSet.has(e2.nativeEvent)) {
      return;
    }
    cancelSet.delete(e2.nativeEvent);
    e2.preventDefault();
  }
};
function createInput(parentContext, fontFamilies, style, properties, defaultProperties, object) {
  var _a, _b, _c, _d, _e3, _f2;
  const hoveredSignal = d([]);
  const activeSignal = d([]);
  const hasFocusSignal = d(false);
  const initializers = [];
  setupCursorCleanup(hoveredSignal, initializers);
  const mergedProperties = computedMergedProperties(style, properties, defaultProperties, {
    ...darkPropertyTransformers,
    ...createResponsivePropertyTransformers(parentContext.root.size),
    ...createHoverPropertyTransformers(hoveredSignal),
    ...createActivePropertyTransfomers(activeSignal),
    ...createFocusPropertyTransformers(hasFocusSignal)
  }, void 0, (m) => {
    traverseProperties(style.value, properties.value, defaultProperties.value, (p2) => {
      m.add("caretOpacity", p2.opacity);
      m.add("caretColor", p2.color);
    });
  });
  const flexState = createFlexNodeState();
  const nodeSignal = d(void 0);
  createNode(nodeSignal, flexState, parentContext, mergedProperties, object, false, initializers);
  const transformMatrix = computedTransformMatrix(mergedProperties, flexState, parentContext.root.pixelSize);
  applyTransform(parentContext.root, object, transformMatrix, initializers);
  const globalMatrix = computedGlobalMatrix(parentContext.childrenMatrix, transformMatrix);
  const isClipped = computedIsClipped(parentContext.clippingRect, globalMatrix, flexState.size, parentContext.root.pixelSize);
  const isVisible = computedIsVisible(flexState, isClipped, mergedProperties);
  const groupDeps = computedPanelGroupDependencies(mergedProperties);
  const backgroundOrderInfo = computedOrderInfo(mergedProperties, ElementType.Panel, groupDeps, parentContext.orderInfo);
  initializers.push((subscriptions) => createInstancedPanel(mergedProperties, backgroundOrderInfo, groupDeps, parentContext.root.panelGroupManager, globalMatrix, flexState.size, void 0, flexState.borderInset, parentContext.clippingRect, isVisible, getDefaultPanelMaterialConfig(), subscriptions));
  const instancedTextRef = {};
  const selectionBoxes = d([]);
  const caretPosition = d(void 0);
  const selectionRange = d(void 0);
  createCaret(mergedProperties, globalMatrix, caretPosition, isVisible, backgroundOrderInfo, parentContext.clippingRect, parentContext.root.panelGroupManager, initializers);
  const selectionOrderInfo = createSelection(mergedProperties, globalMatrix, selectionBoxes, isVisible, backgroundOrderInfo, parentContext.clippingRect, parentContext.root.panelGroupManager, initializers);
  const fontSignal = computedFont(mergedProperties, fontFamilies, parentContext.root.renderer, initializers);
  const orderInfo = computedOrderInfo(void 0, ElementType.Text, computedGylphGroupDependencies(fontSignal), selectionOrderInfo);
  const defaultValue = ((_a = style.peek()) == null ? void 0 : _a.defaultValue) ?? ((_b = properties.peek()) == null ? void 0 : _b.defaultValue);
  const writeValue = ((_c = style.peek()) == null ? void 0 : _c.value) == null && ((_d = properties.peek()) == null ? void 0 : _d.value) == null ? d(defaultValue ?? "") : void 0;
  const valueSignal = w(() => {
    var _a2, _b2;
    return (writeValue == null ? void 0 : writeValue.value) ?? readReactive((_a2 = style.value) == null ? void 0 : _a2.value) ?? readReactive((_b2 = properties.value) == null ? void 0 : _b2.value) ?? "";
  });
  const type = computedNonInheritableProperty(style, properties, "type", "text");
  const displayValueSignal = w(() => type.value === "text" ? valueSignal.value : "*".repeat(valueSignal.value.length ?? 0));
  const multiline = ((_e3 = style.peek()) == null ? void 0 : _e3.multiline) ?? ((_f2 = properties.peek()) == null ? void 0 : _f2.multiline) ?? false;
  const customLayouting = createInstancedText(mergedProperties, displayValueSignal, globalMatrix, nodeSignal, flexState, isVisible, parentContext.clippingRect, orderInfo, fontSignal, parentContext.root.gylphGroupManager, selectionRange, selectionBoxes, caretPosition, instancedTextRef, initializers, multiline ? "break-word" : "keep-all");
  initializers.push(() => E(() => {
    var _a2;
    return (_a2 = nodeSignal.value) == null ? void 0 : _a2.setCustomLayouting(customLayouting.value);
  }));
  setupLayoutListeners(style, properties, flexState.size, initializers);
  setupClippedListeners(style, properties, isClipped, initializers);
  const disabled = computedNonInheritableProperty(style, properties, "disabled", false);
  const element = createHtmlInputElement(valueSignal, selectionRange, (newValue) => {
    var _a2, _b2, _c2, _d2;
    if (writeValue != null) {
      writeValue.value = newValue;
    }
    (_b2 = (_a2 = style.peek()) == null ? void 0 : _a2.onValueChange) == null ? void 0 : _b2.call(_a2, newValue);
    (_d2 = (_c2 = properties.peek()) == null ? void 0 : _c2.onValueChange) == null ? void 0 : _d2.call(_c2, newValue);
  }, multiline, type, disabled, computedNonInheritableProperty(style, properties, "tabIndex", 0), initializers);
  const focus = (start, end, direction) => {
    const inputElement = element.peek();
    if (inputElement == null) {
      return;
    }
    if (!hasFocusSignal.peek()) {
      inputElement.focus();
    }
    if (start != null && end != null) {
      inputElement.setSelectionRange(start, end, direction);
    }
    selectionRange.value = [inputElement.selectionStart ?? 0, inputElement.selectionEnd ?? 0];
  };
  setupUpdateHasFocus(element, hasFocusSignal, initializers, (hasFocus) => {
    var _a2, _b2, _c2, _d2;
    (_b2 = (_a2 = properties.peek()) == null ? void 0 : _a2.onFocusChange) == null ? void 0 : _b2.call(_a2, hasFocus);
    (_d2 = (_c2 = style.peek()) == null ? void 0 : _c2.onFocusChange) == null ? void 0 : _d2.call(_c2, hasFocus);
  });
  const selectionHandlers = computedSelectionHandlers(flexState, instancedTextRef, focus, disabled);
  return Object.assign(flexState, {
    isClipped,
    mergedProperties,
    valueSignal,
    focus: () => focus(),
    root: parentContext.root,
    element,
    node: nodeSignal,
    interactionPanel: createInteractionPanel(backgroundOrderInfo, parentContext.root, parentContext.clippingRect, flexState.size, initializers),
    handlers: computedHandlers(style, properties, defaultProperties, hoveredSignal, activeSignal, selectionHandlers, "text"),
    initializers
  });
}
function computedSelectionHandlers(flexState, instancedTextRef, focus, disabled) {
  return w(() => {
    if (disabled.value) {
      return void 0;
    }
    let startCharIndex;
    return {
      onPointerDown: (e2) => {
        var _a;
        if (e2.defaultPrevented || e2.uv == null || instancedTextRef.current == null) {
          return;
        }
        cancelBlur(e2.nativeEvent);
        (_a = e2.stopPropagation) == null ? void 0 : _a.call(e2);
        const charIndex = uvToCharIndex(flexState, e2.uv, instancedTextRef.current);
        startCharIndex = charIndex;
        setTimeout(() => focus(charIndex, charIndex));
      },
      onPointerUp: (e2) => {
        startCharIndex = void 0;
      },
      onPointerLeave: (e2) => {
        startCharIndex = void 0;
      },
      onPointerMove: (e2) => {
        var _a;
        if (startCharIndex == null || e2.uv == null || instancedTextRef.current == null) {
          return;
        }
        (_a = e2.stopPropagation) == null ? void 0 : _a.call(e2);
        const charIndex = uvToCharIndex(flexState, e2.uv, instancedTextRef.current);
        const start = Math.min(startCharIndex, charIndex);
        const end = Math.max(startCharIndex, charIndex);
        const direction = startCharIndex < charIndex ? "forward" : "backward";
        setTimeout(() => focus(start, end, direction));
      }
    };
  });
}
function createHtmlInputElement(value, selectionRange, onChange, multiline, type, disabled, tabIndex, initializers) {
  const elementSignal = d(void 0);
  initializers.push((subscriptions) => {
    const element = document.createElement(multiline ? "textarea" : "input");
    const style = element.style;
    style.setProperty("position", "absolute");
    style.setProperty("left", "-1000vw");
    style.setProperty("top", "0");
    style.setProperty("pointerEvents", "none");
    style.setProperty("opacity", "0");
    element.addEventListener("input", () => {
      onChange == null ? void 0 : onChange(element.value);
      updateSelection();
    });
    const updateSelection = () => {
      const { selectionStart, selectionEnd } = element;
      if (selectionStart == null || selectionEnd == null) {
        selectionRange.value = void 0;
        return;
      }
      const current = selectionRange.peek();
      if (current != null && current[0] === selectionStart && current[1] === selectionEnd) {
        return;
      }
      selectionRange.value = [selectionStart, selectionEnd];
    };
    element.addEventListener("keydown", updateSelection);
    element.addEventListener("keyup", updateSelection);
    element.addEventListener("blur", () => selectionRange.value = void 0);
    document.body.appendChild(element);
    elementSignal.value = element;
    subscriptions.push(() => {
      elementSignal.value = void 0;
      element.remove();
    }, E(() => element.value = value.value), E(() => element.disabled = disabled.value), E(() => element.tabIndex = tabIndex.value), E(() => element.setAttribute("type", type.value)));
    return subscriptions;
  });
  return elementSignal;
}
function setupUpdateHasFocus(elementSignal, hasFocusSignal, initializers, onFocusChange) {
  initializers.push(() => E(() => {
    const element = elementSignal.value;
    if (element == null) {
      return;
    }
    hasFocusSignal.value = document.activeElement === element;
    const listener = () => {
      const hasFocus = document.activeElement === element;
      if (hasFocus == hasFocusSignal.value) {
        return;
      }
      hasFocusSignal.value = hasFocus;
      onFocusChange(hasFocus);
    };
    element.addEventListener("focus", listener);
    element.addEventListener("blur", listener);
    return () => {
      element.removeEventListener("focus", listener);
      element.removeEventListener("blur", listener);
    };
  }));
}
function uvToCharIndex({ size: s2, borderInset: b3, paddingInset: p2 }, uv2, instancedText) {
  const size = s2.peek();
  const borderInset = b3.peek();
  const paddingInset = p2.peek();
  if (size == null || borderInset == null || paddingInset == null) {
    return 0;
  }
  const [width, height] = size;
  const [bTop, , , bLeft] = borderInset;
  const [pTop, , , pLeft] = paddingInset;
  const x2 = uv2.x * width - bLeft - pLeft;
  const y3 = -uv2.y * height + bTop + pTop;
  return instancedText.getCharIndex(x2, y3);
}

// node_modules/@pmndrs/uikit/dist/components/custom.js
function createCustomContainer(parentContext, style, properties, defaultProperties, object, meshRef) {
  const hoveredSignal = d([]);
  const activeSignal = d([]);
  const initializers = [];
  setupCursorCleanup(hoveredSignal, initializers);
  const mergedProperties = computedMergedProperties(style, properties, defaultProperties, {
    ...darkPropertyTransformers,
    ...createResponsivePropertyTransformers(parentContext.root.size),
    ...createHoverPropertyTransformers(hoveredSignal),
    ...createActivePropertyTransfomers(activeSignal)
  });
  const flexState = createFlexNodeState();
  createNode(void 0, flexState, parentContext, mergedProperties, object, true, initializers);
  const transformMatrix = computedTransformMatrix(mergedProperties, flexState, parentContext.root.pixelSize);
  applyTransform(parentContext.root, object, transformMatrix, initializers);
  const globalMatrix = computedGlobalMatrix(parentContext.childrenMatrix, transformMatrix);
  const isClipped = computedIsClipped(parentContext.clippingRect, globalMatrix, flexState.size, parentContext.root.pixelSize);
  const isVisible = computedIsVisible(flexState, isClipped, mergedProperties);
  const orderInfo = computedOrderInfo(mergedProperties, ElementType.Custom, void 0, parentContext.orderInfo);
  const clippingPlanes = createGlobalClippingPlanes(parentContext.root, parentContext.clippingRect, initializers);
  initializers.push((subscriptions) => {
    const mesh = meshRef.current;
    if (mesh == null) {
      return subscriptions;
    }
    mesh.matrixAutoUpdate = false;
    if (mesh.material instanceof Material) {
      const material = mesh.material;
      material.clippingPlanes = clippingPlanes;
      material.needsUpdate = true;
      material.shadowSide = FrontSide;
      subscriptions.push(() => E(() => {
        material.depthTest = parentContext.root.depthTest.value;
        parentContext.root.requestRender();
      }));
    }
    mesh.raycast = makeClippedCast(mesh, mesh.raycast, parentContext.root.object, parentContext.clippingRect, orderInfo);
    setupRenderOrder(mesh, parentContext.root, orderInfo);
    subscriptions.push(E(() => {
      mesh.renderOrder = parentContext.root.renderOrder.value;
      parentContext.root.requestRender();
    }), E(() => {
      mesh.receiveShadow = mergedProperties.value.read("receiveShadow", false);
      parentContext.root.requestRender();
    }), E(() => {
      mesh.castShadow = mergedProperties.value.read("castShadow", false);
      parentContext.root.requestRender();
    }), E(() => {
      if (flexState.size.value == null) {
        return;
      }
      const [width, height] = flexState.size.value;
      const pixelSize = parentContext.root.pixelSize.value;
      mesh.scale.set(width * pixelSize, height * pixelSize, 1);
      mesh.updateMatrix();
      parentContext.root.requestRender();
    }), E(() => {
      void (mesh.visible = isVisible.value);
      parentContext.root.requestRender();
    }));
    return subscriptions;
  });
  setupLayoutListeners(style, properties, flexState.size, initializers);
  setupClippedListeners(style, properties, isClipped, initializers);
  return Object.assign(flexState, {
    isClipped,
    mergedProperties,
    root: parentContext.root,
    handlers: computedHandlers(style, properties, defaultProperties, hoveredSignal, activeSignal),
    initializers
  });
}

// node_modules/@pmndrs/uikit/dist/components/content.js
function createContent(parentContext, style, properties, defaultProperties, object, contentContainerRef) {
  const hoveredSignal = d([]);
  const activeSignal = d([]);
  const initializers = [];
  const flexState = createFlexNodeState();
  setupCursorCleanup(hoveredSignal, initializers);
  const sizeSignal = d(new Vector3(1, 1, 1));
  const aspectRatio = w(() => sizeSignal.value.x / sizeSignal.value.y);
  const mergedProperties = computedMergedProperties(style, properties, defaultProperties, {
    ...darkPropertyTransformers,
    ...createResponsivePropertyTransformers(parentContext.root.size),
    ...createHoverPropertyTransformers(hoveredSignal),
    ...createActivePropertyTransfomers(activeSignal)
  }, keepAspectRatioPropertyTransformer, (m) => m.add("aspectRatio", aspectRatio));
  createNode(void 0, flexState, parentContext, mergedProperties, object, true, initializers);
  const transformMatrix = computedTransformMatrix(mergedProperties, flexState, parentContext.root.pixelSize);
  applyTransform(parentContext.root, object, transformMatrix, initializers);
  const globalMatrix = computedGlobalMatrix(parentContext.childrenMatrix, transformMatrix);
  const isClipped = computedIsClipped(parentContext.clippingRect, globalMatrix, flexState.size, parentContext.root.pixelSize);
  const isVisible = computedIsVisible(flexState, isClipped, mergedProperties);
  const groupDeps = computedPanelGroupDependencies(mergedProperties);
  const backgroundorderInfo = computedOrderInfo(mergedProperties, ElementType.Panel, groupDeps, parentContext.orderInfo);
  initializers.push((subscriptions) => createInstancedPanel(mergedProperties, backgroundorderInfo, groupDeps, parentContext.root.panelGroupManager, globalMatrix, flexState.size, void 0, flexState.borderInset, parentContext.clippingRect, isVisible, getDefaultPanelMaterialConfig(), subscriptions));
  const orderInfo = computedOrderInfo(void 0, ElementType.Object, void 0, backgroundorderInfo);
  setupLayoutListeners(style, properties, flexState.size, initializers);
  setupClippedListeners(style, properties, isClipped, initializers);
  return Object.assign(flexState, {
    isClipped,
    mergedProperties,
    remeasureContent: createMeasureContent(mergedProperties, parentContext.root, flexState, parentContext.clippingRect, isVisible, orderInfo, sizeSignal, contentContainerRef, initializers),
    interactionPanel: createInteractionPanel(backgroundorderInfo, parentContext.root, parentContext.clippingRect, flexState.size, initializers),
    handlers: computedHandlers(style, properties, defaultProperties, hoveredSignal, activeSignal),
    initializers
  });
}
var box3Helper2 = new Box3();
var smallValue = new Vector3().setScalar(1e-3);
var vectorHelper4 = new Vector3();
var defaultDepthAlign = "back";
function createMeasureContent(propertiesSignal, root, flexState, parentClippingRect, isVisible, orderInfo, sizeSignal, contentContainerRef, initializers) {
  const clippingPlanes = createGlobalClippingPlanes(root, parentClippingRect, initializers);
  const depthAlign = computedInheritableProperty(propertiesSignal, "depthAlign", defaultDepthAlign);
  const keepAspectRatio = computedInheritableProperty(propertiesSignal, "keepAspectRatio", true);
  const measuredSize = new Vector3();
  const measuredCenter = new Vector3();
  const updateRenderProperties = (content, visible, renderOrder, depthTest) => {
    if (content == null) {
      return;
    }
    content.visible = visible;
    content.traverse((object) => {
      if (!(object instanceof Mesh)) {
        return;
      }
      object.renderOrder = renderOrder;
      if (!(object.material instanceof Material)) {
        return;
      }
      object.material.depthTest = depthTest;
    });
    root.requestRender();
  };
  const measureContent = () => {
    const content = contentContainerRef.current;
    if (content == null) {
      measuredSize.copy(smallValue);
      measuredCenter.set(0, 0, 0);
      return;
    }
    content.traverse((object) => {
      if (object instanceof Mesh) {
        setupRenderOrder(object, root, orderInfo);
        object.material.clippingPlanes = clippingPlanes;
        object.material.needsUpdate = true;
        object.raycast = makeClippedCast(object, object.raycast, root.object, parentClippingRect, orderInfo);
      }
    });
    const parent = content.parent;
    content.parent = null;
    box3Helper2.setFromObject(content);
    box3Helper2.getSize(measuredSize).max(smallValue);
    sizeSignal.value = measuredSize;
    if (parent != null) {
      content.parent = parent;
    }
    box3Helper2.getCenter(measuredCenter);
    root.requestRender();
  };
  initializers.push(() => E(() => {
    updateRenderProperties(contentContainerRef.current, isVisible.value, root.renderOrder.value, root.depthTest.value);
    root.requestRender();
  }), (subscriptions) => {
    const content = contentContainerRef.current;
    if (content == null) {
      return subscriptions;
    }
    measureContent();
    subscriptions.push(E(() => {
      const { size: { value: size }, paddingInset: { value: paddingInset }, borderInset: { value: borderInset } } = flexState;
      if (size == null || paddingInset == null || borderInset == null) {
        return;
      }
      const [width, height] = size;
      const [pTop, pRight, pBottom, pLeft] = paddingInset;
      const [bTop, bRight, bBottom, bLeft] = borderInset;
      const topInset = pTop + bTop;
      const rightInset = pRight + bRight;
      const bottomInset = pBottom + bBottom;
      const leftInset = pLeft + bLeft;
      const innerWidth = width - leftInset - rightInset;
      const innerHeight = height - topInset - bottomInset;
      const pixelSize = root.pixelSize.value;
      content.scale.set(innerWidth * pixelSize, innerHeight * pixelSize, keepAspectRatio.value ? innerHeight * pixelSize * measuredSize.z / measuredSize.y : measuredSize.z).divide(measuredSize);
      content.position.copy(measuredCenter).negate();
      content.position.z -= alignmentZMap[depthAlign.value] * measuredSize.z;
      content.position.multiply(content.scale);
      content.position.add(vectorHelper4.set((leftInset - rightInset) * 0.5 * pixelSize, (bottomInset - topInset) * 0.5 * pixelSize, 0));
      content.updateMatrix();
      root.requestRender();
    }));
    return subscriptions;
  });
  return () => {
    updateRenderProperties(contentContainerRef.current, isVisible.peek(), root.renderOrder.peek(), root.depthTest.peek());
    measureContent();
  };
}

// node_modules/@pmndrs/uikit/dist/components/fullscreen.js
function updateSizeFullscreen(sizeX, sizeY, pixelSize, distanceToCamera, camera, screenHeight) {
  if (camera instanceof PerspectiveCamera) {
    const cameraHeight = 2 * Math.tan(Math.PI * camera.fov / 360) * distanceToCamera;
    pixelSize.value = cameraHeight / screenHeight;
    sizeY.value = cameraHeight;
    sizeX.value = cameraHeight * camera.aspect;
  }
  if (camera instanceof OrthographicCamera) {
    const cameraHeight = camera.top - camera.bottom;
    const cameraWidth = camera.right - camera.left;
    pixelSize.value = cameraHeight / screenHeight;
    sizeY.value = cameraHeight;
    sizeX.value = cameraWidth;
  }
}

// node_modules/@pmndrs/uikit/dist/components/video.js
function updateVideoElement(element, { src, autoplay, loop, muted, playbackRate, preservesPitch, volume }) {
  if (src instanceof HTMLElement) {
    return;
  }
  if (autoplay) {
    element.remove();
    document.body.append(element);
    element.style.position = "absolute";
    element.style.width = "1px";
    element.style.zIndex = "-1000";
    element.style.top = "0px";
    element.style.left = "0px";
  }
  element.playsInline = true;
  element.volume = volume ?? 1;
  element.preservesPitch = preservesPitch ?? true;
  element.playbackRate = playbackRate ?? 1;
  element.muted = muted ?? false;
  element.loop = loop ?? false;
  element.autoplay = autoplay ?? false;
  if (src == null) {
    element.removeAttribute("src");
    element.removeAttribute("srcObject");
    return;
  }
  if (typeof src === "string") {
    element.src = src;
  } else {
    element.srcObject = src;
  }
}
function setupVideoElementInvalidation(element, invalidate) {
  let requestId;
  const callback = () => {
    invalidate();
    requestId = element.requestVideoFrameCallback(callback);
  };
  requestId = element.requestVideoFrameCallback(callback);
  return () => element.cancelVideoFrameCallback(requestId);
}

// node_modules/@pmndrs/uikit/dist/hover.js
function setupCursorCleanup(hoveredSignal, initializers) {
  initializers.push(() => () => unsetCursorType(hoveredSignal));
}
function addHoverHandlers(target, style, properties, defaultProperties, hoveredSignal, defaultCursor) {
  let hoverPropertiesExist = false;
  traverseProperties(style, properties, defaultProperties, (p2) => {
    if ("hover" in p2) {
      hoverPropertiesExist = true;
    }
  });
  const cursor = (style == null ? void 0 : style.cursor) ?? (properties == null ? void 0 : properties.cursor) ?? defaultCursor;
  if (!hoverPropertiesExist && (style == null ? void 0 : style.onHoverChange) == null && (properties == null ? void 0 : properties.onHoverChange) == null && cursor == null) {
    hoveredSignal.value.length = 0;
    return;
  }
  addHandler("onPointerOver", target, ({ pointerId }) => {
    var _a, _b;
    hoveredSignal.value = [pointerId, ...hoveredSignal.value];
    if (hoveredSignal.value.length === 1) {
      (_a = properties == null ? void 0 : properties.onHoverChange) == null ? void 0 : _a.call(properties, true);
      (_b = style == null ? void 0 : style.onHoverChange) == null ? void 0 : _b.call(style, true);
    }
    if (cursor != null) {
      setCursorType(hoveredSignal, cursor);
    }
  });
  addHandler("onPointerOut", target, ({ pointerId }) => {
    var _a, _b;
    hoveredSignal.value = hoveredSignal.value.filter((id) => id != pointerId);
    if (hoveredSignal.value.length === 0) {
      (_a = properties == null ? void 0 : properties.onHoverChange) == null ? void 0 : _a.call(properties, false);
      (_b = style == null ? void 0 : style.onHoverChange) == null ? void 0 : _b.call(style, false);
    }
    unsetCursorType(hoveredSignal);
  });
}
function createHoverPropertyTransformers(hoveredSignal) {
  return {
    hover: createConditionalPropertyTranslator(() => hoveredSignal.value.length > 0)
  };
}
var cursorRefStack = [];
var cursorTypeStack = [];
function setCursorType(ref, type) {
  cursorRefStack.push(ref);
  cursorTypeStack.push(type);
  document.body.style.cursor = type;
}
function unsetCursorType(ref) {
  const index = cursorRefStack.indexOf(ref);
  if (index == -1) {
    return;
  }
  cursorRefStack.splice(index, 1);
  cursorTypeStack.splice(index, 1);
  document.body.style.cursor = cursorTypeStack[cursorTypeStack.length - 1] ?? "default";
}

// node_modules/@pmndrs/uikit/dist/convert/html/internals.js
var import_node_html_parser = __toESM(require_dist(), 1);

// node_modules/@pmndrs/uikit/dist/convert/html/defaults.js
var htmlDefaults = {
  h1: {
    defaultProperties: {
      //tailwind disables this marginY: 10.67,
      fontSize: 32,
      fontWeight: "bold"
    }
  },
  h2: {
    defaultProperties: {
      //tailwind disables this marginY: 13.28,
      fontSize: 24,
      fontWeight: "bold"
    }
  },
  h3: {
    defaultProperties: {
      //tailwind disables this marginY: 16,
      fontSize: 18.72,
      fontWeight: "bold"
    }
  },
  h4: {
    defaultProperties: {
      //tailwind disables this marginY: 21.28,
      fontSize: 16,
      fontWeight: "bold"
    }
  },
  h5: {
    defaultProperties: {
      //tailwind disables this marginY: 26.72,
      fontSize: 13.28,
      fontWeight: "bold"
    }
  },
  h6: {
    defaultProperties: {
      //tailwind disables this marginY: 37.28,
      fontSize: 10.67,
      fontWeight: "bold"
    }
  },
  ol: {
    defaultProperties: { flexDirection: "column" }
  },
  ul: {
    defaultProperties: { flexDirection: "column" }
  },
  p: {
    defaultProperties: {
      //tailwind disables this marginY: 16
    }
  },
  a: {
    //TODO: custom property converter href => onClick ...
    defaultProperties: {
      //color: 'blue',
      cursor: "pointer"
    }
  },
  img: {
    renderAs: "Image"
  },
  button: { defaultProperties: { verticalAlign: "middle", textAlign: "center", cursor: "pointer" } },
  input: {
    renderAs: "Input",
    children: "none"
  },
  textarea: {
    renderAs: "Input",
    children: "none",
    defaultProperties: { multiline: true }
  },
  video: {
    renderAs: "Video"
  }
};

// node_modules/@pmndrs/uikit/dist/convert/html/internals.js
var import_inline_style_parser = __toESM(require_inline_style_parser(), 1);

// node_modules/tw-to-css/dist/index.mjs
var Ap = Object.create;
var gr = Object.defineProperty;
var _p = Object.getOwnPropertyDescriptor;
var Tp = Object.getOwnPropertyNames;
var Pp = Object.getPrototypeOf;
var Ip = Object.prototype.hasOwnProperty;
var dt = (t2, e2) => () => (t2 && (e2 = t2(t2 = 0)), e2);
var S = (t2, e2) => () => (e2 || t2((e2 = { exports: {} }).exports, e2), e2.exports);
var yr = (t2, e2) => {
  for (var r2 in e2)
    gr(t2, r2, { get: e2[r2], enumerable: true });
};
var Ia = (t2, e2, r2, n2) => {
  if (e2 && typeof e2 == "object" || typeof e2 == "function")
    for (let i2 of Tp(e2))
      !Ip.call(t2, i2) && i2 !== r2 && gr(t2, i2, { get: () => e2[i2], enumerable: !(n2 = _p(e2, i2)) || n2.enumerable });
  return t2;
};
var H = (t2, e2, r2) => (r2 = t2 != null ? Ap(Pp(t2)) : {}, Ia(e2 || !t2 || !t2.__esModule ? gr(r2, "default", { value: t2, enumerable: true }) : r2, t2));
var $e = (t2) => Ia(gr({}, "__esModule", { value: true }), t2);
var Ma;
var Da = dt(() => {
  Ma = `*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:theme("borderColor.DEFAULT",currentColor)}:before,:after{--tw-content: ""}html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:theme("fontFamily.sans",ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:theme("fontFamily.sans[1].fontFeatureSettings",normal);font-variation-settings:theme("fontFamily.sans[1].fontVariationSettings",normal)}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:theme("fontFamily.mono",ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,[type=button],[type=reset],[type=submit]{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:theme("colors.gray.400",#9ca3af)}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]{display:none}
`;
});
var Fa = {};
yr(Fa, { default: () => ht });
var ht;
var vr = dt(() => {
  Da();
  ht = { readFileSync: () => Ma };
});
var Na = S((mb, La) => {
  "use strict";
  var jn = class {
    constructor(e2 = {}) {
      if (!(e2.maxSize && e2.maxSize > 0))
        throw new TypeError("`maxSize` must be a number greater than 0");
      if (typeof e2.maxAge == "number" && e2.maxAge === 0)
        throw new TypeError("`maxAge` must be a number greater than 0");
      this.maxSize = e2.maxSize, this.maxAge = e2.maxAge || 1 / 0, this.onEviction = e2.onEviction, this.cache = /* @__PURE__ */ new Map(), this.oldCache = /* @__PURE__ */ new Map(), this._size = 0;
    }
    _emitEvictions(e2) {
      if (typeof this.onEviction == "function")
        for (let [r2, n2] of e2)
          this.onEviction(r2, n2.value);
    }
    _deleteIfExpired(e2, r2) {
      return typeof r2.expiry == "number" && r2.expiry <= Date.now() ? (typeof this.onEviction == "function" && this.onEviction(e2, r2.value), this.delete(e2)) : false;
    }
    _getOrDeleteIfExpired(e2, r2) {
      if (this._deleteIfExpired(e2, r2) === false)
        return r2.value;
    }
    _getItemValue(e2, r2) {
      return r2.expiry ? this._getOrDeleteIfExpired(e2, r2) : r2.value;
    }
    _peek(e2, r2) {
      let n2 = r2.get(e2);
      return this._getItemValue(e2, n2);
    }
    _set(e2, r2) {
      this.cache.set(e2, r2), this._size++, this._size >= this.maxSize && (this._size = 0, this._emitEvictions(this.oldCache), this.oldCache = this.cache, this.cache = /* @__PURE__ */ new Map());
    }
    _moveToRecent(e2, r2) {
      this.oldCache.delete(e2), this._set(e2, r2);
    }
    *_entriesAscending() {
      for (let e2 of this.oldCache) {
        let [r2, n2] = e2;
        this.cache.has(r2) || this._deleteIfExpired(r2, n2) === false && (yield e2);
      }
      for (let e2 of this.cache) {
        let [r2, n2] = e2;
        this._deleteIfExpired(r2, n2) === false && (yield e2);
      }
    }
    get(e2) {
      if (this.cache.has(e2)) {
        let r2 = this.cache.get(e2);
        return this._getItemValue(e2, r2);
      }
      if (this.oldCache.has(e2)) {
        let r2 = this.oldCache.get(e2);
        if (this._deleteIfExpired(e2, r2) === false)
          return this._moveToRecent(e2, r2), r2.value;
      }
    }
    set(e2, r2, { maxAge: n2 = this.maxAge === 1 / 0 ? void 0 : Date.now() + this.maxAge } = {}) {
      this.cache.has(e2) ? this.cache.set(e2, { value: r2, maxAge: n2 }) : this._set(e2, { value: r2, expiry: n2 });
    }
    has(e2) {
      return this.cache.has(e2) ? !this._deleteIfExpired(e2, this.cache.get(e2)) : this.oldCache.has(e2) ? !this._deleteIfExpired(e2, this.oldCache.get(e2)) : false;
    }
    peek(e2) {
      if (this.cache.has(e2))
        return this._peek(e2, this.cache);
      if (this.oldCache.has(e2))
        return this._peek(e2, this.oldCache);
    }
    delete(e2) {
      let r2 = this.cache.delete(e2);
      return r2 && this._size--, this.oldCache.delete(e2) || r2;
    }
    clear() {
      this.cache.clear(), this.oldCache.clear(), this._size = 0;
    }
    resize(e2) {
      if (!(e2 && e2 > 0))
        throw new TypeError("`maxSize` must be a number greater than 0");
      let r2 = [...this._entriesAscending()], n2 = r2.length - e2;
      n2 < 0 ? (this.cache = new Map(r2), this.oldCache = /* @__PURE__ */ new Map(), this._size = r2.length) : (n2 > 0 && this._emitEvictions(r2.slice(0, n2)), this.oldCache = new Map(r2.slice(n2)), this.cache = /* @__PURE__ */ new Map(), this._size = 0), this.maxSize = e2;
    }
    *keys() {
      for (let [e2] of this)
        yield e2;
    }
    *values() {
      for (let [, e2] of this)
        yield e2;
    }
    *[Symbol.iterator]() {
      for (let e2 of this.cache) {
        let [r2, n2] = e2;
        this._deleteIfExpired(r2, n2) === false && (yield [r2, n2.value]);
      }
      for (let e2 of this.oldCache) {
        let [r2, n2] = e2;
        this.cache.has(r2) || this._deleteIfExpired(r2, n2) === false && (yield [r2, n2.value]);
      }
    }
    *entriesDescending() {
      let e2 = [...this.cache];
      for (let r2 = e2.length - 1; r2 >= 0; --r2) {
        let n2 = e2[r2], [i2, a2] = n2;
        this._deleteIfExpired(i2, a2) === false && (yield [i2, a2.value]);
      }
      e2 = [...this.oldCache];
      for (let r2 = e2.length - 1; r2 >= 0; --r2) {
        let n2 = e2[r2], [i2, a2] = n2;
        this.cache.has(i2) || this._deleteIfExpired(i2, a2) === false && (yield [i2, a2.value]);
      }
    }
    *entriesAscending() {
      for (let [e2, r2] of this._entriesAscending())
        yield [e2, r2.value];
    }
    get size() {
      if (!this._size)
        return this.oldCache.size;
      let e2 = 0;
      for (let r2 of this.oldCache.keys())
        this.cache.has(r2) || e2++;
      return Math.min(this._size + e2, this.maxSize);
    }
  };
  La.exports = jn;
});
var Ua = {};
yr(Ua, { default: () => Bn });
var Bn;
var Gn = dt(() => {
  Bn = { yellow: (t2) => t2 };
});
var Yn = S(() => {
});
var br = S((bb, Va) => {
  "use strict";
  var ja = (Gn(), $e(Ua)), za = Yn(), Ue2 = class extends Error {
    constructor(e2, r2, n2, i2, a2, s2) {
      super(e2), this.name = "CssSyntaxError", this.reason = e2, a2 && (this.file = a2), i2 && (this.source = i2), s2 && (this.plugin = s2), typeof r2 < "u" && typeof n2 < "u" && (typeof r2 == "number" ? (this.line = r2, this.column = n2) : (this.line = r2.line, this.column = r2.column, this.endLine = n2.line, this.endColumn = n2.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, Ue2);
    }
    setMessage() {
      this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
    }
    showSourceCode(e2) {
      if (!this.source)
        return "";
      let r2 = this.source;
      e2 == null && (e2 = ja.isColorSupported), za && e2 && (r2 = za(r2));
      let n2 = r2.split(/\r?\n/), i2 = Math.max(this.line - 3, 0), a2 = Math.min(this.line + 2, n2.length), s2 = String(a2).length, o2, l2;
      if (e2) {
        let { bold: u2, gray: f2, red: p2 } = ja.createColors(true);
        o2 = (c2) => u2(p2(c2)), l2 = (c2) => f2(c2);
      } else
        o2 = l2 = (u2) => u2;
      return n2.slice(i2, a2).map((u2, f2) => {
        let p2 = i2 + 1 + f2, c2 = " " + (" " + p2).slice(-s2) + " | ";
        if (p2 === this.line) {
          let d2 = l2(c2.replace(/\d/g, " ")) + u2.slice(0, this.column - 1).replace(/[^\t]/g, " ");
          return o2(">") + l2(c2) + u2 + `
 ` + d2 + o2("^");
        }
        return " " + l2(c2) + u2;
      }).join(`
`);
    }
    toString() {
      let e2 = this.showSourceCode();
      return e2 && (e2 = `

` + e2 + `
`), this.name + ": " + this.message + e2;
    }
  };
  Va.exports = Ue2;
  Ue2.default = Ue2;
});
var xr = S((xb, Hn) => {
  "use strict";
  Hn.exports.isClean = Symbol("isClean");
  Hn.exports.my = Symbol("my");
});
var Qn = S((Sb, Ba) => {
  "use strict";
  var Wa = { after: `
`, beforeClose: `
`, beforeComment: `
`, beforeDecl: `
`, beforeOpen: " ", beforeRule: `
`, colon: ": ", commentLeft: " ", commentRight: " ", emptyBody: "", indent: "    ", semicolon: false };
  function Mp(t2) {
    return t2[0].toUpperCase() + t2.slice(1);
  }
  var gt2 = class {
    constructor(e2) {
      this.builder = e2;
    }
    atrule(e2, r2) {
      let n2 = "@" + e2.name, i2 = e2.params ? this.rawValue(e2, "params") : "";
      if (typeof e2.raws.afterName < "u" ? n2 += e2.raws.afterName : i2 && (n2 += " "), e2.nodes)
        this.block(e2, n2 + i2);
      else {
        let a2 = (e2.raws.between || "") + (r2 ? ";" : "");
        this.builder(n2 + i2 + a2, e2);
      }
    }
    beforeAfter(e2, r2) {
      let n2;
      e2.type === "decl" ? n2 = this.raw(e2, null, "beforeDecl") : e2.type === "comment" ? n2 = this.raw(e2, null, "beforeComment") : r2 === "before" ? n2 = this.raw(e2, null, "beforeRule") : n2 = this.raw(e2, null, "beforeClose");
      let i2 = e2.parent, a2 = 0;
      for (; i2 && i2.type !== "root"; )
        a2 += 1, i2 = i2.parent;
      if (n2.includes(`
`)) {
        let s2 = this.raw(e2, null, "indent");
        if (s2.length)
          for (let o2 = 0; o2 < a2; o2++)
            n2 += s2;
      }
      return n2;
    }
    block(e2, r2) {
      let n2 = this.raw(e2, "between", "beforeOpen");
      this.builder(r2 + n2 + "{", e2, "start");
      let i2;
      e2.nodes && e2.nodes.length ? (this.body(e2), i2 = this.raw(e2, "after")) : i2 = this.raw(e2, "after", "emptyBody"), i2 && this.builder(i2), this.builder("}", e2, "end");
    }
    body(e2) {
      let r2 = e2.nodes.length - 1;
      for (; r2 > 0 && e2.nodes[r2].type === "comment"; )
        r2 -= 1;
      let n2 = this.raw(e2, "semicolon");
      for (let i2 = 0; i2 < e2.nodes.length; i2++) {
        let a2 = e2.nodes[i2], s2 = this.raw(a2, "before");
        s2 && this.builder(s2), this.stringify(a2, r2 !== i2 || n2);
      }
    }
    comment(e2) {
      let r2 = this.raw(e2, "left", "commentLeft"), n2 = this.raw(e2, "right", "commentRight");
      this.builder("/*" + r2 + e2.text + n2 + "*/", e2);
    }
    decl(e2, r2) {
      let n2 = this.raw(e2, "between", "colon"), i2 = e2.prop + n2 + this.rawValue(e2, "value");
      e2.important && (i2 += e2.raws.important || " !important"), r2 && (i2 += ";"), this.builder(i2, e2);
    }
    document(e2) {
      this.body(e2);
    }
    raw(e2, r2, n2) {
      let i2;
      if (n2 || (n2 = r2), r2 && (i2 = e2.raws[r2], typeof i2 < "u"))
        return i2;
      let a2 = e2.parent;
      if (n2 === "before" && (!a2 || a2.type === "root" && a2.first === e2 || a2 && a2.type === "document"))
        return "";
      if (!a2)
        return Wa[n2];
      let s2 = e2.root();
      if (s2.rawCache || (s2.rawCache = {}), typeof s2.rawCache[n2] < "u")
        return s2.rawCache[n2];
      if (n2 === "before" || n2 === "after")
        return this.beforeAfter(e2, n2);
      {
        let o2 = "raw" + Mp(n2);
        this[o2] ? i2 = this[o2](s2, e2) : s2.walk((l2) => {
          if (i2 = l2.raws[r2], typeof i2 < "u")
            return false;
        });
      }
      return typeof i2 > "u" && (i2 = Wa[n2]), s2.rawCache[n2] = i2, i2;
    }
    rawBeforeClose(e2) {
      let r2;
      return e2.walk((n2) => {
        if (n2.nodes && n2.nodes.length > 0 && typeof n2.raws.after < "u")
          return r2 = n2.raws.after, r2.includes(`
`) && (r2 = r2.replace(/[^\n]+$/, "")), false;
      }), r2 && (r2 = r2.replace(/\S/g, "")), r2;
    }
    rawBeforeComment(e2, r2) {
      let n2;
      return e2.walkComments((i2) => {
        if (typeof i2.raws.before < "u")
          return n2 = i2.raws.before, n2.includes(`
`) && (n2 = n2.replace(/[^\n]+$/, "")), false;
      }), typeof n2 > "u" ? n2 = this.raw(r2, null, "beforeDecl") : n2 && (n2 = n2.replace(/\S/g, "")), n2;
    }
    rawBeforeDecl(e2, r2) {
      let n2;
      return e2.walkDecls((i2) => {
        if (typeof i2.raws.before < "u")
          return n2 = i2.raws.before, n2.includes(`
`) && (n2 = n2.replace(/[^\n]+$/, "")), false;
      }), typeof n2 > "u" ? n2 = this.raw(r2, null, "beforeRule") : n2 && (n2 = n2.replace(/\S/g, "")), n2;
    }
    rawBeforeOpen(e2) {
      let r2;
      return e2.walk((n2) => {
        if (n2.type !== "decl" && (r2 = n2.raws.between, typeof r2 < "u"))
          return false;
      }), r2;
    }
    rawBeforeRule(e2) {
      let r2;
      return e2.walk((n2) => {
        if (n2.nodes && (n2.parent !== e2 || e2.first !== n2) && typeof n2.raws.before < "u")
          return r2 = n2.raws.before, r2.includes(`
`) && (r2 = r2.replace(/[^\n]+$/, "")), false;
      }), r2 && (r2 = r2.replace(/\S/g, "")), r2;
    }
    rawColon(e2) {
      let r2;
      return e2.walkDecls((n2) => {
        if (typeof n2.raws.between < "u")
          return r2 = n2.raws.between.replace(/[^\s:]/g, ""), false;
      }), r2;
    }
    rawEmptyBody(e2) {
      let r2;
      return e2.walk((n2) => {
        if (n2.nodes && n2.nodes.length === 0 && (r2 = n2.raws.after, typeof r2 < "u"))
          return false;
      }), r2;
    }
    rawIndent(e2) {
      if (e2.raws.indent)
        return e2.raws.indent;
      let r2;
      return e2.walk((n2) => {
        let i2 = n2.parent;
        if (i2 && i2 !== e2 && i2.parent && i2.parent === e2 && typeof n2.raws.before < "u") {
          let a2 = n2.raws.before.split(`
`);
          return r2 = a2[a2.length - 1], r2 = r2.replace(/\S/g, ""), false;
        }
      }), r2;
    }
    rawSemicolon(e2) {
      let r2;
      return e2.walk((n2) => {
        if (n2.nodes && n2.nodes.length && n2.last.type === "decl" && (r2 = n2.raws.semicolon, typeof r2 < "u"))
          return false;
      }), r2;
    }
    rawValue(e2, r2) {
      let n2 = e2[r2], i2 = e2.raws[r2];
      return i2 && i2.value === n2 ? i2.raw : n2;
    }
    root(e2) {
      this.body(e2), e2.raws.after && this.builder(e2.raws.after);
    }
    rule(e2) {
      this.block(e2, this.rawValue(e2, "selector")), e2.raws.ownSemicolon && this.builder(e2.raws.ownSemicolon, e2, "end");
    }
    stringify(e2, r2) {
      if (!this[e2.type])
        throw new Error("Unknown AST node type " + e2.type + ". Maybe you need to change PostCSS stringifier.");
      this[e2.type](e2, r2);
    }
  };
  Ba.exports = gt2;
  gt2.default = gt2;
});
var yt = S((kb, Ga) => {
  "use strict";
  var Fp = Qn();
  function Jn2(t2, e2) {
    new Fp(e2).stringify(t2);
  }
  Ga.exports = Jn2;
  Jn2.default = Jn2;
});
var wt = S((Ob, Ya) => {
  "use strict";
  var { isClean: Sr2, my: Lp } = xr(), Np = br(), qp = Qn(), $p = yt();
  function Xn2(t2, e2) {
    let r2 = new t2.constructor();
    for (let n2 in t2) {
      if (!Object.prototype.hasOwnProperty.call(t2, n2) || n2 === "proxyCache")
        continue;
      let i2 = t2[n2], a2 = typeof i2;
      n2 === "parent" && a2 === "object" ? e2 && (r2[n2] = e2) : n2 === "source" ? r2[n2] = i2 : Array.isArray(i2) ? r2[n2] = i2.map((s2) => Xn2(s2, r2)) : (a2 === "object" && i2 !== null && (i2 = Xn2(i2)), r2[n2] = i2);
    }
    return r2;
  }
  var vt2 = class {
    constructor(e2 = {}) {
      this.raws = {}, this[Sr2] = false, this[Lp] = true;
      for (let r2 in e2)
        if (r2 === "nodes") {
          this.nodes = [];
          for (let n2 of e2[r2])
            typeof n2.clone == "function" ? this.append(n2.clone()) : this.append(n2);
        } else
          this[r2] = e2[r2];
    }
    addToError(e2) {
      if (e2.postcssNode = this, e2.stack && this.source && /\n\s{4}at /.test(e2.stack)) {
        let r2 = this.source;
        e2.stack = e2.stack.replace(/\n\s{4}at /, `$&${r2.input.from}:${r2.start.line}:${r2.start.column}$&`);
      }
      return e2;
    }
    after(e2) {
      return this.parent.insertAfter(this, e2), this;
    }
    assign(e2 = {}) {
      for (let r2 in e2)
        this[r2] = e2[r2];
      return this;
    }
    before(e2) {
      return this.parent.insertBefore(this, e2), this;
    }
    cleanRaws(e2) {
      delete this.raws.before, delete this.raws.after, e2 || delete this.raws.between;
    }
    clone(e2 = {}) {
      let r2 = Xn2(this);
      for (let n2 in e2)
        r2[n2] = e2[n2];
      return r2;
    }
    cloneAfter(e2 = {}) {
      let r2 = this.clone(e2);
      return this.parent.insertAfter(this, r2), r2;
    }
    cloneBefore(e2 = {}) {
      let r2 = this.clone(e2);
      return this.parent.insertBefore(this, r2), r2;
    }
    error(e2, r2 = {}) {
      if (this.source) {
        let { end: n2, start: i2 } = this.rangeBy(r2);
        return this.source.input.error(e2, { column: i2.column, line: i2.line }, { column: n2.column, line: n2.line }, r2);
      }
      return new Np(e2);
    }
    getProxyProcessor() {
      return { get(e2, r2) {
        return r2 === "proxyOf" ? e2 : r2 === "root" ? () => e2.root().toProxy() : e2[r2];
      }, set(e2, r2, n2) {
        return e2[r2] === n2 || (e2[r2] = n2, (r2 === "prop" || r2 === "value" || r2 === "name" || r2 === "params" || r2 === "important" || r2 === "text") && e2.markDirty()), true;
      } };
    }
    markDirty() {
      if (this[Sr2]) {
        this[Sr2] = false;
        let e2 = this;
        for (; e2 = e2.parent; )
          e2[Sr2] = false;
      }
    }
    next() {
      if (!this.parent)
        return;
      let e2 = this.parent.index(this);
      return this.parent.nodes[e2 + 1];
    }
    positionBy(e2, r2) {
      let n2 = this.source.start;
      if (e2.index)
        n2 = this.positionInside(e2.index, r2);
      else if (e2.word) {
        r2 = this.toString();
        let i2 = r2.indexOf(e2.word);
        i2 !== -1 && (n2 = this.positionInside(i2, r2));
      }
      return n2;
    }
    positionInside(e2, r2) {
      let n2 = r2 || this.toString(), i2 = this.source.start.column, a2 = this.source.start.line;
      for (let s2 = 0; s2 < e2; s2++)
        n2[s2] === `
` ? (i2 = 1, a2 += 1) : i2 += 1;
      return { column: i2, line: a2 };
    }
    prev() {
      if (!this.parent)
        return;
      let e2 = this.parent.index(this);
      return this.parent.nodes[e2 - 1];
    }
    rangeBy(e2) {
      let r2 = { column: this.source.start.column, line: this.source.start.line }, n2 = this.source.end ? { column: this.source.end.column + 1, line: this.source.end.line } : { column: r2.column + 1, line: r2.line };
      if (e2.word) {
        let i2 = this.toString(), a2 = i2.indexOf(e2.word);
        a2 !== -1 && (r2 = this.positionInside(a2, i2), n2 = this.positionInside(a2 + e2.word.length, i2));
      } else
        e2.start ? r2 = { column: e2.start.column, line: e2.start.line } : e2.index && (r2 = this.positionInside(e2.index)), e2.end ? n2 = { column: e2.end.column, line: e2.end.line } : e2.endIndex ? n2 = this.positionInside(e2.endIndex) : e2.index && (n2 = this.positionInside(e2.index + 1));
      return (n2.line < r2.line || n2.line === r2.line && n2.column <= r2.column) && (n2 = { column: r2.column + 1, line: r2.line }), { end: n2, start: r2 };
    }
    raw(e2, r2) {
      return new qp().raw(this, e2, r2);
    }
    remove() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }
    replaceWith(...e2) {
      if (this.parent) {
        let r2 = this, n2 = false;
        for (let i2 of e2)
          i2 === this ? n2 = true : n2 ? (this.parent.insertAfter(r2, i2), r2 = i2) : this.parent.insertBefore(r2, i2);
        n2 || this.remove();
      }
      return this;
    }
    root() {
      let e2 = this;
      for (; e2.parent && e2.parent.type !== "document"; )
        e2 = e2.parent;
      return e2;
    }
    toJSON(e2, r2) {
      let n2 = {}, i2 = r2 == null;
      r2 = r2 || /* @__PURE__ */ new Map();
      let a2 = 0;
      for (let s2 in this) {
        if (!Object.prototype.hasOwnProperty.call(this, s2) || s2 === "parent" || s2 === "proxyCache")
          continue;
        let o2 = this[s2];
        if (Array.isArray(o2))
          n2[s2] = o2.map((l2) => typeof l2 == "object" && l2.toJSON ? l2.toJSON(null, r2) : l2);
        else if (typeof o2 == "object" && o2.toJSON)
          n2[s2] = o2.toJSON(null, r2);
        else if (s2 === "source") {
          let l2 = r2.get(o2.input);
          l2 == null && (l2 = a2, r2.set(o2.input, a2), a2++), n2[s2] = { end: o2.end, inputId: l2, start: o2.start };
        } else
          n2[s2] = o2;
      }
      return i2 && (n2.inputs = [...r2.keys()].map((s2) => s2.toJSON())), n2;
    }
    toProxy() {
      return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
    }
    toString(e2 = $p) {
      e2.stringify && (e2 = e2.stringify);
      let r2 = "";
      return e2(this, (n2) => {
        r2 += n2;
      }), r2;
    }
    warn(e2, r2, n2) {
      let i2 = { node: this };
      for (let a2 in n2)
        i2[a2] = n2[a2];
      return e2.warn(r2, i2);
    }
    get proxyOf() {
      return this;
    }
  };
  Ya.exports = vt2;
  vt2.default = vt2;
});
var xt = S((Eb, Ha) => {
  "use strict";
  var Up = wt(), bt2 = class extends Up {
    constructor(e2) {
      e2 && typeof e2.value < "u" && typeof e2.value != "string" && (e2 = { ...e2, value: String(e2.value) }), super(e2), this.type = "decl";
    }
    get variable() {
      return this.prop.startsWith("--") || this.prop[0] === "$";
    }
  };
  Ha.exports = bt2;
  bt2.default = bt2;
});
var kr = S(() => {
});
var St = {};
yr(St, { join: () => Kn });
var Kn;
var kt = dt(() => {
  Kn = () => "";
});
var Zn = {};
yr(Zn, { default: () => jp });
var jp;
var ei = dt(() => {
  jp = null;
});
var Ja = S((_b, Qa) => {
  var zp = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", Vp = (t2, e2 = 21) => (r2 = e2) => {
    let n2 = "", i2 = r2;
    for (; i2--; )
      n2 += t2[Math.random() * t2.length | 0];
    return n2;
  }, Wp = (t2 = 21) => {
    let e2 = "", r2 = t2;
    for (; r2--; )
      e2 += zp[Math.random() * 64 | 0];
    return e2;
  };
  Qa.exports = { nanoid: Wp, customAlphabet: Vp };
});
var ri = S((Tb, Za) => {
  "use strict";
  var { SourceMapConsumer: Xa, SourceMapGenerator: Ka } = kr(), { existsSync: Bp, readFileSync: Gp } = (vr(), $e(Fa)), { dirname: ti2, join: Yp } = (kt(), $e(St));
  function Hp(t2) {
    return Buffer ? Buffer.from(t2, "base64").toString() : window.atob(t2);
  }
  var Ot2 = class {
    constructor(e2, r2) {
      if (r2.map === false)
        return;
      this.loadAnnotation(e2), this.inline = this.startWith(this.annotation, "data:");
      let n2 = r2.map ? r2.map.prev : void 0, i2 = this.loadMap(r2.from, n2);
      !this.mapFile && r2.from && (this.mapFile = r2.from), this.mapFile && (this.root = ti2(this.mapFile)), i2 && (this.text = i2);
    }
    consumer() {
      return this.consumerCache || (this.consumerCache = new Xa(this.text)), this.consumerCache;
    }
    decodeInline(e2) {
      let r2 = /^data:application\/json;charset=utf-?8;base64,/, n2 = /^data:application\/json;base64,/, i2 = /^data:application\/json;charset=utf-?8,/, a2 = /^data:application\/json,/;
      if (i2.test(e2) || a2.test(e2))
        return decodeURIComponent(e2.substr(RegExp.lastMatch.length));
      if (r2.test(e2) || n2.test(e2))
        return Hp(e2.substr(RegExp.lastMatch.length));
      let s2 = e2.match(/data:application\/json;([^,]+),/)[1];
      throw new Error("Unsupported source map encoding " + s2);
    }
    getAnnotationURL(e2) {
      return e2.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
    }
    isMap(e2) {
      return typeof e2 != "object" ? false : typeof e2.mappings == "string" || typeof e2._mappings == "string" || Array.isArray(e2.sections);
    }
    loadAnnotation(e2) {
      let r2 = e2.match(/\/\*\s*# sourceMappingURL=/gm);
      if (!r2)
        return;
      let n2 = e2.lastIndexOf(r2.pop()), i2 = e2.indexOf("*/", n2);
      n2 > -1 && i2 > -1 && (this.annotation = this.getAnnotationURL(e2.substring(n2, i2)));
    }
    loadFile(e2) {
      if (this.root = ti2(e2), Bp(e2))
        return this.mapFile = e2, Gp(e2, "utf-8").toString().trim();
    }
    loadMap(e2, r2) {
      if (r2 === false)
        return false;
      if (r2) {
        if (typeof r2 == "string")
          return r2;
        if (typeof r2 == "function") {
          let n2 = r2(e2);
          if (n2) {
            let i2 = this.loadFile(n2);
            if (!i2)
              throw new Error("Unable to load previous source map: " + n2.toString());
            return i2;
          }
        } else {
          if (r2 instanceof Xa)
            return Ka.fromSourceMap(r2).toString();
          if (r2 instanceof Ka)
            return r2.toString();
          if (this.isMap(r2))
            return JSON.stringify(r2);
          throw new Error("Unsupported previous source map format: " + r2.toString());
        }
      } else {
        if (this.inline)
          return this.decodeInline(this.annotation);
        if (this.annotation) {
          let n2 = this.annotation;
          return e2 && (n2 = Yp(ti2(e2), n2)), this.loadFile(n2);
        }
      }
    }
    startWith(e2, r2) {
      return e2 ? e2.substr(0, r2.length) === r2 : false;
    }
    withContent() {
      return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
    }
  };
  Za.exports = Ot2;
  Ot2.default = Ot2;
});
var Et = S((Pb, no2) => {
  "use strict";
  var { SourceMapConsumer: Qp, SourceMapGenerator: Jp } = kr(), { fileURLToPath: eo2, pathToFileURL: Or2 } = (ei(), $e(Zn)), { isAbsolute: si2, resolve: ai2 } = (kt(), $e(St)), { nanoid: Xp } = Ja(), ni2 = Yn(), to2 = br(), Kp = ri(), ii2 = Symbol("fromOffsetCache"), Zp = Boolean(Qp && Jp), ro2 = Boolean(ai2 && si2), Ye2 = class {
    constructor(e2, r2 = {}) {
      if (e2 === null || typeof e2 > "u" || typeof e2 == "object" && !e2.toString)
        throw new Error(`PostCSS received ${e2} instead of CSS string`);
      if (this.css = e2.toString(), this.css[0] === "\uFEFF" || this.css[0] === "ï¿¾" ? (this.hasBOM = true, this.css = this.css.slice(1)) : this.hasBOM = false, r2.from && (!ro2 || /^\w+:\/\//.test(r2.from) || si2(r2.from) ? this.file = r2.from : this.file = ai2(r2.from)), ro2 && Zp) {
        let n2 = new Kp(this.css, r2);
        if (n2.text) {
          this.map = n2;
          let i2 = n2.consumer().file;
          !this.file && i2 && (this.file = this.mapResolve(i2));
        }
      }
      this.file || (this.id = "<input css " + Xp(6) + ">"), this.map && (this.map.file = this.from);
    }
    error(e2, r2, n2, i2 = {}) {
      let a2, s2, o2;
      if (r2 && typeof r2 == "object") {
        let u2 = r2, f2 = n2;
        if (typeof u2.offset == "number") {
          let p2 = this.fromOffset(u2.offset);
          r2 = p2.line, n2 = p2.col;
        } else
          r2 = u2.line, n2 = u2.column;
        if (typeof f2.offset == "number") {
          let p2 = this.fromOffset(f2.offset);
          s2 = p2.line, o2 = p2.col;
        } else
          s2 = f2.line, o2 = f2.column;
      } else if (!n2) {
        let u2 = this.fromOffset(r2);
        r2 = u2.line, n2 = u2.col;
      }
      let l2 = this.origin(r2, n2, s2, o2);
      return l2 ? a2 = new to2(e2, l2.endLine === void 0 ? l2.line : { column: l2.column, line: l2.line }, l2.endLine === void 0 ? l2.column : { column: l2.endColumn, line: l2.endLine }, l2.source, l2.file, i2.plugin) : a2 = new to2(e2, s2 === void 0 ? r2 : { column: n2, line: r2 }, s2 === void 0 ? n2 : { column: o2, line: s2 }, this.css, this.file, i2.plugin), a2.input = { column: n2, endColumn: o2, endLine: s2, line: r2, source: this.css }, this.file && (Or2 && (a2.input.url = Or2(this.file).toString()), a2.input.file = this.file), a2;
    }
    fromOffset(e2) {
      let r2, n2;
      if (this[ii2])
        n2 = this[ii2];
      else {
        let a2 = this.css.split(`
`);
        n2 = new Array(a2.length);
        let s2 = 0;
        for (let o2 = 0, l2 = a2.length; o2 < l2; o2++)
          n2[o2] = s2, s2 += a2[o2].length + 1;
        this[ii2] = n2;
      }
      r2 = n2[n2.length - 1];
      let i2 = 0;
      if (e2 >= r2)
        i2 = n2.length - 1;
      else {
        let a2 = n2.length - 2, s2;
        for (; i2 < a2; )
          if (s2 = i2 + (a2 - i2 >> 1), e2 < n2[s2])
            a2 = s2 - 1;
          else if (e2 >= n2[s2 + 1])
            i2 = s2 + 1;
          else {
            i2 = s2;
            break;
          }
      }
      return { col: e2 - n2[i2] + 1, line: i2 + 1 };
    }
    mapResolve(e2) {
      return /^\w+:\/\//.test(e2) ? e2 : ai2(this.map.consumer().sourceRoot || this.map.root || ".", e2);
    }
    origin(e2, r2, n2, i2) {
      if (!this.map)
        return false;
      let a2 = this.map.consumer(), s2 = a2.originalPositionFor({ column: r2, line: e2 });
      if (!s2.source)
        return false;
      let o2;
      typeof n2 == "number" && (o2 = a2.originalPositionFor({ column: i2, line: n2 }));
      let l2;
      si2(s2.source) ? l2 = Or2(s2.source) : l2 = new URL(s2.source, this.map.consumer().sourceRoot || Or2(this.map.mapFile));
      let u2 = { column: s2.column, endColumn: o2 && o2.column, endLine: o2 && o2.line, line: s2.line, url: l2.toString() };
      if (l2.protocol === "file:")
        if (eo2)
          u2.file = eo2(l2);
        else
          throw new Error("file: protocol is not available in this PostCSS build");
      let f2 = a2.sourceContentFor(s2.source);
      return f2 && (u2.source = f2), u2;
    }
    toJSON() {
      let e2 = {};
      for (let r2 of ["hasBOM", "css", "file", "id"])
        this[r2] != null && (e2[r2] = this[r2]);
      return this.map && (e2.map = { ...this.map }, e2.map.consumerCache && (e2.map.consumerCache = void 0)), e2;
    }
    get from() {
      return this.file || this.id;
    }
  };
  no2.exports = Ye2;
  Ye2.default = Ye2;
  ni2 && ni2.registerInput && ni2.registerInput(Ye2);
});
var li = S((Ib, uo2) => {
  "use strict";
  var { SourceMapConsumer: so2, SourceMapGenerator: Er2 } = kr(), { dirname: Cr2, relative: ao2, resolve: oo2, sep: lo2 } = (kt(), $e(St)), { pathToFileURL: io2 } = (ei(), $e(Zn)), ed = Et(), td = Boolean(so2 && Er2), rd = Boolean(Cr2 && oo2 && ao2 && lo2), oi2 = class {
    constructor(e2, r2, n2, i2) {
      this.stringify = e2, this.mapOpts = n2.map || {}, this.root = r2, this.opts = n2, this.css = i2, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = /* @__PURE__ */ new Map(), this.memoizedPaths = /* @__PURE__ */ new Map(), this.memoizedURLs = /* @__PURE__ */ new Map();
    }
    addAnnotation() {
      let e2;
      this.isInline() ? e2 = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? e2 = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? e2 = this.mapOpts.annotation(this.opts.to, this.root) : e2 = this.outputFile() + ".map";
      let r2 = `
`;
      this.css.includes(`\r
`) && (r2 = `\r
`), this.css += r2 + "/*# sourceMappingURL=" + e2 + " */";
    }
    applyPrevMaps() {
      for (let e2 of this.previous()) {
        let r2 = this.toUrl(this.path(e2.file)), n2 = e2.root || Cr2(e2.file), i2;
        this.mapOpts.sourcesContent === false ? (i2 = new so2(e2.text), i2.sourcesContent && (i2.sourcesContent = i2.sourcesContent.map(() => null))) : i2 = e2.consumer(), this.map.applySourceMap(i2, r2, this.toUrl(this.path(n2)));
      }
    }
    clearAnnotation() {
      if (this.mapOpts.annotation !== false)
        if (this.root) {
          let e2;
          for (let r2 = this.root.nodes.length - 1; r2 >= 0; r2--)
            e2 = this.root.nodes[r2], e2.type === "comment" && e2.text.indexOf("# sourceMappingURL=") === 0 && this.root.removeChild(r2);
        } else
          this.css && (this.css = this.css.replace(/(\n)?\/\*#[\S\s]*?\*\/$/gm, ""));
    }
    generate() {
      if (this.clearAnnotation(), rd && td && this.isMap())
        return this.generateMap();
      {
        let e2 = "";
        return this.stringify(this.root, (r2) => {
          e2 += r2;
        }), [e2];
      }
    }
    generateMap() {
      if (this.root)
        this.generateString();
      else if (this.previous().length === 1) {
        let e2 = this.previous()[0].consumer();
        e2.file = this.outputFile(), this.map = Er2.fromSourceMap(e2);
      } else
        this.map = new Er2({ file: this.outputFile() }), this.map.addMapping({ generated: { column: 0, line: 1 }, original: { column: 0, line: 1 }, source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>" });
      return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
    }
    generateString() {
      this.css = "", this.map = new Er2({ file: this.outputFile() });
      let e2 = 1, r2 = 1, n2 = "<no source>", i2 = { generated: { column: 0, line: 0 }, original: { column: 0, line: 0 }, source: "" }, a2, s2;
      this.stringify(this.root, (o2, l2, u2) => {
        if (this.css += o2, l2 && u2 !== "end" && (i2.generated.line = e2, i2.generated.column = r2 - 1, l2.source && l2.source.start ? (i2.source = this.sourcePath(l2), i2.original.line = l2.source.start.line, i2.original.column = l2.source.start.column - 1, this.map.addMapping(i2)) : (i2.source = n2, i2.original.line = 1, i2.original.column = 0, this.map.addMapping(i2))), a2 = o2.match(/\n/g), a2 ? (e2 += a2.length, s2 = o2.lastIndexOf(`
`), r2 = o2.length - s2) : r2 += o2.length, l2 && u2 !== "start") {
          let f2 = l2.parent || { raws: {} };
          (!(l2.type === "decl" || l2.type === "atrule" && !l2.nodes) || l2 !== f2.last || f2.raws.semicolon) && (l2.source && l2.source.end ? (i2.source = this.sourcePath(l2), i2.original.line = l2.source.end.line, i2.original.column = l2.source.end.column - 1, i2.generated.line = e2, i2.generated.column = r2 - 2, this.map.addMapping(i2)) : (i2.source = n2, i2.original.line = 1, i2.original.column = 0, i2.generated.line = e2, i2.generated.column = r2 - 1, this.map.addMapping(i2)));
        }
      });
    }
    isAnnotation() {
      return this.isInline() ? true : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((e2) => e2.annotation) : true;
    }
    isInline() {
      if (typeof this.mapOpts.inline < "u")
        return this.mapOpts.inline;
      let e2 = this.mapOpts.annotation;
      return typeof e2 < "u" && e2 !== true ? false : this.previous().length ? this.previous().some((r2) => r2.inline) : true;
    }
    isMap() {
      return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0;
    }
    isSourcesContent() {
      return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((e2) => e2.withContent()) : true;
    }
    outputFile() {
      return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
    }
    path(e2) {
      if (this.mapOpts.absolute || e2.charCodeAt(0) === 60 || /^\w+:\/\//.test(e2))
        return e2;
      let r2 = this.memoizedPaths.get(e2);
      if (r2)
        return r2;
      let n2 = this.opts.to ? Cr2(this.opts.to) : ".";
      typeof this.mapOpts.annotation == "string" && (n2 = Cr2(oo2(n2, this.mapOpts.annotation)));
      let i2 = ao2(n2, e2);
      return this.memoizedPaths.set(e2, i2), i2;
    }
    previous() {
      if (!this.previousMaps)
        if (this.previousMaps = [], this.root)
          this.root.walk((e2) => {
            if (e2.source && e2.source.input.map) {
              let r2 = e2.source.input.map;
              this.previousMaps.includes(r2) || this.previousMaps.push(r2);
            }
          });
        else {
          let e2 = new ed(this.css, this.opts);
          e2.map && this.previousMaps.push(e2.map);
        }
      return this.previousMaps;
    }
    setSourcesContent() {
      let e2 = {};
      if (this.root)
        this.root.walk((r2) => {
          if (r2.source) {
            let n2 = r2.source.input.from;
            if (n2 && !e2[n2]) {
              e2[n2] = true;
              let i2 = this.usesFileUrls ? this.toFileUrl(n2) : this.toUrl(this.path(n2));
              this.map.setSourceContent(i2, r2.source.input.css);
            }
          }
        });
      else if (this.css) {
        let r2 = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
        this.map.setSourceContent(r2, this.css);
      }
    }
    sourcePath(e2) {
      return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(e2.source.input.from) : this.toUrl(this.path(e2.source.input.from));
    }
    toBase64(e2) {
      return Buffer ? Buffer.from(e2).toString("base64") : window.btoa(unescape(encodeURIComponent(e2)));
    }
    toFileUrl(e2) {
      let r2 = this.memoizedFileURLs.get(e2);
      if (r2)
        return r2;
      if (io2) {
        let n2 = io2(e2).toString();
        return this.memoizedFileURLs.set(e2, n2), n2;
      } else
        throw new Error("`map.absolute` option is not available in this PostCSS build");
    }
    toUrl(e2) {
      let r2 = this.memoizedURLs.get(e2);
      if (r2)
        return r2;
      lo2 === "\\" && (e2 = e2.replace(/\\/g, "/"));
      let n2 = encodeURI(e2).replace(/[#?]/g, encodeURIComponent);
      return this.memoizedURLs.set(e2, n2), n2;
    }
  };
  uo2.exports = oi2;
});
var At = S((Rb, fo2) => {
  "use strict";
  var nd = wt(), Ct = class extends nd {
    constructor(e2) {
      super(e2), this.type = "comment";
    }
  };
  fo2.exports = Ct;
  Ct.default = Ct;
});
var _e = S((Db, bo) => {
  "use strict";
  var { isClean: co2, my: po2 } = xr(), ho2 = xt(), mo2 = At(), id = wt(), go2, ui2, fi2, yo2;
  function vo(t2) {
    return t2.map((e2) => (e2.nodes && (e2.nodes = vo(e2.nodes)), delete e2.source, e2));
  }
  function wo2(t2) {
    if (t2[co2] = false, t2.proxyOf.nodes)
      for (let e2 of t2.proxyOf.nodes)
        wo2(e2);
  }
  var ae2 = class extends id {
    append(...e2) {
      for (let r2 of e2) {
        let n2 = this.normalize(r2, this.last);
        for (let i2 of n2)
          this.proxyOf.nodes.push(i2);
      }
      return this.markDirty(), this;
    }
    cleanRaws(e2) {
      if (super.cleanRaws(e2), this.nodes)
        for (let r2 of this.nodes)
          r2.cleanRaws(e2);
    }
    each(e2) {
      if (!this.proxyOf.nodes)
        return;
      let r2 = this.getIterator(), n2, i2;
      for (; this.indexes[r2] < this.proxyOf.nodes.length && (n2 = this.indexes[r2], i2 = e2(this.proxyOf.nodes[n2], n2), i2 !== false); )
        this.indexes[r2] += 1;
      return delete this.indexes[r2], i2;
    }
    every(e2) {
      return this.nodes.every(e2);
    }
    getIterator() {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      let e2 = this.lastEach;
      return this.indexes[e2] = 0, e2;
    }
    getProxyProcessor() {
      return { get(e2, r2) {
        return r2 === "proxyOf" ? e2 : e2[r2] ? r2 === "each" || typeof r2 == "string" && r2.startsWith("walk") ? (...n2) => e2[r2](...n2.map((i2) => typeof i2 == "function" ? (a2, s2) => i2(a2.toProxy(), s2) : i2)) : r2 === "every" || r2 === "some" ? (n2) => e2[r2]((i2, ...a2) => n2(i2.toProxy(), ...a2)) : r2 === "root" ? () => e2.root().toProxy() : r2 === "nodes" ? e2.nodes.map((n2) => n2.toProxy()) : r2 === "first" || r2 === "last" ? e2[r2].toProxy() : e2[r2] : e2[r2];
      }, set(e2, r2, n2) {
        return e2[r2] === n2 || (e2[r2] = n2, (r2 === "name" || r2 === "params" || r2 === "selector") && e2.markDirty()), true;
      } };
    }
    index(e2) {
      return typeof e2 == "number" ? e2 : (e2.proxyOf && (e2 = e2.proxyOf), this.proxyOf.nodes.indexOf(e2));
    }
    insertAfter(e2, r2) {
      let n2 = this.index(e2), i2 = this.normalize(r2, this.proxyOf.nodes[n2]).reverse();
      n2 = this.index(e2);
      for (let s2 of i2)
        this.proxyOf.nodes.splice(n2 + 1, 0, s2);
      let a2;
      for (let s2 in this.indexes)
        a2 = this.indexes[s2], n2 < a2 && (this.indexes[s2] = a2 + i2.length);
      return this.markDirty(), this;
    }
    insertBefore(e2, r2) {
      let n2 = this.index(e2), i2 = n2 === 0 ? "prepend" : false, a2 = this.normalize(r2, this.proxyOf.nodes[n2], i2).reverse();
      n2 = this.index(e2);
      for (let o2 of a2)
        this.proxyOf.nodes.splice(n2, 0, o2);
      let s2;
      for (let o2 in this.indexes)
        s2 = this.indexes[o2], n2 <= s2 && (this.indexes[o2] = s2 + a2.length);
      return this.markDirty(), this;
    }
    normalize(e2, r2) {
      if (typeof e2 == "string")
        e2 = vo(go2(e2).nodes);
      else if (Array.isArray(e2)) {
        e2 = e2.slice(0);
        for (let i2 of e2)
          i2.parent && i2.parent.removeChild(i2, "ignore");
      } else if (e2.type === "root" && this.type !== "document") {
        e2 = e2.nodes.slice(0);
        for (let i2 of e2)
          i2.parent && i2.parent.removeChild(i2, "ignore");
      } else if (e2.type)
        e2 = [e2];
      else if (e2.prop) {
        if (typeof e2.value > "u")
          throw new Error("Value field is missed in node creation");
        typeof e2.value != "string" && (e2.value = String(e2.value)), e2 = [new ho2(e2)];
      } else if (e2.selector)
        e2 = [new ui2(e2)];
      else if (e2.name)
        e2 = [new fi2(e2)];
      else if (e2.text)
        e2 = [new mo2(e2)];
      else
        throw new Error("Unknown node type in node creation");
      return e2.map((i2) => (i2[po2] || ae2.rebuild(i2), i2 = i2.proxyOf, i2.parent && i2.parent.removeChild(i2), i2[co2] && wo2(i2), typeof i2.raws.before > "u" && r2 && typeof r2.raws.before < "u" && (i2.raws.before = r2.raws.before.replace(/\S/g, "")), i2.parent = this.proxyOf, i2));
    }
    prepend(...e2) {
      e2 = e2.reverse();
      for (let r2 of e2) {
        let n2 = this.normalize(r2, this.first, "prepend").reverse();
        for (let i2 of n2)
          this.proxyOf.nodes.unshift(i2);
        for (let i2 in this.indexes)
          this.indexes[i2] = this.indexes[i2] + n2.length;
      }
      return this.markDirty(), this;
    }
    push(e2) {
      return e2.parent = this, this.proxyOf.nodes.push(e2), this;
    }
    removeAll() {
      for (let e2 of this.proxyOf.nodes)
        e2.parent = void 0;
      return this.proxyOf.nodes = [], this.markDirty(), this;
    }
    removeChild(e2) {
      e2 = this.index(e2), this.proxyOf.nodes[e2].parent = void 0, this.proxyOf.nodes.splice(e2, 1);
      let r2;
      for (let n2 in this.indexes)
        r2 = this.indexes[n2], r2 >= e2 && (this.indexes[n2] = r2 - 1);
      return this.markDirty(), this;
    }
    replaceValues(e2, r2, n2) {
      return n2 || (n2 = r2, r2 = {}), this.walkDecls((i2) => {
        r2.props && !r2.props.includes(i2.prop) || r2.fast && !i2.value.includes(r2.fast) || (i2.value = i2.value.replace(e2, n2));
      }), this.markDirty(), this;
    }
    some(e2) {
      return this.nodes.some(e2);
    }
    walk(e2) {
      return this.each((r2, n2) => {
        let i2;
        try {
          i2 = e2(r2, n2);
        } catch (a2) {
          throw r2.addToError(a2);
        }
        return i2 !== false && r2.walk && (i2 = r2.walk(e2)), i2;
      });
    }
    walkAtRules(e2, r2) {
      return r2 ? e2 instanceof RegExp ? this.walk((n2, i2) => {
        if (n2.type === "atrule" && e2.test(n2.name))
          return r2(n2, i2);
      }) : this.walk((n2, i2) => {
        if (n2.type === "atrule" && n2.name === e2)
          return r2(n2, i2);
      }) : (r2 = e2, this.walk((n2, i2) => {
        if (n2.type === "atrule")
          return r2(n2, i2);
      }));
    }
    walkComments(e2) {
      return this.walk((r2, n2) => {
        if (r2.type === "comment")
          return e2(r2, n2);
      });
    }
    walkDecls(e2, r2) {
      return r2 ? e2 instanceof RegExp ? this.walk((n2, i2) => {
        if (n2.type === "decl" && e2.test(n2.prop))
          return r2(n2, i2);
      }) : this.walk((n2, i2) => {
        if (n2.type === "decl" && n2.prop === e2)
          return r2(n2, i2);
      }) : (r2 = e2, this.walk((n2, i2) => {
        if (n2.type === "decl")
          return r2(n2, i2);
      }));
    }
    walkRules(e2, r2) {
      return r2 ? e2 instanceof RegExp ? this.walk((n2, i2) => {
        if (n2.type === "rule" && e2.test(n2.selector))
          return r2(n2, i2);
      }) : this.walk((n2, i2) => {
        if (n2.type === "rule" && n2.selector === e2)
          return r2(n2, i2);
      }) : (r2 = e2, this.walk((n2, i2) => {
        if (n2.type === "rule")
          return r2(n2, i2);
      }));
    }
    get first() {
      if (!!this.proxyOf.nodes)
        return this.proxyOf.nodes[0];
    }
    get last() {
      if (!!this.proxyOf.nodes)
        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
    }
  };
  ae2.registerParse = (t2) => {
    go2 = t2;
  };
  ae2.registerRule = (t2) => {
    ui2 = t2;
  };
  ae2.registerAtRule = (t2) => {
    fi2 = t2;
  };
  ae2.registerRoot = (t2) => {
    yo2 = t2;
  };
  bo.exports = ae2;
  ae2.default = ae2;
  ae2.rebuild = (t2) => {
    t2.type === "atrule" ? Object.setPrototypeOf(t2, fi2.prototype) : t2.type === "rule" ? Object.setPrototypeOf(t2, ui2.prototype) : t2.type === "decl" ? Object.setPrototypeOf(t2, ho2.prototype) : t2.type === "comment" ? Object.setPrototypeOf(t2, mo2.prototype) : t2.type === "root" && Object.setPrototypeOf(t2, yo2.prototype), t2[po2] = true, t2.nodes && t2.nodes.forEach((e2) => {
      ae2.rebuild(e2);
    });
  };
});
var Ar = S((Mb, ko2) => {
  "use strict";
  var sd = _e(), xo2, So, je2 = class extends sd {
    constructor(e2) {
      super({ type: "document", ...e2 }), this.nodes || (this.nodes = []);
    }
    toResult(e2 = {}) {
      return new xo2(new So(), this, e2).stringify();
    }
  };
  je2.registerLazyResult = (t2) => {
    xo2 = t2;
  };
  je2.registerProcessor = (t2) => {
    So = t2;
  };
  ko2.exports = je2;
  je2.default = je2;
});
var ci = S((Fb, Eo2) => {
  "use strict";
  var Oo = {};
  Eo2.exports = function(e2) {
    Oo[e2] || (Oo[e2] = true, typeof console < "u" && console.warn && console.warn(e2));
  };
});
var pi = S((Lb, Co) => {
  "use strict";
  var _t2 = class {
    constructor(e2, r2 = {}) {
      if (this.type = "warning", this.text = e2, r2.node && r2.node.source) {
        let n2 = r2.node.rangeBy(r2);
        this.line = n2.start.line, this.column = n2.start.column, this.endLine = n2.end.line, this.endColumn = n2.end.column;
      }
      for (let n2 in r2)
        this[n2] = r2[n2];
    }
    toString() {
      return this.node ? this.node.error(this.text, { index: this.index, plugin: this.plugin, word: this.word }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
    }
  };
  Co.exports = _t2;
  _t2.default = _t2;
});
var _r = S((Nb, Ao2) => {
  "use strict";
  var ad = pi(), Tt2 = class {
    constructor(e2, r2, n2) {
      this.processor = e2, this.messages = [], this.root = r2, this.opts = n2, this.css = void 0, this.map = void 0;
    }
    toString() {
      return this.css;
    }
    warn(e2, r2 = {}) {
      r2.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (r2.plugin = this.lastPlugin.postcssPlugin);
      let n2 = new ad(e2, r2);
      return this.messages.push(n2), n2;
    }
    warnings() {
      return this.messages.filter((e2) => e2.type === "warning");
    }
    get content() {
      return this.css;
    }
  };
  Ao2.exports = Tt2;
  Tt2.default = Tt2;
});
var Ro = S((qb, Io2) => {
  "use strict";
  var di2 = "'".charCodeAt(0), _o2 = '"'.charCodeAt(0), Tr2 = "\\".charCodeAt(0), To = "/".charCodeAt(0), Pr2 = `
`.charCodeAt(0), Pt2 = " ".charCodeAt(0), Ir2 = "\f".charCodeAt(0), Rr2 = "	".charCodeAt(0), Dr2 = "\r".charCodeAt(0), od = "[".charCodeAt(0), ld = "]".charCodeAt(0), ud = "(".charCodeAt(0), fd = ")".charCodeAt(0), cd = "{".charCodeAt(0), pd = "}".charCodeAt(0), dd = ";".charCodeAt(0), hd = "*".charCodeAt(0), md = ":".charCodeAt(0), gd = "@".charCodeAt(0), Mr2 = /[\t\n\f\r "#'()/;[\\\]{}]/g, Fr2 = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, yd = /.[\r\n"'(/\\]/, Po2 = /[\da-f]/i;
  Io2.exports = function(e2, r2 = {}) {
    let n2 = e2.css.valueOf(), i2 = r2.ignoreErrors, a2, s2, o2, l2, u2, f2, p2, c2, d2, h2, y3 = n2.length, m = 0, g2 = [], w2 = [];
    function b3() {
      return m;
    }
    function v2(E2) {
      throw e2.error("Unclosed " + E2, m);
    }
    function O2() {
      return w2.length === 0 && m >= y3;
    }
    function x2(E2) {
      if (w2.length)
        return w2.pop();
      if (m >= y3)
        return;
      let I2 = E2 ? E2.ignoreUnclosed : false;
      switch (a2 = n2.charCodeAt(m), a2) {
        case Pr2:
        case Pt2:
        case Rr2:
        case Dr2:
        case Ir2: {
          s2 = m;
          do
            s2 += 1, a2 = n2.charCodeAt(s2);
          while (a2 === Pt2 || a2 === Pr2 || a2 === Rr2 || a2 === Dr2 || a2 === Ir2);
          h2 = ["space", n2.slice(m, s2)], m = s2 - 1;
          break;
        }
        case od:
        case ld:
        case cd:
        case pd:
        case md:
        case dd:
        case fd: {
          let F = String.fromCharCode(a2);
          h2 = [F, F, m];
          break;
        }
        case ud: {
          if (c2 = g2.length ? g2.pop()[1] : "", d2 = n2.charCodeAt(m + 1), c2 === "url" && d2 !== di2 && d2 !== _o2 && d2 !== Pt2 && d2 !== Pr2 && d2 !== Rr2 && d2 !== Ir2 && d2 !== Dr2) {
            s2 = m;
            do {
              if (f2 = false, s2 = n2.indexOf(")", s2 + 1), s2 === -1)
                if (i2 || I2) {
                  s2 = m;
                  break;
                } else
                  v2("bracket");
              for (p2 = s2; n2.charCodeAt(p2 - 1) === Tr2; )
                p2 -= 1, f2 = !f2;
            } while (f2);
            h2 = ["brackets", n2.slice(m, s2 + 1), m, s2], m = s2;
          } else
            s2 = n2.indexOf(")", m + 1), l2 = n2.slice(m, s2 + 1), s2 === -1 || yd.test(l2) ? h2 = ["(", "(", m] : (h2 = ["brackets", l2, m, s2], m = s2);
          break;
        }
        case di2:
        case _o2: {
          o2 = a2 === di2 ? "'" : '"', s2 = m;
          do {
            if (f2 = false, s2 = n2.indexOf(o2, s2 + 1), s2 === -1)
              if (i2 || I2) {
                s2 = m + 1;
                break;
              } else
                v2("string");
            for (p2 = s2; n2.charCodeAt(p2 - 1) === Tr2; )
              p2 -= 1, f2 = !f2;
          } while (f2);
          h2 = ["string", n2.slice(m, s2 + 1), m, s2], m = s2;
          break;
        }
        case gd: {
          Mr2.lastIndex = m + 1, Mr2.test(n2), Mr2.lastIndex === 0 ? s2 = n2.length - 1 : s2 = Mr2.lastIndex - 2, h2 = ["at-word", n2.slice(m, s2 + 1), m, s2], m = s2;
          break;
        }
        case Tr2: {
          for (s2 = m, u2 = true; n2.charCodeAt(s2 + 1) === Tr2; )
            s2 += 1, u2 = !u2;
          if (a2 = n2.charCodeAt(s2 + 1), u2 && a2 !== To && a2 !== Pt2 && a2 !== Pr2 && a2 !== Rr2 && a2 !== Dr2 && a2 !== Ir2 && (s2 += 1, Po2.test(n2.charAt(s2)))) {
            for (; Po2.test(n2.charAt(s2 + 1)); )
              s2 += 1;
            n2.charCodeAt(s2 + 1) === Pt2 && (s2 += 1);
          }
          h2 = ["word", n2.slice(m, s2 + 1), m, s2], m = s2;
          break;
        }
        default: {
          a2 === To && n2.charCodeAt(m + 1) === hd ? (s2 = n2.indexOf("*/", m + 2) + 1, s2 === 0 && (i2 || I2 ? s2 = n2.length : v2("comment")), h2 = ["comment", n2.slice(m, s2 + 1), m, s2], m = s2) : (Fr2.lastIndex = m + 1, Fr2.test(n2), Fr2.lastIndex === 0 ? s2 = n2.length - 1 : s2 = Fr2.lastIndex - 2, h2 = ["word", n2.slice(m, s2 + 1), m, s2], g2.push(h2), m = s2);
          break;
        }
      }
      return m++, h2;
    }
    function A(E2) {
      w2.push(E2);
    }
    return { back: A, endOfFile: O2, nextToken: x2, position: b3 };
  };
});
var Lr = S(($b, Mo2) => {
  "use strict";
  var Do2 = _e(), He2 = class extends Do2 {
    constructor(e2) {
      super(e2), this.type = "atrule";
    }
    append(...e2) {
      return this.proxyOf.nodes || (this.nodes = []), super.append(...e2);
    }
    prepend(...e2) {
      return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e2);
    }
  };
  Mo2.exports = He2;
  He2.default = He2;
  Do2.registerAtRule(He2);
});
var Qe = S((Ub, qo2) => {
  "use strict";
  var Fo2 = _e(), Lo2, No, Te2 = class extends Fo2 {
    constructor(e2) {
      super(e2), this.type = "root", this.nodes || (this.nodes = []);
    }
    normalize(e2, r2, n2) {
      let i2 = super.normalize(e2);
      if (r2) {
        if (n2 === "prepend")
          this.nodes.length > 1 ? r2.raws.before = this.nodes[1].raws.before : delete r2.raws.before;
        else if (this.first !== r2)
          for (let a2 of i2)
            a2.raws.before = r2.raws.before;
      }
      return i2;
    }
    removeChild(e2, r2) {
      let n2 = this.index(e2);
      return !r2 && n2 === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[n2].raws.before), super.removeChild(e2);
    }
    toResult(e2 = {}) {
      return new Lo2(new No(), this, e2).stringify();
    }
  };
  Te2.registerLazyResult = (t2) => {
    Lo2 = t2;
  };
  Te2.registerProcessor = (t2) => {
    No = t2;
  };
  qo2.exports = Te2;
  Te2.default = Te2;
  Fo2.registerRoot(Te2);
});
var hi = S((jb, $o2) => {
  "use strict";
  var It2 = { comma(t2) {
    return It2.split(t2, [","], true);
  }, space(t2) {
    let e2 = [" ", `
`, "	"];
    return It2.split(t2, e2);
  }, split(t2, e2, r2) {
    let n2 = [], i2 = "", a2 = false, s2 = 0, o2 = false, l2 = "", u2 = false;
    for (let f2 of t2)
      u2 ? u2 = false : f2 === "\\" ? u2 = true : o2 ? f2 === l2 && (o2 = false) : f2 === '"' || f2 === "'" ? (o2 = true, l2 = f2) : f2 === "(" ? s2 += 1 : f2 === ")" ? s2 > 0 && (s2 -= 1) : s2 === 0 && e2.includes(f2) && (a2 = true), a2 ? (i2 !== "" && n2.push(i2.trim()), i2 = "", a2 = false) : i2 += f2;
    return (r2 || i2 !== "") && n2.push(i2.trim()), n2;
  } };
  $o2.exports = It2;
  It2.default = It2;
});
var Nr = S((zb, jo2) => {
  "use strict";
  var Uo2 = _e(), vd = hi(), Je2 = class extends Uo2 {
    constructor(e2) {
      super(e2), this.type = "rule", this.nodes || (this.nodes = []);
    }
    get selectors() {
      return vd.comma(this.selector);
    }
    set selectors(e2) {
      let r2 = this.selector ? this.selector.match(/,\s*/) : null, n2 = r2 ? r2[0] : "," + this.raw("between", "beforeOpen");
      this.selector = e2.join(n2);
    }
  };
  jo2.exports = Je2;
  Je2.default = Je2;
  Uo2.registerRule(Je2);
});
var Bo = S((Vb, Wo2) => {
  "use strict";
  var wd = xt(), bd = Ro(), xd = At(), Sd = Lr(), kd = Qe(), zo = Nr(), Vo2 = { empty: true, space: true };
  function Od(t2) {
    for (let e2 = t2.length - 1; e2 >= 0; e2--) {
      let r2 = t2[e2], n2 = r2[3] || r2[2];
      if (n2)
        return n2;
    }
  }
  var mi = class {
    constructor(e2) {
      this.input = e2, this.root = new kd(), this.current = this.root, this.spaces = "", this.semicolon = false, this.customProperty = false, this.createTokenizer(), this.root.source = { input: e2, start: { column: 1, line: 1, offset: 0 } };
    }
    atrule(e2) {
      let r2 = new Sd();
      r2.name = e2[1].slice(1), r2.name === "" && this.unnamedAtrule(r2, e2), this.init(r2, e2[2]);
      let n2, i2, a2, s2 = false, o2 = false, l2 = [], u2 = [];
      for (; !this.tokenizer.endOfFile(); ) {
        if (e2 = this.tokenizer.nextToken(), n2 = e2[0], n2 === "(" || n2 === "[" ? u2.push(n2 === "(" ? ")" : "]") : n2 === "{" && u2.length > 0 ? u2.push("}") : n2 === u2[u2.length - 1] && u2.pop(), u2.length === 0)
          if (n2 === ";") {
            r2.source.end = this.getPosition(e2[2]), r2.source.end.offset++, this.semicolon = true;
            break;
          } else if (n2 === "{") {
            o2 = true;
            break;
          } else if (n2 === "}") {
            if (l2.length > 0) {
              for (a2 = l2.length - 1, i2 = l2[a2]; i2 && i2[0] === "space"; )
                i2 = l2[--a2];
              i2 && (r2.source.end = this.getPosition(i2[3] || i2[2]), r2.source.end.offset++);
            }
            this.end(e2);
            break;
          } else
            l2.push(e2);
        else
          l2.push(e2);
        if (this.tokenizer.endOfFile()) {
          s2 = true;
          break;
        }
      }
      r2.raws.between = this.spacesAndCommentsFromEnd(l2), l2.length ? (r2.raws.afterName = this.spacesAndCommentsFromStart(l2), this.raw(r2, "params", l2), s2 && (e2 = l2[l2.length - 1], r2.source.end = this.getPosition(e2[3] || e2[2]), r2.source.end.offset++, this.spaces = r2.raws.between, r2.raws.between = "")) : (r2.raws.afterName = "", r2.params = ""), o2 && (r2.nodes = [], this.current = r2);
    }
    checkMissedSemicolon(e2) {
      let r2 = this.colon(e2);
      if (r2 === false)
        return;
      let n2 = 0, i2;
      for (let a2 = r2 - 1; a2 >= 0 && (i2 = e2[a2], !(i2[0] !== "space" && (n2 += 1, n2 === 2))); a2--)
        ;
      throw this.input.error("Missed semicolon", i2[0] === "word" ? i2[3] + 1 : i2[2]);
    }
    colon(e2) {
      let r2 = 0, n2, i2, a2;
      for (let [s2, o2] of e2.entries()) {
        if (n2 = o2, i2 = n2[0], i2 === "(" && (r2 += 1), i2 === ")" && (r2 -= 1), r2 === 0 && i2 === ":")
          if (!a2)
            this.doubleColon(n2);
          else {
            if (a2[0] === "word" && a2[1] === "progid")
              continue;
            return s2;
          }
        a2 = n2;
      }
      return false;
    }
    comment(e2) {
      let r2 = new xd();
      this.init(r2, e2[2]), r2.source.end = this.getPosition(e2[3] || e2[2]), r2.source.end.offset++;
      let n2 = e2[1].slice(2, -2);
      if (/^\s*$/.test(n2))
        r2.text = "", r2.raws.left = n2, r2.raws.right = "";
      else {
        let i2 = n2.match(/^(\s*)([^]*\S)(\s*)$/);
        r2.text = i2[2], r2.raws.left = i2[1], r2.raws.right = i2[3];
      }
    }
    createTokenizer() {
      this.tokenizer = bd(this.input);
    }
    decl(e2, r2) {
      let n2 = new wd();
      this.init(n2, e2[0][2]);
      let i2 = e2[e2.length - 1];
      for (i2[0] === ";" && (this.semicolon = true, e2.pop()), n2.source.end = this.getPosition(i2[3] || i2[2] || Od(e2)), n2.source.end.offset++; e2[0][0] !== "word"; )
        e2.length === 1 && this.unknownWord(e2), n2.raws.before += e2.shift()[1];
      for (n2.source.start = this.getPosition(e2[0][2]), n2.prop = ""; e2.length; ) {
        let u2 = e2[0][0];
        if (u2 === ":" || u2 === "space" || u2 === "comment")
          break;
        n2.prop += e2.shift()[1];
      }
      n2.raws.between = "";
      let a2;
      for (; e2.length; )
        if (a2 = e2.shift(), a2[0] === ":") {
          n2.raws.between += a2[1];
          break;
        } else
          a2[0] === "word" && /\w/.test(a2[1]) && this.unknownWord([a2]), n2.raws.between += a2[1];
      (n2.prop[0] === "_" || n2.prop[0] === "*") && (n2.raws.before += n2.prop[0], n2.prop = n2.prop.slice(1));
      let s2 = [], o2;
      for (; e2.length && (o2 = e2[0][0], !(o2 !== "space" && o2 !== "comment")); )
        s2.push(e2.shift());
      this.precheckMissedSemicolon(e2);
      for (let u2 = e2.length - 1; u2 >= 0; u2--) {
        if (a2 = e2[u2], a2[1].toLowerCase() === "!important") {
          n2.important = true;
          let f2 = this.stringFrom(e2, u2);
          f2 = this.spacesFromEnd(e2) + f2, f2 !== " !important" && (n2.raws.important = f2);
          break;
        } else if (a2[1].toLowerCase() === "important") {
          let f2 = e2.slice(0), p2 = "";
          for (let c2 = u2; c2 > 0; c2--) {
            let d2 = f2[c2][0];
            if (p2.trim().indexOf("!") === 0 && d2 !== "space")
              break;
            p2 = f2.pop()[1] + p2;
          }
          p2.trim().indexOf("!") === 0 && (n2.important = true, n2.raws.important = p2, e2 = f2);
        }
        if (a2[0] !== "space" && a2[0] !== "comment")
          break;
      }
      e2.some((u2) => u2[0] !== "space" && u2[0] !== "comment") && (n2.raws.between += s2.map((u2) => u2[1]).join(""), s2 = []), this.raw(n2, "value", s2.concat(e2), r2), n2.value.includes(":") && !r2 && this.checkMissedSemicolon(e2);
    }
    doubleColon(e2) {
      throw this.input.error("Double colon", { offset: e2[2] }, { offset: e2[2] + e2[1].length });
    }
    emptyRule(e2) {
      let r2 = new zo();
      this.init(r2, e2[2]), r2.selector = "", r2.raws.between = "", this.current = r2;
    }
    end(e2) {
      this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = false, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e2[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(e2);
    }
    endFile() {
      this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
    }
    freeSemicolon(e2) {
      if (this.spaces += e2[1], this.current.nodes) {
        let r2 = this.current.nodes[this.current.nodes.length - 1];
        r2 && r2.type === "rule" && !r2.raws.ownSemicolon && (r2.raws.ownSemicolon = this.spaces, this.spaces = "");
      }
    }
    getPosition(e2) {
      let r2 = this.input.fromOffset(e2);
      return { column: r2.col, line: r2.line, offset: e2 };
    }
    init(e2, r2) {
      this.current.push(e2), e2.source = { input: this.input, start: this.getPosition(r2) }, e2.raws.before = this.spaces, this.spaces = "", e2.type !== "comment" && (this.semicolon = false);
    }
    other(e2) {
      let r2 = false, n2 = null, i2 = false, a2 = null, s2 = [], o2 = e2[1].startsWith("--"), l2 = [], u2 = e2;
      for (; u2; ) {
        if (n2 = u2[0], l2.push(u2), n2 === "(" || n2 === "[")
          a2 || (a2 = u2), s2.push(n2 === "(" ? ")" : "]");
        else if (o2 && i2 && n2 === "{")
          a2 || (a2 = u2), s2.push("}");
        else if (s2.length === 0)
          if (n2 === ";")
            if (i2) {
              this.decl(l2, o2);
              return;
            } else
              break;
          else if (n2 === "{") {
            this.rule(l2);
            return;
          } else if (n2 === "}") {
            this.tokenizer.back(l2.pop()), r2 = true;
            break;
          } else
            n2 === ":" && (i2 = true);
        else
          n2 === s2[s2.length - 1] && (s2.pop(), s2.length === 0 && (a2 = null));
        u2 = this.tokenizer.nextToken();
      }
      if (this.tokenizer.endOfFile() && (r2 = true), s2.length > 0 && this.unclosedBracket(a2), r2 && i2) {
        if (!o2)
          for (; l2.length && (u2 = l2[l2.length - 1][0], !(u2 !== "space" && u2 !== "comment")); )
            this.tokenizer.back(l2.pop());
        this.decl(l2, o2);
      } else
        this.unknownWord(l2);
    }
    parse() {
      let e2;
      for (; !this.tokenizer.endOfFile(); )
        switch (e2 = this.tokenizer.nextToken(), e2[0]) {
          case "space":
            this.spaces += e2[1];
            break;
          case ";":
            this.freeSemicolon(e2);
            break;
          case "}":
            this.end(e2);
            break;
          case "comment":
            this.comment(e2);
            break;
          case "at-word":
            this.atrule(e2);
            break;
          case "{":
            this.emptyRule(e2);
            break;
          default:
            this.other(e2);
            break;
        }
      this.endFile();
    }
    precheckMissedSemicolon() {
    }
    raw(e2, r2, n2, i2) {
      let a2, s2, o2 = n2.length, l2 = "", u2 = true, f2, p2;
      for (let c2 = 0; c2 < o2; c2 += 1)
        a2 = n2[c2], s2 = a2[0], s2 === "space" && c2 === o2 - 1 && !i2 ? u2 = false : s2 === "comment" ? (p2 = n2[c2 - 1] ? n2[c2 - 1][0] : "empty", f2 = n2[c2 + 1] ? n2[c2 + 1][0] : "empty", !Vo2[p2] && !Vo2[f2] ? l2.slice(-1) === "," ? u2 = false : l2 += a2[1] : u2 = false) : l2 += a2[1];
      if (!u2) {
        let c2 = n2.reduce((d2, h2) => d2 + h2[1], "");
        e2.raws[r2] = { raw: c2, value: l2 };
      }
      e2[r2] = l2;
    }
    rule(e2) {
      e2.pop();
      let r2 = new zo();
      this.init(r2, e2[0][2]), r2.raws.between = this.spacesAndCommentsFromEnd(e2), this.raw(r2, "selector", e2), this.current = r2;
    }
    spacesAndCommentsFromEnd(e2) {
      let r2, n2 = "";
      for (; e2.length && (r2 = e2[e2.length - 1][0], !(r2 !== "space" && r2 !== "comment")); )
        n2 = e2.pop()[1] + n2;
      return n2;
    }
    spacesAndCommentsFromStart(e2) {
      let r2, n2 = "";
      for (; e2.length && (r2 = e2[0][0], !(r2 !== "space" && r2 !== "comment")); )
        n2 += e2.shift()[1];
      return n2;
    }
    spacesFromEnd(e2) {
      let r2, n2 = "";
      for (; e2.length && (r2 = e2[e2.length - 1][0], r2 === "space"); )
        n2 = e2.pop()[1] + n2;
      return n2;
    }
    stringFrom(e2, r2) {
      let n2 = "";
      for (let i2 = r2; i2 < e2.length; i2++)
        n2 += e2[i2][1];
      return e2.splice(r2, e2.length - r2), n2;
    }
    unclosedBlock() {
      let e2 = this.current.source.start;
      throw this.input.error("Unclosed block", e2.line, e2.column);
    }
    unclosedBracket(e2) {
      throw this.input.error("Unclosed bracket", { offset: e2[2] }, { offset: e2[2] + 1 });
    }
    unexpectedClose(e2) {
      throw this.input.error("Unexpected }", { offset: e2[2] }, { offset: e2[2] + 1 });
    }
    unknownWord(e2) {
      throw this.input.error("Unknown word", { offset: e2[0][2] }, { offset: e2[0][2] + e2[0][1].length });
    }
    unnamedAtrule(e2, r2) {
      throw this.input.error("At-rule without name", { offset: r2[2] }, { offset: r2[2] + r2[1].length });
    }
  };
  Wo2.exports = mi;
});
var $r = S((Wb, Go2) => {
  "use strict";
  var Ed = _e(), Cd = Bo(), Ad = Et();
  function qr2(t2, e2) {
    let r2 = new Ad(t2, e2), n2 = new Cd(r2);
    try {
      n2.parse();
    } catch (i2) {
      throw i2;
    }
    return n2.root;
  }
  Go2.exports = qr2;
  qr2.default = qr2;
  Ed.registerParse(qr2);
});
var vi = S((Gb, Jo2) => {
  "use strict";
  var { isClean: me2, my: _d } = xr(), Td = li(), Pd = yt(), Id = _e(), Rd = Ar(), Bb = ci(), Yo2 = _r(), Dd = $r(), Md = Qe(), Fd = { atrule: "AtRule", comment: "Comment", decl: "Declaration", document: "Document", root: "Root", rule: "Rule" }, Ld = { AtRule: true, AtRuleExit: true, Comment: true, CommentExit: true, Declaration: true, DeclarationExit: true, Document: true, DocumentExit: true, Once: true, OnceExit: true, postcssPlugin: true, prepare: true, Root: true, RootExit: true, Rule: true, RuleExit: true }, Nd = { Once: true, postcssPlugin: true, prepare: true }, Xe2 = 0;
  function Rt2(t2) {
    return typeof t2 == "object" && typeof t2.then == "function";
  }
  function Qo2(t2) {
    let e2 = false, r2 = Fd[t2.type];
    return t2.type === "decl" ? e2 = t2.prop.toLowerCase() : t2.type === "atrule" && (e2 = t2.name.toLowerCase()), e2 && t2.append ? [r2, r2 + "-" + e2, Xe2, r2 + "Exit", r2 + "Exit-" + e2] : e2 ? [r2, r2 + "-" + e2, r2 + "Exit", r2 + "Exit-" + e2] : t2.append ? [r2, Xe2, r2 + "Exit"] : [r2, r2 + "Exit"];
  }
  function Ho2(t2) {
    let e2;
    return t2.type === "document" ? e2 = ["Document", Xe2, "DocumentExit"] : t2.type === "root" ? e2 = ["Root", Xe2, "RootExit"] : e2 = Qo2(t2), { eventIndex: 0, events: e2, iterator: 0, node: t2, visitorIndex: 0, visitors: [] };
  }
  function gi(t2) {
    return t2[me2] = false, t2.nodes && t2.nodes.forEach((e2) => gi(e2)), t2;
  }
  var yi = {}, ge2 = class {
    constructor(e2, r2, n2) {
      this.stringified = false, this.processed = false;
      let i2;
      if (typeof r2 == "object" && r2 !== null && (r2.type === "root" || r2.type === "document"))
        i2 = gi(r2);
      else if (r2 instanceof ge2 || r2 instanceof Yo2)
        i2 = gi(r2.root), r2.map && (typeof n2.map > "u" && (n2.map = {}), n2.map.inline || (n2.map.inline = false), n2.map.prev = r2.map);
      else {
        let a2 = Dd;
        n2.syntax && (a2 = n2.syntax.parse), n2.parser && (a2 = n2.parser), a2.parse && (a2 = a2.parse);
        try {
          i2 = a2(r2, n2);
        } catch (s2) {
          this.processed = true, this.error = s2;
        }
        i2 && !i2[_d] && Id.rebuild(i2);
      }
      this.result = new Yo2(e2, i2, n2), this.helpers = { ...yi, postcss: yi, result: this.result }, this.plugins = this.processor.plugins.map((a2) => typeof a2 == "object" && a2.prepare ? { ...a2, ...a2.prepare(this.result) } : a2);
    }
    async() {
      return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
    }
    catch(e2) {
      return this.async().catch(e2);
    }
    finally(e2) {
      return this.async().then(e2, e2);
    }
    getAsyncError() {
      throw new Error("Use process(css).then(cb) to work with async plugins");
    }
    handleError(e2, r2) {
      let n2 = this.result.lastPlugin;
      try {
        r2 && r2.addToError(e2), this.error = e2, e2.name === "CssSyntaxError" && !e2.plugin ? (e2.plugin = n2.postcssPlugin, e2.setMessage()) : n2.postcssVersion;
      } catch (i2) {
        console && console.error && console.error(i2);
      }
      return e2;
    }
    prepareVisitors() {
      this.listeners = {};
      let e2 = (r2, n2, i2) => {
        this.listeners[n2] || (this.listeners[n2] = []), this.listeners[n2].push([r2, i2]);
      };
      for (let r2 of this.plugins)
        if (typeof r2 == "object")
          for (let n2 in r2) {
            if (!Ld[n2] && /^[A-Z]/.test(n2))
              throw new Error(`Unknown event ${n2} in ${r2.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
            if (!Nd[n2])
              if (typeof r2[n2] == "object")
                for (let i2 in r2[n2])
                  i2 === "*" ? e2(r2, n2, r2[n2][i2]) : e2(r2, n2 + "-" + i2.toLowerCase(), r2[n2][i2]);
              else
                typeof r2[n2] == "function" && e2(r2, n2, r2[n2]);
          }
      this.hasListener = Object.keys(this.listeners).length > 0;
    }
    async runAsync() {
      this.plugin = 0;
      for (let e2 = 0; e2 < this.plugins.length; e2++) {
        let r2 = this.plugins[e2], n2 = this.runOnRoot(r2);
        if (Rt2(n2))
          try {
            await n2;
          } catch (i2) {
            throw this.handleError(i2);
          }
      }
      if (this.prepareVisitors(), this.hasListener) {
        let e2 = this.result.root;
        for (; !e2[me2]; ) {
          e2[me2] = true;
          let r2 = [Ho2(e2)];
          for (; r2.length > 0; ) {
            let n2 = this.visitTick(r2);
            if (Rt2(n2))
              try {
                await n2;
              } catch (i2) {
                let a2 = r2[r2.length - 1].node;
                throw this.handleError(i2, a2);
              }
          }
        }
        if (this.listeners.OnceExit)
          for (let [r2, n2] of this.listeners.OnceExit) {
            this.result.lastPlugin = r2;
            try {
              if (e2.type === "document") {
                let i2 = e2.nodes.map((a2) => n2(a2, this.helpers));
                await Promise.all(i2);
              } else
                await n2(e2, this.helpers);
            } catch (i2) {
              throw this.handleError(i2);
            }
          }
      }
      return this.processed = true, this.stringify();
    }
    runOnRoot(e2) {
      this.result.lastPlugin = e2;
      try {
        if (typeof e2 == "object" && e2.Once) {
          if (this.result.root.type === "document") {
            let r2 = this.result.root.nodes.map((n2) => e2.Once(n2, this.helpers));
            return Rt2(r2[0]) ? Promise.all(r2) : r2;
          }
          return e2.Once(this.result.root, this.helpers);
        } else if (typeof e2 == "function")
          return e2(this.result.root, this.result);
      } catch (r2) {
        throw this.handleError(r2);
      }
    }
    stringify() {
      if (this.error)
        throw this.error;
      if (this.stringified)
        return this.result;
      this.stringified = true, this.sync();
      let e2 = this.result.opts, r2 = Pd;
      e2.syntax && (r2 = e2.syntax.stringify), e2.stringifier && (r2 = e2.stringifier), r2.stringify && (r2 = r2.stringify);
      let i2 = new Td(r2, this.result.root, this.result.opts).generate();
      return this.result.css = i2[0], this.result.map = i2[1], this.result;
    }
    sync() {
      if (this.error)
        throw this.error;
      if (this.processed)
        return this.result;
      if (this.processed = true, this.processing)
        throw this.getAsyncError();
      for (let e2 of this.plugins) {
        let r2 = this.runOnRoot(e2);
        if (Rt2(r2))
          throw this.getAsyncError();
      }
      if (this.prepareVisitors(), this.hasListener) {
        let e2 = this.result.root;
        for (; !e2[me2]; )
          e2[me2] = true, this.walkSync(e2);
        if (this.listeners.OnceExit)
          if (e2.type === "document")
            for (let r2 of e2.nodes)
              this.visitSync(this.listeners.OnceExit, r2);
          else
            this.visitSync(this.listeners.OnceExit, e2);
      }
      return this.result;
    }
    then(e2, r2) {
      return this.async().then(e2, r2);
    }
    toString() {
      return this.css;
    }
    visitSync(e2, r2) {
      for (let [n2, i2] of e2) {
        this.result.lastPlugin = n2;
        let a2;
        try {
          a2 = i2(r2, this.helpers);
        } catch (s2) {
          throw this.handleError(s2, r2.proxyOf);
        }
        if (r2.type !== "root" && r2.type !== "document" && !r2.parent)
          return true;
        if (Rt2(a2))
          throw this.getAsyncError();
      }
    }
    visitTick(e2) {
      let r2 = e2[e2.length - 1], { node: n2, visitors: i2 } = r2;
      if (n2.type !== "root" && n2.type !== "document" && !n2.parent) {
        e2.pop();
        return;
      }
      if (i2.length > 0 && r2.visitorIndex < i2.length) {
        let [s2, o2] = i2[r2.visitorIndex];
        r2.visitorIndex += 1, r2.visitorIndex === i2.length && (r2.visitors = [], r2.visitorIndex = 0), this.result.lastPlugin = s2;
        try {
          return o2(n2.toProxy(), this.helpers);
        } catch (l2) {
          throw this.handleError(l2, n2);
        }
      }
      if (r2.iterator !== 0) {
        let s2 = r2.iterator, o2;
        for (; o2 = n2.nodes[n2.indexes[s2]]; )
          if (n2.indexes[s2] += 1, !o2[me2]) {
            o2[me2] = true, e2.push(Ho2(o2));
            return;
          }
        r2.iterator = 0, delete n2.indexes[s2];
      }
      let a2 = r2.events;
      for (; r2.eventIndex < a2.length; ) {
        let s2 = a2[r2.eventIndex];
        if (r2.eventIndex += 1, s2 === Xe2) {
          n2.nodes && n2.nodes.length && (n2[me2] = true, r2.iterator = n2.getIterator());
          return;
        } else if (this.listeners[s2]) {
          r2.visitors = this.listeners[s2];
          return;
        }
      }
      e2.pop();
    }
    walkSync(e2) {
      e2[me2] = true;
      let r2 = Qo2(e2);
      for (let n2 of r2)
        if (n2 === Xe2)
          e2.nodes && e2.each((i2) => {
            i2[me2] || this.walkSync(i2);
          });
        else {
          let i2 = this.listeners[n2];
          if (i2 && this.visitSync(i2, e2.toProxy()))
            return;
        }
    }
    warnings() {
      return this.sync().warnings();
    }
    get content() {
      return this.stringify().content;
    }
    get css() {
      return this.stringify().css;
    }
    get map() {
      return this.stringify().map;
    }
    get messages() {
      return this.sync().messages;
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      return this.sync().root;
    }
    get [Symbol.toStringTag]() {
      return "LazyResult";
    }
  };
  ge2.registerPostcss = (t2) => {
    yi = t2;
  };
  Jo2.exports = ge2;
  ge2.default = ge2;
  Md.registerLazyResult(ge2);
  Rd.registerLazyResult(ge2);
});
var Ko = S((Hb, Xo2) => {
  "use strict";
  var qd = li(), $d = yt(), Yb = ci(), Ud = $r(), jd = _r(), Dt2 = class {
    constructor(e2, r2, n2) {
      r2 = r2.toString(), this.stringified = false, this._processor = e2, this._css = r2, this._opts = n2, this._map = void 0;
      let i2, a2 = $d;
      this.result = new jd(this._processor, i2, this._opts), this.result.css = r2;
      let s2 = this;
      Object.defineProperty(this.result, "root", { get() {
        return s2.root;
      } });
      let o2 = new qd(a2, i2, this._opts, r2);
      if (o2.isMap()) {
        let [l2, u2] = o2.generate();
        l2 && (this.result.css = l2), u2 && (this.result.map = u2);
      }
    }
    async() {
      return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
    }
    catch(e2) {
      return this.async().catch(e2);
    }
    finally(e2) {
      return this.async().then(e2, e2);
    }
    sync() {
      if (this.error)
        throw this.error;
      return this.result;
    }
    then(e2, r2) {
      return this.async().then(e2, r2);
    }
    toString() {
      return this._css;
    }
    warnings() {
      return [];
    }
    get content() {
      return this.result.css;
    }
    get css() {
      return this.result.css;
    }
    get map() {
      return this.result.map;
    }
    get messages() {
      return [];
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      if (this._root)
        return this._root;
      let e2, r2 = Ud;
      try {
        e2 = r2(this._css, this._opts);
      } catch (n2) {
        this.error = n2;
      }
      if (this.error)
        throw this.error;
      return this._root = e2, e2;
    }
    get [Symbol.toStringTag]() {
      return "NoWorkResult";
    }
  };
  Xo2.exports = Dt2;
  Dt2.default = Dt2;
});
var el = S((Qb, Zo2) => {
  "use strict";
  var zd = Ko(), Vd = vi(), Wd = Ar(), Bd = Qe(), ze2 = class {
    constructor(e2 = []) {
      this.version = "8.4.31", this.plugins = this.normalize(e2);
    }
    normalize(e2) {
      let r2 = [];
      for (let n2 of e2)
        if (n2.postcss === true ? n2 = n2() : n2.postcss && (n2 = n2.postcss), typeof n2 == "object" && Array.isArray(n2.plugins))
          r2 = r2.concat(n2.plugins);
        else if (typeof n2 == "object" && n2.postcssPlugin)
          r2.push(n2);
        else if (typeof n2 == "function")
          r2.push(n2);
        else if (!(typeof n2 == "object" && (n2.parse || n2.stringify)))
          throw new Error(n2 + " is not a PostCSS plugin");
      return r2;
    }
    process(e2, r2 = {}) {
      return this.plugins.length === 0 && typeof r2.parser > "u" && typeof r2.stringifier > "u" && typeof r2.syntax > "u" ? new zd(this, e2, r2) : new Vd(this, e2, r2);
    }
    use(e2) {
      return this.plugins = this.plugins.concat(this.normalize([e2])), this;
    }
  };
  Zo2.exports = ze2;
  ze2.default = ze2;
  Bd.registerProcessor(ze2);
  Wd.registerProcessor(ze2);
});
var rl = S((Jb, tl) => {
  "use strict";
  var Gd = xt(), Yd = ri(), Hd = At(), Qd = Lr(), Jd = Et(), Xd = Qe(), Kd = Nr();
  function Mt2(t2, e2) {
    if (Array.isArray(t2))
      return t2.map((i2) => Mt2(i2));
    let { inputs: r2, ...n2 } = t2;
    if (r2) {
      e2 = [];
      for (let i2 of r2) {
        let a2 = { ...i2, __proto__: Jd.prototype };
        a2.map && (a2.map = { ...a2.map, __proto__: Yd.prototype }), e2.push(a2);
      }
    }
    if (n2.nodes && (n2.nodes = t2.nodes.map((i2) => Mt2(i2, e2))), n2.source) {
      let { inputId: i2, ...a2 } = n2.source;
      n2.source = a2, i2 != null && (n2.source.input = e2[i2]);
    }
    if (n2.type === "root")
      return new Xd(n2);
    if (n2.type === "decl")
      return new Gd(n2);
    if (n2.type === "rule")
      return new Kd(n2);
    if (n2.type === "comment")
      return new Hd(n2);
    if (n2.type === "atrule")
      return new Qd(n2);
    throw new Error("Unknown node type: " + t2.type);
  }
  tl.exports = Mt2;
  Mt2.default = Mt2;
});
var Ke = S((Xb, ul) => {
  "use strict";
  var Zd = br(), nl = xt(), eh = vi(), th = _e(), wi = el(), rh = yt(), nh = rl(), il = Ar(), ih = pi(), sl = At(), al = Lr(), sh = _r(), ah = Et(), oh = $r(), lh = hi(), ol = Nr(), ll = Qe(), uh = wt();
  function N2(...t2) {
    return t2.length === 1 && Array.isArray(t2[0]) && (t2 = t2[0]), new wi(t2);
  }
  N2.plugin = function(e2, r2) {
    let n2 = false;
    function i2(...s2) {
      console && console.warn && !n2 && (n2 = true, console.warn(e2 + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`), process.env.LANG && process.env.LANG.startsWith("cn") && console.warn(e2 + `: é‡Œé¢ postcss.plugin è¢«å¼ƒç”¨. è¿ç§»æŒ‡å—:
https://www.w3ctech.com/topic/2226`));
      let o2 = r2(...s2);
      return o2.postcssPlugin = e2, o2.postcssVersion = new wi().version, o2;
    }
    let a2;
    return Object.defineProperty(i2, "postcss", { get() {
      return a2 || (a2 = i2()), a2;
    } }), i2.process = function(s2, o2, l2) {
      return N2([i2(l2)]).process(s2, o2);
    }, i2;
  };
  N2.stringify = rh;
  N2.parse = oh;
  N2.fromJSON = nh;
  N2.list = lh;
  N2.comment = (t2) => new sl(t2);
  N2.atRule = (t2) => new al(t2);
  N2.decl = (t2) => new nl(t2);
  N2.rule = (t2) => new ol(t2);
  N2.root = (t2) => new ll(t2);
  N2.document = (t2) => new il(t2);
  N2.CssSyntaxError = Zd;
  N2.Declaration = nl;
  N2.Container = th;
  N2.Processor = wi;
  N2.Document = il;
  N2.Comment = sl;
  N2.Warning = ih;
  N2.AtRule = al;
  N2.Result = sh;
  N2.Input = ah;
  N2.Rule = ol;
  N2.Root = ll;
  N2.Node = uh;
  eh.registerPostcss(N2);
  ul.exports = N2;
  N2.default = N2;
});
var jr = S((Ur2, fl) => {
  "use strict";
  Ur2.__esModule = true;
  Ur2.default = ph;
  function fh(t2) {
    for (var e2 = t2.toLowerCase(), r2 = "", n2 = false, i2 = 0; i2 < 6 && e2[i2] !== void 0; i2++) {
      var a2 = e2.charCodeAt(i2), s2 = a2 >= 97 && a2 <= 102 || a2 >= 48 && a2 <= 57;
      if (n2 = a2 === 32, !s2)
        break;
      r2 += e2[i2];
    }
    if (r2.length !== 0) {
      var o2 = parseInt(r2, 16), l2 = o2 >= 55296 && o2 <= 57343;
      return l2 || o2 === 0 || o2 > 1114111 ? ["ï¿½", r2.length + (n2 ? 1 : 0)] : [String.fromCodePoint(o2), r2.length + (n2 ? 1 : 0)];
    }
  }
  var ch = /\\/;
  function ph(t2) {
    var e2 = ch.test(t2);
    if (!e2)
      return t2;
    for (var r2 = "", n2 = 0; n2 < t2.length; n2++) {
      if (t2[n2] === "\\") {
        var i2 = fh(t2.slice(n2 + 1, n2 + 7));
        if (i2 !== void 0) {
          r2 += i2[0], n2 += i2[1];
          continue;
        }
        if (t2[n2 + 1] === "\\") {
          r2 += "\\", n2++;
          continue;
        }
        t2.length === n2 + 1 && (r2 += t2[n2]);
        continue;
      }
      r2 += t2[n2];
    }
    return r2;
  }
  fl.exports = Ur2.default;
});
var pl = S((zr2, cl) => {
  "use strict";
  zr2.__esModule = true;
  zr2.default = dh;
  function dh(t2) {
    for (var e2 = arguments.length, r2 = new Array(e2 > 1 ? e2 - 1 : 0), n2 = 1; n2 < e2; n2++)
      r2[n2 - 1] = arguments[n2];
    for (; r2.length > 0; ) {
      var i2 = r2.shift();
      if (!t2[i2])
        return;
      t2 = t2[i2];
    }
    return t2;
  }
  cl.exports = zr2.default;
});
var hl = S((Vr2, dl) => {
  "use strict";
  Vr2.__esModule = true;
  Vr2.default = hh;
  function hh(t2) {
    for (var e2 = arguments.length, r2 = new Array(e2 > 1 ? e2 - 1 : 0), n2 = 1; n2 < e2; n2++)
      r2[n2 - 1] = arguments[n2];
    for (; r2.length > 0; ) {
      var i2 = r2.shift();
      t2[i2] || (t2[i2] = {}), t2 = t2[i2];
    }
  }
  dl.exports = Vr2.default;
});
var gl = S((Wr2, ml) => {
  "use strict";
  Wr2.__esModule = true;
  Wr2.default = mh;
  function mh(t2) {
    for (var e2 = "", r2 = t2.indexOf("/*"), n2 = 0; r2 >= 0; ) {
      e2 = e2 + t2.slice(n2, r2);
      var i2 = t2.indexOf("*/", r2 + 2);
      if (i2 < 0)
        return e2;
      n2 = i2 + 2, r2 = t2.indexOf("/*", n2);
    }
    return e2 = e2 + t2.slice(n2), e2;
  }
  ml.exports = Wr2.default;
});
var Ft = S((ye) => {
  "use strict";
  ye.__esModule = true;
  ye.unesc = ye.stripComments = ye.getProp = ye.ensureObject = void 0;
  var gh = Br2(jr());
  ye.unesc = gh.default;
  var yh = Br2(pl());
  ye.getProp = yh.default;
  var vh = Br2(hl());
  ye.ensureObject = vh.default;
  var wh = Br2(gl());
  ye.stripComments = wh.default;
  function Br2(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
});
var Oe = S((Lt2, wl) => {
  "use strict";
  Lt2.__esModule = true;
  Lt2.default = void 0;
  var yl = Ft();
  function vl(t2, e2) {
    for (var r2 = 0; r2 < e2.length; r2++) {
      var n2 = e2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
    }
  }
  function bh(t2, e2, r2) {
    return e2 && vl(t2.prototype, e2), r2 && vl(t2, r2), Object.defineProperty(t2, "prototype", { writable: false }), t2;
  }
  var xh = function t2(e2, r2) {
    if (typeof e2 != "object" || e2 === null)
      return e2;
    var n2 = new e2.constructor();
    for (var i2 in e2)
      if (!!e2.hasOwnProperty(i2)) {
        var a2 = e2[i2], s2 = typeof a2;
        i2 === "parent" && s2 === "object" ? r2 && (n2[i2] = r2) : a2 instanceof Array ? n2[i2] = a2.map(function(o2) {
          return t2(o2, n2);
        }) : n2[i2] = t2(a2, n2);
      }
    return n2;
  }, Sh = function() {
    function t2(r2) {
      r2 === void 0 && (r2 = {}), Object.assign(this, r2), this.spaces = this.spaces || {}, this.spaces.before = this.spaces.before || "", this.spaces.after = this.spaces.after || "";
    }
    var e2 = t2.prototype;
    return e2.remove = function() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }, e2.replaceWith = function() {
      if (this.parent) {
        for (var n2 in arguments)
          this.parent.insertBefore(this, arguments[n2]);
        this.remove();
      }
      return this;
    }, e2.next = function() {
      return this.parent.at(this.parent.index(this) + 1);
    }, e2.prev = function() {
      return this.parent.at(this.parent.index(this) - 1);
    }, e2.clone = function(n2) {
      n2 === void 0 && (n2 = {});
      var i2 = xh(this);
      for (var a2 in n2)
        i2[a2] = n2[a2];
      return i2;
    }, e2.appendToPropertyAndEscape = function(n2, i2, a2) {
      this.raws || (this.raws = {});
      var s2 = this[n2], o2 = this.raws[n2];
      this[n2] = s2 + i2, o2 || a2 !== i2 ? this.raws[n2] = (o2 || s2) + a2 : delete this.raws[n2];
    }, e2.setPropertyAndEscape = function(n2, i2, a2) {
      this.raws || (this.raws = {}), this[n2] = i2, this.raws[n2] = a2;
    }, e2.setPropertyWithoutEscape = function(n2, i2) {
      this[n2] = i2, this.raws && delete this.raws[n2];
    }, e2.isAtPosition = function(n2, i2) {
      if (this.source && this.source.start && this.source.end)
        return !(this.source.start.line > n2 || this.source.end.line < n2 || this.source.start.line === n2 && this.source.start.column > i2 || this.source.end.line === n2 && this.source.end.column < i2);
    }, e2.stringifyProperty = function(n2) {
      return this.raws && this.raws[n2] || this[n2];
    }, e2.valueToString = function() {
      return String(this.stringifyProperty("value"));
    }, e2.toString = function() {
      return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
    }, bh(t2, [{ key: "rawSpaceBefore", get: function() {
      var n2 = this.raws && this.raws.spaces && this.raws.spaces.before;
      return n2 === void 0 && (n2 = this.spaces && this.spaces.before), n2 || "";
    }, set: function(n2) {
      (0, yl.ensureObject)(this, "raws", "spaces"), this.raws.spaces.before = n2;
    } }, { key: "rawSpaceAfter", get: function() {
      var n2 = this.raws && this.raws.spaces && this.raws.spaces.after;
      return n2 === void 0 && (n2 = this.spaces.after), n2 || "";
    }, set: function(n2) {
      (0, yl.ensureObject)(this, "raws", "spaces"), this.raws.spaces.after = n2;
    } }]), t2;
  }();
  Lt2.default = Sh;
  wl.exports = Lt2.default;
});
var J = S((U2) => {
  "use strict";
  U2.__esModule = true;
  U2.UNIVERSAL = U2.TAG = U2.STRING = U2.SELECTOR = U2.ROOT = U2.PSEUDO = U2.NESTING = U2.ID = U2.COMMENT = U2.COMBINATOR = U2.CLASS = U2.ATTRIBUTE = void 0;
  var kh = "tag";
  U2.TAG = kh;
  var Oh = "string";
  U2.STRING = Oh;
  var Eh = "selector";
  U2.SELECTOR = Eh;
  var Ch = "root";
  U2.ROOT = Ch;
  var Ah = "pseudo";
  U2.PSEUDO = Ah;
  var _h = "nesting";
  U2.NESTING = _h;
  var Th = "id";
  U2.ID = Th;
  var Ph = "comment";
  U2.COMMENT = Ph;
  var Ih = "combinator";
  U2.COMBINATOR = Ih;
  var Rh = "class";
  U2.CLASS = Rh;
  var Dh = "attribute";
  U2.ATTRIBUTE = Dh;
  var Mh = "universal";
  U2.UNIVERSAL = Mh;
});
var Gr = S((Nt2, kl) => {
  "use strict";
  Nt2.__esModule = true;
  Nt2.default = void 0;
  var Fh = Nh(Oe()), Ee2 = Lh(J());
  function Sl(t2) {
    if (typeof WeakMap != "function")
      return null;
    var e2 = /* @__PURE__ */ new WeakMap(), r2 = /* @__PURE__ */ new WeakMap();
    return (Sl = function(i2) {
      return i2 ? r2 : e2;
    })(t2);
  }
  function Lh(t2, e2) {
    if (!e2 && t2 && t2.__esModule)
      return t2;
    if (t2 === null || typeof t2 != "object" && typeof t2 != "function")
      return { default: t2 };
    var r2 = Sl(e2);
    if (r2 && r2.has(t2))
      return r2.get(t2);
    var n2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a2 in t2)
      if (a2 !== "default" && Object.prototype.hasOwnProperty.call(t2, a2)) {
        var s2 = i2 ? Object.getOwnPropertyDescriptor(t2, a2) : null;
        s2 && (s2.get || s2.set) ? Object.defineProperty(n2, a2, s2) : n2[a2] = t2[a2];
      }
    return n2.default = t2, r2 && r2.set(t2, n2), n2;
  }
  function Nh(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  function qh(t2, e2) {
    var r2 = typeof Symbol < "u" && t2[Symbol.iterator] || t2["@@iterator"];
    if (r2)
      return (r2 = r2.call(t2)).next.bind(r2);
    if (Array.isArray(t2) || (r2 = $h(t2)) || e2 && t2 && typeof t2.length == "number") {
      r2 && (t2 = r2);
      var n2 = 0;
      return function() {
        return n2 >= t2.length ? { done: true } : { done: false, value: t2[n2++] };
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function $h(t2, e2) {
    if (!!t2) {
      if (typeof t2 == "string")
        return bl(t2, e2);
      var r2 = Object.prototype.toString.call(t2).slice(8, -1);
      if (r2 === "Object" && t2.constructor && (r2 = t2.constructor.name), r2 === "Map" || r2 === "Set")
        return Array.from(t2);
      if (r2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
        return bl(t2, e2);
    }
  }
  function bl(t2, e2) {
    (e2 == null || e2 > t2.length) && (e2 = t2.length);
    for (var r2 = 0, n2 = new Array(e2); r2 < e2; r2++)
      n2[r2] = t2[r2];
    return n2;
  }
  function xl(t2, e2) {
    for (var r2 = 0; r2 < e2.length; r2++) {
      var n2 = e2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
    }
  }
  function Uh(t2, e2, r2) {
    return e2 && xl(t2.prototype, e2), r2 && xl(t2, r2), Object.defineProperty(t2, "prototype", { writable: false }), t2;
  }
  function jh(t2, e2) {
    t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, bi(t2, e2);
  }
  function bi(t2, e2) {
    return bi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i2) {
      return n2.__proto__ = i2, n2;
    }, bi(t2, e2);
  }
  var zh = function(t2) {
    jh(e2, t2);
    function e2(n2) {
      var i2;
      return i2 = t2.call(this, n2) || this, i2.nodes || (i2.nodes = []), i2;
    }
    var r2 = e2.prototype;
    return r2.append = function(i2) {
      return i2.parent = this, this.nodes.push(i2), this;
    }, r2.prepend = function(i2) {
      return i2.parent = this, this.nodes.unshift(i2), this;
    }, r2.at = function(i2) {
      return this.nodes[i2];
    }, r2.index = function(i2) {
      return typeof i2 == "number" ? i2 : this.nodes.indexOf(i2);
    }, r2.removeChild = function(i2) {
      i2 = this.index(i2), this.at(i2).parent = void 0, this.nodes.splice(i2, 1);
      var a2;
      for (var s2 in this.indexes)
        a2 = this.indexes[s2], a2 >= i2 && (this.indexes[s2] = a2 - 1);
      return this;
    }, r2.removeAll = function() {
      for (var i2 = qh(this.nodes), a2; !(a2 = i2()).done; ) {
        var s2 = a2.value;
        s2.parent = void 0;
      }
      return this.nodes = [], this;
    }, r2.empty = function() {
      return this.removeAll();
    }, r2.insertAfter = function(i2, a2) {
      a2.parent = this;
      var s2 = this.index(i2);
      this.nodes.splice(s2 + 1, 0, a2), a2.parent = this;
      var o2;
      for (var l2 in this.indexes)
        o2 = this.indexes[l2], s2 <= o2 && (this.indexes[l2] = o2 + 1);
      return this;
    }, r2.insertBefore = function(i2, a2) {
      a2.parent = this;
      var s2 = this.index(i2);
      this.nodes.splice(s2, 0, a2), a2.parent = this;
      var o2;
      for (var l2 in this.indexes)
        o2 = this.indexes[l2], o2 <= s2 && (this.indexes[l2] = o2 + 1);
      return this;
    }, r2._findChildAtPosition = function(i2, a2) {
      var s2 = void 0;
      return this.each(function(o2) {
        if (o2.atPosition) {
          var l2 = o2.atPosition(i2, a2);
          if (l2)
            return s2 = l2, false;
        } else if (o2.isAtPosition(i2, a2))
          return s2 = o2, false;
      }), s2;
    }, r2.atPosition = function(i2, a2) {
      if (this.isAtPosition(i2, a2))
        return this._findChildAtPosition(i2, a2) || this;
    }, r2._inferEndPosition = function() {
      this.last && this.last.source && this.last.source.end && (this.source = this.source || {}, this.source.end = this.source.end || {}, Object.assign(this.source.end, this.last.source.end));
    }, r2.each = function(i2) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
      var a2 = this.lastEach;
      if (this.indexes[a2] = 0, !!this.length) {
        for (var s2, o2; this.indexes[a2] < this.length && (s2 = this.indexes[a2], o2 = i2(this.at(s2), s2), o2 !== false); )
          this.indexes[a2] += 1;
        if (delete this.indexes[a2], o2 === false)
          return false;
      }
    }, r2.walk = function(i2) {
      return this.each(function(a2, s2) {
        var o2 = i2(a2, s2);
        if (o2 !== false && a2.length && (o2 = a2.walk(i2)), o2 === false)
          return false;
      });
    }, r2.walkAttributes = function(i2) {
      var a2 = this;
      return this.walk(function(s2) {
        if (s2.type === Ee2.ATTRIBUTE)
          return i2.call(a2, s2);
      });
    }, r2.walkClasses = function(i2) {
      var a2 = this;
      return this.walk(function(s2) {
        if (s2.type === Ee2.CLASS)
          return i2.call(a2, s2);
      });
    }, r2.walkCombinators = function(i2) {
      var a2 = this;
      return this.walk(function(s2) {
        if (s2.type === Ee2.COMBINATOR)
          return i2.call(a2, s2);
      });
    }, r2.walkComments = function(i2) {
      var a2 = this;
      return this.walk(function(s2) {
        if (s2.type === Ee2.COMMENT)
          return i2.call(a2, s2);
      });
    }, r2.walkIds = function(i2) {
      var a2 = this;
      return this.walk(function(s2) {
        if (s2.type === Ee2.ID)
          return i2.call(a2, s2);
      });
    }, r2.walkNesting = function(i2) {
      var a2 = this;
      return this.walk(function(s2) {
        if (s2.type === Ee2.NESTING)
          return i2.call(a2, s2);
      });
    }, r2.walkPseudos = function(i2) {
      var a2 = this;
      return this.walk(function(s2) {
        if (s2.type === Ee2.PSEUDO)
          return i2.call(a2, s2);
      });
    }, r2.walkTags = function(i2) {
      var a2 = this;
      return this.walk(function(s2) {
        if (s2.type === Ee2.TAG)
          return i2.call(a2, s2);
      });
    }, r2.walkUniversals = function(i2) {
      var a2 = this;
      return this.walk(function(s2) {
        if (s2.type === Ee2.UNIVERSAL)
          return i2.call(a2, s2);
      });
    }, r2.split = function(i2) {
      var a2 = this, s2 = [];
      return this.reduce(function(o2, l2, u2) {
        var f2 = i2.call(a2, l2);
        return s2.push(l2), f2 ? (o2.push(s2), s2 = []) : u2 === a2.length - 1 && o2.push(s2), o2;
      }, []);
    }, r2.map = function(i2) {
      return this.nodes.map(i2);
    }, r2.reduce = function(i2, a2) {
      return this.nodes.reduce(i2, a2);
    }, r2.every = function(i2) {
      return this.nodes.every(i2);
    }, r2.some = function(i2) {
      return this.nodes.some(i2);
    }, r2.filter = function(i2) {
      return this.nodes.filter(i2);
    }, r2.sort = function(i2) {
      return this.nodes.sort(i2);
    }, r2.toString = function() {
      return this.map(String).join("");
    }, Uh(e2, [{ key: "first", get: function() {
      return this.at(0);
    } }, { key: "last", get: function() {
      return this.at(this.length - 1);
    } }, { key: "length", get: function() {
      return this.nodes.length;
    } }]), e2;
  }(Fh.default);
  Nt2.default = zh;
  kl.exports = Nt2.default;
});
var Si = S((qt2, El) => {
  "use strict";
  qt2.__esModule = true;
  qt2.default = void 0;
  var Vh = Bh(Gr()), Wh = J();
  function Bh(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  function Ol(t2, e2) {
    for (var r2 = 0; r2 < e2.length; r2++) {
      var n2 = e2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
    }
  }
  function Gh(t2, e2, r2) {
    return e2 && Ol(t2.prototype, e2), r2 && Ol(t2, r2), Object.defineProperty(t2, "prototype", { writable: false }), t2;
  }
  function Yh(t2, e2) {
    t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, xi(t2, e2);
  }
  function xi(t2, e2) {
    return xi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i2) {
      return n2.__proto__ = i2, n2;
    }, xi(t2, e2);
  }
  var Hh = function(t2) {
    Yh(e2, t2);
    function e2(n2) {
      var i2;
      return i2 = t2.call(this, n2) || this, i2.type = Wh.ROOT, i2;
    }
    var r2 = e2.prototype;
    return r2.toString = function() {
      var i2 = this.reduce(function(a2, s2) {
        return a2.push(String(s2)), a2;
      }, []).join(",");
      return this.trailingComma ? i2 + "," : i2;
    }, r2.error = function(i2, a2) {
      return this._error ? this._error(i2, a2) : new Error(i2);
    }, Gh(e2, [{ key: "errorGenerator", set: function(i2) {
      this._error = i2;
    } }]), e2;
  }(Vh.default);
  qt2.default = Hh;
  El.exports = qt2.default;
});
var Oi = S(($t2, Cl) => {
  "use strict";
  $t2.__esModule = true;
  $t2.default = void 0;
  var Qh = Xh(Gr()), Jh = J();
  function Xh(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  function Kh(t2, e2) {
    t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, ki(t2, e2);
  }
  function ki(t2, e2) {
    return ki = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i2) {
      return n2.__proto__ = i2, n2;
    }, ki(t2, e2);
  }
  var Zh = function(t2) {
    Kh(e2, t2);
    function e2(r2) {
      var n2;
      return n2 = t2.call(this, r2) || this, n2.type = Jh.SELECTOR, n2;
    }
    return e2;
  }(Qh.default);
  $t2.default = Zh;
  Cl.exports = $t2.default;
});
var Yr = S((Ex, Al) => {
  "use strict";
  var em = {}, tm = em.hasOwnProperty, rm = function(e2, r2) {
    if (!e2)
      return r2;
    var n2 = {};
    for (var i2 in r2)
      n2[i2] = tm.call(e2, i2) ? e2[i2] : r2[i2];
    return n2;
  }, nm = /[ -,\.\/:-@\[-\^`\{-~]/, im = /[ -,\.\/:-@\[\]\^`\{-~]/, sm = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g, Ei = function t2(e2, r2) {
    r2 = rm(r2, t2.options), r2.quotes != "single" && r2.quotes != "double" && (r2.quotes = "single");
    for (var n2 = r2.quotes == "double" ? '"' : "'", i2 = r2.isIdentifier, a2 = e2.charAt(0), s2 = "", o2 = 0, l2 = e2.length; o2 < l2; ) {
      var u2 = e2.charAt(o2++), f2 = u2.charCodeAt(), p2 = void 0;
      if (f2 < 32 || f2 > 126) {
        if (f2 >= 55296 && f2 <= 56319 && o2 < l2) {
          var c2 = e2.charCodeAt(o2++);
          (c2 & 64512) == 56320 ? f2 = ((f2 & 1023) << 10) + (c2 & 1023) + 65536 : o2--;
        }
        p2 = "\\" + f2.toString(16).toUpperCase() + " ";
      } else
        r2.escapeEverything ? nm.test(u2) ? p2 = "\\" + u2 : p2 = "\\" + f2.toString(16).toUpperCase() + " " : /[\t\n\f\r\x0B]/.test(u2) ? p2 = "\\" + f2.toString(16).toUpperCase() + " " : u2 == "\\" || !i2 && (u2 == '"' && n2 == u2 || u2 == "'" && n2 == u2) || i2 && im.test(u2) ? p2 = "\\" + u2 : p2 = u2;
      s2 += p2;
    }
    return i2 && (/^-[-\d]/.test(s2) ? s2 = "\\-" + s2.slice(1) : /\d/.test(a2) && (s2 = "\\3" + a2 + " " + s2.slice(1))), s2 = s2.replace(sm, function(d2, h2, y3) {
      return h2 && h2.length % 2 ? d2 : (h2 || "") + y3;
    }), !i2 && r2.wrap ? n2 + s2 + n2 : s2;
  };
  Ei.options = { escapeEverything: false, isIdentifier: false, quotes: "single", wrap: false };
  Ei.version = "3.0.0";
  Al.exports = Ei;
});
var Ai = S((Ut2, Pl) => {
  "use strict";
  Ut2.__esModule = true;
  Ut2.default = void 0;
  var am = Tl(Yr()), om = Ft(), lm = Tl(Oe()), um = J();
  function Tl(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  function _l(t2, e2) {
    for (var r2 = 0; r2 < e2.length; r2++) {
      var n2 = e2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
    }
  }
  function fm(t2, e2, r2) {
    return e2 && _l(t2.prototype, e2), r2 && _l(t2, r2), Object.defineProperty(t2, "prototype", { writable: false }), t2;
  }
  function cm(t2, e2) {
    t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, Ci(t2, e2);
  }
  function Ci(t2, e2) {
    return Ci = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i2) {
      return n2.__proto__ = i2, n2;
    }, Ci(t2, e2);
  }
  var pm = function(t2) {
    cm(e2, t2);
    function e2(n2) {
      var i2;
      return i2 = t2.call(this, n2) || this, i2.type = um.CLASS, i2._constructed = true, i2;
    }
    var r2 = e2.prototype;
    return r2.valueToString = function() {
      return "." + t2.prototype.valueToString.call(this);
    }, fm(e2, [{ key: "value", get: function() {
      return this._value;
    }, set: function(i2) {
      if (this._constructed) {
        var a2 = (0, am.default)(i2, { isIdentifier: true });
        a2 !== i2 ? ((0, om.ensureObject)(this, "raws"), this.raws.value = a2) : this.raws && delete this.raws.value;
      }
      this._value = i2;
    } }]), e2;
  }(lm.default);
  Ut2.default = pm;
  Pl.exports = Ut2.default;
});
var Ti = S((jt2, Il) => {
  "use strict";
  jt2.__esModule = true;
  jt2.default = void 0;
  var dm = mm(Oe()), hm = J();
  function mm(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  function gm(t2, e2) {
    t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, _i(t2, e2);
  }
  function _i(t2, e2) {
    return _i = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i2) {
      return n2.__proto__ = i2, n2;
    }, _i(t2, e2);
  }
  var ym = function(t2) {
    gm(e2, t2);
    function e2(r2) {
      var n2;
      return n2 = t2.call(this, r2) || this, n2.type = hm.COMMENT, n2;
    }
    return e2;
  }(dm.default);
  jt2.default = ym;
  Il.exports = jt2.default;
});
var Ii = S((zt2, Rl) => {
  "use strict";
  zt2.__esModule = true;
  zt2.default = void 0;
  var vm = bm(Oe()), wm = J();
  function bm(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  function xm(t2, e2) {
    t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, Pi(t2, e2);
  }
  function Pi(t2, e2) {
    return Pi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i2) {
      return n2.__proto__ = i2, n2;
    }, Pi(t2, e2);
  }
  var Sm = function(t2) {
    xm(e2, t2);
    function e2(n2) {
      var i2;
      return i2 = t2.call(this, n2) || this, i2.type = wm.ID, i2;
    }
    var r2 = e2.prototype;
    return r2.valueToString = function() {
      return "#" + t2.prototype.valueToString.call(this);
    }, e2;
  }(vm.default);
  zt2.default = Sm;
  Rl.exports = zt2.default;
});
var Hr = S((Vt2, Fl) => {
  "use strict";
  Vt2.__esModule = true;
  Vt2.default = void 0;
  var km = Ml(Yr()), Om = Ft(), Em = Ml(Oe());
  function Ml(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  function Dl(t2, e2) {
    for (var r2 = 0; r2 < e2.length; r2++) {
      var n2 = e2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
    }
  }
  function Cm(t2, e2, r2) {
    return e2 && Dl(t2.prototype, e2), r2 && Dl(t2, r2), Object.defineProperty(t2, "prototype", { writable: false }), t2;
  }
  function Am(t2, e2) {
    t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, Ri(t2, e2);
  }
  function Ri(t2, e2) {
    return Ri = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i2) {
      return n2.__proto__ = i2, n2;
    }, Ri(t2, e2);
  }
  var _m = function(t2) {
    Am(e2, t2);
    function e2() {
      return t2.apply(this, arguments) || this;
    }
    var r2 = e2.prototype;
    return r2.qualifiedName = function(i2) {
      return this.namespace ? this.namespaceString + "|" + i2 : i2;
    }, r2.valueToString = function() {
      return this.qualifiedName(t2.prototype.valueToString.call(this));
    }, Cm(e2, [{ key: "namespace", get: function() {
      return this._namespace;
    }, set: function(i2) {
      if (i2 === true || i2 === "*" || i2 === "&") {
        this._namespace = i2, this.raws && delete this.raws.namespace;
        return;
      }
      var a2 = (0, km.default)(i2, { isIdentifier: true });
      this._namespace = i2, a2 !== i2 ? ((0, Om.ensureObject)(this, "raws"), this.raws.namespace = a2) : this.raws && delete this.raws.namespace;
    } }, { key: "ns", get: function() {
      return this._namespace;
    }, set: function(i2) {
      this.namespace = i2;
    } }, { key: "namespaceString", get: function() {
      if (this.namespace) {
        var i2 = this.stringifyProperty("namespace");
        return i2 === true ? "" : i2;
      } else
        return "";
    } }]), e2;
  }(Em.default);
  Vt2.default = _m;
  Fl.exports = Vt2.default;
});
var Mi = S((Wt2, Ll) => {
  "use strict";
  Wt2.__esModule = true;
  Wt2.default = void 0;
  var Tm = Im(Hr()), Pm = J();
  function Im(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  function Rm(t2, e2) {
    t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, Di2(t2, e2);
  }
  function Di2(t2, e2) {
    return Di2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i2) {
      return n2.__proto__ = i2, n2;
    }, Di2(t2, e2);
  }
  var Dm = function(t2) {
    Rm(e2, t2);
    function e2(r2) {
      var n2;
      return n2 = t2.call(this, r2) || this, n2.type = Pm.TAG, n2;
    }
    return e2;
  }(Tm.default);
  Wt2.default = Dm;
  Ll.exports = Wt2.default;
});
var Li = S((Bt2, Nl) => {
  "use strict";
  Bt2.__esModule = true;
  Bt2.default = void 0;
  var Mm = Lm(Oe()), Fm = J();
  function Lm(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  function Nm(t2, e2) {
    t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, Fi(t2, e2);
  }
  function Fi(t2, e2) {
    return Fi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i2) {
      return n2.__proto__ = i2, n2;
    }, Fi(t2, e2);
  }
  var qm = function(t2) {
    Nm(e2, t2);
    function e2(r2) {
      var n2;
      return n2 = t2.call(this, r2) || this, n2.type = Fm.STRING, n2;
    }
    return e2;
  }(Mm.default);
  Bt2.default = qm;
  Nl.exports = Bt2.default;
});
var qi = S((Gt2, ql) => {
  "use strict";
  Gt2.__esModule = true;
  Gt2.default = void 0;
  var $m = jm(Gr()), Um = J();
  function jm(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  function zm(t2, e2) {
    t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, Ni(t2, e2);
  }
  function Ni(t2, e2) {
    return Ni = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i2) {
      return n2.__proto__ = i2, n2;
    }, Ni(t2, e2);
  }
  var Vm = function(t2) {
    zm(e2, t2);
    function e2(n2) {
      var i2;
      return i2 = t2.call(this, n2) || this, i2.type = Um.PSEUDO, i2;
    }
    var r2 = e2.prototype;
    return r2.toString = function() {
      var i2 = this.length ? "(" + this.map(String).join(",") + ")" : "";
      return [this.rawSpaceBefore, this.stringifyProperty("value"), i2, this.rawSpaceAfter].join("");
    }, e2;
  }($m.default);
  Gt2.default = Vm;
  ql.exports = Gt2.default;
});
var Ul = S((Cx, $l) => {
  $l.exports = Wm;
  function Wm(t2, e2) {
    if ($i("noDeprecation"))
      return t2;
    var r2 = false;
    function n2() {
      if (!r2) {
        if ($i("throwDeprecation"))
          throw new Error(e2);
        $i("traceDeprecation") ? console.trace(e2) : console.warn(e2), r2 = true;
      }
      return t2.apply(this, arguments);
    }
    return n2;
  }
  function $i(t2) {
    try {
      if (!global.localStorage)
        return false;
    } catch {
      return false;
    }
    var e2 = global.localStorage[t2];
    return e2 == null ? false : String(e2).toLowerCase() === "true";
  }
});
var Bi = S((Qt2) => {
  "use strict";
  Qt2.__esModule = true;
  Qt2.default = void 0;
  Qt2.unescapeValue = Wi;
  var Yt2 = Vi(Yr()), Bm = Vi(jr()), Gm = Vi(Hr()), Ym = J(), Ui;
  function Vi(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  function jl(t2, e2) {
    for (var r2 = 0; r2 < e2.length; r2++) {
      var n2 = e2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
    }
  }
  function Hm(t2, e2, r2) {
    return e2 && jl(t2.prototype, e2), r2 && jl(t2, r2), Object.defineProperty(t2, "prototype", { writable: false }), t2;
  }
  function Qm(t2, e2) {
    t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, zi(t2, e2);
  }
  function zi(t2, e2) {
    return zi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i2) {
      return n2.__proto__ = i2, n2;
    }, zi(t2, e2);
  }
  var Ht2 = Ul(), Jm = /^('|")([^]*)\1$/, Xm = Ht2(function() {
  }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead."), Km = Ht2(function() {
  }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead."), Zm = Ht2(function() {
  }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
  function Wi(t2) {
    var e2 = false, r2 = null, n2 = t2, i2 = n2.match(Jm);
    return i2 && (r2 = i2[1], n2 = i2[2]), n2 = (0, Bm.default)(n2), n2 !== t2 && (e2 = true), { deprecatedUsage: e2, unescaped: n2, quoteMark: r2 };
  }
  function eg(t2) {
    if (t2.quoteMark !== void 0 || t2.value === void 0)
      return t2;
    Zm();
    var e2 = Wi(t2.value), r2 = e2.quoteMark, n2 = e2.unescaped;
    return t2.raws || (t2.raws = {}), t2.raws.value === void 0 && (t2.raws.value = t2.value), t2.value = n2, t2.quoteMark = r2, t2;
  }
  var Qr2 = function(t2) {
    Qm(e2, t2);
    function e2(n2) {
      var i2;
      return n2 === void 0 && (n2 = {}), i2 = t2.call(this, eg(n2)) || this, i2.type = Ym.ATTRIBUTE, i2.raws = i2.raws || {}, Object.defineProperty(i2.raws, "unquoted", { get: Ht2(function() {
        return i2.value;
      }, "attr.raws.unquoted is deprecated. Call attr.value instead."), set: Ht2(function() {
        return i2.value;
      }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.") }), i2._constructed = true, i2;
    }
    var r2 = e2.prototype;
    return r2.getQuotedValue = function(i2) {
      i2 === void 0 && (i2 = {});
      var a2 = this._determineQuoteMark(i2), s2 = ji[a2], o2 = (0, Yt2.default)(this._value, s2);
      return o2;
    }, r2._determineQuoteMark = function(i2) {
      return i2.smart ? this.smartQuoteMark(i2) : this.preferredQuoteMark(i2);
    }, r2.setValue = function(i2, a2) {
      a2 === void 0 && (a2 = {}), this._value = i2, this._quoteMark = this._determineQuoteMark(a2), this._syncRawValue();
    }, r2.smartQuoteMark = function(i2) {
      var a2 = this.value, s2 = a2.replace(/[^']/g, "").length, o2 = a2.replace(/[^"]/g, "").length;
      if (s2 + o2 === 0) {
        var l2 = (0, Yt2.default)(a2, { isIdentifier: true });
        if (l2 === a2)
          return e2.NO_QUOTE;
        var u2 = this.preferredQuoteMark(i2);
        if (u2 === e2.NO_QUOTE) {
          var f2 = this.quoteMark || i2.quoteMark || e2.DOUBLE_QUOTE, p2 = ji[f2], c2 = (0, Yt2.default)(a2, p2);
          if (c2.length < l2.length)
            return f2;
        }
        return u2;
      } else
        return o2 === s2 ? this.preferredQuoteMark(i2) : o2 < s2 ? e2.DOUBLE_QUOTE : e2.SINGLE_QUOTE;
    }, r2.preferredQuoteMark = function(i2) {
      var a2 = i2.preferCurrentQuoteMark ? this.quoteMark : i2.quoteMark;
      return a2 === void 0 && (a2 = i2.preferCurrentQuoteMark ? i2.quoteMark : this.quoteMark), a2 === void 0 && (a2 = e2.DOUBLE_QUOTE), a2;
    }, r2._syncRawValue = function() {
      var i2 = (0, Yt2.default)(this._value, ji[this.quoteMark]);
      i2 === this._value ? this.raws && delete this.raws.value : this.raws.value = i2;
    }, r2._handleEscapes = function(i2, a2) {
      if (this._constructed) {
        var s2 = (0, Yt2.default)(a2, { isIdentifier: true });
        s2 !== a2 ? this.raws[i2] = s2 : delete this.raws[i2];
      }
    }, r2._spacesFor = function(i2) {
      var a2 = { before: "", after: "" }, s2 = this.spaces[i2] || {}, o2 = this.raws.spaces && this.raws.spaces[i2] || {};
      return Object.assign(a2, s2, o2);
    }, r2._stringFor = function(i2, a2, s2) {
      a2 === void 0 && (a2 = i2), s2 === void 0 && (s2 = zl);
      var o2 = this._spacesFor(a2);
      return s2(this.stringifyProperty(i2), o2);
    }, r2.offsetOf = function(i2) {
      var a2 = 1, s2 = this._spacesFor("attribute");
      if (a2 += s2.before.length, i2 === "namespace" || i2 === "ns")
        return this.namespace ? a2 : -1;
      if (i2 === "attributeNS" || (a2 += this.namespaceString.length, this.namespace && (a2 += 1), i2 === "attribute"))
        return a2;
      a2 += this.stringifyProperty("attribute").length, a2 += s2.after.length;
      var o2 = this._spacesFor("operator");
      a2 += o2.before.length;
      var l2 = this.stringifyProperty("operator");
      if (i2 === "operator")
        return l2 ? a2 : -1;
      a2 += l2.length, a2 += o2.after.length;
      var u2 = this._spacesFor("value");
      a2 += u2.before.length;
      var f2 = this.stringifyProperty("value");
      if (i2 === "value")
        return f2 ? a2 : -1;
      a2 += f2.length, a2 += u2.after.length;
      var p2 = this._spacesFor("insensitive");
      return a2 += p2.before.length, i2 === "insensitive" && this.insensitive ? a2 : -1;
    }, r2.toString = function() {
      var i2 = this, a2 = [this.rawSpaceBefore, "["];
      return a2.push(this._stringFor("qualifiedAttribute", "attribute")), this.operator && (this.value || this.value === "") && (a2.push(this._stringFor("operator")), a2.push(this._stringFor("value")), a2.push(this._stringFor("insensitiveFlag", "insensitive", function(s2, o2) {
        return s2.length > 0 && !i2.quoted && o2.before.length === 0 && !(i2.spaces.value && i2.spaces.value.after) && (o2.before = " "), zl(s2, o2);
      }))), a2.push("]"), a2.push(this.rawSpaceAfter), a2.join("");
    }, Hm(e2, [{ key: "quoted", get: function() {
      var i2 = this.quoteMark;
      return i2 === "'" || i2 === '"';
    }, set: function(i2) {
      Km();
    } }, { key: "quoteMark", get: function() {
      return this._quoteMark;
    }, set: function(i2) {
      if (!this._constructed) {
        this._quoteMark = i2;
        return;
      }
      this._quoteMark !== i2 && (this._quoteMark = i2, this._syncRawValue());
    } }, { key: "qualifiedAttribute", get: function() {
      return this.qualifiedName(this.raws.attribute || this.attribute);
    } }, { key: "insensitiveFlag", get: function() {
      return this.insensitive ? "i" : "";
    } }, { key: "value", get: function() {
      return this._value;
    }, set: function(i2) {
      if (this._constructed) {
        var a2 = Wi(i2), s2 = a2.deprecatedUsage, o2 = a2.unescaped, l2 = a2.quoteMark;
        if (s2 && Xm(), o2 === this._value && l2 === this._quoteMark)
          return;
        this._value = o2, this._quoteMark = l2, this._syncRawValue();
      } else
        this._value = i2;
    } }, { key: "insensitive", get: function() {
      return this._insensitive;
    }, set: function(i2) {
      i2 || (this._insensitive = false, this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i") && (this.raws.insensitiveFlag = void 0)), this._insensitive = i2;
    } }, { key: "attribute", get: function() {
      return this._attribute;
    }, set: function(i2) {
      this._handleEscapes("attribute", i2), this._attribute = i2;
    } }]), e2;
  }(Gm.default);
  Qt2.default = Qr2;
  Qr2.NO_QUOTE = null;
  Qr2.SINGLE_QUOTE = "'";
  Qr2.DOUBLE_QUOTE = '"';
  var ji = (Ui = { "'": { quotes: "single", wrap: true }, '"': { quotes: "double", wrap: true } }, Ui[null] = { isIdentifier: true }, Ui);
  function zl(t2, e2) {
    return "" + e2.before + t2 + e2.after;
  }
});
var Yi = S((Jt2, Vl) => {
  "use strict";
  Jt2.__esModule = true;
  Jt2.default = void 0;
  var tg = ng(Hr()), rg = J();
  function ng(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  function ig(t2, e2) {
    t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, Gi(t2, e2);
  }
  function Gi(t2, e2) {
    return Gi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i2) {
      return n2.__proto__ = i2, n2;
    }, Gi(t2, e2);
  }
  var sg = function(t2) {
    ig(e2, t2);
    function e2(r2) {
      var n2;
      return n2 = t2.call(this, r2) || this, n2.type = rg.UNIVERSAL, n2.value = "*", n2;
    }
    return e2;
  }(tg.default);
  Jt2.default = sg;
  Vl.exports = Jt2.default;
});
var Qi = S((Xt, Wl) => {
  "use strict";
  Xt.__esModule = true;
  Xt.default = void 0;
  var ag = lg(Oe()), og = J();
  function lg(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  function ug(t2, e2) {
    t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, Hi(t2, e2);
  }
  function Hi(t2, e2) {
    return Hi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i2) {
      return n2.__proto__ = i2, n2;
    }, Hi(t2, e2);
  }
  var fg = function(t2) {
    ug(e2, t2);
    function e2(r2) {
      var n2;
      return n2 = t2.call(this, r2) || this, n2.type = og.COMBINATOR, n2;
    }
    return e2;
  }(ag.default);
  Xt.default = fg;
  Wl.exports = Xt.default;
});
var Xi = S((Kt2, Bl) => {
  "use strict";
  Kt2.__esModule = true;
  Kt2.default = void 0;
  var cg = dg(Oe()), pg = J();
  function dg(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  function hg(t2, e2) {
    t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, Ji(t2, e2);
  }
  function Ji(t2, e2) {
    return Ji = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i2) {
      return n2.__proto__ = i2, n2;
    }, Ji(t2, e2);
  }
  var mg = function(t2) {
    hg(e2, t2);
    function e2(r2) {
      var n2;
      return n2 = t2.call(this, r2) || this, n2.type = pg.NESTING, n2.value = "&", n2;
    }
    return e2;
  }(cg.default);
  Kt2.default = mg;
  Bl.exports = Kt2.default;
});
var Yl = S((Jr2, Gl) => {
  "use strict";
  Jr2.__esModule = true;
  Jr2.default = gg;
  function gg(t2) {
    return t2.sort(function(e2, r2) {
      return e2 - r2;
    });
  }
  Gl.exports = Jr2.default;
});
var Ki = S((P2) => {
  "use strict";
  P2.__esModule = true;
  P2.word = P2.tilde = P2.tab = P2.str = P2.space = P2.slash = P2.singleQuote = P2.semicolon = P2.plus = P2.pipe = P2.openSquare = P2.openParenthesis = P2.newline = P2.greaterThan = P2.feed = P2.equals = P2.doubleQuote = P2.dollar = P2.cr = P2.comment = P2.comma = P2.combinator = P2.colon = P2.closeSquare = P2.closeParenthesis = P2.caret = P2.bang = P2.backslash = P2.at = P2.asterisk = P2.ampersand = void 0;
  var yg = 38;
  P2.ampersand = yg;
  var vg = 42;
  P2.asterisk = vg;
  var wg = 64;
  P2.at = wg;
  var bg = 44;
  P2.comma = bg;
  var xg = 58;
  P2.colon = xg;
  var Sg = 59;
  P2.semicolon = Sg;
  var kg = 40;
  P2.openParenthesis = kg;
  var Og = 41;
  P2.closeParenthesis = Og;
  var Eg = 91;
  P2.openSquare = Eg;
  var Cg = 93;
  P2.closeSquare = Cg;
  var Ag = 36;
  P2.dollar = Ag;
  var _g = 126;
  P2.tilde = _g;
  var Tg = 94;
  P2.caret = Tg;
  var Pg = 43;
  P2.plus = Pg;
  var Ig = 61;
  P2.equals = Ig;
  var Rg = 124;
  P2.pipe = Rg;
  var Dg = 62;
  P2.greaterThan = Dg;
  var Mg = 32;
  P2.space = Mg;
  var Hl = 39;
  P2.singleQuote = Hl;
  var Fg = 34;
  P2.doubleQuote = Fg;
  var Lg = 47;
  P2.slash = Lg;
  var Ng = 33;
  P2.bang = Ng;
  var qg = 92;
  P2.backslash = qg;
  var $g = 13;
  P2.cr = $g;
  var Ug = 12;
  P2.feed = Ug;
  var jg = 10;
  P2.newline = jg;
  var zg = 9;
  P2.tab = zg;
  var Vg = Hl;
  P2.str = Vg;
  var Wg = -1;
  P2.comment = Wg;
  var Bg = -2;
  P2.word = Bg;
  var Gg = -3;
  P2.combinator = Gg;
});
var Xl = S((Zt) => {
  "use strict";
  Zt.__esModule = true;
  Zt.FIELDS = void 0;
  Zt.default = Zg;
  var C = Yg(Ki()), Ze2, q2;
  function Jl(t2) {
    if (typeof WeakMap != "function")
      return null;
    var e2 = /* @__PURE__ */ new WeakMap(), r2 = /* @__PURE__ */ new WeakMap();
    return (Jl = function(i2) {
      return i2 ? r2 : e2;
    })(t2);
  }
  function Yg(t2, e2) {
    if (!e2 && t2 && t2.__esModule)
      return t2;
    if (t2 === null || typeof t2 != "object" && typeof t2 != "function")
      return { default: t2 };
    var r2 = Jl(e2);
    if (r2 && r2.has(t2))
      return r2.get(t2);
    var n2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a2 in t2)
      if (a2 !== "default" && Object.prototype.hasOwnProperty.call(t2, a2)) {
        var s2 = i2 ? Object.getOwnPropertyDescriptor(t2, a2) : null;
        s2 && (s2.get || s2.set) ? Object.defineProperty(n2, a2, s2) : n2[a2] = t2[a2];
      }
    return n2.default = t2, r2 && r2.set(t2, n2), n2;
  }
  var Hg = (Ze2 = {}, Ze2[C.tab] = true, Ze2[C.newline] = true, Ze2[C.cr] = true, Ze2[C.feed] = true, Ze2), Qg = (q2 = {}, q2[C.space] = true, q2[C.tab] = true, q2[C.newline] = true, q2[C.cr] = true, q2[C.feed] = true, q2[C.ampersand] = true, q2[C.asterisk] = true, q2[C.bang] = true, q2[C.comma] = true, q2[C.colon] = true, q2[C.semicolon] = true, q2[C.openParenthesis] = true, q2[C.closeParenthesis] = true, q2[C.openSquare] = true, q2[C.closeSquare] = true, q2[C.singleQuote] = true, q2[C.doubleQuote] = true, q2[C.plus] = true, q2[C.pipe] = true, q2[C.tilde] = true, q2[C.greaterThan] = true, q2[C.equals] = true, q2[C.dollar] = true, q2[C.caret] = true, q2[C.slash] = true, q2), Zi = {}, Ql = "0123456789abcdefABCDEF";
  for (Xr2 = 0; Xr2 < Ql.length; Xr2++)
    Zi[Ql.charCodeAt(Xr2)] = true;
  var Xr2;
  function Jg(t2, e2) {
    var r2 = e2, n2;
    do {
      if (n2 = t2.charCodeAt(r2), Qg[n2])
        return r2 - 1;
      n2 === C.backslash ? r2 = Xg(t2, r2) + 1 : r2++;
    } while (r2 < t2.length);
    return r2 - 1;
  }
  function Xg(t2, e2) {
    var r2 = e2, n2 = t2.charCodeAt(r2 + 1);
    if (!Hg[n2])
      if (Zi[n2]) {
        var i2 = 0;
        do
          r2++, i2++, n2 = t2.charCodeAt(r2 + 1);
        while (Zi[n2] && i2 < 6);
        i2 < 6 && n2 === C.space && r2++;
      } else
        r2++;
    return r2;
  }
  var Kg = { TYPE: 0, START_LINE: 1, START_COL: 2, END_LINE: 3, END_COL: 4, START_POS: 5, END_POS: 6 };
  Zt.FIELDS = Kg;
  function Zg(t2) {
    var e2 = [], r2 = t2.css.valueOf(), n2 = r2, i2 = n2.length, a2 = -1, s2 = 1, o2 = 0, l2 = 0, u2, f2, p2, c2, d2, h2, y3, m, g2, w2, b3, v2, O2;
    function x2(A, E2) {
      if (t2.safe)
        r2 += E2, g2 = r2.length - 1;
      else
        throw t2.error("Unclosed " + A, s2, o2 - a2, o2);
    }
    for (; o2 < i2; ) {
      switch (u2 = r2.charCodeAt(o2), u2 === C.newline && (a2 = o2, s2 += 1), u2) {
        case C.space:
        case C.tab:
        case C.newline:
        case C.cr:
        case C.feed:
          g2 = o2;
          do
            g2 += 1, u2 = r2.charCodeAt(g2), u2 === C.newline && (a2 = g2, s2 += 1);
          while (u2 === C.space || u2 === C.newline || u2 === C.tab || u2 === C.cr || u2 === C.feed);
          O2 = C.space, c2 = s2, p2 = g2 - a2 - 1, l2 = g2;
          break;
        case C.plus:
        case C.greaterThan:
        case C.tilde:
        case C.pipe:
          g2 = o2;
          do
            g2 += 1, u2 = r2.charCodeAt(g2);
          while (u2 === C.plus || u2 === C.greaterThan || u2 === C.tilde || u2 === C.pipe);
          O2 = C.combinator, c2 = s2, p2 = o2 - a2, l2 = g2;
          break;
        case C.asterisk:
        case C.ampersand:
        case C.bang:
        case C.comma:
        case C.equals:
        case C.dollar:
        case C.caret:
        case C.openSquare:
        case C.closeSquare:
        case C.colon:
        case C.semicolon:
        case C.openParenthesis:
        case C.closeParenthesis:
          g2 = o2, O2 = u2, c2 = s2, p2 = o2 - a2, l2 = g2 + 1;
          break;
        case C.singleQuote:
        case C.doubleQuote:
          v2 = u2 === C.singleQuote ? "'" : '"', g2 = o2;
          do
            for (d2 = false, g2 = r2.indexOf(v2, g2 + 1), g2 === -1 && x2("quote", v2), h2 = g2; r2.charCodeAt(h2 - 1) === C.backslash; )
              h2 -= 1, d2 = !d2;
          while (d2);
          O2 = C.str, c2 = s2, p2 = o2 - a2, l2 = g2 + 1;
          break;
        default:
          u2 === C.slash && r2.charCodeAt(o2 + 1) === C.asterisk ? (g2 = r2.indexOf("*/", o2 + 2) + 1, g2 === 0 && x2("comment", "*/"), f2 = r2.slice(o2, g2 + 1), m = f2.split(`
`), y3 = m.length - 1, y3 > 0 ? (w2 = s2 + y3, b3 = g2 - m[y3].length) : (w2 = s2, b3 = a2), O2 = C.comment, s2 = w2, c2 = w2, p2 = g2 - b3) : u2 === C.slash ? (g2 = o2, O2 = u2, c2 = s2, p2 = o2 - a2, l2 = g2 + 1) : (g2 = Jg(r2, o2), O2 = C.word, c2 = s2, p2 = g2 - a2), l2 = g2 + 1;
          break;
      }
      e2.push([O2, s2, o2 - a2, c2, p2, o2, l2]), b3 && (a2 = b3, b3 = null), o2 = l2;
    }
    return e2;
  }
});
var su = S((er2, iu2) => {
  "use strict";
  er2.__esModule = true;
  er2.default = void 0;
  var ey = le2(Si()), es = le2(Oi()), ty = le2(Ai()), Kl = le2(Ti()), ry = le2(Ii()), ny = le2(Mi()), ts = le2(Li()), iy = le2(qi()), Zl = Kr2(Bi()), sy = le2(Yi()), rs = le2(Qi()), ay = le2(Xi()), oy = le2(Yl()), k = Kr2(Xl()), _3 = Kr2(Ki()), ly = Kr2(J()), V2 = Ft(), Ve2, ns;
  function nu2(t2) {
    if (typeof WeakMap != "function")
      return null;
    var e2 = /* @__PURE__ */ new WeakMap(), r2 = /* @__PURE__ */ new WeakMap();
    return (nu2 = function(i2) {
      return i2 ? r2 : e2;
    })(t2);
  }
  function Kr2(t2, e2) {
    if (!e2 && t2 && t2.__esModule)
      return t2;
    if (t2 === null || typeof t2 != "object" && typeof t2 != "function")
      return { default: t2 };
    var r2 = nu2(e2);
    if (r2 && r2.has(t2))
      return r2.get(t2);
    var n2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a2 in t2)
      if (a2 !== "default" && Object.prototype.hasOwnProperty.call(t2, a2)) {
        var s2 = i2 ? Object.getOwnPropertyDescriptor(t2, a2) : null;
        s2 && (s2.get || s2.set) ? Object.defineProperty(n2, a2, s2) : n2[a2] = t2[a2];
      }
    return n2.default = t2, r2 && r2.set(t2, n2), n2;
  }
  function le2(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  function eu2(t2, e2) {
    for (var r2 = 0; r2 < e2.length; r2++) {
      var n2 = e2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
    }
  }
  function uy(t2, e2, r2) {
    return e2 && eu2(t2.prototype, e2), r2 && eu2(t2, r2), Object.defineProperty(t2, "prototype", { writable: false }), t2;
  }
  var as = (Ve2 = {}, Ve2[_3.space] = true, Ve2[_3.cr] = true, Ve2[_3.feed] = true, Ve2[_3.newline] = true, Ve2[_3.tab] = true, Ve2), fy = Object.assign({}, as, (ns = {}, ns[_3.comment] = true, ns));
  function tu2(t2) {
    return { line: t2[k.FIELDS.START_LINE], column: t2[k.FIELDS.START_COL] };
  }
  function ru2(t2) {
    return { line: t2[k.FIELDS.END_LINE], column: t2[k.FIELDS.END_COL] };
  }
  function We2(t2, e2, r2, n2) {
    return { start: { line: t2, column: e2 }, end: { line: r2, column: n2 } };
  }
  function et2(t2) {
    return We2(t2[k.FIELDS.START_LINE], t2[k.FIELDS.START_COL], t2[k.FIELDS.END_LINE], t2[k.FIELDS.END_COL]);
  }
  function is(t2, e2) {
    if (!!t2)
      return We2(t2[k.FIELDS.START_LINE], t2[k.FIELDS.START_COL], e2[k.FIELDS.END_LINE], e2[k.FIELDS.END_COL]);
  }
  function tt2(t2, e2) {
    var r2 = t2[e2];
    if (typeof r2 == "string")
      return r2.indexOf("\\") !== -1 && ((0, V2.ensureObject)(t2, "raws"), t2[e2] = (0, V2.unesc)(r2), t2.raws[e2] === void 0 && (t2.raws[e2] = r2)), t2;
  }
  function ss(t2, e2) {
    for (var r2 = -1, n2 = []; (r2 = t2.indexOf(e2, r2 + 1)) !== -1; )
      n2.push(r2);
    return n2;
  }
  function cy() {
    var t2 = Array.prototype.concat.apply([], arguments);
    return t2.filter(function(e2, r2) {
      return r2 === t2.indexOf(e2);
    });
  }
  var py = function() {
    function t2(r2, n2) {
      n2 === void 0 && (n2 = {}), this.rule = r2, this.options = Object.assign({ lossy: false, safe: false }, n2), this.position = 0, this.css = typeof this.rule == "string" ? this.rule : this.rule.selector, this.tokens = (0, k.default)({ css: this.css, error: this._errorGenerator(), safe: this.options.safe });
      var i2 = is(this.tokens[0], this.tokens[this.tokens.length - 1]);
      this.root = new ey.default({ source: i2 }), this.root.errorGenerator = this._errorGenerator();
      var a2 = new es.default({ source: { start: { line: 1, column: 1 } } });
      this.root.append(a2), this.current = a2, this.loop();
    }
    var e2 = t2.prototype;
    return e2._errorGenerator = function() {
      var n2 = this;
      return function(i2, a2) {
        return typeof n2.rule == "string" ? new Error(i2) : n2.rule.error(i2, a2);
      };
    }, e2.attribute = function() {
      var n2 = [], i2 = this.currToken;
      for (this.position++; this.position < this.tokens.length && this.currToken[k.FIELDS.TYPE] !== _3.closeSquare; )
        n2.push(this.currToken), this.position++;
      if (this.currToken[k.FIELDS.TYPE] !== _3.closeSquare)
        return this.expected("closing square bracket", this.currToken[k.FIELDS.START_POS]);
      var a2 = n2.length, s2 = { source: We2(i2[1], i2[2], this.currToken[3], this.currToken[4]), sourceIndex: i2[k.FIELDS.START_POS] };
      if (a2 === 1 && !~[_3.word].indexOf(n2[0][k.FIELDS.TYPE]))
        return this.expected("attribute", n2[0][k.FIELDS.START_POS]);
      for (var o2 = 0, l2 = "", u2 = "", f2 = null, p2 = false; o2 < a2; ) {
        var c2 = n2[o2], d2 = this.content(c2), h2 = n2[o2 + 1];
        switch (c2[k.FIELDS.TYPE]) {
          case _3.space:
            if (p2 = true, this.options.lossy)
              break;
            if (f2) {
              (0, V2.ensureObject)(s2, "spaces", f2);
              var y3 = s2.spaces[f2].after || "";
              s2.spaces[f2].after = y3 + d2;
              var m = (0, V2.getProp)(s2, "raws", "spaces", f2, "after") || null;
              m && (s2.raws.spaces[f2].after = m + d2);
            } else
              l2 = l2 + d2, u2 = u2 + d2;
            break;
          case _3.asterisk:
            if (h2[k.FIELDS.TYPE] === _3.equals)
              s2.operator = d2, f2 = "operator";
            else if ((!s2.namespace || f2 === "namespace" && !p2) && h2) {
              l2 && ((0, V2.ensureObject)(s2, "spaces", "attribute"), s2.spaces.attribute.before = l2, l2 = ""), u2 && ((0, V2.ensureObject)(s2, "raws", "spaces", "attribute"), s2.raws.spaces.attribute.before = l2, u2 = ""), s2.namespace = (s2.namespace || "") + d2;
              var g2 = (0, V2.getProp)(s2, "raws", "namespace") || null;
              g2 && (s2.raws.namespace += d2), f2 = "namespace";
            }
            p2 = false;
            break;
          case _3.dollar:
            if (f2 === "value") {
              var w2 = (0, V2.getProp)(s2, "raws", "value");
              s2.value += "$", w2 && (s2.raws.value = w2 + "$");
              break;
            }
          case _3.caret:
            h2[k.FIELDS.TYPE] === _3.equals && (s2.operator = d2, f2 = "operator"), p2 = false;
            break;
          case _3.combinator:
            if (d2 === "~" && h2[k.FIELDS.TYPE] === _3.equals && (s2.operator = d2, f2 = "operator"), d2 !== "|") {
              p2 = false;
              break;
            }
            h2[k.FIELDS.TYPE] === _3.equals ? (s2.operator = d2, f2 = "operator") : !s2.namespace && !s2.attribute && (s2.namespace = true), p2 = false;
            break;
          case _3.word:
            if (h2 && this.content(h2) === "|" && n2[o2 + 2] && n2[o2 + 2][k.FIELDS.TYPE] !== _3.equals && !s2.operator && !s2.namespace)
              s2.namespace = d2, f2 = "namespace";
            else if (!s2.attribute || f2 === "attribute" && !p2) {
              l2 && ((0, V2.ensureObject)(s2, "spaces", "attribute"), s2.spaces.attribute.before = l2, l2 = ""), u2 && ((0, V2.ensureObject)(s2, "raws", "spaces", "attribute"), s2.raws.spaces.attribute.before = u2, u2 = ""), s2.attribute = (s2.attribute || "") + d2;
              var b3 = (0, V2.getProp)(s2, "raws", "attribute") || null;
              b3 && (s2.raws.attribute += d2), f2 = "attribute";
            } else if (!s2.value && s2.value !== "" || f2 === "value" && !(p2 || s2.quoteMark)) {
              var v2 = (0, V2.unesc)(d2), O2 = (0, V2.getProp)(s2, "raws", "value") || "", x2 = s2.value || "";
              s2.value = x2 + v2, s2.quoteMark = null, (v2 !== d2 || O2) && ((0, V2.ensureObject)(s2, "raws"), s2.raws.value = (O2 || x2) + d2), f2 = "value";
            } else {
              var A = d2 === "i" || d2 === "I";
              (s2.value || s2.value === "") && (s2.quoteMark || p2) ? (s2.insensitive = A, (!A || d2 === "I") && ((0, V2.ensureObject)(s2, "raws"), s2.raws.insensitiveFlag = d2), f2 = "insensitive", l2 && ((0, V2.ensureObject)(s2, "spaces", "insensitive"), s2.spaces.insensitive.before = l2, l2 = ""), u2 && ((0, V2.ensureObject)(s2, "raws", "spaces", "insensitive"), s2.raws.spaces.insensitive.before = u2, u2 = "")) : (s2.value || s2.value === "") && (f2 = "value", s2.value += d2, s2.raws.value && (s2.raws.value += d2));
            }
            p2 = false;
            break;
          case _3.str:
            if (!s2.attribute || !s2.operator)
              return this.error("Expected an attribute followed by an operator preceding the string.", { index: c2[k.FIELDS.START_POS] });
            var E2 = (0, Zl.unescapeValue)(d2), I2 = E2.unescaped, F = E2.quoteMark;
            s2.value = I2, s2.quoteMark = F, f2 = "value", (0, V2.ensureObject)(s2, "raws"), s2.raws.value = d2, p2 = false;
            break;
          case _3.equals:
            if (!s2.attribute)
              return this.expected("attribute", c2[k.FIELDS.START_POS], d2);
            if (s2.value)
              return this.error('Unexpected "=" found; an operator was already defined.', { index: c2[k.FIELDS.START_POS] });
            s2.operator = s2.operator ? s2.operator + d2 : d2, f2 = "operator", p2 = false;
            break;
          case _3.comment:
            if (f2)
              if (p2 || h2 && h2[k.FIELDS.TYPE] === _3.space || f2 === "insensitive") {
                var Y2 = (0, V2.getProp)(s2, "spaces", f2, "after") || "", K2 = (0, V2.getProp)(s2, "raws", "spaces", f2, "after") || Y2;
                (0, V2.ensureObject)(s2, "raws", "spaces", f2), s2.raws.spaces[f2].after = K2 + d2;
              } else {
                var B2 = s2[f2] || "", qe2 = (0, V2.getProp)(s2, "raws", f2) || B2;
                (0, V2.ensureObject)(s2, "raws"), s2.raws[f2] = qe2 + d2;
              }
            else
              u2 = u2 + d2;
            break;
          default:
            return this.error('Unexpected "' + d2 + '" found.', { index: c2[k.FIELDS.START_POS] });
        }
        o2++;
      }
      tt2(s2, "attribute"), tt2(s2, "namespace"), this.newNode(new Zl.default(s2)), this.position++;
    }, e2.parseWhitespaceEquivalentTokens = function(n2) {
      n2 < 0 && (n2 = this.tokens.length);
      var i2 = this.position, a2 = [], s2 = "", o2 = void 0;
      do
        if (as[this.currToken[k.FIELDS.TYPE]])
          this.options.lossy || (s2 += this.content());
        else if (this.currToken[k.FIELDS.TYPE] === _3.comment) {
          var l2 = {};
          s2 && (l2.before = s2, s2 = ""), o2 = new Kl.default({ value: this.content(), source: et2(this.currToken), sourceIndex: this.currToken[k.FIELDS.START_POS], spaces: l2 }), a2.push(o2);
        }
      while (++this.position < n2);
      if (s2) {
        if (o2)
          o2.spaces.after = s2;
        else if (!this.options.lossy) {
          var u2 = this.tokens[i2], f2 = this.tokens[this.position - 1];
          a2.push(new ts.default({ value: "", source: We2(u2[k.FIELDS.START_LINE], u2[k.FIELDS.START_COL], f2[k.FIELDS.END_LINE], f2[k.FIELDS.END_COL]), sourceIndex: u2[k.FIELDS.START_POS], spaces: { before: s2, after: "" } }));
        }
      }
      return a2;
    }, e2.convertWhitespaceNodesToSpace = function(n2, i2) {
      var a2 = this;
      i2 === void 0 && (i2 = false);
      var s2 = "", o2 = "";
      n2.forEach(function(u2) {
        var f2 = a2.lossySpace(u2.spaces.before, i2), p2 = a2.lossySpace(u2.rawSpaceBefore, i2);
        s2 += f2 + a2.lossySpace(u2.spaces.after, i2 && f2.length === 0), o2 += f2 + u2.value + a2.lossySpace(u2.rawSpaceAfter, i2 && p2.length === 0);
      }), o2 === s2 && (o2 = void 0);
      var l2 = { space: s2, rawSpace: o2 };
      return l2;
    }, e2.isNamedCombinator = function(n2) {
      return n2 === void 0 && (n2 = this.position), this.tokens[n2 + 0] && this.tokens[n2 + 0][k.FIELDS.TYPE] === _3.slash && this.tokens[n2 + 1] && this.tokens[n2 + 1][k.FIELDS.TYPE] === _3.word && this.tokens[n2 + 2] && this.tokens[n2 + 2][k.FIELDS.TYPE] === _3.slash;
    }, e2.namedCombinator = function() {
      if (this.isNamedCombinator()) {
        var n2 = this.content(this.tokens[this.position + 1]), i2 = (0, V2.unesc)(n2).toLowerCase(), a2 = {};
        i2 !== n2 && (a2.value = "/" + n2 + "/");
        var s2 = new rs.default({ value: "/" + i2 + "/", source: We2(this.currToken[k.FIELDS.START_LINE], this.currToken[k.FIELDS.START_COL], this.tokens[this.position + 2][k.FIELDS.END_LINE], this.tokens[this.position + 2][k.FIELDS.END_COL]), sourceIndex: this.currToken[k.FIELDS.START_POS], raws: a2 });
        return this.position = this.position + 3, s2;
      } else
        this.unexpected();
    }, e2.combinator = function() {
      var n2 = this;
      if (this.content() === "|")
        return this.namespace();
      var i2 = this.locateNextMeaningfulToken(this.position);
      if (i2 < 0 || this.tokens[i2][k.FIELDS.TYPE] === _3.comma) {
        var a2 = this.parseWhitespaceEquivalentTokens(i2);
        if (a2.length > 0) {
          var s2 = this.current.last;
          if (s2) {
            var o2 = this.convertWhitespaceNodesToSpace(a2), l2 = o2.space, u2 = o2.rawSpace;
            u2 !== void 0 && (s2.rawSpaceAfter += u2), s2.spaces.after += l2;
          } else
            a2.forEach(function(O2) {
              return n2.newNode(O2);
            });
        }
        return;
      }
      var f2 = this.currToken, p2 = void 0;
      i2 > this.position && (p2 = this.parseWhitespaceEquivalentTokens(i2));
      var c2;
      if (this.isNamedCombinator() ? c2 = this.namedCombinator() : this.currToken[k.FIELDS.TYPE] === _3.combinator ? (c2 = new rs.default({ value: this.content(), source: et2(this.currToken), sourceIndex: this.currToken[k.FIELDS.START_POS] }), this.position++) : as[this.currToken[k.FIELDS.TYPE]] || p2 || this.unexpected(), c2) {
        if (p2) {
          var d2 = this.convertWhitespaceNodesToSpace(p2), h2 = d2.space, y3 = d2.rawSpace;
          c2.spaces.before = h2, c2.rawSpaceBefore = y3;
        }
      } else {
        var m = this.convertWhitespaceNodesToSpace(p2, true), g2 = m.space, w2 = m.rawSpace;
        w2 || (w2 = g2);
        var b3 = {}, v2 = { spaces: {} };
        g2.endsWith(" ") && w2.endsWith(" ") ? (b3.before = g2.slice(0, g2.length - 1), v2.spaces.before = w2.slice(0, w2.length - 1)) : g2.startsWith(" ") && w2.startsWith(" ") ? (b3.after = g2.slice(1), v2.spaces.after = w2.slice(1)) : v2.value = w2, c2 = new rs.default({ value: " ", source: is(f2, this.tokens[this.position - 1]), sourceIndex: f2[k.FIELDS.START_POS], spaces: b3, raws: v2 });
      }
      return this.currToken && this.currToken[k.FIELDS.TYPE] === _3.space && (c2.spaces.after = this.optionalSpace(this.content()), this.position++), this.newNode(c2);
    }, e2.comma = function() {
      if (this.position === this.tokens.length - 1) {
        this.root.trailingComma = true, this.position++;
        return;
      }
      this.current._inferEndPosition();
      var n2 = new es.default({ source: { start: tu2(this.tokens[this.position + 1]) } });
      this.current.parent.append(n2), this.current = n2, this.position++;
    }, e2.comment = function() {
      var n2 = this.currToken;
      this.newNode(new Kl.default({ value: this.content(), source: et2(n2), sourceIndex: n2[k.FIELDS.START_POS] })), this.position++;
    }, e2.error = function(n2, i2) {
      throw this.root.error(n2, i2);
    }, e2.missingBackslash = function() {
      return this.error("Expected a backslash preceding the semicolon.", { index: this.currToken[k.FIELDS.START_POS] });
    }, e2.missingParenthesis = function() {
      return this.expected("opening parenthesis", this.currToken[k.FIELDS.START_POS]);
    }, e2.missingSquareBracket = function() {
      return this.expected("opening square bracket", this.currToken[k.FIELDS.START_POS]);
    }, e2.unexpected = function() {
      return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[k.FIELDS.START_POS]);
    }, e2.unexpectedPipe = function() {
      return this.error("Unexpected '|'.", this.currToken[k.FIELDS.START_POS]);
    }, e2.namespace = function() {
      var n2 = this.prevToken && this.content(this.prevToken) || true;
      if (this.nextToken[k.FIELDS.TYPE] === _3.word)
        return this.position++, this.word(n2);
      if (this.nextToken[k.FIELDS.TYPE] === _3.asterisk)
        return this.position++, this.universal(n2);
      this.unexpectedPipe();
    }, e2.nesting = function() {
      if (this.nextToken) {
        var n2 = this.content(this.nextToken);
        if (n2 === "|") {
          this.position++;
          return;
        }
      }
      var i2 = this.currToken;
      this.newNode(new ay.default({ value: this.content(), source: et2(i2), sourceIndex: i2[k.FIELDS.START_POS] })), this.position++;
    }, e2.parentheses = function() {
      var n2 = this.current.last, i2 = 1;
      if (this.position++, n2 && n2.type === ly.PSEUDO) {
        var a2 = new es.default({ source: { start: tu2(this.tokens[this.position - 1]) } }), s2 = this.current;
        for (n2.append(a2), this.current = a2; this.position < this.tokens.length && i2; )
          this.currToken[k.FIELDS.TYPE] === _3.openParenthesis && i2++, this.currToken[k.FIELDS.TYPE] === _3.closeParenthesis && i2--, i2 ? this.parse() : (this.current.source.end = ru2(this.currToken), this.current.parent.source.end = ru2(this.currToken), this.position++);
        this.current = s2;
      } else {
        for (var o2 = this.currToken, l2 = "(", u2; this.position < this.tokens.length && i2; )
          this.currToken[k.FIELDS.TYPE] === _3.openParenthesis && i2++, this.currToken[k.FIELDS.TYPE] === _3.closeParenthesis && i2--, u2 = this.currToken, l2 += this.parseParenthesisToken(this.currToken), this.position++;
        n2 ? n2.appendToPropertyAndEscape("value", l2, l2) : this.newNode(new ts.default({ value: l2, source: We2(o2[k.FIELDS.START_LINE], o2[k.FIELDS.START_COL], u2[k.FIELDS.END_LINE], u2[k.FIELDS.END_COL]), sourceIndex: o2[k.FIELDS.START_POS] }));
      }
      if (i2)
        return this.expected("closing parenthesis", this.currToken[k.FIELDS.START_POS]);
    }, e2.pseudo = function() {
      for (var n2 = this, i2 = "", a2 = this.currToken; this.currToken && this.currToken[k.FIELDS.TYPE] === _3.colon; )
        i2 += this.content(), this.position++;
      if (!this.currToken)
        return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
      if (this.currToken[k.FIELDS.TYPE] === _3.word)
        this.splitWord(false, function(s2, o2) {
          i2 += s2, n2.newNode(new iy.default({ value: i2, source: is(a2, n2.currToken), sourceIndex: a2[k.FIELDS.START_POS] })), o2 > 1 && n2.nextToken && n2.nextToken[k.FIELDS.TYPE] === _3.openParenthesis && n2.error("Misplaced parenthesis.", { index: n2.nextToken[k.FIELDS.START_POS] });
        });
      else
        return this.expected(["pseudo-class", "pseudo-element"], this.currToken[k.FIELDS.START_POS]);
    }, e2.space = function() {
      var n2 = this.content();
      this.position === 0 || this.prevToken[k.FIELDS.TYPE] === _3.comma || this.prevToken[k.FIELDS.TYPE] === _3.openParenthesis || this.current.nodes.every(function(i2) {
        return i2.type === "comment";
      }) ? (this.spaces = this.optionalSpace(n2), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[k.FIELDS.TYPE] === _3.comma || this.nextToken[k.FIELDS.TYPE] === _3.closeParenthesis ? (this.current.last.spaces.after = this.optionalSpace(n2), this.position++) : this.combinator();
    }, e2.string = function() {
      var n2 = this.currToken;
      this.newNode(new ts.default({ value: this.content(), source: et2(n2), sourceIndex: n2[k.FIELDS.START_POS] })), this.position++;
    }, e2.universal = function(n2) {
      var i2 = this.nextToken;
      if (i2 && this.content(i2) === "|")
        return this.position++, this.namespace();
      var a2 = this.currToken;
      this.newNode(new sy.default({ value: this.content(), source: et2(a2), sourceIndex: a2[k.FIELDS.START_POS] }), n2), this.position++;
    }, e2.splitWord = function(n2, i2) {
      for (var a2 = this, s2 = this.nextToken, o2 = this.content(); s2 && ~[_3.dollar, _3.caret, _3.equals, _3.word].indexOf(s2[k.FIELDS.TYPE]); ) {
        this.position++;
        var l2 = this.content();
        if (o2 += l2, l2.lastIndexOf("\\") === l2.length - 1) {
          var u2 = this.nextToken;
          u2 && u2[k.FIELDS.TYPE] === _3.space && (o2 += this.requiredSpace(this.content(u2)), this.position++);
        }
        s2 = this.nextToken;
      }
      var f2 = ss(o2, ".").filter(function(h2) {
        var y3 = o2[h2 - 1] === "\\", m = /^\d+\.\d+%$/.test(o2);
        return !y3 && !m;
      }), p2 = ss(o2, "#").filter(function(h2) {
        return o2[h2 - 1] !== "\\";
      }), c2 = ss(o2, "#{");
      c2.length && (p2 = p2.filter(function(h2) {
        return !~c2.indexOf(h2);
      }));
      var d2 = (0, oy.default)(cy([0].concat(f2, p2)));
      d2.forEach(function(h2, y3) {
        var m = d2[y3 + 1] || o2.length, g2 = o2.slice(h2, m);
        if (y3 === 0 && i2)
          return i2.call(a2, g2, d2.length);
        var w2, b3 = a2.currToken, v2 = b3[k.FIELDS.START_POS] + d2[y3], O2 = We2(b3[1], b3[2] + h2, b3[3], b3[2] + (m - 1));
        if (~f2.indexOf(h2)) {
          var x2 = { value: g2.slice(1), source: O2, sourceIndex: v2 };
          w2 = new ty.default(tt2(x2, "value"));
        } else if (~p2.indexOf(h2)) {
          var A = { value: g2.slice(1), source: O2, sourceIndex: v2 };
          w2 = new ry.default(tt2(A, "value"));
        } else {
          var E2 = { value: g2, source: O2, sourceIndex: v2 };
          tt2(E2, "value"), w2 = new ny.default(E2);
        }
        a2.newNode(w2, n2), n2 = null;
      }), this.position++;
    }, e2.word = function(n2) {
      var i2 = this.nextToken;
      return i2 && this.content(i2) === "|" ? (this.position++, this.namespace()) : this.splitWord(n2);
    }, e2.loop = function() {
      for (; this.position < this.tokens.length; )
        this.parse(true);
      return this.current._inferEndPosition(), this.root;
    }, e2.parse = function(n2) {
      switch (this.currToken[k.FIELDS.TYPE]) {
        case _3.space:
          this.space();
          break;
        case _3.comment:
          this.comment();
          break;
        case _3.openParenthesis:
          this.parentheses();
          break;
        case _3.closeParenthesis:
          n2 && this.missingParenthesis();
          break;
        case _3.openSquare:
          this.attribute();
          break;
        case _3.dollar:
        case _3.caret:
        case _3.equals:
        case _3.word:
          this.word();
          break;
        case _3.colon:
          this.pseudo();
          break;
        case _3.comma:
          this.comma();
          break;
        case _3.asterisk:
          this.universal();
          break;
        case _3.ampersand:
          this.nesting();
          break;
        case _3.slash:
        case _3.combinator:
          this.combinator();
          break;
        case _3.str:
          this.string();
          break;
        case _3.closeSquare:
          this.missingSquareBracket();
        case _3.semicolon:
          this.missingBackslash();
        default:
          this.unexpected();
      }
    }, e2.expected = function(n2, i2, a2) {
      if (Array.isArray(n2)) {
        var s2 = n2.pop();
        n2 = n2.join(", ") + " or " + s2;
      }
      var o2 = /^[aeiou]/.test(n2[0]) ? "an" : "a";
      return a2 ? this.error("Expected " + o2 + " " + n2 + ', found "' + a2 + '" instead.', { index: i2 }) : this.error("Expected " + o2 + " " + n2 + ".", { index: i2 });
    }, e2.requiredSpace = function(n2) {
      return this.options.lossy ? " " : n2;
    }, e2.optionalSpace = function(n2) {
      return this.options.lossy ? "" : n2;
    }, e2.lossySpace = function(n2, i2) {
      return this.options.lossy ? i2 ? " " : "" : n2;
    }, e2.parseParenthesisToken = function(n2) {
      var i2 = this.content(n2);
      return n2[k.FIELDS.TYPE] === _3.space ? this.requiredSpace(i2) : i2;
    }, e2.newNode = function(n2, i2) {
      return i2 && (/^ +$/.test(i2) && (this.options.lossy || (this.spaces = (this.spaces || "") + i2), i2 = true), n2.namespace = i2, tt2(n2, "namespace")), this.spaces && (n2.spaces.before = this.spaces, this.spaces = ""), this.current.append(n2);
    }, e2.content = function(n2) {
      return n2 === void 0 && (n2 = this.currToken), this.css.slice(n2[k.FIELDS.START_POS], n2[k.FIELDS.END_POS]);
    }, e2.locateNextMeaningfulToken = function(n2) {
      n2 === void 0 && (n2 = this.position + 1);
      for (var i2 = n2; i2 < this.tokens.length; )
        if (fy[this.tokens[i2][k.FIELDS.TYPE]]) {
          i2++;
          continue;
        } else
          return i2;
      return -1;
    }, uy(t2, [{ key: "currToken", get: function() {
      return this.tokens[this.position];
    } }, { key: "nextToken", get: function() {
      return this.tokens[this.position + 1];
    } }, { key: "prevToken", get: function() {
      return this.tokens[this.position - 1];
    } }]), t2;
  }();
  er2.default = py;
  iu2.exports = er2.default;
});
var ou = S((tr2, au2) => {
  "use strict";
  tr2.__esModule = true;
  tr2.default = void 0;
  var dy = hy(su());
  function hy(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  var my = function() {
    function t2(r2, n2) {
      this.func = r2 || function() {
      }, this.funcRes = null, this.options = n2;
    }
    var e2 = t2.prototype;
    return e2._shouldUpdateSelector = function(n2, i2) {
      i2 === void 0 && (i2 = {});
      var a2 = Object.assign({}, this.options, i2);
      return a2.updateSelector === false ? false : typeof n2 != "string";
    }, e2._isLossy = function(n2) {
      n2 === void 0 && (n2 = {});
      var i2 = Object.assign({}, this.options, n2);
      return i2.lossless === false;
    }, e2._root = function(n2, i2) {
      i2 === void 0 && (i2 = {});
      var a2 = new dy.default(n2, this._parseOptions(i2));
      return a2.root;
    }, e2._parseOptions = function(n2) {
      return { lossy: this._isLossy(n2) };
    }, e2._run = function(n2, i2) {
      var a2 = this;
      return i2 === void 0 && (i2 = {}), new Promise(function(s2, o2) {
        try {
          var l2 = a2._root(n2, i2);
          Promise.resolve(a2.func(l2)).then(function(u2) {
            var f2 = void 0;
            return a2._shouldUpdateSelector(n2, i2) && (f2 = l2.toString(), n2.selector = f2), { transform: u2, root: l2, string: f2 };
          }).then(s2, o2);
        } catch (u2) {
          o2(u2);
          return;
        }
      });
    }, e2._runSync = function(n2, i2) {
      i2 === void 0 && (i2 = {});
      var a2 = this._root(n2, i2), s2 = this.func(a2);
      if (s2 && typeof s2.then == "function")
        throw new Error("Selector processor returned a promise to a synchronous call.");
      var o2 = void 0;
      return i2.updateSelector && typeof n2 != "string" && (o2 = a2.toString(), n2.selector = o2), { transform: s2, root: a2, string: o2 };
    }, e2.ast = function(n2, i2) {
      return this._run(n2, i2).then(function(a2) {
        return a2.root;
      });
    }, e2.astSync = function(n2, i2) {
      return this._runSync(n2, i2).root;
    }, e2.transform = function(n2, i2) {
      return this._run(n2, i2).then(function(a2) {
        return a2.transform;
      });
    }, e2.transformSync = function(n2, i2) {
      return this._runSync(n2, i2).transform;
    }, e2.process = function(n2, i2) {
      return this._run(n2, i2).then(function(a2) {
        return a2.string || a2.root.toString();
      });
    }, e2.processSync = function(n2, i2) {
      var a2 = this._runSync(n2, i2);
      return a2.string || a2.root.toString();
    }, t2;
  }();
  tr2.default = my;
  au2.exports = tr2.default;
});
var lu = S((j2) => {
  "use strict";
  j2.__esModule = true;
  j2.universal = j2.tag = j2.string = j2.selector = j2.root = j2.pseudo = j2.nesting = j2.id = j2.comment = j2.combinator = j2.className = j2.attribute = void 0;
  var gy = ue2(Bi()), yy = ue2(Ai()), vy = ue2(Qi()), wy = ue2(Ti()), by = ue2(Ii()), xy = ue2(Xi()), Sy = ue2(qi()), ky = ue2(Si()), Oy = ue2(Oi()), Ey = ue2(Li()), Cy = ue2(Mi()), Ay = ue2(Yi());
  function ue2(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  var _y = function(e2) {
    return new gy.default(e2);
  };
  j2.attribute = _y;
  var Ty = function(e2) {
    return new yy.default(e2);
  };
  j2.className = Ty;
  var Py = function(e2) {
    return new vy.default(e2);
  };
  j2.combinator = Py;
  var Iy = function(e2) {
    return new wy.default(e2);
  };
  j2.comment = Iy;
  var Ry = function(e2) {
    return new by.default(e2);
  };
  j2.id = Ry;
  var Dy = function(e2) {
    return new xy.default(e2);
  };
  j2.nesting = Dy;
  var My = function(e2) {
    return new Sy.default(e2);
  };
  j2.pseudo = My;
  var Fy = function(e2) {
    return new ky.default(e2);
  };
  j2.root = Fy;
  var Ly = function(e2) {
    return new Oy.default(e2);
  };
  j2.selector = Ly;
  var Ny = function(e2) {
    return new Ey.default(e2);
  };
  j2.string = Ny;
  var qy = function(e2) {
    return new Cy.default(e2);
  };
  j2.tag = qy;
  var $y = function(e2) {
    return new Ay.default(e2);
  };
  j2.universal = $y;
});
var pu = S((D) => {
  "use strict";
  D.__esModule = true;
  D.isComment = D.isCombinator = D.isClassName = D.isAttribute = void 0;
  D.isContainer = Xy;
  D.isIdentifier = void 0;
  D.isNamespace = Ky;
  D.isNesting = void 0;
  D.isNode = os;
  D.isPseudo = void 0;
  D.isPseudoClass = Jy;
  D.isPseudoElement = cu2;
  D.isUniversal = D.isTag = D.isString = D.isSelector = D.isRoot = void 0;
  var W2 = J(), te2, Uy = (te2 = {}, te2[W2.ATTRIBUTE] = true, te2[W2.CLASS] = true, te2[W2.COMBINATOR] = true, te2[W2.COMMENT] = true, te2[W2.ID] = true, te2[W2.NESTING] = true, te2[W2.PSEUDO] = true, te2[W2.ROOT] = true, te2[W2.SELECTOR] = true, te2[W2.STRING] = true, te2[W2.TAG] = true, te2[W2.UNIVERSAL] = true, te2);
  function os(t2) {
    return typeof t2 == "object" && Uy[t2.type];
  }
  function fe2(t2, e2) {
    return os(e2) && e2.type === t2;
  }
  var uu2 = fe2.bind(null, W2.ATTRIBUTE);
  D.isAttribute = uu2;
  var jy = fe2.bind(null, W2.CLASS);
  D.isClassName = jy;
  var zy = fe2.bind(null, W2.COMBINATOR);
  D.isCombinator = zy;
  var Vy = fe2.bind(null, W2.COMMENT);
  D.isComment = Vy;
  var Wy = fe2.bind(null, W2.ID);
  D.isIdentifier = Wy;
  var By = fe2.bind(null, W2.NESTING);
  D.isNesting = By;
  var ls = fe2.bind(null, W2.PSEUDO);
  D.isPseudo = ls;
  var Gy = fe2.bind(null, W2.ROOT);
  D.isRoot = Gy;
  var Yy = fe2.bind(null, W2.SELECTOR);
  D.isSelector = Yy;
  var Hy = fe2.bind(null, W2.STRING);
  D.isString = Hy;
  var fu2 = fe2.bind(null, W2.TAG);
  D.isTag = fu2;
  var Qy = fe2.bind(null, W2.UNIVERSAL);
  D.isUniversal = Qy;
  function cu2(t2) {
    return ls(t2) && t2.value && (t2.value.startsWith("::") || t2.value.toLowerCase() === ":before" || t2.value.toLowerCase() === ":after" || t2.value.toLowerCase() === ":first-letter" || t2.value.toLowerCase() === ":first-line");
  }
  function Jy(t2) {
    return ls(t2) && !cu2(t2);
  }
  function Xy(t2) {
    return !!(os(t2) && t2.walk);
  }
  function Ky(t2) {
    return uu2(t2) || fu2(t2);
  }
});
var du = S((de2) => {
  "use strict";
  de2.__esModule = true;
  var us = J();
  Object.keys(us).forEach(function(t2) {
    t2 === "default" || t2 === "__esModule" || t2 in de2 && de2[t2] === us[t2] || (de2[t2] = us[t2]);
  });
  var fs = lu();
  Object.keys(fs).forEach(function(t2) {
    t2 === "default" || t2 === "__esModule" || t2 in de2 && de2[t2] === fs[t2] || (de2[t2] = fs[t2]);
  });
  var cs = pu();
  Object.keys(cs).forEach(function(t2) {
    t2 === "default" || t2 === "__esModule" || t2 in de2 && de2[t2] === cs[t2] || (de2[t2] = cs[t2]);
  });
});
var ve = S((rr2, mu2) => {
  "use strict";
  rr2.__esModule = true;
  rr2.default = void 0;
  var Zy = r0(ou()), e0 = t0(du());
  function hu2(t2) {
    if (typeof WeakMap != "function")
      return null;
    var e2 = /* @__PURE__ */ new WeakMap(), r2 = /* @__PURE__ */ new WeakMap();
    return (hu2 = function(i2) {
      return i2 ? r2 : e2;
    })(t2);
  }
  function t0(t2, e2) {
    if (!e2 && t2 && t2.__esModule)
      return t2;
    if (t2 === null || typeof t2 != "object" && typeof t2 != "function")
      return { default: t2 };
    var r2 = hu2(e2);
    if (r2 && r2.has(t2))
      return r2.get(t2);
    var n2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a2 in t2)
      if (a2 !== "default" && Object.prototype.hasOwnProperty.call(t2, a2)) {
        var s2 = i2 ? Object.getOwnPropertyDescriptor(t2, a2) : null;
        s2 && (s2.get || s2.set) ? Object.defineProperty(n2, a2, s2) : n2[a2] = t2[a2];
      }
    return n2.default = t2, r2 && r2.set(t2, n2), n2;
  }
  function r0(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  var ps = function(e2) {
    return new Zy.default(e2);
  };
  Object.assign(ps, e0);
  delete ps.__esModule;
  var n0 = ps;
  rr2.default = n0;
  mu2.exports = rr2.default;
});
var Su = S((Dx, ys) => {
  var { Rule: yu2, AtRule: i0 } = Ke(), vu2 = ve();
  function ms(t2, e2) {
    let r2;
    try {
      vu2((n2) => {
        r2 = n2;
      }).processSync(t2);
    } catch (n2) {
      throw t2.includes(":") ? e2 ? e2.error("Missed semicolon") : n2 : e2 ? e2.error(n2.message) : n2;
    }
    return r2.at(0);
  }
  function wu2(t2, e2) {
    let r2 = false;
    return t2.each((n2) => {
      if (n2.type === "nesting") {
        let i2 = e2.clone({});
        n2.value !== "&" ? n2.replaceWith(ms(n2.value.replace("&", i2.toString()))) : n2.replaceWith(i2), r2 = true;
      } else
        "nodes" in n2 && n2.nodes && wu2(n2, e2) && (r2 = true);
    }), r2;
  }
  function bu2(t2, e2) {
    let r2 = [];
    return t2.selectors.forEach((n2) => {
      let i2 = ms(n2, t2);
      e2.selectors.forEach((a2) => {
        if (!a2)
          return;
        let s2 = ms(a2, e2);
        wu2(s2, i2) || (s2.prepend(vu2.combinator({ value: " " })), s2.prepend(i2.clone({}))), r2.push(s2.toString());
      });
    }), r2;
  }
  function Zr2(t2, e2) {
    let r2 = t2.prev();
    for (e2.after(t2); r2 && r2.type === "comment"; ) {
      let n2 = r2.prev();
      e2.after(r2), r2 = n2;
    }
    return t2;
  }
  function s0(t2) {
    return function e2(r2, n2, i2, a2 = i2) {
      let s2 = [];
      if (n2.each((o2) => {
        o2.type === "rule" && i2 ? a2 && (o2.selectors = bu2(r2, o2)) : o2.type === "atrule" && o2.nodes ? t2[o2.name] ? e2(r2, o2, a2) : n2[gs] !== false && s2.push(o2) : s2.push(o2);
      }), i2 && s2.length) {
        let o2 = r2.clone({ nodes: [] });
        for (let l2 of s2)
          o2.append(l2);
        n2.prepend(o2);
      }
    };
  }
  function ds(t2, e2, r2) {
    let n2 = new yu2({ selector: t2, nodes: [] });
    return n2.append(e2), r2.after(n2), n2;
  }
  function gu2(t2, e2) {
    let r2 = {};
    for (let n2 of t2)
      r2[n2] = true;
    if (e2)
      for (let n2 of e2)
        r2[n2.replace(/^@/, "")] = true;
    return r2;
  }
  function a0(t2) {
    t2 = t2.trim();
    let e2 = t2.match(/^\((.*)\)$/);
    if (!e2)
      return { type: "basic", selector: t2 };
    let r2 = e2[1].match(/^(with(?:out)?):(.+)$/);
    if (r2) {
      let n2 = r2[1] === "with", i2 = Object.fromEntries(r2[2].trim().split(/\s+/).map((s2) => [s2, true]));
      if (n2 && i2.all)
        return { type: "noop" };
      let a2 = (s2) => !!i2[s2];
      return i2.all ? a2 = () => true : n2 && (a2 = (s2) => s2 === "all" ? false : !i2[s2]), { type: "withrules", escapes: a2 };
    }
    return { type: "unknown" };
  }
  function o0(t2) {
    let e2 = [], r2 = t2.parent;
    for (; r2 && r2 instanceof i0; )
      e2.push(r2), r2 = r2.parent;
    return e2;
  }
  function l0(t2) {
    let e2 = t2[xu2];
    if (!e2)
      t2.after(t2.nodes);
    else {
      let r2 = t2.nodes, n2, i2 = -1, a2, s2, o2, l2 = o0(t2);
      if (l2.forEach((u2, f2) => {
        if (e2(u2.name))
          n2 = u2, i2 = f2, s2 = o2;
        else {
          let p2 = o2;
          o2 = u2.clone({ nodes: [] }), p2 && o2.append(p2), a2 = a2 || o2;
        }
      }), n2 ? s2 ? (a2.append(r2), n2.after(s2)) : n2.after(r2) : t2.after(r2), t2.next() && n2) {
        let u2;
        l2.slice(0, i2 + 1).forEach((f2, p2, c2) => {
          let d2 = u2;
          u2 = f2.clone({ nodes: [] }), d2 && u2.append(d2);
          let h2 = [], m = (c2[p2 - 1] || t2).next();
          for (; m; )
            h2.push(m), m = m.next();
          u2.append(h2);
        }), u2 && (s2 || r2[r2.length - 1]).after(u2);
      }
    }
    t2.remove();
  }
  var gs = Symbol("rootRuleMergeSel"), xu2 = Symbol("rootRuleEscapes");
  function u0(t2) {
    let { params: e2 } = t2, { type: r2, selector: n2, escapes: i2 } = a0(e2);
    if (r2 === "unknown")
      throw t2.error(`Unknown @${t2.name} parameter ${JSON.stringify(e2)}`);
    if (r2 === "basic" && n2) {
      let a2 = new yu2({ selector: n2, nodes: t2.nodes });
      t2.removeAll(), t2.append(a2);
    }
    t2[xu2] = i2, t2[gs] = i2 ? !i2("all") : r2 === "noop";
  }
  var hs = Symbol("hasRootRule");
  ys.exports = (t2 = {}) => {
    let e2 = gu2(["media", "supports", "layer", "container"], t2.bubble), r2 = s0(e2), n2 = gu2(["document", "font-face", "keyframes", "-webkit-keyframes", "-moz-keyframes"], t2.unwrap), i2 = (t2.rootRuleName || "at-root").replace(/^@/, ""), a2 = t2.preserveEmpty;
    return { postcssPlugin: "postcss-nested", Once(s2) {
      s2.walkAtRules(i2, (o2) => {
        u0(o2), s2[hs] = true;
      });
    }, Rule(s2) {
      let o2 = false, l2 = s2, u2 = false, f2 = [];
      s2.each((p2) => {
        p2.type === "rule" ? (f2.length && (l2 = ds(s2.selector, f2, l2), f2 = []), u2 = true, o2 = true, p2.selectors = bu2(s2, p2), l2 = Zr2(p2, l2)) : p2.type === "atrule" ? (f2.length && (l2 = ds(s2.selector, f2, l2), f2 = []), p2.name === i2 ? (o2 = true, r2(s2, p2, true, p2[gs]), l2 = Zr2(p2, l2)) : e2[p2.name] ? (u2 = true, o2 = true, r2(s2, p2, true), l2 = Zr2(p2, l2)) : n2[p2.name] ? (u2 = true, o2 = true, r2(s2, p2, false), l2 = Zr2(p2, l2)) : u2 && f2.push(p2)) : p2.type === "decl" && u2 && f2.push(p2);
      }), f2.length && (l2 = ds(s2.selector, f2, l2)), o2 && a2 !== true && (s2.raws.semicolon = true, s2.nodes.length === 0 && s2.remove());
    }, RootExit(s2) {
      s2[hs] && (s2.walkAtRules(i2, l0), s2[hs] = false);
    } };
  };
  ys.exports.postcss = true;
});
var Cu = S((Mx, Eu2) => {
  "use strict";
  var ku2 = /-(\w|$)/g, Ou2 = function(e2, r2) {
    return r2.toUpperCase();
  }, f0 = function(e2) {
    return e2 = e2.toLowerCase(), e2 === "float" ? "cssFloat" : e2.charCodeAt(0) === 45 && e2.charCodeAt(1) === 109 && e2.charCodeAt(2) === 115 && e2.charCodeAt(3) === 45 ? e2.substr(1).replace(ku2, Ou2) : e2.replace(ku2, Ou2);
  };
  Eu2.exports = f0;
});
var bs = S((Fx, Au2) => {
  var c0 = Cu(), p0 = { boxFlex: true, boxFlexGroup: true, columnCount: true, flex: true, flexGrow: true, flexPositive: true, flexShrink: true, flexNegative: true, fontWeight: true, lineClamp: true, lineHeight: true, opacity: true, order: true, orphans: true, tabSize: true, widows: true, zIndex: true, zoom: true, fillOpacity: true, strokeDashoffset: true, strokeOpacity: true, strokeWidth: true };
  function vs(t2) {
    return typeof t2.nodes > "u" ? true : ws(t2);
  }
  function ws(t2) {
    let e2, r2 = {};
    return t2.each((n2) => {
      if (n2.type === "atrule")
        e2 = "@" + n2.name, n2.params && (e2 += " " + n2.params), typeof r2[e2] > "u" ? r2[e2] = vs(n2) : Array.isArray(r2[e2]) ? r2[e2].push(vs(n2)) : r2[e2] = [r2[e2], vs(n2)];
      else if (n2.type === "rule") {
        let i2 = ws(n2);
        if (r2[n2.selector])
          for (let a2 in i2)
            r2[n2.selector][a2] = i2[a2];
        else
          r2[n2.selector] = i2;
      } else if (n2.type === "decl") {
        n2.prop[0] === "-" && n2.prop[1] === "-" || n2.parent && n2.parent.selector === ":export" ? e2 = n2.prop : e2 = c0(n2.prop);
        let i2 = n2.value;
        !isNaN(n2.value) && p0[e2] && (i2 = parseFloat(n2.value)), n2.important && (i2 += " !important"), typeof r2[e2] > "u" ? r2[e2] = i2 : Array.isArray(r2[e2]) ? r2[e2].push(i2) : r2[e2] = [r2[e2], i2];
      }
    }), r2;
  }
  Au2.exports = ws;
});
var en = S((Lx, Iu2) => {
  var nr2 = Ke(), _u2 = /\s*!important\s*$/i, d0 = { "box-flex": true, "box-flex-group": true, "column-count": true, flex: true, "flex-grow": true, "flex-positive": true, "flex-shrink": true, "flex-negative": true, "font-weight": true, "line-clamp": true, "line-height": true, opacity: true, order: true, orphans: true, "tab-size": true, widows: true, "z-index": true, zoom: true, "fill-opacity": true, "stroke-dashoffset": true, "stroke-opacity": true, "stroke-width": true };
  function h0(t2) {
    return t2.replace(/([A-Z])/g, "-$1").replace(/^ms-/, "-ms-").toLowerCase();
  }
  function Tu2(t2, e2, r2) {
    r2 === false || r2 === null || (e2.startsWith("--") || (e2 = h0(e2)), typeof r2 == "number" && (r2 === 0 || d0[e2] ? r2 = r2.toString() : r2 += "px"), e2 === "css-float" && (e2 = "float"), _u2.test(r2) ? (r2 = r2.replace(_u2, ""), t2.push(nr2.decl({ prop: e2, value: r2, important: true }))) : t2.push(nr2.decl({ prop: e2, value: r2 })));
  }
  function Pu2(t2, e2, r2) {
    let n2 = nr2.atRule({ name: e2[1], params: e2[3] || "" });
    typeof r2 == "object" && (n2.nodes = [], xs(r2, n2)), t2.push(n2);
  }
  function xs(t2, e2) {
    let r2, n2, i2;
    for (r2 in t2)
      if (n2 = t2[r2], !(n2 === null || typeof n2 > "u"))
        if (r2[0] === "@") {
          let a2 = r2.match(/@(\S+)(\s+([\W\w]*)\s*)?/);
          if (Array.isArray(n2))
            for (let s2 of n2)
              Pu2(e2, a2, s2);
          else
            Pu2(e2, a2, n2);
        } else if (Array.isArray(n2))
          for (let a2 of n2)
            Tu2(e2, r2, a2);
        else
          typeof n2 == "object" ? (i2 = nr2.rule({ selector: r2 }), xs(n2, i2), e2.push(i2)) : Tu2(e2, r2, n2);
  }
  Iu2.exports = function(t2) {
    let e2 = nr2.root();
    return xs(t2, e2), e2;
  };
});
var Ss = S((Nx, Ru2) => {
  var m0 = bs();
  Ru2.exports = function(e2) {
    return console && console.warn && e2.warnings().forEach((r2) => {
      let n2 = r2.plugin || "PostCSS";
      console.warn(n2 + ": " + r2.text);
    }), m0(e2.root);
  };
});
var Mu = S((qx, Du2) => {
  var g0 = Ke(), y0 = Ss(), v0 = en();
  Du2.exports = function(e2) {
    let r2 = g0(e2);
    return async (n2) => {
      let i2 = await r2.process(n2, { parser: v0, from: void 0 });
      return y0(i2);
    };
  };
});
var Lu = S(($x, Fu2) => {
  var w0 = Ke(), b0 = Ss(), x0 = en();
  Fu2.exports = function(t2) {
    let e2 = w0(t2);
    return (r2) => {
      let n2 = e2.process(r2, { parser: x0, from: void 0 });
      return b0(n2);
    };
  };
});
var qu = S((Ux, Nu2) => {
  var S0 = bs(), k0 = en(), O0 = Mu(), E0 = Lu();
  Nu2.exports = { objectify: S0, parse: k0, async: O0, sync: E0 };
});
var qs = S((Ls, Ns) => {
  (function(t2, e2) {
    typeof Ls == "object" && typeof Ns < "u" ? Ns.exports = function(r2, n2, i2, a2, s2) {
      for (n2 = n2.split ? n2.split(".") : n2, a2 = 0; a2 < n2.length; a2++)
        r2 = r2 ? r2[n2[a2]] : s2;
      return r2 === s2 ? i2 : r2;
    } : typeof define == "function" && define.amd ? define(function() {
      return function(r2, n2, i2, a2, s2) {
        for (n2 = n2.split ? n2.split(".") : n2, a2 = 0; a2 < n2.length; a2++)
          r2 = r2 ? r2[n2[a2]] : s2;
        return r2 === s2 ? i2 : r2;
      };
    }) : t2.dlv = function(r2, n2, i2, a2, s2) {
      for (n2 = n2.split ? n2.split(".") : n2, a2 = 0; a2 < n2.length; a2++)
        r2 = r2 ? r2[n2[a2]] : s2;
      return r2 === s2 ? i2 : r2;
    };
  })(Ls);
});
var Bf = S((bk, On2) => {
  (function() {
    "use strict";
    function t2(n2, i2, a2) {
      if (!n2)
        return null;
      t2.caseSensitive || (n2 = n2.toLowerCase());
      var s2 = t2.threshold === null ? null : t2.threshold * n2.length, o2 = t2.thresholdAbsolute, l2;
      s2 !== null && o2 !== null ? l2 = Math.min(s2, o2) : s2 !== null ? l2 = s2 : o2 !== null ? l2 = o2 : l2 = null;
      var u2, f2, p2, c2, d2, h2 = i2.length;
      for (d2 = 0; d2 < h2; d2++)
        if (f2 = i2[d2], a2 && (f2 = f2[a2]), !!f2 && (t2.caseSensitive ? p2 = f2 : p2 = f2.toLowerCase(), c2 = r2(n2, p2, l2), (l2 === null || c2 < l2) && (l2 = c2, a2 && t2.returnWinningObject ? u2 = i2[d2] : u2 = f2, t2.returnFirstMatch)))
          return u2;
      return u2 || t2.nullResultValue;
    }
    t2.threshold = 0.4, t2.thresholdAbsolute = 20, t2.caseSensitive = false, t2.nullResultValue = null, t2.returnWinningObject = null, t2.returnFirstMatch = false, typeof On2 < "u" && On2.exports ? On2.exports = t2 : window.didYouMean = t2;
    var e2 = Math.pow(2, 32) - 1;
    function r2(n2, i2, a2) {
      a2 = a2 || a2 === 0 ? a2 : e2;
      var s2 = n2.length, o2 = i2.length;
      if (s2 === 0)
        return Math.min(a2 + 1, o2);
      if (o2 === 0)
        return Math.min(a2 + 1, s2);
      if (Math.abs(s2 - o2) > a2)
        return a2 + 1;
      var l2 = [], u2, f2, p2, c2, d2;
      for (u2 = 0; u2 <= o2; u2++)
        l2[u2] = [u2];
      for (f2 = 0; f2 <= s2; f2++)
        l2[0][f2] = f2;
      for (u2 = 1; u2 <= o2; u2++) {
        for (p2 = e2, c2 = 1, u2 > a2 && (c2 = u2 - a2), d2 = o2 + 1, d2 > a2 + u2 && (d2 = a2 + u2), f2 = 1; f2 <= s2; f2++)
          f2 < c2 || f2 > d2 ? l2[u2][f2] = a2 + 1 : i2.charAt(u2 - 1) === n2.charAt(f2 - 1) ? l2[u2][f2] = l2[u2 - 1][f2 - 1] : l2[u2][f2] = Math.min(l2[u2 - 1][f2 - 1] + 1, Math.min(l2[u2][f2 - 1] + 1, l2[u2 - 1][f2] + 1)), l2[u2][f2] < p2 && (p2 = l2[u2][f2]);
        if (p2 > a2)
          return a2 + 1;
      }
      return l2[o2][s2];
    }
  })();
});
var Yf = S((xk, Gf) => {
  var Ks = "(".charCodeAt(0), Zs = ")".charCodeAt(0), En2 = "'".charCodeAt(0), ea = '"'.charCodeAt(0), ta = "\\".charCodeAt(0), ft2 = "/".charCodeAt(0), ra = ",".charCodeAt(0), na = ":".charCodeAt(0), Cn2 = "*".charCodeAt(0), Yv = "u".charCodeAt(0), Hv = "U".charCodeAt(0), Qv = "+".charCodeAt(0), Jv = /^[a-f0-9?-]+$/i;
  Gf.exports = function(t2) {
    for (var e2 = [], r2 = t2, n2, i2, a2, s2, o2, l2, u2, f2, p2 = 0, c2 = r2.charCodeAt(p2), d2 = r2.length, h2 = [{ nodes: e2 }], y3 = 0, m, g2 = "", w2 = "", b3 = ""; p2 < d2; )
      if (c2 <= 32) {
        n2 = p2;
        do
          n2 += 1, c2 = r2.charCodeAt(n2);
        while (c2 <= 32);
        s2 = r2.slice(p2, n2), a2 = e2[e2.length - 1], c2 === Zs && y3 ? b3 = s2 : a2 && a2.type === "div" ? (a2.after = s2, a2.sourceEndIndex += s2.length) : c2 === ra || c2 === na || c2 === ft2 && r2.charCodeAt(n2 + 1) !== Cn2 && (!m || m && m.type === "function" && m.value !== "calc") ? w2 = s2 : e2.push({ type: "space", sourceIndex: p2, sourceEndIndex: n2, value: s2 }), p2 = n2;
      } else if (c2 === En2 || c2 === ea) {
        n2 = p2, i2 = c2 === En2 ? "'" : '"', s2 = { type: "string", sourceIndex: p2, quote: i2 };
        do
          if (o2 = false, n2 = r2.indexOf(i2, n2 + 1), ~n2)
            for (l2 = n2; r2.charCodeAt(l2 - 1) === ta; )
              l2 -= 1, o2 = !o2;
          else
            r2 += i2, n2 = r2.length - 1, s2.unclosed = true;
        while (o2);
        s2.value = r2.slice(p2 + 1, n2), s2.sourceEndIndex = s2.unclosed ? n2 : n2 + 1, e2.push(s2), p2 = n2 + 1, c2 = r2.charCodeAt(p2);
      } else if (c2 === ft2 && r2.charCodeAt(p2 + 1) === Cn2)
        n2 = r2.indexOf("*/", p2), s2 = { type: "comment", sourceIndex: p2, sourceEndIndex: n2 + 2 }, n2 === -1 && (s2.unclosed = true, n2 = r2.length, s2.sourceEndIndex = n2), s2.value = r2.slice(p2 + 2, n2), e2.push(s2), p2 = n2 + 2, c2 = r2.charCodeAt(p2);
      else if ((c2 === ft2 || c2 === Cn2) && m && m.type === "function" && m.value === "calc")
        s2 = r2[p2], e2.push({ type: "word", sourceIndex: p2 - w2.length, sourceEndIndex: p2 + s2.length, value: s2 }), p2 += 1, c2 = r2.charCodeAt(p2);
      else if (c2 === ft2 || c2 === ra || c2 === na)
        s2 = r2[p2], e2.push({ type: "div", sourceIndex: p2 - w2.length, sourceEndIndex: p2 + s2.length, value: s2, before: w2, after: "" }), w2 = "", p2 += 1, c2 = r2.charCodeAt(p2);
      else if (Ks === c2) {
        n2 = p2;
        do
          n2 += 1, c2 = r2.charCodeAt(n2);
        while (c2 <= 32);
        if (f2 = p2, s2 = { type: "function", sourceIndex: p2 - g2.length, value: g2, before: r2.slice(f2 + 1, n2) }, p2 = n2, g2 === "url" && c2 !== En2 && c2 !== ea) {
          n2 -= 1;
          do
            if (o2 = false, n2 = r2.indexOf(")", n2 + 1), ~n2)
              for (l2 = n2; r2.charCodeAt(l2 - 1) === ta; )
                l2 -= 1, o2 = !o2;
            else
              r2 += ")", n2 = r2.length - 1, s2.unclosed = true;
          while (o2);
          u2 = n2;
          do
            u2 -= 1, c2 = r2.charCodeAt(u2);
          while (c2 <= 32);
          f2 < u2 ? (p2 !== u2 + 1 ? s2.nodes = [{ type: "word", sourceIndex: p2, sourceEndIndex: u2 + 1, value: r2.slice(p2, u2 + 1) }] : s2.nodes = [], s2.unclosed && u2 + 1 !== n2 ? (s2.after = "", s2.nodes.push({ type: "space", sourceIndex: u2 + 1, sourceEndIndex: n2, value: r2.slice(u2 + 1, n2) })) : (s2.after = r2.slice(u2 + 1, n2), s2.sourceEndIndex = n2)) : (s2.after = "", s2.nodes = []), p2 = n2 + 1, s2.sourceEndIndex = s2.unclosed ? n2 : p2, c2 = r2.charCodeAt(p2), e2.push(s2);
        } else
          y3 += 1, s2.after = "", s2.sourceEndIndex = p2 + 1, e2.push(s2), h2.push(s2), e2 = s2.nodes = [], m = s2;
        g2 = "";
      } else if (Zs === c2 && y3)
        p2 += 1, c2 = r2.charCodeAt(p2), m.after = b3, m.sourceEndIndex += b3.length, b3 = "", y3 -= 1, h2[h2.length - 1].sourceEndIndex = p2, h2.pop(), m = h2[y3], e2 = m.nodes;
      else {
        n2 = p2;
        do
          c2 === ta && (n2 += 1), n2 += 1, c2 = r2.charCodeAt(n2);
        while (n2 < d2 && !(c2 <= 32 || c2 === En2 || c2 === ea || c2 === ra || c2 === na || c2 === ft2 || c2 === Ks || c2 === Cn2 && m && m.type === "function" && m.value === "calc" || c2 === ft2 && m.type === "function" && m.value === "calc" || c2 === Zs && y3));
        s2 = r2.slice(p2, n2), Ks === c2 ? g2 = s2 : (Yv === s2.charCodeAt(0) || Hv === s2.charCodeAt(0)) && Qv === s2.charCodeAt(1) && Jv.test(s2.slice(2)) ? e2.push({ type: "unicode-range", sourceIndex: p2, sourceEndIndex: n2, value: s2 }) : e2.push({ type: "word", sourceIndex: p2, sourceEndIndex: n2, value: s2 }), p2 = n2;
      }
    for (p2 = h2.length - 1; p2; p2 -= 1)
      h2[p2].unclosed = true, h2[p2].sourceEndIndex = r2.length;
    return h2[0].nodes;
  };
});
var Qf = S((Sk, Hf) => {
  Hf.exports = function t2(e2, r2, n2) {
    var i2, a2, s2, o2;
    for (i2 = 0, a2 = e2.length; i2 < a2; i2 += 1)
      s2 = e2[i2], n2 || (o2 = r2(s2, i2, e2)), o2 !== false && s2.type === "function" && Array.isArray(s2.nodes) && t2(s2.nodes, r2, n2), n2 && r2(s2, i2, e2);
  };
});
var Zf = S((kk, Kf) => {
  function Jf(t2, e2) {
    var r2 = t2.type, n2 = t2.value, i2, a2;
    return e2 && (a2 = e2(t2)) !== void 0 ? a2 : r2 === "word" || r2 === "space" ? n2 : r2 === "string" ? (i2 = t2.quote || "", i2 + n2 + (t2.unclosed ? "" : i2)) : r2 === "comment" ? "/*" + n2 + (t2.unclosed ? "" : "*/") : r2 === "div" ? (t2.before || "") + n2 + (t2.after || "") : Array.isArray(t2.nodes) ? (i2 = Xf(t2.nodes, e2), r2 !== "function" ? i2 : n2 + "(" + (t2.before || "") + i2 + (t2.after || "") + (t2.unclosed ? "" : ")")) : n2;
  }
  function Xf(t2, e2) {
    var r2, n2;
    if (Array.isArray(t2)) {
      for (r2 = "", n2 = t2.length - 1; ~n2; n2 -= 1)
        r2 = Jf(t2[n2], e2) + r2;
      return r2;
    }
    return Jf(t2, e2);
  }
  Kf.exports = Xf;
});
var tc = S((Ok, ec) => {
  var An2 = "-".charCodeAt(0), _n2 = "+".charCodeAt(0), ia = ".".charCodeAt(0), Xv = "e".charCodeAt(0), Kv = "E".charCodeAt(0);
  function Zv(t2) {
    var e2 = t2.charCodeAt(0), r2;
    if (e2 === _n2 || e2 === An2) {
      if (r2 = t2.charCodeAt(1), r2 >= 48 && r2 <= 57)
        return true;
      var n2 = t2.charCodeAt(2);
      return r2 === ia && n2 >= 48 && n2 <= 57;
    }
    return e2 === ia ? (r2 = t2.charCodeAt(1), r2 >= 48 && r2 <= 57) : e2 >= 48 && e2 <= 57;
  }
  ec.exports = function(t2) {
    var e2 = 0, r2 = t2.length, n2, i2, a2;
    if (r2 === 0 || !Zv(t2))
      return false;
    for (n2 = t2.charCodeAt(e2), (n2 === _n2 || n2 === An2) && e2++; e2 < r2 && (n2 = t2.charCodeAt(e2), !(n2 < 48 || n2 > 57)); )
      e2 += 1;
    if (n2 = t2.charCodeAt(e2), i2 = t2.charCodeAt(e2 + 1), n2 === ia && i2 >= 48 && i2 <= 57)
      for (e2 += 2; e2 < r2 && (n2 = t2.charCodeAt(e2), !(n2 < 48 || n2 > 57)); )
        e2 += 1;
    if (n2 = t2.charCodeAt(e2), i2 = t2.charCodeAt(e2 + 1), a2 = t2.charCodeAt(e2 + 2), (n2 === Xv || n2 === Kv) && (i2 >= 48 && i2 <= 57 || (i2 === _n2 || i2 === An2) && a2 >= 48 && a2 <= 57))
      for (e2 += i2 === _n2 || i2 === An2 ? 3 : 2; e2 < r2 && (n2 = t2.charCodeAt(e2), !(n2 < 48 || n2 > 57)); )
        e2 += 1;
    return { number: t2.slice(0, e2), unit: t2.slice(e2) };
  };
});
var sc = S((Ek, ic) => {
  var ew = Yf(), rc = Qf(), nc = Zf();
  function Ne2(t2) {
    return this instanceof Ne2 ? (this.nodes = ew(t2), this) : new Ne2(t2);
  }
  Ne2.prototype.toString = function() {
    return Array.isArray(this.nodes) ? nc(this.nodes) : "";
  };
  Ne2.prototype.walk = function(t2, e2) {
    return rc(this.nodes, t2, e2), this;
  };
  Ne2.unit = tc();
  Ne2.walk = rc;
  Ne2.stringify = nc;
  ic.exports = Ne2;
});
var Sc = S((CO, xc) => {
  xc.exports = { content: [], presets: [], darkMode: "media", theme: { accentColor: ({ theme: t2 }) => ({ ...t2("colors"), auto: "auto" }), animation: { none: "none", spin: "spin 1s linear infinite", ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite", pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite", bounce: "bounce 1s infinite" }, aria: { checked: 'checked="true"', disabled: 'disabled="true"', expanded: 'expanded="true"', hidden: 'hidden="true"', pressed: 'pressed="true"', readonly: 'readonly="true"', required: 'required="true"', selected: 'selected="true"' }, aspectRatio: { auto: "auto", square: "1 / 1", video: "16 / 9" }, backdropBlur: ({ theme: t2 }) => t2("blur"), backdropBrightness: ({ theme: t2 }) => t2("brightness"), backdropContrast: ({ theme: t2 }) => t2("contrast"), backdropGrayscale: ({ theme: t2 }) => t2("grayscale"), backdropHueRotate: ({ theme: t2 }) => t2("hueRotate"), backdropInvert: ({ theme: t2 }) => t2("invert"), backdropOpacity: ({ theme: t2 }) => t2("opacity"), backdropSaturate: ({ theme: t2 }) => t2("saturate"), backdropSepia: ({ theme: t2 }) => t2("sepia"), backgroundColor: ({ theme: t2 }) => t2("colors"), backgroundImage: { none: "none", "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))", "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))", "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))", "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))", "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))", "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))", "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))", "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))" }, backgroundOpacity: ({ theme: t2 }) => t2("opacity"), backgroundPosition: { bottom: "bottom", center: "center", left: "left", "left-bottom": "left bottom", "left-top": "left top", right: "right", "right-bottom": "right bottom", "right-top": "right top", top: "top" }, backgroundSize: { auto: "auto", cover: "cover", contain: "contain" }, blur: { 0: "0", none: "0", sm: "4px", DEFAULT: "8px", md: "12px", lg: "16px", xl: "24px", "2xl": "40px", "3xl": "64px" }, borderColor: ({ theme: t2 }) => ({ ...t2("colors"), DEFAULT: t2("colors.gray.200", "currentColor") }), borderOpacity: ({ theme: t2 }) => t2("opacity"), borderRadius: { none: "0px", sm: "0.125rem", DEFAULT: "0.25rem", md: "0.375rem", lg: "0.5rem", xl: "0.75rem", "2xl": "1rem", "3xl": "1.5rem", full: "9999px" }, borderSpacing: ({ theme: t2 }) => ({ ...t2("spacing") }), borderWidth: { DEFAULT: "1px", 0: "0px", 2: "2px", 4: "4px", 8: "8px" }, boxShadow: { sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)", DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)", md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)", lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)", xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)", "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)", inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)", none: "none" }, boxShadowColor: ({ theme: t2 }) => t2("colors"), brightness: { 0: "0", 50: ".5", 75: ".75", 90: ".9", 95: ".95", 100: "1", 105: "1.05", 110: "1.1", 125: "1.25", 150: "1.5", 200: "2" }, caretColor: ({ theme: t2 }) => t2("colors"), colors: ({ colors: t2 }) => ({ inherit: t2.inherit, current: t2.current, transparent: t2.transparent, black: t2.black, white: t2.white, slate: t2.slate, gray: t2.gray, zinc: t2.zinc, neutral: t2.neutral, stone: t2.stone, red: t2.red, orange: t2.orange, amber: t2.amber, yellow: t2.yellow, lime: t2.lime, green: t2.green, emerald: t2.emerald, teal: t2.teal, cyan: t2.cyan, sky: t2.sky, blue: t2.blue, indigo: t2.indigo, violet: t2.violet, purple: t2.purple, fuchsia: t2.fuchsia, pink: t2.pink, rose: t2.rose }), columns: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", "3xs": "16rem", "2xs": "18rem", xs: "20rem", sm: "24rem", md: "28rem", lg: "32rem", xl: "36rem", "2xl": "42rem", "3xl": "48rem", "4xl": "56rem", "5xl": "64rem", "6xl": "72rem", "7xl": "80rem" }, container: {}, content: { none: "none" }, contrast: { 0: "0", 50: ".5", 75: ".75", 100: "1", 125: "1.25", 150: "1.5", 200: "2" }, cursor: { auto: "auto", default: "default", pointer: "pointer", wait: "wait", text: "text", move: "move", help: "help", "not-allowed": "not-allowed", none: "none", "context-menu": "context-menu", progress: "progress", cell: "cell", crosshair: "crosshair", "vertical-text": "vertical-text", alias: "alias", copy: "copy", "no-drop": "no-drop", grab: "grab", grabbing: "grabbing", "all-scroll": "all-scroll", "col-resize": "col-resize", "row-resize": "row-resize", "n-resize": "n-resize", "e-resize": "e-resize", "s-resize": "s-resize", "w-resize": "w-resize", "ne-resize": "ne-resize", "nw-resize": "nw-resize", "se-resize": "se-resize", "sw-resize": "sw-resize", "ew-resize": "ew-resize", "ns-resize": "ns-resize", "nesw-resize": "nesw-resize", "nwse-resize": "nwse-resize", "zoom-in": "zoom-in", "zoom-out": "zoom-out" }, divideColor: ({ theme: t2 }) => t2("borderColor"), divideOpacity: ({ theme: t2 }) => t2("borderOpacity"), divideWidth: ({ theme: t2 }) => t2("borderWidth"), dropShadow: { sm: "0 1px 1px rgb(0 0 0 / 0.05)", DEFAULT: ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"], md: ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"], lg: ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"], xl: ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"], "2xl": "0 25px 25px rgb(0 0 0 / 0.15)", none: "0 0 #0000" }, fill: ({ theme: t2 }) => ({ none: "none", ...t2("colors") }), flex: { 1: "1 1 0%", auto: "1 1 auto", initial: "0 1 auto", none: "none" }, flexBasis: ({ theme: t2 }) => ({ auto: "auto", ...t2("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", "1/12": "8.333333%", "2/12": "16.666667%", "3/12": "25%", "4/12": "33.333333%", "5/12": "41.666667%", "6/12": "50%", "7/12": "58.333333%", "8/12": "66.666667%", "9/12": "75%", "10/12": "83.333333%", "11/12": "91.666667%", full: "100%" }), flexGrow: { 0: "0", DEFAULT: "1" }, flexShrink: { 0: "0", DEFAULT: "1" }, fontFamily: { sans: ["ui-sans-serif", "system-ui", "-apple-system", "BlinkMacSystemFont", '"Segoe UI"', "Roboto", '"Helvetica Neue"', "Arial", '"Noto Sans"', "sans-serif", '"Apple Color Emoji"', '"Segoe UI Emoji"', '"Segoe UI Symbol"', '"Noto Color Emoji"'], serif: ["ui-serif", "Georgia", "Cambria", '"Times New Roman"', "Times", "serif"], mono: ["ui-monospace", "SFMono-Regular", "Menlo", "Monaco", "Consolas", '"Liberation Mono"', '"Courier New"', "monospace"] }, fontSize: { xs: ["0.75rem", { lineHeight: "1rem" }], sm: ["0.875rem", { lineHeight: "1.25rem" }], base: ["1rem", { lineHeight: "1.5rem" }], lg: ["1.125rem", { lineHeight: "1.75rem" }], xl: ["1.25rem", { lineHeight: "1.75rem" }], "2xl": ["1.5rem", { lineHeight: "2rem" }], "3xl": ["1.875rem", { lineHeight: "2.25rem" }], "4xl": ["2.25rem", { lineHeight: "2.5rem" }], "5xl": ["3rem", { lineHeight: "1" }], "6xl": ["3.75rem", { lineHeight: "1" }], "7xl": ["4.5rem", { lineHeight: "1" }], "8xl": ["6rem", { lineHeight: "1" }], "9xl": ["8rem", { lineHeight: "1" }] }, fontWeight: { thin: "100", extralight: "200", light: "300", normal: "400", medium: "500", semibold: "600", bold: "700", extrabold: "800", black: "900" }, gap: ({ theme: t2 }) => t2("spacing"), gradientColorStops: ({ theme: t2 }) => t2("colors"), gradientColorStopPositions: { "0%": "0%", "5%": "5%", "10%": "10%", "15%": "15%", "20%": "20%", "25%": "25%", "30%": "30%", "35%": "35%", "40%": "40%", "45%": "45%", "50%": "50%", "55%": "55%", "60%": "60%", "65%": "65%", "70%": "70%", "75%": "75%", "80%": "80%", "85%": "85%", "90%": "90%", "95%": "95%", "100%": "100%" }, grayscale: { 0: "0", DEFAULT: "100%" }, gridAutoColumns: { auto: "auto", min: "min-content", max: "max-content", fr: "minmax(0, 1fr)" }, gridAutoRows: { auto: "auto", min: "min-content", max: "max-content", fr: "minmax(0, 1fr)" }, gridColumn: { auto: "auto", "span-1": "span 1 / span 1", "span-2": "span 2 / span 2", "span-3": "span 3 / span 3", "span-4": "span 4 / span 4", "span-5": "span 5 / span 5", "span-6": "span 6 / span 6", "span-7": "span 7 / span 7", "span-8": "span 8 / span 8", "span-9": "span 9 / span 9", "span-10": "span 10 / span 10", "span-11": "span 11 / span 11", "span-12": "span 12 / span 12", "span-full": "1 / -1" }, gridColumnEnd: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", 13: "13" }, gridColumnStart: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", 13: "13" }, gridRow: { auto: "auto", "span-1": "span 1 / span 1", "span-2": "span 2 / span 2", "span-3": "span 3 / span 3", "span-4": "span 4 / span 4", "span-5": "span 5 / span 5", "span-6": "span 6 / span 6", "span-full": "1 / -1" }, gridRowEnd: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7" }, gridRowStart: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7" }, gridTemplateColumns: { none: "none", 1: "repeat(1, minmax(0, 1fr))", 2: "repeat(2, minmax(0, 1fr))", 3: "repeat(3, minmax(0, 1fr))", 4: "repeat(4, minmax(0, 1fr))", 5: "repeat(5, minmax(0, 1fr))", 6: "repeat(6, minmax(0, 1fr))", 7: "repeat(7, minmax(0, 1fr))", 8: "repeat(8, minmax(0, 1fr))", 9: "repeat(9, minmax(0, 1fr))", 10: "repeat(10, minmax(0, 1fr))", 11: "repeat(11, minmax(0, 1fr))", 12: "repeat(12, minmax(0, 1fr))" }, gridTemplateRows: { none: "none", 1: "repeat(1, minmax(0, 1fr))", 2: "repeat(2, minmax(0, 1fr))", 3: "repeat(3, minmax(0, 1fr))", 4: "repeat(4, minmax(0, 1fr))", 5: "repeat(5, minmax(0, 1fr))", 6: "repeat(6, minmax(0, 1fr))" }, height: ({ theme: t2 }) => ({ auto: "auto", ...t2("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", full: "100%", screen: "100vh", min: "min-content", max: "max-content", fit: "fit-content" }), hueRotate: { 0: "0deg", 15: "15deg", 30: "30deg", 60: "60deg", 90: "90deg", 180: "180deg" }, inset: ({ theme: t2 }) => ({ auto: "auto", ...t2("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", full: "100%" }), invert: { 0: "0", DEFAULT: "100%" }, keyframes: { spin: { to: { transform: "rotate(360deg)" } }, ping: { "75%, 100%": { transform: "scale(2)", opacity: "0" } }, pulse: { "50%": { opacity: ".5" } }, bounce: { "0%, 100%": { transform: "translateY(-25%)", animationTimingFunction: "cubic-bezier(0.8,0,1,1)" }, "50%": { transform: "none", animationTimingFunction: "cubic-bezier(0,0,0.2,1)" } } }, letterSpacing: { tighter: "-0.05em", tight: "-0.025em", normal: "0em", wide: "0.025em", wider: "0.05em", widest: "0.1em" }, lineHeight: { none: "1", tight: "1.25", snug: "1.375", normal: "1.5", relaxed: "1.625", loose: "2", 3: ".75rem", 4: "1rem", 5: "1.25rem", 6: "1.5rem", 7: "1.75rem", 8: "2rem", 9: "2.25rem", 10: "2.5rem" }, listStyleType: { none: "none", disc: "disc", decimal: "decimal" }, listStyleImage: { none: "none" }, margin: ({ theme: t2 }) => ({ auto: "auto", ...t2("spacing") }), lineClamp: { 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6" }, maxHeight: ({ theme: t2 }) => ({ ...t2("spacing"), none: "none", full: "100%", screen: "100vh", min: "min-content", max: "max-content", fit: "fit-content" }), maxWidth: ({ theme: t2, breakpoints: e2 }) => ({ none: "none", 0: "0rem", xs: "20rem", sm: "24rem", md: "28rem", lg: "32rem", xl: "36rem", "2xl": "42rem", "3xl": "48rem", "4xl": "56rem", "5xl": "64rem", "6xl": "72rem", "7xl": "80rem", full: "100%", min: "min-content", max: "max-content", fit: "fit-content", prose: "65ch", ...e2(t2("screens")) }), minHeight: { 0: "0px", full: "100%", screen: "100vh", min: "min-content", max: "max-content", fit: "fit-content" }, minWidth: { 0: "0px", full: "100%", min: "min-content", max: "max-content", fit: "fit-content" }, objectPosition: { bottom: "bottom", center: "center", left: "left", "left-bottom": "left bottom", "left-top": "left top", right: "right", "right-bottom": "right bottom", "right-top": "right top", top: "top" }, opacity: { 0: "0", 5: "0.05", 10: "0.1", 20: "0.2", 25: "0.25", 30: "0.3", 40: "0.4", 50: "0.5", 60: "0.6", 70: "0.7", 75: "0.75", 80: "0.8", 90: "0.9", 95: "0.95", 100: "1" }, order: { first: "-9999", last: "9999", none: "0", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12" }, outlineColor: ({ theme: t2 }) => t2("colors"), outlineOffset: { 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, outlineWidth: { 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, padding: ({ theme: t2 }) => t2("spacing"), placeholderColor: ({ theme: t2 }) => t2("colors"), placeholderOpacity: ({ theme: t2 }) => t2("opacity"), ringColor: ({ theme: t2 }) => ({ DEFAULT: t2("colors.blue.500", "#3b82f6"), ...t2("colors") }), ringOffsetColor: ({ theme: t2 }) => t2("colors"), ringOffsetWidth: { 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, ringOpacity: ({ theme: t2 }) => ({ DEFAULT: "0.5", ...t2("opacity") }), ringWidth: { DEFAULT: "3px", 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, rotate: { 0: "0deg", 1: "1deg", 2: "2deg", 3: "3deg", 6: "6deg", 12: "12deg", 45: "45deg", 90: "90deg", 180: "180deg" }, saturate: { 0: "0", 50: ".5", 100: "1", 150: "1.5", 200: "2" }, scale: { 0: "0", 50: ".5", 75: ".75", 90: ".9", 95: ".95", 100: "1", 105: "1.05", 110: "1.1", 125: "1.25", 150: "1.5" }, screens: { sm: "640px", md: "768px", lg: "1024px", xl: "1280px", "2xl": "1536px" }, scrollMargin: ({ theme: t2 }) => ({ ...t2("spacing") }), scrollPadding: ({ theme: t2 }) => t2("spacing"), sepia: { 0: "0", DEFAULT: "100%" }, skew: { 0: "0deg", 1: "1deg", 2: "2deg", 3: "3deg", 6: "6deg", 12: "12deg" }, space: ({ theme: t2 }) => ({ ...t2("spacing") }), spacing: { px: "1px", 0: "0px", 0.5: "0.125rem", 1: "0.25rem", 1.5: "0.375rem", 2: "0.5rem", 2.5: "0.625rem", 3: "0.75rem", 3.5: "0.875rem", 4: "1rem", 5: "1.25rem", 6: "1.5rem", 7: "1.75rem", 8: "2rem", 9: "2.25rem", 10: "2.5rem", 11: "2.75rem", 12: "3rem", 14: "3.5rem", 16: "4rem", 20: "5rem", 24: "6rem", 28: "7rem", 32: "8rem", 36: "9rem", 40: "10rem", 44: "11rem", 48: "12rem", 52: "13rem", 56: "14rem", 60: "15rem", 64: "16rem", 72: "18rem", 80: "20rem", 96: "24rem" }, stroke: ({ theme: t2 }) => ({ none: "none", ...t2("colors") }), strokeWidth: { 0: "0", 1: "1", 2: "2" }, supports: {}, data: {}, textColor: ({ theme: t2 }) => t2("colors"), textDecorationColor: ({ theme: t2 }) => t2("colors"), textDecorationThickness: { auto: "auto", "from-font": "from-font", 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, textIndent: ({ theme: t2 }) => ({ ...t2("spacing") }), textOpacity: ({ theme: t2 }) => t2("opacity"), textUnderlineOffset: { auto: "auto", 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, transformOrigin: { center: "center", top: "top", "top-right": "top right", right: "right", "bottom-right": "bottom right", bottom: "bottom", "bottom-left": "bottom left", left: "left", "top-left": "top left" }, transitionDelay: { 0: "0s", 75: "75ms", 100: "100ms", 150: "150ms", 200: "200ms", 300: "300ms", 500: "500ms", 700: "700ms", 1e3: "1000ms" }, transitionDuration: { DEFAULT: "150ms", 0: "0s", 75: "75ms", 100: "100ms", 150: "150ms", 200: "200ms", 300: "300ms", 500: "500ms", 700: "700ms", 1e3: "1000ms" }, transitionProperty: { none: "none", all: "all", DEFAULT: "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter", colors: "color, background-color, border-color, text-decoration-color, fill, stroke", opacity: "opacity", shadow: "box-shadow", transform: "transform" }, transitionTimingFunction: { DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)", linear: "linear", in: "cubic-bezier(0.4, 0, 1, 1)", out: "cubic-bezier(0, 0, 0.2, 1)", "in-out": "cubic-bezier(0.4, 0, 0.2, 1)" }, translate: ({ theme: t2 }) => ({ ...t2("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", full: "100%" }), width: ({ theme: t2 }) => ({ auto: "auto", ...t2("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", "1/12": "8.333333%", "2/12": "16.666667%", "3/12": "25%", "4/12": "33.333333%", "5/12": "41.666667%", "6/12": "50%", "7/12": "58.333333%", "8/12": "66.666667%", "9/12": "75%", "10/12": "83.333333%", "11/12": "91.666667%", full: "100%", screen: "100vw", min: "min-content", max: "max-content", fit: "fit-content" }), willChange: { auto: "auto", scroll: "scroll-position", contents: "contents", transform: "transform" }, zIndex: { auto: "auto", 0: "0", 10: "10", 20: "20", 30: "30", 40: "40", 50: "50" } }, plugins: [] };
});
var Dc = S((FO, Rc) => {
  "use strict";
  var Dn2 = Object.prototype.hasOwnProperty, Ic = Object.prototype.toString, Ec = Object.defineProperty, Cc = Object.getOwnPropertyDescriptor, Ac = function(e2) {
    return typeof Array.isArray == "function" ? Array.isArray(e2) : Ic.call(e2) === "[object Array]";
  }, _c = function(e2) {
    if (!e2 || Ic.call(e2) !== "[object Object]")
      return false;
    var r2 = Dn2.call(e2, "constructor"), n2 = e2.constructor && e2.constructor.prototype && Dn2.call(e2.constructor.prototype, "isPrototypeOf");
    if (e2.constructor && !r2 && !n2)
      return false;
    var i2;
    for (i2 in e2)
      ;
    return typeof i2 > "u" || Dn2.call(e2, i2);
  }, Tc = function(e2, r2) {
    Ec && r2.name === "__proto__" ? Ec(e2, r2.name, { enumerable: true, configurable: true, value: r2.newValue, writable: true }) : e2[r2.name] = r2.newValue;
  }, Pc = function(e2, r2) {
    if (r2 === "__proto__")
      if (Dn2.call(e2, r2)) {
        if (Cc)
          return Cc(e2, r2).value;
      } else
        return;
    return e2[r2];
  };
  Rc.exports = function t2() {
    var e2, r2, n2, i2, a2, s2, o2 = arguments[0], l2 = 1, u2 = arguments.length, f2 = false;
    for (typeof o2 == "boolean" && (f2 = o2, o2 = arguments[1] || {}, l2 = 2), (o2 == null || typeof o2 != "object" && typeof o2 != "function") && (o2 = {}); l2 < u2; ++l2)
      if (e2 = arguments[l2], e2 != null)
        for (r2 in e2)
          n2 = Pc(o2, r2), i2 = Pc(e2, r2), o2 !== i2 && (f2 && i2 && (_c(i2) || (a2 = Ac(i2))) ? (a2 ? (a2 = false, s2 = n2 && Ac(n2) ? n2 : []) : s2 = n2 && _c(n2) ? n2 : {}, Tc(o2, { name: r2, newValue: t2(f2, s2, i2) })) : typeof i2 < "u" && Tc(o2, { name: r2, newValue: i2 }));
    return o2;
  };
});
var Mn = S((LO, Mc) => {
  var ya = function(t2, e2) {
    var r2 = new t2.constructor();
    return Object.keys(t2).forEach(function(n2) {
      if (!!t2.hasOwnProperty(n2)) {
        var i2 = t2[n2], a2 = typeof i2;
        n2 === "parent" && a2 === "object" ? e2 && (r2[n2] = e2) : n2 === "source" ? r2[n2] = i2 : i2 instanceof Array ? n2 === "nodes" ? r2[n2] = [] : r2[n2] = i2.map(function(s2) {
          ya(s2, r2);
        }) : n2 !== "before" && n2 !== "after" && n2 !== "between" && n2 !== "semicolon" && (a2 === "object" && (i2 = ya(i2)), r2[n2] = i2);
      }
    }), r2;
  };
  Mc.exports = ya;
});
var $c = S((NO, qc) => {
  "use strict";
  qc.exports = Lc;
  function Lc(t2, e2, r2) {
    t2 instanceof RegExp && (t2 = Fc(t2, r2)), e2 instanceof RegExp && (e2 = Fc(e2, r2));
    var n2 = Nc(t2, e2, r2);
    return n2 && { start: n2[0], end: n2[1], pre: r2.slice(0, n2[0]), body: r2.slice(n2[0] + t2.length, n2[1]), post: r2.slice(n2[1] + e2.length) };
  }
  function Fc(t2, e2) {
    var r2 = e2.match(t2);
    return r2 ? r2[0] : null;
  }
  Lc.range = Nc;
  function Nc(t2, e2, r2) {
    var n2, i2, a2, s2, o2, l2 = r2.indexOf(t2), u2 = r2.indexOf(e2, l2 + 1), f2 = l2;
    if (l2 >= 0 && u2 > 0) {
      if (t2 === e2)
        return [l2, u2];
      for (n2 = [], a2 = r2.length; f2 >= 0 && !o2; )
        f2 == l2 ? (n2.push(f2), l2 = r2.indexOf(t2, f2 + 1)) : n2.length == 1 ? o2 = [n2.pop(), u2] : (i2 = n2.pop(), i2 < a2 && (a2 = i2, s2 = u2), u2 = r2.indexOf(e2, f2 + 1)), f2 = l2 < u2 && l2 >= 0 ? l2 : u2;
      n2.length && (o2 = [a2, s2]);
    }
    return o2;
  }
});
var jc = S((qO, Uc) => {
  var Ow = /(.*?(?:(?:\([^\)]+\)|\[[^\]]+\]|(?![><+~\s]).)+)(?:(?:(?:\s(?!>>))|(?:\t(?!>>))|(?:\s?>>\s?))(?!\s+))(?![><+~][\s]+?))/, Ew = function(t2) {
    return t2.split(Ow).filter(function(e2) {
      return e2.length > 0;
    }).map(function(e2) {
      return e2.trim().replace(/\s*?>>\s*?/g, "");
    });
  };
  Uc.exports = Ew;
});
var dr = S(($O, zc) => {
  var Cw = jc(), Aw = function(t2, e2) {
    e2 = e2 || false;
    for (var r2 = [[]], n2 = e2 ? t2 : t2.parent; n2; ) {
      var i2 = (n2.selectors || []).map(function(s2) {
        return { value: s2, type: "selector" };
      });
      n2.type === "atrule" && (i2 = [].concat(n2.params).map(function(s2) {
        return { value: "@" + n2.name + " " + s2, type: "atrule" };
      }));
      var a2 = (i2.length > 0 ? i2 : [1]).map(function() {
        return r2.map(function(s2) {
          return s2.slice(0);
        });
      });
      i2.forEach(function(s2, o2) {
        a2[o2] = a2[o2].map(function(l2) {
          var u2 = [s2.value];
          return s2.type === "selector" && (u2 = Cw(s2.value)), l2.unshift.apply(l2, u2), l2;
        });
      }), r2 = [], a2.forEach(function(s2) {
        r2 = r2.concat(s2);
      }), n2 = n2.parent;
    }
    return r2;
  };
  zc.exports = Aw;
});
var Wc = S((UO, Vc) => {
  "use strict";
  var _w = /[|\\{}()[\]^$+*?.]/g;
  Vc.exports = function(t2) {
    if (typeof t2 != "string")
      throw new TypeError("Expected a string");
    return t2.replace(_w, "\\$&");
  };
});
var Gc = S((jO, Bc) => {
  var Tw = { "*": true, ":root": true, html: true }, Pw = function(t2) {
    return !!Tw[t2];
  };
  Bc.exports = Pw;
});
var Hc = S((zO, Yc) => {
  var Iw = /(.*?(?:(?:\([^\)]+\)|\[[^\]]+\]|(?!>>|<|\+|~|\s).)+)(?:(?:(?:>(?!>))|(?:\s?>(?!>)\s?))(?!\s+))(?!(?:>>|<|\+|~)[\s]+?))/, Rw = function(t2) {
    return t2.split(Iw).filter(function(e2) {
      return e2.length > 0;
    }).map(function(e2) {
      return e2.trim().replace(/\s*?>\s*?/g, "");
    });
  };
  Yc.exports = Rw;
});
var va = S((VO, tp) => {
  var Dw = Wc(), Qc = Gc(), Jc = Hc(), Mw = /^@.*/, Kc = /([^\s:]+)((?::|::)[^\s]*?)(\s+|$)/;
  function Zc(t2, e2) {
    var r2, n2, i2 = e2.some(function(a2) {
      return t2.some(function(s2) {
        r2 = null;
        var o2 = true;
        for (n2 = 0; n2 < a2.length; n2++) {
          for (var l2 = a2[n2], u2 = r2 || 0, f2 = -1, p2 = s2.slice(u2), c2 = 0; c2 < p2.length; c2++) {
            var d2 = p2[c2], h2 = u2 + c2;
            if (new RegExp(Dw(l2) + "$").test(d2)) {
              f2 = h2;
              break;
            }
            if (Qc(l2) || Qc(d2)) {
              f2 = h2;
              break;
            }
            var y3 = Jc(d2);
            if (y3.length > 1) {
              var m = [].concat([y3]), g2 = [].concat([a2.slice(n2).reduce(function(v2, O2) {
                return v2.concat(Jc(O2));
              }, [])]), w2 = Zc(m, g2);
              (w2.doesMatchScope || n2 + 1 < a2.length) && (f2 = h2, n2 += w2.scopePieceIndex - 1);
              break;
            }
          }
          var b3 = f2 >= u2;
          if (r2 = f2 + 1, o2 = o2 && b3, !o2)
            break;
        }
        return o2;
      });
    });
    return { doesMatchScope: i2, nodeScopePieceIndex: r2 - 1, scopePieceIndex: n2 };
  }
  var Xc = function(t2) {
    return t2.map(function(e2) {
      return e2.map(function(r2) {
        return Mw.test(r2) ? r2 : r2.replace(new RegExp(Kc.source, "g"), function(n2, i2, a2, s2) {
          return i2 + s2;
        });
      });
    });
  }, ep = function(t2, e2, r2) {
    return t2 = Xc(t2), r2 && (e2 = Xc(e2)), Zc(t2, e2).doesMatchScope;
  };
  ep.RE_PSEUDO_SELECTOR = Kc;
  tp.exports = ep;
});
var wa = S((WO, np) => {
  var Fw = va(), rp = dr(), Lw = function(t2, e2, r2) {
    var n2 = rp(t2, true), i2 = rp(e2, true);
    return Fw(n2, i2, r2);
  };
  np.exports = Lw;
});
var ba = S((BO, sp) => {
  var ip = function(t2, e2, r2) {
    r2 = r2 || [];
    var n2 = false;
    return t2 && (r2 = t2.reduce(function(i2, a2) {
      var s2 = !!e2[a2], o2 = s2 ? i2.some(function(l2) {
        return e2[a2].some(function(u2) {
          return l2 === u2;
        });
      }) : false;
      return n2 = n2 || o2, s2 && !n2 && (i2 = i2.concat(e2[a2]), (e2[a2] || []).forEach(function(l2) {
        var u2 = ip(l2.variablesUsed, e2, i2);
        i2 = u2.deps, n2 = n2 || u2.hasCircularOrSelfReference;
      })), i2;
    }, r2)), { deps: r2, hasCircularOrSelfReference: n2 };
  };
  sp.exports = ip;
});
var xa = S((GO, ap) => {
  var Nw = dr(), qw = function(t2, e2) {
    for (var r2, n2 = e2; n2.parent && !r2; ) {
      var i2 = Nw(n2.clone(), true);
      i2.some(function(a2) {
        return a2.some(function(s2) {
          return s2 === t2 ? (r2 = n2, true) : false;
        });
      }), n2 = n2.parent;
    }
    return r2;
  };
  ap.exports = qw;
});
var Sa = S((YO, lp) => {
  var op = Mn(), $w = function(t2, e2, r2) {
    r2 = r2 || function() {
      return true;
    };
    for (var n2 = [], i2 = t2, a2 = false; i2 && !a2; )
      i2.type === "decl" ? n2.push(i2.clone()) : n2.push(op(i2)), a2 = r2(i2), i2 = i2.parent;
    for (var s2 = [], o2 = e2; o2; )
      s2.push(op(o2)), o2 = o2.parent;
    return s2.forEach(function(l2, u2, f2) {
      u2 + 1 < f2.length && (l2.parent = f2[u2 + 1]);
    }), n2.forEach(function(l2, u2, f2) {
      u2 + 1 < f2.length ? l2.parent = f2[u2 + 1] : (s2.slice(-1)[0].parent = i2, l2.parent = s2[0]);
    }), n2[0];
  };
  lp.exports = $w;
});
var ka = S((HO, fp) => {
  var Uw = $c(), jw = dr(), up = wa(), zw = ba(), Vw = xa(), Ww = Sa(), Bw = /var\(\s*(--[^,\s)]+)/;
  function Gw(t2) {
    return String(t2);
  }
  function Fn2(t2) {
    var e2 = Uw("(", ")", t2);
    if (e2) {
      if (/(?:^|[^\w-])var$/.test(e2.pre))
        return { pre: e2.pre.slice(0, -3), body: e2.body, post: e2.post };
      var r2 = Fn2(e2.body);
      if (r2)
        return { pre: e2.pre + "(" + r2.pre, body: r2.body, post: r2.post + ")" + e2.post };
      var n2 = Fn2(e2.post);
      if (n2)
        return { pre: e2.pre + "(" + e2.body + ")" + n2.pre, body: n2.body, post: n2.post };
    }
  }
  var Ln = function(t2, e2, r2, n2) {
    for (var i2 = n2 ? "	" : "", a2 = void 0, s2 = Gw(t2.value), o2 = [], l2 = {}, u2 = s2; a2 = Fn2(u2); ) {
      var f2 = a2.body.split(","), p2 = f2[0].trim();
      l2[p2] = true, u2 = (a2.pre || "") + a2.body.replace(p2, "") + (a2.post || "");
    }
    u2 = void 0;
    for (var c2 = Object.keys(l2), d2 = false; a2 = Fn2(s2); ) {
      var h2 = void 0, f2 = a2.body.split(","), p2 = f2[0].trim(), y3 = f2.length > 1 ? f2.slice(1).join(",").trim() : void 0;
      (e2[p2] || []).forEach(function(A) {
        var E2 = A.parent.type === "root" || A.parent.selectors[0] === ":root", I2 = up(t2.parent, A.parent), F = up(t2.parent, A.parent, r2);
        F && (!(h2 || {}).isImportant || A.isImportant) && (h2 = A);
      });
      var m = (h2 || {}).calculatedInPlaceValue || function() {
        var A = y3;
        if (y3) {
          var E2 = t2.clone({ parent: t2.parent, value: y3 });
          A = Ln(E2, e2, false, true).value;
        }
        return A;
      }();
      if (h2 !== void 0 && !zw(c2, e2).hasCircularOrSelfReference) {
        var g2 = jw(t2.parent.parent, true), w2 = g2[0].slice(-1)[0], b3 = Vw(w2, h2.decl.parent), v2 = Ww(h2.decl, t2.parent.parent, function(A) {
          return A === b3;
        });
        m = Ln(v2, e2, false, true).value;
      }
      d2 = m === void 0, d2 && o2.push(["variable " + p2 + " is undefined and used without a fallback", { node: t2 }]), s2 = (a2.pre || "") + m + (a2.post || "");
    }
    return { value: d2 ? void 0 : s2, variablesUsed: c2, warnings: o2 };
  };
  Ln.RE_VAR_FUNC = Bw;
  fp.exports = Ln;
});
var hp = S((QO, dp) => {
  var cp = ka(), Yw = dr(), Hw = ba(), pp = va(), Qw = wa(), Nn2 = Mn(), Jw = xa(), Xw = Sa();
  function Kw(t2, e2, r2, n2) {
    t2.forEach(function(i2) {
      Hw(t2, e2).deps.forEach(function(a2) {
        var s2;
        if (a2.isUnderAtRule) {
          var o2 = Yw(a2.parent, true), l2 = o2[0].slice(-1)[0], u2 = Jw(l2, r2.parent), f2 = a2.parent.parent;
          s2 = Xw(r2, f2, function(h2) {
            return h2 === u2;
          });
        } else if (pp.RE_PSEUDO_SELECTOR.test(a2.parent.selector)) {
          var p2 = Nn2(r2.parent);
          p2.parent = r2.parent.parent, s2 = r2.clone(), p2.append(s2);
          var c2 = a2.parent.selector.match(new RegExp(pp.RE_PSEUDO_SELECTOR.source + "$")), d2 = c2 ? c2[2] : "";
          p2.selector += d2;
        }
        s2 && Qw(s2, a2.parent, true) && n2(s2, a2);
      });
    });
  }
  function Zw(t2, e2, r2, n2, i2) {
    r2 = (typeof r2 == "function" ? r2(t2) : r2) || false, n2 = n2 || false;
    var a2 = function(l2) {
      return i2 && i2(l2), l2;
    }, s2 = a2(cp(t2, e2)), o2;
    Kw(s2.variablesUsed, e2, t2, function(l2, u2) {
      var f2 = Nn2(t2.parent), p2 = t2.clone();
      f2.append(p2);
      let c2;
      if (typeof r2 == "function" ? c2 = r2(t2) : c2 = r2, c2 === true && p2.cloneAfter(), p2.value = a2(cp(l2, e2, true)).value, u2.isUnderAtRule) {
        var d2 = Nn2(u2.parent.parent);
        d2.append(f2);
        for (var h2 = d2, y3 = u2.parent.parent; y3.parent.type === "atrule"; ) {
          var m = Nn2(y3.parent);
          m.append(h2), h2 = m, y3 = y3.parent;
        }
        t2.parent.parent.insertAfter(n2 && o2 || t2.parent, h2), o2 = h2;
      } else
        f2.selector = l2.parent.selector, t2.parent.parent.insertAfter(n2 && o2 || t2.parent, f2);
    }), r2 === true && t2.value !== s2.value && t2.cloneAfter(), s2.value === void 0 && (s2.value = "undefined"), t2.value = s2.value;
  }
  dp.exports = Zw;
});
var vp = S((JO, Oa) => {
  var mp = Dc(), eb = Mn(), gp = ka(), tb = hp(), yp = /(--(.+))/;
  function rb(t2, e2) {
    t2.walkDecls(function(r2) {
      yp.test(r2.prop) && e2(r2);
    });
  }
  function nb(t2) {
    for (var e2 = t2; e2 && e2.nodes.length <= 0; ) {
      var r2 = e2.type !== "root" ? e2 : null;
      r2 ? (e2 = r2.parent, r2.remove()) : e2 = null;
    }
  }
  var ib = { preserve: false, variables: {}, preserveInjectedVariables: true, preserveAtRulesOrder: false };
  Oa.exports = (t2 = {}) => {
    var e2 = mp({}, ib, t2);
    return { postcssPlugin: "postcss-css-variables", Once(r2, { decl: n2, result: i2, rule: a2 }) {
      var s2 = [], o2 = [], l2 = {};
      l2 = mp(l2, Object.keys(e2.variables).reduce(function(p2, c2) {
        var d2 = e2.variables[c2];
        c2 = c2.slice(0, 2) === "--" ? c2 : "--" + c2;
        var h2 = (d2 || {}).value || d2, y3 = (d2 || {}).isImportant || false, m = a2({ selector: ":root" });
        r2.root().prepend(m);
        var g2 = n2({ prop: c2, value: h2, important: y3 });
        return m.append(g2), e2.preserveInjectedVariables || o2.push(g2), p2[c2] = (p2[c2] || []).concat({ decl: g2, prop: c2, calculatedInPlaceValue: h2, isImportant: y3, variablesUsed: [], parent: m, isUnderAtRule: false }), p2;
      }, {}));
      var u2 = function(p2) {
        var c2 = [].concat(p2.warnings);
        return c2.forEach(function(d2) {
          d2 = [].concat(d2), i2.warn.apply(i2, d2);
        }), p2;
      };
      rb(r2, function(p2) {
        var c2 = p2.parent, d2 = u2(gp(p2, l2));
        p2.parent.selectors.forEach(function(y3) {
          var m = eb(p2.parent);
          m.selector = y3, m.parent = p2.parent.parent;
          var g2 = p2.clone();
          m.append(g2);
          var w2 = p2.prop;
          l2[w2] = (l2[w2] || []).concat({ decl: g2, prop: w2, calculatedInPlaceValue: d2.value, isImportant: p2.important || false, variablesUsed: d2.variablesUsed, parent: m, isUnderAtRule: m.parent.type === "atrule" });
        });
        let h2;
        typeof e2.preserve == "function" ? h2 = e2.preserve(p2) : h2 = e2.preserve, h2 ? h2 === "computed" && (p2.value = d2.value) : p2.remove(), c2.nodes.length <= 0 && s2.push(c2);
      });
      var f2 = [];
      r2.walk(function(p2) {
        if (p2.nodes !== void 0) {
          var c2 = p2.nodes.some(function(d2) {
            if (d2.type === "decl") {
              var h2 = d2;
              if (gp.RE_VAR_FUNC.test(h2.value) && !yp.test(h2.prop))
                return true;
            }
            return false;
          });
          c2 && f2.push(p2);
        }
      }), f2.forEach(function(p2) {
        var c2 = [].concat(p2);
        p2.type === "rule" && p2.selectors.length > 1 && (c2 = p2.selectors.reverse().map(function(d2) {
          var h2 = p2.cloneAfter();
          return h2.selector = d2, h2;
        }), p2.remove()), c2.forEach(function(d2) {
          d2.nodes.slice(0).forEach(function(h2) {
            if (h2.type === "decl") {
              var y3 = h2;
              tb(y3, l2, e2.preserve, e2.preserveAtRulesOrder, u2);
            }
          });
        });
      }), s2.forEach(nb), o2.forEach(function(p2) {
        p2.remove();
      });
    } };
  };
  Oa.exports.postcss = true;
});
var Ra = (t2) => ({ extractCSS(e2, r2 = false) {
  let n2 = /(?:[\s\r\n]*)?(?<prop>[\w-]+)\s*:\s*(?<value>[^;\r\n]+)/gm, i2, a2 = {};
  for (; (i2 = n2.exec(e2)) !== null; ) {
    let { prop: s2, value: o2 } = i2.groups;
    a2[s2] = o2;
  }
  return Object.entries(a2).reduce((s2, [o2, l2]) => s2 + `${r2 ? "	" : ""}${o2}: ${l2}; 
\r`, "");
}, merge() {
  let e2 = new RegExp("(?<=\\.)[^{]+\\s*\\{(?<content>[^{}]*(?:(?<=;)\\s*\\n\\r?[^{}]*)*)\\s*\\}", "gm"), r2, n2 = "";
  for (; (r2 = e2.exec(t2)) !== null; ) {
    let { content: o2 } = r2.groups;
    n2 += o2;
  }
  let i2 = this.extractCSS(n2), a2 = /(?<media>@media\s*\([^\)]*\))\s*\{(?<content>[^\}]*)\}/gm, s2;
  for (; (s2 = a2.exec(t2)) !== null; ) {
    let { media: o2, content: l2 } = s2.groups;
    i2 += `
\r${o2} {
\r${this.extractCSS(l2, true)}}
\r`;
  }
  return t2 = i2, this;
}, removeUndefined() {
  let e2 = /^[^{}]*(?:[.#][a-zA-Z0-9_-]+)[^{]*{[^}]*\b(?:[a-z-]+):\s*undefined\s*;?[^}]*}/gm;
  return t2 = t2.replace(e2, ""), this;
}, combineMediaQueries() {
  let e2 = new RegExp("@media\\s*(?<conditions>\\([^)]+\\))\\s*{(?<content>(?:[^{}]+|{(?:[^{}]+|{[^{}]*})*})+)}", "gs"), r2 = /* @__PURE__ */ new Map(), n2 = (a2) => a2.replace(e2, (s2, o2, l2) => {
    var f2;
    let u2 = (f2 = r2.get(o2)) != null ? f2 : "";
    return r2.set(o2, u2 + n2(l2.trim())), n2(l2), "";
  }), i2 = [];
  return i2.push(n2(t2)), i2.push(...Array.from(r2, ([a2, s2]) => `@media${a2}{${s2}}`)), t2 = i2.join(""), this;
}, minify() {
  return t2 = t2.replace(/\/\*[\s\S]*?\*\//gm, "").replace(/;\s+/gm, ";").replace(/:\s+/gm, ":").replace(/\)\s*{/gm, "){").replace(/\s+\(/gm, "(").replace(/{\s+/gm, "{").replace(/}\s+/gm, "}").replace(/\s*{/gm, "{").replace(/;?\s*}/gm, "}"), this;
}, fixRGB() {
  let e2 = /rgb\(\s*(?<red>\d+)\s*(?<green>\d+)\s*(?<blue>\d+)(?:\s*\/\s*(?<alpha>[\d%.]+))?\s*\)/gm, r2;
  for (; (r2 = e2.exec(t2)) !== null; ) {
    let [n2] = r2, { red: i2, green: a2, blue: s2, alpha: o2 = 1 } = r2.groups;
    t2 = t2.replace(n2, `rgb(${i2},${a2},${s2}${o2 === "1" ? "" : `,${o2}`})`);
  }
  return this;
}, removeMediaQueries() {
  return t2 = t2.replace(/@media[^\{]+\{[^@]+\}/g, ""), this;
}, get() {
  return t2;
} });
function $n() {
}
var L = { info: $n, warn: $n, risk: $n };
function Un(t2) {
  let e2 = /* @__PURE__ */ new Set(), r2 = /* @__PURE__ */ new Set(), n2 = /* @__PURE__ */ new Set();
  if (t2.walkAtRules((i2) => {
    i2.name === "apply" && n2.add(i2), i2.name === "import" && (i2.params === '"tailwindcss/base"' || i2.params === "'tailwindcss/base'" ? (i2.name = "tailwind", i2.params = "base") : i2.params === '"tailwindcss/components"' || i2.params === "'tailwindcss/components'" ? (i2.name = "tailwind", i2.params = "components") : i2.params === '"tailwindcss/utilities"' || i2.params === "'tailwindcss/utilities'" ? (i2.name = "tailwind", i2.params = "utilities") : (i2.params === '"tailwindcss/screens"' || i2.params === "'tailwindcss/screens'" || i2.params === '"tailwindcss/variants"' || i2.params === "'tailwindcss/variants'") && (i2.name = "tailwind", i2.params = "variants")), i2.name === "tailwind" && (i2.params === "screens" && (i2.params = "variants"), e2.add(i2.params)), ["layer", "responsive", "variants"].includes(i2.name) && (["responsive", "variants"].includes(i2.name) && L.warn(`${i2.name}-at-rule-deprecated`, [`The \`@${i2.name}\` directive has been deprecated in Tailwind CSS v3.0.`, "Use `@layer utilities` or `@layer components` instead.", "https://tailwindcss.com/docs/upgrade-guide#replace-variants-with-layer"]), r2.add(i2));
  }), !e2.has("base") || !e2.has("components") || !e2.has("utilities")) {
    for (let i2 of r2)
      if (i2.name === "layer" && ["base", "components", "utilities"].includes(i2.params)) {
        if (!e2.has(i2.params))
          throw i2.error(`\`@layer ${i2.params}\` is used but no matching \`@tailwind ${i2.params}\` directive is present.`);
      } else if (i2.name === "responsive") {
        if (!e2.has("utilities"))
          throw i2.error("`@responsive` is used but `@tailwind utilities` is missing.");
      } else if (i2.name === "variants" && !e2.has("utilities"))
        throw i2.error("`@variants` is used but `@tailwind utilities` is missing.");
  }
  return { tailwindDirectives: e2, applyDirectives: n2 };
}
vr();
var $f = H(Na());
var $a = "3.3.2";
var zn = { name: "tailwindcss", version: $a, description: "A utility-first CSS framework for rapidly building custom user interfaces.", license: "MIT", main: "lib/index.js", types: "types/index.d.ts", repository: "https://github.com/tailwindlabs/tailwindcss.git", bugs: "https://github.com/tailwindlabs/tailwindcss/issues", homepage: "https://tailwindcss.com", bin: { tailwind: "lib/cli.js", tailwindcss: "lib/cli.js" }, tailwindcss: { engine: "stable" }, scripts: { prebuild: "npm run generate && rimraf lib", build: `swc src --out-dir lib --copy-files --config jsc.transform.optimizer.globals.vars.__OXIDE__='"false"'`, postbuild: "esbuild lib/cli-peer-dependencies.js --bundle --platform=node --outfile=peers/index.js --define:process.env.CSS_TRANSFORMER_WASM=false", "rebuild-fixtures": "npm run build && node -r @swc/register scripts/rebuildFixtures.js", style: "eslint .", pretest: "npm run generate", test: "jest", "test:integrations": "npm run test --prefix ./integrations", "install:integrations": "node scripts/install-integrations.js", "generate:plugin-list": "node -r @swc/register scripts/create-plugin-list.js", "generate:types": "node -r @swc/register scripts/generate-types.js", generate: "npm run generate:plugin-list && npm run generate:types", "release-channel": "node ./scripts/release-channel.js", "release-notes": "node ./scripts/release-notes.js", prepublishOnly: "npm install --force && npm run build" }, files: ["src/*", "cli/*", "lib/*", "peers/*", "scripts/*.js", "stubs/*", "nesting/*", "types/**/*", "*.d.ts", "*.css", "*.js"], devDependencies: { "@swc/cli": "^0.1.62", "@swc/core": "^1.3.55", "@swc/jest": "^0.2.26", "@swc/register": "^0.1.10", autoprefixer: "^10.4.14", browserslist: "^4.21.5", concurrently: "^8.0.1", cssnano: "^6.0.0", esbuild: "^0.17.18", eslint: "^8.39.0", "eslint-config-prettier": "^8.8.0", "eslint-plugin-prettier": "^4.2.1", jest: "^29.5.0", "jest-diff": "^29.5.0", lightningcss: "1.18.0", prettier: "^2.8.8", rimraf: "^5.0.0", "source-map-js": "^1.0.2", turbo: "^1.9.3" }, dependencies: { "@alloc/quick-lru": "^5.2.0", arg: "^5.0.2", chokidar: "^3.5.3", didyoumean: "^1.2.2", dlv: "^1.1.3", "fast-glob": "^3.2.12", "glob-parent": "^6.0.2", "is-glob": "^4.0.3", jiti: "^1.18.2", lilconfig: "^2.1.0", micromatch: "^4.0.5", "normalize-path": "^3.0.0", "object-hash": "^3.0.0", picocolors: "^1.0.0", postcss: "^8.4.23", "postcss-import": "^15.1.0", "postcss-js": "^4.0.1", "postcss-load-config": "^4.0.1", "postcss-nested": "^6.0.1", "postcss-selector-parser": "^6.0.11", "postcss-value-parser": "^4.2.0", resolve: "^1.22.2", sucrase: "^3.32.0" }, browserslist: ["> 1%", "not edge <= 18", "not ie 11", "not op_mini all"], jest: { testTimeout: 3e4, setupFilesAfterEnv: ["<rootDir>/jest/customMatchers.js"], testPathIgnorePatterns: ["/node_modules/", "/integrations/", "/standalone-cli/", "\\.test\\.skip\\.js$"], transformIgnorePatterns: ["node_modules/(?!lightningcss)"], transform: { "\\.js$": "@swc/jest", "\\.ts$": "@swc/jest" } }, engines: { node: ">=14.0.0" } };
var Vn = typeof process < "u" ? { NODE_ENV: "production", DEBUG: Dp(void 0), ENGINE: zn.tailwindcss.engine } : { NODE_ENV: "production", DEBUG: false, ENGINE: zn.tailwindcss.engine };
var Wn = /* @__PURE__ */ new Map();
var ke = new String("*");
var mt = Symbol("__NONE__");
function Dp(t2) {
  if (t2 === void 0)
    return false;
  if (t2 === "true" || t2 === "1")
    return true;
  if (t2 === "false" || t2 === "0")
    return false;
  if (t2 === "*")
    return true;
  let e2 = t2.split(",").map((r2) => r2.split(":")[0]);
  return e2.includes("-tailwindcss") ? false : !!e2.includes("tailwindcss");
}
var $ = H(Ke(), 1);
var R = $.default;
var Kb = $.default.stringify;
var Zb = $.default.fromJSON;
var ex = $.default.plugin;
var tx = $.default.parse;
var rx = $.default.list;
var nx = $.default.document;
var ix = $.default.comment;
var sx = $.default.atRule;
var ax = $.default.rule;
var ox = $.default.decl;
var lx = $.default.root;
var ux = $.default.CssSyntaxError;
var fx = $.default.Declaration;
var cx = $.default.Container;
var px = $.default.Processor;
var dx = $.default.Document;
var hx = $.default.Comment;
var mx = $.default.Warning;
var gx = $.default.AtRule;
var yx = $.default.Result;
var vx = $.default.Input;
var wx = $.default.Rule;
var bx = $.default.Root;
var xx = $.default.Node;
var wn = H(ve());
var $u = H(Su());
var rt = H(qu(), 1);
var tn = rt.default;
var jx = rt.default.objectify;
var zx = rt.default.parse;
var Vx = rt.default.async;
var Wx = rt.default.sync;
function nt(t2) {
  return Array.isArray(t2) ? t2.flatMap((e2) => R([(0, $u.default)({ bubble: ["screen"] })]).process(e2, { parser: tn }).root.nodes) : nt([t2]);
}
function X(t2) {
  if (Object.prototype.toString.call(t2) !== "[object Object]")
    return false;
  let e2 = Object.getPrototypeOf(t2);
  return e2 === null || e2 === Object.prototype;
}
var Uu = H(ve());
function it(t2, e2, r2 = false) {
  if (t2 === "")
    return e2;
  let n2 = typeof e2 == "string" ? (0, Uu.default)().astSync(e2) : e2;
  return n2.walkClasses((i2) => {
    let a2 = i2.value, s2 = r2 && a2.startsWith("-");
    i2.value = s2 ? `-${t2}${a2.slice(1)}` : `${t2}${a2}`;
  }), typeof e2 == "string" ? n2.toString() : n2;
}
function Be(t2) {
  return t2.replace(/\\,/g, "\\2c ");
}
var ks = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
var C0 = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i;
var A0 = /^#([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i;
var Pe = /(?:\d+|\d*\.\d+)%?/;
var rn = /(?:\s*,\s*|\s+)/;
var ju = /\s*[,/]\s*/;
var Ie = /var\(--(?:[^ )]*?)\)/;
var _0 = new RegExp(`^(rgba?)\\(\\s*(${Pe.source}|${Ie.source})(?:${rn.source}(${Pe.source}|${Ie.source}))?(?:${rn.source}(${Pe.source}|${Ie.source}))?(?:${ju.source}(${Pe.source}|${Ie.source}))?\\s*\\)$`);
var T0 = new RegExp(`^(hsla?)\\(\\s*((?:${Pe.source})(?:deg|rad|grad|turn)?|${Ie.source})(?:${rn.source}(${Pe.source}|${Ie.source}))?(?:${rn.source}(${Pe.source}|${Ie.source}))?(?:${ju.source}(${Pe.source}|${Ie.source}))?\\s*\\)$`);
function ir(t2, { loose: e2 = false } = {}) {
  var a2, s2, o2;
  if (typeof t2 != "string")
    return null;
  if (t2 = t2.trim(), t2 === "transparent")
    return { mode: "rgb", color: ["0", "0", "0"], alpha: "0" };
  if (t2 in ks)
    return { mode: "rgb", color: ks[t2].map((l2) => l2.toString()) };
  let r2 = t2.replace(A0, (l2, u2, f2, p2, c2) => ["#", u2, u2, f2, f2, p2, p2, c2 ? c2 + c2 : ""].join("")).match(C0);
  if (r2 !== null)
    return { mode: "rgb", color: [parseInt(r2[1], 16), parseInt(r2[2], 16), parseInt(r2[3], 16)].map((l2) => l2.toString()), alpha: r2[4] ? (parseInt(r2[4], 16) / 255).toString() : void 0 };
  let n2 = (a2 = t2.match(_0)) != null ? a2 : t2.match(T0);
  if (n2 === null)
    return null;
  let i2 = [n2[2], n2[3], n2[4]].filter(Boolean).map((l2) => l2.toString());
  return i2.length === 2 && i2[0].startsWith("var(") ? { mode: n2[1], color: [i2[0]], alpha: i2[1] } : !e2 && i2.length !== 3 || i2.length < 3 && !i2.some((l2) => /^var\(.*?\)$/.test(l2)) ? null : { mode: n2[1], color: i2, alpha: (o2 = (s2 = n2[5]) == null ? void 0 : s2.toString) == null ? void 0 : o2.call(s2) };
}
function Os({ mode: t2, color: e2, alpha: r2 }) {
  let n2 = r2 !== void 0;
  return t2 === "rgba" || t2 === "hsla" ? `${t2}(${e2.join(", ")}${n2 ? `, ${r2}` : ""})` : `${t2}(${e2.join(" ")}${n2 ? ` / ${r2}` : ""})`;
}
function we(t2, e2, r2) {
  if (typeof t2 == "function")
    return t2({ opacityValue: e2 });
  let n2 = ir(t2, { loose: true });
  return n2 === null ? r2 : Os({ ...n2, alpha: e2 });
}
function Z({ color: t2, property: e2, variable: r2 }) {
  let n2 = [].concat(e2);
  if (typeof t2 == "function")
    return { [r2]: "1", ...Object.fromEntries(n2.map((a2) => [a2, t2({ opacityVariable: r2, opacityValue: `var(${r2})` })])) };
  let i2 = ir(t2);
  return i2 === null ? Object.fromEntries(n2.map((a2) => [a2, t2])) : i2.alpha !== void 0 ? Object.fromEntries(n2.map((a2) => [a2, t2])) : { [r2]: "1", ...Object.fromEntries(n2.map((a2) => [a2, Os({ ...i2, alpha: `var(${r2})` })])) };
}
function ee(t2, e2) {
  let r2 = [], n2 = [], i2 = 0, a2 = false;
  for (let s2 = 0; s2 < t2.length; s2++) {
    let o2 = t2[s2];
    r2.length === 0 && o2 === e2[0] && !a2 && (e2.length === 1 || t2.slice(s2, s2 + e2.length) === e2) && (n2.push(t2.slice(i2, s2)), i2 = s2 + e2.length), a2 ? a2 = false : o2 === "\\" && (a2 = true), o2 === "(" || o2 === "[" || o2 === "{" ? r2.push(o2) : (o2 === ")" && r2[r2.length - 1] === "(" || o2 === "]" && r2[r2.length - 1] === "[" || o2 === "}" && r2[r2.length - 1] === "{") && r2.pop();
  }
  return n2.push(t2.slice(i2)), n2;
}
var P0 = /* @__PURE__ */ new Set(["inset", "inherit", "initial", "revert", "unset"]);
var I0 = /\ +(?![^(]*\))/g;
var zu = /^-?(\d+|\.\d+)(.*?)$/g;
function nn(t2) {
  return ee(t2, ",").map((r2) => {
    let n2 = r2.trim(), i2 = { raw: n2 }, a2 = n2.split(I0), s2 = /* @__PURE__ */ new Set();
    for (let o2 of a2)
      zu.lastIndex = 0, !s2.has("KEYWORD") && P0.has(o2) ? (i2.keyword = o2, s2.add("KEYWORD")) : zu.test(o2) ? s2.has("X") ? s2.has("Y") ? s2.has("BLUR") ? s2.has("SPREAD") || (i2.spread = o2, s2.add("SPREAD")) : (i2.blur = o2, s2.add("BLUR")) : (i2.y = o2, s2.add("Y")) : (i2.x = o2, s2.add("X")) : i2.color ? (i2.unknown || (i2.unknown = []), i2.unknown.push(o2)) : i2.color = o2;
    return i2.valid = i2.x !== void 0 && i2.y !== void 0, i2;
  });
}
function Vu(t2) {
  return t2.map((e2) => e2.valid ? [e2.keyword, e2.x, e2.y, e2.blur, e2.spread, e2.color].filter(Boolean).join(" ") : e2.raw).join(", ");
}
var R0 = ["min", "max", "clamp", "calc"];
function Es(t2) {
  return R0.some((e2) => new RegExp(`^${e2}\\(.*\\)`).test(t2));
}
var Wu = "--tw-placeholder";
var D0 = new RegExp(Wu, "g");
function z(t2, e2 = true) {
  return t2.startsWith("--") ? `var(${t2})` : t2.includes("url(") ? t2.split(/(url\(.*?\))/g).filter(Boolean).map((r2) => /^url\(.*?\)$/.test(r2) ? r2 : z(r2, false)).join("") : (t2 = t2.replace(/([^\\])_+/g, (r2, n2) => n2 + " ".repeat(r2.length - 1)).replace(/^_/g, " ").replace(/\\_/g, "_"), e2 && (t2 = t2.trim()), t2 = t2.replace(/(calc|min|max|clamp)\(.+\)/g, (r2) => {
    let n2 = [];
    return r2.replace(/var\((--.+?)[,)]/g, (i2, a2) => (n2.push(a2), i2.replace(a2, Wu))).replace(/(-?\d*\.?\d(?!\b-\d.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, "$1 $2 ").replace(D0, () => n2.shift());
  }), t2);
}
function Cs(t2) {
  return t2.startsWith("url(");
}
function As(t2) {
  return !isNaN(Number(t2)) || Es(t2);
}
function sr(t2) {
  return t2.endsWith("%") && As(t2.slice(0, -1)) || Es(t2);
}
var M0 = ["cm", "mm", "Q", "in", "pc", "pt", "px", "em", "ex", "ch", "rem", "lh", "rlh", "vw", "vh", "vmin", "vmax", "vb", "vi", "svw", "svh", "lvw", "lvh", "dvw", "dvh", "cqw", "cqh", "cqi", "cqb", "cqmin", "cqmax"];
var F0 = `(?:${M0.join("|")})`;
function ar(t2) {
  return t2 === "0" || new RegExp(`^[+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?${F0}$`).test(t2) || Es(t2);
}
var L0 = /* @__PURE__ */ new Set(["thin", "medium", "thick"]);
function Bu(t2) {
  return L0.has(t2);
}
function Gu(t2) {
  let e2 = nn(z(t2));
  for (let r2 of e2)
    if (!r2.valid)
      return false;
  return true;
}
function Yu(t2) {
  let e2 = 0;
  return ee(t2, "_").every((n2) => (n2 = z(n2), n2.startsWith("var(") ? true : ir(n2, { loose: true }) !== null ? (e2++, true) : false)) ? e2 > 0 : false;
}
function Hu(t2) {
  let e2 = 0;
  return ee(t2, ",").every((n2) => (n2 = z(n2), n2.startsWith("var(") ? true : Cs(n2) || q0(n2) || ["element(", "image(", "cross-fade(", "image-set("].some((i2) => n2.startsWith(i2)) ? (e2++, true) : false)) ? e2 > 0 : false;
}
var N0 = /* @__PURE__ */ new Set(["linear-gradient", "radial-gradient", "repeating-linear-gradient", "repeating-radial-gradient", "conic-gradient"]);
function q0(t2) {
  t2 = z(t2);
  for (let e2 of N0)
    if (t2.startsWith(`${e2}(`))
      return true;
  return false;
}
var $0 = /* @__PURE__ */ new Set(["center", "top", "right", "bottom", "left"]);
function Qu(t2) {
  let e2 = 0;
  return ee(t2, "_").every((n2) => (n2 = z(n2), n2.startsWith("var(") ? true : $0.has(n2) || ar(n2) || sr(n2) ? (e2++, true) : false)) ? e2 > 0 : false;
}
function Ju(t2) {
  let e2 = 0;
  return ee(t2, ",").every((n2) => (n2 = z(n2), n2.startsWith("var(") ? true : n2.includes(" ") && !/(['"])([^"']+)\1/g.test(n2) || /^\d/g.test(n2) ? false : (e2++, true))) ? e2 > 0 : false;
}
var U0 = /* @__PURE__ */ new Set(["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong"]);
function Xu(t2) {
  return U0.has(t2);
}
var j0 = /* @__PURE__ */ new Set(["xx-small", "x-small", "small", "medium", "large", "x-large", "x-large", "xxx-large"]);
function Ku(t2) {
  return j0.has(t2);
}
var z0 = /* @__PURE__ */ new Set(["larger", "smaller"]);
function Zu(t2) {
  return z0.has(t2);
}
function Re(t2) {
  if (t2 = `${t2}`, t2 === "0")
    return "0";
  if (/^[+-]?(\d+|\d*\.\d+)(e[+-]?\d+)?(%|\w+)?$/.test(t2))
    return t2.replace(/^[+-]?/, (r2) => r2 === "-" ? "" : "-");
  let e2 = ["var", "calc", "min", "max", "clamp"];
  for (let r2 of e2)
    if (t2.includes(`${r2}(`))
      return `calc(${t2} * -1)`;
}
function ef(t2) {
  let e2 = ["cover", "contain"];
  return ee(t2, ",").every((r2) => {
    let n2 = ee(r2, "_").filter(Boolean);
    return n2.length === 1 && e2.includes(n2[0]) ? true : n2.length !== 1 && n2.length !== 2 ? false : n2.every((i2) => ar(i2) || sr(i2) || i2 === "auto");
  });
}
Gn();
var tf = { optimizeUniversalDefaults: false, generalizedModifiers: true, get disableColorOpacityUtilitiesByDefault() {
}, get relativeContentPathsByDefault() {
} };
var sn = { future: ["hoverOnlyWhenSupported", "respectDefaultRingColorOpacity", "disableColorOpacityUtilitiesByDefault", "relativeContentPathsByDefault"], experimental: ["optimizeUniversalDefaults", "generalizedModifiers"] };
function G(t2, e2) {
  var r2, n2, i2, a2, s2, o2;
  return sn.future.includes(e2) ? t2.future === "all" || ((i2 = (n2 = (r2 = t2 == null ? void 0 : t2.future) == null ? void 0 : r2[e2]) != null ? n2 : tf[e2]) != null ? i2 : false) : sn.experimental.includes(e2) ? t2.experimental === "all" || ((o2 = (s2 = (a2 = t2 == null ? void 0 : t2.experimental) == null ? void 0 : a2[e2]) != null ? s2 : tf[e2]) != null ? o2 : false) : false;
}
function nf(t2) {
  if (false) {
    let e2 = rf(t2).map((r2) => Bn.yellow(r2)).join(", ");
    L.warn("experimental-flags-enabled", [`You have enabled experimental features: ${e2}`, "Experimental features in Tailwind CSS are not covered by semver, may introduce breaking changes, and can change at any time."]);
  }
}
function af(t2, e2) {
  t2.walkClasses((r2) => {
    r2.value = e2(r2.value), r2.raws && r2.raws.value && (r2.raws.value = Be(r2.raws.value));
  });
}
function of(t2, e2) {
  if (!De(t2))
    return;
  let r2 = t2.slice(1, -1);
  if (!!e2(r2))
    return z(r2);
}
function V0(t2, e2 = {}, r2) {
  let n2 = e2[t2];
  if (n2 !== void 0)
    return Re(n2);
  if (De(t2)) {
    let i2 = of(t2, r2);
    return i2 === void 0 ? void 0 : Re(i2);
  }
}
function an(t2, e2 = {}, { validate: r2 = () => true } = {}) {
  var i2;
  let n2 = (i2 = e2.values) == null ? void 0 : i2[t2];
  return n2 !== void 0 ? n2 : e2.supportsNegativeValues && t2.startsWith("-") ? V0(t2.slice(1), e2.values, r2) : of(t2, r2);
}
function De(t2) {
  return t2.startsWith("[") && t2.endsWith("]");
}
function lf(t2) {
  let e2 = t2.lastIndexOf("/");
  return e2 === -1 || e2 === t2.length - 1 ? [t2, void 0] : De(t2) && !t2.includes("]/[") ? [t2, void 0] : [t2.slice(0, e2), t2.slice(e2 + 1)];
}
function st(t2) {
  if (typeof t2 == "string" && t2.includes("<alpha-value>")) {
    let e2 = t2;
    return ({ opacityValue: r2 = 1 }) => e2.replace("<alpha-value>", r2);
  }
  return t2;
}
function uf(t2) {
  return z(t2.slice(1, -1));
}
function W0(t2, e2 = {}, { tailwindConfig: r2 = {} } = {}) {
  var a2, s2, o2, l2, u2, f2;
  if (((a2 = e2.values) == null ? void 0 : a2[t2]) !== void 0)
    return st((s2 = e2.values) == null ? void 0 : s2[t2]);
  let [n2, i2] = lf(t2);
  if (i2 !== void 0) {
    let p2 = (l2 = (o2 = e2.values) == null ? void 0 : o2[n2]) != null ? l2 : De(n2) ? n2.slice(1, -1) : void 0;
    return p2 === void 0 ? void 0 : (p2 = st(p2), De(i2) ? we(p2, uf(i2)) : ((f2 = (u2 = r2.theme) == null ? void 0 : u2.opacity) == null ? void 0 : f2[i2]) === void 0 ? void 0 : we(p2, r2.theme.opacity[i2]));
  }
  return an(t2, e2, { validate: Yu });
}
function B0(t2, e2 = {}) {
  var r2;
  return (r2 = e2.values) == null ? void 0 : r2[t2];
}
function oe(t2) {
  return (e2, r2) => an(e2, r2, { validate: t2 });
}
var _s = { any: an, color: W0, url: oe(Cs), image: oe(Hu), length: oe(ar), percentage: oe(sr), position: oe(Qu), lookup: B0, "generic-name": oe(Xu), "family-name": oe(Ju), number: oe(As), "line-width": oe(Bu), "absolute-size": oe(Ku), "relative-size": oe(Zu), shadow: oe(Gu), size: oe(ef) };
var sf = Object.keys(_s);
function G0(t2, e2) {
  let r2 = t2.indexOf(e2);
  return r2 === -1 ? [void 0, t2] : [t2.slice(0, r2), t2.slice(r2 + 1)];
}
function Ts(t2, e2, r2, n2) {
  if (r2.values && e2 in r2.values)
    for (let { type: a2 } of t2 != null ? t2 : []) {
      let s2 = _s[a2](e2, r2, { tailwindConfig: n2 });
      if (s2 !== void 0)
        return [s2, a2, null];
    }
  if (De(e2)) {
    let a2 = e2.slice(1, -1), [s2, o2] = G0(a2, ":");
    if (!/^[\w-_]+$/g.test(s2))
      o2 = a2;
    else if (s2 !== void 0 && !sf.includes(s2))
      return [];
    if (o2.length > 0 && sf.includes(s2))
      return [an(`[${o2}]`, r2), s2, null];
  }
  let i2 = Ps(t2, e2, r2, n2);
  for (let a2 of i2)
    return a2;
  return [];
}
function* Ps(t2, e2, r2, n2) {
  var l2, u2;
  let i2 = G(n2, "generalizedModifiers"), [a2, s2] = lf(e2);
  if (i2 && r2.modifiers != null && (r2.modifiers === "any" || typeof r2.modifiers == "object" && (s2 && De(s2) || s2 in r2.modifiers)) || (a2 = e2, s2 = void 0), s2 !== void 0 && a2 === "" && (a2 = "DEFAULT"), s2 !== void 0 && typeof r2.modifiers == "object") {
    let f2 = (u2 = (l2 = r2.modifiers) == null ? void 0 : l2[s2]) != null ? u2 : null;
    f2 !== null ? s2 = f2 : De(s2) && (s2 = uf(s2));
  }
  for (let { type: f2 } of t2 != null ? t2 : []) {
    let p2 = _s[f2](a2, r2, { tailwindConfig: n2 });
    p2 !== void 0 && (yield [p2, f2, s2 != null ? s2 : null]);
  }
}
var be = H(ve());
var hf = H(jr());
var ff = H(ve());
function re(t2) {
  var r2, n2;
  let e2 = ff.default.className();
  return e2.value = t2, Be((n2 = (r2 = e2 == null ? void 0 : e2.raws) == null ? void 0 : r2.value) != null ? n2 : e2.value);
}
var Is = { "::after": ["terminal", "jumpable"], "::backdrop": ["terminal"], "::before": ["terminal", "jumpable"], "::cue": ["terminal"], "::cue-region": ["terminal"], "::first-letter": ["terminal", "jumpable"], "::first-line": ["terminal", "jumpable"], "::grammar-error": ["terminal"], "::marker": ["terminal"], "::part": ["terminal", "actionable"], "::placeholder": ["terminal"], "::selection": ["terminal"], "::slotted": ["terminal"], "::spelling-error": ["terminal"], "::target-text": ["terminal"], "::file-selector-button": ["terminal", "actionable"], "::-webkit-progress-bar": ["terminal", "actionable"], "::-webkit-scrollbar": ["terminal", "actionable"], "::-webkit-scrollbar-button": ["terminal", "actionable"], "::-webkit-scrollbar-thumb": ["terminal", "actionable"], "::-webkit-scrollbar-track": ["terminal", "actionable"], "::-webkit-scrollbar-track-piece": ["terminal", "actionable"], "::-webkit-scrollbar-corner": ["terminal", "actionable"], "::-webkit-resizer": ["terminal", "actionable"], ":after": ["terminal", "jumpable"], ":before": ["terminal", "jumpable"], ":first-letter": ["terminal", "jumpable"], ":first-line": ["terminal", "jumpable"], __default__: ["actionable"] };
function at(t2) {
  let [e2] = cf(t2);
  return e2.forEach(([r2, n2]) => r2.removeChild(n2)), t2.nodes.push(...e2.map(([, r2]) => r2)), t2;
}
function cf(t2) {
  var n2;
  let e2 = [], r2 = null;
  for (let i2 of t2.nodes)
    if (i2.type === "combinator")
      e2 = e2.filter(([, a2]) => Rs(a2).includes("jumpable")), r2 = null;
    else if (i2.type === "pseudo") {
      Y0(i2) ? (r2 = i2, e2.push([t2, i2, null])) : r2 && H0(i2, r2) ? e2.push([t2, i2, r2]) : r2 = null;
      for (let a2 of (n2 = i2.nodes) != null ? n2 : []) {
        let [s2, o2] = cf(a2);
        r2 = o2 || r2, e2.push(...s2);
      }
    }
  return [e2, r2];
}
function pf(t2) {
  return t2.value.startsWith("::") || Is[t2.value] !== void 0;
}
function Y0(t2) {
  return pf(t2) && Rs(t2).includes("terminal");
}
function H0(t2, e2) {
  return t2.type !== "pseudo" || pf(t2) ? false : Rs(e2).includes("actionable");
}
function Rs(t2) {
  var e2;
  return (e2 = Is[t2.value]) != null ? e2 : Is.__default__;
}
var Ds = ":merge";
function ot(t2, { context: e2, candidate: r2 }) {
  var s2;
  let n2 = (s2 = e2 == null ? void 0 : e2.tailwindConfig.prefix) != null ? s2 : "", i2 = t2.map((o2) => {
    let l2 = (0, be.default)().astSync(o2.format);
    return { ...o2, ast: o2.isArbitraryVariant ? l2 : it(n2, l2) };
  }), a2 = be.default.root({ nodes: [be.default.selector({ nodes: [be.default.className({ value: re(r2) })] })] });
  for (let { ast: o2 } of i2)
    [a2, o2] = J0(a2, o2), o2.walkNesting((l2) => l2.replaceWith(...a2.nodes[0].nodes)), a2 = o2;
  return a2;
}
function df(t2) {
  let e2 = [];
  for (; t2.prev() && t2.prev().type !== "combinator"; )
    t2 = t2.prev();
  for (; t2 && t2.type !== "combinator"; )
    e2.push(t2), t2 = t2.next();
  return e2;
}
function Q0(t2) {
  return t2.sort((e2, r2) => e2.type === "tag" && r2.type === "class" ? -1 : e2.type === "class" && r2.type === "tag" ? 1 : e2.type === "class" && r2.type === "pseudo" && r2.value.startsWith("::") ? -1 : e2.type === "pseudo" && e2.value.startsWith("::") && r2.type === "class" ? 1 : t2.index(e2) - t2.index(r2)), t2;
}
function Ms(t2, e2) {
  let r2 = false;
  t2.walk((n2) => {
    if (n2.type === "class" && n2.value === e2)
      return r2 = true, false;
  }), r2 || t2.remove();
}
function on(t2, e2, { context: r2, candidate: n2, base: i2 }) {
  var f2, p2;
  let a2 = (p2 = (f2 = r2 == null ? void 0 : r2.tailwindConfig) == null ? void 0 : f2.separator) != null ? p2 : ":";
  i2 = i2 != null ? i2 : n2.split(new RegExp(`\\${a2}(?![^[]*\\])`)).pop();
  let s2 = (0, be.default)().astSync(t2);
  s2.walkClasses((c2) => {
    c2.raws && c2.value.includes(i2) && (c2.raws.value = re((0, hf.default)(c2.raws.value)));
  }), s2.each((c2) => Ms(c2, i2));
  let o2 = Array.isArray(e2) ? ot(e2, { context: r2, candidate: n2 }) : e2;
  if (o2 === null)
    return s2.toString();
  let l2 = be.default.comment({ value: "/*__simple__*/" }), u2 = be.default.comment({ value: "/*__simple__*/" });
  return s2.walkClasses((c2) => {
    if (c2.value !== i2)
      return;
    let d2 = c2.parent, h2 = o2.nodes[0].nodes;
    if (d2.nodes.length === 1) {
      c2.replaceWith(...h2);
      return;
    }
    let y3 = df(c2);
    d2.insertBefore(y3[0], l2), d2.insertAfter(y3[y3.length - 1], u2);
    for (let g2 of h2)
      d2.insertBefore(y3[0], g2.clone());
    c2.remove(), y3 = df(l2);
    let m = d2.index(l2);
    d2.nodes.splice(m, y3.length, ...Q0(be.default.selector({ nodes: y3 })).nodes), l2.remove(), u2.remove();
  }), s2.walkPseudos((c2) => {
    c2.value === Ds && c2.replaceWith(c2.nodes);
  }), s2.each((c2) => at(c2)), s2.toString();
}
function J0(t2, e2) {
  let r2 = [];
  return t2.walkPseudos((n2) => {
    n2.value === Ds && r2.push({ pseudo: n2, value: n2.nodes[0].toString() });
  }), e2.walkPseudos((n2) => {
    if (n2.value !== Ds)
      return;
    let i2 = n2.nodes[0].toString(), a2 = r2.find((u2) => u2.value === i2);
    if (!a2)
      return;
    let s2 = [], o2 = n2.next();
    for (; o2 && o2.type !== "combinator"; )
      s2.push(o2), o2 = o2.next();
    let l2 = o2;
    a2.pseudo.parent.insertAfter(a2.pseudo, be.default.selector({ nodes: s2.map((u2) => u2.clone()) })), n2.remove(), s2.forEach((u2) => u2.remove()), l2 && l2.type === "combinator" && l2.remove();
  }), [t2, e2];
}
function Fs(t2) {
  return Be(`.${re(t2)}`);
}
function ln(t2, e2) {
  return Fs(or(t2, e2));
}
function or(t2, e2) {
  return e2 === "DEFAULT" ? t2 : e2 === "-" || e2 === "-DEFAULT" ? `-${t2}` : e2.startsWith("-") ? `-${t2}${e2}` : e2.startsWith("/") ? `${t2}${e2}` : `${t2}-${e2}`;
}
var Cf = H(qs());
var Vs = H(ve());
function Ce(t2) {
  return ["fontSize", "outline"].includes(t2) ? (e2) => (typeof e2 == "function" && (e2 = e2({})), Array.isArray(e2) && (e2 = e2[0]), e2) : t2 === "fontFamily" ? (e2) => {
    typeof e2 == "function" && (e2 = e2({}));
    let r2 = Array.isArray(e2) && X(e2[1]) ? e2[0] : e2;
    return Array.isArray(r2) ? r2.join(", ") : r2;
  } : ["boxShadow", "transitionProperty", "transitionDuration", "transitionDelay", "transitionTimingFunction", "backgroundImage", "backgroundSize", "backgroundColor", "cursor", "animation"].includes(t2) ? (e2) => (typeof e2 == "function" && (e2 = e2({})), Array.isArray(e2) && (e2 = e2.join(", ")), e2) : ["gridTemplateColumns", "gridTemplateRows", "objectPosition"].includes(t2) ? (e2) => (typeof e2 == "function" && (e2 = e2({})), typeof e2 == "string" && (e2 = R.list.comma(e2).join(" ")), e2) : (e2, r2 = {}) => (typeof e2 == "function" && (e2 = e2(r2)), e2);
}
vr();
kt();
function T(t2, e2 = [[t2, [t2]]], { filterDefault: r2 = false, ...n2 } = {}) {
  let i2 = Ce(t2);
  return function({ matchUtilities: a2, theme: s2 }) {
    var o2;
    for (let l2 of e2) {
      let u2 = Array.isArray(l2[0]) ? l2 : [l2];
      a2(u2.reduce((f2, [p2, c2]) => Object.assign(f2, { [p2]: (d2) => c2.reduce((h2, y3) => Array.isArray(y3) ? Object.assign(h2, { [y3[0]]: y3[1] }) : Object.assign(h2, { [y3]: i2(d2) }), {}) }), {}), { ...n2, values: r2 ? Object.fromEntries(Object.entries((o2 = s2(t2)) != null ? o2 : {}).filter(([f2]) => f2 !== "DEFAULT")) : s2(t2) });
    }
  };
}
function Me(t2) {
  return t2 = Array.isArray(t2) ? t2 : [t2], t2.map((e2) => {
    let r2 = e2.values.map((n2) => n2.raw !== void 0 ? n2.raw : [n2.min && `(min-width: ${n2.min})`, n2.max && `(max-width: ${n2.max})`].filter(Boolean).join(" and "));
    return e2.not ? `not all and ${r2}` : r2;
  }).join(", ");
}
var X0 = /* @__PURE__ */ new Set(["normal", "reverse", "alternate", "alternate-reverse"]);
var K0 = /* @__PURE__ */ new Set(["running", "paused"]);
var Z0 = /* @__PURE__ */ new Set(["none", "forwards", "backwards", "both"]);
var ev = /* @__PURE__ */ new Set(["infinite"]);
var tv = /* @__PURE__ */ new Set(["linear", "ease", "ease-in", "ease-out", "ease-in-out", "step-start", "step-end"]);
var rv = ["cubic-bezier", "steps"];
var nv = /\,(?![^(]*\))/g;
var iv = /\ +(?![^(]*\))/g;
var mf = /^(-?[\d.]+m?s)$/;
var sv = /^(\d+)$/;
function $s(t2) {
  return t2.split(nv).map((r2) => {
    let n2 = r2.trim(), i2 = { value: n2 }, a2 = n2.split(iv), s2 = /* @__PURE__ */ new Set();
    for (let o2 of a2)
      !s2.has("DIRECTIONS") && X0.has(o2) ? (i2.direction = o2, s2.add("DIRECTIONS")) : !s2.has("PLAY_STATES") && K0.has(o2) ? (i2.playState = o2, s2.add("PLAY_STATES")) : !s2.has("FILL_MODES") && Z0.has(o2) ? (i2.fillMode = o2, s2.add("FILL_MODES")) : !s2.has("ITERATION_COUNTS") && (ev.has(o2) || sv.test(o2)) ? (i2.iterationCount = o2, s2.add("ITERATION_COUNTS")) : !s2.has("TIMING_FUNCTION") && tv.has(o2) || !s2.has("TIMING_FUNCTION") && rv.some((l2) => o2.startsWith(`${l2}(`)) ? (i2.timingFunction = o2, s2.add("TIMING_FUNCTION")) : !s2.has("DURATION") && mf.test(o2) ? (i2.duration = o2, s2.add("DURATION")) : !s2.has("DELAY") && mf.test(o2) ? (i2.delay = o2, s2.add("DELAY")) : s2.has("NAME") ? (i2.unknown || (i2.unknown = []), i2.unknown.push(o2)) : (i2.name = o2, s2.add("NAME"));
    return i2;
  });
}
var gf = (t2) => Object.assign({}, ...Object.entries(t2 != null ? t2 : {}).flatMap(([e2, r2]) => typeof r2 == "object" ? Object.entries(gf(r2)).map(([n2, i2]) => ({ [e2 + (n2 === "DEFAULT" ? "" : `-${n2}`)]: i2 })) : [{ [`${e2}`]: r2 }]));
var Q = gf;
function M(t2) {
  return typeof t2 == "function" ? t2({}) : t2;
}
function Fe(t2, e2 = true) {
  return Array.isArray(t2) ? t2.map((r2) => {
    if (e2 && Array.isArray(r2))
      throw new Error("The tuple syntax is not supported for `screens`.");
    if (typeof r2 == "string")
      return { name: r2.toString(), not: false, values: [{ min: r2, max: void 0 }] };
    let [n2, i2] = r2;
    return n2 = n2.toString(), typeof i2 == "string" ? { name: n2, not: false, values: [{ min: i2, max: void 0 }] } : Array.isArray(i2) ? { name: n2, not: false, values: i2.map((a2) => yf(a2)) } : { name: n2, not: false, values: [yf(i2)] };
  }) : Fe(Object.entries(t2 != null ? t2 : {}), false);
}
function un(t2) {
  return t2.values.length !== 1 ? { result: false, reason: "multiple-values" } : t2.values[0].raw !== void 0 ? { result: false, reason: "raw-values" } : t2.values[0].min !== void 0 && t2.values[0].max !== void 0 ? { result: false, reason: "min-and-max" } : { result: true, reason: null };
}
function vf(t2, e2, r2) {
  let n2 = fn(e2, t2), i2 = fn(r2, t2), a2 = un(n2), s2 = un(i2);
  if (a2.reason === "multiple-values" || s2.reason === "multiple-values")
    throw new Error("Attempted to sort a screen with multiple values. This should never happen. Please open a bug report.");
  if (a2.reason === "raw-values" || s2.reason === "raw-values")
    throw new Error("Attempted to sort a screen with raw values. This should never happen. Please open a bug report.");
  if (a2.reason === "min-and-max" || s2.reason === "min-and-max")
    throw new Error("Attempted to sort a screen with both min and max values. This should never happen. Please open a bug report.");
  let { min: o2, max: l2 } = n2.values[0], { min: u2, max: f2 } = i2.values[0];
  e2.not && ([o2, l2] = [l2, o2]), r2.not && ([u2, f2] = [f2, u2]), o2 = o2 === void 0 ? o2 : parseFloat(o2), l2 = l2 === void 0 ? l2 : parseFloat(l2), u2 = u2 === void 0 ? u2 : parseFloat(u2), f2 = f2 === void 0 ? f2 : parseFloat(f2);
  let [p2, c2] = t2 === "min" ? [o2, u2] : [f2, l2];
  return p2 - c2;
}
function fn(t2, e2) {
  return typeof t2 == "object" ? t2 : { name: "arbitrary-screen", values: [{ [e2]: t2 }] };
}
function yf({ "min-width": t2, min: e2 = t2, max: r2, raw: n2 } = {}) {
  return { min: e2, max: r2, raw: n2 };
}
function cn(t2, e2) {
  t2.walkDecls((r2) => {
    if (e2.includes(r2.prop)) {
      r2.remove();
      return;
    }
    for (let n2 of e2)
      r2.value.includes(`/ var(${n2})`) && (r2.value = r2.value.replace(`/ var(${n2})`, ""));
  });
}
var ne = { pseudoElementVariants: ({ addVariant: t2 }) => {
  t2("first-letter", "&::first-letter"), t2("first-line", "&::first-line"), t2("marker", [({ container: e2 }) => (cn(e2, ["--tw-text-opacity"]), "& *::marker"), ({ container: e2 }) => (cn(e2, ["--tw-text-opacity"]), "&::marker")]), t2("selection", ["& *::selection", "&::selection"]), t2("file", "&::file-selector-button"), t2("placeholder", "&::placeholder"), t2("backdrop", "&::backdrop"), t2("before", ({ container: e2 }) => (e2.walkRules((r2) => {
    let n2 = false;
    r2.walkDecls("content", () => {
      n2 = true;
    }), n2 || r2.prepend(R.decl({ prop: "content", value: "var(--tw-content)" }));
  }), "&::before")), t2("after", ({ container: e2 }) => (e2.walkRules((r2) => {
    let n2 = false;
    r2.walkDecls("content", () => {
      n2 = true;
    }), n2 || r2.prepend(R.decl({ prop: "content", value: "var(--tw-content)" }));
  }), "&::after"));
}, pseudoClassVariants: ({ addVariant: t2, matchVariant: e2, config: r2 }) => {
  let n2 = [["first", "&:first-child"], ["last", "&:last-child"], ["only", "&:only-child"], ["odd", "&:nth-child(odd)"], ["even", "&:nth-child(even)"], "first-of-type", "last-of-type", "only-of-type", ["visited", ({ container: a2 }) => (cn(a2, ["--tw-text-opacity", "--tw-border-opacity", "--tw-bg-opacity"]), "&:visited")], "target", ["open", "&[open]"], "default", "checked", "indeterminate", "placeholder-shown", "autofill", "optional", "required", "valid", "invalid", "in-range", "out-of-range", "read-only", "empty", "focus-within", ["hover", G(r2(), "hoverOnlyWhenSupported") ? "@media (hover: hover) and (pointer: fine) { &:hover }" : "&:hover"], "focus", "focus-visible", "active", "enabled", "disabled"].map((a2) => Array.isArray(a2) ? a2 : [a2, `&:${a2}`]);
  for (let [a2, s2] of n2)
    t2(a2, (o2) => typeof s2 == "function" ? s2(o2) : s2);
  let i2 = { group: (a2, { modifier: s2 }) => s2 ? [`:merge(.group\\/${re(s2)})`, " &"] : [":merge(.group)", " &"], peer: (a2, { modifier: s2 }) => s2 ? [`:merge(.peer\\/${re(s2)})`, " ~ &"] : [":merge(.peer)", " ~ &"] };
  for (let [a2, s2] of Object.entries(i2))
    e2(a2, (o2 = "", l2) => {
      let u2 = z(typeof o2 == "function" ? o2(l2) : o2);
      u2.includes("&") || (u2 = "&" + u2);
      let [f2, p2] = s2("", l2), c2 = null, d2 = null, h2 = 0;
      for (let y3 = 0; y3 < u2.length; ++y3) {
        let m = u2[y3];
        m === "&" ? c2 = y3 : m === "'" || m === '"' ? h2 += 1 : c2 !== null && m === " " && !h2 && (d2 = y3);
      }
      return c2 !== null && d2 === null && (d2 = u2.length), u2.slice(0, c2) + f2 + u2.slice(c2 + 1, d2) + p2 + u2.slice(d2);
    }, { values: Object.fromEntries(n2) });
}, directionVariants: ({ addVariant: t2 }) => {
  t2("ltr", ':is([dir="ltr"] &)'), t2("rtl", ':is([dir="rtl"] &)');
}, reducedMotionVariants: ({ addVariant: t2 }) => {
  t2("motion-safe", "@media (prefers-reduced-motion: no-preference)"), t2("motion-reduce", "@media (prefers-reduced-motion: reduce)");
}, darkVariants: ({ config: t2, addVariant: e2 }) => {
  let [r2, n2 = ".dark"] = [].concat(t2("darkMode", "media"));
  r2 === false && (r2 = "media", L.warn("darkmode-false", ["The `darkMode` option in your Tailwind CSS configuration is set to `false`, which now behaves the same as `media`.", "Change `darkMode` to `media` or remove it entirely.", "https://tailwindcss.com/docs/upgrade-guide#remove-dark-mode-configuration"])), r2 === "class" ? e2("dark", `:is(${n2} &)`) : r2 === "media" && e2("dark", "@media (prefers-color-scheme: dark)");
}, printVariant: ({ addVariant: t2 }) => {
  t2("print", "@media print");
}, screenVariants: ({ theme: t2, addVariant: e2, matchVariant: r2 }) => {
  var g2;
  let n2 = (g2 = t2("screens")) != null ? g2 : {}, i2 = Object.values(n2).every((w2) => typeof w2 == "string"), a2 = Fe(t2("screens")), s2 = /* @__PURE__ */ new Set([]);
  function o2(w2) {
    var b3, v2;
    return (v2 = (b3 = w2.match(/(\D+)$/)) == null ? void 0 : b3[1]) != null ? v2 : "(none)";
  }
  function l2(w2) {
    w2 !== void 0 && s2.add(o2(w2));
  }
  function u2(w2) {
    return l2(w2), s2.size === 1;
  }
  for (let w2 of a2)
    for (let b3 of w2.values)
      l2(b3.min), l2(b3.max);
  let f2 = s2.size <= 1;
  function p2(w2) {
    return Object.fromEntries(a2.filter((b3) => un(b3).result).map((b3) => {
      let { min: v2, max: O2 } = b3.values[0];
      if (w2 === "min" && v2 !== void 0)
        return b3;
      if (w2 === "min" && O2 !== void 0)
        return { ...b3, not: !b3.not };
      if (w2 === "max" && O2 !== void 0)
        return b3;
      if (w2 === "max" && v2 !== void 0)
        return { ...b3, not: !b3.not };
    }).map((b3) => [b3.name, b3]));
  }
  function c2(w2) {
    return (b3, v2) => vf(w2, b3.value, v2.value);
  }
  let d2 = c2("max"), h2 = c2("min");
  function y3(w2) {
    return (b3) => {
      if (i2)
        if (f2) {
          if (typeof b3 == "string" && !u2(b3))
            return L.warn("minmax-have-mixed-units", ["The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."]), [];
        } else
          return L.warn("mixed-screen-units", ["The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."]), [];
      else
        return L.warn("complex-screen-config", ["The `min-*` and `max-*` variants are not supported with a `screens` configuration containing objects."]), [];
      return [`@media ${Me(fn(b3, w2))}`];
    };
  }
  r2("max", y3("max"), { sort: d2, values: i2 ? p2("max") : {} });
  let m = "min-screens";
  for (let w2 of a2)
    e2(w2.name, `@media ${Me(w2)}`, { id: m, sort: i2 && f2 ? h2 : void 0, value: w2 });
  r2("min", y3("min"), { id: m, sort: h2 });
}, supportsVariants: ({ matchVariant: t2, theme: e2 }) => {
  var r2;
  t2("supports", (n2 = "") => {
    let i2 = z(n2), a2 = /^\w*\s*\(/.test(i2);
    return i2 = a2 ? i2.replace(/\b(and|or|not)\b/g, " $1 ") : i2, a2 ? `@supports ${i2}` : (i2.includes(":") || (i2 = `${i2}: var(--tw)`), i2.startsWith("(") && i2.endsWith(")") || (i2 = `(${i2})`), `@supports ${i2}`);
  }, { values: (r2 = e2("supports")) != null ? r2 : {} });
}, ariaVariants: ({ matchVariant: t2, theme: e2 }) => {
  var r2, n2, i2;
  t2("aria", (a2) => `&[aria-${z(a2)}]`, { values: (r2 = e2("aria")) != null ? r2 : {} }), t2("group-aria", (a2, { modifier: s2 }) => s2 ? `:merge(.group\\/${s2})[aria-${z(a2)}] &` : `:merge(.group)[aria-${z(a2)}] &`, { values: (n2 = e2("aria")) != null ? n2 : {} }), t2("peer-aria", (a2, { modifier: s2 }) => s2 ? `:merge(.peer\\/${s2})[aria-${z(a2)}] ~ &` : `:merge(.peer)[aria-${z(a2)}] ~ &`, { values: (i2 = e2("aria")) != null ? i2 : {} });
}, dataVariants: ({ matchVariant: t2, theme: e2 }) => {
  var r2, n2, i2;
  t2("data", (a2) => `&[data-${z(a2)}]`, { values: (r2 = e2("data")) != null ? r2 : {} }), t2("group-data", (a2, { modifier: s2 }) => s2 ? `:merge(.group\\/${s2})[data-${z(a2)}] &` : `:merge(.group)[data-${z(a2)}] &`, { values: (n2 = e2("data")) != null ? n2 : {} }), t2("peer-data", (a2, { modifier: s2 }) => s2 ? `:merge(.peer\\/${s2})[data-${z(a2)}] ~ &` : `:merge(.peer)[data-${z(a2)}] ~ &`, { values: (i2 = e2("data")) != null ? i2 : {} });
}, orientationVariants: ({ addVariant: t2 }) => {
  t2("portrait", "@media (orientation: portrait)"), t2("landscape", "@media (orientation: landscape)");
}, prefersContrastVariants: ({ addVariant: t2 }) => {
  t2("contrast-more", "@media (prefers-contrast: more)"), t2("contrast-less", "@media (prefers-contrast: less)");
} };
var he = ["translate(var(--tw-translate-x), var(--tw-translate-y))", "rotate(var(--tw-rotate))", "skewX(var(--tw-skew-x))", "skewY(var(--tw-skew-y))", "scaleX(var(--tw-scale-x))", "scaleY(var(--tw-scale-y))"].join(" ");
var xe = ["var(--tw-blur)", "var(--tw-brightness)", "var(--tw-contrast)", "var(--tw-grayscale)", "var(--tw-hue-rotate)", "var(--tw-invert)", "var(--tw-saturate)", "var(--tw-sepia)", "var(--tw-drop-shadow)"].join(" ");
var Se = ["var(--tw-backdrop-blur)", "var(--tw-backdrop-brightness)", "var(--tw-backdrop-contrast)", "var(--tw-backdrop-grayscale)", "var(--tw-backdrop-hue-rotate)", "var(--tw-backdrop-invert)", "var(--tw-backdrop-opacity)", "var(--tw-backdrop-saturate)", "var(--tw-backdrop-sepia)"].join(" ");
var wf = { preflight: ({ addBase: t2 }) => {
  let e2 = R.parse(ht.readFileSync(Kn("/", "./css/preflight.css"), "utf8"));
  t2([R.comment({ text: `! tailwindcss v${$a} | MIT License | https://tailwindcss.com` }), ...e2.nodes]);
}, container: (() => {
  function t2(r2 = []) {
    return r2.flatMap((n2) => n2.values.map((i2) => i2.min)).filter((n2) => n2 !== void 0);
  }
  function e2(r2, n2, i2) {
    if (typeof i2 > "u")
      return [];
    if (!(typeof i2 == "object" && i2 !== null))
      return [{ screen: "DEFAULT", minWidth: 0, padding: i2 }];
    let a2 = [];
    i2.DEFAULT && a2.push({ screen: "DEFAULT", minWidth: 0, padding: i2.DEFAULT });
    for (let s2 of r2)
      for (let o2 of n2)
        for (let { min: l2 } of o2.values)
          l2 === s2 && a2.push({ minWidth: s2, padding: i2[o2.name] });
    return a2;
  }
  return function({ addComponents: r2, theme: n2 }) {
    let i2 = Fe(n2("container.screens", n2("screens"))), a2 = t2(i2), s2 = e2(a2, i2, n2("container.padding")), o2 = (u2) => {
      let f2 = s2.find((p2) => p2.minWidth === u2);
      return f2 ? { paddingRight: f2.padding, paddingLeft: f2.padding } : {};
    }, l2 = Array.from(new Set(a2.slice().sort((u2, f2) => parseInt(u2) - parseInt(f2)))).map((u2) => ({ [`@media (min-width: ${u2})`]: { ".container": { "max-width": u2, ...o2(u2) } } }));
    r2([{ ".container": Object.assign({ width: "100%" }, n2("container.center", false) ? { marginRight: "auto", marginLeft: "auto" } : {}, o2(0)) }, ...l2]);
  };
})(), accessibility: ({ addUtilities: t2 }) => {
  t2({ ".sr-only": { position: "absolute", width: "1px", height: "1px", padding: "0", margin: "-1px", overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0" }, ".not-sr-only": { position: "static", width: "auto", height: "auto", padding: "0", margin: "0", overflow: "visible", clip: "auto", whiteSpace: "normal" } });
}, pointerEvents: ({ addUtilities: t2 }) => {
  t2({ ".pointer-events-none": { "pointer-events": "none" }, ".pointer-events-auto": { "pointer-events": "auto" } });
}, visibility: ({ addUtilities: t2 }) => {
  t2({ ".visible": { visibility: "visible" }, ".invisible": { visibility: "hidden" }, ".collapse": { visibility: "collapse" } });
}, position: ({ addUtilities: t2 }) => {
  t2({ ".static": { position: "static" }, ".fixed": { position: "fixed" }, ".absolute": { position: "absolute" }, ".relative": { position: "relative" }, ".sticky": { position: "sticky" } });
}, inset: T("inset", [["inset", ["inset"]], [["inset-x", ["left", "right"]], ["inset-y", ["top", "bottom"]]], [["start", ["inset-inline-start"]], ["end", ["inset-inline-end"]], ["top", ["top"]], ["right", ["right"]], ["bottom", ["bottom"]], ["left", ["left"]]]], { supportsNegativeValues: true }), isolation: ({ addUtilities: t2 }) => {
  t2({ ".isolate": { isolation: "isolate" }, ".isolation-auto": { isolation: "auto" } });
}, zIndex: T("zIndex", [["z", ["zIndex"]]], { supportsNegativeValues: true }), order: T("order", void 0, { supportsNegativeValues: true }), gridColumn: T("gridColumn", [["col", ["gridColumn"]]]), gridColumnStart: T("gridColumnStart", [["col-start", ["gridColumnStart"]]]), gridColumnEnd: T("gridColumnEnd", [["col-end", ["gridColumnEnd"]]]), gridRow: T("gridRow", [["row", ["gridRow"]]]), gridRowStart: T("gridRowStart", [["row-start", ["gridRowStart"]]]), gridRowEnd: T("gridRowEnd", [["row-end", ["gridRowEnd"]]]), float: ({ addUtilities: t2 }) => {
  t2({ ".float-right": { float: "right" }, ".float-left": { float: "left" }, ".float-none": { float: "none" } });
}, clear: ({ addUtilities: t2 }) => {
  t2({ ".clear-left": { clear: "left" }, ".clear-right": { clear: "right" }, ".clear-both": { clear: "both" }, ".clear-none": { clear: "none" } });
}, margin: T("margin", [["m", ["margin"]], [["mx", ["margin-left", "margin-right"]], ["my", ["margin-top", "margin-bottom"]]], [["ms", ["margin-inline-start"]], ["me", ["margin-inline-end"]], ["mt", ["margin-top"]], ["mr", ["margin-right"]], ["mb", ["margin-bottom"]], ["ml", ["margin-left"]]]], { supportsNegativeValues: true }), boxSizing: ({ addUtilities: t2 }) => {
  t2({ ".box-border": { "box-sizing": "border-box" }, ".box-content": { "box-sizing": "content-box" } });
}, lineClamp: ({ matchUtilities: t2, addUtilities: e2, theme: r2 }) => {
  t2({ "line-clamp": (n2) => ({ overflow: "hidden", display: "-webkit-box", "-webkit-box-orient": "vertical", "-webkit-line-clamp": `${n2}` }) }, { values: r2("lineClamp") }), e2({ ".line-clamp-none": { overflow: "visible", display: "block", "-webkit-box-orient": "horizontal", "-webkit-line-clamp": "none" } });
}, display: ({ addUtilities: t2 }) => {
  t2({ ".block": { display: "block" }, ".inline-block": { display: "inline-block" }, ".inline": { display: "inline" }, ".flex": { display: "flex" }, ".inline-flex": { display: "inline-flex" }, ".table": { display: "table" }, ".inline-table": { display: "inline-table" }, ".table-caption": { display: "table-caption" }, ".table-cell": { display: "table-cell" }, ".table-column": { display: "table-column" }, ".table-column-group": { display: "table-column-group" }, ".table-footer-group": { display: "table-footer-group" }, ".table-header-group": { display: "table-header-group" }, ".table-row-group": { display: "table-row-group" }, ".table-row": { display: "table-row" }, ".flow-root": { display: "flow-root" }, ".grid": { display: "grid" }, ".inline-grid": { display: "inline-grid" }, ".contents": { display: "contents" }, ".list-item": { display: "list-item" }, ".hidden": { display: "none" } });
}, aspectRatio: T("aspectRatio", [["aspect", ["aspect-ratio"]]]), height: T("height", [["h", ["height"]]]), maxHeight: T("maxHeight", [["max-h", ["maxHeight"]]]), minHeight: T("minHeight", [["min-h", ["minHeight"]]]), width: T("width", [["w", ["width"]]]), minWidth: T("minWidth", [["min-w", ["minWidth"]]]), maxWidth: T("maxWidth", [["max-w", ["maxWidth"]]]), flex: T("flex"), flexShrink: T("flexShrink", [["flex-shrink", ["flex-shrink"]], ["shrink", ["flex-shrink"]]]), flexGrow: T("flexGrow", [["flex-grow", ["flex-grow"]], ["grow", ["flex-grow"]]]), flexBasis: T("flexBasis", [["basis", ["flex-basis"]]]), tableLayout: ({ addUtilities: t2 }) => {
  t2({ ".table-auto": { "table-layout": "auto" }, ".table-fixed": { "table-layout": "fixed" } });
}, captionSide: ({ addUtilities: t2 }) => {
  t2({ ".caption-top": { "caption-side": "top" }, ".caption-bottom": { "caption-side": "bottom" } });
}, borderCollapse: ({ addUtilities: t2 }) => {
  t2({ ".border-collapse": { "border-collapse": "collapse" }, ".border-separate": { "border-collapse": "separate" } });
}, borderSpacing: ({ addDefaults: t2, matchUtilities: e2, theme: r2 }) => {
  t2("border-spacing", { "--tw-border-spacing-x": 0, "--tw-border-spacing-y": 0 }), e2({ "border-spacing": (n2) => ({ "--tw-border-spacing-x": n2, "--tw-border-spacing-y": n2, "@defaults border-spacing": {}, "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)" }), "border-spacing-x": (n2) => ({ "--tw-border-spacing-x": n2, "@defaults border-spacing": {}, "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)" }), "border-spacing-y": (n2) => ({ "--tw-border-spacing-y": n2, "@defaults border-spacing": {}, "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)" }) }, { values: r2("borderSpacing") });
}, transformOrigin: T("transformOrigin", [["origin", ["transformOrigin"]]]), translate: T("translate", [[["translate-x", [["@defaults transform", {}], "--tw-translate-x", ["transform", he]]], ["translate-y", [["@defaults transform", {}], "--tw-translate-y", ["transform", he]]]]], { supportsNegativeValues: true }), rotate: T("rotate", [["rotate", [["@defaults transform", {}], "--tw-rotate", ["transform", he]]]], { supportsNegativeValues: true }), skew: T("skew", [[["skew-x", [["@defaults transform", {}], "--tw-skew-x", ["transform", he]]], ["skew-y", [["@defaults transform", {}], "--tw-skew-y", ["transform", he]]]]], { supportsNegativeValues: true }), scale: T("scale", [["scale", [["@defaults transform", {}], "--tw-scale-x", "--tw-scale-y", ["transform", he]]], [["scale-x", [["@defaults transform", {}], "--tw-scale-x", ["transform", he]]], ["scale-y", [["@defaults transform", {}], "--tw-scale-y", ["transform", he]]]]], { supportsNegativeValues: true }), transform: ({ addDefaults: t2, addUtilities: e2 }) => {
  t2("transform", { "--tw-translate-x": "0", "--tw-translate-y": "0", "--tw-rotate": "0", "--tw-skew-x": "0", "--tw-skew-y": "0", "--tw-scale-x": "1", "--tw-scale-y": "1" }), e2({ ".transform": { "@defaults transform": {}, transform: he }, ".transform-cpu": { transform: he }, ".transform-gpu": { transform: he.replace("translate(var(--tw-translate-x), var(--tw-translate-y))", "translate3d(var(--tw-translate-x), var(--tw-translate-y), 0)") }, ".transform-none": { transform: "none" } });
}, animation: ({ matchUtilities: t2, theme: e2, config: r2 }) => {
  var a2;
  let n2 = (s2) => `${r2("prefix")}${re(s2)}`, i2 = Object.fromEntries(Object.entries((a2 = e2("keyframes")) != null ? a2 : {}).map(([s2, o2]) => [s2, { [`@keyframes ${n2(s2)}`]: o2 }]));
  t2({ animate: (s2) => {
    let o2 = $s(s2);
    return [...o2.flatMap((l2) => i2[l2.name]), { animation: o2.map(({ name: l2, value: u2 }) => l2 === void 0 || i2[l2] === void 0 ? u2 : u2.replace(l2, n2(l2))).join(", ") }];
  } }, { values: e2("animation") });
}, cursor: T("cursor"), touchAction: ({ addDefaults: t2, addUtilities: e2 }) => {
  t2("touch-action", { "--tw-pan-x": " ", "--tw-pan-y": " ", "--tw-pinch-zoom": " " });
  let r2 = "var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)";
  e2({ ".touch-auto": { "touch-action": "auto" }, ".touch-none": { "touch-action": "none" }, ".touch-pan-x": { "@defaults touch-action": {}, "--tw-pan-x": "pan-x", "touch-action": r2 }, ".touch-pan-left": { "@defaults touch-action": {}, "--tw-pan-x": "pan-left", "touch-action": r2 }, ".touch-pan-right": { "@defaults touch-action": {}, "--tw-pan-x": "pan-right", "touch-action": r2 }, ".touch-pan-y": { "@defaults touch-action": {}, "--tw-pan-y": "pan-y", "touch-action": r2 }, ".touch-pan-up": { "@defaults touch-action": {}, "--tw-pan-y": "pan-up", "touch-action": r2 }, ".touch-pan-down": { "@defaults touch-action": {}, "--tw-pan-y": "pan-down", "touch-action": r2 }, ".touch-pinch-zoom": { "@defaults touch-action": {}, "--tw-pinch-zoom": "pinch-zoom", "touch-action": r2 }, ".touch-manipulation": { "touch-action": "manipulation" } });
}, userSelect: ({ addUtilities: t2 }) => {
  t2({ ".select-none": { "user-select": "none" }, ".select-text": { "user-select": "text" }, ".select-all": { "user-select": "all" }, ".select-auto": { "user-select": "auto" } });
}, resize: ({ addUtilities: t2 }) => {
  t2({ ".resize-none": { resize: "none" }, ".resize-y": { resize: "vertical" }, ".resize-x": { resize: "horizontal" }, ".resize": { resize: "both" } });
}, scrollSnapType: ({ addDefaults: t2, addUtilities: e2 }) => {
  t2("scroll-snap-type", { "--tw-scroll-snap-strictness": "proximity" }), e2({ ".snap-none": { "scroll-snap-type": "none" }, ".snap-x": { "@defaults scroll-snap-type": {}, "scroll-snap-type": "x var(--tw-scroll-snap-strictness)" }, ".snap-y": { "@defaults scroll-snap-type": {}, "scroll-snap-type": "y var(--tw-scroll-snap-strictness)" }, ".snap-both": { "@defaults scroll-snap-type": {}, "scroll-snap-type": "both var(--tw-scroll-snap-strictness)" }, ".snap-mandatory": { "--tw-scroll-snap-strictness": "mandatory" }, ".snap-proximity": { "--tw-scroll-snap-strictness": "proximity" } });
}, scrollSnapAlign: ({ addUtilities: t2 }) => {
  t2({ ".snap-start": { "scroll-snap-align": "start" }, ".snap-end": { "scroll-snap-align": "end" }, ".snap-center": { "scroll-snap-align": "center" }, ".snap-align-none": { "scroll-snap-align": "none" } });
}, scrollSnapStop: ({ addUtilities: t2 }) => {
  t2({ ".snap-normal": { "scroll-snap-stop": "normal" }, ".snap-always": { "scroll-snap-stop": "always" } });
}, scrollMargin: T("scrollMargin", [["scroll-m", ["scroll-margin"]], [["scroll-mx", ["scroll-margin-left", "scroll-margin-right"]], ["scroll-my", ["scroll-margin-top", "scroll-margin-bottom"]]], [["scroll-ms", ["scroll-margin-inline-start"]], ["scroll-me", ["scroll-margin-inline-end"]], ["scroll-mt", ["scroll-margin-top"]], ["scroll-mr", ["scroll-margin-right"]], ["scroll-mb", ["scroll-margin-bottom"]], ["scroll-ml", ["scroll-margin-left"]]]], { supportsNegativeValues: true }), scrollPadding: T("scrollPadding", [["scroll-p", ["scroll-padding"]], [["scroll-px", ["scroll-padding-left", "scroll-padding-right"]], ["scroll-py", ["scroll-padding-top", "scroll-padding-bottom"]]], [["scroll-ps", ["scroll-padding-inline-start"]], ["scroll-pe", ["scroll-padding-inline-end"]], ["scroll-pt", ["scroll-padding-top"]], ["scroll-pr", ["scroll-padding-right"]], ["scroll-pb", ["scroll-padding-bottom"]], ["scroll-pl", ["scroll-padding-left"]]]]), listStylePosition: ({ addUtilities: t2 }) => {
  t2({ ".list-inside": { "list-style-position": "inside" }, ".list-outside": { "list-style-position": "outside" } });
}, listStyleType: T("listStyleType", [["list", ["listStyleType"]]]), listStyleImage: T("listStyleImage", [["list-image", ["listStyleImage"]]]), appearance: ({ addUtilities: t2 }) => {
  t2({ ".appearance-none": { appearance: "none" } });
}, columns: T("columns", [["columns", ["columns"]]]), breakBefore: ({ addUtilities: t2 }) => {
  t2({ ".break-before-auto": { "break-before": "auto" }, ".break-before-avoid": { "break-before": "avoid" }, ".break-before-all": { "break-before": "all" }, ".break-before-avoid-page": { "break-before": "avoid-page" }, ".break-before-page": { "break-before": "page" }, ".break-before-left": { "break-before": "left" }, ".break-before-right": { "break-before": "right" }, ".break-before-column": { "break-before": "column" } });
}, breakInside: ({ addUtilities: t2 }) => {
  t2({ ".break-inside-auto": { "break-inside": "auto" }, ".break-inside-avoid": { "break-inside": "avoid" }, ".break-inside-avoid-page": { "break-inside": "avoid-page" }, ".break-inside-avoid-column": { "break-inside": "avoid-column" } });
}, breakAfter: ({ addUtilities: t2 }) => {
  t2({ ".break-after-auto": { "break-after": "auto" }, ".break-after-avoid": { "break-after": "avoid" }, ".break-after-all": { "break-after": "all" }, ".break-after-avoid-page": { "break-after": "avoid-page" }, ".break-after-page": { "break-after": "page" }, ".break-after-left": { "break-after": "left" }, ".break-after-right": { "break-after": "right" }, ".break-after-column": { "break-after": "column" } });
}, gridAutoColumns: T("gridAutoColumns", [["auto-cols", ["gridAutoColumns"]]]), gridAutoFlow: ({ addUtilities: t2 }) => {
  t2({ ".grid-flow-row": { gridAutoFlow: "row" }, ".grid-flow-col": { gridAutoFlow: "column" }, ".grid-flow-dense": { gridAutoFlow: "dense" }, ".grid-flow-row-dense": { gridAutoFlow: "row dense" }, ".grid-flow-col-dense": { gridAutoFlow: "column dense" } });
}, gridAutoRows: T("gridAutoRows", [["auto-rows", ["gridAutoRows"]]]), gridTemplateColumns: T("gridTemplateColumns", [["grid-cols", ["gridTemplateColumns"]]]), gridTemplateRows: T("gridTemplateRows", [["grid-rows", ["gridTemplateRows"]]]), flexDirection: ({ addUtilities: t2 }) => {
  t2({ ".flex-row": { "flex-direction": "row" }, ".flex-row-reverse": { "flex-direction": "row-reverse" }, ".flex-col": { "flex-direction": "column" }, ".flex-col-reverse": { "flex-direction": "column-reverse" } });
}, flexWrap: ({ addUtilities: t2 }) => {
  t2({ ".flex-wrap": { "flex-wrap": "wrap" }, ".flex-wrap-reverse": { "flex-wrap": "wrap-reverse" }, ".flex-nowrap": { "flex-wrap": "nowrap" } });
}, placeContent: ({ addUtilities: t2 }) => {
  t2({ ".place-content-center": { "place-content": "center" }, ".place-content-start": { "place-content": "start" }, ".place-content-end": { "place-content": "end" }, ".place-content-between": { "place-content": "space-between" }, ".place-content-around": { "place-content": "space-around" }, ".place-content-evenly": { "place-content": "space-evenly" }, ".place-content-baseline": { "place-content": "baseline" }, ".place-content-stretch": { "place-content": "stretch" } });
}, placeItems: ({ addUtilities: t2 }) => {
  t2({ ".place-items-start": { "place-items": "start" }, ".place-items-end": { "place-items": "end" }, ".place-items-center": { "place-items": "center" }, ".place-items-baseline": { "place-items": "baseline" }, ".place-items-stretch": { "place-items": "stretch" } });
}, alignContent: ({ addUtilities: t2 }) => {
  t2({ ".content-normal": { "align-content": "normal" }, ".content-center": { "align-content": "center" }, ".content-start": { "align-content": "flex-start" }, ".content-end": { "align-content": "flex-end" }, ".content-between": { "align-content": "space-between" }, ".content-around": { "align-content": "space-around" }, ".content-evenly": { "align-content": "space-evenly" }, ".content-baseline": { "align-content": "baseline" }, ".content-stretch": { "align-content": "stretch" } });
}, alignItems: ({ addUtilities: t2 }) => {
  t2({ ".items-start": { "align-items": "flex-start" }, ".items-end": { "align-items": "flex-end" }, ".items-center": { "align-items": "center" }, ".items-baseline": { "align-items": "baseline" }, ".items-stretch": { "align-items": "stretch" } });
}, justifyContent: ({ addUtilities: t2 }) => {
  t2({ ".justify-normal": { "justify-content": "normal" }, ".justify-start": { "justify-content": "flex-start" }, ".justify-end": { "justify-content": "flex-end" }, ".justify-center": { "justify-content": "center" }, ".justify-between": { "justify-content": "space-between" }, ".justify-around": { "justify-content": "space-around" }, ".justify-evenly": { "justify-content": "space-evenly" }, ".justify-stretch": { "justify-content": "stretch" } });
}, justifyItems: ({ addUtilities: t2 }) => {
  t2({ ".justify-items-start": { "justify-items": "start" }, ".justify-items-end": { "justify-items": "end" }, ".justify-items-center": { "justify-items": "center" }, ".justify-items-stretch": { "justify-items": "stretch" } });
}, gap: T("gap", [["gap", ["gap"]], [["gap-x", ["columnGap"]], ["gap-y", ["rowGap"]]]]), space: ({ matchUtilities: t2, addUtilities: e2, theme: r2 }) => {
  t2({ "space-x": (n2) => (n2 = n2 === "0" ? "0px" : n2, { "& > :not([hidden]) ~ :not([hidden])": { "--tw-space-x-reverse": "0", "margin-right": `calc(${n2} * var(--tw-space-x-reverse))`, "margin-left": `calc(${n2} * calc(1 - var(--tw-space-x-reverse)))` } }), "space-y": (n2) => (n2 = n2 === "0" ? "0px" : n2, { "& > :not([hidden]) ~ :not([hidden])": { "--tw-space-y-reverse": "0", "margin-top": `calc(${n2} * calc(1 - var(--tw-space-y-reverse)))`, "margin-bottom": `calc(${n2} * var(--tw-space-y-reverse))` } }) }, { values: r2("space"), supportsNegativeValues: true }), e2({ ".space-y-reverse > :not([hidden]) ~ :not([hidden])": { "--tw-space-y-reverse": "1" }, ".space-x-reverse > :not([hidden]) ~ :not([hidden])": { "--tw-space-x-reverse": "1" } });
}, divideWidth: ({ matchUtilities: t2, addUtilities: e2, theme: r2 }) => {
  t2({ "divide-x": (n2) => (n2 = n2 === "0" ? "0px" : n2, { "& > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-x-reverse": "0", "border-right-width": `calc(${n2} * var(--tw-divide-x-reverse))`, "border-left-width": `calc(${n2} * calc(1 - var(--tw-divide-x-reverse)))` } }), "divide-y": (n2) => (n2 = n2 === "0" ? "0px" : n2, { "& > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-y-reverse": "0", "border-top-width": `calc(${n2} * calc(1 - var(--tw-divide-y-reverse)))`, "border-bottom-width": `calc(${n2} * var(--tw-divide-y-reverse))` } }) }, { values: r2("divideWidth"), type: ["line-width", "length", "any"] }), e2({ ".divide-y-reverse > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-y-reverse": "1" }, ".divide-x-reverse > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-x-reverse": "1" } });
}, divideStyle: ({ addUtilities: t2 }) => {
  t2({ ".divide-solid > :not([hidden]) ~ :not([hidden])": { "border-style": "solid" }, ".divide-dashed > :not([hidden]) ~ :not([hidden])": { "border-style": "dashed" }, ".divide-dotted > :not([hidden]) ~ :not([hidden])": { "border-style": "dotted" }, ".divide-double > :not([hidden]) ~ :not([hidden])": { "border-style": "double" }, ".divide-none > :not([hidden]) ~ :not([hidden])": { "border-style": "none" } });
}, divideColor: ({ matchUtilities: t2, theme: e2, corePlugins: r2 }) => {
  t2({ divide: (n2) => r2("divideOpacity") ? { ["& > :not([hidden]) ~ :not([hidden])"]: Z({ color: n2, property: "border-color", variable: "--tw-divide-opacity" }) } : { ["& > :not([hidden]) ~ :not([hidden])"]: { "border-color": M(n2) } } }, { values: (({ DEFAULT: n2, ...i2 }) => i2)(Q(e2("divideColor"))), type: ["color", "any"] });
}, divideOpacity: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ "divide-opacity": (r2) => ({ ["& > :not([hidden]) ~ :not([hidden])"]: { "--tw-divide-opacity": r2 } }) }, { values: e2("divideOpacity") });
}, placeSelf: ({ addUtilities: t2 }) => {
  t2({ ".place-self-auto": { "place-self": "auto" }, ".place-self-start": { "place-self": "start" }, ".place-self-end": { "place-self": "end" }, ".place-self-center": { "place-self": "center" }, ".place-self-stretch": { "place-self": "stretch" } });
}, alignSelf: ({ addUtilities: t2 }) => {
  t2({ ".self-auto": { "align-self": "auto" }, ".self-start": { "align-self": "flex-start" }, ".self-end": { "align-self": "flex-end" }, ".self-center": { "align-self": "center" }, ".self-stretch": { "align-self": "stretch" }, ".self-baseline": { "align-self": "baseline" } });
}, justifySelf: ({ addUtilities: t2 }) => {
  t2({ ".justify-self-auto": { "justify-self": "auto" }, ".justify-self-start": { "justify-self": "start" }, ".justify-self-end": { "justify-self": "end" }, ".justify-self-center": { "justify-self": "center" }, ".justify-self-stretch": { "justify-self": "stretch" } });
}, overflow: ({ addUtilities: t2 }) => {
  t2({ ".overflow-auto": { overflow: "auto" }, ".overflow-hidden": { overflow: "hidden" }, ".overflow-clip": { overflow: "clip" }, ".overflow-visible": { overflow: "visible" }, ".overflow-scroll": { overflow: "scroll" }, ".overflow-x-auto": { "overflow-x": "auto" }, ".overflow-y-auto": { "overflow-y": "auto" }, ".overflow-x-hidden": { "overflow-x": "hidden" }, ".overflow-y-hidden": { "overflow-y": "hidden" }, ".overflow-x-clip": { "overflow-x": "clip" }, ".overflow-y-clip": { "overflow-y": "clip" }, ".overflow-x-visible": { "overflow-x": "visible" }, ".overflow-y-visible": { "overflow-y": "visible" }, ".overflow-x-scroll": { "overflow-x": "scroll" }, ".overflow-y-scroll": { "overflow-y": "scroll" } });
}, overscrollBehavior: ({ addUtilities: t2 }) => {
  t2({ ".overscroll-auto": { "overscroll-behavior": "auto" }, ".overscroll-contain": { "overscroll-behavior": "contain" }, ".overscroll-none": { "overscroll-behavior": "none" }, ".overscroll-y-auto": { "overscroll-behavior-y": "auto" }, ".overscroll-y-contain": { "overscroll-behavior-y": "contain" }, ".overscroll-y-none": { "overscroll-behavior-y": "none" }, ".overscroll-x-auto": { "overscroll-behavior-x": "auto" }, ".overscroll-x-contain": { "overscroll-behavior-x": "contain" }, ".overscroll-x-none": { "overscroll-behavior-x": "none" } });
}, scrollBehavior: ({ addUtilities: t2 }) => {
  t2({ ".scroll-auto": { "scroll-behavior": "auto" }, ".scroll-smooth": { "scroll-behavior": "smooth" } });
}, textOverflow: ({ addUtilities: t2 }) => {
  t2({ ".truncate": { overflow: "hidden", "text-overflow": "ellipsis", "white-space": "nowrap" }, ".overflow-ellipsis": { "text-overflow": "ellipsis" }, ".text-ellipsis": { "text-overflow": "ellipsis" }, ".text-clip": { "text-overflow": "clip" } });
}, hyphens: ({ addUtilities: t2 }) => {
  t2({ ".hyphens-none": { hyphens: "none" }, ".hyphens-manual": { hyphens: "manual" }, ".hyphens-auto": { hyphens: "auto" } });
}, whitespace: ({ addUtilities: t2 }) => {
  t2({ ".whitespace-normal": { "white-space": "normal" }, ".whitespace-nowrap": { "white-space": "nowrap" }, ".whitespace-pre": { "white-space": "pre" }, ".whitespace-pre-line": { "white-space": "pre-line" }, ".whitespace-pre-wrap": { "white-space": "pre-wrap" }, ".whitespace-break-spaces": { "white-space": "break-spaces" } });
}, wordBreak: ({ addUtilities: t2 }) => {
  t2({ ".break-normal": { "overflow-wrap": "normal", "word-break": "normal" }, ".break-words": { "overflow-wrap": "break-word" }, ".break-all": { "word-break": "break-all" }, ".break-keep": { "word-break": "keep-all" } });
}, borderRadius: T("borderRadius", [["rounded", ["border-radius"]], [["rounded-s", ["border-start-start-radius", "border-end-start-radius"]], ["rounded-e", ["border-start-end-radius", "border-end-end-radius"]], ["rounded-t", ["border-top-left-radius", "border-top-right-radius"]], ["rounded-r", ["border-top-right-radius", "border-bottom-right-radius"]], ["rounded-b", ["border-bottom-right-radius", "border-bottom-left-radius"]], ["rounded-l", ["border-top-left-radius", "border-bottom-left-radius"]]], [["rounded-ss", ["border-start-start-radius"]], ["rounded-se", ["border-start-end-radius"]], ["rounded-ee", ["border-end-end-radius"]], ["rounded-es", ["border-end-start-radius"]], ["rounded-tl", ["border-top-left-radius"]], ["rounded-tr", ["border-top-right-radius"]], ["rounded-br", ["border-bottom-right-radius"]], ["rounded-bl", ["border-bottom-left-radius"]]]]), borderWidth: T("borderWidth", [["border", [["@defaults border-width", {}], "border-width"]], [["border-x", [["@defaults border-width", {}], "border-left-width", "border-right-width"]], ["border-y", [["@defaults border-width", {}], "border-top-width", "border-bottom-width"]]], [["border-s", [["@defaults border-width", {}], "border-inline-start-width"]], ["border-e", [["@defaults border-width", {}], "border-inline-end-width"]], ["border-t", [["@defaults border-width", {}], "border-top-width"]], ["border-r", [["@defaults border-width", {}], "border-right-width"]], ["border-b", [["@defaults border-width", {}], "border-bottom-width"]], ["border-l", [["@defaults border-width", {}], "border-left-width"]]]], { type: ["line-width", "length"] }), borderStyle: ({ addUtilities: t2 }) => {
  t2({ ".border-solid": { "border-style": "solid" }, ".border-dashed": { "border-style": "dashed" }, ".border-dotted": { "border-style": "dotted" }, ".border-double": { "border-style": "double" }, ".border-hidden": { "border-style": "hidden" }, ".border-none": { "border-style": "none" } });
}, borderColor: ({ matchUtilities: t2, theme: e2, corePlugins: r2 }) => {
  t2({ border: (n2) => r2("borderOpacity") ? Z({ color: n2, property: "border-color", variable: "--tw-border-opacity" }) : { "border-color": M(n2) } }, { values: (({ DEFAULT: n2, ...i2 }) => i2)(Q(e2("borderColor"))), type: ["color", "any"] }), t2({ "border-x": (n2) => r2("borderOpacity") ? Z({ color: n2, property: ["border-left-color", "border-right-color"], variable: "--tw-border-opacity" }) : { "border-left-color": M(n2), "border-right-color": M(n2) }, "border-y": (n2) => r2("borderOpacity") ? Z({ color: n2, property: ["border-top-color", "border-bottom-color"], variable: "--tw-border-opacity" }) : { "border-top-color": M(n2), "border-bottom-color": M(n2) } }, { values: (({ DEFAULT: n2, ...i2 }) => i2)(Q(e2("borderColor"))), type: ["color", "any"] }), t2({ "border-s": (n2) => r2("borderOpacity") ? Z({ color: n2, property: "border-inline-start-color", variable: "--tw-border-opacity" }) : { "border-inline-start-color": M(n2) }, "border-e": (n2) => r2("borderOpacity") ? Z({ color: n2, property: "border-inline-end-color", variable: "--tw-border-opacity" }) : { "border-inline-end-color": M(n2) }, "border-t": (n2) => r2("borderOpacity") ? Z({ color: n2, property: "border-top-color", variable: "--tw-border-opacity" }) : { "border-top-color": M(n2) }, "border-r": (n2) => r2("borderOpacity") ? Z({ color: n2, property: "border-right-color", variable: "--tw-border-opacity" }) : { "border-right-color": M(n2) }, "border-b": (n2) => r2("borderOpacity") ? Z({ color: n2, property: "border-bottom-color", variable: "--tw-border-opacity" }) : { "border-bottom-color": M(n2) }, "border-l": (n2) => r2("borderOpacity") ? Z({ color: n2, property: "border-left-color", variable: "--tw-border-opacity" }) : { "border-left-color": M(n2) } }, { values: (({ DEFAULT: n2, ...i2 }) => i2)(Q(e2("borderColor"))), type: ["color", "any"] });
}, borderOpacity: T("borderOpacity", [["border-opacity", ["--tw-border-opacity"]]]), backgroundColor: ({ matchUtilities: t2, theme: e2, corePlugins: r2 }) => {
  t2({ bg: (n2) => r2("backgroundOpacity") ? Z({ color: n2, property: "background-color", variable: "--tw-bg-opacity" }) : { "background-color": M(n2) } }, { values: Q(e2("backgroundColor")), type: ["color", "any"] });
}, backgroundOpacity: T("backgroundOpacity", [["bg-opacity", ["--tw-bg-opacity"]]]), backgroundImage: T("backgroundImage", [["bg", ["background-image"]]], { type: ["lookup", "image", "url"] }), gradientColorStops: (() => {
  function t2(e2) {
    return we(e2, 0, "rgb(255 255 255 / 0)");
  }
  return function({ matchUtilities: e2, theme: r2, addDefaults: n2 }) {
    n2("gradient-color-stops", { "--tw-gradient-from-position": " ", "--tw-gradient-via-position": " ", "--tw-gradient-to-position": " " });
    let i2 = { values: Q(r2("gradientColorStops")), type: ["color", "any"] }, a2 = { values: r2("gradientColorStopPositions"), type: ["length", "percentage"] };
    e2({ from: (s2) => {
      let o2 = t2(s2);
      return { "@defaults gradient-color-stops": {}, "--tw-gradient-from": `${M(s2)} var(--tw-gradient-from-position)`, "--tw-gradient-to": `${o2} var(--tw-gradient-to-position)`, "--tw-gradient-stops": "var(--tw-gradient-from), var(--tw-gradient-to)" };
    } }, i2), e2({ from: (s2) => ({ "--tw-gradient-from-position": s2 }) }, a2), e2({ via: (s2) => {
      let o2 = t2(s2);
      return { "@defaults gradient-color-stops": {}, "--tw-gradient-to": `${o2}  var(--tw-gradient-to-position)`, "--tw-gradient-stops": `var(--tw-gradient-from), ${M(s2)} var(--tw-gradient-via-position), var(--tw-gradient-to)` };
    } }, i2), e2({ via: (s2) => ({ "--tw-gradient-via-position": s2 }) }, a2), e2({ to: (s2) => ({ "@defaults gradient-color-stops": {}, "--tw-gradient-to": `${M(s2)} var(--tw-gradient-to-position)` }) }, i2), e2({ to: (s2) => ({ "--tw-gradient-to-position": s2 }) }, a2);
  };
})(), boxDecorationBreak: ({ addUtilities: t2 }) => {
  t2({ ".decoration-slice": { "box-decoration-break": "slice" }, ".decoration-clone": { "box-decoration-break": "clone" }, ".box-decoration-slice": { "box-decoration-break": "slice" }, ".box-decoration-clone": { "box-decoration-break": "clone" } });
}, backgroundSize: T("backgroundSize", [["bg", ["background-size"]]], { type: ["lookup", "length", "percentage", "size"] }), backgroundAttachment: ({ addUtilities: t2 }) => {
  t2({ ".bg-fixed": { "background-attachment": "fixed" }, ".bg-local": { "background-attachment": "local" }, ".bg-scroll": { "background-attachment": "scroll" } });
}, backgroundClip: ({ addUtilities: t2 }) => {
  t2({ ".bg-clip-border": { "background-clip": "border-box" }, ".bg-clip-padding": { "background-clip": "padding-box" }, ".bg-clip-content": { "background-clip": "content-box" }, ".bg-clip-text": { "background-clip": "text" } });
}, backgroundPosition: T("backgroundPosition", [["bg", ["background-position"]]], { type: ["lookup", ["position", { preferOnConflict: true }]] }), backgroundRepeat: ({ addUtilities: t2 }) => {
  t2({ ".bg-repeat": { "background-repeat": "repeat" }, ".bg-no-repeat": { "background-repeat": "no-repeat" }, ".bg-repeat-x": { "background-repeat": "repeat-x" }, ".bg-repeat-y": { "background-repeat": "repeat-y" }, ".bg-repeat-round": { "background-repeat": "round" }, ".bg-repeat-space": { "background-repeat": "space" } });
}, backgroundOrigin: ({ addUtilities: t2 }) => {
  t2({ ".bg-origin-border": { "background-origin": "border-box" }, ".bg-origin-padding": { "background-origin": "padding-box" }, ".bg-origin-content": { "background-origin": "content-box" } });
}, fill: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ fill: (r2) => ({ fill: M(r2) }) }, { values: Q(e2("fill")), type: ["color", "any"] });
}, stroke: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ stroke: (r2) => ({ stroke: M(r2) }) }, { values: Q(e2("stroke")), type: ["color", "url", "any"] });
}, strokeWidth: T("strokeWidth", [["stroke", ["stroke-width"]]], { type: ["length", "number", "percentage"] }), objectFit: ({ addUtilities: t2 }) => {
  t2({ ".object-contain": { "object-fit": "contain" }, ".object-cover": { "object-fit": "cover" }, ".object-fill": { "object-fit": "fill" }, ".object-none": { "object-fit": "none" }, ".object-scale-down": { "object-fit": "scale-down" } });
}, objectPosition: T("objectPosition", [["object", ["object-position"]]]), padding: T("padding", [["p", ["padding"]], [["px", ["padding-left", "padding-right"]], ["py", ["padding-top", "padding-bottom"]]], [["ps", ["padding-inline-start"]], ["pe", ["padding-inline-end"]], ["pt", ["padding-top"]], ["pr", ["padding-right"]], ["pb", ["padding-bottom"]], ["pl", ["padding-left"]]]]), textAlign: ({ addUtilities: t2 }) => {
  t2({ ".text-left": { "text-align": "left" }, ".text-center": { "text-align": "center" }, ".text-right": { "text-align": "right" }, ".text-justify": { "text-align": "justify" }, ".text-start": { "text-align": "start" }, ".text-end": { "text-align": "end" } });
}, textIndent: T("textIndent", [["indent", ["text-indent"]]], { supportsNegativeValues: true }), verticalAlign: ({ addUtilities: t2, matchUtilities: e2 }) => {
  t2({ ".align-baseline": { "vertical-align": "baseline" }, ".align-top": { "vertical-align": "top" }, ".align-middle": { "vertical-align": "middle" }, ".align-bottom": { "vertical-align": "bottom" }, ".align-text-top": { "vertical-align": "text-top" }, ".align-text-bottom": { "vertical-align": "text-bottom" }, ".align-sub": { "vertical-align": "sub" }, ".align-super": { "vertical-align": "super" } }), e2({ align: (r2) => ({ "vertical-align": r2 }) });
}, fontFamily: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ font: (r2) => {
    let [n2, i2 = {}] = Array.isArray(r2) && X(r2[1]) ? r2 : [r2], { fontFeatureSettings: a2, fontVariationSettings: s2 } = i2;
    return { "font-family": Array.isArray(n2) ? n2.join(", ") : n2, ...a2 === void 0 ? {} : { "font-feature-settings": a2 }, ...s2 === void 0 ? {} : { "font-variation-settings": s2 } };
  } }, { values: e2("fontFamily"), type: ["lookup", "generic-name", "family-name"] });
}, fontSize: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ text: (r2, { modifier: n2 }) => {
    let [i2, a2] = Array.isArray(r2) ? r2 : [r2];
    if (n2)
      return { "font-size": i2, "line-height": n2 };
    let { lineHeight: s2, letterSpacing: o2, fontWeight: l2 } = X(a2) ? a2 : { lineHeight: a2 };
    return { "font-size": i2, ...s2 === void 0 ? {} : { "line-height": s2 }, ...o2 === void 0 ? {} : { "letter-spacing": o2 }, ...l2 === void 0 ? {} : { "font-weight": l2 } };
  } }, { values: e2("fontSize"), modifiers: e2("lineHeight"), type: ["absolute-size", "relative-size", "length", "percentage"] });
}, fontWeight: T("fontWeight", [["font", ["fontWeight"]]], { type: ["lookup", "number", "any"] }), textTransform: ({ addUtilities: t2 }) => {
  t2({ ".uppercase": { "text-transform": "uppercase" }, ".lowercase": { "text-transform": "lowercase" }, ".capitalize": { "text-transform": "capitalize" }, ".normal-case": { "text-transform": "none" } });
}, fontStyle: ({ addUtilities: t2 }) => {
  t2({ ".italic": { "font-style": "italic" }, ".not-italic": { "font-style": "normal" } });
}, fontVariantNumeric: ({ addDefaults: t2, addUtilities: e2 }) => {
  let r2 = "var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)";
  t2("font-variant-numeric", { "--tw-ordinal": " ", "--tw-slashed-zero": " ", "--tw-numeric-figure": " ", "--tw-numeric-spacing": " ", "--tw-numeric-fraction": " " }), e2({ ".normal-nums": { "font-variant-numeric": "normal" }, ".ordinal": { "@defaults font-variant-numeric": {}, "--tw-ordinal": "ordinal", "font-variant-numeric": r2 }, ".slashed-zero": { "@defaults font-variant-numeric": {}, "--tw-slashed-zero": "slashed-zero", "font-variant-numeric": r2 }, ".lining-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-figure": "lining-nums", "font-variant-numeric": r2 }, ".oldstyle-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-figure": "oldstyle-nums", "font-variant-numeric": r2 }, ".proportional-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-spacing": "proportional-nums", "font-variant-numeric": r2 }, ".tabular-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-spacing": "tabular-nums", "font-variant-numeric": r2 }, ".diagonal-fractions": { "@defaults font-variant-numeric": {}, "--tw-numeric-fraction": "diagonal-fractions", "font-variant-numeric": r2 }, ".stacked-fractions": { "@defaults font-variant-numeric": {}, "--tw-numeric-fraction": "stacked-fractions", "font-variant-numeric": r2 } });
}, lineHeight: T("lineHeight", [["leading", ["lineHeight"]]]), letterSpacing: T("letterSpacing", [["tracking", ["letterSpacing"]]], { supportsNegativeValues: true }), textColor: ({ matchUtilities: t2, theme: e2, corePlugins: r2 }) => {
  t2({ text: (n2) => r2("textOpacity") ? Z({ color: n2, property: "color", variable: "--tw-text-opacity" }) : { color: M(n2) } }, { values: Q(e2("textColor")), type: ["color", "any"] });
}, textOpacity: T("textOpacity", [["text-opacity", ["--tw-text-opacity"]]]), textDecoration: ({ addUtilities: t2 }) => {
  t2({ ".underline": { "text-decoration-line": "underline" }, ".overline": { "text-decoration-line": "overline" }, ".line-through": { "text-decoration-line": "line-through" }, ".no-underline": { "text-decoration-line": "none" } });
}, textDecorationColor: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ decoration: (r2) => ({ "text-decoration-color": M(r2) }) }, { values: Q(e2("textDecorationColor")), type: ["color", "any"] });
}, textDecorationStyle: ({ addUtilities: t2 }) => {
  t2({ ".decoration-solid": { "text-decoration-style": "solid" }, ".decoration-double": { "text-decoration-style": "double" }, ".decoration-dotted": { "text-decoration-style": "dotted" }, ".decoration-dashed": { "text-decoration-style": "dashed" }, ".decoration-wavy": { "text-decoration-style": "wavy" } });
}, textDecorationThickness: T("textDecorationThickness", [["decoration", ["text-decoration-thickness"]]], { type: ["length", "percentage"] }), textUnderlineOffset: T("textUnderlineOffset", [["underline-offset", ["text-underline-offset"]]], { type: ["length", "percentage", "any"] }), fontSmoothing: ({ addUtilities: t2 }) => {
  t2({ ".antialiased": { "-webkit-font-smoothing": "antialiased", "-moz-osx-font-smoothing": "grayscale" }, ".subpixel-antialiased": { "-webkit-font-smoothing": "auto", "-moz-osx-font-smoothing": "auto" } });
}, placeholderColor: ({ matchUtilities: t2, theme: e2, corePlugins: r2 }) => {
  t2({ placeholder: (n2) => r2("placeholderOpacity") ? { "&::placeholder": Z({ color: n2, property: "color", variable: "--tw-placeholder-opacity" }) } : { "&::placeholder": { color: M(n2) } } }, { values: Q(e2("placeholderColor")), type: ["color", "any"] });
}, placeholderOpacity: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ "placeholder-opacity": (r2) => ({ ["&::placeholder"]: { "--tw-placeholder-opacity": r2 } }) }, { values: e2("placeholderOpacity") });
}, caretColor: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ caret: (r2) => ({ "caret-color": M(r2) }) }, { values: Q(e2("caretColor")), type: ["color", "any"] });
}, accentColor: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ accent: (r2) => ({ "accent-color": M(r2) }) }, { values: Q(e2("accentColor")), type: ["color", "any"] });
}, opacity: T("opacity", [["opacity", ["opacity"]]]), backgroundBlendMode: ({ addUtilities: t2 }) => {
  t2({ ".bg-blend-normal": { "background-blend-mode": "normal" }, ".bg-blend-multiply": { "background-blend-mode": "multiply" }, ".bg-blend-screen": { "background-blend-mode": "screen" }, ".bg-blend-overlay": { "background-blend-mode": "overlay" }, ".bg-blend-darken": { "background-blend-mode": "darken" }, ".bg-blend-lighten": { "background-blend-mode": "lighten" }, ".bg-blend-color-dodge": { "background-blend-mode": "color-dodge" }, ".bg-blend-color-burn": { "background-blend-mode": "color-burn" }, ".bg-blend-hard-light": { "background-blend-mode": "hard-light" }, ".bg-blend-soft-light": { "background-blend-mode": "soft-light" }, ".bg-blend-difference": { "background-blend-mode": "difference" }, ".bg-blend-exclusion": { "background-blend-mode": "exclusion" }, ".bg-blend-hue": { "background-blend-mode": "hue" }, ".bg-blend-saturation": { "background-blend-mode": "saturation" }, ".bg-blend-color": { "background-blend-mode": "color" }, ".bg-blend-luminosity": { "background-blend-mode": "luminosity" } });
}, mixBlendMode: ({ addUtilities: t2 }) => {
  t2({ ".mix-blend-normal": { "mix-blend-mode": "normal" }, ".mix-blend-multiply": { "mix-blend-mode": "multiply" }, ".mix-blend-screen": { "mix-blend-mode": "screen" }, ".mix-blend-overlay": { "mix-blend-mode": "overlay" }, ".mix-blend-darken": { "mix-blend-mode": "darken" }, ".mix-blend-lighten": { "mix-blend-mode": "lighten" }, ".mix-blend-color-dodge": { "mix-blend-mode": "color-dodge" }, ".mix-blend-color-burn": { "mix-blend-mode": "color-burn" }, ".mix-blend-hard-light": { "mix-blend-mode": "hard-light" }, ".mix-blend-soft-light": { "mix-blend-mode": "soft-light" }, ".mix-blend-difference": { "mix-blend-mode": "difference" }, ".mix-blend-exclusion": { "mix-blend-mode": "exclusion" }, ".mix-blend-hue": { "mix-blend-mode": "hue" }, ".mix-blend-saturation": { "mix-blend-mode": "saturation" }, ".mix-blend-color": { "mix-blend-mode": "color" }, ".mix-blend-luminosity": { "mix-blend-mode": "luminosity" }, ".mix-blend-plus-lighter": { "mix-blend-mode": "plus-lighter" } });
}, boxShadow: (() => {
  let t2 = Ce("boxShadow"), e2 = ["var(--tw-ring-offset-shadow, 0 0 #0000)", "var(--tw-ring-shadow, 0 0 #0000)", "var(--tw-shadow)"].join(", ");
  return function({ matchUtilities: r2, addDefaults: n2, theme: i2 }) {
    n2(" box-shadow", { "--tw-ring-offset-shadow": "0 0 #0000", "--tw-ring-shadow": "0 0 #0000", "--tw-shadow": "0 0 #0000", "--tw-shadow-colored": "0 0 #0000" }), r2({ shadow: (a2) => {
      a2 = t2(a2);
      let s2 = nn(a2);
      for (let o2 of s2)
        !o2.valid || (o2.color = "var(--tw-shadow-color)");
      return { "@defaults box-shadow": {}, "--tw-shadow": a2 === "none" ? "0 0 #0000" : a2, "--tw-shadow-colored": a2 === "none" ? "0 0 #0000" : Vu(s2), "box-shadow": e2 };
    } }, { values: i2("boxShadow"), type: ["shadow"] });
  };
})(), boxShadowColor: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ shadow: (r2) => ({ "--tw-shadow-color": M(r2), "--tw-shadow": "var(--tw-shadow-colored)" }) }, { values: Q(e2("boxShadowColor")), type: ["color", "any"] });
}, outlineStyle: ({ addUtilities: t2 }) => {
  t2({ ".outline-none": { outline: "2px solid transparent", "outline-offset": "2px" }, ".outline": { "outline-style": "solid" }, ".outline-dashed": { "outline-style": "dashed" }, ".outline-dotted": { "outline-style": "dotted" }, ".outline-double": { "outline-style": "double" } });
}, outlineWidth: T("outlineWidth", [["outline", ["outline-width"]]], { type: ["length", "number", "percentage"] }), outlineOffset: T("outlineOffset", [["outline-offset", ["outline-offset"]]], { type: ["length", "number", "percentage", "any"], supportsNegativeValues: true }), outlineColor: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ outline: (r2) => ({ "outline-color": M(r2) }) }, { values: Q(e2("outlineColor")), type: ["color", "any"] });
}, ringWidth: ({ matchUtilities: t2, addDefaults: e2, addUtilities: r2, theme: n2, config: i2 }) => {
  let a2 = (() => {
    var o2, l2;
    if (G(i2(), "respectDefaultRingColorOpacity"))
      return n2("ringColor.DEFAULT");
    let s2 = n2("ringOpacity.DEFAULT", "0.5");
    return (o2 = n2("ringColor")) != null && o2.DEFAULT ? we((l2 = n2("ringColor")) == null ? void 0 : l2.DEFAULT, s2, `rgb(147 197 253 / ${s2})`) : `rgb(147 197 253 / ${s2})`;
  })();
  e2("ring-width", { "--tw-ring-inset": " ", "--tw-ring-offset-width": n2("ringOffsetWidth.DEFAULT", "0px"), "--tw-ring-offset-color": n2("ringOffsetColor.DEFAULT", "#fff"), "--tw-ring-color": a2, "--tw-ring-offset-shadow": "0 0 #0000", "--tw-ring-shadow": "0 0 #0000", "--tw-shadow": "0 0 #0000", "--tw-shadow-colored": "0 0 #0000" }), t2({ ring: (s2) => ({ "@defaults ring-width": {}, "--tw-ring-offset-shadow": "var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)", "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(${s2} + var(--tw-ring-offset-width)) var(--tw-ring-color)`, "box-shadow": ["var(--tw-ring-offset-shadow)", "var(--tw-ring-shadow)", "var(--tw-shadow, 0 0 #0000)"].join(", ") }) }, { values: n2("ringWidth"), type: "length" }), r2({ ".ring-inset": { "@defaults ring-width": {}, "--tw-ring-inset": "inset" } });
}, ringColor: ({ matchUtilities: t2, theme: e2, corePlugins: r2 }) => {
  t2({ ring: (n2) => r2("ringOpacity") ? Z({ color: n2, property: "--tw-ring-color", variable: "--tw-ring-opacity" }) : { "--tw-ring-color": M(n2) } }, { values: Object.fromEntries(Object.entries(Q(e2("ringColor"))).filter(([n2]) => n2 !== "DEFAULT")), type: ["color", "any"] });
}, ringOpacity: (t2) => {
  let { config: e2 } = t2;
  return T("ringOpacity", [["ring-opacity", ["--tw-ring-opacity"]]], { filterDefault: !G(e2(), "respectDefaultRingColorOpacity") })(t2);
}, ringOffsetWidth: T("ringOffsetWidth", [["ring-offset", ["--tw-ring-offset-width"]]], { type: "length" }), ringOffsetColor: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ "ring-offset": (r2) => ({ "--tw-ring-offset-color": M(r2) }) }, { values: Q(e2("ringOffsetColor")), type: ["color", "any"] });
}, blur: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ blur: (r2) => ({ "--tw-blur": `blur(${r2})`, "@defaults filter": {}, filter: xe }) }, { values: e2("blur") });
}, brightness: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ brightness: (r2) => ({ "--tw-brightness": `brightness(${r2})`, "@defaults filter": {}, filter: xe }) }, { values: e2("brightness") });
}, contrast: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ contrast: (r2) => ({ "--tw-contrast": `contrast(${r2})`, "@defaults filter": {}, filter: xe }) }, { values: e2("contrast") });
}, dropShadow: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ "drop-shadow": (r2) => ({ "--tw-drop-shadow": Array.isArray(r2) ? r2.map((n2) => `drop-shadow(${n2})`).join(" ") : `drop-shadow(${r2})`, "@defaults filter": {}, filter: xe }) }, { values: e2("dropShadow") });
}, grayscale: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ grayscale: (r2) => ({ "--tw-grayscale": `grayscale(${r2})`, "@defaults filter": {}, filter: xe }) }, { values: e2("grayscale") });
}, hueRotate: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ "hue-rotate": (r2) => ({ "--tw-hue-rotate": `hue-rotate(${r2})`, "@defaults filter": {}, filter: xe }) }, { values: e2("hueRotate"), supportsNegativeValues: true });
}, invert: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ invert: (r2) => ({ "--tw-invert": `invert(${r2})`, "@defaults filter": {}, filter: xe }) }, { values: e2("invert") });
}, saturate: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ saturate: (r2) => ({ "--tw-saturate": `saturate(${r2})`, "@defaults filter": {}, filter: xe }) }, { values: e2("saturate") });
}, sepia: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ sepia: (r2) => ({ "--tw-sepia": `sepia(${r2})`, "@defaults filter": {}, filter: xe }) }, { values: e2("sepia") });
}, filter: ({ addDefaults: t2, addUtilities: e2 }) => {
  t2("filter", { "--tw-blur": " ", "--tw-brightness": " ", "--tw-contrast": " ", "--tw-grayscale": " ", "--tw-hue-rotate": " ", "--tw-invert": " ", "--tw-saturate": " ", "--tw-sepia": " ", "--tw-drop-shadow": " " }), e2({ ".filter": { "@defaults filter": {}, filter: xe }, ".filter-none": { filter: "none" } });
}, backdropBlur: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ "backdrop-blur": (r2) => ({ "--tw-backdrop-blur": `blur(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e2("backdropBlur") });
}, backdropBrightness: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ "backdrop-brightness": (r2) => ({ "--tw-backdrop-brightness": `brightness(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e2("backdropBrightness") });
}, backdropContrast: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ "backdrop-contrast": (r2) => ({ "--tw-backdrop-contrast": `contrast(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e2("backdropContrast") });
}, backdropGrayscale: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ "backdrop-grayscale": (r2) => ({ "--tw-backdrop-grayscale": `grayscale(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e2("backdropGrayscale") });
}, backdropHueRotate: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ "backdrop-hue-rotate": (r2) => ({ "--tw-backdrop-hue-rotate": `hue-rotate(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e2("backdropHueRotate"), supportsNegativeValues: true });
}, backdropInvert: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ "backdrop-invert": (r2) => ({ "--tw-backdrop-invert": `invert(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e2("backdropInvert") });
}, backdropOpacity: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ "backdrop-opacity": (r2) => ({ "--tw-backdrop-opacity": `opacity(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e2("backdropOpacity") });
}, backdropSaturate: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ "backdrop-saturate": (r2) => ({ "--tw-backdrop-saturate": `saturate(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e2("backdropSaturate") });
}, backdropSepia: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ "backdrop-sepia": (r2) => ({ "--tw-backdrop-sepia": `sepia(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e2("backdropSepia") });
}, backdropFilter: ({ addDefaults: t2, addUtilities: e2 }) => {
  t2("backdrop-filter", { "--tw-backdrop-blur": " ", "--tw-backdrop-brightness": " ", "--tw-backdrop-contrast": " ", "--tw-backdrop-grayscale": " ", "--tw-backdrop-hue-rotate": " ", "--tw-backdrop-invert": " ", "--tw-backdrop-opacity": " ", "--tw-backdrop-saturate": " ", "--tw-backdrop-sepia": " " }), e2({ ".backdrop-filter": { "@defaults backdrop-filter": {}, "backdrop-filter": Se }, ".backdrop-filter-none": { "backdrop-filter": "none" } });
}, transitionProperty: ({ matchUtilities: t2, theme: e2 }) => {
  let r2 = e2("transitionTimingFunction.DEFAULT"), n2 = e2("transitionDuration.DEFAULT");
  t2({ transition: (i2) => ({ "transition-property": i2, ...i2 === "none" ? {} : { "transition-timing-function": r2, "transition-duration": n2 } }) }, { values: e2("transitionProperty") });
}, transitionDelay: T("transitionDelay", [["delay", ["transitionDelay"]]]), transitionDuration: T("transitionDuration", [["duration", ["transitionDuration"]]], { filterDefault: true }), transitionTimingFunction: T("transitionTimingFunction", [["ease", ["transitionTimingFunction"]]], { filterDefault: true }), willChange: T("willChange", [["will-change", ["will-change"]]]), content: T("content", [["content", ["--tw-content", ["content", "var(--tw-content)"]]]]) };
function Le(t2) {
  if (Array.isArray(t2))
    return t2;
  let e2 = t2.split("[").length - 1, r2 = t2.split("]").length - 1;
  if (e2 !== r2)
    throw new Error(`Path is invalid. Has unbalanced brackets: ${t2}`);
  return t2.split(/\.(?![^\[]*\])|[\[\]]/g).filter(Boolean);
}
var xf = /* @__PURE__ */ new Map([["{", "}"], ["[", "]"], ["(", ")"]]);
var bf = new Map(Array.from(xf.entries()).map(([t2, e2]) => [e2, t2]));
var av = /* @__PURE__ */ new Set(['"', "'", "`"]);
function lt(t2) {
  let e2 = [], r2 = false;
  for (let n2 = 0; n2 < t2.length; n2++) {
    let i2 = t2[n2];
    if (i2 === ":" && !r2 && e2.length === 0)
      return false;
    if (av.has(i2) && t2[n2 - 1] !== "\\" && (r2 = !r2), !r2 && t2[n2 - 1] !== "\\") {
      if (xf.has(i2))
        e2.push(i2);
      else if (bf.has(i2)) {
        let a2 = bf.get(i2);
        if (e2.length <= 0 || e2.pop() !== a2)
          return false;
      }
    }
  }
  return !(e2.length > 0);
}
function pn(t2) {
  return (t2 > 0n) - (t2 < 0n);
}
function Sf(t2, e2) {
  let r2 = 0n, n2 = 0n;
  for (let [i2, a2] of e2)
    t2 & i2 && (r2 = r2 | i2, n2 = n2 | a2);
  return t2 & ~r2 | n2;
}
var dn = class {
  constructor() {
    this.offsets = { defaults: 0n, base: 0n, components: 0n, utilities: 0n, variants: 0n, user: 0n }, this.layerPositions = { defaults: 0n, base: 1n, components: 2n, utilities: 3n, user: 4n, variants: 5n }, this.reservedVariantBits = 0n, this.variantOffsets = /* @__PURE__ */ new Map();
  }
  create(e2) {
    return { layer: e2, parentLayer: e2, arbitrary: 0n, variants: 0n, parallelIndex: 0n, index: this.offsets[e2]++, options: [] };
  }
  arbitraryProperty() {
    return { ...this.create("utilities"), arbitrary: 1n };
  }
  forVariant(e2, r2 = 0) {
    let n2 = this.variantOffsets.get(e2);
    if (n2 === void 0)
      throw new Error(`Cannot find offset for unknown variant ${e2}`);
    return { ...this.create("variants"), variants: n2 << BigInt(r2) };
  }
  applyVariantOffset(e2, r2, n2) {
    return n2.variant = r2.variants, { ...e2, layer: "variants", parentLayer: e2.layer === "variants" ? e2.parentLayer : e2.layer, variants: e2.variants | r2.variants, options: n2.sort ? [].concat(n2, e2.options) : e2.options, parallelIndex: kf([e2.parallelIndex, r2.parallelIndex]) };
  }
  applyParallelOffset(e2, r2) {
    return { ...e2, parallelIndex: BigInt(r2) };
  }
  recordVariants(e2, r2) {
    for (let n2 of e2)
      this.recordVariant(n2, r2(n2));
  }
  recordVariant(e2, r2 = 1) {
    return this.variantOffsets.set(e2, 1n << this.reservedVariantBits), this.reservedVariantBits += BigInt(r2), { ...this.create("variants"), variants: this.variantOffsets.get(e2) };
  }
  compare(e2, r2) {
    var n2;
    if (e2.layer !== r2.layer)
      return this.layerPositions[e2.layer] - this.layerPositions[r2.layer];
    if (e2.parentLayer !== r2.parentLayer)
      return this.layerPositions[e2.parentLayer] - this.layerPositions[r2.parentLayer];
    for (let i2 of e2.options)
      for (let a2 of r2.options) {
        if (i2.id !== a2.id || !i2.sort || !a2.sort)
          continue;
        let s2 = (n2 = kf([i2.variant, a2.variant])) != null ? n2 : 0n, o2 = ~(s2 | s2 - 1n), l2 = e2.variants & o2, u2 = r2.variants & o2;
        if (l2 !== u2)
          continue;
        let f2 = i2.sort({ value: i2.value, modifier: i2.modifier }, { value: a2.value, modifier: a2.modifier });
        if (f2 !== 0)
          return f2;
      }
    return e2.variants !== r2.variants ? e2.variants - r2.variants : e2.parallelIndex !== r2.parallelIndex ? e2.parallelIndex - r2.parallelIndex : e2.arbitrary !== r2.arbitrary ? e2.arbitrary - r2.arbitrary : e2.index - r2.index;
  }
  recalculateVariantOffsets() {
    let e2 = Array.from(this.variantOffsets.entries()).filter(([i2]) => i2.startsWith("[")).sort(([i2], [a2]) => ov(i2, a2)), r2 = e2.map(([, i2]) => i2).sort((i2, a2) => pn(i2 - a2));
    return e2.map(([, i2], a2) => [i2, r2[a2]]).filter(([i2, a2]) => i2 !== a2);
  }
  remapArbitraryVariantOffsets(e2) {
    let r2 = this.recalculateVariantOffsets();
    return r2.length === 0 ? e2 : e2.map((n2) => {
      let [i2, a2] = n2;
      return i2 = { ...i2, variants: Sf(i2.variants, r2) }, [i2, a2];
    });
  }
  sort(e2) {
    return e2 = this.remapArbitraryVariantOffsets(e2), e2.sort(([r2], [n2]) => pn(this.compare(r2, n2)));
  }
};
function kf(t2) {
  let e2 = null;
  for (let r2 of t2)
    e2 = e2 != null ? e2 : r2, e2 = e2 > r2 ? e2 : r2;
  return e2;
}
function ov(t2, e2) {
  let r2 = t2.length, n2 = e2.length, i2 = r2 < n2 ? r2 : n2;
  for (let a2 = 0; a2 < i2; a2++) {
    let s2 = t2.charCodeAt(a2) - e2.charCodeAt(a2);
    if (s2 !== 0)
      return s2;
  }
  return r2 - n2;
}
var Us = { AddVariant: Symbol.for("ADD_VARIANT"), MatchVariant: Symbol.for("MATCH_VARIANT") };
var zs = { Base: 1 << 0, Dynamic: 1 << 1 };
function js(t2, e2) {
  let r2 = t2.tailwindConfig.prefix;
  return typeof r2 == "function" ? r2(e2) : r2 + e2;
}
function Of({ type: t2 = "any", ...e2 }) {
  let r2 = [].concat(t2);
  return { ...e2, types: r2.map((n2) => Array.isArray(n2) ? { type: n2[0], ...n2[1] } : { type: n2, preferOnConflict: false }) };
}
function lv(t2) {
  let e2 = [], r2 = "", n2 = 0;
  for (let i2 = 0; i2 < t2.length; i2++) {
    let a2 = t2[i2];
    if (a2 === "\\")
      r2 += "\\" + t2[++i2];
    else if (a2 === "{")
      ++n2, e2.push(r2.trim()), r2 = "";
    else if (a2 === "}") {
      if (--n2 < 0)
        throw new Error("Your { and } are unbalanced.");
      e2.push(r2.trim()), r2 = "";
    } else
      r2 += a2;
  }
  return r2.length > 0 && e2.push(r2.trim()), e2 = e2.filter((i2) => i2 !== ""), e2;
}
function uv(t2, e2, { before: r2 = [] } = {}) {
  if (r2 = [].concat(r2), r2.length <= 0) {
    t2.push(e2);
    return;
  }
  let n2 = t2.length - 1;
  for (let i2 of r2) {
    let a2 = t2.indexOf(i2);
    a2 !== -1 && (n2 = Math.min(n2, a2));
  }
  t2.splice(n2, 0, e2);
}
function Af(t2) {
  return Array.isArray(t2) ? t2.flatMap((e2) => !Array.isArray(e2) && !X(e2) ? e2 : nt(e2)) : Af([t2]);
}
function Ef(t2, e2) {
  return (0, Vs.default)((n2) => {
    let i2 = [];
    return e2 && e2(n2), n2.walkClasses((a2) => {
      i2.push(a2.value);
    }), i2;
  }).transformSync(t2);
}
function fv(t2, e2 = { containsNonOnDemandable: false }, r2 = 0) {
  let n2 = [];
  if (t2.type === "rule") {
    let i2 = function(a2) {
      a2.walkPseudos((s2) => {
        s2.value === ":not" && s2.remove();
      });
    };
    for (let a2 of t2.selectors) {
      let s2 = Ef(a2, i2);
      s2.length === 0 && (e2.containsNonOnDemandable = true);
      for (let o2 of s2)
        n2.push(o2);
    }
  } else
    t2.type === "atrule" && t2.walkRules((i2) => {
      for (let a2 of i2.selectors.flatMap((s2) => Ef(s2)))
        n2.push(a2);
    });
  return r2 === 0 ? [e2.containsNonOnDemandable || n2.length === 0, n2] : n2;
}
function hn(t2) {
  return Af(t2).flatMap((e2) => {
    let r2 = /* @__PURE__ */ new Map(), [n2, i2] = fv(e2);
    return n2 && i2.unshift(ke), i2.map((a2) => (r2.has(e2) || r2.set(e2, e2), [a2, r2.get(e2)]));
  });
}
function mn(t2) {
  return t2.startsWith("@") || t2.includes("&");
}
function lr(t2) {
  t2 = t2.replace(/\n+/g, "").replace(/\s{1,}/g, " ").trim();
  let e2 = lv(t2).map((r2) => {
    if (!r2.startsWith("@"))
      return ({ format: a2 }) => a2(r2);
    let [, n2, i2] = /@(.*?)( .+|[({].*)/g.exec(r2);
    return ({ wrap: a2 }) => a2(R.atRule({ name: n2, params: i2.trim() }));
  }).reverse();
  return (r2) => {
    for (let n2 of e2)
      n2(r2);
  };
}
function cv(t2, e2, { variantList: r2, variantMap: n2, offsets: i2, classList: a2 }) {
  function s2(c2, d2) {
    return c2 ? (0, Cf.default)(t2, c2, d2) : t2;
  }
  function o2(c2) {
    return it(t2.prefix, c2);
  }
  function l2(c2, d2) {
    return c2 === ke ? ke : d2.respectPrefix ? e2.tailwindConfig.prefix + c2 : c2;
  }
  function u2(c2, d2, h2 = {}) {
    let y3 = Le(c2), m = s2(["theme", ...y3], d2);
    return Ce(y3[0])(m, h2);
  }
  let f2 = 0, p2 = { postcss: R, prefix: o2, e: re, config: s2, theme: u2, corePlugins: (c2) => Array.isArray(t2.corePlugins) ? t2.corePlugins.includes(c2) : s2(["corePlugins", c2], true), variants: () => [], addBase(c2) {
    for (let [d2, h2] of hn(c2)) {
      let y3 = l2(d2, {}), m = i2.create("base");
      e2.candidateRuleMap.has(y3) || e2.candidateRuleMap.set(y3, []), e2.candidateRuleMap.get(y3).push([{ sort: m, layer: "base" }, h2]);
    }
  }, addDefaults(c2, d2) {
    let h2 = { [`@defaults ${c2}`]: d2 };
    for (let [y3, m] of hn(h2)) {
      let g2 = l2(y3, {});
      e2.candidateRuleMap.has(g2) || e2.candidateRuleMap.set(g2, []), e2.candidateRuleMap.get(g2).push([{ sort: i2.create("defaults"), layer: "defaults" }, m]);
    }
  }, addComponents(c2, d2) {
    d2 = Object.assign({}, { preserveSource: false, respectPrefix: true, respectImportant: false }, Array.isArray(d2) ? {} : d2);
    for (let [y3, m] of hn(c2)) {
      let g2 = l2(y3, d2);
      a2.add(g2), e2.candidateRuleMap.has(g2) || e2.candidateRuleMap.set(g2, []), e2.candidateRuleMap.get(g2).push([{ sort: i2.create("components"), layer: "components", options: d2 }, m]);
    }
  }, addUtilities(c2, d2) {
    d2 = Object.assign({}, { preserveSource: false, respectPrefix: true, respectImportant: true }, Array.isArray(d2) ? {} : d2);
    for (let [y3, m] of hn(c2)) {
      let g2 = l2(y3, d2);
      a2.add(g2), e2.candidateRuleMap.has(g2) || e2.candidateRuleMap.set(g2, []), e2.candidateRuleMap.get(g2).push([{ sort: i2.create("utilities"), layer: "utilities", options: d2 }, m]);
    }
  }, matchUtilities: function(c2, d2) {
    d2 = Of({ ...{ respectPrefix: true, respectImportant: true, modifiers: false }, ...d2 });
    let y3 = i2.create("utilities");
    for (let m in c2) {
      let b3 = function(O2, { isOnlyPlugin: x2 }) {
        let [A, E2, I2] = Ts(d2.types, O2, d2, t2);
        if (A === void 0)
          return [];
        if (!d2.types.some(({ type: B2 }) => B2 === E2))
          if (x2)
            L.warn([`Unnecessary typehint \`${E2}\` in \`${m}-${O2}\`.`, `You can safely update it to \`${m}-${O2.replace(E2 + ":", "")}\`.`]);
          else
            return [];
        if (!lt(A))
          return [];
        let F = { get modifier() {
          return d2.modifiers || L.warn(`modifier-used-without-options-for-${m}`, ["Your plugin must set `modifiers: true` in its options to support modifiers."]), I2;
        } }, Y2 = G(t2, "generalizedModifiers");
        return [].concat(Y2 ? w2(A, F) : w2(A)).filter(Boolean).map((B2) => ({ [ln(m, O2)]: B2 }));
      }, g2 = l2(m, d2), w2 = c2[m];
      a2.add([g2, d2]);
      let v2 = [{ sort: y3, layer: "utilities", options: d2 }, b3];
      e2.candidateRuleMap.has(g2) || e2.candidateRuleMap.set(g2, []), e2.candidateRuleMap.get(g2).push(v2);
    }
  }, matchComponents: function(c2, d2) {
    d2 = Of({ ...{ respectPrefix: true, respectImportant: false, modifiers: false }, ...d2 });
    let y3 = i2.create("components");
    for (let m in c2) {
      let b3 = function(O2, { isOnlyPlugin: x2 }) {
        let [A, E2, I2] = Ts(d2.types, O2, d2, t2);
        if (A === void 0)
          return [];
        if (!d2.types.some(({ type: B2 }) => B2 === E2))
          if (x2)
            L.warn([`Unnecessary typehint \`${E2}\` in \`${m}-${O2}\`.`, `You can safely update it to \`${m}-${O2.replace(E2 + ":", "")}\`.`]);
          else
            return [];
        if (!lt(A))
          return [];
        let F = { get modifier() {
          return d2.modifiers || L.warn(`modifier-used-without-options-for-${m}`, ["Your plugin must set `modifiers: true` in its options to support modifiers."]), I2;
        } }, Y2 = G(t2, "generalizedModifiers");
        return [].concat(Y2 ? w2(A, F) : w2(A)).filter(Boolean).map((B2) => ({ [ln(m, O2)]: B2 }));
      }, g2 = l2(m, d2), w2 = c2[m];
      a2.add([g2, d2]);
      let v2 = [{ sort: y3, layer: "components", options: d2 }, b3];
      e2.candidateRuleMap.has(g2) || e2.candidateRuleMap.set(g2, []), e2.candidateRuleMap.get(g2).push(v2);
    }
  }, addVariant(c2, d2, h2 = {}) {
    d2 = [].concat(d2).map((y3) => {
      if (typeof y3 != "string")
        return (m = {}) => {
          let { args: g2, modifySelectors: w2, container: b3, separator: v2, wrap: O2, format: x2 } = m, A = y3(Object.assign({ modifySelectors: w2, container: b3, separator: v2 }, h2.type === Us.MatchVariant && { args: g2, wrap: O2, format: x2 }));
          if (typeof A == "string" && !mn(A))
            throw new Error(`Your custom variant \`${c2}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
          return Array.isArray(A) ? A.filter((E2) => typeof E2 == "string").map((E2) => lr(E2)) : A && typeof A == "string" && lr(A)(m);
        };
      if (!mn(y3))
        throw new Error(`Your custom variant \`${c2}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
      return lr(y3);
    }), uv(r2, c2, h2), n2.set(c2, d2), e2.variantOptions.set(c2, h2);
  }, matchVariant(c2, d2, h2) {
    var b3, v2, O2;
    let y3 = (b3 = h2 == null ? void 0 : h2.id) != null ? b3 : ++f2, m = c2 === "@", g2 = G(t2, "generalizedModifiers");
    for (let [x2, A] of Object.entries((v2 = h2 == null ? void 0 : h2.values) != null ? v2 : {}))
      x2 !== "DEFAULT" && p2.addVariant(m ? `${c2}${x2}` : `${c2}-${x2}`, ({ args: E2, container: I2 }) => d2(A, g2 ? { modifier: E2 == null ? void 0 : E2.modifier, container: I2 } : { container: I2 }), { ...h2, value: A, id: y3, type: Us.MatchVariant, variantInfo: zs.Base });
    let w2 = "DEFAULT" in ((O2 = h2 == null ? void 0 : h2.values) != null ? O2 : {});
    p2.addVariant(c2, ({ args: x2, container: A }) => {
      var E2;
      return (x2 == null ? void 0 : x2.value) === mt && !w2 ? null : d2((x2 == null ? void 0 : x2.value) === mt ? h2.values.DEFAULT : (E2 = x2 == null ? void 0 : x2.value) != null ? E2 : typeof x2 == "string" ? x2 : "", g2 ? { modifier: x2 == null ? void 0 : x2.modifier, container: A } : { container: A });
    }, { ...h2, id: y3, type: Us.MatchVariant, variantInfo: zs.Dynamic });
  } };
  return p2;
}
function _f(t2) {
  t2.walkAtRules((e2) => {
    ["responsive", "variants"].includes(e2.name) && (_f(e2), e2.before(e2.nodes), e2.remove());
  });
}
function pv(t2) {
  let e2 = [];
  return t2.each((r2) => {
    r2.type === "atrule" && ["responsive", "variants"].includes(r2.name) && (r2.name = "layer", r2.params = "utilities");
  }), t2.walkAtRules("layer", (r2) => {
    if (_f(r2), r2.params === "base") {
      for (let n2 of r2.nodes)
        e2.push(function({ addBase: i2 }) {
          i2(n2, { respectPrefix: false });
        });
      r2.remove();
    } else if (r2.params === "components") {
      for (let n2 of r2.nodes)
        e2.push(function({ addComponents: i2 }) {
          i2(n2, { respectPrefix: false, preserveSource: true });
        });
      r2.remove();
    } else if (r2.params === "utilities") {
      for (let n2 of r2.nodes)
        e2.push(function({ addUtilities: i2 }) {
          i2(n2, { respectPrefix: false, preserveSource: true });
        });
      r2.remove();
    }
  }), e2;
}
function dv(t2, e2) {
  let r2 = Object.entries({ ...ne, ...wf }).map(([o2, l2]) => t2.tailwindConfig.corePlugins.includes(o2) ? l2 : null).filter(Boolean), n2 = t2.tailwindConfig.plugins.map((o2) => (o2.__isOptionsFunction && (o2 = o2()), typeof o2 == "function" ? o2 : o2.handler)), i2 = pv(e2), a2 = [ne.pseudoElementVariants, ne.pseudoClassVariants, ne.ariaVariants, ne.dataVariants], s2 = [ne.supportsVariants, ne.directionVariants, ne.reducedMotionVariants, ne.prefersContrastVariants, ne.darkVariants, ne.printVariant, ne.screenVariants, ne.orientationVariants];
  return [...r2, ...a2, ...n2, ...s2, ...i2];
}
function hv(t2, e2) {
  var f2, p2, c2;
  let r2 = [], n2 = /* @__PURE__ */ new Map();
  e2.variantMap = n2;
  let i2 = new dn();
  e2.offsets = i2;
  let a2 = /* @__PURE__ */ new Set(), s2 = cv(e2.tailwindConfig, e2, { variantList: r2, variantMap: n2, offsets: i2, classList: a2 });
  for (let d2 of t2)
    if (Array.isArray(d2))
      for (let h2 of d2)
        h2(s2);
    else
      d2 == null || d2(s2);
  i2.recordVariants(r2, (d2) => n2.get(d2).length);
  for (let [d2, h2] of n2.entries())
    e2.variantMap.set(d2, h2.map((y3, m) => [i2.forVariant(d2, m), y3]));
  let o2 = ((f2 = e2.tailwindConfig.safelist) != null ? f2 : []).filter(Boolean);
  if (o2.length > 0) {
    let d2 = [];
    for (let h2 of o2) {
      if (typeof h2 == "string") {
        e2.changedContent.push({ content: h2, extension: "html" });
        continue;
      }
      if (h2 instanceof RegExp) {
        L.warn("root-regex", ["Regular expressions in `safelist` work differently in Tailwind CSS v3.0.", "Update your `safelist` configuration to eliminate this warning.", "https://tailwindcss.com/docs/content-configuration#safelisting-classes"]);
        continue;
      }
      d2.push(h2);
    }
    if (d2.length > 0) {
      let h2 = /* @__PURE__ */ new Map(), y3 = e2.tailwindConfig.prefix.length, m = d2.some((g2) => g2.pattern.source.includes("!"));
      for (let g2 of a2) {
        let w2 = Array.isArray(g2) ? (() => {
          var A;
          let [b3, v2] = g2, x2 = Object.keys((A = v2 == null ? void 0 : v2.values) != null ? A : {}).map((E2) => or(b3, E2));
          return v2 != null && v2.supportsNegativeValues && (x2 = [...x2, ...x2.map((E2) => "-" + E2)], x2 = [...x2, ...x2.map((E2) => E2.slice(0, y3) + "-" + E2.slice(y3))]), v2.types.some(({ type: E2 }) => E2 === "color") && (x2 = [...x2, ...x2.flatMap((E2) => Object.keys(e2.tailwindConfig.theme.opacity).map((I2) => `${E2}/${I2}`))]), m && (v2 == null ? void 0 : v2.respectImportant) && (x2 = [...x2, ...x2.map((E2) => "!" + E2)]), x2;
        })() : [g2];
        for (let b3 of w2)
          for (let { pattern: v2, variants: O2 = [] } of d2)
            if (v2.lastIndex = 0, h2.has(v2) || h2.set(v2, 0), !!v2.test(b3)) {
              h2.set(v2, h2.get(v2) + 1), e2.changedContent.push({ content: b3, extension: "html" });
              for (let x2 of O2)
                e2.changedContent.push({ content: x2 + e2.tailwindConfig.separator + b3, extension: "html" });
            }
      }
      for (let [g2, w2] of h2.entries())
        w2 === 0 && L.warn([`The safelist pattern \`${g2}\` doesn't match any Tailwind CSS classes.`, "Fix this pattern or remove it from your `safelist` configuration.", "https://tailwindcss.com/docs/content-configuration#safelisting-classes"]);
    }
  }
  let l2 = (c2 = [].concat((p2 = e2.tailwindConfig.darkMode) != null ? p2 : "media")[1]) != null ? c2 : "dark", u2 = [js(e2, l2), js(e2, "group"), js(e2, "peer")];
  e2.getClassOrder = function(h2) {
    let y3 = [...h2].sort((b3, v2) => b3 === v2 ? 0 : b3 < v2 ? -1 : 1), m = new Map(y3.map((b3) => [b3, null])), g2 = gn(new Set(y3), e2);
    g2 = e2.offsets.sort(g2);
    let w2 = BigInt(u2.length);
    for (let [, b3] of g2)
      m.set(b3.raws.tailwind.candidate, w2++);
    return h2.map((b3) => {
      var x2;
      let v2 = (x2 = m.get(b3)) != null ? x2 : null, O2 = u2.indexOf(b3);
      return v2 === null && O2 !== -1 && (v2 = BigInt(O2)), [b3, v2];
    });
  }, e2.getClassList = function(h2 = {}) {
    var m, g2, w2, b3;
    let y3 = [];
    for (let v2 of a2)
      if (Array.isArray(v2)) {
        let [O2, x2] = v2, A = [], E2 = Object.keys((m = x2 == null ? void 0 : x2.modifiers) != null ? m : {});
        (g2 = x2 == null ? void 0 : x2.types) != null && g2.some(({ type: Y2 }) => Y2 === "color") && E2.push(...Object.keys((w2 = e2.tailwindConfig.theme.opacity) != null ? w2 : {}));
        let I2 = { modifiers: E2 }, F = h2.includeMetadata && E2.length > 0;
        for (let [Y2, K2] of Object.entries((b3 = x2 == null ? void 0 : x2.values) != null ? b3 : {})) {
          if (K2 == null)
            continue;
          let B2 = or(O2, Y2);
          if (y3.push(F ? [B2, I2] : B2), (x2 == null ? void 0 : x2.supportsNegativeValues) && Re(K2)) {
            let qe2 = or(O2, `-${Y2}`);
            A.push(F ? [qe2, I2] : qe2);
          }
        }
        y3.push(...A);
      } else
        y3.push(v2);
    return y3;
  }, e2.getVariants = function() {
    var y3;
    let h2 = [];
    for (let [m, g2] of e2.variantOptions.entries())
      g2.variantInfo !== zs.Base && h2.push({ name: m, isArbitrary: g2.type === Symbol.for("MATCH_VARIANT"), values: Object.keys((y3 = g2.values) != null ? y3 : {}), hasDash: m !== "@", selectors({ modifier: w2, value: b3 } = {}) {
        var Ca, Aa, _a, Ta;
        let v2 = "__TAILWIND_PLACEHOLDER__", O2 = R.rule({ selector: `.${v2}` }), x2 = R.root({ nodes: [O2.clone()] }), A = x2.toString(), E2 = ((Ca = e2.variantMap.get(m)) != null ? Ca : []).flatMap(([ie2, se2]) => se2), I2 = [];
        for (let ie2 of E2) {
          let se2 = [], hr2 = { args: { modifier: w2, value: (_a = (Aa = g2.values) == null ? void 0 : Aa[b3]) != null ? _a : b3 }, separator: e2.tailwindConfig.separator, modifySelectors(pe2) {
            return x2.each((qn2) => {
              qn2.type === "rule" && (qn2.selectors = qn2.selectors.map((Pa) => pe2({ get className() {
                return Ws(Pa);
              }, selector: Pa })));
            }), x2;
          }, format(pe2) {
            se2.push(pe2);
          }, wrap(pe2) {
            se2.push(`@${pe2.name} ${pe2.params} { & }`);
          }, container: x2 }, mr2 = ie2(hr2);
          if (se2.length > 0 && I2.push(se2), Array.isArray(mr2))
            for (let pe2 of mr2)
              se2 = [], pe2(hr2), I2.push(se2);
        }
        let F = [], Y2 = x2.toString();
        A !== Y2 && (x2.walkRules((ie2) => {
          let se2 = ie2.selector, hr2 = (0, Vs.default)((mr2) => {
            mr2.walkClasses((pe2) => {
              pe2.value = `${m}${e2.tailwindConfig.separator}${pe2.value}`;
            });
          }).processSync(se2);
          F.push(se2.replace(hr2, "&").replace(v2, "&"));
        }), x2.walkAtRules((ie2) => {
          F.push(`@${ie2.name} (${ie2.params}) { & }`);
        }));
        let K2 = !(b3 in ((Ta = g2.values) != null ? Ta : {}));
        I2 = I2.map((ie2) => ie2.map((se2) => ({ format: se2, isArbitraryVariant: K2 }))), F = F.map((ie2) => ({ format: ie2, isArbitraryVariant: K2 }));
        let B2 = { candidate: v2, context: e2 }, qe2 = I2.map((ie2) => on(`.${v2}`, ot(ie2, B2), B2).replace(`.${v2}`, "&").replace("{ & }", "").trim());
        return F.length > 0 && qe2.push(ot(F, B2).toString().replace(`.${v2}`, "&")), qe2;
      } });
    return h2;
  };
}
function Tf(t2, e2) {
  !t2.classCache.has(e2) || (t2.notClassCache.add(e2), t2.classCache.delete(e2), t2.applyClassCache.delete(e2), t2.candidateRuleMap.delete(e2), t2.candidateRuleCache.delete(e2), t2.stylesheetCache = null);
}
function mv(t2, e2) {
  let r2 = e2.raws.tailwind.candidate;
  if (!!r2) {
    for (let n2 of t2.ruleCache)
      n2[1].raws.tailwind.candidate === r2 && t2.ruleCache.delete(n2);
    Tf(t2, r2);
  }
}
function Pf(t2, e2 = [], r2 = R.root()) {
  var a2;
  let n2 = { disposables: [], ruleCache: /* @__PURE__ */ new Set(), candidateRuleCache: /* @__PURE__ */ new Map(), classCache: /* @__PURE__ */ new Map(), applyClassCache: /* @__PURE__ */ new Map(), notClassCache: new Set((a2 = t2.blocklist) != null ? a2 : []), postCssNodeCache: /* @__PURE__ */ new Map(), candidateRuleMap: /* @__PURE__ */ new Map(), tailwindConfig: t2, changedContent: e2, variantMap: /* @__PURE__ */ new Map(), stylesheetCache: null, variantOptions: /* @__PURE__ */ new Map(), markInvalidUtilityCandidate: (s2) => Tf(n2, s2), markInvalidUtilityNode: (s2) => mv(n2, s2) }, i2 = dv(n2, r2);
  return hv(i2, n2), n2;
}
var Bs = H(ve());
function yn(t2, e2) {
  let r2 = (0, Bs.default)().astSync(t2);
  return r2.each((n2) => {
    n2.nodes[0].type === "pseudo" && n2.nodes[0].value === ":is" && n2.nodes.every((a2) => a2.type !== "combinator") || (n2.nodes = [Bs.default.pseudo({ value: ":is", nodes: [n2.clone()] })]), at(n2);
  }), `${e2} ${r2.toString()}`;
}
var gv = (0, wn.default)((t2) => t2.first.filter(({ type: e2 }) => e2 === "class").pop().value);
function Ws(t2) {
  return gv.transformSync(t2);
}
function* yv(t2) {
  let e2 = 1 / 0;
  for (; e2 >= 0; ) {
    let r2, n2 = false;
    if (e2 === 1 / 0 && t2.endsWith("]")) {
      let s2 = t2.indexOf("[");
      t2[s2 - 1] === "-" ? r2 = s2 - 1 : t2[s2 - 1] === "/" ? (r2 = s2 - 1, n2 = true) : r2 = -1;
    } else
      e2 === 1 / 0 && t2.includes("/") ? (r2 = t2.lastIndexOf("/"), n2 = true) : r2 = t2.lastIndexOf("-", e2);
    if (r2 < 0)
      break;
    let i2 = t2.slice(0, r2), a2 = t2.slice(n2 ? r2 : r2 + 1);
    e2 = r2 - 1, !(i2 === "" || a2 === "/") && (yield [i2, a2]);
  }
}
function vv(t2, e2) {
  if (t2.length === 0 || e2.tailwindConfig.prefix === "")
    return t2;
  for (let r2 of t2) {
    let [n2] = r2;
    if (n2.options.respectPrefix) {
      let i2 = R.root({ nodes: [r2[1].clone()] }), a2 = r2[1].raws.tailwind.classCandidate;
      i2.walkRules((s2) => {
        let o2 = a2.startsWith("-");
        s2.selector = it(e2.tailwindConfig.prefix, s2.selector, o2);
      }), r2[1] = i2.nodes[0];
    }
  }
  return t2;
}
function wv(t2, e2) {
  if (t2.length === 0)
    return t2;
  let r2 = [];
  for (let [n2, i2] of t2) {
    let a2 = R.root({ nodes: [i2.clone()] });
    a2.walkRules((s2) => {
      let o2 = (0, wn.default)().astSync(s2.selector);
      o2.each((l2) => Ms(l2, e2)), af(o2, (l2) => l2 === e2 ? `!${l2}` : l2), s2.selector = o2.toString(), s2.walkDecls((l2) => l2.important = true);
    }), r2.push([{ ...n2, important: true }, a2.nodes[0]]);
  }
  return r2;
}
function bv(t2, e2, r2) {
  var i2;
  if (e2.length === 0)
    return e2;
  let n2 = { modifier: null, value: mt };
  {
    let [a2, ...s2] = ee(t2, "/");
    if (s2.length > 1 && (a2 = a2 + "/" + s2.slice(0, -1).join("/"), s2 = s2.slice(-1)), s2.length && !r2.variantMap.has(t2) && (t2 = a2, n2.modifier = s2[0], !G(r2.tailwindConfig, "generalizedModifiers")))
      return [];
  }
  if (t2.endsWith("]") && !t2.startsWith("[")) {
    let a2 = /(.)(-?)\[(.*)\]/g.exec(t2);
    if (a2) {
      let [, s2, o2, l2] = a2;
      if (s2 === "@" && o2 === "-")
        return [];
      if (s2 !== "@" && o2 === "")
        return [];
      t2 = t2.replace(`${o2}[${l2}]`, ""), n2.value = l2;
    }
  }
  if (Ys(t2) && !r2.variantMap.has(t2)) {
    let a2 = r2.offsets.recordVariant(t2), s2 = z(t2.slice(1, -1)), o2 = ee(s2, ",");
    if (o2.length > 1)
      return [];
    if (!o2.every(mn))
      return [];
    let l2 = o2.map((u2, f2) => [r2.offsets.applyParallelOffset(a2, f2), lr(u2.trim())]);
    r2.variantMap.set(t2, l2);
  }
  if (r2.variantMap.has(t2)) {
    let a2 = Ys(t2), s2 = r2.variantMap.get(t2).slice(), o2 = [];
    for (let [l2, u2] of e2) {
      if (l2.layer === "user")
        continue;
      let f2 = R.root({ nodes: [u2.clone()] });
      for (let [p2, c2, d2] of s2) {
        let m = function() {
          h2.raws.neededBackup || (h2.raws.neededBackup = true, h2.walkRules((v2) => v2.raws.originalSelector = v2.selector));
        }, g2 = function(v2) {
          return m(), h2.each((O2) => {
            O2.type === "rule" && (O2.selectors = O2.selectors.map((x2) => v2({ get className() {
              return Ws(x2);
            }, selector: x2 })));
          }), h2;
        }, h2 = (d2 != null ? d2 : f2).clone(), y3 = [], w2 = c2({ get container() {
          return m(), h2;
        }, separator: r2.tailwindConfig.separator, modifySelectors: g2, wrap(v2) {
          let O2 = h2.nodes;
          h2.removeAll(), v2.append(O2), h2.append(v2);
        }, format(v2) {
          y3.push({ format: v2, isArbitraryVariant: a2 });
        }, args: n2 });
        if (Array.isArray(w2)) {
          for (let [v2, O2] of w2.entries())
            s2.push([r2.offsets.applyParallelOffset(p2, v2), O2, h2.clone()]);
          continue;
        }
        if (typeof w2 == "string" && y3.push({ format: w2, isArbitraryVariant: a2 }), w2 === null)
          continue;
        h2.raws.neededBackup && (delete h2.raws.neededBackup, h2.walkRules((v2) => {
          let O2 = v2.raws.originalSelector;
          if (!O2 || (delete v2.raws.originalSelector, O2 === v2.selector))
            return;
          let x2 = v2.selector, A = (0, wn.default)((E2) => {
            E2.walkClasses((I2) => {
              I2.value = `${t2}${r2.tailwindConfig.separator}${I2.value}`;
            });
          }).processSync(O2);
          y3.push({ format: x2.replace(A, "&"), isArbitraryVariant: a2 }), v2.selector = O2;
        })), h2.nodes[0].raws.tailwind = { ...h2.nodes[0].raws.tailwind, parentLayer: l2.layer };
        let b3 = [{ ...l2, sort: r2.offsets.applyVariantOffset(l2.sort, p2, Object.assign(n2, r2.variantOptions.get(t2))), collectedFormats: ((i2 = l2.collectedFormats) != null ? i2 : []).concat(y3) }, h2.nodes[0]];
        o2.push(b3);
      }
    }
    return o2;
  }
  return [];
}
function Gs(t2, e2, r2 = {}) {
  return !X(t2) && !Array.isArray(t2) ? [[t2], r2] : Array.isArray(t2) ? Gs(t2[0], e2, t2[1]) : (e2.has(t2) || e2.set(t2, nt(t2)), [e2.get(t2), r2]);
}
var xv = /^[a-z_-]/;
function Sv(t2) {
  return xv.test(t2);
}
function kv(t2) {
  if (!t2.includes("://"))
    return false;
  try {
    let e2 = new URL(t2);
    return e2.scheme !== "" && e2.host !== "";
  } catch {
    return false;
  }
}
function If(t2) {
  let e2 = true;
  return t2.walkDecls((r2) => {
    if (!Rf(r2.prop, r2.value))
      return e2 = false, false;
  }), e2;
}
function Rf(t2, e2) {
  if (kv(`${t2}:${e2}`))
    return false;
  try {
    return R.parse(`a{${t2}:${e2}}`).toResult(), true;
  } catch {
    return false;
  }
}
function Ov(t2, e2) {
  var s2;
  let [, r2, n2] = (s2 = t2.match(/^\[([a-zA-Z0-9-_]+):(\S+)\]$/)) != null ? s2 : [];
  if (n2 === void 0 || !Sv(r2) || !lt(n2))
    return null;
  let i2 = z(n2);
  return Rf(r2, i2) ? [[{ sort: e2.offsets.arbitraryProperty(), layer: "utilities" }, () => ({ [Fs(t2)]: { [r2]: i2 } })]] : null;
}
function* Ev(t2, e2) {
  e2.candidateRuleMap.has(t2) && (yield [e2.candidateRuleMap.get(t2), "DEFAULT"]), yield* function* (o2) {
    o2 !== null && (yield [o2, "DEFAULT"]);
  }(Ov(t2, e2));
  let r2 = t2, n2 = false, i2 = e2.tailwindConfig.prefix, a2 = i2.length, s2 = r2.startsWith(i2) || r2.startsWith(`-${i2}`);
  r2[a2] === "-" && s2 && (n2 = true, r2 = i2 + r2.slice(a2 + 1)), n2 && e2.candidateRuleMap.has(r2) && (yield [e2.candidateRuleMap.get(r2), "-DEFAULT"]);
  for (let [o2, l2] of yv(r2))
    e2.candidateRuleMap.has(o2) && (yield [e2.candidateRuleMap.get(o2), n2 ? `-${l2}` : l2]);
}
function Cv(t2, e2) {
  return t2 === ke ? [ke] : ee(t2, e2);
}
function* Av(t2, e2) {
  var r2, n2;
  for (let i2 of t2)
    i2[1].raws.tailwind = { ...i2[1].raws.tailwind, classCandidate: e2, preserveSource: (n2 = (r2 = i2[0].options) == null ? void 0 : r2.preserveSource) != null ? n2 : false }, yield i2;
}
function* bn(t2, e2, r2 = t2) {
  var o2, l2, u2, f2;
  let n2 = e2.tailwindConfig.separator, [i2, ...a2] = Cv(t2, n2).reverse(), s2 = false;
  if (i2.startsWith("!") && (s2 = true, i2 = i2.slice(1)), G(e2.tailwindConfig, "variantGrouping") && i2.startsWith("(") && i2.endsWith(")")) {
    let p2 = a2.slice().reverse().join(n2);
    for (let c2 of ee(i2.slice(1, -1), ","))
      yield* bn(p2 + n2 + c2, e2, r2);
  }
  for (let p2 of Ev(i2, e2)) {
    let c2 = [], d2 = /* @__PURE__ */ new Map(), [h2, y3] = p2, m = h2.length === 1;
    for (let [g2, w2] of h2) {
      let b3 = [];
      if (typeof w2 == "function")
        for (let v2 of [].concat(w2(y3, { isOnlyPlugin: m }))) {
          let [O2, x2] = Gs(v2, e2.postCssNodeCache);
          for (let A of O2)
            b3.push([{ ...g2, options: { ...g2.options, ...x2 } }, A]);
        }
      else if (y3 === "DEFAULT" || y3 === "-DEFAULT") {
        let v2 = w2, [O2, x2] = Gs(v2, e2.postCssNodeCache);
        for (let A of O2)
          b3.push([{ ...g2, options: { ...g2.options, ...x2 } }, A]);
      }
      if (b3.length > 0) {
        let v2 = Array.from(Ps((l2 = (o2 = g2.options) == null ? void 0 : o2.types) != null ? l2 : [], y3, (u2 = g2.options) != null ? u2 : {}, e2.tailwindConfig)).map(([O2, x2]) => x2);
        v2.length > 0 && d2.set(b3, v2), c2.push(b3);
      }
    }
    if (Ys(y3)) {
      if (c2.length > 1) {
        let b3 = function(O2) {
          return O2.length === 1 ? O2[0] : O2.find((x2) => {
            let A = d2.get(x2);
            return x2.some(([{ options: E2 }, I2]) => If(I2) ? E2.types.some(({ type: F, preferOnConflict: Y2 }) => A.includes(F) && Y2) : false);
          });
        }, [g2, w2] = c2.reduce((O2, x2) => (x2.some(([{ options: E2 }]) => E2.types.some(({ type: I2 }) => I2 === "any")) ? O2[0].push(x2) : O2[1].push(x2), O2), [[], []]), v2 = (f2 = b3(w2)) != null ? f2 : b3(g2);
        if (v2)
          c2 = [v2];
        else {
          let O2 = c2.map((A) => {
            var E2;
            return /* @__PURE__ */ new Set([...(E2 = d2.get(A)) != null ? E2 : []]);
          });
          for (let A of O2)
            for (let E2 of A) {
              let I2 = false;
              for (let F of O2)
                A !== F && F.has(E2) && (F.delete(E2), I2 = true);
              I2 && A.delete(E2);
            }
          let x2 = [];
          for (let [A, E2] of O2.entries())
            for (let I2 of E2) {
              let F = c2[A].map(([, Y2]) => Y2).flat().map((Y2) => Y2.toString().split(`
`).slice(1, -1).map((K2) => K2.trim()).map((K2) => `      ${K2}`).join(`
`)).join(`

`);
              x2.push(`  Use \`${t2.replace("[", `[${I2}:`)}\` for \`${F.trim()}\``);
              break;
            }
          L.warn([`The class \`${t2}\` is ambiguous and matches multiple utilities.`, ...x2, `If this is content and not a class, replace it with \`${t2.replace("[", "&lsqb;").replace("]", "&rsqb;")}\` to silence this warning.`]);
          continue;
        }
      }
      c2 = c2.map((g2) => g2.filter((w2) => If(w2[1])));
    }
    c2 = c2.flat(), c2 = Array.from(Av(c2, i2)), c2 = vv(c2, e2), s2 && (c2 = wv(c2, i2));
    for (let g2 of a2)
      c2 = bv(g2, c2, e2);
    for (let g2 of c2)
      g2[1].raws.tailwind = { ...g2[1].raws.tailwind, candidate: t2 }, g2 = _v(g2, { context: e2, candidate: t2, original: r2 }), g2 !== null && (yield g2);
  }
}
function _v(t2, { context: e2, candidate: r2, original: n2 }) {
  if (!t2[0].collectedFormats)
    return t2;
  let i2 = true, a2;
  try {
    a2 = ot(t2[0].collectedFormats, { context: e2, candidate: r2 });
  } catch {
    return null;
  }
  let s2 = R.root({ nodes: [t2[1].clone()] });
  return s2.walkRules((o2) => {
    if (!vn(o2))
      try {
        o2.selector = on(o2.selector, a2, { candidate: n2, context: e2 });
      } catch {
        return i2 = false, false;
      }
  }), i2 ? (t2[1] = s2.nodes[0], t2) : null;
}
function vn(t2) {
  return t2.parent && t2.parent.type === "atrule" && t2.parent.name === "keyframes";
}
function Tv(t2) {
  if (t2 === true)
    return (e2) => {
      vn(e2) || e2.walkDecls((r2) => {
        r2.parent.type === "rule" && !vn(r2.parent) && (r2.important = true);
      });
    };
  if (typeof t2 == "string")
    return (e2) => {
      vn(e2) || (e2.selectors = e2.selectors.map((r2) => yn(r2, t2)));
    };
}
function gn(t2, e2) {
  var i2;
  let r2 = [], n2 = Tv(e2.tailwindConfig.important);
  for (let a2 of t2) {
    if (e2.notClassCache.has(a2))
      continue;
    if (e2.candidateRuleCache.has(a2)) {
      r2 = r2.concat(Array.from(e2.candidateRuleCache.get(a2)));
      continue;
    }
    let s2 = Array.from(bn(a2, e2));
    if (s2.length === 0) {
      e2.notClassCache.add(a2);
      continue;
    }
    e2.classCache.set(a2, s2);
    let o2 = (i2 = e2.candidateRuleCache.get(a2)) != null ? i2 : /* @__PURE__ */ new Set();
    e2.candidateRuleCache.set(a2, o2);
    for (let l2 of s2) {
      let [{ sort: u2, options: f2 }, p2] = l2;
      if (f2.respectImportant && n2) {
        let d2 = R.root({ nodes: [p2.clone()] });
        d2.walkRules(n2), p2 = d2.nodes[0];
      }
      let c2 = [u2, p2];
      o2.add(c2), e2.ruleCache.add(c2), r2.push(c2);
    }
  }
  return r2;
}
function Ys(t2) {
  return t2.startsWith("[") && t2.endsWith("]");
}
function Ge(t2, e2 = void 0, r2 = void 0) {
  return t2.map((n2) => {
    var s2;
    let i2 = n2.clone(), a2 = ((s2 = n2.raws.tailwind) == null ? void 0 : s2.preserveSource) !== true || !i2.source;
    return e2 !== void 0 && a2 && (i2.source = e2, "walk" in i2 && i2.walk((o2) => {
      o2.source = e2;
    })), r2 !== void 0 && (i2.raws.tailwind = { ...i2.raws.tailwind, ...r2 }), i2;
  });
}
var Df = /[\\^$.*+?()[\]{}|]/g;
var Pv = RegExp(Df.source);
function xn(t2) {
  return t2 = Array.isArray(t2) ? t2 : [t2], t2 = t2.map((e2) => e2 instanceof RegExp ? e2.source : e2), t2.join("");
}
function ce(t2) {
  return new RegExp(xn(t2), "g");
}
function ut(t2) {
  return `(?:${t2.map(xn).join("|")})`;
}
function Hs(t2) {
  return `(?:${xn(t2)})?`;
}
function Mf(t2) {
  return `(?:${xn(t2)})*`;
}
function Ff(t2) {
  return t2 && Pv.test(t2) ? t2.replace(Df, "\\$&") : t2 || "";
}
function Lf(t2) {
  let e2 = Array.from(Rv(t2));
  return (r2) => {
    var i2;
    let n2 = [];
    for (let a2 of e2)
      n2 = [...n2, ...(i2 = r2.match(a2)) != null ? i2 : []];
    return n2.filter((a2) => a2 !== void 0).map(Fv);
  };
}
function* Rv(t2) {
  let e2 = t2.tailwindConfig.separator, r2 = G(t2.tailwindConfig, "variantGrouping"), n2 = t2.tailwindConfig.prefix !== "" ? Hs(ce([/-?/, Ff(t2.tailwindConfig.prefix)])) : "", i2 = ut([/\[[^\s:'"`]+:[^\s\[\]]+\]/, /\[[^\s:'"`]+:[^\s]+?\[[^\s]+\][^\s]+?\]/, ce([/-?(?:\w+)/, Hs(ut([ce([/-(?:\w+-)*\[[^\s:]+\]/, /(?![{([]])/, /(?:\/[^\s'"`\\><$]*)?/]), ce([/-(?:\w+-)*\[[^\s]+\]/, /(?![{([]])/, /(?:\/[^\s'"`\\$]*)?/]), /[-\/][^\s'"`\\$={><]*/]))])]), a2 = [ut([ce([/@\[[^\s"'`]+\](\/[^\s"'`]+)?/, e2]), ce([/([^\s"'`\[\\]+-)?\[[^\s"'`]+\]/, e2]), ce([/[^\s"'`\[\\]+/, e2])]), ut([ce([/([^\s"'`\[\\]+-)?\[[^\s`]+\]/, e2]), ce([/[^\s`\[\\]+/, e2])])];
  for (let s2 of a2)
    yield ce(["((?=((", s2, ")+))\\2)?", /!?/, n2, r2 ? ut([ce([/\(/, i2, Mf([/,/, i2]), /\)/]), i2]) : i2]);
  yield /[^<>"'`\s.(){}[\]#=%$]*[^<>"'`\s.(){}[\]#=%:$]/g;
}
var Dv = /([\[\]'"`])([^\[\]'"`])?/g;
var Mv = /[^"'`\s<>\]]+/;
function Fv(t2) {
  if (!t2.includes("-["))
    return t2;
  let e2 = 0, r2 = [], n2 = t2.matchAll(Dv);
  n2 = Array.from(n2).flatMap((i2) => {
    let [, ...a2] = i2;
    return a2.map((s2, o2) => Object.assign([], i2, { index: i2.index + o2, 0: s2 }));
  });
  for (let i2 of n2) {
    let a2 = i2[0], s2 = r2[r2.length - 1];
    if (a2 === s2 ? r2.pop() : (a2 === "'" || a2 === '"' || a2 === "`") && r2.push(a2), !s2) {
      if (a2 === "[") {
        e2++;
        continue;
      } else if (a2 === "]") {
        e2--;
        continue;
      }
      if (e2 < 0)
        return t2.substring(0, i2.index - 1);
      if (e2 === 0 && !Mv.test(a2))
        return t2.substring(0, i2.index);
    }
  }
  return t2;
}
var Ae = Vn;
var Nf = { DEFAULT: Lf };
var qf = { DEFAULT: (t2) => t2, svelte: (t2) => t2.replace(/(?:^|\s)class:/g, " ") };
function Lv(t2, e2) {
  let r2 = t2.tailwindConfig.content.extract;
  return r2[e2] || r2.DEFAULT || Nf[e2] || Nf.DEFAULT(t2);
}
function Nv(t2, e2) {
  let r2 = t2.content.transform;
  return r2[e2] || r2.DEFAULT || qf[e2] || qf.DEFAULT;
}
var ur = /* @__PURE__ */ new WeakMap();
function qv(t2, e2, r2, n2) {
  ur.has(e2) || ur.set(e2, new $f.default({ maxSize: 25e3 }));
  for (let i2 of t2.split(`
`))
    if (i2 = i2.trim(), !n2.has(i2))
      if (n2.add(i2), ur.get(e2).has(i2))
        for (let a2 of ur.get(e2).get(i2))
          r2.add(a2);
      else {
        let a2 = e2(i2).filter((o2) => o2 !== "!*"), s2 = new Set(a2);
        for (let o2 of s2)
          r2.add(o2);
        ur.get(e2).set(i2, s2);
      }
}
function $v(t2, e2) {
  let r2 = e2.offsets.sort(t2), n2 = { base: /* @__PURE__ */ new Set(), defaults: /* @__PURE__ */ new Set(), components: /* @__PURE__ */ new Set(), utilities: /* @__PURE__ */ new Set(), variants: /* @__PURE__ */ new Set() };
  for (let [i2, a2] of r2)
    n2[i2.layer].add(a2);
  return n2;
}
function Qs(t2) {
  return (e2) => {
    var h2;
    let r2 = { base: null, components: null, utilities: null, variants: null };
    if (e2.walkAtRules((y3) => {
      y3.name === "tailwind" && Object.keys(r2).includes(y3.params) && (r2[y3.params] = y3);
    }), Object.values(r2).every((y3) => y3 === null))
      return e2;
    let n2 = /* @__PURE__ */ new Set([...(h2 = t2.candidates) != null ? h2 : [], ke]), i2 = /* @__PURE__ */ new Set();
    Ae.DEBUG && console.time("Reading changed files");
    for (let { file: y3, content: m, extension: g2 } of t2.changedContent) {
      let w2 = Nv(t2.tailwindConfig, g2), b3 = Lv(t2, g2);
      m = y3 ? ht.readFileSync(y3, "utf8") : m, qv(w2(m), b3, n2, i2);
    }
    Ae.DEBUG && console.timeEnd("Reading changed files");
    let a2 = t2.classCache.size;
    Ae.DEBUG && console.time("Generate rules"), Ae.DEBUG && console.time("Sorting candidates");
    let s2 = new Set([...n2].sort((y3, m) => y3 === m ? 0 : y3 < m ? -1 : 1));
    Ae.DEBUG && console.timeEnd("Sorting candidates"), gn(s2, t2), Ae.DEBUG && console.timeEnd("Generate rules"), Ae.DEBUG && console.time("Build stylesheet"), (t2.stylesheetCache === null || t2.classCache.size !== a2) && (t2.stylesheetCache = $v([...t2.ruleCache], t2)), Ae.DEBUG && console.timeEnd("Build stylesheet");
    let { defaults: o2, base: l2, components: u2, utilities: f2, variants: p2 } = t2.stylesheetCache;
    r2.base && (r2.base.before(Ge([...l2, ...o2], r2.base.source, { layer: "base" })), r2.base.remove()), r2.components && (r2.components.before(Ge([...u2], r2.components.source, { layer: "components" })), r2.components.remove()), r2.utilities && (r2.utilities.before(Ge([...f2], r2.utilities.source, { layer: "utilities" })), r2.utilities.remove());
    let c2 = Array.from(p2).filter((y3) => {
      var g2;
      let m = (g2 = y3.raws.tailwind) == null ? void 0 : g2.parentLayer;
      return m === "components" ? r2.components !== null : m === "utilities" ? r2.utilities !== null : true;
    });
    r2.variants ? (r2.variants.before(Ge(c2, r2.variants.source, { layer: "variants" })), r2.variants.remove()) : c2.length > 0 && e2.append(Ge(c2, e2.source, { layer: "variants" }));
    let d2 = c2.some((y3) => {
      var m;
      return ((m = y3.raws.tailwind) == null ? void 0 : m.parentLayer) === "utilities";
    });
    r2.utilities && f2.size === 0 && !d2 && L.warn("content-problems", ["No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.", "https://tailwindcss.com/docs/content-configuration"]), Ae.DEBUG && (console.log("Potential classes: ", n2.size), console.log("Active contexts: ", Wn.size)), t2.changedContent = [], e2.walkAtRules("layer", (y3) => {
      Object.keys(r2).includes(y3.params) && y3.remove();
    });
  };
}
var kn = H(ve());
function Sn(t2) {
  let e2 = /* @__PURE__ */ new Map();
  R.root({ nodes: [t2.clone()] }).walkRules((a2) => {
    (0, kn.default)((s2) => {
      s2.walkClasses((o2) => {
        let l2 = o2.parent.toString(), u2 = e2.get(l2);
        u2 || e2.set(l2, u2 = /* @__PURE__ */ new Set()), u2.add(o2.value);
      });
    }).processSync(a2.selector);
  });
  let n2 = Array.from(e2.values(), (a2) => Array.from(a2)), i2 = n2.flat();
  return Object.assign(i2, { groups: n2 });
}
var Uv = (0, kn.default)();
function Js(t2) {
  return Uv.astSync(t2);
}
function Uf(t2, e2) {
  let r2 = /* @__PURE__ */ new Set();
  for (let n2 of t2)
    r2.add(n2.split(e2).pop());
  return Array.from(r2);
}
function jf(t2, e2) {
  let r2 = t2.tailwindConfig.prefix;
  return typeof r2 == "function" ? r2(e2) : r2 + e2;
}
function* Vf(t2) {
  for (yield t2; t2.parent; )
    yield t2.parent, t2 = t2.parent;
}
function jv(t2, e2 = {}) {
  let r2 = t2.nodes;
  t2.nodes = [];
  let n2 = t2.clone(e2);
  return t2.nodes = r2, n2;
}
function zv(t2) {
  for (let e2 of Vf(t2))
    if (t2 !== e2) {
      if (e2.type === "root")
        break;
      t2 = jv(e2, { nodes: [t2] });
    }
  return t2;
}
function Vv(t2, e2) {
  let r2 = /* @__PURE__ */ new Map();
  return t2.walkRules((n2) => {
    var s2;
    for (let o2 of Vf(n2))
      if (((s2 = o2.raws.tailwind) == null ? void 0 : s2.layer) !== void 0)
        return;
    let i2 = zv(n2), a2 = e2.offsets.create("user");
    for (let o2 of Sn(n2)) {
      let l2 = r2.get(o2) || [];
      r2.set(o2, l2), l2.push([{ layer: "user", sort: a2, important: false }, i2]);
    }
  }), r2;
}
function Wv(t2, e2) {
  for (let r2 of t2) {
    if (e2.notClassCache.has(r2) || e2.applyClassCache.has(r2))
      continue;
    if (e2.classCache.has(r2)) {
      e2.applyClassCache.set(r2, e2.classCache.get(r2).map(([i2, a2]) => [i2, a2.clone()]));
      continue;
    }
    let n2 = Array.from(bn(r2, e2));
    if (n2.length === 0) {
      e2.notClassCache.add(r2);
      continue;
    }
    e2.applyClassCache.set(r2, n2);
  }
  return e2.applyClassCache;
}
function Bv(t2) {
  let e2 = null;
  return { get: (r2) => (e2 = e2 || t2(), e2.get(r2)), has: (r2) => (e2 = e2 || t2(), e2.has(r2)) };
}
function Gv(t2) {
  return { get: (e2) => t2.flatMap((r2) => r2.get(e2) || []), has: (e2) => t2.some((r2) => r2.has(e2)) };
}
function zf(t2) {
  let e2 = t2.split(/[\s\t\n]+/g);
  return e2[e2.length - 1] === "!important" ? [e2.slice(0, -1), true] : [e2, false];
}
function Wf(t2, e2, r2) {
  let n2 = /* @__PURE__ */ new Set(), i2 = [];
  if (t2.walkAtRules("apply", (l2) => {
    let [u2] = zf(l2.params);
    for (let f2 of u2)
      n2.add(f2);
    i2.push(l2);
  }), i2.length === 0)
    return;
  let a2 = Gv([r2, Wv(n2, e2)]);
  function s2(l2, u2, f2) {
    let p2 = Js(l2), c2 = Js(u2), h2 = Js(`.${re(f2)}`).nodes[0].nodes[0];
    return p2.each((y3) => {
      let m = /* @__PURE__ */ new Set();
      c2.each((g2) => {
        let w2 = false;
        g2 = g2.clone(), g2.walkClasses((b3) => {
          b3.value === h2.value && (w2 || (b3.replaceWith(...y3.nodes.map((v2) => v2.clone())), m.add(g2), w2 = true));
        });
      });
      for (let g2 of m) {
        let w2 = [[]];
        for (let b3 of g2.nodes)
          b3.type === "combinator" ? (w2.push(b3), w2.push([])) : w2[w2.length - 1].push(b3);
        g2.nodes = [];
        for (let b3 of w2)
          Array.isArray(b3) && b3.sort((v2, O2) => v2.type === "tag" && O2.type === "class" ? -1 : v2.type === "class" && O2.type === "tag" ? 1 : v2.type === "class" && O2.type === "pseudo" && O2.value.startsWith("::") ? -1 : v2.type === "pseudo" && v2.value.startsWith("::") && O2.type === "class" ? 1 : 0), g2.nodes = g2.nodes.concat(b3);
      }
      y3.replaceWith(...m);
    }), p2.toString();
  }
  let o2 = /* @__PURE__ */ new Map();
  for (let l2 of i2) {
    let [u2] = o2.get(l2.parent) || [[], l2.source];
    o2.set(l2.parent, [u2, l2.source]);
    let [f2, p2] = zf(l2.params);
    if (l2.parent.type === "atrule") {
      if (l2.parent.name === "screen") {
        let c2 = l2.parent.params;
        throw l2.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${f2.map((d2) => `${c2}:${d2}`).join(" ")} instead.`);
      }
      throw l2.error(`@apply is not supported within nested at-rules like @${l2.parent.name}. You can fix this by un-nesting @${l2.parent.name}.`);
    }
    for (let c2 of f2) {
      if ([jf(e2, "group"), jf(e2, "peer")].includes(c2))
        throw l2.error(`@apply should not be used with the '${c2}' utility`);
      if (!a2.has(c2))
        throw l2.error(`The \`${c2}\` class does not exist. If \`${c2}\` is a custom class, make sure it is defined within a \`@layer\` directive.`);
      let d2 = a2.get(c2);
      u2.push([c2, p2, d2]);
    }
  }
  for (let [l2, [u2, f2]] of o2) {
    let p2 = [];
    for (let [d2, h2, y3] of u2) {
      let m = [d2, ...Uf([d2], e2.tailwindConfig.separator)];
      for (let [g2, w2] of y3) {
        let b3 = Sn(l2), v2 = Sn(w2);
        if (v2 = v2.groups.filter((E2) => E2.some((I2) => m.includes(I2))).flat(), v2 = v2.concat(Uf(v2, e2.tailwindConfig.separator)), b3.some((E2) => v2.includes(E2)))
          throw w2.error(`You cannot \`@apply\` the \`${d2}\` utility here because it creates a circular dependency.`);
        let x2 = R.root({ nodes: [w2.clone()] });
        x2.walk((E2) => {
          E2.source = f2;
        }), (w2.type !== "atrule" || w2.type === "atrule" && w2.name !== "keyframes") && x2.walkRules((E2) => {
          if (!Sn(E2).some((B2) => B2 === d2)) {
            E2.remove();
            return;
          }
          let I2 = typeof e2.tailwindConfig.important == "string" ? e2.tailwindConfig.important : null, Y2 = l2.raws.tailwind !== void 0 && I2 && l2.selector.indexOf(I2) === 0 ? l2.selector.slice(I2.length) : l2.selector;
          E2.selector = s2(Y2, E2.selector, d2), I2 && Y2 !== l2.selector && (E2.selector = yn(E2.selector, I2)), E2.walkDecls((B2) => {
            B2.important = g2.important || h2;
          });
          let K2 = (0, kn.default)().astSync(E2.selector);
          K2.each((B2) => at(B2)), E2.selector = K2.toString();
        }), x2.nodes[0] && p2.push([g2.sort, x2.nodes[0]]);
      }
    }
    let c2 = e2.offsets.sort(p2).map((d2) => d2[1]);
    l2.after(c2);
  }
  for (let l2 of i2)
    l2.parent.nodes.length > 1 ? l2.remove() : l2.parent.remove();
  Wf(t2, e2, r2);
}
function Xs(t2) {
  return (e2) => {
    let r2 = Bv(() => Vv(e2, t2));
    Wf(e2, t2, r2);
  };
}
var fr = H(qs());
var oc = H(Bf());
var oa = H(sc());
function sa(t2) {
  return typeof t2 == "object" && t2 !== null;
}
function tw(t2, e2) {
  let r2 = Le(e2);
  do
    if (r2.pop(), (0, fr.default)(t2, r2) !== void 0)
      break;
  while (r2.length);
  return r2.length ? r2 : void 0;
}
function ct(t2) {
  return typeof t2 == "string" ? t2 : t2.reduce((e2, r2, n2) => r2.includes(".") ? `${e2}[${r2}]` : n2 === 0 ? r2 : `${e2}.${r2}`, "");
}
function lc(t2) {
  return t2.map((e2) => `'${e2}'`).join(", ");
}
function ac(t2) {
  return lc(Object.keys(t2));
}
function aa(t2, e2, r2, n2 = {}) {
  let i2 = Array.isArray(e2) ? ct(e2) : e2.replace(/^['"]+|['"]+$/g, ""), a2 = Array.isArray(e2) ? e2 : Le(i2), s2 = (0, fr.default)(t2.theme, a2, r2);
  if (s2 === void 0) {
    let l2 = `'${i2}' does not exist in your theme config.`, u2 = a2.slice(0, -1), f2 = (0, fr.default)(t2.theme, u2);
    if (sa(f2)) {
      let p2 = Object.keys(f2).filter((d2) => aa(t2, [...u2, d2]).isValid), c2 = (0, oc.default)(a2[a2.length - 1], p2);
      c2 ? l2 += ` Did you mean '${ct([...u2, c2])}'?` : p2.length > 0 && (l2 += ` '${ct(u2)}' has the following valid keys: ${lc(p2)}`);
    } else {
      let p2 = tw(t2.theme, i2);
      if (p2) {
        let c2 = (0, fr.default)(t2.theme, p2);
        sa(c2) ? l2 += ` '${ct(p2)}' has the following keys: ${ac(c2)}` : l2 += ` '${ct(p2)}' is not an object.`;
      } else
        l2 += ` Your theme has the following top-level keys: ${ac(t2.theme)}`;
    }
    return { isValid: false, error: l2 };
  }
  if (!(typeof s2 == "string" || typeof s2 == "number" || typeof s2 == "function" || s2 instanceof String || s2 instanceof Number || Array.isArray(s2))) {
    let l2 = `'${i2}' was found but does not resolve to a string.`;
    if (sa(s2)) {
      let u2 = Object.keys(s2).filter((f2) => aa(t2, [...a2, f2]).isValid);
      u2.length && (l2 += ` Did you mean something like '${ct([...a2, u2[0]])}'?`);
    }
    return { isValid: false, error: l2 };
  }
  let [o2] = a2;
  return { isValid: true, value: Ce(o2)(s2, n2) };
}
function rw(t2, e2, r2) {
  e2 = e2.map((i2) => uc(t2, i2, r2));
  let n2 = [""];
  for (let i2 of e2)
    i2.type === "div" && i2.value === "," ? n2.push("") : n2[n2.length - 1] += oa.default.stringify(i2);
  return n2;
}
function uc(t2, e2, r2) {
  if (e2.type === "function" && r2[e2.value] !== void 0) {
    let n2 = rw(t2, e2.nodes, r2);
    e2.type = "word", e2.value = r2[e2.value](t2, ...n2);
  }
  return e2;
}
function nw(t2, e2, r2) {
  return (0, oa.default)(e2).walk((n2) => {
    uc(t2, n2, r2);
  }).toString();
}
var iw = { atrule: "params", decl: "value" };
function* sw(t2) {
  t2 = t2.replace(/^['"]+|['"]+$/g, "");
  let e2 = t2.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]+))$/), r2;
  yield [t2, void 0], e2 && (t2 = e2[1], r2 = e2[2], yield [t2, r2]);
}
function aw(t2, e2, r2) {
  var i2;
  let n2 = Array.from(sw(e2)).map(([a2, s2]) => Object.assign(aa(t2, a2, r2, { opacityValue: s2 }), { resolvedPath: a2, alpha: s2 }));
  return (i2 = n2.find((a2) => a2.isValid)) != null ? i2 : n2[0];
}
function fc(t2) {
  let e2 = t2.tailwindConfig, r2 = { theme: (n2, i2, ...a2) => {
    var c2;
    let { isValid: s2, value: o2, error: l2, alpha: u2 } = aw(e2, i2, a2.length ? a2 : void 0);
    if (!s2) {
      let d2 = n2.parent, h2 = (c2 = d2 == null ? void 0 : d2.raws.tailwind) == null ? void 0 : c2.candidate;
      if (d2 && h2 !== void 0) {
        t2.markInvalidUtilityNode(d2), d2.remove(), L.warn("invalid-theme-key-in-class", [`The utility \`${h2}\` contains an invalid theme value and was not generated.`]);
        return;
      }
      throw n2.error(l2);
    }
    let f2 = st(o2);
    return (u2 !== void 0 || f2 !== void 0 && typeof f2 == "function") && (u2 === void 0 && (u2 = 1), o2 = we(f2, u2, f2)), o2;
  }, screen: (n2, i2) => {
    i2 = i2.replace(/^['"]+/g, "").replace(/['"]+$/g, "");
    let s2 = Fe(e2.theme.screens).find(({ name: o2 }) => o2 === i2);
    if (!s2)
      throw n2.error(`The '${i2}' screen does not exist in your theme.`);
    return Me(s2);
  } };
  return (n2) => {
    n2.walk((i2) => {
      let a2 = iw[i2.type];
      a2 !== void 0 && (i2[a2] = nw(i2, i2[a2], r2));
    });
  };
}
function cc({ tailwindConfig: { theme: t2 } }) {
  return function(e2) {
    e2.walkAtRules("screen", (r2) => {
      let n2 = r2.params, a2 = Fe(t2.screens).find(({ name: s2 }) => s2 === n2);
      if (!a2)
        throw r2.error(`No \`${n2}\` screen found.`);
      r2.name = "media", r2.params = Me(a2);
    });
  };
}
var Tn = H(ve());
var pc = { id(t2) {
  return Tn.default.attribute({ attribute: "id", operator: "=", value: t2.value, quoteMark: '"' });
} };
function ow(t2) {
  let e2 = t2.filter((o2) => o2.type !== "pseudo" || o2.nodes.length > 0 ? true : o2.value.startsWith("::") || [":before", ":after", ":first-line", ":first-letter"].includes(o2.value)).reverse(), r2 = /* @__PURE__ */ new Set(["tag", "class", "id", "attribute"]), n2 = e2.findIndex((o2) => r2.has(o2.type));
  if (n2 === -1)
    return e2.reverse().join("").trim();
  let i2 = e2[n2], a2 = pc[i2.type] ? pc[i2.type](i2) : i2;
  e2 = e2.slice(0, n2);
  let s2 = e2.findIndex((o2) => o2.type === "combinator" && o2.value === ">");
  return s2 !== -1 && (e2.splice(0, s2), e2.unshift(Tn.default.universal())), [a2, ...e2.reverse()].join("").trim();
}
var lw = (0, Tn.default)((t2) => t2.map((e2) => {
  let r2 = e2.split((n2) => n2.type === "combinator" && n2.value === " ").pop();
  return ow(r2);
}));
var la = /* @__PURE__ */ new Map();
function uw(t2) {
  return la.has(t2) || la.set(t2, lw.transformSync(t2)), la.get(t2);
}
function ua({ tailwindConfig: t2 }) {
  return (e2) => {
    var i2, a2;
    let r2 = /* @__PURE__ */ new Map(), n2 = /* @__PURE__ */ new Set();
    if (e2.walkAtRules("defaults", (s2) => {
      if (s2.nodes && s2.nodes.length > 0) {
        n2.add(s2);
        return;
      }
      let o2 = s2.params;
      r2.has(o2) || r2.set(o2, /* @__PURE__ */ new Set()), r2.get(o2).add(s2.parent), s2.remove();
    }), G(t2, "optimizeUniversalDefaults"))
      for (let s2 of n2) {
        let o2 = /* @__PURE__ */ new Map(), l2 = (i2 = r2.get(s2.params)) != null ? i2 : [];
        for (let u2 of l2)
          for (let f2 of uw(u2.selector)) {
            let p2 = f2.includes(":-") || f2.includes("::-") ? f2 : "__DEFAULT__", c2 = (a2 = o2.get(p2)) != null ? a2 : /* @__PURE__ */ new Set();
            o2.set(p2, c2), c2.add(f2);
          }
        if (G(t2, "optimizeUniversalDefaults")) {
          if (o2.size === 0) {
            s2.remove();
            continue;
          }
          for (let [, u2] of o2) {
            let f2 = R.rule({ source: s2.source });
            f2.selectors = [...u2], f2.append(s2.nodes.map((p2) => p2.clone())), s2.before(f2);
          }
        }
        s2.remove();
      }
    else if (n2.size) {
      let s2 = R.rule({ selectors: ["*", "::before", "::after"] });
      for (let l2 of n2)
        s2.append(l2.nodes), s2.parent || l2.before(s2), s2.source || (s2.source = l2.source), l2.remove();
      let o2 = s2.clone({ selectors: ["::backdrop"] });
      s2.after(o2);
    }
  };
}
var dc = { atrule: ["name", "params"], rule: ["selector"] };
var fw = new Set(Object.keys(dc));
function fa() {
  function t2(e2) {
    let r2 = null;
    e2.each((n2) => {
      if (!fw.has(n2.type)) {
        r2 = null;
        return;
      }
      if (r2 === null) {
        r2 = n2;
        return;
      }
      let i2 = dc[n2.type];
      n2.type === "atrule" && n2.name === "font-face" ? r2 = n2 : i2.every((a2) => {
        var s2, o2;
        return ((s2 = n2[a2]) != null ? s2 : "").replace(/\s+/g, " ") === ((o2 = r2[a2]) != null ? o2 : "").replace(/\s+/g, " ");
      }) ? (n2.nodes && r2.append(n2.nodes), n2.remove()) : r2 = n2;
    }), e2.each((n2) => {
      n2.type === "atrule" && t2(n2);
    });
  }
  return (e2) => {
    t2(e2);
  };
}
function ca() {
  return (t2) => {
    t2.walkRules((e2) => {
      let r2 = /* @__PURE__ */ new Map(), n2 = /* @__PURE__ */ new Set([]), i2 = /* @__PURE__ */ new Map();
      e2.walkDecls((a2) => {
        if (a2.parent === e2) {
          if (r2.has(a2.prop)) {
            if (r2.get(a2.prop).value === a2.value) {
              n2.add(r2.get(a2.prop)), r2.set(a2.prop, a2);
              return;
            }
            i2.has(a2.prop) || i2.set(a2.prop, /* @__PURE__ */ new Set()), i2.get(a2.prop).add(r2.get(a2.prop)), i2.get(a2.prop).add(a2);
          }
          r2.set(a2.prop, a2);
        }
      });
      for (let a2 of n2)
        a2.remove();
      for (let a2 of i2.values()) {
        let s2 = /* @__PURE__ */ new Map();
        for (let o2 of a2) {
          let l2 = pw(o2.value);
          l2 !== null && (s2.has(l2) || s2.set(l2, /* @__PURE__ */ new Set()), s2.get(l2).add(o2));
        }
        for (let o2 of s2.values()) {
          let l2 = Array.from(o2).slice(0, -1);
          for (let u2 of l2)
            u2.remove();
        }
      }
    });
  };
}
var cw = Symbol("unitless-number");
function pw(t2) {
  var r2;
  let e2 = /^-?\d*.?\d+([\w%]+)?$/g.exec(t2);
  return e2 ? (r2 = e2[1]) != null ? r2 : cw : null;
}
function dw(t2) {
  if (!t2.walkAtRules)
    return;
  let e2 = /* @__PURE__ */ new Set();
  if (t2.walkAtRules("apply", (r2) => {
    e2.add(r2.parent);
  }), e2.size !== 0)
    for (let r2 of e2) {
      let n2 = [], i2 = [];
      for (let a2 of r2.nodes)
        a2.type === "atrule" && a2.name === "apply" ? (i2.length > 0 && (n2.push(i2), i2 = []), n2.push([a2])) : i2.push(a2);
      if (i2.length > 0 && n2.push(i2), n2.length !== 1) {
        for (let a2 of [...n2].reverse()) {
          let s2 = r2.clone({ nodes: [] });
          s2.append(a2), r2.after(s2);
        }
        r2.remove();
      }
    }
}
function Pn() {
  return (t2) => {
    dw(t2);
  };
}
function hw(t2) {
  return t2.type === "root";
}
function mw(t2) {
  return t2.type === "atrule" && t2.name === "layer";
}
function hc(t2) {
  return (e2, r2) => {
    let n2 = false;
    e2.walkAtRules("tailwind", (i2) => {
      if (n2)
        return false;
      if (i2.parent && !(hw(i2.parent) || mw(i2.parent)))
        return n2 = true, i2.warn(r2, ["Nested @tailwind rules were detected, but are not supported.", "Consider using a prefix to scope Tailwind's classes: https://tailwindcss.com/docs/configuration#prefix", "Alternatively, use the important selector strategy: https://tailwindcss.com/docs/configuration#selector-strategy"].join(`
`)), false;
    }), e2.walkRules((i2) => {
      if (n2)
        return false;
      i2.walkRules((a2) => (n2 = true, a2.warn(r2, ["Nested CSS was detected, but CSS nesting has not been configured correctly.", "Please enable a CSS nesting plugin *before* Tailwind in your configuration.", "See how here: https://tailwindcss.com/docs/using-with-preprocessors#nesting"].join(`
`)), false));
    });
  };
}
function pa(t2) {
  return function(e2, r2) {
    let { tailwindDirectives: n2, applyDirectives: i2 } = Un(e2);
    hc()(e2, r2), Pn()(e2, r2);
    let a2 = t2({ tailwindDirectives: n2, applyDirectives: i2, registerDependency(s2) {
      r2.messages.push({ plugin: "tailwindcss", parent: r2.opts.from, ...s2 });
    }, createContext(s2, o2) {
      return Pf(s2, o2, e2);
    } })(e2, r2);
    if (a2.tailwindConfig.separator === "-")
      throw new Error("The '-' character cannot be used as a custom separator in JIT mode due to parsing ambiguity. Please use another character like '_' instead.");
    nf(a2.tailwindConfig), Qs(a2)(e2, r2), Pn()(e2, r2), Xs(a2)(e2, r2), fc(a2)(e2, r2), cc(a2)(e2, r2), ua(a2)(e2, r2), fa(a2)(e2, r2), ca(a2)(e2, r2);
  };
}
var mc = ["preflight", "container", "accessibility", "pointerEvents", "visibility", "position", "inset", "isolation", "zIndex", "order", "gridColumn", "gridColumnStart", "gridColumnEnd", "gridRow", "gridRowStart", "gridRowEnd", "float", "clear", "margin", "boxSizing", "lineClamp", "display", "aspectRatio", "height", "maxHeight", "minHeight", "width", "minWidth", "maxWidth", "flex", "flexShrink", "flexGrow", "flexBasis", "tableLayout", "captionSide", "borderCollapse", "borderSpacing", "transformOrigin", "translate", "rotate", "skew", "scale", "transform", "animation", "cursor", "touchAction", "userSelect", "resize", "scrollSnapType", "scrollSnapAlign", "scrollSnapStop", "scrollMargin", "scrollPadding", "listStylePosition", "listStyleType", "listStyleImage", "appearance", "columns", "breakBefore", "breakInside", "breakAfter", "gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateColumns", "gridTemplateRows", "flexDirection", "flexWrap", "placeContent", "placeItems", "alignContent", "alignItems", "justifyContent", "justifyItems", "gap", "space", "divideWidth", "divideStyle", "divideColor", "divideOpacity", "placeSelf", "alignSelf", "justifySelf", "overflow", "overscrollBehavior", "scrollBehavior", "textOverflow", "hyphens", "whitespace", "wordBreak", "borderRadius", "borderWidth", "borderStyle", "borderColor", "borderOpacity", "backgroundColor", "backgroundOpacity", "backgroundImage", "gradientColorStops", "boxDecorationBreak", "backgroundSize", "backgroundAttachment", "backgroundClip", "backgroundPosition", "backgroundRepeat", "backgroundOrigin", "fill", "stroke", "strokeWidth", "objectFit", "objectPosition", "padding", "textAlign", "textIndent", "verticalAlign", "fontFamily", "fontSize", "fontWeight", "textTransform", "fontStyle", "fontVariantNumeric", "lineHeight", "letterSpacing", "textColor", "textOpacity", "textDecoration", "textDecorationColor", "textDecorationStyle", "textDecorationThickness", "textUnderlineOffset", "fontSmoothing", "placeholderColor", "placeholderOpacity", "caretColor", "accentColor", "opacity", "backgroundBlendMode", "mixBlendMode", "boxShadow", "boxShadowColor", "outlineStyle", "outlineWidth", "outlineOffset", "outlineColor", "ringWidth", "ringColor", "ringOpacity", "ringOffsetWidth", "ringOffsetColor", "blur", "brightness", "contrast", "dropShadow", "grayscale", "hueRotate", "invert", "saturate", "sepia", "filter", "backdropBlur", "backdropBrightness", "backdropContrast", "backdropGrayscale", "backdropHueRotate", "backdropInvert", "backdropOpacity", "backdropSaturate", "backdropSepia", "backdropFilter", "transitionProperty", "transitionDelay", "transitionDuration", "transitionTimingFunction", "willChange", "content"];
function gc(t2, e2) {
  return t2 === void 0 ? e2 : Array.isArray(t2) ? t2 : [...new Set(e2.filter((n2) => t2 !== false && t2[n2] !== false).concat(Object.keys(t2).filter((n2) => t2[n2] !== false)))];
}
function cr({ version: t2, from: e2, to: r2 }) {
  L.warn(`${e2}-color-renamed`, [`As of Tailwind CSS ${t2}, \`${e2}\` has been renamed to \`${r2}\`.`, "Update your configuration file to silence this warning."]);
}
var yc = { inherit: "inherit", current: "currentColor", transparent: "transparent", black: "#000", white: "#fff", slate: { 50: "#f8fafc", 100: "#f1f5f9", 200: "#e2e8f0", 300: "#cbd5e1", 400: "#94a3b8", 500: "#64748b", 600: "#475569", 700: "#334155", 800: "#1e293b", 900: "#0f172a", 950: "#020617" }, gray: { 50: "#f9fafb", 100: "#f3f4f6", 200: "#e5e7eb", 300: "#d1d5db", 400: "#9ca3af", 500: "#6b7280", 600: "#4b5563", 700: "#374151", 800: "#1f2937", 900: "#111827", 950: "#030712" }, zinc: { 50: "#fafafa", 100: "#f4f4f5", 200: "#e4e4e7", 300: "#d4d4d8", 400: "#a1a1aa", 500: "#71717a", 600: "#52525b", 700: "#3f3f46", 800: "#27272a", 900: "#18181b", 950: "#09090b" }, neutral: { 50: "#fafafa", 100: "#f5f5f5", 200: "#e5e5e5", 300: "#d4d4d4", 400: "#a3a3a3", 500: "#737373", 600: "#525252", 700: "#404040", 800: "#262626", 900: "#171717", 950: "#0a0a0a" }, stone: { 50: "#fafaf9", 100: "#f5f5f4", 200: "#e7e5e4", 300: "#d6d3d1", 400: "#a8a29e", 500: "#78716c", 600: "#57534e", 700: "#44403c", 800: "#292524", 900: "#1c1917", 950: "#0c0a09" }, red: { 50: "#fef2f2", 100: "#fee2e2", 200: "#fecaca", 300: "#fca5a5", 400: "#f87171", 500: "#ef4444", 600: "#dc2626", 700: "#b91c1c", 800: "#991b1b", 900: "#7f1d1d", 950: "#450a0a" }, orange: { 50: "#fff7ed", 100: "#ffedd5", 200: "#fed7aa", 300: "#fdba74", 400: "#fb923c", 500: "#f97316", 600: "#ea580c", 700: "#c2410c", 800: "#9a3412", 900: "#7c2d12", 950: "#431407" }, amber: { 50: "#fffbeb", 100: "#fef3c7", 200: "#fde68a", 300: "#fcd34d", 400: "#fbbf24", 500: "#f59e0b", 600: "#d97706", 700: "#b45309", 800: "#92400e", 900: "#78350f", 950: "#451a03" }, yellow: { 50: "#fefce8", 100: "#fef9c3", 200: "#fef08a", 300: "#fde047", 400: "#facc15", 500: "#eab308", 600: "#ca8a04", 700: "#a16207", 800: "#854d0e", 900: "#713f12", 950: "#422006" }, lime: { 50: "#f7fee7", 100: "#ecfccb", 200: "#d9f99d", 300: "#bef264", 400: "#a3e635", 500: "#84cc16", 600: "#65a30d", 700: "#4d7c0f", 800: "#3f6212", 900: "#365314", 950: "#1a2e05" }, green: { 50: "#f0fdf4", 100: "#dcfce7", 200: "#bbf7d0", 300: "#86efac", 400: "#4ade80", 500: "#22c55e", 600: "#16a34a", 700: "#15803d", 800: "#166534", 900: "#14532d", 950: "#052e16" }, emerald: { 50: "#ecfdf5", 100: "#d1fae5", 200: "#a7f3d0", 300: "#6ee7b7", 400: "#34d399", 500: "#10b981", 600: "#059669", 700: "#047857", 800: "#065f46", 900: "#064e3b", 950: "#022c22" }, teal: { 50: "#f0fdfa", 100: "#ccfbf1", 200: "#99f6e4", 300: "#5eead4", 400: "#2dd4bf", 500: "#14b8a6", 600: "#0d9488", 700: "#0f766e", 800: "#115e59", 900: "#134e4a", 950: "#042f2e" }, cyan: { 50: "#ecfeff", 100: "#cffafe", 200: "#a5f3fc", 300: "#67e8f9", 400: "#22d3ee", 500: "#06b6d4", 600: "#0891b2", 700: "#0e7490", 800: "#155e75", 900: "#164e63", 950: "#083344" }, sky: { 50: "#f0f9ff", 100: "#e0f2fe", 200: "#bae6fd", 300: "#7dd3fc", 400: "#38bdf8", 500: "#0ea5e9", 600: "#0284c7", 700: "#0369a1", 800: "#075985", 900: "#0c4a6e", 950: "#082f49" }, blue: { 50: "#eff6ff", 100: "#dbeafe", 200: "#bfdbfe", 300: "#93c5fd", 400: "#60a5fa", 500: "#3b82f6", 600: "#2563eb", 700: "#1d4ed8", 800: "#1e40af", 900: "#1e3a8a", 950: "#172554" }, indigo: { 50: "#eef2ff", 100: "#e0e7ff", 200: "#c7d2fe", 300: "#a5b4fc", 400: "#818cf8", 500: "#6366f1", 600: "#4f46e5", 700: "#4338ca", 800: "#3730a3", 900: "#312e81", 950: "#1e1b4b" }, violet: { 50: "#f5f3ff", 100: "#ede9fe", 200: "#ddd6fe", 300: "#c4b5fd", 400: "#a78bfa", 500: "#8b5cf6", 600: "#7c3aed", 700: "#6d28d9", 800: "#5b21b6", 900: "#4c1d95", 950: "#2e1065" }, purple: { 50: "#faf5ff", 100: "#f3e8ff", 200: "#e9d5ff", 300: "#d8b4fe", 400: "#c084fc", 500: "#a855f7", 600: "#9333ea", 700: "#7e22ce", 800: "#6b21a8", 900: "#581c87", 950: "#3b0764" }, fuchsia: { 50: "#fdf4ff", 100: "#fae8ff", 200: "#f5d0fe", 300: "#f0abfc", 400: "#e879f9", 500: "#d946ef", 600: "#c026d3", 700: "#a21caf", 800: "#86198f", 900: "#701a75", 950: "#4a044e" }, pink: { 50: "#fdf2f8", 100: "#fce7f3", 200: "#fbcfe8", 300: "#f9a8d4", 400: "#f472b6", 500: "#ec4899", 600: "#db2777", 700: "#be185d", 800: "#9d174d", 900: "#831843", 950: "#500724" }, rose: { 50: "#fff1f2", 100: "#ffe4e6", 200: "#fecdd3", 300: "#fda4af", 400: "#fb7185", 500: "#f43f5e", 600: "#e11d48", 700: "#be123c", 800: "#9f1239", 900: "#881337", 950: "#4c0519" }, get lightBlue() {
  return cr({ version: "v2.2", from: "lightBlue", to: "sky" }), this.sky;
}, get warmGray() {
  return cr({ version: "v3.0", from: "warmGray", to: "stone" }), this.stone;
}, get trueGray() {
  return cr({ version: "v3.0", from: "trueGray", to: "neutral" }), this.neutral;
}, get coolGray() {
  return cr({ version: "v3.0", from: "coolGray", to: "gray" }), this.gray;
}, get blueGray() {
  return cr({ version: "v3.0", from: "blueGray", to: "slate" }), this.slate;
} };
function da(t2, ...e2) {
  var r2, n2;
  for (let i2 of e2) {
    for (let a2 in i2)
      (r2 = t2 == null ? void 0 : t2.hasOwnProperty) != null && r2.call(t2, a2) || (t2[a2] = i2[a2]);
    for (let a2 of Object.getOwnPropertySymbols(i2))
      (n2 = t2 == null ? void 0 : t2.hasOwnProperty) != null && n2.call(t2, a2) || (t2[a2] = i2[a2]);
  }
  return t2;
}
function vc(t2) {
  var r2;
  (() => {
    if (t2.purge || !t2.content || !Array.isArray(t2.content) && !(typeof t2.content == "object" && t2.content !== null))
      return false;
    if (Array.isArray(t2.content))
      return t2.content.every((n2) => typeof n2 == "string" ? true : !(typeof (n2 == null ? void 0 : n2.raw) != "string" || (n2 == null ? void 0 : n2.extension) && typeof (n2 == null ? void 0 : n2.extension) != "string"));
    if (typeof t2.content == "object" && t2.content !== null) {
      if (Object.keys(t2.content).some((n2) => !["files", "relative", "extract", "transform"].includes(n2)))
        return false;
      if (Array.isArray(t2.content.files)) {
        if (!t2.content.files.every((n2) => typeof n2 == "string" ? true : !(typeof (n2 == null ? void 0 : n2.raw) != "string" || (n2 == null ? void 0 : n2.extension) && typeof (n2 == null ? void 0 : n2.extension) != "string")))
          return false;
        if (typeof t2.content.extract == "object") {
          for (let n2 of Object.values(t2.content.extract))
            if (typeof n2 != "function")
              return false;
        } else if (!(t2.content.extract === void 0 || typeof t2.content.extract == "function"))
          return false;
        if (typeof t2.content.transform == "object") {
          for (let n2 of Object.values(t2.content.transform))
            if (typeof n2 != "function")
              return false;
        } else if (!(t2.content.transform === void 0 || typeof t2.content.transform == "function"))
          return false;
        if (typeof t2.content.relative != "boolean" && typeof t2.content.relative < "u")
          return false;
      }
      return true;
    }
    return false;
  })() || L.warn("purge-deprecation", ["The `purge`/`content` options have changed in Tailwind CSS v3.0.", "Update your configuration file to eliminate this warning.", "https://tailwindcss.com/docs/upgrade-guide#configure-content-sources"]), t2.safelist = (() => {
    var s2;
    let { content: n2, purge: i2, safelist: a2 } = t2;
    return Array.isArray(a2) ? a2 : Array.isArray(n2 == null ? void 0 : n2.safelist) ? n2.safelist : Array.isArray(i2 == null ? void 0 : i2.safelist) ? i2.safelist : Array.isArray((s2 = i2 == null ? void 0 : i2.options) == null ? void 0 : s2.safelist) ? i2.options.safelist : [];
  })(), t2.blocklist = (() => {
    let { blocklist: n2 } = t2;
    if (Array.isArray(n2)) {
      if (n2.every((i2) => typeof i2 == "string"))
        return n2;
      L.warn("blocklist-invalid", ["The `blocklist` option must be an array of strings.", "https://tailwindcss.com/docs/content-configuration#discarding-classes"]);
    }
    return [];
  })(), typeof t2.prefix == "function" ? (L.warn("prefix-function", ["As of Tailwind CSS v3.0, `prefix` cannot be a function.", "Update `prefix` in your configuration to be a string to eliminate this warning.", "https://tailwindcss.com/docs/upgrade-guide#prefix-cannot-be-a-function"]), t2.prefix = "") : t2.prefix = (r2 = t2.prefix) != null ? r2 : "", t2.content = { relative: (() => {
    let { content: n2 } = t2;
    return n2 != null && n2.relative ? n2.relative : G(t2, "relativeContentPathsByDefault");
  })(), files: (() => {
    let { content: n2, purge: i2 } = t2;
    return Array.isArray(i2) ? i2 : Array.isArray(i2 == null ? void 0 : i2.content) ? i2.content : Array.isArray(n2) ? n2 : Array.isArray(n2 == null ? void 0 : n2.content) ? n2.content : Array.isArray(n2 == null ? void 0 : n2.files) ? n2.files : [];
  })(), extract: (() => {
    let n2 = (() => {
      var s2, o2, l2, u2, f2, p2, c2, d2, h2, y3;
      return (s2 = t2.purge) != null && s2.extract ? t2.purge.extract : (o2 = t2.content) != null && o2.extract ? t2.content.extract : (u2 = (l2 = t2.purge) == null ? void 0 : l2.extract) != null && u2.DEFAULT ? t2.purge.extract.DEFAULT : (p2 = (f2 = t2.content) == null ? void 0 : f2.extract) != null && p2.DEFAULT ? t2.content.extract.DEFAULT : (d2 = (c2 = t2.purge) == null ? void 0 : c2.options) != null && d2.extractors ? t2.purge.options.extractors : (y3 = (h2 = t2.content) == null ? void 0 : h2.options) != null && y3.extractors ? t2.content.options.extractors : {};
    })(), i2 = {}, a2 = (() => {
      var s2, o2, l2, u2;
      if ((o2 = (s2 = t2.purge) == null ? void 0 : s2.options) != null && o2.defaultExtractor)
        return t2.purge.options.defaultExtractor;
      if ((u2 = (l2 = t2.content) == null ? void 0 : l2.options) != null && u2.defaultExtractor)
        return t2.content.options.defaultExtractor;
    })();
    if (a2 !== void 0 && (i2.DEFAULT = a2), typeof n2 == "function")
      i2.DEFAULT = n2;
    else if (Array.isArray(n2))
      for (let { extensions: s2, extractor: o2 } of n2 != null ? n2 : [])
        for (let l2 of s2)
          i2[l2] = o2;
    else
      typeof n2 == "object" && n2 !== null && Object.assign(i2, n2);
    return i2;
  })(), transform: (() => {
    let n2 = (() => {
      var a2, s2, o2, l2, u2, f2;
      return (a2 = t2.purge) != null && a2.transform ? t2.purge.transform : (s2 = t2.content) != null && s2.transform ? t2.content.transform : (l2 = (o2 = t2.purge) == null ? void 0 : o2.transform) != null && l2.DEFAULT ? t2.purge.transform.DEFAULT : (f2 = (u2 = t2.content) == null ? void 0 : u2.transform) != null && f2.DEFAULT ? t2.content.transform.DEFAULT : {};
    })(), i2 = {};
    return typeof n2 == "function" && (i2.DEFAULT = n2), typeof n2 == "object" && n2 !== null && Object.assign(i2, n2), i2;
  })() };
  for (let n2 of t2.content.files)
    if (typeof n2 == "string" && /{([^,]*?)}/g.test(n2)) {
      L.warn("invalid-glob-braces", [`The glob pattern ${n2} in your Tailwind CSS configuration is invalid.`, `Update it to ${n2.replace(/{([^,]*?)}/g, "$1")} to silence this warning.`]);
      break;
    }
  return t2;
}
function In(t2) {
  return Array.isArray(t2) ? t2.map((e2) => In(e2)) : typeof t2 == "object" && t2 !== null ? Object.fromEntries(Object.entries(t2).map(([e2, r2]) => [e2, In(r2)])) : t2;
}
function pt(t2) {
  return typeof t2 == "function";
}
function pr(t2, ...e2) {
  let r2 = e2.pop();
  for (let n2 of e2)
    for (let i2 in n2) {
      let a2 = r2(t2[i2], n2[i2]);
      a2 === void 0 ? X(t2[i2]) && X(n2[i2]) ? t2[i2] = pr({}, t2[i2], n2[i2], r2) : t2[i2] = n2[i2] : t2[i2] = a2;
    }
  return t2;
}
var ha = { colors: yc, negative(t2) {
  return Object.keys(t2).filter((e2) => t2[e2] !== "0").reduce((e2, r2) => {
    let n2 = Re(t2[r2]);
    return n2 !== void 0 && (e2[`-${r2}`] = n2), e2;
  }, {});
}, breakpoints(t2) {
  return Object.keys(t2).filter((e2) => typeof t2[e2] == "string").reduce((e2, r2) => ({ ...e2, [`screen-${r2}`]: t2[r2] }), {});
} };
function gw(t2, ...e2) {
  return pt(t2) ? t2(...e2) : t2;
}
function yw(t2) {
  return t2.reduce((e2, { extend: r2 }) => pr(e2, r2, (n2, i2) => n2 === void 0 ? [i2] : Array.isArray(n2) ? [i2, ...n2] : [i2, n2]), {});
}
function vw(t2) {
  return { ...t2.reduce((e2, r2) => da(e2, r2), {}), extend: yw(t2) };
}
function wc(t2, e2) {
  if (Array.isArray(t2) && X(t2[0]))
    return t2.concat(e2);
  if (Array.isArray(e2) && X(e2[0]) && X(t2))
    return [t2, ...e2];
  if (Array.isArray(e2))
    return e2;
}
function ww({ extend: t2, ...e2 }) {
  return pr(e2, t2, (r2, n2) => !pt(r2) && !n2.some(pt) ? pr({}, r2, ...n2, wc) : (i2, a2) => pr({}, ...[r2, ...n2].map((s2) => gw(s2, i2, a2)), wc));
}
function* bw(t2) {
  let e2 = Le(t2);
  if (e2.length === 0 || (yield e2, Array.isArray(t2)))
    return;
  let r2 = /^(.*?)\s*\/\s*([^/]+)$/, n2 = t2.match(r2);
  if (n2 !== null) {
    let [, i2, a2] = n2, s2 = Le(i2);
    s2.alpha = a2, yield s2;
  }
}
function xw(t2) {
  let e2 = (r2, n2) => {
    for (let i2 of bw(r2)) {
      let a2 = 0, s2 = t2;
      for (; s2 != null && a2 < i2.length; )
        s2 = s2[i2[a2++]], s2 = pt(s2) && (i2.alpha === void 0 || a2 <= i2.length - 1) ? s2(e2, ha) : s2;
      if (s2 !== void 0) {
        if (i2.alpha !== void 0) {
          let o2 = st(s2);
          return we(o2, i2.alpha, M(o2));
        }
        return X(s2) ? In(s2) : s2;
      }
    }
    return n2;
  };
  return Object.assign(e2, { theme: e2, ...ha }), Object.keys(t2).reduce((r2, n2) => (r2[n2] = pt(t2[n2]) ? t2[n2](e2, ha) : t2[n2], r2), {});
}
function bc(t2) {
  let e2 = [];
  return t2.forEach((r2) => {
    var i2;
    e2 = [...e2, r2];
    let n2 = (i2 = r2 == null ? void 0 : r2.plugins) != null ? i2 : [];
    n2.length !== 0 && n2.forEach((a2) => {
      var s2;
      a2.__isOptionsFunction && (a2 = a2()), e2 = [...e2, ...bc([(s2 = a2 == null ? void 0 : a2.config) != null ? s2 : {}])];
    });
  }), e2;
}
function Sw(t2) {
  return [...t2].reduceRight((r2, n2) => pt(n2) ? n2({ corePlugins: r2 }) : gc(n2, r2), mc);
}
function kw(t2) {
  return [...t2].reduceRight((r2, n2) => [...r2, ...n2], []);
}
function ma(t2) {
  let e2 = [...bc(t2), { prefix: "", important: false, separator: ":" }];
  return vc(da({ theme: xw(ww(vw(e2.map((r2) => {
    var n2;
    return (n2 = r2 == null ? void 0 : r2.theme) != null ? n2 : {};
  })))), corePlugins: Sw(e2.map((r2) => r2.corePlugins)), plugins: kw(t2.map((r2) => {
    var n2;
    return (n2 = r2 == null ? void 0 : r2.plugins) != null ? n2 : [];
  })) }, ...e2));
}
var kc = H(Sc());
function Rn(t2) {
  var i2;
  let e2 = ((i2 = t2 == null ? void 0 : t2.presets) != null ? i2 : [kc.default]).slice().reverse().flatMap((a2) => Rn(a2 instanceof Function ? a2() : a2)), r2 = { respectDefaultRingColorOpacity: { theme: { ringColor: ({ theme: a2 }) => ({ DEFAULT: "#3b82f67f", ...a2("colors") }) } }, disableColorOpacityUtilitiesByDefault: { corePlugins: { backgroundOpacity: false, borderOpacity: false, divideOpacity: false, placeholderOpacity: false, ringOpacity: false, textOpacity: false } } }, n2 = Object.keys(r2).filter((a2) => G(t2, a2)).map((a2) => r2[a2]);
  return [t2, ...n2, ...e2];
}
function ga(...t2) {
  let [, ...e2] = Rn(t2[0]);
  return ma([...t2, ...e2]);
}
var Oc = (t2) => {
  var n2;
  let e2 = ga((n2 = t2.config) != null ? n2 : {});
  return pa((i2) => () => i2.createContext(e2, [{ content: t2.content }]));
};
var wp = H(vp(), 1);
var bp = (t2) => {
  let e2 = Oc({ config: t2.config, content: t2.content });
  return R([e2, (0, wp.default)()]).process(xp, { from: void 0 }).css;
};
var xp = String.raw`
  @tailwind base;
  @tailwind components;
  @tailwind utilities;
`;
function kp(t2) {
  let e2 = R.parse(t2);
  return tn.objectify(e2);
}
var sb = (t2, e2) => {
  var i2, a2;
  let r2 = (a2 = (i2 = e2 == null ? void 0 : e2.corePlugins) == null ? void 0 : i2.preflight) != null ? a2 : false, n2 = (e2 == null ? void 0 : e2.corePlugins) || {};
  return bp({ config: { ...e2, corePlugins: { ...n2, preflight: r2 } }, content: t2 });
};
var Op = ({ config: t2, options: e2 }) => ({ twi: Ea(t2, e2), twj: Cp(t2, e2) });
var Ep = (...t2) => {
  let e2 = "";
  return typeof t2[0] == "string" ? e2 = t2[0] : Array.isArray(t2[0]) ? e2 = t2.flat(1 / 0).map((r2) => Ep(r2)).join(" ") : typeof t2[0] == "object" && (e2 = Object.entries(t2[0]).filter((r2) => !!r2[1]).map((r2) => r2[0]).join(" ")), e2 = e2.replace(/\s+/g, " "), e2;
};
var Ea = (t2, e2) => (...r2) => {
  let n2 = Ep(r2), { 1: i2 } = r2 || {}, s2 = { ...{ merge: true, minify: true, ignoreMediaQueries: true }, ...e2, ...i2 }, o2 = Ra(sb(n2, t2));
  return s2 != null && s2.ignoreMediaQueries ? o2.removeMediaQueries() : (o2.removeUndefined(), o2.combineMediaQueries()), o2.fixRGB(), s2 != null && s2.merge && o2.merge(), s2 != null && s2.minify && o2.minify(), o2.get();
};
var Cp = (t2, e2) => (...r2) => kp(Ea(t2, e2)(r2));
var Sp = Ea();
var ab = Cp();

// node_modules/@pmndrs/uikit/dist/convert/html/generated-property-types.js
var generatedPropertyTypes = { "Inheriting": { "textAlign": [["block", "center", "left", "middle", "right"]], "verticalAlign": [["bottom", "center", "middle", "top"]], "color": ["string", "number"], "opacity": ["number"], "letterSpacing": ["number"], "lineHeight": ["percentage", "number"], "fontSize": ["number"], "wordBreak": [["break-all", "break-word", "keep-all"]], "fontFamily": ["string"], "fontWeight": [["black", "bold", "extra-black", "extra-bold", "extra-light", "light", "medium", "normal", "semi-bold", "thin"], "number"], "scrollbarOpacity": ["number"], "scrollbarColor": ["string", "number"], "scrollbarWidth": ["number"], "scrollbarBorderRightWidth": ["number"], "scrollbarBorderTopWidth": ["number"], "scrollbarBorderLeftWidth": ["number"], "scrollbarBorderBottomWidth": ["number"], "scrollbarBorderTopLeftRadius": ["number"], "scrollbarBorderTopRightRadius": ["number"], "scrollbarBorderBottomLeftRadius": ["number"], "scrollbarBorderBottomRightRadius": ["number"], "scrollbarBorderColor": ["string", "number"], "scrollbarBorderBend": ["number"], "scrollbarBorderOpacity": ["number"], "scrollbarBorderRadius": ["number"], "scrollbarBorderTopRadius": ["number"], "scrollbarBorderLeftRadius": ["number"], "scrollbarBorderRightRadius": ["number"], "scrollbarBorderBottomRadius": ["number"], "scrollbarBorderWidth": ["number"], "scrollbarBorderXWidth": ["number"], "scrollbarBorderYWidth": ["number"], "caretOpacity": ["number"], "caretColor": ["string", "number"], "caretWidth": ["number"], "caretBorderRightWidth": ["number"], "caretBorderTopWidth": ["number"], "caretBorderLeftWidth": ["number"], "caretBorderBottomWidth": ["number"], "caretBorderTopLeftRadius": ["number"], "caretBorderTopRightRadius": ["number"], "caretBorderBottomLeftRadius": ["number"], "caretBorderBottomRightRadius": ["number"], "caretBorderColor": ["string", "number"], "caretBorderBend": ["number"], "caretBorderOpacity": ["number"], "selectionOpacity": ["number"], "selectionColor": ["string", "number"], "selectionBorderRightWidth": ["number"], "selectionBorderTopWidth": ["number"], "selectionBorderLeftWidth": ["number"], "selectionBorderBottomWidth": ["number"], "selectionBorderTopLeftRadius": ["number"], "selectionBorderTopRightRadius": ["number"], "selectionBorderBottomLeftRadius": ["number"], "selectionBorderBottomRightRadius": ["number"], "selectionBorderColor": ["string", "number"], "selectionBorderBend": ["number"], "selectionBorderOpacity": ["number"], "caretBorderRadius": ["number"], "caretBorderTopRadius": ["number"], "caretBorderLeftRadius": ["number"], "caretBorderRightRadius": ["number"], "caretBorderBottomRadius": ["number"], "caretBorderWidth": ["number"], "caretBorderXWidth": ["number"], "caretBorderYWidth": ["number"], "selectionBorderRadius": ["number"], "selectionBorderTopRadius": ["number"], "selectionBorderLeftRadius": ["number"], "selectionBorderRightRadius": ["number"], "selectionBorderBottomRadius": ["number"], "selectionBorderWidth": ["number"], "selectionBorderXWidth": ["number"], "selectionBorderYWidth": ["number"] }, "Shared": { "positionType": [["absolute", "relative", "static"]], "positionTop": ["percentage", "number"], "positionLeft": ["percentage", "number"], "positionRight": ["percentage", "number"], "positionBottom": ["percentage", "number"], "alignContent": [["auto", "baseline", "center", "flex-end", "flex-start", "space-around", "space-between", "space-evenly", "stretch"]], "alignItems": [["auto", "baseline", "center", "flex-end", "flex-start", "space-around", "space-between", "space-evenly", "stretch"]], "alignSelf": [["auto", "baseline", "center", "flex-end", "flex-start", "space-around", "space-between", "space-evenly", "stretch"]], "flexDirection": [["column", "column-reverse", "row", "row-reverse"]], "flexWrap": [["no-wrap", "wrap", "wrap-reverse"]], "justifyContent": [["center", "flex-end", "flex-start", "space-around", "space-between", "space-evenly"]], "marginTop": ["percentage", ["auto"], "number"], "marginLeft": ["percentage", ["auto"], "number"], "marginRight": ["percentage", ["auto"], "number"], "marginBottom": ["percentage", ["auto"], "number"], "flexBasis": ["percentage", ["auto"], "number"], "flexGrow": ["number"], "flexShrink": ["number"], "width": ["percentage", ["auto"], "number"], "height": ["percentage", ["auto"], "number"], "minWidth": ["percentage", "number"], "minHeight": ["percentage", "number"], "maxWidth": ["percentage", "number"], "maxHeight": ["percentage", "number"], "aspectRatio": ["number"], "borderTopWidth": ["number"], "borderLeftWidth": ["number"], "borderRightWidth": ["number"], "borderBottomWidth": ["number"], "overflow": [["hidden", "scroll", "visible"]], "display": [["flex", "none"]], "paddingTop": ["percentage", "number"], "paddingLeft": ["percentage", "number"], "paddingRight": ["percentage", "number"], "paddingBottom": ["percentage", "number"], "gapRow": ["number"], "gapColumn": ["number"], "borderTopLeftRadius": ["number"], "borderTopRightRadius": ["number"], "borderBottomLeftRadius": ["number"], "borderBottomRightRadius": ["number"], "backgroundOpacity": ["number"], "backgroundColor": ["string", "number"], "borderColor": ["string", "number"], "borderBend": ["number"], "borderOpacity": ["number"], "zIndexOffset": ["number"], "transformTranslateX": ["percentage", "number"], "transformTranslateY": ["percentage", "number"], "transformTranslateZ": ["number"], "transformRotateX": ["number"], "transformRotateY": ["number"], "transformRotateZ": ["number"], "transformScaleX": ["percentage", "number"], "transformScaleY": ["percentage", "number"], "transformScaleZ": ["percentage", "number"], "transformOriginX": [["center", "left", "middle", "right"]], "transformOriginY": [["bottom", "center", "middle", "top"]], "receiveShadow": ["boolean"], "castShadow": ["boolean"], "visibility": [["hidden", "visible"]], "inset": ["percentage", "number"], "padding": ["percentage", "number"], "paddingX": ["percentage", "number"], "paddingY": ["percentage", "number"], "margin": ["percentage", ["auto"], "number"], "marginX": ["percentage", ["auto"], "number"], "marginY": ["percentage", ["auto"], "number"], "gap": ["number"], "borderWidth": ["number"], "borderXWidth": ["number"], "borderYWidth": ["number"], "borderRadius": ["number"], "borderTopRadius": ["number"], "borderLeftRadius": ["number"], "borderRightRadius": ["number"], "borderBottomRadius": ["number"], "transformScale": ["percentage", "number"], "cursor": ["string"] }, "Container": {}, "Image": { "keepAspectRatio": ["boolean"], "objectFit": [["cover", "fill"]], "src": ["string"] }, "Svg": { "keepAspectRatio": ["boolean"], "src": ["string"] }, "Icon": {}, "Input": { "disabled": ["boolean"], "type": [["password", "text"]], "value": ["string"], "tabIndex": ["number"], "multiline": ["boolean"], "defaultValue": ["string"] }, "Text": {}, "Video": { "keepAspectRatio": ["boolean"], "objectFit": [["cover", "fill"]], "src": ["string"], "volume": ["number"], "preservesPitch": ["boolean"], "playbackRate": ["number"], "muted": ["boolean"], "loop": ["boolean"], "autoplay": ["boolean"] } };

// node_modules/@pmndrs/uikit/dist/convert/html/properties.js
var propertyRenamings = {
  //yoga
  rowGap: "gapRow",
  columnGap: "gapColumn",
  position: "positionType",
  top: "positionTop",
  left: "positionLeft",
  right: "positionRight",
  bottom: "positionBottom",
  //ours
  zIndex: "zIndexOffset"
};
var transformRegex = /(translate|rotate)(X|Y|Z|3d)?\((\s*[^,)]+\s*(?:,\s*[^,)]+\s*)*)\)/g;
var customCssTranslation = {
  transform: (set, property) => {
    if (typeof property != "string") {
      return;
    }
    let result;
    while ((result = transformRegex.exec(property)) != null) {
      let [, operation, type, values] = result;
      let [x2, y3, z3] = values.split(",").map((s2) => s2.trim());
      const prefix = `transform${operation[0].toUpperCase()}${operation.slice(1)}`;
      if (operation === "rotate") {
        type ?? (type = "Z");
      }
      y3 ?? (y3 = x2);
      z3 ?? (z3 = x2);
      if (type === "X" || type === "3d" || type === void 0) {
        set(`${prefix}X`, x2);
      }
      if (type === "Y" || type === "3d" || type === void 0) {
        set(`${prefix}Y`, y3);
      }
      if (type === "Z" || type === "3d") {
        set(`${prefix}Z`, z3);
      }
    }
  },
  flex: (set, property) => {
    if (typeof property != "string") {
      return;
    }
    if (property === "auto") {
      set("flexGrow", "1");
      set("flexShrink", "1");
      set("flexBasis", "auto");
      return;
    }
    if (property === "none") {
      set("flexGrow", "0");
      set("flexShrink", "0");
      set("flexBasis", "auto");
    }
    if (property === "initial") {
      set("flexGrow", "0");
      set("flexShrink", "1");
      set("flexBasis", "auto");
    }
    let flexGrowShink = [];
    let flexBasis;
    const parts = property.split(/\s+/);
    for (const part of parts) {
      if (part === "auto") {
        flexBasis = part;
        continue;
      }
      const result = digitsWithUnitRegex.exec(part);
      if (result == null) {
        return;
      }
      const [, float, unit] = result;
      if (unit === "") {
        flexGrowShink.push(float);
        continue;
      }
      flexBasis = `${float}${unit}`;
    }
    const [flexGrow, flexShrink] = flexGrowShink;
    if (flexGrow != null) {
      set("flexGrow", flexGrow);
    }
    if (flexShrink != null) {
      set("flexShrink", flexShrink);
    }
    if (flexBasis != null) {
      set("flexBasis", flexBasis);
    }
  }
};
function isInheritingProperty(key) {
  switch (key) {
    case "opacity":
    case "color":
    case "textAlign":
    case "verticalAlign":
    case "fontSize":
    case "letterSpacing":
    case "lineHeight":
    case "wordBreak":
    case "fontFamily":
    case "fontWeight":
    case "visibility":
      return true;
    default:
      return key.startsWith("caret") || key.startsWith("scrollbar") || key.startsWith("selection");
  }
}
var conditionals = ["sm", "md", "lg", "xl", "2xl", "focus", "hover", "active", "dark"];
function convertProperties(propertyTypes, properties, colorMap, convertKey) {
  let result;
  const set = (key, value) => {
    const converted = convertProperty(propertyTypes, key, value, colorMap);
    if (converted == null) {
      return;
    }
    if (result == null) {
      result = {};
    }
    result[key] = converted;
  };
  for (let key in properties) {
    let property = properties[key];
    if (conditionals.includes(key) && property != null && typeof property === "object") {
      const conditionalProperties = convertProperties(propertyTypes, property, colorMap, convertKey);
      if (conditionalProperties != null) {
        if (result == null) {
          result = {};
        }
        result[key] = conditionalProperties;
        continue;
      }
    }
    if (key in propertyRenamings) {
      key = propertyRenamings[key];
    }
    if (convertKey != null) {
      key = convertKey(key);
    }
    if (key in customCssTranslation) {
      customCssTranslation[key](set, property);
      continue;
    }
    if (key === "positionType" && property === "fixed") {
      property = "absolute";
    }
    if (key === "display" && property === "block") {
      property = "flex";
    }
    if (key === "overflow" && property === "auto") {
      property = "scroll";
    }
    if (key === "borderColor" && property === "transparent") {
      key = "borderOpacity";
      property = "0";
    }
    if (key === "backgroundColor" && property === "transparent") {
      if (result == null) {
        result = {};
      }
      result[key] = void 0;
      return;
    }
    if (key === "opacity") {
      set("backgroundOpacity", property);
    }
    set(key, property);
  }
  return result;
}
var nonDigitRegex = /[^\d\.-]/;
function convertProperty(propertyTypes, key, value, colorMap) {
  if (key === "panelMaterialClass") {
    return value;
  }
  if (Array.isArray(propertyTypes)) {
    return firstNotNull(propertyTypes, (type) => convertProperty(type, key, value, colorMap));
  }
  const types = propertyTypes[key];
  if (types == null) {
    return void 0;
  }
  return firstNotNull(types, (type) => {
    if (Array.isArray(type)) {
      return typeof value === "string" && type.includes(value) ? value : void 0;
    }
    if (type === "boolean") {
      return value != "false";
    }
    if (type === "string") {
      return typeof value === "string" ? applyCustomColor(value, colorMap) ?? value : void 0;
    }
    if (type === "percentage") {
      return typeof value === "string" && percentageRegex.test(value) ? value : void 0;
    }
    let result = toNumber(value);
    if (result != null && key === "lineHeight" && !nonDigitRegex.test(value)) {
      return `${result * 100}%`;
    }
    return result;
  });
}
function firstNotNull(array, fn3) {
  const length = array.length;
  for (let i2 = 0; i2 < length; i2++) {
    const result = fn3(array[i2]);
    if (result != null) {
      return result;
    }
  }
  return void 0;
}
var divisionExpression = /(\d+)\s*\/\s*(\d+)/;
var digitsWithUnitRegex = /^(-?\d+|\d*\.\d+)([^\s\d]*)$/;
var unitMultiplierMap = {
  rem: 16,
  em: 16,
  px: 1,
  "": 1
};
function toNumber(value) {
  let result;
  result = digitsWithUnitRegex.exec(value);
  if (result != null) {
    const [, float, unit] = result;
    const multiplier2 = unitMultiplierMap[unit];
    if (multiplier2 != null) {
      return Number.parseFloat(float) * multiplier2;
    }
  }
  result = divisionExpression.exec(value);
  if (result != null) {
    const [, a2, b3] = result;
    return Number.parseFloat(a2) / Number.parseFloat(b3);
  }
}
var variableRegex = /^\$(.+)$/;
function applyCustomColor(value, customColors) {
  if (customColors == null) {
    return void 0;
  }
  const result = variableRegex.exec(value);
  if (result == null) {
    return value;
  }
  const entry = customColors[result[1]];
  if (entry == null) {
    throw new Error(`unknown custom color "${result[1]}"`);
  }
  if (typeof entry === "function") {
    return entry();
  }
  return entry;
}

// node_modules/@pmndrs/uikit/dist/convert/html/internals.js
var import_node_html_parser2 = __toESM(require_dist(), 1);
var styleTagRegex = /\<style\>(?:.|\s)*?\<\/style\>/gm;
var cssClassRegex = /\s*\.([^\{]+)\s*\{([^}]*)\}/g;
var cssPropsRegex = /([^:\s]+)\s*\:\s*([^;\s]+(?:[ \t]+[^;\s]+)*)\s*\;?\s*/g;
var spaceXYRegex = /(-?)space-(x|y)-(\d+)/g;
var PlasticMaterial = class extends MeshPhongMaterial {
  constructor() {
    super({
      specular: "#111",
      shininess: 100
    });
  }
};
var GlassMaterial = class extends MeshPhysicalMaterial {
  constructor() {
    super({
      transmission: 0.5,
      roughness: 0.1,
      reflectivity: 0.5,
      iridescence: 0.4,
      thickness: 0.05,
      specularIntensity: 1,
      metalness: 0.3,
      ior: 2,
      envMapIntensity: 1
    });
  }
};
var MetalMaterial = class extends MeshPhysicalMaterial {
  constructor() {
    super({
      metalness: 0.8,
      roughness: 0.1
    });
  }
};
var voidTagRegex = /<((\S+).*)\/>/g;
var mediaQueryRegex = /@media\(min-width:(\d+)px\)([^@]+)/gm;
var breakpoints = {
  "640": "sm",
  "768": "md",
  "1024": "lg",
  "1280": "xl",
  "1536": "2xl"
};
function parseHtml(text, colorMap) {
  text = text.replaceAll(styleTagRegex, "").replaceAll(voidTagRegex, (_3, tagContent, tagName) => `<${tagContent}></${tagName}>`);
  const element = (0, import_node_html_parser.parse)(text, { voidTag: { tags: [] } });
  const themeColors = {};
  for (const key in colorMap) {
    themeColors[key.replaceAll(/([A-Z])/g, (_3, char) => `-${char.toLowerCase()}`)] = `$${key}`;
  }
  const classes = /* @__PURE__ */ new Map([
    [
      "material-plastic",
      {
        panelMaterialClass: PlasticMaterial
      }
    ],
    [
      "material-metal",
      {
        panelMaterialClass: MetalMaterial
      }
    ],
    [
      "material-glass",
      {
        panelMaterialClass: GlassMaterial
      }
    ],
    [
      "border-bend",
      {
        borderBend: 0.5
      }
    ],
    [
      "inline-flex",
      {
        alignSelf: "flex-start"
      }
    ]
  ]);
  const css = Op({
    config: {
      theme: {
        extend: {
          colors: themeColors
        }
      }
    }
  }).twi(collectClasses(element).replaceAll(conditionalRegex, (_3, _selector, className) => className).replaceAll(spaceXYRegex, (className, negative, dir, value) => {
    const multiplier2 = negative === "-" ? -1 : 1;
    switch (dir) {
      case "x":
        classes.set(className, { flexDirection: "row", columnGap: parseFloat(value) * 4 * multiplier2 });
        break;
      case "y":
        classes.set(className, { flexDirection: "column", rowGap: parseFloat(value) * 4 * multiplier2 });
        break;
    }
    return "";
  }), { merge: false, ignoreMediaQueries: false }).replaceAll(/\\(.)/g, (_3, result) => result).replaceAll(mediaQueryRegex, (_3, breakpoint, content) => {
    const prefix = breakpoints[breakpoint];
    if (prefix == null) {
      return "";
    }
    content = content.slice(1, -1);
    parseCssClassDefinitions(content, (key, properties) => {
      const existingProperties = classes.get(key) ?? {};
      classes.set(key, { ...existingProperties, [prefix]: { ...existingProperties[prefix], ...properties } });
    });
    return "";
  });
  parseCssClassDefinitions(css, (key, properties) => classes.set(key, { ...classes.get(key), ...properties }));
  return { classes, element };
}
function parseCssClassDefinitions(css, set) {
  let classesResult;
  let contentResult;
  while ((classesResult = cssClassRegex.exec(css)) != null) {
    const [, className, classContent] = classesResult;
    const properties = {};
    while ((contentResult = cssPropsRegex.exec(classContent)) != null) {
      const [, name, value] = contentResult;
      properties[kebabToCamelCase(name)] = value;
    }
    set(className, properties);
  }
}
function collectClasses(element) {
  let result = "";
  if (element instanceof import_node_html_parser.HTMLElement) {
    result += " " + (element.classNames ?? "");
    result += " " + (element.attributes.className ?? "");
  }
  const childrenLength = element.childNodes.length;
  for (let i2 = 0; i2 < childrenLength; i2++) {
    result += collectClasses(element.childNodes[i2]);
  }
  return result;
}
function convertParsedHtml(element, classes, generate, colorMap, componentMap) {
  return convertParsedHtmlRecursive(element, classes, 0, generate, colorMap, componentMap);
}
var conversionPropertyTypes = {
  Inheriting: generatedPropertyTypes.Inheriting,
  Container: [generatedPropertyTypes.Inheriting, generatedPropertyTypes.Shared, generatedPropertyTypes.Container],
  Icon: [generatedPropertyTypes.Inheriting, generatedPropertyTypes.Shared, generatedPropertyTypes.Icon],
  Image: [generatedPropertyTypes.Inheriting, generatedPropertyTypes.Shared, generatedPropertyTypes.Image],
  Input: [generatedPropertyTypes.Inheriting, generatedPropertyTypes.Shared, generatedPropertyTypes.Input],
  Svg: [generatedPropertyTypes.Inheriting, generatedPropertyTypes.Shared, generatedPropertyTypes.Svg],
  Text: [generatedPropertyTypes.Inheriting, generatedPropertyTypes.Shared, generatedPropertyTypes.Text],
  Video: [generatedPropertyTypes.Inheriting, generatedPropertyTypes.Shared, generatedPropertyTypes.Video]
};
function convertParsedHtmlRecursive(element, classes, index, generate, colorMap, componentMap) {
  var _a;
  if (element instanceof import_node_html_parser.HTMLElement && ((_a = element.tagName) == null ? void 0 : _a.toLowerCase()) === "svg") {
    const { width, height, ...restAttributes } = element.attributes;
    const { inheritingProperties: inheritingProperties2, properties: properties2, srOnly: srOnly2 } = convertMergeSortProperties(false, [...conversionPropertyTypes.Icon, { svgWidth: ["number"], svgHeight: ["number"] }], classes, { svgWidth: toNumber(width) ?? 24, svgHeight: toNumber(height) ?? 24, text: element.toString() }, restAttributes, colorMap);
    if (srOnly2) {
      return void 0;
    }
    return generate(element, "Icon", false, { ...inheritingProperties2, ...properties2 }, index);
  }
  const [{ skipIfEmpty, defaultProperties, children, propertyTypes, renderAs }, custom] = nodeToConversionData(element, componentMap);
  if (skipIfEmpty && element.childNodes.length === 0) {
    return void 0;
  }
  if (skipIfEmpty && element.childNodes.length === 1) {
    return convertParsedHtmlRecursive(element.childNodes[0], classes, index, generate, colorMap, componentMap);
  }
  const { inheritingProperties, properties, srOnly } = element instanceof import_node_html_parser.HTMLElement ? convertMergeSortProperties(custom, propertyTypes, classes, defaultProperties, element.attributes, colorMap) : { inheritingProperties: void 0, properties: void 0, srOnly: false };
  if (srOnly) {
    return void 0;
  }
  switch (children) {
    case "none":
      return generate(element, renderAs, custom, { ...inheritingProperties, ...properties }, index);
    case "text":
      if (!(element instanceof import_node_html_parser.TextNode)) {
        return generate(element, renderAs, custom, { ...inheritingProperties, ...properties }, index, element.childNodes.filter(filterTextNode).map((e2) => e2.text.trim()).filter((text2) => text2.length > 0));
      }
      const text = element.text.trim();
      if (text.length === 0) {
        return void 0;
      }
      return generate(element, renderAs, custom, { ...inheritingProperties, ...properties }, index, [text]);
  }
  let result = generate(element, renderAs, custom, properties ?? {}, index, element.childNodes.map((node, i2) => convertParsedHtmlRecursive(node, classes, i2, generate, colorMap, componentMap)).filter(filterNull));
  if (inheritingProperties == null || Object.keys(inheritingProperties).length > 0) {
    result = generate(void 0, "DefaultProperties", false, inheritingProperties ?? {}, index, [result]);
  }
  return result;
}
function filterTextNode(val) {
  return val instanceof import_node_html_parser.TextNode;
}
function nodeToConversionData(element, customComponents) {
  if (element instanceof import_node_html_parser.TextNode) {
    return [
      {
        propertyTypes: conversionPropertyTypes.Text,
        renderAs: "Text",
        children: "text"
      },
      false
    ];
  }
  if (element.rawTagName == null) {
    return [
      {
        skipIfEmpty: true,
        propertyTypes: {},
        renderAs: "Fragment"
      },
      false
    ];
  }
  if (customComponents != null && element.rawTagName in customComponents) {
    return [customComponents[element.rawTagName], true];
  }
  let { children, defaultProperties, renderAs, skipIfEmpty } = htmlDefaults[element.rawTagName.toLowerCase()] ?? {};
  if (element.childNodes.length > 0 && element.childNodes.every((e2) => e2 instanceof import_node_html_parser.TextNode) && element.childNodes.some((e2) => e2 instanceof import_node_html_parser.TextNode && e2.text.trim().length > 0)) {
    renderAs ?? (renderAs = "Text");
    children ?? (children = "text");
  }
  renderAs ?? (renderAs = "Container");
  return [
    {
      propertyTypes: conversionPropertyTypes[renderAs],
      renderAs,
      children,
      defaultProperties,
      skipIfEmpty
    },
    false
  ];
}
function filterNull(val) {
  return val != null;
}
function convertMergeSortProperties(custom, propertyTypes, classes, defaultProperties, attributes, colorMap) {
  const [properties, srOnly] = convertHtmlAttributes(custom, propertyTypes, classes, attributes, colorMap);
  const result = {
    ...defaultProperties,
    ...properties
  };
  const inheritingProperties = {};
  for (const key in result) {
    if (!isInheritingProperty(key)) {
      continue;
    }
    inheritingProperties[key] = result[key];
    delete result[key];
  }
  return {
    inheritingProperties,
    properties: result,
    srOnly
  };
}
var kebebToCamelRegex = /-([a-zA-z])/g;
function kebabToCamelCase(name) {
  return name.replaceAll(kebebToCamelRegex, (_3, group) => group.toUpperCase());
}
function convertHtmlAttributes(custom, propertyTypes, classes, { class: _class, className, style, ...rest }, colorMap) {
  let srOnly = false;
  const result = convertProperties(propertyTypes, rest, colorMap, kebabToCamelCase) ?? {};
  if (_class != null) {
    if (_class.includes("sr-only")) {
      srOnly = true;
    }
    Object.assign(result, convertTailwind(propertyTypes, classes, _class, colorMap));
  }
  if (className != null) {
    if (className.includes("sr-only")) {
      srOnly = true;
    }
    Object.assign(result, convertTailwind(propertyTypes, classes, className, colorMap));
  }
  let styles = [];
  try {
    if (style != null) {
      styles = (0, import_inline_style_parser.default)(style);
    }
  } catch {
  }
  const stylesMap = {};
  for (const style2 of styles) {
    if (style2.type === "comment") {
      continue;
    }
    stylesMap[kebabToCamelCase(style2.property)] = style2.value;
  }
  Object.assign(result, convertProperties(propertyTypes, stylesMap, colorMap, kebabToCamelCase) ?? {});
  if (!custom && !("display" in result) && !("flexDirection" in result)) {
    const key = "flexDirection";
    const value = convertProperty(propertyTypes, key, "column", colorMap);
    if (value != null) {
      result[key] = value;
    }
  }
  return [result, srOnly];
}
var nonWhitespaceRegex = /\S+/g;
function tailwindToJson(classNames, classes) {
  const result = {};
  let classNameResult;
  while ((classNameResult = nonWhitespaceRegex.exec(classNames)) != null) {
    const [className] = classNameResult;
    const classesEntry = classes.get(className);
    if (classesEntry == null) {
      continue;
    }
    Object.assign(result, classesEntry);
  }
  return result;
}
var conditionalRegex = /(\S+)\:(\S+)/g;
function convertTailwind(propertyTypes, classes, className, colorMap) {
  const properties = {};
  const withoutConditionals = className.replaceAll(conditionalRegex, (_3, conditional, value) => {
    properties[conditional] = {
      ...properties[conditional],
      ...tailwindToJson(value, classes)
    };
    return "";
  });
  Object.assign(properties, tailwindToJson(withoutConditionals, classes));
  return convertProperties(propertyTypes, properties, colorMap) ?? {};
}

// node_modules/@react-three/uikit/dist/font.js
var import_react = __toESM(require_react(), 1);
var FontFamiliesContext = (0, import_react.createContext)(null);
function FontFamilyProvider(properties) {
  let { children, ...fontFamilies } = properties;
  const existinFontFamilyUrls = (0, import_react.useContext)(FontFamiliesContext);
  if (existinFontFamilyUrls != null) {
    fontFamilies = { ...existinFontFamilyUrls, ...fontFamilies };
  }
  return (0, import_jsx_runtime.jsx)(FontFamiliesContext.Provider, { value: fontFamilies, children });
}
function useFontFamilies() {
  return (0, import_react.useContext)(FontFamiliesContext);
}
function useMeasureText(fontFamily, fontWeight) {
  const fontFamilies = useFontFamilies();
  const propertiesSignal = (0, import_react.useMemo)(() => d(new MergedProperties()), []);
  propertiesSignal.value = new MergedProperties();
  propertiesSignal.value.add("fontFamily", fontFamily);
  propertiesSignal.value.add("fontWeight", fontWeight);
  const initializers = (0, import_react.useMemo)(() => [], []);
  const renderer = useThree((state) => state.gl);
  const font = (0, import_react.useMemo)(() => computedFont(propertiesSignal, d(fontFamilies), renderer, initializers), [fontFamilies, initializers, propertiesSignal, renderer]);
  (0, import_react.useEffect)(() => {
    const subscriptions = [];
    initialize(initializers, subscriptions);
    return () => unsubscribeSubscriptions(subscriptions);
  }, [initializers]);
  return (0, import_react.useCallback)(async (properties) => {
    let fontValue = font.peek();
    if (fontValue == null) {
      fontValue = await new Promise((resolve) => {
        const unsubscribe = font.subscribe((font2) => {
          if (font2 == null) {
            return;
          }
          unsubscribe();
          resolve(font2);
        });
      });
    }
    return measureGlyphLayout({ ...properties, font: fontValue }, properties.availableWidth);
  }, [font]);
}

// node_modules/@react-three/uikit/dist/context.js
var import_react2 = __toESM(require_react(), 1);
var ParentContext = (0, import_react2.createContext)(void 0);
function useParent() {
  const parent = (0, import_react2.useContext)(ParentContext);
  if (parent == null) {
    throw new Error(`Cannot be used outside of a uikit component.`);
  }
  return parent;
}
var ParentProvider = ParentContext.Provider;

// node_modules/@react-three/uikit/dist/responsive.js
function useRootSize() {
  return useParent().root.size;
}

// node_modules/@pmndrs/uikit/dist/vanilla/fullscreen.js
var vectorHelper5 = new Vector2();

// node_modules/@react-three/uikit/dist/default.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);
var DefaultPropertiesContext = (0, import_react3.createContext)(void 0);
function useDefaultProperties() {
  return (0, import_react3.useContext)(DefaultPropertiesContext);
}
function DefaultProperties(properties) {
  const existingDefaultProperties = (0, import_react3.useContext)(DefaultPropertiesContext);
  const result = { ...existingDefaultProperties };
  for (const key in properties) {
    if (key === "children") {
      continue;
    }
    const value = properties[key];
    if (value == null) {
      continue;
    }
    result[key] = value;
  }
  return (0, import_jsx_runtime2.jsx)(DefaultPropertiesContext.Provider, { value: result, children: properties.children });
}

// node_modules/@react-three/uikit/dist/container.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react6 = __toESM(require_react(), 1);

// node_modules/@react-three/uikit/dist/utilts.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react4 = __toESM(require_react(), 1);
var eventHandlerKeys = [
  "onClick",
  "onContextMenu",
  "onDoubleClick",
  "onPointerCancel",
  "onPointerDown",
  "onPointerEnter",
  "onPointerLeave",
  "onPointerMissed",
  "onPointerMove",
  "onPointerOut",
  "onPointerOver",
  "onPointerUp",
  "onWheel"
];
var AddHandlers = (0, import_react4.forwardRef)(({ handlers: handlersSignal, allowSkippingChildren, userHandlers, children }, ref) => {
  const [systemHandlers, setSystemHandlers] = (0, import_react4.useState)(() => handlersSignal.peek());
  (0, import_react4.useEffect)(() => E(() => {
    const handlers2 = handlersSignal.value;
    const ref2 = void setTimeout(() => setSystemHandlers(handlers2), 0);
    return () => clearTimeout(ref2);
  }), [handlersSignal]);
  const handlers = (0, import_react4.useMemo)(() => {
    const result = { ...systemHandlers };
    const keysLength = eventHandlerKeys.length;
    for (let i2 = 0; i2 < keysLength; i2++) {
      const key = eventHandlerKeys[i2];
      addHandler(key, result, userHandlers[key]);
    }
    if (Object.keys(result).length === 0) {
      return void 0;
    }
    return result;
  }, [systemHandlers, userHandlers]);
  if (allowSkippingChildren && handlers == null) {
    return null;
  }
  return (0, import_jsx_runtime3.jsx)("object3D", { ref, matrixAutoUpdate: false, ...handlers, children });
});
function usePropertySignals(properties) {
  const propertySignals = (0, import_react4.useMemo)(() => ({
    style: d(void 0),
    properties: d(void 0),
    default: d(void 0)
  }), []);
  propertySignals.properties.value = properties;
  propertySignals.default.value = useDefaultProperties();
  return propertySignals;
}

// node_modules/@react-three/uikit/dist/ref.js
var import_react5 = __toESM(require_react(), 1);
function useComponentInternals(ref, pixelSize, styleSignal, internals, interactionPanel, additional) {
  (0, import_react5.useImperativeHandle)(ref, () => {
    const { scrollPosition, paddingInset, borderInset, relativeCenter, size, maxScrollPosition } = internals;
    return {
      setStyle: (style) => styleSignal.value = style,
      getStyle: () => styleSignal.peek(),
      getComputedProperty: (key) => n(() => internals.mergedProperties.value.read(key, void 0)),
      pixelSize,
      borderInset,
      paddingInset,
      center: relativeCenter,
      maxScrollPosition,
      size,
      interactionPanel: interactionPanel instanceof Mesh ? interactionPanel : interactionPanel.current,
      scrollPosition,
      isClipped: internals.isClipped,
      ...additional
    };
  }, [internals, pixelSize, interactionPanel, additional, styleSignal]);
}

// node_modules/@react-three/uikit/dist/container.js
var Container = (0, import_react6.forwardRef)((properties, ref) => {
  const parent = useParent();
  const outerRef = (0, import_react6.useRef)(null);
  const innerRef = (0, import_react6.useRef)(null);
  const propertySignals = usePropertySignals(properties);
  const internals = (0, import_react6.useMemo)(() => createContainer(parent, propertySignals.style, propertySignals.properties, propertySignals.default, outerRef, innerRef), [parent, propertySignals]);
  internals.interactionPanel.name = properties.name ?? "";
  (0, import_react6.useEffect)(() => {
    const subscriptions = [];
    initialize(internals.initializers, subscriptions);
    return () => unsubscribeSubscriptions(subscriptions);
  }, [parent, propertySignals, internals]);
  useComponentInternals(ref, parent.root.pixelSize, propertySignals.style, internals, internals.interactionPanel);
  return (0, import_jsx_runtime4.jsxs)(AddHandlers, { userHandlers: properties, handlers: internals.handlers, ref: outerRef, children: [(0, import_jsx_runtime4.jsx)("primitive", { object: internals.interactionPanel }), (0, import_jsx_runtime4.jsx)("object3D", { matrixAutoUpdate: false, ref: innerRef, children: (0, import_jsx_runtime4.jsx)(ParentProvider, { value: internals, children: properties.children }) })] });
});

// node_modules/@react-three/uikit/dist/root.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);
var Root2 = (0, import_react7.forwardRef)((properties, ref) => {
  const renderer = useThree((state) => state.gl);
  renderer.setTransparentSort(reversePainterSortStable);
  const store = useStore();
  const outerRef = (0, import_react7.useRef)(null);
  const innerRef = (0, import_react7.useRef)(null);
  const pixelSizeSignal = (0, import_react7.useMemo)(() => d(void 0), []);
  pixelSizeSignal.value = properties.pixelSize;
  const propertySignals = usePropertySignals(properties);
  const onFrameSet = (0, import_react7.useMemo)(() => /* @__PURE__ */ new Set(), []);
  const whileOnFrameRef = (0, import_react7.useRef)(false);
  const invalidate = useThree((s2) => s2.invalidate);
  const internals = (0, import_react7.useMemo)(
    () => createRoot(
      w(() => readReactive(pixelSizeSignal.value) ?? DEFAULT_PIXEL_SIZE),
      propertySignals.style,
      propertySignals.properties,
      propertySignals.default,
      outerRef,
      innerRef,
      () => store.getState().camera,
      renderer,
      onFrameSet,
      () => {
        if (whileOnFrameRef.current) {
          return;
        }
        invalidate();
      },
      //requestFrame = invalidate, because invalidate always causes another frame
      invalidate
    ),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [invalidate]
  );
  internals.interactionPanel.name = properties.name ?? "";
  (0, import_react7.useEffect)(() => {
    const subscriptions = [];
    initialize(internals.initializers, subscriptions);
    return () => unsubscribeSubscriptions(subscriptions);
  }, [internals]);
  useFrame((_3, delta) => {
    whileOnFrameRef.current = true;
    for (const onFrame of onFrameSet) {
      onFrame(delta);
    }
    whileOnFrameRef.current = false;
  });
  useComponentInternals(ref, internals.root.pixelSize, propertySignals.style, internals, internals.interactionPanel);
  return (0, import_jsx_runtime5.jsxs)(AddHandlers, { userHandlers: properties, handlers: internals.handlers, ref: outerRef, children: [(0, import_jsx_runtime5.jsx)("primitive", { object: internals.interactionPanel }), (0, import_jsx_runtime5.jsx)("object3D", { matrixAutoUpdate: false, ref: innerRef, children: (0, import_jsx_runtime5.jsx)(ParentProvider, { value: internals, children: properties.children }) })] });
});

// node_modules/@react-three/uikit/dist/image.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);
var Image2 = (0, import_react8.forwardRef)((properties, ref) => {
  const parent = useParent();
  const outerRef = (0, import_react8.useRef)(null);
  const innerRef = (0, import_react8.useRef)(null);
  const propertySignals = usePropertySignals(properties);
  const internals = (0, import_react8.useMemo)(
    () => createImage(parent, propertySignals.style, propertySignals.properties, propertySignals.default, outerRef, innerRef),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  internals.interactionPanel.name = properties.name ?? "";
  (0, import_react8.useEffect)(() => {
    const subscriptions = [];
    initialize(internals.initializers, subscriptions);
    return () => unsubscribeSubscriptions(subscriptions);
  }, [internals]);
  useComponentInternals(ref, parent.root.pixelSize, propertySignals.style, internals, internals.interactionPanel);
  return (0, import_jsx_runtime6.jsxs)(AddHandlers, { userHandlers: properties, ref: outerRef, handlers: internals.handlers, children: [(0, import_jsx_runtime6.jsx)("primitive", { object: internals.interactionPanel }), (0, import_jsx_runtime6.jsx)("object3D", { matrixAutoUpdate: false, ref: innerRef, children: (0, import_jsx_runtime6.jsx)(ParentProvider, { value: internals, children: properties.children }) })] });
});

// node_modules/@react-three/uikit/dist/text.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react9 = __toESM(require_react(), 1);
var Text = (0, import_react9.forwardRef)((properties, ref) => {
  const parent = useParent();
  const outerRef = (0, import_react9.useRef)(null);
  const propertySignals = usePropertySignals(properties);
  const textSignal = (0, import_react9.useMemo)(() => d(void 0), []);
  textSignal.value = properties.children;
  const fontFamilies = (0, import_react9.useMemo)(() => d(void 0), []);
  fontFamilies.value = useFontFamilies();
  const internals = (0, import_react9.useMemo)(() => createText(parent, textSignal, fontFamilies, propertySignals.style, propertySignals.properties, propertySignals.default, outerRef), [fontFamilies, parent, propertySignals, textSignal]);
  internals.interactionPanel.name = properties.name ?? "";
  (0, import_react9.useEffect)(() => {
    const subscriptions = [];
    initialize(internals.initializers, subscriptions);
    return () => unsubscribeSubscriptions(subscriptions);
  }, [internals]);
  useComponentInternals(ref, parent.root.pixelSize, propertySignals.style, internals, internals.interactionPanel);
  return (0, import_jsx_runtime7.jsx)(AddHandlers, { allowSkippingChildren: true, userHandlers: properties, handlers: internals.handlers, ref: outerRef, children: (0, import_jsx_runtime7.jsx)("primitive", { object: internals.interactionPanel }) });
});

// node_modules/@react-three/uikit/dist/svg.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_react10 = __toESM(require_react(), 1);
var Svg = (0, import_react10.forwardRef)((properties, ref) => {
  const parent = useParent();
  const outerRef = (0, import_react10.useRef)(null);
  const innerRef = (0, import_react10.useRef)(null);
  const propertySignals = usePropertySignals(properties);
  const internals = (0, import_react10.useMemo)(() => createSvg(parent, propertySignals.style, propertySignals.properties, propertySignals.default, outerRef, innerRef), [parent, propertySignals]);
  internals.interactionPanel.name = properties.name ?? "";
  (0, import_react10.useEffect)(() => {
    const subscriptions = [];
    initialize(internals.initializers, subscriptions);
    return () => unsubscribeSubscriptions(subscriptions);
  }, [internals]);
  useComponentInternals(ref, parent.root.pixelSize, propertySignals.style, internals, internals.interactionPanel);
  return (0, import_jsx_runtime8.jsxs)(AddHandlers, { userHandlers: properties, ref: outerRef, handlers: internals.handlers, children: [(0, import_jsx_runtime8.jsx)("primitive", { object: internals.interactionPanel }), (0, import_jsx_runtime8.jsx)("primitive", { object: internals.centerGroup }), (0, import_jsx_runtime8.jsx)("object3D", { matrixAutoUpdate: false, ref: innerRef, children: (0, import_jsx_runtime8.jsx)(ParentProvider, { value: internals, children: properties.children }) })] });
});

// node_modules/@react-three/uikit/dist/icon.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_react11 = __toESM(require_react(), 1);
var Icon = (0, import_react11.forwardRef)((properties, ref) => {
  const parent = useParent();
  const outerRef = (0, import_react11.useRef)(null);
  const propertySignals = usePropertySignals(properties);
  const internals = (0, import_react11.useMemo)(() => createIcon(parent, properties.text, properties.svgWidth, properties.svgHeight, propertySignals.style, propertySignals.properties, propertySignals.default, outerRef), [parent, properties.svgHeight, properties.svgWidth, properties.text, propertySignals]);
  internals.interactionPanel.name = properties.name ?? "";
  (0, import_react11.useEffect)(() => {
    const subscriptions = [];
    initialize(internals.initializers, subscriptions);
    return () => unsubscribeSubscriptions(subscriptions);
  }, [internals]);
  useComponentInternals(ref, parent.root.pixelSize, propertySignals.style, internals, internals.interactionPanel);
  return (0, import_jsx_runtime9.jsxs)(AddHandlers, { userHandlers: properties, ref: outerRef, handlers: internals.handlers, children: [(0, import_jsx_runtime9.jsx)("primitive", { object: internals.interactionPanel }), (0, import_jsx_runtime9.jsx)("primitive", { object: internals.iconGroup })] });
});

// node_modules/@react-three/uikit/dist/input.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var import_react12 = __toESM(require_react(), 1);
var Input = (0, import_react12.forwardRef)((properties, ref) => {
  const parent = useParent();
  const outerRef = (0, import_react12.useRef)(null);
  const propertySignals = usePropertySignals(properties);
  const fontFamilies = (0, import_react12.useMemo)(() => d(void 0), []);
  fontFamilies.value = useFontFamilies();
  const internals = (0, import_react12.useMemo)(
    () => createInput(parent, fontFamilies, propertySignals.style, propertySignals.properties, propertySignals.default, outerRef),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  internals.interactionPanel.name = properties.name ?? "";
  (0, import_react12.useEffect)(() => {
    const subscriptions = [];
    initialize(internals.initializers, subscriptions);
    return () => unsubscribeSubscriptions(subscriptions);
  }, [internals]);
  useComponentInternals(ref, parent.root.pixelSize, propertySignals.style, internals, internals.interactionPanel, (0, import_react12.useMemo)(() => ({ focus: internals.focus, current: internals.valueSignal }), [internals.focus, internals.valueSignal]));
  return (0, import_jsx_runtime10.jsx)(AddHandlers, { allowSkippingChildren: true, userHandlers: properties, handlers: internals.handlers, ref: outerRef, children: (0, import_jsx_runtime10.jsx)("primitive", { object: internals.interactionPanel }) });
});

// node_modules/@react-three/uikit/dist/custom.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var import_react13 = __toESM(require_react(), 1);
var CustomContainer = (0, import_react13.forwardRef)((properties, ref) => {
  const parent = useParent();
  const outerRef = (0, import_react13.useRef)(null);
  const innerRef = (0, import_react13.useRef)(null);
  const propertySignals = usePropertySignals(properties);
  const internals = (0, import_react13.useMemo)(() => createCustomContainer(parent, propertySignals.style, propertySignals.properties, propertySignals.default, outerRef, innerRef), [parent, propertySignals]);
  (0, import_react13.useEffect)(() => {
    const subscriptions = [];
    initialize(internals.initializers, subscriptions);
    return () => unsubscribeSubscriptions(subscriptions);
  }, [internals]);
  useComponentInternals(ref, parent.root.pixelSize, propertySignals.style, internals, innerRef);
  (0, import_react13.useEffect)(() => {
    if (innerRef.current && properties.name) {
      innerRef.current.name = properties.name;
    }
  }, [properties.name]);
  return (0, import_jsx_runtime11.jsx)(AddHandlers, { userHandlers: properties, handlers: internals.handlers, ref: outerRef, children: (0, import_jsx_runtime11.jsx)(ParentProvider, { value: void 0, children: (0, import_jsx_runtime11.jsx)("mesh", { ref: innerRef, matrixAutoUpdate: false, geometry: panelGeometry, customDepthMaterial: properties.customDepthMaterial, customDistanceMaterial: properties.customDistanceMaterial, children: properties.children }) }) });
});

// node_modules/@react-three/uikit/dist/content.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var import_react14 = __toESM(require_react(), 1);
var Content = (0, import_react14.forwardRef)((properties, ref) => {
  const parent = useParent();
  const outerRef = (0, import_react14.useRef)(null);
  const innerRef = (0, import_react14.useRef)(null);
  const propertySignals = usePropertySignals(properties);
  const internals = (0, import_react14.useMemo)(() => createContent(parent, propertySignals.style, propertySignals.properties, propertySignals.default, outerRef, innerRef), [parent, propertySignals]);
  internals.interactionPanel.name = properties.name ?? "";
  (0, import_react14.useEffect)(() => {
    const subscriptions = [];
    initialize(internals.initializers, subscriptions);
    return () => unsubscribeSubscriptions(subscriptions);
  }, [internals]);
  useComponentInternals(ref, parent.root.pixelSize, propertySignals.style, internals, internals.interactionPanel);
  return (0, import_jsx_runtime12.jsxs)(AddHandlers, { userHandlers: properties, handlers: internals.handlers, ref: outerRef, children: [(0, import_jsx_runtime12.jsx)("primitive", { object: internals.interactionPanel }), (0, import_jsx_runtime12.jsx)("object3D", { matrixAutoUpdate: false, ref: innerRef, children: (0, import_jsx_runtime12.jsx)(ParentProvider, { value: void 0, children: properties.children }) })] });
});

// node_modules/@react-three/uikit/dist/fullscreen.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var import_react15 = __toESM(require_react(), 1);
var Fullscreen = (0, import_react15.forwardRef)((properties, ref) => {
  const store = useStore();
  const [sizeX, sizeY, pixelSize] = (0, import_react15.useMemo)(() => [d(1), d(1), d(1)], []);
  const camera = useThree((s2) => s2.camera);
  const distanceToCamera = properties.distanceToCamera ?? camera.near + 0.1;
  (0, import_react15.useEffect)(() => {
    const fn3 = ({ camera: camera2, size: { height } }) => r(() => updateSizeFullscreen(sizeX, sizeY, pixelSize, distanceToCamera, camera2, height));
    fn3(store.getState());
    return store.subscribe(fn3);
  }, [pixelSize, sizeX, sizeY, store, distanceToCamera]);
  const attachCamera = properties.attachCamera ?? true;
  return (0, import_jsx_runtime13.jsxs)(import_jsx_runtime13.Fragment, { children: [attachCamera && (0, import_jsx_runtime13.jsx)("primitive", { object: camera }), createPortal((0, import_jsx_runtime13.jsx)("group", { "position-z": -distanceToCamera, children: (0, import_jsx_runtime13.jsx)(Root2, { ref, ...properties, sizeX, sizeY, pixelSize, children: properties.children }) }), camera)] });
});

// node_modules/@react-three/uikit/dist/suspending.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var import_react16 = __toESM(require_react(), 1);
var SuspendingImage = (0, import_react16.forwardRef)(({ src, ...props }, ref) => {
  const texture = useLoader(TextureLoader, src);
  texture.colorSpace = SRGBColorSpace;
  texture.matrixAutoUpdate = false;
  return (0, import_jsx_runtime14.jsx)(Image2, { ref, src: texture, ...props });
});

// node_modules/@react-three/uikit/dist/portal.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var import_react17 = __toESM(require_react(), 1);
var privateKeys = [
  "set",
  "get",
  "setSize",
  "setFrameloop",
  "setDpr",
  "events",
  "invalidate",
  "advance",
  "size",
  "viewport"
];
var isOrthographicCamera = (def) => def && def.isOrthographicCamera;
var Portal = (0, import_react17.forwardRef)(({ children, dpr, frames = Infinity, renderPriority = 0, eventPriority = 0, ...props }, ref) => {
  const fbo = (0, import_react17.useMemo)(() => new u(void 0), []);
  const imageRef = (0, import_react17.useRef)(null);
  const previousRoot = useStore();
  dpr ?? (dpr = previousRoot.getState().viewport.dpr);
  (0, import_react17.useImperativeHandle)(ref, () => imageRef.current, []);
  const texture = (0, import_react17.useMemo)(() => w(() => {
    var _a;
    return (_a = fbo.value) == null ? void 0 : _a.texture;
  }), [fbo]);
  const usePortalStore = (0, import_react17.useMemo)(() => {
    let previousState = previousRoot.getState();
    const camera = new PerspectiveCamera(50, 1, 0.1, 1e3);
    camera.position.set(0, 0, 5);
    const pointer = new Vector2();
    let ownState = {
      events: { compute: uvCompute.bind(null, imageRef), priority: eventPriority },
      size: { width: 1, height: 1, left: 0, top: 0 },
      camera,
      scene: new Scene(),
      raycaster: new Raycaster(),
      pointer,
      mouse: pointer,
      previousRoot
    };
    const store = create((innerSet, get) => {
      const merge = () => {
        const result = {};
        for (const key in previousState) {
          if (privateKeys.includes(key)) {
            continue;
          }
          result[key] = previousState[key];
        }
        return Object.assign(result, ownState, {
          events: { ...previousState.events, ...ownState.events },
          viewport: Object.assign({}, previousState.viewport, previousState.viewport.getCurrentViewport(camera, new Vector3(), ownState.size))
        });
      };
      const update = () => innerSet(merge());
      return {
        ...previousState,
        // Set and get refer to this root-state
        set(newOwnState) {
          if (typeof newOwnState === "function") {
            newOwnState = newOwnState(get());
          }
          Object.assign(ownState, newOwnState);
          update();
        },
        setPreviousState(prevState) {
          previousState = prevState;
          update();
        },
        get,
        // Layers are allowed to override events
        setEvents(events) {
          Object.assign(ownState.events, events);
          update();
        },
        ...merge()
      };
    });
    return Object.assign(store, {
      setState(state) {
        store.getState().set(state);
      }
    });
  }, [eventPriority, previousRoot]);
  (0, import_react17.useEffect)(() => previousRoot.subscribe(usePortalStore.getState().setPreviousState), [previousRoot, usePortalStore]);
  (0, import_react17.useEffect)(() => {
    if (imageRef.current == null) {
      return;
    }
    const renderTarget = fbo.value = new WebGLRenderTarget(1, 1, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      type: HalfFloatType
    });
    const { size } = imageRef.current;
    const unsubscribeSetSize = E(() => {
      if (size.value == null) {
        return;
      }
      const [width, height] = size.value;
      renderTarget.setSize(width * dpr, height * dpr);
      usePortalStore.setState({
        size: { width, height, top: 0, left: 0 },
        viewport: { ...previousRoot.getState().viewport, width, height, aspect: width / height }
      });
    });
    return () => {
      unsubscribeSetSize();
      renderTarget.dispose();
    };
  }, [fbo, previousRoot, usePortalStore, dpr]);
  return (0, import_jsx_runtime15.jsxs)(import_jsx_runtime15.Fragment, { children: [reconciler.createPortal((0, import_jsx_runtime15.jsx)(context.Provider, { value: usePortalStore, children: (0, import_jsx_runtime15.jsxs)(ChildrenToFBO, { renderPriority, frames, fbo, children: [children, (0, import_jsx_runtime15.jsx)("group", { onPointerOver: () => null })] }) }), usePortalStore, null), (0, import_jsx_runtime15.jsx)(Image2, { src: texture, objectFit: "fill", keepAspectRatio: false, ...props, ref: imageRef })] });
});
function uvCompute({ current }, event, state, previous) {
  var _a, _b, _c;
  if (current == null || previous == null) {
    return false;
  }
  if (!previous.raycaster.camera)
    (_c = (_b = previous.events).compute) == null ? void 0 : _c.call(_b, event, previous, (_a = previous.previousRoot) == null ? void 0 : _a.getState());
  const [intersection] = previous.raycaster.intersectObject(current.interactionPanel);
  if (!intersection)
    return false;
  const uv2 = intersection.uv;
  if (!uv2)
    return false;
  state.raycaster.setFromCamera(state.pointer.set(uv2.x * 2 - 1, uv2.y * 2 - 1), state.camera);
}
function ChildrenToFBO({ frames, renderPriority, children, fbo }) {
  const store = useStore();
  (0, import_react17.useEffect)(() => {
    return store.subscribe((state, prevState) => {
      const { size, camera } = state;
      if (size) {
        if (isOrthographicCamera(camera)) {
          camera.left = size.width / -2;
          camera.right = size.width / 2;
          camera.top = size.height / 2;
          camera.bottom = size.height / -2;
        } else {
          camera.aspect = size.width / size.height;
        }
        if (size !== prevState.size || camera !== prevState.camera) {
          camera.updateProjectionMatrix();
          camera.updateMatrixWorld();
        }
      }
    });
  }, [store]);
  let count = 0;
  let oldAutoClear;
  let oldXrEnabled;
  useFrame((state) => {
    const currentFBO = fbo.peek();
    if (currentFBO == null) {
      return;
    }
    if (frames === Infinity || count < frames) {
      oldAutoClear = state.gl.autoClear;
      oldXrEnabled = state.gl.xr.enabled;
      state.gl.autoClear = true;
      state.gl.xr.enabled = false;
      state.gl.setRenderTarget(currentFBO);
      state.gl.render(state.scene, state.camera);
      state.gl.setRenderTarget(null);
      state.gl.autoClear = oldAutoClear;
      state.gl.xr.enabled = oldXrEnabled;
      count++;
    }
  }, renderPriority);
  return (0, import_jsx_runtime15.jsx)(import_jsx_runtime15.Fragment, { children });
}

// node_modules/@react-three/uikit/dist/video.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var import_react18 = __toESM(require_react(), 1);
var VideoContext = (0, import_react18.createContext)(void 0);
function useVideoElement() {
  const element = (0, import_react18.useContext)(VideoContext);
  if (element == null) {
    throw new Error(`useVideoElement can only be executed inside a Video component`);
  }
  return element;
}
var Video = (0, import_react18.forwardRef)((props, ref) => {
  const texture = (0, import_react18.useMemo)(() => d(void 0), []);
  const aspectRatio = (0, import_react18.useMemo)(() => d(1), []);
  const providedHtmlElement = props.src instanceof HTMLVideoElement ? props.src : void 0;
  const element = (0, import_react18.useMemo)(() => providedHtmlElement ?? document.createElement("video"), [providedHtmlElement]);
  const invalidate = useThree((s2) => s2.invalidate);
  (0, import_react18.useEffect)(() => setupVideoElementInvalidation(element, invalidate), [element, invalidate]);
  updateVideoElement(element, props);
  (0, import_react18.useEffect)(() => {
    const updateAspectRatio = () => aspectRatio.value = element.videoWidth / element.videoHeight;
    updateAspectRatio();
    element.addEventListener("resize", updateAspectRatio);
    return () => element.removeEventListener("resize", updateAspectRatio);
  }, [aspectRatio, element]);
  (0, import_react18.useEffect)(() => {
    const videoTexture = new VideoTexture(element);
    videoTexture.colorSpace = SRGBColorSpace;
    texture.value = videoTexture;
    return () => videoTexture.dispose();
  }, [texture, element]);
  const internalRef = (0, import_react18.useRef)(null);
  (0, import_react18.useImperativeHandle)(ref, () => ({ ...internalRef.current, element }), [element]);
  return (0, import_jsx_runtime16.jsx)(VideoContext.Provider, { value: element, children: (0, import_jsx_runtime16.jsx)(Image2, { aspectRatio, ...props, ref: internalRef, src: texture }) });
});

// node_modules/@react-three/uikit/node_modules/prettier/standalone.mjs
var yu = Object.create;
var He = Object.defineProperty;
var Au = Object.getOwnPropertyDescriptor;
var Bu2 = Object.getOwnPropertyNames;
var wu = Object.getPrototypeOf;
var xu = Object.prototype.hasOwnProperty;
var sr2 = (e2) => {
  throw TypeError(e2);
};
var _u = (e2, t2) => () => (e2 && (t2 = e2(e2 = 0)), t2);
var At2 = (e2, t2) => () => (t2 || e2((t2 = { exports: {} }).exports, t2), t2.exports);
var We = (e2, t2) => {
  for (var r2 in t2)
    He(e2, r2, { get: t2[r2], enumerable: true });
};
var ar2 = (e2, t2, r2, n2) => {
  if (t2 && typeof t2 == "object" || typeof t2 == "function")
    for (let o2 of Bu2(t2))
      !xu.call(e2, o2) && o2 !== r2 && He(e2, o2, { get: () => t2[o2], enumerable: !(n2 = Au(t2, o2)) || n2.enumerable });
  return e2;
};
var Me2 = (e2, t2, r2) => (r2 = e2 != null ? yu(wu(e2)) : {}, ar2(t2 || !e2 || !e2.__esModule ? He(r2, "default", { value: e2, enumerable: true }) : r2, e2));
var vu = (e2) => ar2(He({}, "__esModule", { value: true }), e2);
var bu = (e2, t2, r2) => t2.has(e2) || sr2("Cannot " + r2);
var Dr = (e2, t2, r2) => t2.has(e2) ? sr2("Cannot add the same private member more than once") : t2 instanceof WeakSet ? t2.add(e2) : t2.set(e2, r2);
var pe = (e2, t2, r2) => (bu(e2, t2, "access private method"), r2);
var it2 = At2((ia, sn2) => {
  "use strict";
  var on2 = new Proxy(String, { get: () => on2 });
  sn2.exports = on2;
});
var Tn2 = {};
We(Tn2, { default: () => _o, shouldHighlight: () => xo });
var xo;
var _o;
var kn2 = _u(() => {
  xo = () => false, _o = String;
});
var Pn2 = At2((bD, Xt) => {
  var g2 = String, Ln = function() {
    return { isColorSupported: false, reset: g2, bold: g2, dim: g2, italic: g2, underline: g2, inverse: g2, hidden: g2, strikethrough: g2, black: g2, red: g2, green: g2, yellow: g2, blue: g2, magenta: g2, cyan: g2, white: g2, gray: g2, bgBlack: g2, bgRed: g2, bgGreen: g2, bgYellow: g2, bgBlue: g2, bgMagenta: g2, bgCyan: g2, bgWhite: g2 };
  };
  Xt.exports = Ln();
  Xt.exports.createColors = Ln;
});
var $n2 = At2((Ct) => {
  "use strict";
  Object.defineProperty(Ct, "__esModule", { value: true });
  Ct.codeFrameColumns = Mn2;
  Ct.default = To;
  var In2 = (kn2(), vu(Tn2)), Hn = vo(Pn2(), true);
  function Wn2(e2) {
    if (typeof WeakMap != "function")
      return null;
    var t2 = /* @__PURE__ */ new WeakMap(), r2 = /* @__PURE__ */ new WeakMap();
    return (Wn2 = function(n2) {
      return n2 ? r2 : t2;
    })(e2);
  }
  function vo(e2, t2) {
    if (!t2 && e2 && e2.__esModule)
      return e2;
    if (e2 === null || typeof e2 != "object" && typeof e2 != "function")
      return { default: e2 };
    var r2 = Wn2(t2);
    if (r2 && r2.has(e2))
      return r2.get(e2);
    var n2 = { __proto__: null }, o2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var u2 in e2)
      if (u2 !== "default" && {}.hasOwnProperty.call(e2, u2)) {
        var i2 = o2 ? Object.getOwnPropertyDescriptor(e2, u2) : null;
        i2 && (i2.get || i2.set) ? Object.defineProperty(n2, u2, i2) : n2[u2] = e2[u2];
      }
    return n2.default = e2, r2 && r2.set(e2, n2), n2;
  }
  var bo = Hn.default, Rn2 = (e2, t2) => (r2) => e2(t2(r2)), Zt;
  function Oo(e2) {
    if (e2) {
      var t2;
      return (t2 = Zt) != null || (Zt = (0, Hn.createColors)(true)), Zt;
    }
    return bo;
  }
  var Yn2 = false;
  function So(e2) {
    return { gutter: e2.gray, marker: Rn2(e2.red, e2.bold), message: Rn2(e2.red, e2.bold) };
  }
  var jn = /\r\n|[\n\r\u2028\u2029]/;
  function No(e2, t2, r2) {
    let n2 = Object.assign({ column: 0, line: -1 }, e2.start), o2 = Object.assign({}, n2, e2.end), { linesAbove: u2 = 2, linesBelow: i2 = 3 } = r2 || {}, s2 = n2.line, a2 = n2.column, D = o2.line, l2 = o2.column, d2 = Math.max(s2 - (u2 + 1), 0), f2 = Math.min(t2.length, D + i2);
    s2 === -1 && (d2 = 0), D === -1 && (f2 = t2.length);
    let p2 = D - s2, c2 = {};
    if (p2)
      for (let F = 0; F <= p2; F++) {
        let m = F + s2;
        if (!a2)
          c2[m] = true;
        else if (F === 0) {
          let E2 = t2[m - 1].length;
          c2[m] = [a2, E2 - a2 + 1];
        } else if (F === p2)
          c2[m] = [0, l2];
        else {
          let E2 = t2[m - F].length;
          c2[m] = [0, E2];
        }
      }
    else
      a2 === l2 ? a2 ? c2[s2] = [a2, 0] : c2[s2] = true : c2[s2] = [a2, l2 - a2];
    return { start: d2, end: f2, markerLines: c2 };
  }
  function Mn2(e2, t2, r2 = {}) {
    let n2 = (r2.highlightCode || r2.forceColor) && (0, In2.shouldHighlight)(r2), o2 = Oo(r2.forceColor), u2 = So(o2), i2 = (F, m) => n2 ? F(m) : m, s2 = e2.split(jn), { start: a2, end: D, markerLines: l2 } = No(t2, s2, r2), d2 = t2.start && typeof t2.start.column == "number", f2 = String(D).length, c2 = (n2 ? (0, In2.default)(e2, r2) : e2).split(jn, D).slice(a2, D).map((F, m) => {
      let E2 = a2 + 1 + m, w2 = ` ${` ${E2}`.slice(-f2)} |`, h2 = l2[E2], C = !l2[E2 + 1];
      if (h2) {
        let k = "";
        if (Array.isArray(h2)) {
          let v2 = F.slice(0, Math.max(h2[0] - 1, 0)).replace(/[^\t]/g, " "), $2 = h2[1] || 1;
          k = [`
 `, i2(u2.gutter, w2.replace(/\d/g, " ")), " ", v2, i2(u2.marker, "^").repeat($2)].join(""), C && r2.message && (k += " " + i2(u2.message, r2.message));
        }
        return [i2(u2.marker, ">"), i2(u2.gutter, w2), F.length > 0 ? ` ${F}` : "", k].join("");
      } else
        return ` ${i2(u2.gutter, w2)}${F.length > 0 ? ` ${F}` : ""}`;
    }).join(`
`);
    return r2.message && !d2 && (c2 = `${" ".repeat(f2 + 1)}${r2.message}
${c2}`), n2 ? o2.reset(c2) : c2;
  }
  function To(e2, t2, r2, n2 = {}) {
    if (!Yn2) {
      Yn2 = true;
      let u2 = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      {
        let i2 = new Error(u2);
        i2.name = "DeprecationWarning", console.warn(new Error(u2));
      }
    }
    return r2 = Math.max(r2, 0), Mn2(e2, { start: { column: r2, line: t2 } }, n2);
  }
});
var ir2 = {};
We(ir2, { __debug: () => di, check: () => fi, doc: () => nr, format: () => gu, formatWithCursor: () => Cu2, getSupportInfo: () => pi2, util: () => or2, version: () => fu });
var Ou = (e2, t2, r2, n2) => {
  if (!(e2 && t2 == null))
    return t2.replaceAll ? t2.replaceAll(r2, n2) : r2.global ? t2.replace(r2, n2) : t2.split(r2).join(n2);
};
var ne2 = Ou;
function Z2() {
}
Z2.prototype = { diff: function(t2, r2) {
  var n2, o2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, u2 = o2.callback;
  typeof o2 == "function" && (u2 = o2, o2 = {}), this.options = o2;
  var i2 = this;
  function s2(h2) {
    return u2 ? (setTimeout(function() {
      u2(void 0, h2);
    }, 0), true) : h2;
  }
  t2 = this.castInput(t2), r2 = this.castInput(r2), t2 = this.removeEmpty(this.tokenize(t2)), r2 = this.removeEmpty(this.tokenize(r2));
  var a2 = r2.length, D = t2.length, l2 = 1, d2 = a2 + D;
  o2.maxEditLength && (d2 = Math.min(d2, o2.maxEditLength));
  var f2 = (n2 = o2.timeout) !== null && n2 !== void 0 ? n2 : 1 / 0, p2 = Date.now() + f2, c2 = [{ oldPos: -1, lastComponent: void 0 }], F = this.extractCommon(c2[0], r2, t2, 0);
  if (c2[0].oldPos + 1 >= D && F + 1 >= a2)
    return s2([{ value: this.join(r2), count: r2.length }]);
  var m = -1 / 0, E2 = 1 / 0;
  function A() {
    for (var h2 = Math.max(m, -l2); h2 <= Math.min(E2, l2); h2 += 2) {
      var C = void 0, k = c2[h2 - 1], v2 = c2[h2 + 1];
      k && (c2[h2 - 1] = void 0);
      var $2 = false;
      if (v2) {
        var ye = v2.oldPos - h2;
        $2 = v2 && 0 <= ye && ye < a2;
      }
      var yt2 = k && k.oldPos + 1 < D;
      if (!$2 && !yt2) {
        c2[h2] = void 0;
        continue;
      }
      if (!yt2 || $2 && k.oldPos + 1 < v2.oldPos ? C = i2.addToPath(v2, true, void 0, 0) : C = i2.addToPath(k, void 0, true, 1), F = i2.extractCommon(C, r2, t2, h2), C.oldPos + 1 >= D && F + 1 >= a2)
        return s2(Su2(i2, C.lastComponent, r2, t2, i2.useLongestToken));
      c2[h2] = C, C.oldPos + 1 >= D && (E2 = Math.min(E2, h2 - 1)), F + 1 >= a2 && (m = Math.max(m, h2 + 1));
    }
    l2++;
  }
  if (u2)
    (function h2() {
      setTimeout(function() {
        if (l2 > d2 || Date.now() > p2)
          return u2();
        A() || h2();
      }, 0);
    })();
  else
    for (; l2 <= d2 && Date.now() <= p2; ) {
      var w2 = A();
      if (w2)
        return w2;
    }
}, addToPath: function(t2, r2, n2, o2) {
  var u2 = t2.lastComponent;
  return u2 && u2.added === r2 && u2.removed === n2 ? { oldPos: t2.oldPos + o2, lastComponent: { count: u2.count + 1, added: r2, removed: n2, previousComponent: u2.previousComponent } } : { oldPos: t2.oldPos + o2, lastComponent: { count: 1, added: r2, removed: n2, previousComponent: u2 } };
}, extractCommon: function(t2, r2, n2, o2) {
  for (var u2 = r2.length, i2 = n2.length, s2 = t2.oldPos, a2 = s2 - o2, D = 0; a2 + 1 < u2 && s2 + 1 < i2 && this.equals(r2[a2 + 1], n2[s2 + 1]); )
    a2++, s2++, D++;
  return D && (t2.lastComponent = { count: D, previousComponent: t2.lastComponent }), t2.oldPos = s2, a2;
}, equals: function(t2, r2) {
  return this.options.comparator ? this.options.comparator(t2, r2) : t2 === r2 || this.options.ignoreCase && t2.toLowerCase() === r2.toLowerCase();
}, removeEmpty: function(t2) {
  for (var r2 = [], n2 = 0; n2 < t2.length; n2++)
    t2[n2] && r2.push(t2[n2]);
  return r2;
}, castInput: function(t2) {
  return t2;
}, tokenize: function(t2) {
  return t2.split("");
}, join: function(t2) {
  return t2.join("");
} };
function Su2(e2, t2, r2, n2, o2) {
  for (var u2 = [], i2; t2; )
    u2.push(t2), i2 = t2.previousComponent, delete t2.previousComponent, t2 = i2;
  u2.reverse();
  for (var s2 = 0, a2 = u2.length, D = 0, l2 = 0; s2 < a2; s2++) {
    var d2 = u2[s2];
    if (d2.removed) {
      if (d2.value = e2.join(n2.slice(l2, l2 + d2.count)), l2 += d2.count, s2 && u2[s2 - 1].added) {
        var p2 = u2[s2 - 1];
        u2[s2 - 1] = u2[s2], u2[s2] = p2;
      }
    } else {
      if (!d2.added && o2) {
        var f2 = r2.slice(D, D + d2.count);
        f2 = f2.map(function(F, m) {
          var E2 = n2[l2 + m];
          return E2.length > F.length ? E2 : F;
        }), d2.value = e2.join(f2);
      } else
        d2.value = e2.join(r2.slice(D, D + d2.count));
      D += d2.count, d2.added || (l2 += d2.count);
    }
  }
  var c2 = u2[a2 - 1];
  return a2 > 1 && typeof c2.value == "string" && (c2.added || c2.removed) && e2.equals("", c2.value) && (u2[a2 - 2].value += c2.value, u2.pop()), u2;
}
var hi2 = new Z2();
var lr2 = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
var cr2 = /\S/;
var fr2 = new Z2();
fr2.equals = function(e2, t2) {
  return this.options.ignoreCase && (e2 = e2.toLowerCase(), t2 = t2.toLowerCase()), e2 === t2 || this.options.ignoreWhitespace && !cr2.test(e2) && !cr2.test(t2);
};
fr2.tokenize = function(e2) {
  for (var t2 = e2.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), r2 = 0; r2 < t2.length - 1; r2++)
    !t2[r2 + 1] && t2[r2 + 2] && lr2.test(t2[r2]) && lr2.test(t2[r2 + 2]) && (t2[r2] += t2[r2 + 2], t2.splice(r2 + 1, 2), r2--);
  return t2;
};
var pr2 = new Z2();
pr2.tokenize = function(e2) {
  this.options.stripTrailingCr && (e2 = e2.replace(/\r\n/g, `
`));
  var t2 = [], r2 = e2.split(/(\n|\r\n)/);
  r2[r2.length - 1] || r2.pop();
  for (var n2 = 0; n2 < r2.length; n2++) {
    var o2 = r2[n2];
    n2 % 2 && !this.options.newlineIsToken ? t2[t2.length - 1] += o2 : (this.options.ignoreWhitespace && (o2 = o2.trim()), t2.push(o2));
  }
  return t2;
};
var Nu = new Z2();
Nu.tokenize = function(e2) {
  return e2.split(/(\S.+?[.!?])(?=\s+|$)/);
};
var Tu = new Z2();
Tu.tokenize = function(e2) {
  return e2.split(/([{}:;,]|\s+)/);
};
function $e2(e2) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? $e2 = function(t2) {
    return typeof t2;
  } : $e2 = function(t2) {
    return t2 && typeof Symbol == "function" && t2.constructor === Symbol && t2 !== Symbol.prototype ? "symbol" : typeof t2;
  }, $e2(e2);
}
var ku = Object.prototype.toString;
var Ae2 = new Z2();
Ae2.useLongestToken = true;
Ae2.tokenize = pr2.tokenize;
Ae2.castInput = function(e2) {
  var t2 = this.options, r2 = t2.undefinedReplacement, n2 = t2.stringifyReplacer, o2 = n2 === void 0 ? function(u2, i2) {
    return typeof i2 > "u" ? r2 : i2;
  } : n2;
  return typeof e2 == "string" ? e2 : JSON.stringify(Bt(e2, null, null, o2), o2, "  ");
};
Ae2.equals = function(e2, t2) {
  return Z2.prototype.equals.call(Ae2, e2.replace(/,([\r\n])/g, "$1"), t2.replace(/,([\r\n])/g, "$1"));
};
function Bt(e2, t2, r2, n2, o2) {
  t2 = t2 || [], r2 = r2 || [], n2 && (e2 = n2(o2, e2));
  var u2;
  for (u2 = 0; u2 < t2.length; u2 += 1)
    if (t2[u2] === e2)
      return r2[u2];
  var i2;
  if (ku.call(e2) === "[object Array]") {
    for (t2.push(e2), i2 = new Array(e2.length), r2.push(i2), u2 = 0; u2 < e2.length; u2 += 1)
      i2[u2] = Bt(e2[u2], t2, r2, n2, o2);
    return t2.pop(), r2.pop(), i2;
  }
  if (e2 && e2.toJSON && (e2 = e2.toJSON()), $e2(e2) === "object" && e2 !== null) {
    t2.push(e2), i2 = {}, r2.push(i2);
    var s2 = [], a2;
    for (a2 in e2)
      e2.hasOwnProperty(a2) && s2.push(a2);
    for (s2.sort(), u2 = 0; u2 < s2.length; u2 += 1)
      a2 = s2[u2], i2[a2] = Bt(e2[a2], t2, r2, n2, a2);
    t2.pop(), r2.pop();
  } else
    i2 = e2;
  return i2;
}
var Ve = new Z2();
Ve.tokenize = function(e2) {
  return e2.slice();
};
Ve.join = Ve.removeEmpty = function(e2) {
  return e2;
};
function dr2(e2, t2, r2) {
  return Ve.diff(e2, t2, r2);
}
function Fr(e2) {
  let t2 = e2.indexOf("\r");
  return t2 >= 0 ? e2.charAt(t2 + 1) === `
` ? "crlf" : "cr" : "lf";
}
function Be2(e2) {
  switch (e2) {
    case "cr":
      return "\r";
    case "crlf":
      return `\r
`;
    default:
      return `
`;
  }
}
function wt2(e2, t2) {
  let r2;
  switch (t2) {
    case `
`:
      r2 = /\n/gu;
      break;
    case "\r":
      r2 = /\r/gu;
      break;
    case `\r
`:
      r2 = /\r\n/gu;
      break;
    default:
      throw new Error(`Unexpected "eol" ${JSON.stringify(t2)}.`);
  }
  let n2 = e2.match(r2);
  return n2 ? n2.length : 0;
}
function mr(e2) {
  return ne2(false, e2, /\r\n?/gu, `
`);
}
var U = "string";
var W = "array";
var z2 = "cursor";
var L2 = "indent";
var P = "align";
var I = "trim";
var x = "group";
var S2 = "fill";
var _2 = "if-break";
var R2 = "indent-if-break";
var Y = "line-suffix";
var j = "line-suffix-boundary";
var B = "line";
var N = "label";
var b2 = "break-parent";
var Ue = /* @__PURE__ */ new Set([z2, L2, P, I, x, S2, _2, R2, Y, j, B, N, b2]);
function Lu2(e2) {
  if (typeof e2 == "string")
    return U;
  if (Array.isArray(e2))
    return W;
  if (!e2)
    return;
  let { type: t2 } = e2;
  if (Ue.has(t2))
    return t2;
}
var G2 = Lu2;
var Pu = (e2) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(e2);
function Iu(e2) {
  let t2 = e2 === null ? "null" : typeof e2;
  if (t2 !== "string" && t2 !== "object")
    return `Unexpected doc '${t2}', 
Expected it to be 'string' or 'object'.`;
  if (G2(e2))
    throw new Error("doc is valid.");
  let r2 = Object.prototype.toString.call(e2);
  if (r2 !== "[object Object]")
    return `Unexpected doc '${r2}'.`;
  let n2 = Pu([...Ue].map((o2) => `'${o2}'`));
  return `Unexpected doc.type '${e2.type}'.
Expected it to be ${n2}.`;
}
var xt2 = class extends Error {
  constructor(t2) {
    super(Iu(t2));
    __publicField(this, "name", "InvalidDocError");
    this.doc = t2;
  }
};
var Q2 = xt2;
var Er = {};
function Ru(e2, t2, r2, n2) {
  let o2 = [e2];
  for (; o2.length > 0; ) {
    let u2 = o2.pop();
    if (u2 === Er) {
      r2(o2.pop());
      continue;
    }
    r2 && o2.push(u2, Er);
    let i2 = G2(u2);
    if (!i2)
      throw new Q2(u2);
    if ((t2 == null ? void 0 : t2(u2)) !== false)
      switch (i2) {
        case W:
        case S2: {
          let s2 = i2 === W ? u2 : u2.parts;
          for (let a2 = s2.length, D = a2 - 1; D >= 0; --D)
            o2.push(s2[D]);
          break;
        }
        case _2:
          o2.push(u2.flatContents, u2.breakContents);
          break;
        case x:
          if (n2 && u2.expandedStates)
            for (let s2 = u2.expandedStates.length, a2 = s2 - 1; a2 >= 0; --a2)
              o2.push(u2.expandedStates[a2]);
          else
            o2.push(u2.contents);
          break;
        case P:
        case L2:
        case R2:
        case N:
        case Y:
          o2.push(u2.contents);
          break;
        case U:
        case z2:
        case I:
        case j:
        case B:
        case b2:
          break;
        default:
          throw new Q2(u2);
      }
  }
}
var we2 = Ru;
var hr = () => {
};
var K = hr;
var ze = hr;
function De2(e2) {
  return K(e2), { type: L2, contents: e2 };
}
function ae(e2, t2) {
  return K(t2), { type: P, contents: t2, n: e2 };
}
function _t(e2, t2 = {}) {
  return K(e2), ze(t2.expandedStates, true), { type: x, id: t2.id, contents: e2, break: !!t2.shouldBreak, expandedStates: t2.expandedStates };
}
function Cr(e2) {
  return ae(Number.NEGATIVE_INFINITY, e2);
}
function gr2(e2) {
  return ae({ type: "root" }, e2);
}
function yr2(e2) {
  return ae(-1, e2);
}
function Ar2(e2, t2) {
  return _t(e2[0], { ...t2, expandedStates: e2 });
}
function Ge2(e2) {
  return ze(e2), { type: S2, parts: e2 };
}
function Br(e2, t2 = "", r2 = {}) {
  return K(e2), t2 !== "" && K(t2), { type: _2, breakContents: e2, flatContents: t2, groupId: r2.groupId };
}
function wr(e2, t2) {
  return K(e2), { type: R2, contents: e2, groupId: t2.groupId, negate: t2.negate };
}
function xe2(e2) {
  return K(e2), { type: Y, contents: e2 };
}
var xr2 = { type: j };
var de = { type: b2 };
var _r2 = { type: I };
var _e2 = { type: B, hard: true };
var vt = { type: B, hard: true, literal: true };
var Ke2 = { type: B };
var vr2 = { type: B, soft: true };
var q = [_e2, de];
var qe = [vt, de];
var ve2 = { type: z2 };
function be2(e2, t2) {
  K(e2), ze(t2);
  let r2 = [];
  for (let n2 = 0; n2 < t2.length; n2++)
    n2 !== 0 && r2.push(e2), r2.push(t2[n2]);
  return r2;
}
function Je(e2, t2, r2) {
  K(e2);
  let n2 = e2;
  if (t2 > 0) {
    for (let o2 = 0; o2 < Math.floor(t2 / r2); ++o2)
      n2 = De2(n2);
    n2 = ae(t2 % r2, n2), n2 = ae(Number.NEGATIVE_INFINITY, n2);
  }
  return n2;
}
function br2(e2, t2) {
  return K(t2), e2 ? { type: N, label: e2, contents: t2 } : t2;
}
function ee2(e2) {
  var t2;
  if (!e2)
    return "";
  if (Array.isArray(e2)) {
    let r2 = [];
    for (let n2 of e2)
      if (Array.isArray(n2))
        r2.push(...ee2(n2));
      else {
        let o2 = ee2(n2);
        o2 !== "" && r2.push(o2);
      }
    return r2;
  }
  return e2.type === _2 ? { ...e2, breakContents: ee2(e2.breakContents), flatContents: ee2(e2.flatContents) } : e2.type === x ? { ...e2, contents: ee2(e2.contents), expandedStates: (t2 = e2.expandedStates) == null ? void 0 : t2.map(ee2) } : e2.type === S2 ? { type: "fill", parts: e2.parts.map(ee2) } : e2.contents ? { ...e2, contents: ee2(e2.contents) } : e2;
}
function Or(e2) {
  let t2 = /* @__PURE__ */ Object.create(null), r2 = /* @__PURE__ */ new Set();
  return n2(ee2(e2));
  function n2(u2, i2, s2) {
    var a2, D;
    if (typeof u2 == "string")
      return JSON.stringify(u2);
    if (Array.isArray(u2)) {
      let l2 = u2.map(n2).filter(Boolean);
      return l2.length === 1 ? l2[0] : `[${l2.join(", ")}]`;
    }
    if (u2.type === B) {
      let l2 = ((a2 = s2 == null ? void 0 : s2[i2 + 1]) == null ? void 0 : a2.type) === b2;
      return u2.literal ? l2 ? "literalline" : "literallineWithoutBreakParent" : u2.hard ? l2 ? "hardline" : "hardlineWithoutBreakParent" : u2.soft ? "softline" : "line";
    }
    if (u2.type === b2)
      return ((D = s2 == null ? void 0 : s2[i2 - 1]) == null ? void 0 : D.type) === B && s2[i2 - 1].hard ? void 0 : "breakParent";
    if (u2.type === I)
      return "trim";
    if (u2.type === L2)
      return "indent(" + n2(u2.contents) + ")";
    if (u2.type === P)
      return u2.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + n2(u2.contents) + ")" : u2.n < 0 ? "dedent(" + n2(u2.contents) + ")" : u2.n.type === "root" ? "markAsRoot(" + n2(u2.contents) + ")" : "align(" + JSON.stringify(u2.n) + ", " + n2(u2.contents) + ")";
    if (u2.type === _2)
      return "ifBreak(" + n2(u2.breakContents) + (u2.flatContents ? ", " + n2(u2.flatContents) : "") + (u2.groupId ? (u2.flatContents ? "" : ', ""') + `, { groupId: ${o2(u2.groupId)} }` : "") + ")";
    if (u2.type === R2) {
      let l2 = [];
      u2.negate && l2.push("negate: true"), u2.groupId && l2.push(`groupId: ${o2(u2.groupId)}`);
      let d2 = l2.length > 0 ? `, { ${l2.join(", ")} }` : "";
      return `indentIfBreak(${n2(u2.contents)}${d2})`;
    }
    if (u2.type === x) {
      let l2 = [];
      u2.break && u2.break !== "propagated" && l2.push("shouldBreak: true"), u2.id && l2.push(`id: ${o2(u2.id)}`);
      let d2 = l2.length > 0 ? `, { ${l2.join(", ")} }` : "";
      return u2.expandedStates ? `conditionalGroup([${u2.expandedStates.map((f2) => n2(f2)).join(",")}]${d2})` : `group(${n2(u2.contents)}${d2})`;
    }
    if (u2.type === S2)
      return `fill([${u2.parts.map((l2) => n2(l2)).join(", ")}])`;
    if (u2.type === Y)
      return "lineSuffix(" + n2(u2.contents) + ")";
    if (u2.type === j)
      return "lineSuffixBoundary";
    if (u2.type === N)
      return `label(${JSON.stringify(u2.label)}, ${n2(u2.contents)})`;
    throw new Error("Unknown doc type " + u2.type);
  }
  function o2(u2) {
    if (typeof u2 != "symbol")
      return JSON.stringify(String(u2));
    if (u2 in t2)
      return t2[u2];
    let i2 = u2.description || "symbol";
    for (let s2 = 0; ; s2++) {
      let a2 = i2 + (s2 > 0 ? ` #${s2}` : "");
      if (!r2.has(a2))
        return r2.add(a2), t2[u2] = `Symbol.for(${JSON.stringify(a2)})`;
    }
  }
}
var Yu2 = (e2, t2, r2) => {
  if (!(e2 && t2 == null))
    return Array.isArray(t2) || typeof t2 == "string" ? t2[r2 < 0 ? t2.length + r2 : r2] : t2.at(r2);
};
var y2 = Yu2;
var Sr = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
function Nr2(e2) {
  return e2 === 12288 || e2 >= 65281 && e2 <= 65376 || e2 >= 65504 && e2 <= 65510;
}
function Tr(e2) {
  return e2 >= 4352 && e2 <= 4447 || e2 === 8986 || e2 === 8987 || e2 === 9001 || e2 === 9002 || e2 >= 9193 && e2 <= 9196 || e2 === 9200 || e2 === 9203 || e2 === 9725 || e2 === 9726 || e2 === 9748 || e2 === 9749 || e2 >= 9800 && e2 <= 9811 || e2 === 9855 || e2 === 9875 || e2 === 9889 || e2 === 9898 || e2 === 9899 || e2 === 9917 || e2 === 9918 || e2 === 9924 || e2 === 9925 || e2 === 9934 || e2 === 9940 || e2 === 9962 || e2 === 9970 || e2 === 9971 || e2 === 9973 || e2 === 9978 || e2 === 9981 || e2 === 9989 || e2 === 9994 || e2 === 9995 || e2 === 10024 || e2 === 10060 || e2 === 10062 || e2 >= 10067 && e2 <= 10069 || e2 === 10071 || e2 >= 10133 && e2 <= 10135 || e2 === 10160 || e2 === 10175 || e2 === 11035 || e2 === 11036 || e2 === 11088 || e2 === 11093 || e2 >= 11904 && e2 <= 11929 || e2 >= 11931 && e2 <= 12019 || e2 >= 12032 && e2 <= 12245 || e2 >= 12272 && e2 <= 12287 || e2 >= 12289 && e2 <= 12350 || e2 >= 12353 && e2 <= 12438 || e2 >= 12441 && e2 <= 12543 || e2 >= 12549 && e2 <= 12591 || e2 >= 12593 && e2 <= 12686 || e2 >= 12688 && e2 <= 12771 || e2 >= 12783 && e2 <= 12830 || e2 >= 12832 && e2 <= 12871 || e2 >= 12880 && e2 <= 19903 || e2 >= 19968 && e2 <= 42124 || e2 >= 42128 && e2 <= 42182 || e2 >= 43360 && e2 <= 43388 || e2 >= 44032 && e2 <= 55203 || e2 >= 63744 && e2 <= 64255 || e2 >= 65040 && e2 <= 65049 || e2 >= 65072 && e2 <= 65106 || e2 >= 65108 && e2 <= 65126 || e2 >= 65128 && e2 <= 65131 || e2 >= 94176 && e2 <= 94180 || e2 === 94192 || e2 === 94193 || e2 >= 94208 && e2 <= 100343 || e2 >= 100352 && e2 <= 101589 || e2 >= 101632 && e2 <= 101640 || e2 >= 110576 && e2 <= 110579 || e2 >= 110581 && e2 <= 110587 || e2 === 110589 || e2 === 110590 || e2 >= 110592 && e2 <= 110882 || e2 === 110898 || e2 >= 110928 && e2 <= 110930 || e2 === 110933 || e2 >= 110948 && e2 <= 110951 || e2 >= 110960 && e2 <= 111355 || e2 === 126980 || e2 === 127183 || e2 === 127374 || e2 >= 127377 && e2 <= 127386 || e2 >= 127488 && e2 <= 127490 || e2 >= 127504 && e2 <= 127547 || e2 >= 127552 && e2 <= 127560 || e2 === 127568 || e2 === 127569 || e2 >= 127584 && e2 <= 127589 || e2 >= 127744 && e2 <= 127776 || e2 >= 127789 && e2 <= 127797 || e2 >= 127799 && e2 <= 127868 || e2 >= 127870 && e2 <= 127891 || e2 >= 127904 && e2 <= 127946 || e2 >= 127951 && e2 <= 127955 || e2 >= 127968 && e2 <= 127984 || e2 === 127988 || e2 >= 127992 && e2 <= 128062 || e2 === 128064 || e2 >= 128066 && e2 <= 128252 || e2 >= 128255 && e2 <= 128317 || e2 >= 128331 && e2 <= 128334 || e2 >= 128336 && e2 <= 128359 || e2 === 128378 || e2 === 128405 || e2 === 128406 || e2 === 128420 || e2 >= 128507 && e2 <= 128591 || e2 >= 128640 && e2 <= 128709 || e2 === 128716 || e2 >= 128720 && e2 <= 128722 || e2 >= 128725 && e2 <= 128727 || e2 >= 128732 && e2 <= 128735 || e2 === 128747 || e2 === 128748 || e2 >= 128756 && e2 <= 128764 || e2 >= 128992 && e2 <= 129003 || e2 === 129008 || e2 >= 129292 && e2 <= 129338 || e2 >= 129340 && e2 <= 129349 || e2 >= 129351 && e2 <= 129535 || e2 >= 129648 && e2 <= 129660 || e2 >= 129664 && e2 <= 129672 || e2 >= 129680 && e2 <= 129725 || e2 >= 129727 && e2 <= 129733 || e2 >= 129742 && e2 <= 129755 || e2 >= 129760 && e2 <= 129768 || e2 >= 129776 && e2 <= 129784 || e2 >= 131072 && e2 <= 196605 || e2 >= 196608 && e2 <= 262141;
}
var kr2 = (e2) => !(Nr2(e2) || Tr(e2));
var ju2 = /[^\x20-\x7F]/u;
function Hu2(e2) {
  if (!e2)
    return 0;
  if (!ju2.test(e2))
    return e2.length;
  e2 = e2.replace(Sr(), "  ");
  let t2 = 0;
  for (let r2 of e2) {
    let n2 = r2.codePointAt(0);
    n2 <= 31 || n2 >= 127 && n2 <= 159 || n2 >= 768 && n2 <= 879 || (t2 += kr2(n2) ? 1 : 2);
  }
  return t2;
}
var Oe2 = Hu2;
function Ne(e2, t2) {
  if (typeof e2 == "string")
    return t2(e2);
  let r2 = /* @__PURE__ */ new Map();
  return n2(e2);
  function n2(u2) {
    if (r2.has(u2))
      return r2.get(u2);
    let i2 = o2(u2);
    return r2.set(u2, i2), i2;
  }
  function o2(u2) {
    switch (G2(u2)) {
      case W:
        return t2(u2.map(n2));
      case S2:
        return t2({ ...u2, parts: u2.parts.map(n2) });
      case _2:
        return t2({ ...u2, breakContents: n2(u2.breakContents), flatContents: n2(u2.flatContents) });
      case x: {
        let { expandedStates: i2, contents: s2 } = u2;
        return i2 ? (i2 = i2.map(n2), s2 = i2[0]) : s2 = n2(s2), t2({ ...u2, contents: s2, expandedStates: i2 });
      }
      case P:
      case L2:
      case R2:
      case N:
      case Y:
        return t2({ ...u2, contents: n2(u2.contents) });
      case U:
      case z2:
      case I:
      case j:
      case B:
      case b2:
        return t2(u2);
      default:
        throw new Q2(u2);
    }
  }
}
function Xe(e2, t2, r2) {
  let n2 = r2, o2 = false;
  function u2(i2) {
    if (o2)
      return false;
    let s2 = t2(i2);
    s2 !== void 0 && (o2 = true, n2 = s2);
  }
  return we2(e2, u2), n2;
}
function Wu2(e2) {
  if (e2.type === x && e2.break || e2.type === B && e2.hard || e2.type === b2)
    return true;
}
function Ir(e2) {
  return Xe(e2, Wu2, false);
}
function Lr2(e2) {
  if (e2.length > 0) {
    let t2 = y2(false, e2, -1);
    !t2.expandedStates && !t2.break && (t2.break = "propagated");
  }
  return null;
}
function Rr(e2) {
  let t2 = /* @__PURE__ */ new Set(), r2 = [];
  function n2(u2) {
    if (u2.type === b2 && Lr2(r2), u2.type === x) {
      if (r2.push(u2), t2.has(u2))
        return false;
      t2.add(u2);
    }
  }
  function o2(u2) {
    u2.type === x && r2.pop().break && Lr2(r2);
  }
  we2(e2, n2, o2, true);
}
function Mu2(e2) {
  return e2.type === B && !e2.hard ? e2.soft ? "" : " " : e2.type === _2 ? e2.flatContents : e2;
}
function Yr2(e2) {
  return Ne(e2, Mu2);
}
function Pr(e2) {
  for (e2 = [...e2]; e2.length >= 2 && y2(false, e2, -2).type === B && y2(false, e2, -1).type === b2; )
    e2.length -= 2;
  if (e2.length > 0) {
    let t2 = Se2(y2(false, e2, -1));
    e2[e2.length - 1] = t2;
  }
  return e2;
}
function Se2(e2) {
  switch (G2(e2)) {
    case L2:
    case R2:
    case x:
    case Y:
    case N: {
      let t2 = Se2(e2.contents);
      return { ...e2, contents: t2 };
    }
    case _2:
      return { ...e2, breakContents: Se2(e2.breakContents), flatContents: Se2(e2.flatContents) };
    case S2:
      return { ...e2, parts: Pr(e2.parts) };
    case W:
      return Pr(e2);
    case U:
      return e2.replace(/[\n\r]*$/u, "");
    case P:
    case z2:
    case I:
    case j:
    case B:
    case b2:
      break;
    default:
      throw new Q2(e2);
  }
  return e2;
}
function Ze(e2) {
  return Se2(Vu2(e2));
}
function $u2(e2) {
  switch (G2(e2)) {
    case S2:
      if (e2.parts.every((t2) => t2 === ""))
        return "";
      break;
    case x:
      if (!e2.contents && !e2.id && !e2.break && !e2.expandedStates)
        return "";
      if (e2.contents.type === x && e2.contents.id === e2.id && e2.contents.break === e2.break && e2.contents.expandedStates === e2.expandedStates)
        return e2.contents;
      break;
    case P:
    case L2:
    case R2:
    case Y:
      if (!e2.contents)
        return "";
      break;
    case _2:
      if (!e2.flatContents && !e2.breakContents)
        return "";
      break;
    case W: {
      let t2 = [];
      for (let r2 of e2) {
        if (!r2)
          continue;
        let [n2, ...o2] = Array.isArray(r2) ? r2 : [r2];
        typeof n2 == "string" && typeof y2(false, t2, -1) == "string" ? t2[t2.length - 1] += n2 : t2.push(n2), t2.push(...o2);
      }
      return t2.length === 0 ? "" : t2.length === 1 ? t2[0] : t2;
    }
    case U:
    case z2:
    case I:
    case j:
    case B:
    case N:
    case b2:
      break;
    default:
      throw new Q2(e2);
  }
  return e2;
}
function Vu2(e2) {
  return Ne(e2, (t2) => $u2(t2));
}
function jr2(e2, t2 = qe) {
  return Ne(e2, (r2) => typeof r2 == "string" ? be2(t2, r2.split(`
`)) : r2);
}
function Uu2(e2) {
  if (e2.type === B)
    return true;
}
function Hr2(e2) {
  return Xe(e2, Uu2, false);
}
function Qe2(e2, t2) {
  return e2.type === N ? { ...e2, contents: t2(e2.contents) } : t2(e2);
}
var H2 = Symbol("MODE_BREAK");
var J2 = Symbol("MODE_FLAT");
var Te = Symbol("cursor");
function Wr() {
  return { value: "", length: 0, queue: [] };
}
function zu2(e2, t2) {
  return bt(e2, { type: "indent" }, t2);
}
function Gu2(e2, t2, r2) {
  return t2 === Number.NEGATIVE_INFINITY ? e2.root || Wr() : t2 < 0 ? bt(e2, { type: "dedent" }, r2) : t2 ? t2.type === "root" ? { ...e2, root: e2 } : bt(e2, { type: typeof t2 == "string" ? "stringAlign" : "numberAlign", n: t2 }, r2) : e2;
}
function bt(e2, t2, r2) {
  let n2 = t2.type === "dedent" ? e2.queue.slice(0, -1) : [...e2.queue, t2], o2 = "", u2 = 0, i2 = 0, s2 = 0;
  for (let c2 of n2)
    switch (c2.type) {
      case "indent":
        l2(), r2.useTabs ? a2(1) : D(r2.tabWidth);
        break;
      case "stringAlign":
        l2(), o2 += c2.n, u2 += c2.n.length;
        break;
      case "numberAlign":
        i2 += 1, s2 += c2.n;
        break;
      default:
        throw new Error(`Unexpected type '${c2.type}'`);
    }
  return f2(), { ...e2, value: o2, length: u2, queue: n2 };
  function a2(c2) {
    o2 += "	".repeat(c2), u2 += r2.tabWidth * c2;
  }
  function D(c2) {
    o2 += " ".repeat(c2), u2 += c2;
  }
  function l2() {
    r2.useTabs ? d2() : f2();
  }
  function d2() {
    i2 > 0 && a2(i2), p2();
  }
  function f2() {
    s2 > 0 && D(s2), p2();
  }
  function p2() {
    i2 = 0, s2 = 0;
  }
}
function Ot(e2) {
  let t2 = 0, r2 = 0, n2 = e2.length;
  e:
    for (; n2--; ) {
      let o2 = e2[n2];
      if (o2 === Te) {
        r2++;
        continue;
      }
      for (let u2 = o2.length - 1; u2 >= 0; u2--) {
        let i2 = o2[u2];
        if (i2 === " " || i2 === "	")
          t2++;
        else {
          e2[n2] = o2.slice(0, u2 + 1);
          break e;
        }
      }
    }
  if (t2 > 0 || r2 > 0)
    for (e2.length = n2 + 1; r2-- > 0; )
      e2.push(Te);
  return t2;
}
function et(e2, t2, r2, n2, o2, u2) {
  if (r2 === Number.POSITIVE_INFINITY)
    return true;
  let i2 = t2.length, s2 = [e2], a2 = [];
  for (; r2 >= 0; ) {
    if (s2.length === 0) {
      if (i2 === 0)
        return true;
      s2.push(t2[--i2]);
      continue;
    }
    let { mode: D, doc: l2 } = s2.pop(), d2 = G2(l2);
    switch (d2) {
      case U:
        a2.push(l2), r2 -= Oe2(l2);
        break;
      case W:
      case S2: {
        let f2 = d2 === W ? l2 : l2.parts;
        for (let p2 = f2.length - 1; p2 >= 0; p2--)
          s2.push({ mode: D, doc: f2[p2] });
        break;
      }
      case L2:
      case P:
      case R2:
      case N:
        s2.push({ mode: D, doc: l2.contents });
        break;
      case I:
        r2 += Ot(a2);
        break;
      case x: {
        if (u2 && l2.break)
          return false;
        let f2 = l2.break ? H2 : D, p2 = l2.expandedStates && f2 === H2 ? y2(false, l2.expandedStates, -1) : l2.contents;
        s2.push({ mode: f2, doc: p2 });
        break;
      }
      case _2: {
        let p2 = (l2.groupId ? o2[l2.groupId] || J2 : D) === H2 ? l2.breakContents : l2.flatContents;
        p2 && s2.push({ mode: D, doc: p2 });
        break;
      }
      case B:
        if (D === H2 || l2.hard)
          return true;
        l2.soft || (a2.push(" "), r2--);
        break;
      case Y:
        n2 = true;
        break;
      case j:
        if (n2)
          return false;
        break;
    }
  }
  return false;
}
function Fe2(e2, t2) {
  let r2 = {}, n2 = t2.printWidth, o2 = Be2(t2.endOfLine), u2 = 0, i2 = [{ ind: Wr(), mode: H2, doc: e2 }], s2 = [], a2 = false, D = [], l2 = 0;
  for (Rr(e2); i2.length > 0; ) {
    let { ind: f2, mode: p2, doc: c2 } = i2.pop();
    switch (G2(c2)) {
      case U: {
        let F = o2 !== `
` ? ne2(false, c2, `
`, o2) : c2;
        s2.push(F), i2.length > 0 && (u2 += Oe2(F));
        break;
      }
      case W:
        for (let F = c2.length - 1; F >= 0; F--)
          i2.push({ ind: f2, mode: p2, doc: c2[F] });
        break;
      case z2:
        if (l2 >= 2)
          throw new Error("There are too many 'cursor' in doc.");
        s2.push(Te), l2++;
        break;
      case L2:
        i2.push({ ind: zu2(f2, t2), mode: p2, doc: c2.contents });
        break;
      case P:
        i2.push({ ind: Gu2(f2, c2.n, t2), mode: p2, doc: c2.contents });
        break;
      case I:
        u2 -= Ot(s2);
        break;
      case x:
        switch (p2) {
          case J2:
            if (!a2) {
              i2.push({ ind: f2, mode: c2.break ? H2 : J2, doc: c2.contents });
              break;
            }
          case H2: {
            a2 = false;
            let F = { ind: f2, mode: J2, doc: c2.contents }, m = n2 - u2, E2 = D.length > 0;
            if (!c2.break && et(F, i2, m, E2, r2))
              i2.push(F);
            else if (c2.expandedStates) {
              let A = y2(false, c2.expandedStates, -1);
              if (c2.break) {
                i2.push({ ind: f2, mode: H2, doc: A });
                break;
              } else
                for (let w2 = 1; w2 < c2.expandedStates.length + 1; w2++)
                  if (w2 >= c2.expandedStates.length) {
                    i2.push({ ind: f2, mode: H2, doc: A });
                    break;
                  } else {
                    let h2 = c2.expandedStates[w2], C = { ind: f2, mode: J2, doc: h2 };
                    if (et(C, i2, m, E2, r2)) {
                      i2.push(C);
                      break;
                    }
                  }
            } else
              i2.push({ ind: f2, mode: H2, doc: c2.contents });
            break;
          }
        }
        c2.id && (r2[c2.id] = y2(false, i2, -1).mode);
        break;
      case S2: {
        let F = n2 - u2, { parts: m } = c2;
        if (m.length === 0)
          break;
        let [E2, A] = m, w2 = { ind: f2, mode: J2, doc: E2 }, h2 = { ind: f2, mode: H2, doc: E2 }, C = et(w2, [], F, D.length > 0, r2, true);
        if (m.length === 1) {
          C ? i2.push(w2) : i2.push(h2);
          break;
        }
        let k = { ind: f2, mode: J2, doc: A }, v2 = { ind: f2, mode: H2, doc: A };
        if (m.length === 2) {
          C ? i2.push(k, w2) : i2.push(v2, h2);
          break;
        }
        m.splice(0, 2);
        let $2 = { ind: f2, mode: p2, doc: Ge2(m) }, ye = m[0];
        et({ ind: f2, mode: J2, doc: [E2, A, ye] }, [], F, D.length > 0, r2, true) ? i2.push($2, k, w2) : C ? i2.push($2, v2, w2) : i2.push($2, v2, h2);
        break;
      }
      case _2:
      case R2: {
        let F = c2.groupId ? r2[c2.groupId] : p2;
        if (F === H2) {
          let m = c2.type === _2 ? c2.breakContents : c2.negate ? c2.contents : De2(c2.contents);
          m && i2.push({ ind: f2, mode: p2, doc: m });
        }
        if (F === J2) {
          let m = c2.type === _2 ? c2.flatContents : c2.negate ? De2(c2.contents) : c2.contents;
          m && i2.push({ ind: f2, mode: p2, doc: m });
        }
        break;
      }
      case Y:
        D.push({ ind: f2, mode: p2, doc: c2.contents });
        break;
      case j:
        D.length > 0 && i2.push({ ind: f2, mode: p2, doc: _e2 });
        break;
      case B:
        switch (p2) {
          case J2:
            if (c2.hard)
              a2 = true;
            else {
              c2.soft || (s2.push(" "), u2 += 1);
              break;
            }
          case H2:
            if (D.length > 0) {
              i2.push({ ind: f2, mode: p2, doc: c2 }, ...D.reverse()), D.length = 0;
              break;
            }
            c2.literal ? f2.root ? (s2.push(o2, f2.root.value), u2 = f2.root.length) : (s2.push(o2), u2 = 0) : (u2 -= Ot(s2), s2.push(o2 + f2.value), u2 = f2.length);
            break;
        }
        break;
      case N:
        i2.push({ ind: f2, mode: p2, doc: c2.contents });
        break;
      case b2:
        break;
      default:
        throw new Q2(c2);
    }
    i2.length === 0 && D.length > 0 && (i2.push(...D.reverse()), D.length = 0);
  }
  let d2 = s2.indexOf(Te);
  if (d2 !== -1) {
    let f2 = s2.indexOf(Te, d2 + 1), p2 = s2.slice(0, d2).join(""), c2 = s2.slice(d2 + 1, f2).join(""), F = s2.slice(f2 + 1).join("");
    return { formatted: p2 + c2 + F, cursorNodeStart: p2.length, cursorNodeText: c2 };
  }
  return { formatted: s2.join("") };
}
function Ku2(e2, t2, r2 = 0) {
  let n2 = 0;
  for (let o2 = r2; o2 < e2.length; ++o2)
    e2[o2] === "	" ? n2 = n2 + t2 - n2 % t2 : n2++;
  return n2;
}
var me = Ku2;
var te;
var Nt;
var tt;
var St2 = class {
  constructor(t2) {
    Dr(this, te);
    this.stack = [t2];
  }
  get key() {
    let { stack: t2, siblings: r2 } = this;
    return y2(false, t2, r2 === null ? -2 : -4) ?? null;
  }
  get index() {
    return this.siblings === null ? null : y2(false, this.stack, -2);
  }
  get node() {
    return y2(false, this.stack, -1);
  }
  get parent() {
    return this.getNode(1);
  }
  get grandparent() {
    return this.getNode(2);
  }
  get isInArray() {
    return this.siblings !== null;
  }
  get siblings() {
    let { stack: t2 } = this, r2 = y2(false, t2, -3);
    return Array.isArray(r2) ? r2 : null;
  }
  get next() {
    let { siblings: t2 } = this;
    return t2 === null ? null : t2[this.index + 1];
  }
  get previous() {
    let { siblings: t2 } = this;
    return t2 === null ? null : t2[this.index - 1];
  }
  get isFirst() {
    return this.index === 0;
  }
  get isLast() {
    let { siblings: t2, index: r2 } = this;
    return t2 !== null && r2 === t2.length - 1;
  }
  get isRoot() {
    return this.stack.length === 1;
  }
  get root() {
    return this.stack[0];
  }
  get ancestors() {
    return [...pe(this, te, tt).call(this)];
  }
  getName() {
    let { stack: t2 } = this, { length: r2 } = t2;
    return r2 > 1 ? y2(false, t2, -2) : null;
  }
  getValue() {
    return y2(false, this.stack, -1);
  }
  getNode(t2 = 0) {
    let r2 = pe(this, te, Nt).call(this, t2);
    return r2 === -1 ? null : this.stack[r2];
  }
  getParentNode(t2 = 0) {
    return this.getNode(t2 + 1);
  }
  call(t2, ...r2) {
    let { stack: n2 } = this, { length: o2 } = n2, u2 = y2(false, n2, -1);
    for (let i2 of r2)
      u2 = u2[i2], n2.push(i2, u2);
    try {
      return t2(this);
    } finally {
      n2.length = o2;
    }
  }
  callParent(t2, r2 = 0) {
    let n2 = pe(this, te, Nt).call(this, r2 + 1), o2 = this.stack.splice(n2 + 1);
    try {
      return t2(this);
    } finally {
      this.stack.push(...o2);
    }
  }
  each(t2, ...r2) {
    let { stack: n2 } = this, { length: o2 } = n2, u2 = y2(false, n2, -1);
    for (let i2 of r2)
      u2 = u2[i2], n2.push(i2, u2);
    try {
      for (let i2 = 0; i2 < u2.length; ++i2)
        n2.push(i2, u2[i2]), t2(this, i2, u2), n2.length -= 2;
    } finally {
      n2.length = o2;
    }
  }
  map(t2, ...r2) {
    let n2 = [];
    return this.each((o2, u2, i2) => {
      n2[u2] = t2(o2, u2, i2);
    }, ...r2), n2;
  }
  match(...t2) {
    let r2 = this.stack.length - 1, n2 = null, o2 = this.stack[r2--];
    for (let u2 of t2) {
      if (o2 === void 0)
        return false;
      let i2 = null;
      if (typeof n2 == "number" && (i2 = n2, n2 = this.stack[r2--], o2 = this.stack[r2--]), u2 && !u2(o2, n2, i2))
        return false;
      n2 = this.stack[r2--], o2 = this.stack[r2--];
    }
    return true;
  }
  findAncestor(t2) {
    for (let r2 of pe(this, te, tt).call(this))
      if (t2(r2))
        return r2;
  }
  hasAncestor(t2) {
    for (let r2 of pe(this, te, tt).call(this))
      if (t2(r2))
        return true;
    return false;
  }
};
te = /* @__PURE__ */ new WeakSet(), Nt = function(t2) {
  let { stack: r2 } = this;
  for (let n2 = r2.length - 1; n2 >= 0; n2 -= 2)
    if (!Array.isArray(r2[n2]) && --t2 < 0)
      return n2;
  return -1;
}, tt = function* () {
  let { stack: t2 } = this;
  for (let r2 = t2.length - 3; r2 >= 0; r2 -= 2) {
    let n2 = t2[r2];
    Array.isArray(n2) || (yield n2);
  }
};
var Mr = St2;
var $r2 = new Proxy(() => {
}, { get: () => $r2 });
var ke2 = $r2;
function qu2(e2) {
  return e2 !== null && typeof e2 == "object";
}
var Vr = qu2;
function* Tt(e2, t2) {
  let { getVisitorKeys: r2, filter: n2 = () => true } = t2, o2 = (u2) => Vr(u2) && n2(u2);
  for (let u2 of r2(e2)) {
    let i2 = e2[u2];
    if (Array.isArray(i2))
      for (let s2 of i2)
        o2(s2) && (yield s2);
    else
      o2(i2) && (yield i2);
  }
}
function* Ur(e2, t2) {
  let r2 = [e2];
  for (let n2 = 0; n2 < r2.length; n2++) {
    let o2 = r2[n2];
    for (let u2 of Tt(o2, t2))
      yield u2, r2.push(u2);
  }
}
function Ee(e2) {
  return (t2, r2, n2) => {
    let o2 = !!(n2 != null && n2.backwards);
    if (r2 === false)
      return false;
    let { length: u2 } = t2, i2 = r2;
    for (; i2 >= 0 && i2 < u2; ) {
      let s2 = t2.charAt(i2);
      if (e2 instanceof RegExp) {
        if (!e2.test(s2))
          return i2;
      } else if (!e2.includes(s2))
        return i2;
      o2 ? i2-- : i2++;
    }
    return i2 === -1 || i2 === u2 ? i2 : false;
  };
}
var zr = Ee(/\s/u);
var T2 = Ee(" 	");
var rt2 = Ee(",; 	");
var nt2 = Ee(/[^\n\r]/u);
function Ju2(e2, t2, r2) {
  let n2 = !!(r2 != null && r2.backwards);
  if (t2 === false)
    return false;
  let o2 = e2.charAt(t2);
  if (n2) {
    if (e2.charAt(t2 - 1) === "\r" && o2 === `
`)
      return t2 - 2;
    if (o2 === `
` || o2 === "\r" || o2 === "\u2028" || o2 === "\u2029")
      return t2 - 1;
  } else {
    if (o2 === "\r" && e2.charAt(t2 + 1) === `
`)
      return t2 + 2;
    if (o2 === `
` || o2 === "\r" || o2 === "\u2028" || o2 === "\u2029")
      return t2 + 1;
  }
  return t2;
}
var M2 = Ju2;
function Xu2(e2, t2, r2 = {}) {
  let n2 = T2(e2, r2.backwards ? t2 - 1 : t2, r2), o2 = M2(e2, n2, r2);
  return n2 !== o2;
}
var V = Xu2;
function Zu2(e2) {
  return Array.isArray(e2) && e2.length > 0;
}
var kt2 = Zu2;
var Gr2 = /* @__PURE__ */ new Set(["tokens", "comments", "parent", "enclosingNode", "precedingNode", "followingNode"]);
var Qu2 = (e2) => Object.keys(e2).filter((t2) => !Gr2.has(t2));
function eo(e2) {
  return e2 ? (t2) => e2(t2, Gr2) : Qu2;
}
var X2 = eo;
function to(e2) {
  let t2 = e2.type || e2.kind || "(unknown type)", r2 = String(e2.name || e2.id && (typeof e2.id == "object" ? e2.id.name : e2.id) || e2.key && (typeof e2.key == "object" ? e2.key.name : e2.key) || e2.value && (typeof e2.value == "object" ? "" : String(e2.value)) || e2.operator || "");
  return r2.length > 20 && (r2 = r2.slice(0, 19) + "â€¦"), t2 + (r2 ? " " + r2 : "");
}
function Lt(e2, t2) {
  (e2.comments ?? (e2.comments = [])).push(t2), t2.printed = false, t2.nodeDescription = to(e2);
}
function ue(e2, t2) {
  t2.leading = true, t2.trailing = false, Lt(e2, t2);
}
function re2(e2, t2, r2) {
  t2.leading = false, t2.trailing = false, r2 && (t2.marker = r2), Lt(e2, t2);
}
function oe2(e2, t2) {
  t2.leading = false, t2.trailing = true, Lt(e2, t2);
}
var Pt = /* @__PURE__ */ new WeakMap();
function ut2(e2, t2) {
  if (Pt.has(e2))
    return Pt.get(e2);
  let { printer: { getCommentChildNodes: r2, canAttachComment: n2, getVisitorKeys: o2 }, locStart: u2, locEnd: i2 } = t2;
  if (!n2)
    return [];
  let s2 = ((r2 == null ? void 0 : r2(e2, t2)) ?? [...Tt(e2, { getVisitorKeys: X2(o2) })]).flatMap((a2) => n2(a2) ? [a2] : ut2(a2, t2));
  return s2.sort((a2, D) => u2(a2) - u2(D) || i2(a2) - i2(D)), Pt.set(e2, s2), s2;
}
function qr(e2, t2, r2, n2) {
  let { locStart: o2, locEnd: u2 } = r2, i2 = o2(t2), s2 = u2(t2), a2 = ut2(e2, r2), D, l2, d2 = 0, f2 = a2.length;
  for (; d2 < f2; ) {
    let p2 = d2 + f2 >> 1, c2 = a2[p2], F = o2(c2), m = u2(c2);
    if (F <= i2 && s2 <= m)
      return qr(c2, t2, r2, c2);
    if (m <= i2) {
      D = c2, d2 = p2 + 1;
      continue;
    }
    if (s2 <= F) {
      l2 = c2, f2 = p2;
      continue;
    }
    throw new Error("Comment location overlaps with node location");
  }
  if ((n2 == null ? void 0 : n2.type) === "TemplateLiteral") {
    let { quasis: p2 } = n2, c2 = Rt(p2, t2, r2);
    D && Rt(p2, D, r2) !== c2 && (D = null), l2 && Rt(p2, l2, r2) !== c2 && (l2 = null);
  }
  return { enclosingNode: n2, precedingNode: D, followingNode: l2 };
}
var It = () => false;
function Jr(e2, t2) {
  let { comments: r2 } = e2;
  if (delete e2.comments, !kt2(r2) || !t2.printer.canAttachComment)
    return;
  let n2 = [], { locStart: o2, locEnd: u2, printer: { experimentalFeatures: { avoidAstMutation: i2 = false } = {}, handleComments: s2 = {} }, originalText: a2 } = t2, { ownLine: D = It, endOfLine: l2 = It, remaining: d2 = It } = s2, f2 = r2.map((p2, c2) => ({ ...qr(e2, p2, t2), comment: p2, text: a2, options: t2, ast: e2, isLastComment: r2.length - 1 === c2 }));
  for (let [p2, c2] of f2.entries()) {
    let { comment: F, precedingNode: m, enclosingNode: E2, followingNode: A, text: w2, options: h2, ast: C, isLastComment: k } = c2;
    if (h2.parser === "json" || h2.parser === "json5" || h2.parser === "jsonc" || h2.parser === "__js_expression" || h2.parser === "__ts_expression" || h2.parser === "__vue_expression" || h2.parser === "__vue_ts_expression") {
      if (o2(F) - o2(C) <= 0) {
        ue(C, F);
        continue;
      }
      if (u2(F) - u2(C) >= 0) {
        oe2(C, F);
        continue;
      }
    }
    let v2;
    if (i2 ? v2 = [c2] : (F.enclosingNode = E2, F.precedingNode = m, F.followingNode = A, v2 = [F, w2, h2, C, k]), ro(w2, h2, f2, p2))
      F.placement = "ownLine", D(...v2) || (A ? ue(A, F) : m ? oe2(m, F) : E2 ? re2(E2, F) : re2(C, F));
    else if (no(w2, h2, f2, p2))
      F.placement = "endOfLine", l2(...v2) || (m ? oe2(m, F) : A ? ue(A, F) : E2 ? re2(E2, F) : re2(C, F));
    else if (F.placement = "remaining", !d2(...v2))
      if (m && A) {
        let $2 = n2.length;
        $2 > 0 && n2[$2 - 1].followingNode !== A && Kr(n2, h2), n2.push(c2);
      } else
        m ? oe2(m, F) : A ? ue(A, F) : E2 ? re2(E2, F) : re2(C, F);
  }
  if (Kr(n2, t2), !i2)
    for (let p2 of r2)
      delete p2.precedingNode, delete p2.enclosingNode, delete p2.followingNode;
}
var Xr = (e2) => !/[\S\n\u2028\u2029]/u.test(e2);
function ro(e2, t2, r2, n2) {
  let { comment: o2, precedingNode: u2 } = r2[n2], { locStart: i2, locEnd: s2 } = t2, a2 = i2(o2);
  if (u2)
    for (let D = n2 - 1; D >= 0; D--) {
      let { comment: l2, precedingNode: d2 } = r2[D];
      if (d2 !== u2 || !Xr(e2.slice(s2(l2), a2)))
        break;
      a2 = i2(l2);
    }
  return V(e2, a2, { backwards: true });
}
function no(e2, t2, r2, n2) {
  let { comment: o2, followingNode: u2 } = r2[n2], { locStart: i2, locEnd: s2 } = t2, a2 = s2(o2);
  if (u2)
    for (let D = n2 + 1; D < r2.length; D++) {
      let { comment: l2, followingNode: d2 } = r2[D];
      if (d2 !== u2 || !Xr(e2.slice(a2, i2(l2))))
        break;
      a2 = s2(l2);
    }
  return V(e2, a2);
}
function Kr(e2, t2) {
  var s2, a2;
  let r2 = e2.length;
  if (r2 === 0)
    return;
  let { precedingNode: n2, followingNode: o2 } = e2[0], u2 = t2.locStart(o2), i2;
  for (i2 = r2; i2 > 0; --i2) {
    let { comment: D, precedingNode: l2, followingNode: d2 } = e2[i2 - 1];
    ke2.strictEqual(l2, n2), ke2.strictEqual(d2, o2);
    let f2 = t2.originalText.slice(t2.locEnd(D), u2);
    if (((a2 = (s2 = t2.printer).isGap) == null ? void 0 : a2.call(s2, f2, t2)) ?? /^[\s(]*$/u.test(f2))
      u2 = t2.locStart(D);
    else
      break;
  }
  for (let [D, { comment: l2 }] of e2.entries())
    D < i2 ? oe2(n2, l2) : ue(o2, l2);
  for (let D of [n2, o2])
    D.comments && D.comments.length > 1 && D.comments.sort((l2, d2) => t2.locStart(l2) - t2.locStart(d2));
  e2.length = 0;
}
function Rt(e2, t2, r2) {
  let n2 = r2.locStart(t2) - 1;
  for (let o2 = 1; o2 < e2.length; ++o2)
    if (n2 < r2.locStart(e2[o2]))
      return o2 - 1;
  return 0;
}
function uo(e2, t2) {
  let r2 = t2 - 1;
  r2 = T2(e2, r2, { backwards: true }), r2 = M2(e2, r2, { backwards: true }), r2 = T2(e2, r2, { backwards: true });
  let n2 = M2(e2, r2, { backwards: true });
  return r2 !== n2;
}
var Le2 = uo;
function Zr(e2, t2) {
  let r2 = e2.node;
  return r2.printed = true, t2.printer.printComment(e2, t2);
}
function oo(e2, t2) {
  var l2;
  let r2 = e2.node, n2 = [Zr(e2, t2)], { printer: o2, originalText: u2, locStart: i2, locEnd: s2 } = t2;
  if ((l2 = o2.isBlockComment) == null ? void 0 : l2.call(o2, r2)) {
    let d2 = V(u2, s2(r2)) ? V(u2, i2(r2), { backwards: true }) ? q : Ke2 : " ";
    n2.push(d2);
  } else
    n2.push(q);
  let D = M2(u2, T2(u2, s2(r2)));
  return D !== false && V(u2, D) && n2.push(q), n2;
}
function io(e2, t2, r2) {
  var D;
  let n2 = e2.node, o2 = Zr(e2, t2), { printer: u2, originalText: i2, locStart: s2 } = t2, a2 = (D = u2.isBlockComment) == null ? void 0 : D.call(u2, n2);
  if (r2 != null && r2.hasLineSuffix && !(r2 != null && r2.isBlock) || V(i2, s2(n2), { backwards: true })) {
    let l2 = Le2(i2, s2(n2));
    return { doc: xe2([q, l2 ? q : "", o2]), isBlock: a2, hasLineSuffix: true };
  }
  return !a2 || r2 != null && r2.hasLineSuffix ? { doc: [xe2([" ", o2]), de], isBlock: a2, hasLineSuffix: true } : { doc: [" ", o2], isBlock: a2, hasLineSuffix: false };
}
function so(e2, t2) {
  let r2 = e2.node;
  if (!r2)
    return {};
  let n2 = t2[Symbol.for("printedComments")];
  if ((r2.comments || []).filter((a2) => !n2.has(a2)).length === 0)
    return { leading: "", trailing: "" };
  let u2 = [], i2 = [], s2;
  return e2.each(() => {
    let a2 = e2.node;
    if (n2 != null && n2.has(a2))
      return;
    let { leading: D, trailing: l2 } = a2;
    D ? u2.push(oo(e2, t2)) : l2 && (s2 = io(e2, t2, s2), i2.push(s2.doc));
  }, "comments"), { leading: u2, trailing: i2 };
}
function Qr(e2, t2, r2) {
  let { leading: n2, trailing: o2 } = so(e2, r2);
  return !n2 && !o2 ? t2 : Qe2(t2, (u2) => [n2, u2, o2]);
}
function en2(e2) {
  let { [Symbol.for("comments")]: t2, [Symbol.for("printedComments")]: r2 } = e2;
  for (let n2 of t2) {
    if (!n2.printed && !r2.has(n2))
      throw new Error('Comment "' + n2.value.trim() + '" was not printed. Please report this error!');
    delete n2.printed;
  }
}
function ao(e2) {
  return () => {
  };
}
var tn2 = ao;
var Pe2 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "ConfigError");
  }
};
var Ie2 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "UndefinedParserError");
  }
};
var rn2 = { cursorOffset: { category: "Special", type: "int", default: -1, range: { start: -1, end: 1 / 0, step: 1 }, description: "Print (to stderr) where a cursor at the given position would move to after formatting.", cliCategory: "Editor" }, endOfLine: { category: "Global", type: "choice", default: "lf", description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: `Maintain existing
(mixed values within one file are normalised by looking at what's used after the first line)` }] }, filepath: { category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { category: "Special", type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other" }, parser: { category: "Global", type: "choice", default: void 0, description: "Which parser to use.", exception: (e2) => typeof e2 == "string" || typeof e2 == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", description: "JavaScript" }, { value: "babel-flow", description: "Flow" }, { value: "babel-ts", description: "TypeScript" }, { value: "typescript", description: "TypeScript" }, { value: "acorn", description: "JavaScript" }, { value: "espree", description: "JavaScript" }, { value: "meriyah", description: "JavaScript" }, { value: "css", description: "CSS" }, { value: "less", description: "Less" }, { value: "scss", description: "SCSS" }, { value: "json", description: "JSON" }, { value: "json5", description: "JSON5" }, { value: "jsonc", description: "JSON with Comments" }, { value: "json-stringify", description: "JSON.stringify" }, { value: "graphql", description: "GraphQL" }, { value: "markdown", description: "Markdown" }, { value: "mdx", description: "MDX" }, { value: "vue", description: "Vue" }, { value: "yaml", description: "YAML" }, { value: "glimmer", description: "Ember / Handlebars" }, { value: "html", description: "HTML" }, { value: "angular", description: "Angular" }, { value: "lwc", description: "Lightning Web Components" }] }, plugins: { type: "path", array: true, default: [{ value: [] }], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e2) => typeof e2 == "string" || typeof e2 == "object", cliName: "plugin", cliCategory: "Config" }, printWidth: { category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: 1 / 0, step: 1 } }, rangeEnd: { category: "Special", type: "int", default: 1 / 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code ending at a given character offset (exclusive).
The range will extend forwards to the end of the selected statement.`, cliCategory: "Editor" }, rangeStart: { category: "Special", type: "int", default: 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code starting at a given character offset.
The range will extend backwards to the start of the first line containing the selected statement.`, cliCategory: "Editor" }, requirePragma: { category: "Special", type: "boolean", default: false, description: `Require either '@prettier' or '@format' to be present in the file's first docblock comment
in order for it to be formatted.`, cliCategory: "Other" }, tabWidth: { type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: 1 / 0, step: 1 } }, useTabs: { category: "Global", type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { category: "Global", type: "choice", default: "auto", description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
function ot2({ plugins: e2 = [], showDeprecated: t2 = false } = {}) {
  let r2 = e2.flatMap((o2) => o2.languages ?? []), n2 = [];
  for (let o2 of lo(Object.assign({}, ...e2.map(({ options: u2 }) => u2), rn2)))
    !t2 && o2.deprecated || (Array.isArray(o2.choices) && (t2 || (o2.choices = o2.choices.filter((u2) => !u2.deprecated)), o2.name === "parser" && (o2.choices = [...o2.choices, ...Do(o2.choices, r2, e2)])), o2.pluginDefaults = Object.fromEntries(e2.filter((u2) => {
      var i2;
      return ((i2 = u2.defaultOptions) == null ? void 0 : i2[o2.name]) !== void 0;
    }).map((u2) => [u2.name, u2.defaultOptions[o2.name]])), n2.push(o2));
  return { languages: r2, options: n2 };
}
function* Do(e2, t2, r2) {
  let n2 = new Set(e2.map((o2) => o2.value));
  for (let o2 of t2)
    if (o2.parsers) {
      for (let u2 of o2.parsers)
        if (!n2.has(u2)) {
          n2.add(u2);
          let i2 = r2.find((a2) => a2.parsers && Object.prototype.hasOwnProperty.call(a2.parsers, u2)), s2 = o2.name;
          i2 != null && i2.name && (s2 += ` (plugin: ${i2.name})`), yield { value: u2, description: s2 };
        }
    }
}
function lo(e2) {
  let t2 = [];
  for (let [r2, n2] of Object.entries(e2)) {
    let o2 = { name: r2, ...n2 };
    Array.isArray(o2.default) && (o2.default = y2(false, o2.default, -1).value), t2.push(o2);
  }
  return t2;
}
var co = (e2) => String(e2).split(/[/\\]/u).pop();
function nn2(e2, t2) {
  if (!t2)
    return;
  let r2 = co(t2).toLowerCase();
  return e2.find(({ filenames: n2 }) => n2 == null ? void 0 : n2.some((o2) => o2.toLowerCase() === r2)) ?? e2.find(({ extensions: n2 }) => n2 == null ? void 0 : n2.some((o2) => r2.endsWith(o2)));
}
function fo(e2, t2) {
  if (t2)
    return e2.find(({ name: r2 }) => r2.toLowerCase() === t2) ?? e2.find(({ aliases: r2 }) => r2 == null ? void 0 : r2.includes(t2)) ?? e2.find(({ extensions: r2 }) => r2 == null ? void 0 : r2.includes(`.${t2}`));
}
function po(e2, t2) {
  let r2 = e2.plugins.flatMap((o2) => o2.languages ?? []), n2 = fo(r2, t2.language) ?? nn2(r2, t2.physicalFile) ?? nn2(r2, t2.file) ?? (t2.physicalFile, void 0);
  return n2 == null ? void 0 : n2.parsers[0];
}
var un2 = po;
var ie = { key: (e2) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e2) ? e2 : JSON.stringify(e2), value(e2) {
  if (e2 === null || typeof e2 != "object")
    return JSON.stringify(e2);
  if (Array.isArray(e2))
    return `[${e2.map((r2) => ie.value(r2)).join(", ")}]`;
  let t2 = Object.keys(e2);
  return t2.length === 0 ? "{}" : `{ ${t2.map((r2) => `${ie.key(r2)}: ${ie.value(e2[r2])}`).join(", ")} }`;
}, pair: ({ key: e2, value: t2 }) => ie.value({ [e2]: t2 }) };
var Yt = Me2(it2(), 1);
var an2 = (e2, t2, { descriptor: r2 }) => {
  let n2 = [`${Yt.default.yellow(typeof e2 == "string" ? r2.key(e2) : r2.pair(e2))} is deprecated`];
  return t2 && n2.push(`we now treat it as ${Yt.default.blue(typeof t2 == "string" ? r2.key(t2) : r2.pair(t2))}`), n2.join("; ") + ".";
};
var le = Me2(it2(), 1);
var st2 = Symbol.for("vnopts.VALUE_NOT_EXIST");
var he2 = Symbol.for("vnopts.VALUE_UNCHANGED");
var Dn = " ".repeat(2);
var cn2 = (e2, t2, r2) => {
  let { text: n2, list: o2 } = r2.normalizeExpectedResult(r2.schemas[e2].expected(r2)), u2 = [];
  return n2 && u2.push(ln2(e2, t2, n2, r2.descriptor)), o2 && u2.push([ln2(e2, t2, o2.title, r2.descriptor)].concat(o2.values.map((i2) => fn2(i2, r2.loggerPrintWidth))).join(`
`)), pn2(u2, r2.loggerPrintWidth);
};
function ln2(e2, t2, r2, n2) {
  return [`Invalid ${le.default.red(n2.key(e2))} value.`, `Expected ${le.default.blue(r2)},`, `but received ${t2 === st2 ? le.default.gray("nothing") : le.default.red(n2.value(t2))}.`].join(" ");
}
function fn2({ text: e2, list: t2 }, r2) {
  let n2 = [];
  return e2 && n2.push(`- ${le.default.blue(e2)}`), t2 && n2.push([`- ${le.default.blue(t2.title)}:`].concat(t2.values.map((o2) => fn2(o2, r2 - Dn.length).replace(/^|\n/g, `$&${Dn}`))).join(`
`)), pn2(n2, r2);
}
function pn2(e2, t2) {
  if (e2.length === 1)
    return e2[0];
  let [r2, n2] = e2, [o2, u2] = e2.map((i2) => i2.split(`
`, 1)[0].length);
  return o2 > t2 && o2 > u2 ? n2 : r2;
}
var Wt = Me2(it2(), 1);
var jt = [];
var dn2 = [];
function Ht(e2, t2) {
  if (e2 === t2)
    return 0;
  let r2 = e2;
  e2.length > t2.length && (e2 = t2, t2 = r2);
  let n2 = e2.length, o2 = t2.length;
  for (; n2 > 0 && e2.charCodeAt(~-n2) === t2.charCodeAt(~-o2); )
    n2--, o2--;
  let u2 = 0;
  for (; u2 < n2 && e2.charCodeAt(u2) === t2.charCodeAt(u2); )
    u2++;
  if (n2 -= u2, o2 -= u2, n2 === 0)
    return o2;
  let i2, s2, a2, D, l2 = 0, d2 = 0;
  for (; l2 < n2; )
    dn2[l2] = e2.charCodeAt(u2 + l2), jt[l2] = ++l2;
  for (; d2 < o2; )
    for (i2 = t2.charCodeAt(u2 + d2), a2 = d2++, s2 = d2, l2 = 0; l2 < n2; l2++)
      D = i2 === dn2[l2] ? a2 : a2 + 1, a2 = jt[l2], s2 = jt[l2] = a2 > s2 ? D > s2 ? s2 + 1 : D : D > a2 ? a2 + 1 : D;
  return s2;
}
var at2 = (e2, t2, { descriptor: r2, logger: n2, schemas: o2 }) => {
  let u2 = [`Ignored unknown option ${Wt.default.yellow(r2.pair({ key: e2, value: t2 }))}.`], i2 = Object.keys(o2).sort().find((s2) => Ht(e2, s2) < 3);
  i2 && u2.push(`Did you mean ${Wt.default.blue(r2.key(i2))}?`), n2.warn(u2.join(" "));
};
var Fo = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
function mo(e2, t2) {
  let r2 = new e2(t2), n2 = Object.create(r2);
  for (let o2 of Fo)
    o2 in t2 && (n2[o2] = Eo(t2[o2], r2, O.prototype[o2].length));
  return n2;
}
var O = class {
  static create(t2) {
    return mo(this, t2);
  }
  constructor(t2) {
    this.name = t2.name;
  }
  default(t2) {
  }
  expected(t2) {
    return "nothing";
  }
  validate(t2, r2) {
    return false;
  }
  deprecated(t2, r2) {
    return false;
  }
  forward(t2, r2) {
  }
  redirect(t2, r2) {
  }
  overlap(t2, r2, n2) {
    return t2;
  }
  preprocess(t2, r2) {
    return t2;
  }
  postprocess(t2, r2) {
    return he2;
  }
};
function Eo(e2, t2, r2) {
  return typeof e2 == "function" ? (...n2) => e2(...n2.slice(0, r2 - 1), t2, ...n2.slice(r2 - 1)) : () => e2;
}
var Dt = class extends O {
  constructor(t2) {
    super(t2), this._sourceName = t2.sourceName;
  }
  expected(t2) {
    return t2.schemas[this._sourceName].expected(t2);
  }
  validate(t2, r2) {
    return r2.schemas[this._sourceName].validate(t2, r2);
  }
  redirect(t2, r2) {
    return this._sourceName;
  }
};
var lt2 = class extends O {
  expected() {
    return "anything";
  }
  validate() {
    return true;
  }
};
var ct2 = class extends O {
  constructor({ valueSchema: t2, name: r2 = t2.name, ...n2 }) {
    super({ ...n2, name: r2 }), this._valueSchema = t2;
  }
  expected(t2) {
    let { text: r2, list: n2 } = t2.normalizeExpectedResult(this._valueSchema.expected(t2));
    return { text: r2 && `an array of ${r2}`, list: n2 && { title: "an array of the following values", values: [{ list: n2 }] } };
  }
  validate(t2, r2) {
    if (!Array.isArray(t2))
      return false;
    let n2 = [];
    for (let o2 of t2) {
      let u2 = r2.normalizeValidateResult(this._valueSchema.validate(o2, r2), o2);
      u2 !== true && n2.push(u2.value);
    }
    return n2.length === 0 ? true : { value: n2 };
  }
  deprecated(t2, r2) {
    let n2 = [];
    for (let o2 of t2) {
      let u2 = r2.normalizeDeprecatedResult(this._valueSchema.deprecated(o2, r2), o2);
      u2 !== false && n2.push(...u2.map(({ value: i2 }) => ({ value: [i2] })));
    }
    return n2;
  }
  forward(t2, r2) {
    let n2 = [];
    for (let o2 of t2) {
      let u2 = r2.normalizeForwardResult(this._valueSchema.forward(o2, r2), o2);
      n2.push(...u2.map(Fn));
    }
    return n2;
  }
  redirect(t2, r2) {
    let n2 = [], o2 = [];
    for (let u2 of t2) {
      let i2 = r2.normalizeRedirectResult(this._valueSchema.redirect(u2, r2), u2);
      "remain" in i2 && n2.push(i2.remain), o2.push(...i2.redirect.map(Fn));
    }
    return n2.length === 0 ? { redirect: o2 } : { redirect: o2, remain: n2 };
  }
  overlap(t2, r2) {
    return t2.concat(r2);
  }
};
function Fn({ from: e2, to: t2 }) {
  return { from: [e2], to: t2 };
}
var ft = class extends O {
  expected() {
    return "true or false";
  }
  validate(t2) {
    return typeof t2 == "boolean";
  }
};
function En(e2, t2) {
  let r2 = /* @__PURE__ */ Object.create(null);
  for (let n2 of e2) {
    let o2 = n2[t2];
    if (r2[o2])
      throw new Error(`Duplicate ${t2} ${JSON.stringify(o2)}`);
    r2[o2] = n2;
  }
  return r2;
}
function hn2(e2, t2) {
  let r2 = /* @__PURE__ */ new Map();
  for (let n2 of e2) {
    let o2 = n2[t2];
    if (r2.has(o2))
      throw new Error(`Duplicate ${t2} ${JSON.stringify(o2)}`);
    r2.set(o2, n2);
  }
  return r2;
}
function Cn() {
  let e2 = /* @__PURE__ */ Object.create(null);
  return (t2) => {
    let r2 = JSON.stringify(t2);
    return e2[r2] ? true : (e2[r2] = true, false);
  };
}
function gn2(e2, t2) {
  let r2 = [], n2 = [];
  for (let o2 of e2)
    t2(o2) ? r2.push(o2) : n2.push(o2);
  return [r2, n2];
}
function yn2(e2) {
  return e2 === Math.floor(e2);
}
function An(e2, t2) {
  if (e2 === t2)
    return 0;
  let r2 = typeof e2, n2 = typeof t2, o2 = ["undefined", "object", "boolean", "number", "string"];
  return r2 !== n2 ? o2.indexOf(r2) - o2.indexOf(n2) : r2 !== "string" ? Number(e2) - Number(t2) : e2.localeCompare(t2);
}
function Bn2(e2) {
  return (...t2) => {
    let r2 = e2(...t2);
    return typeof r2 == "string" ? new Error(r2) : r2;
  };
}
function Mt(e2) {
  return e2 === void 0 ? {} : e2;
}
function $t(e2) {
  if (typeof e2 == "string")
    return { text: e2 };
  let { text: t2, list: r2 } = e2;
  return ho((t2 || r2) !== void 0, "Unexpected `expected` result, there should be at least one field."), r2 ? { text: t2, list: { title: r2.title, values: r2.values.map($t) } } : { text: t2 };
}
function Vt(e2, t2) {
  return e2 === true ? true : e2 === false ? { value: t2 } : e2;
}
function Ut(e2, t2, r2 = false) {
  return e2 === false ? false : e2 === true ? r2 ? true : [{ value: t2 }] : "value" in e2 ? [e2] : e2.length === 0 ? false : e2;
}
function mn2(e2, t2) {
  return typeof e2 == "string" || "key" in e2 ? { from: t2, to: e2 } : "from" in e2 ? { from: e2.from, to: e2.to } : { from: t2, to: e2.to };
}
function pt2(e2, t2) {
  return e2 === void 0 ? [] : Array.isArray(e2) ? e2.map((r2) => mn2(r2, t2)) : [mn2(e2, t2)];
}
function zt(e2, t2) {
  let r2 = pt2(typeof e2 == "object" && "redirect" in e2 ? e2.redirect : e2, t2);
  return r2.length === 0 ? { remain: t2, redirect: r2 } : typeof e2 == "object" && "remain" in e2 ? { remain: e2.remain, redirect: r2 } : { redirect: r2 };
}
function ho(e2, t2) {
  if (!e2)
    throw new Error(t2);
}
var dt2 = class extends O {
  constructor(t2) {
    super(t2), this._choices = hn2(t2.choices.map((r2) => r2 && typeof r2 == "object" ? r2 : { value: r2 }), "value");
  }
  expected({ descriptor: t2 }) {
    let r2 = Array.from(this._choices.keys()).map((i2) => this._choices.get(i2)).filter(({ hidden: i2 }) => !i2).map((i2) => i2.value).sort(An).map(t2.value), n2 = r2.slice(0, -2), o2 = r2.slice(-2);
    return { text: n2.concat(o2.join(" or ")).join(", "), list: { title: "one of the following values", values: r2 } };
  }
  validate(t2) {
    return this._choices.has(t2);
  }
  deprecated(t2) {
    let r2 = this._choices.get(t2);
    return r2 && r2.deprecated ? { value: t2 } : false;
  }
  forward(t2) {
    let r2 = this._choices.get(t2);
    return r2 ? r2.forward : void 0;
  }
  redirect(t2) {
    let r2 = this._choices.get(t2);
    return r2 ? r2.redirect : void 0;
  }
};
var Ft2 = class extends O {
  expected() {
    return "a number";
  }
  validate(t2, r2) {
    return typeof t2 == "number";
  }
};
var mt2 = class extends Ft2 {
  expected() {
    return "an integer";
  }
  validate(t2, r2) {
    return r2.normalizeValidateResult(super.validate(t2, r2), t2) === true && yn2(t2);
  }
};
var Re2 = class extends O {
  expected() {
    return "a string";
  }
  validate(t2) {
    return typeof t2 == "string";
  }
};
var wn2 = ie;
var xn2 = at2;
var _n = cn2;
var vn2 = an2;
var Et2 = class {
  constructor(t2, r2) {
    let { logger: n2 = console, loggerPrintWidth: o2 = 80, descriptor: u2 = wn2, unknown: i2 = xn2, invalid: s2 = _n, deprecated: a2 = vn2, missing: D = () => false, required: l2 = () => false, preprocess: d2 = (p2) => p2, postprocess: f2 = () => he2 } = r2 || {};
    this._utils = { descriptor: u2, logger: n2 || { warn: () => {
    } }, loggerPrintWidth: o2, schemas: En(t2, "name"), normalizeDefaultResult: Mt, normalizeExpectedResult: $t, normalizeDeprecatedResult: Ut, normalizeForwardResult: pt2, normalizeRedirectResult: zt, normalizeValidateResult: Vt }, this._unknownHandler = i2, this._invalidHandler = Bn2(s2), this._deprecatedHandler = a2, this._identifyMissing = (p2, c2) => !(p2 in c2) || D(p2, c2), this._identifyRequired = l2, this._preprocess = d2, this._postprocess = f2, this.cleanHistory();
  }
  cleanHistory() {
    this._hasDeprecationWarned = Cn();
  }
  normalize(t2) {
    let r2 = {}, o2 = [this._preprocess(t2, this._utils)], u2 = () => {
      for (; o2.length !== 0; ) {
        let i2 = o2.shift(), s2 = this._applyNormalization(i2, r2);
        o2.push(...s2);
      }
    };
    u2();
    for (let i2 of Object.keys(this._utils.schemas)) {
      let s2 = this._utils.schemas[i2];
      if (!(i2 in r2)) {
        let a2 = Mt(s2.default(this._utils));
        "value" in a2 && o2.push({ [i2]: a2.value });
      }
    }
    u2();
    for (let i2 of Object.keys(this._utils.schemas)) {
      if (!(i2 in r2))
        continue;
      let s2 = this._utils.schemas[i2], a2 = r2[i2], D = s2.postprocess(a2, this._utils);
      D !== he2 && (this._applyValidation(D, i2, s2), r2[i2] = D);
    }
    return this._applyPostprocess(r2), this._applyRequiredCheck(r2), r2;
  }
  _applyNormalization(t2, r2) {
    let n2 = [], { knownKeys: o2, unknownKeys: u2 } = this._partitionOptionKeys(t2);
    for (let i2 of o2) {
      let s2 = this._utils.schemas[i2], a2 = s2.preprocess(t2[i2], this._utils);
      this._applyValidation(a2, i2, s2);
      let D = ({ from: p2, to: c2 }) => {
        n2.push(typeof c2 == "string" ? { [c2]: p2 } : { [c2.key]: c2.value });
      }, l2 = ({ value: p2, redirectTo: c2 }) => {
        let F = Ut(s2.deprecated(p2, this._utils), a2, true);
        if (F !== false)
          if (F === true)
            this._hasDeprecationWarned(i2) || this._utils.logger.warn(this._deprecatedHandler(i2, c2, this._utils));
          else
            for (let { value: m } of F) {
              let E2 = { key: i2, value: m };
              if (!this._hasDeprecationWarned(E2)) {
                let A = typeof c2 == "string" ? { key: c2, value: m } : c2;
                this._utils.logger.warn(this._deprecatedHandler(E2, A, this._utils));
              }
            }
      };
      pt2(s2.forward(a2, this._utils), a2).forEach(D);
      let f2 = zt(s2.redirect(a2, this._utils), a2);
      if (f2.redirect.forEach(D), "remain" in f2) {
        let p2 = f2.remain;
        r2[i2] = i2 in r2 ? s2.overlap(r2[i2], p2, this._utils) : p2, l2({ value: p2 });
      }
      for (let { from: p2, to: c2 } of f2.redirect)
        l2({ value: p2, redirectTo: c2 });
    }
    for (let i2 of u2) {
      let s2 = t2[i2];
      this._applyUnknownHandler(i2, s2, r2, (a2, D) => {
        n2.push({ [a2]: D });
      });
    }
    return n2;
  }
  _applyRequiredCheck(t2) {
    for (let r2 of Object.keys(this._utils.schemas))
      if (this._identifyMissing(r2, t2) && this._identifyRequired(r2))
        throw this._invalidHandler(r2, st2, this._utils);
  }
  _partitionOptionKeys(t2) {
    let [r2, n2] = gn2(Object.keys(t2).filter((o2) => !this._identifyMissing(o2, t2)), (o2) => o2 in this._utils.schemas);
    return { knownKeys: r2, unknownKeys: n2 };
  }
  _applyValidation(t2, r2, n2) {
    let o2 = Vt(n2.validate(t2, this._utils), t2);
    if (o2 !== true)
      throw this._invalidHandler(r2, o2.value, this._utils);
  }
  _applyUnknownHandler(t2, r2, n2, o2) {
    let u2 = this._unknownHandler(t2, r2, this._utils);
    if (u2)
      for (let i2 of Object.keys(u2)) {
        if (this._identifyMissing(i2, u2))
          continue;
        let s2 = u2[i2];
        i2 in this._utils.schemas ? o2(i2, s2) : n2[i2] = s2;
      }
  }
  _applyPostprocess(t2) {
    let r2 = this._postprocess(t2, this._utils);
    if (r2 !== he2) {
      if (r2.delete)
        for (let n2 of r2.delete)
          delete t2[n2];
      if (r2.override) {
        let { knownKeys: n2, unknownKeys: o2 } = this._partitionOptionKeys(r2.override);
        for (let u2 of n2) {
          let i2 = r2.override[u2];
          this._applyValidation(i2, u2, this._utils.schemas[u2]), t2[u2] = i2;
        }
        for (let u2 of o2) {
          let i2 = r2.override[u2];
          this._applyUnknownHandler(u2, i2, t2, (s2, a2) => {
            let D = this._utils.schemas[s2];
            this._applyValidation(a2, s2, D), t2[s2] = a2;
          });
        }
      }
    }
  }
};
var Gt;
function go(e2, t2, { logger: r2 = false, isCLI: n2 = false, passThrough: o2 = false, FlagSchema: u2, descriptor: i2 } = {}) {
  if (n2) {
    if (!u2)
      throw new Error("'FlagSchema' option is required.");
    if (!i2)
      throw new Error("'descriptor' option is required.");
  } else
    i2 = ie;
  let s2 = o2 ? Array.isArray(o2) ? (f2, p2) => o2.includes(f2) ? { [f2]: p2 } : void 0 : (f2, p2) => ({ [f2]: p2 }) : (f2, p2, c2) => {
    let { _: F, ...m } = c2.schemas;
    return at2(f2, p2, { ...c2, schemas: m });
  }, a2 = yo(t2, { isCLI: n2, FlagSchema: u2 }), D = new Et2(a2, { logger: r2, unknown: s2, descriptor: i2 }), l2 = r2 !== false;
  l2 && Gt && (D._hasDeprecationWarned = Gt);
  let d2 = D.normalize(e2);
  return l2 && (Gt = D._hasDeprecationWarned), d2;
}
function yo(e2, { isCLI: t2, FlagSchema: r2 }) {
  let n2 = [];
  t2 && n2.push(lt2.create({ name: "_" }));
  for (let o2 of e2)
    n2.push(Ao(o2, { isCLI: t2, optionInfos: e2, FlagSchema: r2 })), o2.alias && t2 && n2.push(Dt.create({ name: o2.alias, sourceName: o2.name }));
  return n2;
}
function Ao(e2, { isCLI: t2, optionInfos: r2, FlagSchema: n2 }) {
  let { name: o2 } = e2, u2 = { name: o2 }, i2, s2 = {};
  switch (e2.type) {
    case "int":
      i2 = mt2, t2 && (u2.preprocess = Number);
      break;
    case "string":
      i2 = Re2;
      break;
    case "choice":
      i2 = dt2, u2.choices = e2.choices.map((a2) => a2 != null && a2.redirect ? { ...a2, redirect: { to: { key: e2.name, value: a2.redirect } } } : a2);
      break;
    case "boolean":
      i2 = ft;
      break;
    case "flag":
      i2 = n2, u2.flags = r2.flatMap((a2) => [a2.alias, a2.description && a2.name, a2.oppositeDescription && `no-${a2.name}`].filter(Boolean));
      break;
    case "path":
      i2 = Re2;
      break;
    default:
      throw new Error(`Unexpected type ${e2.type}`);
  }
  if (e2.exception ? u2.validate = (a2, D, l2) => e2.exception(a2) || D.validate(a2, l2) : u2.validate = (a2, D, l2) => a2 === void 0 || D.validate(a2, l2), e2.redirect && (s2.redirect = (a2) => a2 ? { to: typeof e2.redirect == "string" ? e2.redirect : { key: e2.redirect.option, value: e2.redirect.value } } : void 0), e2.deprecated && (s2.deprecated = true), t2 && !e2.array) {
    let a2 = u2.preprocess || ((D) => D);
    u2.preprocess = (D, l2, d2) => l2.preprocess(a2(Array.isArray(D) ? y2(false, D, -1) : D), d2);
  }
  return e2.array ? ct2.create({ ...t2 ? { preprocess: (a2) => Array.isArray(a2) ? a2 : [a2] } : {}, ...s2, valueSchema: i2.create(u2) }) : i2.create({ ...u2, ...s2 });
}
var bn2 = go;
var Bo2 = (e2, t2, r2) => {
  if (!(e2 && t2 == null)) {
    if (t2.findLast)
      return t2.findLast(r2);
    for (let n2 = t2.length - 1; n2 >= 0; n2--) {
      let o2 = t2[n2];
      if (r2(o2, n2, t2))
        return o2;
    }
  }
};
var Kt = Bo2;
function qt(e2, t2) {
  if (!t2)
    throw new Error("parserName is required.");
  let r2 = Kt(false, e2, (o2) => o2.parsers && Object.prototype.hasOwnProperty.call(o2.parsers, t2));
  if (r2)
    return r2;
  let n2 = `Couldn't resolve parser "${t2}".`;
  throw n2 += " Plugins must be explicitly added to the standalone bundle.", new Pe2(n2);
}
function On(e2, t2) {
  if (!t2)
    throw new Error("astFormat is required.");
  let r2 = Kt(false, e2, (o2) => o2.printers && Object.prototype.hasOwnProperty.call(o2.printers, t2));
  if (r2)
    return r2;
  let n2 = `Couldn't find plugin for AST format "${t2}".`;
  throw n2 += " Plugins must be explicitly added to the standalone bundle.", new Pe2(n2);
}
function ht2({ plugins: e2, parser: t2 }) {
  let r2 = qt(e2, t2);
  return Jt(r2, t2);
}
function Jt(e2, t2) {
  let r2 = e2.parsers[t2];
  return typeof r2 == "function" ? r2() : r2;
}
function Sn2(e2, t2) {
  let r2 = e2.printers[t2];
  return typeof r2 == "function" ? r2() : r2;
}
var Nn = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
async function wo(e2, t2 = {}) {
  var d2;
  let r2 = { ...e2 };
  if (!r2.parser)
    if (r2.filepath) {
      if (r2.parser = un2(r2, { physicalFile: r2.filepath }), !r2.parser)
        throw new Ie2(`No parser could be inferred for file "${r2.filepath}".`);
    } else
      throw new Ie2("No parser and no file path given, couldn't infer a parser.");
  let n2 = ot2({ plugins: e2.plugins, showDeprecated: true }).options, o2 = { ...Nn, ...Object.fromEntries(n2.filter((f2) => f2.default !== void 0).map((f2) => [f2.name, f2.default])) }, u2 = qt(r2.plugins, r2.parser), i2 = await Jt(u2, r2.parser);
  r2.astFormat = i2.astFormat, r2.locEnd = i2.locEnd, r2.locStart = i2.locStart;
  let s2 = (d2 = u2.printers) != null && d2[i2.astFormat] ? u2 : On(r2.plugins, i2.astFormat), a2 = await Sn2(s2, i2.astFormat);
  r2.printer = a2;
  let D = s2.defaultOptions ? Object.fromEntries(Object.entries(s2.defaultOptions).filter(([, f2]) => f2 !== void 0)) : {}, l2 = { ...o2, ...D };
  for (let [f2, p2] of Object.entries(l2))
    (r2[f2] === null || r2[f2] === void 0) && (r2[f2] = p2);
  return r2.parser === "json" && (r2.trailingComma = "none"), bn2(r2, n2, { passThrough: Object.keys(Nn), ...t2 });
}
var se = wo;
var Vn2 = Me2($n2(), 1);
async function ko(e2, t2) {
  let r2 = await ht2(t2), n2 = r2.preprocess ? r2.preprocess(e2, t2) : e2;
  t2.originalText = n2;
  let o2;
  try {
    o2 = await r2.parse(n2, t2, t2);
  } catch (u2) {
    Lo(u2, e2);
  }
  return { text: n2, ast: o2 };
}
function Lo(e2, t2) {
  let { loc: r2 } = e2;
  if (r2) {
    let n2 = (0, Vn2.codeFrameColumns)(t2, r2, { highlightCode: true });
    throw e2.message += `
` + n2, e2.codeFrame = n2, e2;
  }
  throw e2;
}
var ce2 = ko;
async function Un2(e2, t2, r2, n2, o2) {
  let { embeddedLanguageFormatting: u2, printer: { embed: i2, hasPrettierIgnore: s2 = () => false, getVisitorKeys: a2 } } = r2;
  if (!i2 || u2 !== "auto")
    return;
  if (i2.length > 2)
    throw new Error("printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/en/plugins.html#optional-embed");
  let D = X2(i2.getVisitorKeys ?? a2), l2 = [];
  p2();
  let d2 = e2.stack;
  for (let { print: c2, node: F, pathStack: m } of l2)
    try {
      e2.stack = m;
      let E2 = await c2(f2, t2, e2, r2);
      E2 && o2.set(F, E2);
    } catch (E2) {
      if (globalThis.PRETTIER_DEBUG)
        throw E2;
    }
  e2.stack = d2;
  function f2(c2, F) {
    return Po(c2, F, r2, n2);
  }
  function p2() {
    let { node: c2 } = e2;
    if (c2 === null || typeof c2 != "object" || s2(e2))
      return;
    for (let m of D(c2))
      Array.isArray(c2[m]) ? e2.each(p2, m) : e2.call(p2, m);
    let F = i2(e2, r2);
    if (F) {
      if (typeof F == "function") {
        l2.push({ print: F, node: c2, pathStack: [...e2.stack] });
        return;
      }
      o2.set(c2, F);
    }
  }
}
async function Po(e2, t2, r2, n2) {
  let o2 = await se({ ...r2, ...t2, parentParser: r2.parser, originalText: e2 }, { passThrough: true }), { ast: u2 } = await ce2(e2, o2), i2 = await n2(u2, o2);
  return Ze(i2);
}
function Io(e2, t2) {
  let { originalText: r2, [Symbol.for("comments")]: n2, locStart: o2, locEnd: u2, [Symbol.for("printedComments")]: i2 } = t2, { node: s2 } = e2, a2 = o2(s2), D = u2(s2);
  for (let l2 of n2)
    o2(l2) >= a2 && u2(l2) <= D && i2.add(l2);
  return r2.slice(a2, D);
}
var zn2 = Io;
async function Ye(e2, t2) {
  ({ ast: e2 } = await Qt(e2, t2));
  let r2 = /* @__PURE__ */ new Map(), n2 = new Mr(e2), o2 = tn2(t2), u2 = /* @__PURE__ */ new Map();
  await Un2(n2, s2, t2, Ye, u2);
  let i2 = await Gn2(n2, t2, s2, void 0, u2);
  return en2(t2), i2;
  function s2(D, l2) {
    return D === void 0 || D === n2 ? a2(l2) : Array.isArray(D) ? n2.call(() => a2(l2), ...D) : n2.call(() => a2(l2), D);
  }
  function a2(D) {
    o2(n2);
    let l2 = n2.node;
    if (l2 == null)
      return "";
    let d2 = l2 && typeof l2 == "object" && D === void 0;
    if (d2 && r2.has(l2))
      return r2.get(l2);
    let f2 = Gn2(n2, t2, s2, D, u2);
    return d2 && r2.set(l2, f2), f2;
  }
}
function Gn2(e2, t2, r2, n2, o2) {
  var a2;
  let { node: u2 } = e2, { printer: i2 } = t2, s2;
  return (a2 = i2.hasPrettierIgnore) != null && a2.call(i2, e2) ? s2 = zn2(e2, t2) : o2.has(u2) ? s2 = o2.get(u2) : s2 = i2.print(e2, t2, r2, n2), u2 === t2.cursorNode && (s2 = Qe2(s2, (D) => [ve2, D, ve2])), i2.printComment && (!i2.willPrintOwnComments || !i2.willPrintOwnComments(e2, t2)) && (s2 = Qr(e2, s2, t2)), s2;
}
async function Qt(e2, t2) {
  let r2 = e2.comments ?? [];
  t2[Symbol.for("comments")] = r2, t2[Symbol.for("tokens")] = e2.tokens ?? [], t2[Symbol.for("printedComments")] = /* @__PURE__ */ new Set(), Jr(e2, t2);
  let { printer: { preprocess: n2 } } = t2;
  return e2 = n2 ? await n2(e2, t2) : e2, { ast: e2, comments: r2 };
}
function Ro2(e2, t2) {
  let { cursorOffset: r2, locStart: n2, locEnd: o2 } = t2, u2 = X2(t2.printer.getVisitorKeys), i2 = (a2) => n2(a2) <= r2 && o2(a2) >= r2, s2 = e2;
  for (let a2 of Ur(e2, { getVisitorKeys: u2, filter: i2 }))
    s2 = a2;
  return s2;
}
var Kn2 = Ro2;
function Yo(e2, t2) {
  let { printer: { massageAstNode: r2, getVisitorKeys: n2 } } = t2;
  if (!r2)
    return e2;
  let o2 = X2(n2), u2 = r2.ignoredProperties ?? /* @__PURE__ */ new Set();
  return i2(e2);
  function i2(s2, a2) {
    if (!(s2 !== null && typeof s2 == "object"))
      return s2;
    if (Array.isArray(s2))
      return s2.map((f2) => i2(f2, a2)).filter(Boolean);
    let D = {}, l2 = new Set(o2(s2));
    for (let f2 in s2)
      !Object.prototype.hasOwnProperty.call(s2, f2) || u2.has(f2) || (l2.has(f2) ? D[f2] = i2(s2[f2], s2) : D[f2] = s2[f2]);
    let d2 = r2(s2, D, a2);
    if (d2 !== null)
      return d2 ?? D;
  }
}
var qn = Yo;
var jo = (e2, t2, r2) => {
  if (!(e2 && t2 == null)) {
    if (t2.findLastIndex)
      return t2.findLastIndex(r2);
    for (let n2 = t2.length - 1; n2 >= 0; n2--) {
      let o2 = t2[n2];
      if (r2(o2, n2, t2))
        return n2;
    }
    return -1;
  }
};
var Jn = jo;
var Ho = ({ parser: e2 }) => e2 === "json" || e2 === "json5" || e2 === "jsonc" || e2 === "json-stringify";
function Wo(e2, t2) {
  let r2 = [e2.node, ...e2.parentNodes], n2 = /* @__PURE__ */ new Set([t2.node, ...t2.parentNodes]);
  return r2.find((o2) => Qn2.has(o2.type) && n2.has(o2));
}
function Xn(e2) {
  let t2 = Jn(false, e2, (r2) => r2.type !== "Program" && r2.type !== "File");
  return t2 === -1 ? e2 : e2.slice(0, t2 + 1);
}
function Mo(e2, t2, { locStart: r2, locEnd: n2 }) {
  let o2 = e2.node, u2 = t2.node;
  if (o2 === u2)
    return { startNode: o2, endNode: u2 };
  let i2 = r2(e2.node);
  for (let a2 of Xn(t2.parentNodes))
    if (r2(a2) >= i2)
      u2 = a2;
    else
      break;
  let s2 = n2(t2.node);
  for (let a2 of Xn(e2.parentNodes)) {
    if (n2(a2) <= s2)
      o2 = a2;
    else
      break;
    if (o2 === u2)
      break;
  }
  return { startNode: o2, endNode: u2 };
}
function er(e2, t2, r2, n2, o2 = [], u2) {
  let { locStart: i2, locEnd: s2 } = r2, a2 = i2(e2), D = s2(e2);
  if (!(t2 > D || t2 < a2 || u2 === "rangeEnd" && t2 === a2 || u2 === "rangeStart" && t2 === D)) {
    for (let l2 of ut2(e2, r2)) {
      let d2 = er(l2, t2, r2, n2, [e2, ...o2], u2);
      if (d2)
        return d2;
    }
    if (!n2 || n2(e2, o2[0]))
      return { node: e2, parentNodes: o2 };
  }
}
function $o(e2, t2) {
  return t2 !== "DeclareExportDeclaration" && e2 !== "TypeParameterDeclaration" && (e2 === "Directive" || e2 === "TypeAlias" || e2 === "TSExportAssignment" || e2.startsWith("Declare") || e2.startsWith("TSDeclare") || e2.endsWith("Statement") || e2.endsWith("Declaration"));
}
var Qn2 = /* @__PURE__ */ new Set(["JsonRoot", "ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]);
var Vo = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
function Zn2(e2, t2, r2) {
  if (!t2)
    return false;
  switch (e2.parser) {
    case "flow":
    case "babel":
    case "babel-flow":
    case "babel-ts":
    case "typescript":
    case "acorn":
    case "espree":
    case "meriyah":
    case "__babel_estree":
      return $o(t2.type, r2 == null ? void 0 : r2.type);
    case "json":
    case "json5":
    case "jsonc":
    case "json-stringify":
      return Qn2.has(t2.type);
    case "graphql":
      return Vo.has(t2.kind);
    case "vue":
      return t2.tag !== "root";
  }
  return false;
}
function eu(e2, t2, r2) {
  let { rangeStart: n2, rangeEnd: o2, locStart: u2, locEnd: i2 } = t2;
  ke2.ok(o2 > n2);
  let s2 = e2.slice(n2, o2).search(/\S/u), a2 = s2 === -1;
  if (!a2)
    for (n2 += s2; o2 > n2 && !/\S/u.test(e2[o2 - 1]); --o2)
      ;
  let D = er(r2, n2, t2, (p2, c2) => Zn2(t2, p2, c2), [], "rangeStart"), l2 = a2 ? D : er(r2, o2, t2, (p2) => Zn2(t2, p2), [], "rangeEnd");
  if (!D || !l2)
    return { rangeStart: 0, rangeEnd: 0 };
  let d2, f2;
  if (Ho(t2)) {
    let p2 = Wo(D, l2);
    d2 = p2, f2 = p2;
  } else
    ({ startNode: d2, endNode: f2 } = Mo(D, l2, t2));
  return { rangeStart: Math.min(u2(d2), u2(f2)), rangeEnd: Math.max(i2(d2), i2(f2)) };
}
var uu = "\uFEFF";
var tu = Symbol("cursor");
async function ou2(e2, t2, r2 = 0) {
  if (!e2 || e2.trim().length === 0)
    return { formatted: "", cursorOffset: -1, comments: [] };
  let { ast: n2, text: o2 } = await ce2(e2, t2);
  t2.cursorOffset >= 0 && (t2.cursorNode = Kn2(n2, t2));
  let u2 = await Ye(n2, t2, r2);
  r2 > 0 && (u2 = Je([q, u2], r2, t2.tabWidth));
  let i2 = Fe2(u2, t2);
  if (r2 > 0) {
    let a2 = i2.formatted.trim();
    i2.cursorNodeStart !== void 0 && (i2.cursorNodeStart -= i2.formatted.indexOf(a2)), i2.formatted = a2 + Be2(t2.endOfLine);
  }
  let s2 = t2[Symbol.for("comments")];
  if (t2.cursorOffset >= 0) {
    let a2, D, l2, d2, f2;
    if (t2.cursorNode && i2.cursorNodeText ? (a2 = t2.locStart(t2.cursorNode), D = o2.slice(a2, t2.locEnd(t2.cursorNode)), l2 = t2.cursorOffset - a2, d2 = i2.cursorNodeStart, f2 = i2.cursorNodeText) : (a2 = 0, D = o2, l2 = t2.cursorOffset, d2 = 0, f2 = i2.formatted), D === f2)
      return { formatted: i2.formatted, cursorOffset: d2 + l2, comments: s2 };
    let p2 = D.split("");
    p2.splice(l2, 0, tu);
    let c2 = f2.split(""), F = dr2(p2, c2), m = d2;
    for (let E2 of F)
      if (E2.removed) {
        if (E2.value.includes(tu))
          break;
      } else
        m += E2.count;
    return { formatted: i2.formatted, cursorOffset: m, comments: s2 };
  }
  return { formatted: i2.formatted, cursorOffset: -1, comments: s2 };
}
async function Uo(e2, t2) {
  let { ast: r2, text: n2 } = await ce2(e2, t2), { rangeStart: o2, rangeEnd: u2 } = eu(n2, t2, r2), i2 = n2.slice(o2, u2), s2 = Math.min(o2, n2.lastIndexOf(`
`, o2) + 1), a2 = n2.slice(s2, o2).match(/^\s*/u)[0], D = me(a2, t2.tabWidth), l2 = await ou2(i2, { ...t2, rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: t2.cursorOffset > o2 && t2.cursorOffset <= u2 ? t2.cursorOffset - o2 : -1, endOfLine: "lf" }, D), d2 = l2.formatted.trimEnd(), { cursorOffset: f2 } = t2;
  f2 > u2 ? f2 += d2.length - i2.length : l2.cursorOffset >= 0 && (f2 = l2.cursorOffset + o2);
  let p2 = n2.slice(0, o2) + d2 + n2.slice(u2);
  if (t2.endOfLine !== "lf") {
    let c2 = Be2(t2.endOfLine);
    f2 >= 0 && c2 === `\r
` && (f2 += wt2(p2.slice(0, f2), `
`)), p2 = ne2(false, p2, `
`, c2);
  }
  return { formatted: p2, cursorOffset: f2, comments: l2.comments };
}
function tr(e2, t2, r2) {
  return typeof t2 != "number" || Number.isNaN(t2) || t2 < 0 || t2 > e2.length ? r2 : t2;
}
function ru(e2, t2) {
  let { cursorOffset: r2, rangeStart: n2, rangeEnd: o2 } = t2;
  return r2 = tr(e2, r2, -1), n2 = tr(e2, n2, 0), o2 = tr(e2, o2, e2.length), { ...t2, cursorOffset: r2, rangeStart: n2, rangeEnd: o2 };
}
function iu(e2, t2) {
  let { cursorOffset: r2, rangeStart: n2, rangeEnd: o2, endOfLine: u2 } = ru(e2, t2), i2 = e2.charAt(0) === uu;
  if (i2 && (e2 = e2.slice(1), r2--, n2--, o2--), u2 === "auto" && (u2 = Fr(e2)), e2.includes("\r")) {
    let s2 = (a2) => wt2(e2.slice(0, Math.max(a2, 0)), `\r
`);
    r2 -= s2(r2), n2 -= s2(n2), o2 -= s2(o2), e2 = mr(e2);
  }
  return { hasBOM: i2, text: e2, options: ru(e2, { ...t2, cursorOffset: r2, rangeStart: n2, rangeEnd: o2, endOfLine: u2 }) };
}
async function nu(e2, t2) {
  let r2 = await ht2(t2);
  return !r2.hasPragma || r2.hasPragma(e2);
}
async function rr(e2, t2) {
  let { hasBOM: r2, text: n2, options: o2 } = iu(e2, await se(t2));
  if (o2.rangeStart >= o2.rangeEnd && n2 !== "" || o2.requirePragma && !await nu(n2, o2))
    return { formatted: e2, cursorOffset: t2.cursorOffset, comments: [] };
  let u2;
  return o2.rangeStart > 0 || o2.rangeEnd < n2.length ? u2 = await Uo(n2, o2) : (!o2.requirePragma && o2.insertPragma && o2.printer.insertPragma && !await nu(n2, o2) && (n2 = o2.printer.insertPragma(n2)), u2 = await ou2(n2, o2)), r2 && (u2.formatted = uu + u2.formatted, u2.cursorOffset >= 0 && u2.cursorOffset++), u2;
}
async function su2(e2, t2, r2) {
  let { text: n2, options: o2 } = iu(e2, await se(t2)), u2 = await ce2(n2, o2);
  return r2 && (r2.preprocessForPrint && (u2.ast = await Qt(u2.ast, o2)), r2.massage && (u2.ast = qn(u2.ast, o2))), u2;
}
async function au(e2, t2) {
  t2 = await se(t2);
  let r2 = await Ye(e2, t2);
  return Fe2(r2, t2);
}
async function Du(e2, t2) {
  let r2 = Or(e2), { formatted: n2 } = await rr(r2, { ...t2, parser: "__js_expression" });
  return n2;
}
async function lu2(e2, t2) {
  t2 = await se(t2);
  let { ast: r2 } = await ce2(e2, t2);
  return Ye(r2, t2);
}
async function cu(e2, t2) {
  return Fe2(e2, await se(t2));
}
var nr = {};
We(nr, { builders: () => Go, printer: () => Ko2, utils: () => qo });
var Go = { join: be2, line: Ke2, softline: vr2, hardline: q, literalline: qe, group: _t, conditionalGroup: Ar2, fill: Ge2, lineSuffix: xe2, lineSuffixBoundary: xr2, cursor: ve2, breakParent: de, ifBreak: Br, trim: _r2, indent: De2, indentIfBreak: wr, align: ae, addAlignmentToDoc: Je, markAsRoot: gr2, dedentToRoot: Cr, dedent: yr2, hardlineWithoutBreakParent: _e2, literallineWithoutBreakParent: vt, label: br2, concat: (e2) => e2 };
var Ko2 = { printDocToString: Fe2 };
var qo = { willBreak: Ir, traverseDoc: we2, findInDoc: Xe, mapDoc: Ne, removeLines: Yr2, stripTrailingHardline: Ze, replaceEndOfLine: jr2, canBreak: Hr2 };
var fu = "3.3.3";
var or2 = {};
We(or2, { addDanglingComment: () => re2, addLeadingComment: () => ue, addTrailingComment: () => oe2, getAlignmentSize: () => me, getIndentSize: () => pu2, getMaxContinuousCount: () => du2, getNextNonSpaceNonCommentCharacter: () => Fu, getNextNonSpaceNonCommentCharacterIndex: () => si, getStringWidth: () => Oe2, hasNewline: () => V, hasNewlineInRange: () => mu, hasSpaces: () => Eu, isNextLineEmpty: () => ci2, isNextLineEmptyAfterIndex: () => gt, isPreviousLineEmpty: () => Di, makeString: () => hu, skip: () => Ee, skipEverythingButNewLine: () => nt2, skipInlineComment: () => Ce2, skipNewline: () => M2, skipSpaces: () => T2, skipToLineEnd: () => rt2, skipTrailingComment: () => ge, skipWhitespace: () => zr });
function Jo(e2, t2) {
  if (t2 === false)
    return false;
  if (e2.charAt(t2) === "/" && e2.charAt(t2 + 1) === "*") {
    for (let r2 = t2 + 2; r2 < e2.length; ++r2)
      if (e2.charAt(r2) === "*" && e2.charAt(r2 + 1) === "/")
        return r2 + 2;
  }
  return t2;
}
var Ce2 = Jo;
function Xo(e2, t2) {
  return t2 === false ? false : e2.charAt(t2) === "/" && e2.charAt(t2 + 1) === "/" ? nt2(e2, t2) : t2;
}
var ge = Xo;
function Zo(e2, t2) {
  let r2 = null, n2 = t2;
  for (; n2 !== r2; )
    r2 = n2, n2 = T2(e2, n2), n2 = Ce2(e2, n2), n2 = ge(e2, n2), n2 = M2(e2, n2);
  return n2;
}
var je = Zo;
function Qo(e2, t2) {
  let r2 = null, n2 = t2;
  for (; n2 !== r2; )
    r2 = n2, n2 = rt2(e2, n2), n2 = Ce2(e2, n2), n2 = T2(e2, n2);
  return n2 = ge(e2, n2), n2 = M2(e2, n2), n2 !== false && V(e2, n2);
}
var gt = Qo;
function ei2(e2, t2) {
  let r2 = e2.lastIndexOf(`
`);
  return r2 === -1 ? 0 : me(e2.slice(r2 + 1).match(/^[\t ]*/u)[0], t2);
}
var pu2 = ei2;
function ur2(e2) {
  if (typeof e2 != "string")
    throw new TypeError("Expected a string");
  return e2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function ti(e2, t2) {
  let r2 = e2.match(new RegExp(`(${ur2(t2)})+`, "gu"));
  return r2 === null ? 0 : r2.reduce((n2, o2) => Math.max(n2, o2.length / t2.length), 0);
}
var du2 = ti;
function ri2(e2, t2) {
  let r2 = je(e2, t2);
  return r2 === false ? "" : e2.charAt(r2);
}
var Fu = ri2;
function ni(e2, t2, r2) {
  for (let n2 = t2; n2 < r2; ++n2)
    if (e2.charAt(n2) === `
`)
      return true;
  return false;
}
var mu = ni;
function ui(e2, t2, r2 = {}) {
  return T2(e2, r2.backwards ? t2 - 1 : t2, r2) !== t2;
}
var Eu = ui;
function oi(e2, t2, r2) {
  let n2 = t2 === '"' ? "'" : '"', u2 = ne2(false, e2, /\\(.)|(["'])/gsu, (i2, s2, a2) => s2 === n2 ? s2 : a2 === t2 ? "\\" + a2 : a2 || (r2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(s2) ? s2 : "\\" + s2));
  return t2 + u2 + t2;
}
var hu = oi;
function ii(e2, t2, r2) {
  return je(e2, r2(t2));
}
function si(e2, t2) {
  return arguments.length === 2 || typeof t2 == "number" ? je(e2, t2) : ii(...arguments);
}
function ai(e2, t2, r2) {
  return Le2(e2, r2(t2));
}
function Di(e2, t2) {
  return arguments.length === 2 || typeof t2 == "number" ? Le2(e2, t2) : ai(...arguments);
}
function li2(e2, t2, r2) {
  return gt(e2, r2(t2));
}
function ci2(e2, t2) {
  return arguments.length === 2 || typeof t2 == "number" ? gt(e2, t2) : li2(...arguments);
}
function fe(e2, t2 = 1) {
  return async (...r2) => {
    let n2 = r2[t2] ?? {}, o2 = n2.plugins ?? [];
    return r2[t2] = { ...n2, plugins: Array.isArray(o2) ? o2 : Object.values(o2) }, e2(...r2);
  };
}
var Cu2 = fe(rr);
async function gu(e2, t2) {
  let { formatted: r2 } = await Cu2(e2, { ...t2, cursorOffset: -1 });
  return r2;
}
async function fi(e2, t2) {
  return await gu(e2, t2) === e2;
}
var pi2 = fe(ot2, 0);
var di = { parse: fe(su2), formatAST: fe(au), formatDoc: fe(Du), printToDoc: fe(lu2), printDocToString: fe(cu) };

// node_modules/@react-three/uikit/dist/convert/html/index.js
var starBabel = __toESM(require_babel(), 1);
var starEstree = __toESM(require_estree(), 1);

// node_modules/@react-three/uikit/dist/convert/html/preview.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var import_react19 = __toESM(require_react(), 1);
function PreviewHtml({ children, colorMap, customHook }) {
  const { classes, element } = (0, import_react19.useMemo)(() => parseHtml(children, colorMap), [children, colorMap]);
  return (0, import_jsx_runtime17.jsx)(PreviewParsedHtml, { classes, element, colorMap, customHook });
}
function PreviewParsedHtml({ classes, element, colorMap, componentMap, customHook }) {
  return (0, import_react19.useMemo)(() => {
    try {
      return convertParsedHtml(element, classes, createRenderElement(componentMap, customHook), colorMap, componentMap);
    } catch (e2) {
      console.error(e2);
      return null;
    }
  }, [element, classes, componentMap, colorMap, customHook]);
}
function createRenderElement(componentMap, customHook) {
  const Component2 = ({ custom, props, typeName, children, element }) => {
    const ref = (0, import_react19.useRef)(null);
    props = (customHook == null ? void 0 : customHook(element, ref, props)) ?? props;
    if (custom && componentMap != null) {
      const Component3 = componentMap[typeName].renderAsImpl;
      if (Component3 == null) {
        throw new Error(`unknown custom component "${typeName}"`);
      }
      return (0, import_jsx_runtime17.jsx)(Component3, { ...props, ref, children });
    }
    switch (typeName) {
      case "Video":
        return (0, import_jsx_runtime17.jsx)(Video, { ...props, ref });
      case "Image":
        return (0, import_jsx_runtime17.jsx)(Image2, { ...props, ref, children });
      case "Svg":
        return (0, import_jsx_runtime17.jsx)(Svg, { ...props, ref, children });
      case "Icon":
        return (0, import_jsx_runtime17.jsx)(Icon, { ...props, ref });
      case "Input":
        return (0, import_jsx_runtime17.jsx)(Input, { ...props, ref });
      case "Text":
        return (0, import_jsx_runtime17.jsx)(Text, { ...props, ref, children: (children == null ? void 0 : children.join("")) ?? "" });
      case "Container":
        return (0, import_jsx_runtime17.jsx)(Container, { ...props, ref, children });
      case "DefaultProperties":
        return (0, import_jsx_runtime17.jsx)(DefaultProperties, { ...props, children });
      case "Fragment":
        return (0, import_jsx_runtime17.jsx)(import_jsx_runtime17.Fragment, { children });
    }
  };
  return (element, typeName, custom, props, index, children) => (0, import_jsx_runtime17.jsx)(Component2, { element, custom, props, typeName, children }, index);
}

// node_modules/@react-three/uikit/dist/convert/html/index.js
function htmlToCode2(html, colorMap, componentMap) {
  const { classes, element } = parseHtml(html, colorMap);
  return parsedHtmlToCode(element, classes, colorMap, componentMap);
}
function parsedHtmlToCode(element, classes, colorMap, componentMap) {
  return gu(`export default function Index() { return ${convertParsedHtml(element, classes, elementToCode, colorMap, componentMap) ?? `null`} }`, {
    parser: "babel",
    plugins: [starBabel.default ?? starBabel, starEstree.default ?? starEstree],
    semi: false
  });
}
function elementToCode(element, typeName, custom, props, index, children) {
  const propsText = Object.entries(props).filter(([, value]) => typeof value != "undefined").map(([name, value]) => {
    const firstChar = name[0];
    if ("0" <= firstChar && firstChar <= "9") {
      return `{...${JSON.stringify({ [name]: value })}}`;
    }
    if (name === "panelMaterialClass" && typeof value === "function") {
      return `${name}={${value.name}}`;
    }
    switch (typeof value) {
      case "number":
        return `${name}={${value}}`;
      case "string":
        if (value.includes("\n")) {
          return `${name}={\`${value.replaceAll("`", "\\`")}\`}`;
        }
        return `${name}="${value.replaceAll('"', "'")}"`;
      case "boolean":
        return `${name}={${value ? "true" : "false"}}`;
      case "object":
        return `${name}={${JSON.stringify(value)}}`;
    }
    throw new Error(`unable to generate property "${name}" with value of type "${typeof value}"`);
  }).join(" ");
  if (children == null) {
    return `<${typeName} ${propsText} />`;
  }
  if (typeName === "Fragment") {
    typeName = "";
  }
  return `<${typeName} ${propsText} >${children.join("\n")}</${typeName}>`;
}
var export_ConversionHtmlNode = import_node_html_parser2.HTMLElement;
var export_ConversionNode = import_node_html_parser2.Node;
export {
  Container,
  Content,
  export_ConversionHtmlNode as ConversionHtmlNode,
  export_ConversionNode as ConversionNode,
  CustomContainer,
  DefaultProperties,
  FontFamilyProvider,
  Fullscreen,
  GlassMaterial,
  Icon,
  Image2 as Image,
  Input,
  MetalMaterial,
  PlasticMaterial,
  Portal,
  PreviewHtml,
  PreviewParsedHtml,
  Root2 as Root,
  SuspendingImage,
  Svg,
  Text,
  Video,
  basedOnPreferredColorScheme,
  canvasInputProps,
  conversionPropertyTypes,
  getPreferredColorScheme,
  htmlToCode2 as htmlToCode,
  isDarkMode,
  parsedHtmlToCode,
  privateKeys,
  setPreferredColorScheme,
  useMeasureText,
  useRootSize,
  useVideoElement
};
/*! Bundled license information:

he/he.js:
  (*! https://mths.be/he v1.2.0 by @mathias | MIT license *)

tw-to-css/dist/index.mjs:
  (*! https://mths.be/cssesc v3.0.0 by @mathias *)
*/
//# sourceMappingURL=@react-three_uikit.js.map
