import {
  clamp
} from "./chunk-5R7AGACV.js";
import {
  create
} from "./chunk-5LN4NR6U.js";
import {
  require_jsx_runtime
} from "./chunk-XE53ZM2I.js";
import {
  context,
  createPortal,
  reconciler,
  useFrame,
  useLoader,
  useStore,
  useThree
} from "./chunk-ALODSIP4.js";
import {
  Box2,
  Box3,
  BufferAttribute,
  BufferGeometry,
  Color,
  DynamicDrawUsage,
  Euler,
  FileLoader,
  Float32BufferAttribute,
  FrontSide,
  Group,
  HalfFloatType,
  InstancedBufferAttribute,
  LinearFilter,
  Loader,
  Material,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshDistanceMaterial,
  MeshPhongMaterial,
  MeshPhysicalMaterial,
  Object3D,
  OrthographicCamera,
  Path,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  Quaternion,
  RGBADepthPacking,
  Raycaster,
  SRGBColorSpace,
  Scene,
  Shape,
  ShapeGeometry,
  ShapePath,
  ShapeUtils,
  Sphere,
  Texture,
  TextureLoader,
  Vector2,
  Vector3,
  VideoTexture,
  WebGLRenderTarget
} from "./chunk-SRMN6EMH.js";
import "./chunk-KBUAZBQ3.js";
import {
  require_react
} from "./chunk-ZLZLTJQL.js";
import {
  __commonJS,
  __esm,
  __export,
  __publicField,
  __toCommonJS,
  __toESM
} from "./chunk-2LSFTFF7.js";

// node_modules/he/he.js
var require_he = __commonJS({
  "node_modules/he/he.js"(exports, module) {
    (function(root) {
      var freeExports = typeof exports == "object" && exports;
      var freeModule = typeof module == "object" && module && module.exports == freeExports && module;
      var freeGlobal = typeof global == "object" && global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
        root = freeGlobal;
      }
      var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      var regexAsciiWhitelist = /[\x01-\x7F]/g;
      var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
      var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
      var encodeMap = { "­": "shy", "‌": "zwnj", "‍": "zwj", "‎": "lrm", "⁣": "ic", "⁢": "it", "⁡": "af", "‏": "rlm", "​": "ZeroWidthSpace", "⁠": "NoBreak", "̑": "DownBreve", "⃛": "tdot", "⃜": "DotDot", "	": "Tab", "\n": "NewLine", " ": "puncsp", " ": "MediumSpace", " ": "thinsp", " ": "hairsp", " ": "emsp13", " ": "ensp", " ": "emsp14", " ": "emsp", " ": "numsp", " ": "nbsp", "  ": "ThickSpace", "‾": "oline", "_": "lowbar", "‐": "dash", "–": "ndash", "—": "mdash", "―": "horbar", ",": "comma", ";": "semi", "⁏": "bsemi", ":": "colon", "⩴": "Colone", "!": "excl", "¡": "iexcl", "?": "quest", "¿": "iquest", ".": "period", "‥": "nldr", "…": "mldr", "·": "middot", "'": "apos", "‘": "lsquo", "’": "rsquo", "‚": "sbquo", "‹": "lsaquo", "›": "rsaquo", '"': "quot", "“": "ldquo", "”": "rdquo", "„": "bdquo", "«": "laquo", "»": "raquo", "(": "lpar", ")": "rpar", "[": "lsqb", "]": "rsqb", "{": "lcub", "}": "rcub", "⌈": "lceil", "⌉": "rceil", "⌊": "lfloor", "⌋": "rfloor", "⦅": "lopar", "⦆": "ropar", "⦋": "lbrke", "⦌": "rbrke", "⦍": "lbrkslu", "⦎": "rbrksld", "⦏": "lbrksld", "⦐": "rbrkslu", "⦑": "langd", "⦒": "rangd", "⦓": "lparlt", "⦔": "rpargt", "⦕": "gtlPar", "⦖": "ltrPar", "⟦": "lobrk", "⟧": "robrk", "⟨": "lang", "⟩": "rang", "⟪": "Lang", "⟫": "Rang", "⟬": "loang", "⟭": "roang", "❲": "lbbrk", "❳": "rbbrk", "‖": "Vert", "§": "sect", "¶": "para", "@": "commat", "*": "ast", "/": "sol", "undefined": null, "&": "amp", "#": "num", "%": "percnt", "‰": "permil", "‱": "pertenk", "†": "dagger", "‡": "Dagger", "•": "bull", "⁃": "hybull", "′": "prime", "″": "Prime", "‴": "tprime", "⁗": "qprime", "‵": "bprime", "⁁": "caret", "`": "grave", "´": "acute", "˜": "tilde", "^": "Hat", "¯": "macr", "˘": "breve", "˙": "dot", "¨": "die", "˚": "ring", "˝": "dblac", "¸": "cedil", "˛": "ogon", "ˆ": "circ", "ˇ": "caron", "°": "deg", "©": "copy", "®": "reg", "℗": "copysr", "℘": "wp", "℞": "rx", "℧": "mho", "℩": "iiota", "←": "larr", "↚": "nlarr", "→": "rarr", "↛": "nrarr", "↑": "uarr", "↓": "darr", "↔": "harr", "↮": "nharr", "↕": "varr", "↖": "nwarr", "↗": "nearr", "↘": "searr", "↙": "swarr", "↝": "rarrw", "↝̸": "nrarrw", "↞": "Larr", "↟": "Uarr", "↠": "Rarr", "↡": "Darr", "↢": "larrtl", "↣": "rarrtl", "↤": "mapstoleft", "↥": "mapstoup", "↦": "map", "↧": "mapstodown", "↩": "larrhk", "↪": "rarrhk", "↫": "larrlp", "↬": "rarrlp", "↭": "harrw", "↰": "lsh", "↱": "rsh", "↲": "ldsh", "↳": "rdsh", "↵": "crarr", "↶": "cularr", "↷": "curarr", "↺": "olarr", "↻": "orarr", "↼": "lharu", "↽": "lhard", "↾": "uharr", "↿": "uharl", "⇀": "rharu", "⇁": "rhard", "⇂": "dharr", "⇃": "dharl", "⇄": "rlarr", "⇅": "udarr", "⇆": "lrarr", "⇇": "llarr", "⇈": "uuarr", "⇉": "rrarr", "⇊": "ddarr", "⇋": "lrhar", "⇌": "rlhar", "⇐": "lArr", "⇍": "nlArr", "⇑": "uArr", "⇒": "rArr", "⇏": "nrArr", "⇓": "dArr", "⇔": "iff", "⇎": "nhArr", "⇕": "vArr", "⇖": "nwArr", "⇗": "neArr", "⇘": "seArr", "⇙": "swArr", "⇚": "lAarr", "⇛": "rAarr", "⇝": "zigrarr", "⇤": "larrb", "⇥": "rarrb", "⇵": "duarr", "⇽": "loarr", "⇾": "roarr", "⇿": "hoarr", "∀": "forall", "∁": "comp", "∂": "part", "∂̸": "npart", "∃": "exist", "∄": "nexist", "∅": "empty", "∇": "Del", "∈": "in", "∉": "notin", "∋": "ni", "∌": "notni", "϶": "bepsi", "∏": "prod", "∐": "coprod", "∑": "sum", "+": "plus", "±": "pm", "÷": "div", "×": "times", "<": "lt", "≮": "nlt", "<⃒": "nvlt", "=": "equals", "≠": "ne", "=⃥": "bne", "⩵": "Equal", ">": "gt", "≯": "ngt", ">⃒": "nvgt", "¬": "not", "|": "vert", "¦": "brvbar", "−": "minus", "∓": "mp", "∔": "plusdo", "⁄": "frasl", "∖": "setmn", "∗": "lowast", "∘": "compfn", "√": "Sqrt", "∝": "prop", "∞": "infin", "∟": "angrt", "∠": "ang", "∠⃒": "nang", "∡": "angmsd", "∢": "angsph", "∣": "mid", "∤": "nmid", "∥": "par", "∦": "npar", "∧": "and", "∨": "or", "∩": "cap", "∩︀": "caps", "∪": "cup", "∪︀": "cups", "∫": "int", "∬": "Int", "∭": "tint", "⨌": "qint", "∮": "oint", "∯": "Conint", "∰": "Cconint", "∱": "cwint", "∲": "cwconint", "∳": "awconint", "∴": "there4", "∵": "becaus", "∶": "ratio", "∷": "Colon", "∸": "minusd", "∺": "mDDot", "∻": "homtht", "∼": "sim", "≁": "nsim", "∼⃒": "nvsim", "∽": "bsim", "∽̱": "race", "∾": "ac", "∾̳": "acE", "∿": "acd", "≀": "wr", "≂": "esim", "≂̸": "nesim", "≃": "sime", "≄": "nsime", "≅": "cong", "≇": "ncong", "≆": "simne", "≈": "ap", "≉": "nap", "≊": "ape", "≋": "apid", "≋̸": "napid", "≌": "bcong", "≍": "CupCap", "≭": "NotCupCap", "≍⃒": "nvap", "≎": "bump", "≎̸": "nbump", "≏": "bumpe", "≏̸": "nbumpe", "≐": "doteq", "≐̸": "nedot", "≑": "eDot", "≒": "efDot", "≓": "erDot", "≔": "colone", "≕": "ecolon", "≖": "ecir", "≗": "cire", "≙": "wedgeq", "≚": "veeeq", "≜": "trie", "≟": "equest", "≡": "equiv", "≢": "nequiv", "≡⃥": "bnequiv", "≤": "le", "≰": "nle", "≤⃒": "nvle", "≥": "ge", "≱": "nge", "≥⃒": "nvge", "≦": "lE", "≦̸": "nlE", "≧": "gE", "≧̸": "ngE", "≨︀": "lvnE", "≨": "lnE", "≩": "gnE", "≩︀": "gvnE", "≪": "ll", "≪̸": "nLtv", "≪⃒": "nLt", "≫": "gg", "≫̸": "nGtv", "≫⃒": "nGt", "≬": "twixt", "≲": "lsim", "≴": "nlsim", "≳": "gsim", "≵": "ngsim", "≶": "lg", "≸": "ntlg", "≷": "gl", "≹": "ntgl", "≺": "pr", "⊀": "npr", "≻": "sc", "⊁": "nsc", "≼": "prcue", "⋠": "nprcue", "≽": "sccue", "⋡": "nsccue", "≾": "prsim", "≿": "scsim", "≿̸": "NotSucceedsTilde", "⊂": "sub", "⊄": "nsub", "⊂⃒": "vnsub", "⊃": "sup", "⊅": "nsup", "⊃⃒": "vnsup", "⊆": "sube", "⊈": "nsube", "⊇": "supe", "⊉": "nsupe", "⊊︀": "vsubne", "⊊": "subne", "⊋︀": "vsupne", "⊋": "supne", "⊍": "cupdot", "⊎": "uplus", "⊏": "sqsub", "⊏̸": "NotSquareSubset", "⊐": "sqsup", "⊐̸": "NotSquareSuperset", "⊑": "sqsube", "⋢": "nsqsube", "⊒": "sqsupe", "⋣": "nsqsupe", "⊓": "sqcap", "⊓︀": "sqcaps", "⊔": "sqcup", "⊔︀": "sqcups", "⊕": "oplus", "⊖": "ominus", "⊗": "otimes", "⊘": "osol", "⊙": "odot", "⊚": "ocir", "⊛": "oast", "⊝": "odash", "⊞": "plusb", "⊟": "minusb", "⊠": "timesb", "⊡": "sdotb", "⊢": "vdash", "⊬": "nvdash", "⊣": "dashv", "⊤": "top", "⊥": "bot", "⊧": "models", "⊨": "vDash", "⊭": "nvDash", "⊩": "Vdash", "⊮": "nVdash", "⊪": "Vvdash", "⊫": "VDash", "⊯": "nVDash", "⊰": "prurel", "⊲": "vltri", "⋪": "nltri", "⊳": "vrtri", "⋫": "nrtri", "⊴": "ltrie", "⋬": "nltrie", "⊴⃒": "nvltrie", "⊵": "rtrie", "⋭": "nrtrie", "⊵⃒": "nvrtrie", "⊶": "origof", "⊷": "imof", "⊸": "mumap", "⊹": "hercon", "⊺": "intcal", "⊻": "veebar", "⊽": "barvee", "⊾": "angrtvb", "⊿": "lrtri", "⋀": "Wedge", "⋁": "Vee", "⋂": "xcap", "⋃": "xcup", "⋄": "diam", "⋅": "sdot", "⋆": "Star", "⋇": "divonx", "⋈": "bowtie", "⋉": "ltimes", "⋊": "rtimes", "⋋": "lthree", "⋌": "rthree", "⋍": "bsime", "⋎": "cuvee", "⋏": "cuwed", "⋐": "Sub", "⋑": "Sup", "⋒": "Cap", "⋓": "Cup", "⋔": "fork", "⋕": "epar", "⋖": "ltdot", "⋗": "gtdot", "⋘": "Ll", "⋘̸": "nLl", "⋙": "Gg", "⋙̸": "nGg", "⋚︀": "lesg", "⋚": "leg", "⋛": "gel", "⋛︀": "gesl", "⋞": "cuepr", "⋟": "cuesc", "⋦": "lnsim", "⋧": "gnsim", "⋨": "prnsim", "⋩": "scnsim", "⋮": "vellip", "⋯": "ctdot", "⋰": "utdot", "⋱": "dtdot", "⋲": "disin", "⋳": "isinsv", "⋴": "isins", "⋵": "isindot", "⋵̸": "notindot", "⋶": "notinvc", "⋷": "notinvb", "⋹": "isinE", "⋹̸": "notinE", "⋺": "nisd", "⋻": "xnis", "⋼": "nis", "⋽": "notnivc", "⋾": "notnivb", "⌅": "barwed", "⌆": "Barwed", "⌌": "drcrop", "⌍": "dlcrop", "⌎": "urcrop", "⌏": "ulcrop", "⌐": "bnot", "⌒": "profline", "⌓": "profsurf", "⌕": "telrec", "⌖": "target", "⌜": "ulcorn", "⌝": "urcorn", "⌞": "dlcorn", "⌟": "drcorn", "⌢": "frown", "⌣": "smile", "⌭": "cylcty", "⌮": "profalar", "⌶": "topbot", "⌽": "ovbar", "⌿": "solbar", "⍼": "angzarr", "⎰": "lmoust", "⎱": "rmoust", "⎴": "tbrk", "⎵": "bbrk", "⎶": "bbrktbrk", "⏜": "OverParenthesis", "⏝": "UnderParenthesis", "⏞": "OverBrace", "⏟": "UnderBrace", "⏢": "trpezium", "⏧": "elinters", "␣": "blank", "─": "boxh", "│": "boxv", "┌": "boxdr", "┐": "boxdl", "└": "boxur", "┘": "boxul", "├": "boxvr", "┤": "boxvl", "┬": "boxhd", "┴": "boxhu", "┼": "boxvh", "═": "boxH", "║": "boxV", "╒": "boxdR", "╓": "boxDr", "╔": "boxDR", "╕": "boxdL", "╖": "boxDl", "╗": "boxDL", "╘": "boxuR", "╙": "boxUr", "╚": "boxUR", "╛": "boxuL", "╜": "boxUl", "╝": "boxUL", "╞": "boxvR", "╟": "boxVr", "╠": "boxVR", "╡": "boxvL", "╢": "boxVl", "╣": "boxVL", "╤": "boxHd", "╥": "boxhD", "╦": "boxHD", "╧": "boxHu", "╨": "boxhU", "╩": "boxHU", "╪": "boxvH", "╫": "boxVh", "╬": "boxVH", "▀": "uhblk", "▄": "lhblk", "█": "block", "░": "blk14", "▒": "blk12", "▓": "blk34", "□": "squ", "▪": "squf", "▫": "EmptyVerySmallSquare", "▭": "rect", "▮": "marker", "▱": "fltns", "△": "xutri", "▴": "utrif", "▵": "utri", "▸": "rtrif", "▹": "rtri", "▽": "xdtri", "▾": "dtrif", "▿": "dtri", "◂": "ltrif", "◃": "ltri", "◊": "loz", "○": "cir", "◬": "tridot", "◯": "xcirc", "◸": "ultri", "◹": "urtri", "◺": "lltri", "◻": "EmptySmallSquare", "◼": "FilledSmallSquare", "★": "starf", "☆": "star", "☎": "phone", "♀": "female", "♂": "male", "♠": "spades", "♣": "clubs", "♥": "hearts", "♦": "diams", "♪": "sung", "✓": "check", "✗": "cross", "✠": "malt", "✶": "sext", "❘": "VerticalSeparator", "⟈": "bsolhsub", "⟉": "suphsol", "⟵": "xlarr", "⟶": "xrarr", "⟷": "xharr", "⟸": "xlArr", "⟹": "xrArr", "⟺": "xhArr", "⟼": "xmap", "⟿": "dzigrarr", "⤂": "nvlArr", "⤃": "nvrArr", "⤄": "nvHarr", "⤅": "Map", "⤌": "lbarr", "⤍": "rbarr", "⤎": "lBarr", "⤏": "rBarr", "⤐": "RBarr", "⤑": "DDotrahd", "⤒": "UpArrowBar", "⤓": "DownArrowBar", "⤖": "Rarrtl", "⤙": "latail", "⤚": "ratail", "⤛": "lAtail", "⤜": "rAtail", "⤝": "larrfs", "⤞": "rarrfs", "⤟": "larrbfs", "⤠": "rarrbfs", "⤣": "nwarhk", "⤤": "nearhk", "⤥": "searhk", "⤦": "swarhk", "⤧": "nwnear", "⤨": "toea", "⤩": "tosa", "⤪": "swnwar", "⤳": "rarrc", "⤳̸": "nrarrc", "⤵": "cudarrr", "⤶": "ldca", "⤷": "rdca", "⤸": "cudarrl", "⤹": "larrpl", "⤼": "curarrm", "⤽": "cularrp", "⥅": "rarrpl", "⥈": "harrcir", "⥉": "Uarrocir", "⥊": "lurdshar", "⥋": "ldrushar", "⥎": "LeftRightVector", "⥏": "RightUpDownVector", "⥐": "DownLeftRightVector", "⥑": "LeftUpDownVector", "⥒": "LeftVectorBar", "⥓": "RightVectorBar", "⥔": "RightUpVectorBar", "⥕": "RightDownVectorBar", "⥖": "DownLeftVectorBar", "⥗": "DownRightVectorBar", "⥘": "LeftUpVectorBar", "⥙": "LeftDownVectorBar", "⥚": "LeftTeeVector", "⥛": "RightTeeVector", "⥜": "RightUpTeeVector", "⥝": "RightDownTeeVector", "⥞": "DownLeftTeeVector", "⥟": "DownRightTeeVector", "⥠": "LeftUpTeeVector", "⥡": "LeftDownTeeVector", "⥢": "lHar", "⥣": "uHar", "⥤": "rHar", "⥥": "dHar", "⥦": "luruhar", "⥧": "ldrdhar", "⥨": "ruluhar", "⥩": "rdldhar", "⥪": "lharul", "⥫": "llhard", "⥬": "rharul", "⥭": "lrhard", "⥮": "udhar", "⥯": "duhar", "⥰": "RoundImplies", "⥱": "erarr", "⥲": "simrarr", "⥳": "larrsim", "⥴": "rarrsim", "⥵": "rarrap", "⥶": "ltlarr", "⥸": "gtrarr", "⥹": "subrarr", "⥻": "suplarr", "⥼": "lfisht", "⥽": "rfisht", "⥾": "ufisht", "⥿": "dfisht", "⦚": "vzigzag", "⦜": "vangrt", "⦝": "angrtvbd", "⦤": "ange", "⦥": "range", "⦦": "dwangle", "⦧": "uwangle", "⦨": "angmsdaa", "⦩": "angmsdab", "⦪": "angmsdac", "⦫": "angmsdad", "⦬": "angmsdae", "⦭": "angmsdaf", "⦮": "angmsdag", "⦯": "angmsdah", "⦰": "bemptyv", "⦱": "demptyv", "⦲": "cemptyv", "⦳": "raemptyv", "⦴": "laemptyv", "⦵": "ohbar", "⦶": "omid", "⦷": "opar", "⦹": "operp", "⦻": "olcross", "⦼": "odsold", "⦾": "olcir", "⦿": "ofcir", "⧀": "olt", "⧁": "ogt", "⧂": "cirscir", "⧃": "cirE", "⧄": "solb", "⧅": "bsolb", "⧉": "boxbox", "⧍": "trisb", "⧎": "rtriltri", "⧏": "LeftTriangleBar", "⧏̸": "NotLeftTriangleBar", "⧐": "RightTriangleBar", "⧐̸": "NotRightTriangleBar", "⧜": "iinfin", "⧝": "infintie", "⧞": "nvinfin", "⧣": "eparsl", "⧤": "smeparsl", "⧥": "eqvparsl", "⧫": "lozf", "⧴": "RuleDelayed", "⧶": "dsol", "⨀": "xodot", "⨁": "xoplus", "⨂": "xotime", "⨄": "xuplus", "⨆": "xsqcup", "⨍": "fpartint", "⨐": "cirfnint", "⨑": "awint", "⨒": "rppolint", "⨓": "scpolint", "⨔": "npolint", "⨕": "pointint", "⨖": "quatint", "⨗": "intlarhk", "⨢": "pluscir", "⨣": "plusacir", "⨤": "simplus", "⨥": "plusdu", "⨦": "plussim", "⨧": "plustwo", "⨩": "mcomma", "⨪": "minusdu", "⨭": "loplus", "⨮": "roplus", "⨯": "Cross", "⨰": "timesd", "⨱": "timesbar", "⨳": "smashp", "⨴": "lotimes", "⨵": "rotimes", "⨶": "otimesas", "⨷": "Otimes", "⨸": "odiv", "⨹": "triplus", "⨺": "triminus", "⨻": "tritime", "⨼": "iprod", "⨿": "amalg", "⩀": "capdot", "⩂": "ncup", "⩃": "ncap", "⩄": "capand", "⩅": "cupor", "⩆": "cupcap", "⩇": "capcup", "⩈": "cupbrcap", "⩉": "capbrcup", "⩊": "cupcup", "⩋": "capcap", "⩌": "ccups", "⩍": "ccaps", "⩐": "ccupssm", "⩓": "And", "⩔": "Or", "⩕": "andand", "⩖": "oror", "⩗": "orslope", "⩘": "andslope", "⩚": "andv", "⩛": "orv", "⩜": "andd", "⩝": "ord", "⩟": "wedbar", "⩦": "sdote", "⩪": "simdot", "⩭": "congdot", "⩭̸": "ncongdot", "⩮": "easter", "⩯": "apacir", "⩰": "apE", "⩰̸": "napE", "⩱": "eplus", "⩲": "pluse", "⩳": "Esim", "⩷": "eDDot", "⩸": "equivDD", "⩹": "ltcir", "⩺": "gtcir", "⩻": "ltquest", "⩼": "gtquest", "⩽": "les", "⩽̸": "nles", "⩾": "ges", "⩾̸": "nges", "⩿": "lesdot", "⪀": "gesdot", "⪁": "lesdoto", "⪂": "gesdoto", "⪃": "lesdotor", "⪄": "gesdotol", "⪅": "lap", "⪆": "gap", "⪇": "lne", "⪈": "gne", "⪉": "lnap", "⪊": "gnap", "⪋": "lEg", "⪌": "gEl", "⪍": "lsime", "⪎": "gsime", "⪏": "lsimg", "⪐": "gsiml", "⪑": "lgE", "⪒": "glE", "⪓": "lesges", "⪔": "gesles", "⪕": "els", "⪖": "egs", "⪗": "elsdot", "⪘": "egsdot", "⪙": "el", "⪚": "eg", "⪝": "siml", "⪞": "simg", "⪟": "simlE", "⪠": "simgE", "⪡": "LessLess", "⪡̸": "NotNestedLessLess", "⪢": "GreaterGreater", "⪢̸": "NotNestedGreaterGreater", "⪤": "glj", "⪥": "gla", "⪦": "ltcc", "⪧": "gtcc", "⪨": "lescc", "⪩": "gescc", "⪪": "smt", "⪫": "lat", "⪬": "smte", "⪬︀": "smtes", "⪭": "late", "⪭︀": "lates", "⪮": "bumpE", "⪯": "pre", "⪯̸": "npre", "⪰": "sce", "⪰̸": "nsce", "⪳": "prE", "⪴": "scE", "⪵": "prnE", "⪶": "scnE", "⪷": "prap", "⪸": "scap", "⪹": "prnap", "⪺": "scnap", "⪻": "Pr", "⪼": "Sc", "⪽": "subdot", "⪾": "supdot", "⪿": "subplus", "⫀": "supplus", "⫁": "submult", "⫂": "supmult", "⫃": "subedot", "⫄": "supedot", "⫅": "subE", "⫅̸": "nsubE", "⫆": "supE", "⫆̸": "nsupE", "⫇": "subsim", "⫈": "supsim", "⫋︀": "vsubnE", "⫋": "subnE", "⫌︀": "vsupnE", "⫌": "supnE", "⫏": "csub", "⫐": "csup", "⫑": "csube", "⫒": "csupe", "⫓": "subsup", "⫔": "supsub", "⫕": "subsub", "⫖": "supsup", "⫗": "suphsub", "⫘": "supdsub", "⫙": "forkv", "⫚": "topfork", "⫛": "mlcp", "⫤": "Dashv", "⫦": "Vdashl", "⫧": "Barv", "⫨": "vBar", "⫩": "vBarv", "⫫": "Vbar", "⫬": "Not", "⫭": "bNot", "⫮": "rnmid", "⫯": "cirmid", "⫰": "midcir", "⫱": "topcir", "⫲": "nhpar", "⫳": "parsim", "⫽": "parsl", "⫽⃥": "nparsl", "♭": "flat", "♮": "natur", "♯": "sharp", "¤": "curren", "¢": "cent", "$": "dollar", "£": "pound", "¥": "yen", "€": "euro", "¹": "sup1", "½": "half", "⅓": "frac13", "¼": "frac14", "⅕": "frac15", "⅙": "frac16", "⅛": "frac18", "²": "sup2", "⅔": "frac23", "⅖": "frac25", "³": "sup3", "¾": "frac34", "⅗": "frac35", "⅜": "frac38", "⅘": "frac45", "⅚": "frac56", "⅝": "frac58", "⅞": "frac78", "𝒶": "ascr", "𝕒": "aopf", "𝔞": "afr", "𝔸": "Aopf", "𝔄": "Afr", "𝒜": "Ascr", "ª": "ordf", "á": "aacute", "Á": "Aacute", "à": "agrave", "À": "Agrave", "ă": "abreve", "Ă": "Abreve", "â": "acirc", "Â": "Acirc", "å": "aring", "Å": "angst", "ä": "auml", "Ä": "Auml", "ã": "atilde", "Ã": "Atilde", "ą": "aogon", "Ą": "Aogon", "ā": "amacr", "Ā": "Amacr", "æ": "aelig", "Æ": "AElig", "𝒷": "bscr", "𝕓": "bopf", "𝔟": "bfr", "𝔹": "Bopf", "ℬ": "Bscr", "𝔅": "Bfr", "𝔠": "cfr", "𝒸": "cscr", "𝕔": "copf", "ℭ": "Cfr", "𝒞": "Cscr", "ℂ": "Copf", "ć": "cacute", "Ć": "Cacute", "ĉ": "ccirc", "Ĉ": "Ccirc", "č": "ccaron", "Č": "Ccaron", "ċ": "cdot", "Ċ": "Cdot", "ç": "ccedil", "Ç": "Ccedil", "℅": "incare", "𝔡": "dfr", "ⅆ": "dd", "𝕕": "dopf", "𝒹": "dscr", "𝒟": "Dscr", "𝔇": "Dfr", "ⅅ": "DD", "𝔻": "Dopf", "ď": "dcaron", "Ď": "Dcaron", "đ": "dstrok", "Đ": "Dstrok", "ð": "eth", "Ð": "ETH", "ⅇ": "ee", "ℯ": "escr", "𝔢": "efr", "𝕖": "eopf", "ℰ": "Escr", "𝔈": "Efr", "𝔼": "Eopf", "é": "eacute", "É": "Eacute", "è": "egrave", "È": "Egrave", "ê": "ecirc", "Ê": "Ecirc", "ě": "ecaron", "Ě": "Ecaron", "ë": "euml", "Ë": "Euml", "ė": "edot", "Ė": "Edot", "ę": "eogon", "Ę": "Eogon", "ē": "emacr", "Ē": "Emacr", "𝔣": "ffr", "𝕗": "fopf", "𝒻": "fscr", "𝔉": "Ffr", "𝔽": "Fopf", "ℱ": "Fscr", "ﬀ": "fflig", "ﬃ": "ffilig", "ﬄ": "ffllig", "ﬁ": "filig", "fj": "fjlig", "ﬂ": "fllig", "ƒ": "fnof", "ℊ": "gscr", "𝕘": "gopf", "𝔤": "gfr", "𝒢": "Gscr", "𝔾": "Gopf", "𝔊": "Gfr", "ǵ": "gacute", "ğ": "gbreve", "Ğ": "Gbreve", "ĝ": "gcirc", "Ĝ": "Gcirc", "ġ": "gdot", "Ġ": "Gdot", "Ģ": "Gcedil", "𝔥": "hfr", "ℎ": "planckh", "𝒽": "hscr", "𝕙": "hopf", "ℋ": "Hscr", "ℌ": "Hfr", "ℍ": "Hopf", "ĥ": "hcirc", "Ĥ": "Hcirc", "ℏ": "hbar", "ħ": "hstrok", "Ħ": "Hstrok", "𝕚": "iopf", "𝔦": "ifr", "𝒾": "iscr", "ⅈ": "ii", "𝕀": "Iopf", "ℐ": "Iscr", "ℑ": "Im", "í": "iacute", "Í": "Iacute", "ì": "igrave", "Ì": "Igrave", "î": "icirc", "Î": "Icirc", "ï": "iuml", "Ï": "Iuml", "ĩ": "itilde", "Ĩ": "Itilde", "İ": "Idot", "į": "iogon", "Į": "Iogon", "ī": "imacr", "Ī": "Imacr", "ĳ": "ijlig", "Ĳ": "IJlig", "ı": "imath", "𝒿": "jscr", "𝕛": "jopf", "𝔧": "jfr", "𝒥": "Jscr", "𝔍": "Jfr", "𝕁": "Jopf", "ĵ": "jcirc", "Ĵ": "Jcirc", "ȷ": "jmath", "𝕜": "kopf", "𝓀": "kscr", "𝔨": "kfr", "𝒦": "Kscr", "𝕂": "Kopf", "𝔎": "Kfr", "ķ": "kcedil", "Ķ": "Kcedil", "𝔩": "lfr", "𝓁": "lscr", "ℓ": "ell", "𝕝": "lopf", "ℒ": "Lscr", "𝔏": "Lfr", "𝕃": "Lopf", "ĺ": "lacute", "Ĺ": "Lacute", "ľ": "lcaron", "Ľ": "Lcaron", "ļ": "lcedil", "Ļ": "Lcedil", "ł": "lstrok", "Ł": "Lstrok", "ŀ": "lmidot", "Ŀ": "Lmidot", "𝔪": "mfr", "𝕞": "mopf", "𝓂": "mscr", "𝔐": "Mfr", "𝕄": "Mopf", "ℳ": "Mscr", "𝔫": "nfr", "𝕟": "nopf", "𝓃": "nscr", "ℕ": "Nopf", "𝒩": "Nscr", "𝔑": "Nfr", "ń": "nacute", "Ń": "Nacute", "ň": "ncaron", "Ň": "Ncaron", "ñ": "ntilde", "Ñ": "Ntilde", "ņ": "ncedil", "Ņ": "Ncedil", "№": "numero", "ŋ": "eng", "Ŋ": "ENG", "𝕠": "oopf", "𝔬": "ofr", "ℴ": "oscr", "𝒪": "Oscr", "𝔒": "Ofr", "𝕆": "Oopf", "º": "ordm", "ó": "oacute", "Ó": "Oacute", "ò": "ograve", "Ò": "Ograve", "ô": "ocirc", "Ô": "Ocirc", "ö": "ouml", "Ö": "Ouml", "ő": "odblac", "Ő": "Odblac", "õ": "otilde", "Õ": "Otilde", "ø": "oslash", "Ø": "Oslash", "ō": "omacr", "Ō": "Omacr", "œ": "oelig", "Œ": "OElig", "𝔭": "pfr", "𝓅": "pscr", "𝕡": "popf", "ℙ": "Popf", "𝔓": "Pfr", "𝒫": "Pscr", "𝕢": "qopf", "𝔮": "qfr", "𝓆": "qscr", "𝒬": "Qscr", "𝔔": "Qfr", "ℚ": "Qopf", "ĸ": "kgreen", "𝔯": "rfr", "𝕣": "ropf", "𝓇": "rscr", "ℛ": "Rscr", "ℜ": "Re", "ℝ": "Ropf", "ŕ": "racute", "Ŕ": "Racute", "ř": "rcaron", "Ř": "Rcaron", "ŗ": "rcedil", "Ŗ": "Rcedil", "𝕤": "sopf", "𝓈": "sscr", "𝔰": "sfr", "𝕊": "Sopf", "𝔖": "Sfr", "𝒮": "Sscr", "Ⓢ": "oS", "ś": "sacute", "Ś": "Sacute", "ŝ": "scirc", "Ŝ": "Scirc", "š": "scaron", "Š": "Scaron", "ş": "scedil", "Ş": "Scedil", "ß": "szlig", "𝔱": "tfr", "𝓉": "tscr", "𝕥": "topf", "𝒯": "Tscr", "𝔗": "Tfr", "𝕋": "Topf", "ť": "tcaron", "Ť": "Tcaron", "ţ": "tcedil", "Ţ": "Tcedil", "™": "trade", "ŧ": "tstrok", "Ŧ": "Tstrok", "𝓊": "uscr", "𝕦": "uopf", "𝔲": "ufr", "𝕌": "Uopf", "𝔘": "Ufr", "𝒰": "Uscr", "ú": "uacute", "Ú": "Uacute", "ù": "ugrave", "Ù": "Ugrave", "ŭ": "ubreve", "Ŭ": "Ubreve", "û": "ucirc", "Û": "Ucirc", "ů": "uring", "Ů": "Uring", "ü": "uuml", "Ü": "Uuml", "ű": "udblac", "Ű": "Udblac", "ũ": "utilde", "Ũ": "Utilde", "ų": "uogon", "Ų": "Uogon", "ū": "umacr", "Ū": "Umacr", "𝔳": "vfr", "𝕧": "vopf", "𝓋": "vscr", "𝔙": "Vfr", "𝕍": "Vopf", "𝒱": "Vscr", "𝕨": "wopf", "𝓌": "wscr", "𝔴": "wfr", "𝒲": "Wscr", "𝕎": "Wopf", "𝔚": "Wfr", "ŵ": "wcirc", "Ŵ": "Wcirc", "𝔵": "xfr", "𝓍": "xscr", "𝕩": "xopf", "𝕏": "Xopf", "𝔛": "Xfr", "𝒳": "Xscr", "𝔶": "yfr", "𝓎": "yscr", "𝕪": "yopf", "𝒴": "Yscr", "𝔜": "Yfr", "𝕐": "Yopf", "ý": "yacute", "Ý": "Yacute", "ŷ": "ycirc", "Ŷ": "Ycirc", "ÿ": "yuml", "Ÿ": "Yuml", "𝓏": "zscr", "𝔷": "zfr", "𝕫": "zopf", "ℨ": "Zfr", "ℤ": "Zopf", "𝒵": "Zscr", "ź": "zacute", "Ź": "Zacute", "ž": "zcaron", "Ž": "Zcaron", "ż": "zdot", "Ż": "Zdot", "Ƶ": "imped", "þ": "thorn", "Þ": "THORN", "ŉ": "napos", "α": "alpha", "Α": "Alpha", "β": "beta", "Β": "Beta", "γ": "gamma", "Γ": "Gamma", "δ": "delta", "Δ": "Delta", "ε": "epsi", "ϵ": "epsiv", "Ε": "Epsilon", "ϝ": "gammad", "Ϝ": "Gammad", "ζ": "zeta", "Ζ": "Zeta", "η": "eta", "Η": "Eta", "θ": "theta", "ϑ": "thetav", "Θ": "Theta", "ι": "iota", "Ι": "Iota", "κ": "kappa", "ϰ": "kappav", "Κ": "Kappa", "λ": "lambda", "Λ": "Lambda", "μ": "mu", "µ": "micro", "Μ": "Mu", "ν": "nu", "Ν": "Nu", "ξ": "xi", "Ξ": "Xi", "ο": "omicron", "Ο": "Omicron", "π": "pi", "ϖ": "piv", "Π": "Pi", "ρ": "rho", "ϱ": "rhov", "Ρ": "Rho", "σ": "sigma", "Σ": "Sigma", "ς": "sigmaf", "τ": "tau", "Τ": "Tau", "υ": "upsi", "Υ": "Upsilon", "ϒ": "Upsi", "φ": "phi", "ϕ": "phiv", "Φ": "Phi", "χ": "chi", "Χ": "Chi", "ψ": "psi", "Ψ": "Psi", "ω": "omega", "Ω": "ohm", "а": "acy", "А": "Acy", "б": "bcy", "Б": "Bcy", "в": "vcy", "В": "Vcy", "г": "gcy", "Г": "Gcy", "ѓ": "gjcy", "Ѓ": "GJcy", "д": "dcy", "Д": "Dcy", "ђ": "djcy", "Ђ": "DJcy", "е": "iecy", "Е": "IEcy", "ё": "iocy", "Ё": "IOcy", "є": "jukcy", "Є": "Jukcy", "ж": "zhcy", "Ж": "ZHcy", "з": "zcy", "З": "Zcy", "ѕ": "dscy", "Ѕ": "DScy", "и": "icy", "И": "Icy", "і": "iukcy", "І": "Iukcy", "ї": "yicy", "Ї": "YIcy", "й": "jcy", "Й": "Jcy", "ј": "jsercy", "Ј": "Jsercy", "к": "kcy", "К": "Kcy", "ќ": "kjcy", "Ќ": "KJcy", "л": "lcy", "Л": "Lcy", "љ": "ljcy", "Љ": "LJcy", "м": "mcy", "М": "Mcy", "н": "ncy", "Н": "Ncy", "њ": "njcy", "Њ": "NJcy", "о": "ocy", "О": "Ocy", "п": "pcy", "П": "Pcy", "р": "rcy", "Р": "Rcy", "с": "scy", "С": "Scy", "т": "tcy", "Т": "Tcy", "ћ": "tshcy", "Ћ": "TSHcy", "у": "ucy", "У": "Ucy", "ў": "ubrcy", "Ў": "Ubrcy", "ф": "fcy", "Ф": "Fcy", "х": "khcy", "Х": "KHcy", "ц": "tscy", "Ц": "TScy", "ч": "chcy", "Ч": "CHcy", "џ": "dzcy", "Џ": "DZcy", "ш": "shcy", "Ш": "SHcy", "щ": "shchcy", "Щ": "SHCHcy", "ъ": "hardcy", "Ъ": "HARDcy", "ы": "ycy", "Ы": "Ycy", "ь": "softcy", "Ь": "SOFTcy", "э": "ecy", "Э": "Ecy", "ю": "yucy", "Ю": "YUcy", "я": "yacy", "Я": "YAcy", "ℵ": "aleph", "ℶ": "beth", "ℷ": "gimel", "ℸ": "daleth" };
      var regexEscape = /["&'<>`]/g;
      var escapeMap = {
        '"': "&quot;",
        "&": "&amp;",
        "'": "&#x27;",
        "<": "&lt;",
        // See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
        // following is not strictly necessary unless it’s part of a tag or an
        // unquoted attribute value. We’re only escaping it to support those
        // situations, and for XML support.
        ">": "&gt;",
        // In Internet Explorer ≤ 8, the backtick character can be used
        // to break out of (un)quoted attribute values or HTML comments.
        // See http://html5sec.org/#102, http://html5sec.org/#108, and
        // http://html5sec.org/#133.
        "`": "&#x60;"
      };
      var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
      var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
      var regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
      var decodeMap = { "aacute": "á", "Aacute": "Á", "abreve": "ă", "Abreve": "Ă", "ac": "∾", "acd": "∿", "acE": "∾̳", "acirc": "â", "Acirc": "Â", "acute": "´", "acy": "а", "Acy": "А", "aelig": "æ", "AElig": "Æ", "af": "⁡", "afr": "𝔞", "Afr": "𝔄", "agrave": "à", "Agrave": "À", "alefsym": "ℵ", "aleph": "ℵ", "alpha": "α", "Alpha": "Α", "amacr": "ā", "Amacr": "Ā", "amalg": "⨿", "amp": "&", "AMP": "&", "and": "∧", "And": "⩓", "andand": "⩕", "andd": "⩜", "andslope": "⩘", "andv": "⩚", "ang": "∠", "ange": "⦤", "angle": "∠", "angmsd": "∡", "angmsdaa": "⦨", "angmsdab": "⦩", "angmsdac": "⦪", "angmsdad": "⦫", "angmsdae": "⦬", "angmsdaf": "⦭", "angmsdag": "⦮", "angmsdah": "⦯", "angrt": "∟", "angrtvb": "⊾", "angrtvbd": "⦝", "angsph": "∢", "angst": "Å", "angzarr": "⍼", "aogon": "ą", "Aogon": "Ą", "aopf": "𝕒", "Aopf": "𝔸", "ap": "≈", "apacir": "⩯", "ape": "≊", "apE": "⩰", "apid": "≋", "apos": "'", "ApplyFunction": "⁡", "approx": "≈", "approxeq": "≊", "aring": "å", "Aring": "Å", "ascr": "𝒶", "Ascr": "𝒜", "Assign": "≔", "ast": "*", "asymp": "≈", "asympeq": "≍", "atilde": "ã", "Atilde": "Ã", "auml": "ä", "Auml": "Ä", "awconint": "∳", "awint": "⨑", "backcong": "≌", "backepsilon": "϶", "backprime": "‵", "backsim": "∽", "backsimeq": "⋍", "Backslash": "∖", "Barv": "⫧", "barvee": "⊽", "barwed": "⌅", "Barwed": "⌆", "barwedge": "⌅", "bbrk": "⎵", "bbrktbrk": "⎶", "bcong": "≌", "bcy": "б", "Bcy": "Б", "bdquo": "„", "becaus": "∵", "because": "∵", "Because": "∵", "bemptyv": "⦰", "bepsi": "϶", "bernou": "ℬ", "Bernoullis": "ℬ", "beta": "β", "Beta": "Β", "beth": "ℶ", "between": "≬", "bfr": "𝔟", "Bfr": "𝔅", "bigcap": "⋂", "bigcirc": "◯", "bigcup": "⋃", "bigodot": "⨀", "bigoplus": "⨁", "bigotimes": "⨂", "bigsqcup": "⨆", "bigstar": "★", "bigtriangledown": "▽", "bigtriangleup": "△", "biguplus": "⨄", "bigvee": "⋁", "bigwedge": "⋀", "bkarow": "⤍", "blacklozenge": "⧫", "blacksquare": "▪", "blacktriangle": "▴", "blacktriangledown": "▾", "blacktriangleleft": "◂", "blacktriangleright": "▸", "blank": "␣", "blk12": "▒", "blk14": "░", "blk34": "▓", "block": "█", "bne": "=⃥", "bnequiv": "≡⃥", "bnot": "⌐", "bNot": "⫭", "bopf": "𝕓", "Bopf": "𝔹", "bot": "⊥", "bottom": "⊥", "bowtie": "⋈", "boxbox": "⧉", "boxdl": "┐", "boxdL": "╕", "boxDl": "╖", "boxDL": "╗", "boxdr": "┌", "boxdR": "╒", "boxDr": "╓", "boxDR": "╔", "boxh": "─", "boxH": "═", "boxhd": "┬", "boxhD": "╥", "boxHd": "╤", "boxHD": "╦", "boxhu": "┴", "boxhU": "╨", "boxHu": "╧", "boxHU": "╩", "boxminus": "⊟", "boxplus": "⊞", "boxtimes": "⊠", "boxul": "┘", "boxuL": "╛", "boxUl": "╜", "boxUL": "╝", "boxur": "└", "boxuR": "╘", "boxUr": "╙", "boxUR": "╚", "boxv": "│", "boxV": "║", "boxvh": "┼", "boxvH": "╪", "boxVh": "╫", "boxVH": "╬", "boxvl": "┤", "boxvL": "╡", "boxVl": "╢", "boxVL": "╣", "boxvr": "├", "boxvR": "╞", "boxVr": "╟", "boxVR": "╠", "bprime": "‵", "breve": "˘", "Breve": "˘", "brvbar": "¦", "bscr": "𝒷", "Bscr": "ℬ", "bsemi": "⁏", "bsim": "∽", "bsime": "⋍", "bsol": "\\", "bsolb": "⧅", "bsolhsub": "⟈", "bull": "•", "bullet": "•", "bump": "≎", "bumpe": "≏", "bumpE": "⪮", "bumpeq": "≏", "Bumpeq": "≎", "cacute": "ć", "Cacute": "Ć", "cap": "∩", "Cap": "⋒", "capand": "⩄", "capbrcup": "⩉", "capcap": "⩋", "capcup": "⩇", "capdot": "⩀", "CapitalDifferentialD": "ⅅ", "caps": "∩︀", "caret": "⁁", "caron": "ˇ", "Cayleys": "ℭ", "ccaps": "⩍", "ccaron": "č", "Ccaron": "Č", "ccedil": "ç", "Ccedil": "Ç", "ccirc": "ĉ", "Ccirc": "Ĉ", "Cconint": "∰", "ccups": "⩌", "ccupssm": "⩐", "cdot": "ċ", "Cdot": "Ċ", "cedil": "¸", "Cedilla": "¸", "cemptyv": "⦲", "cent": "¢", "centerdot": "·", "CenterDot": "·", "cfr": "𝔠", "Cfr": "ℭ", "chcy": "ч", "CHcy": "Ч", "check": "✓", "checkmark": "✓", "chi": "χ", "Chi": "Χ", "cir": "○", "circ": "ˆ", "circeq": "≗", "circlearrowleft": "↺", "circlearrowright": "↻", "circledast": "⊛", "circledcirc": "⊚", "circleddash": "⊝", "CircleDot": "⊙", "circledR": "®", "circledS": "Ⓢ", "CircleMinus": "⊖", "CirclePlus": "⊕", "CircleTimes": "⊗", "cire": "≗", "cirE": "⧃", "cirfnint": "⨐", "cirmid": "⫯", "cirscir": "⧂", "ClockwiseContourIntegral": "∲", "CloseCurlyDoubleQuote": "”", "CloseCurlyQuote": "’", "clubs": "♣", "clubsuit": "♣", "colon": ":", "Colon": "∷", "colone": "≔", "Colone": "⩴", "coloneq": "≔", "comma": ",", "commat": "@", "comp": "∁", "compfn": "∘", "complement": "∁", "complexes": "ℂ", "cong": "≅", "congdot": "⩭", "Congruent": "≡", "conint": "∮", "Conint": "∯", "ContourIntegral": "∮", "copf": "𝕔", "Copf": "ℂ", "coprod": "∐", "Coproduct": "∐", "copy": "©", "COPY": "©", "copysr": "℗", "CounterClockwiseContourIntegral": "∳", "crarr": "↵", "cross": "✗", "Cross": "⨯", "cscr": "𝒸", "Cscr": "𝒞", "csub": "⫏", "csube": "⫑", "csup": "⫐", "csupe": "⫒", "ctdot": "⋯", "cudarrl": "⤸", "cudarrr": "⤵", "cuepr": "⋞", "cuesc": "⋟", "cularr": "↶", "cularrp": "⤽", "cup": "∪", "Cup": "⋓", "cupbrcap": "⩈", "cupcap": "⩆", "CupCap": "≍", "cupcup": "⩊", "cupdot": "⊍", "cupor": "⩅", "cups": "∪︀", "curarr": "↷", "curarrm": "⤼", "curlyeqprec": "⋞", "curlyeqsucc": "⋟", "curlyvee": "⋎", "curlywedge": "⋏", "curren": "¤", "curvearrowleft": "↶", "curvearrowright": "↷", "cuvee": "⋎", "cuwed": "⋏", "cwconint": "∲", "cwint": "∱", "cylcty": "⌭", "dagger": "†", "Dagger": "‡", "daleth": "ℸ", "darr": "↓", "dArr": "⇓", "Darr": "↡", "dash": "‐", "dashv": "⊣", "Dashv": "⫤", "dbkarow": "⤏", "dblac": "˝", "dcaron": "ď", "Dcaron": "Ď", "dcy": "д", "Dcy": "Д", "dd": "ⅆ", "DD": "ⅅ", "ddagger": "‡", "ddarr": "⇊", "DDotrahd": "⤑", "ddotseq": "⩷", "deg": "°", "Del": "∇", "delta": "δ", "Delta": "Δ", "demptyv": "⦱", "dfisht": "⥿", "dfr": "𝔡", "Dfr": "𝔇", "dHar": "⥥", "dharl": "⇃", "dharr": "⇂", "DiacriticalAcute": "´", "DiacriticalDot": "˙", "DiacriticalDoubleAcute": "˝", "DiacriticalGrave": "`", "DiacriticalTilde": "˜", "diam": "⋄", "diamond": "⋄", "Diamond": "⋄", "diamondsuit": "♦", "diams": "♦", "die": "¨", "DifferentialD": "ⅆ", "digamma": "ϝ", "disin": "⋲", "div": "÷", "divide": "÷", "divideontimes": "⋇", "divonx": "⋇", "djcy": "ђ", "DJcy": "Ђ", "dlcorn": "⌞", "dlcrop": "⌍", "dollar": "$", "dopf": "𝕕", "Dopf": "𝔻", "dot": "˙", "Dot": "¨", "DotDot": "⃜", "doteq": "≐", "doteqdot": "≑", "DotEqual": "≐", "dotminus": "∸", "dotplus": "∔", "dotsquare": "⊡", "doublebarwedge": "⌆", "DoubleContourIntegral": "∯", "DoubleDot": "¨", "DoubleDownArrow": "⇓", "DoubleLeftArrow": "⇐", "DoubleLeftRightArrow": "⇔", "DoubleLeftTee": "⫤", "DoubleLongLeftArrow": "⟸", "DoubleLongLeftRightArrow": "⟺", "DoubleLongRightArrow": "⟹", "DoubleRightArrow": "⇒", "DoubleRightTee": "⊨", "DoubleUpArrow": "⇑", "DoubleUpDownArrow": "⇕", "DoubleVerticalBar": "∥", "downarrow": "↓", "Downarrow": "⇓", "DownArrow": "↓", "DownArrowBar": "⤓", "DownArrowUpArrow": "⇵", "DownBreve": "̑", "downdownarrows": "⇊", "downharpoonleft": "⇃", "downharpoonright": "⇂", "DownLeftRightVector": "⥐", "DownLeftTeeVector": "⥞", "DownLeftVector": "↽", "DownLeftVectorBar": "⥖", "DownRightTeeVector": "⥟", "DownRightVector": "⇁", "DownRightVectorBar": "⥗", "DownTee": "⊤", "DownTeeArrow": "↧", "drbkarow": "⤐", "drcorn": "⌟", "drcrop": "⌌", "dscr": "𝒹", "Dscr": "𝒟", "dscy": "ѕ", "DScy": "Ѕ", "dsol": "⧶", "dstrok": "đ", "Dstrok": "Đ", "dtdot": "⋱", "dtri": "▿", "dtrif": "▾", "duarr": "⇵", "duhar": "⥯", "dwangle": "⦦", "dzcy": "џ", "DZcy": "Џ", "dzigrarr": "⟿", "eacute": "é", "Eacute": "É", "easter": "⩮", "ecaron": "ě", "Ecaron": "Ě", "ecir": "≖", "ecirc": "ê", "Ecirc": "Ê", "ecolon": "≕", "ecy": "э", "Ecy": "Э", "eDDot": "⩷", "edot": "ė", "eDot": "≑", "Edot": "Ė", "ee": "ⅇ", "efDot": "≒", "efr": "𝔢", "Efr": "𝔈", "eg": "⪚", "egrave": "è", "Egrave": "È", "egs": "⪖", "egsdot": "⪘", "el": "⪙", "Element": "∈", "elinters": "⏧", "ell": "ℓ", "els": "⪕", "elsdot": "⪗", "emacr": "ē", "Emacr": "Ē", "empty": "∅", "emptyset": "∅", "EmptySmallSquare": "◻", "emptyv": "∅", "EmptyVerySmallSquare": "▫", "emsp": " ", "emsp13": " ", "emsp14": " ", "eng": "ŋ", "ENG": "Ŋ", "ensp": " ", "eogon": "ę", "Eogon": "Ę", "eopf": "𝕖", "Eopf": "𝔼", "epar": "⋕", "eparsl": "⧣", "eplus": "⩱", "epsi": "ε", "epsilon": "ε", "Epsilon": "Ε", "epsiv": "ϵ", "eqcirc": "≖", "eqcolon": "≕", "eqsim": "≂", "eqslantgtr": "⪖", "eqslantless": "⪕", "Equal": "⩵", "equals": "=", "EqualTilde": "≂", "equest": "≟", "Equilibrium": "⇌", "equiv": "≡", "equivDD": "⩸", "eqvparsl": "⧥", "erarr": "⥱", "erDot": "≓", "escr": "ℯ", "Escr": "ℰ", "esdot": "≐", "esim": "≂", "Esim": "⩳", "eta": "η", "Eta": "Η", "eth": "ð", "ETH": "Ð", "euml": "ë", "Euml": "Ë", "euro": "€", "excl": "!", "exist": "∃", "Exists": "∃", "expectation": "ℰ", "exponentiale": "ⅇ", "ExponentialE": "ⅇ", "fallingdotseq": "≒", "fcy": "ф", "Fcy": "Ф", "female": "♀", "ffilig": "ﬃ", "fflig": "ﬀ", "ffllig": "ﬄ", "ffr": "𝔣", "Ffr": "𝔉", "filig": "ﬁ", "FilledSmallSquare": "◼", "FilledVerySmallSquare": "▪", "fjlig": "fj", "flat": "♭", "fllig": "ﬂ", "fltns": "▱", "fnof": "ƒ", "fopf": "𝕗", "Fopf": "𝔽", "forall": "∀", "ForAll": "∀", "fork": "⋔", "forkv": "⫙", "Fouriertrf": "ℱ", "fpartint": "⨍", "frac12": "½", "frac13": "⅓", "frac14": "¼", "frac15": "⅕", "frac16": "⅙", "frac18": "⅛", "frac23": "⅔", "frac25": "⅖", "frac34": "¾", "frac35": "⅗", "frac38": "⅜", "frac45": "⅘", "frac56": "⅚", "frac58": "⅝", "frac78": "⅞", "frasl": "⁄", "frown": "⌢", "fscr": "𝒻", "Fscr": "ℱ", "gacute": "ǵ", "gamma": "γ", "Gamma": "Γ", "gammad": "ϝ", "Gammad": "Ϝ", "gap": "⪆", "gbreve": "ğ", "Gbreve": "Ğ", "Gcedil": "Ģ", "gcirc": "ĝ", "Gcirc": "Ĝ", "gcy": "г", "Gcy": "Г", "gdot": "ġ", "Gdot": "Ġ", "ge": "≥", "gE": "≧", "gel": "⋛", "gEl": "⪌", "geq": "≥", "geqq": "≧", "geqslant": "⩾", "ges": "⩾", "gescc": "⪩", "gesdot": "⪀", "gesdoto": "⪂", "gesdotol": "⪄", "gesl": "⋛︀", "gesles": "⪔", "gfr": "𝔤", "Gfr": "𝔊", "gg": "≫", "Gg": "⋙", "ggg": "⋙", "gimel": "ℷ", "gjcy": "ѓ", "GJcy": "Ѓ", "gl": "≷", "gla": "⪥", "glE": "⪒", "glj": "⪤", "gnap": "⪊", "gnapprox": "⪊", "gne": "⪈", "gnE": "≩", "gneq": "⪈", "gneqq": "≩", "gnsim": "⋧", "gopf": "𝕘", "Gopf": "𝔾", "grave": "`", "GreaterEqual": "≥", "GreaterEqualLess": "⋛", "GreaterFullEqual": "≧", "GreaterGreater": "⪢", "GreaterLess": "≷", "GreaterSlantEqual": "⩾", "GreaterTilde": "≳", "gscr": "ℊ", "Gscr": "𝒢", "gsim": "≳", "gsime": "⪎", "gsiml": "⪐", "gt": ">", "Gt": "≫", "GT": ">", "gtcc": "⪧", "gtcir": "⩺", "gtdot": "⋗", "gtlPar": "⦕", "gtquest": "⩼", "gtrapprox": "⪆", "gtrarr": "⥸", "gtrdot": "⋗", "gtreqless": "⋛", "gtreqqless": "⪌", "gtrless": "≷", "gtrsim": "≳", "gvertneqq": "≩︀", "gvnE": "≩︀", "Hacek": "ˇ", "hairsp": " ", "half": "½", "hamilt": "ℋ", "hardcy": "ъ", "HARDcy": "Ъ", "harr": "↔", "hArr": "⇔", "harrcir": "⥈", "harrw": "↭", "Hat": "^", "hbar": "ℏ", "hcirc": "ĥ", "Hcirc": "Ĥ", "hearts": "♥", "heartsuit": "♥", "hellip": "…", "hercon": "⊹", "hfr": "𝔥", "Hfr": "ℌ", "HilbertSpace": "ℋ", "hksearow": "⤥", "hkswarow": "⤦", "hoarr": "⇿", "homtht": "∻", "hookleftarrow": "↩", "hookrightarrow": "↪", "hopf": "𝕙", "Hopf": "ℍ", "horbar": "―", "HorizontalLine": "─", "hscr": "𝒽", "Hscr": "ℋ", "hslash": "ℏ", "hstrok": "ħ", "Hstrok": "Ħ", "HumpDownHump": "≎", "HumpEqual": "≏", "hybull": "⁃", "hyphen": "‐", "iacute": "í", "Iacute": "Í", "ic": "⁣", "icirc": "î", "Icirc": "Î", "icy": "и", "Icy": "И", "Idot": "İ", "iecy": "е", "IEcy": "Е", "iexcl": "¡", "iff": "⇔", "ifr": "𝔦", "Ifr": "ℑ", "igrave": "ì", "Igrave": "Ì", "ii": "ⅈ", "iiiint": "⨌", "iiint": "∭", "iinfin": "⧜", "iiota": "℩", "ijlig": "ĳ", "IJlig": "Ĳ", "Im": "ℑ", "imacr": "ī", "Imacr": "Ī", "image": "ℑ", "ImaginaryI": "ⅈ", "imagline": "ℐ", "imagpart": "ℑ", "imath": "ı", "imof": "⊷", "imped": "Ƶ", "Implies": "⇒", "in": "∈", "incare": "℅", "infin": "∞", "infintie": "⧝", "inodot": "ı", "int": "∫", "Int": "∬", "intcal": "⊺", "integers": "ℤ", "Integral": "∫", "intercal": "⊺", "Intersection": "⋂", "intlarhk": "⨗", "intprod": "⨼", "InvisibleComma": "⁣", "InvisibleTimes": "⁢", "iocy": "ё", "IOcy": "Ё", "iogon": "į", "Iogon": "Į", "iopf": "𝕚", "Iopf": "𝕀", "iota": "ι", "Iota": "Ι", "iprod": "⨼", "iquest": "¿", "iscr": "𝒾", "Iscr": "ℐ", "isin": "∈", "isindot": "⋵", "isinE": "⋹", "isins": "⋴", "isinsv": "⋳", "isinv": "∈", "it": "⁢", "itilde": "ĩ", "Itilde": "Ĩ", "iukcy": "і", "Iukcy": "І", "iuml": "ï", "Iuml": "Ï", "jcirc": "ĵ", "Jcirc": "Ĵ", "jcy": "й", "Jcy": "Й", "jfr": "𝔧", "Jfr": "𝔍", "jmath": "ȷ", "jopf": "𝕛", "Jopf": "𝕁", "jscr": "𝒿", "Jscr": "𝒥", "jsercy": "ј", "Jsercy": "Ј", "jukcy": "є", "Jukcy": "Є", "kappa": "κ", "Kappa": "Κ", "kappav": "ϰ", "kcedil": "ķ", "Kcedil": "Ķ", "kcy": "к", "Kcy": "К", "kfr": "𝔨", "Kfr": "𝔎", "kgreen": "ĸ", "khcy": "х", "KHcy": "Х", "kjcy": "ќ", "KJcy": "Ќ", "kopf": "𝕜", "Kopf": "𝕂", "kscr": "𝓀", "Kscr": "𝒦", "lAarr": "⇚", "lacute": "ĺ", "Lacute": "Ĺ", "laemptyv": "⦴", "lagran": "ℒ", "lambda": "λ", "Lambda": "Λ", "lang": "⟨", "Lang": "⟪", "langd": "⦑", "langle": "⟨", "lap": "⪅", "Laplacetrf": "ℒ", "laquo": "«", "larr": "←", "lArr": "⇐", "Larr": "↞", "larrb": "⇤", "larrbfs": "⤟", "larrfs": "⤝", "larrhk": "↩", "larrlp": "↫", "larrpl": "⤹", "larrsim": "⥳", "larrtl": "↢", "lat": "⪫", "latail": "⤙", "lAtail": "⤛", "late": "⪭", "lates": "⪭︀", "lbarr": "⤌", "lBarr": "⤎", "lbbrk": "❲", "lbrace": "{", "lbrack": "[", "lbrke": "⦋", "lbrksld": "⦏", "lbrkslu": "⦍", "lcaron": "ľ", "Lcaron": "Ľ", "lcedil": "ļ", "Lcedil": "Ļ", "lceil": "⌈", "lcub": "{", "lcy": "л", "Lcy": "Л", "ldca": "⤶", "ldquo": "“", "ldquor": "„", "ldrdhar": "⥧", "ldrushar": "⥋", "ldsh": "↲", "le": "≤", "lE": "≦", "LeftAngleBracket": "⟨", "leftarrow": "←", "Leftarrow": "⇐", "LeftArrow": "←", "LeftArrowBar": "⇤", "LeftArrowRightArrow": "⇆", "leftarrowtail": "↢", "LeftCeiling": "⌈", "LeftDoubleBracket": "⟦", "LeftDownTeeVector": "⥡", "LeftDownVector": "⇃", "LeftDownVectorBar": "⥙", "LeftFloor": "⌊", "leftharpoondown": "↽", "leftharpoonup": "↼", "leftleftarrows": "⇇", "leftrightarrow": "↔", "Leftrightarrow": "⇔", "LeftRightArrow": "↔", "leftrightarrows": "⇆", "leftrightharpoons": "⇋", "leftrightsquigarrow": "↭", "LeftRightVector": "⥎", "LeftTee": "⊣", "LeftTeeArrow": "↤", "LeftTeeVector": "⥚", "leftthreetimes": "⋋", "LeftTriangle": "⊲", "LeftTriangleBar": "⧏", "LeftTriangleEqual": "⊴", "LeftUpDownVector": "⥑", "LeftUpTeeVector": "⥠", "LeftUpVector": "↿", "LeftUpVectorBar": "⥘", "LeftVector": "↼", "LeftVectorBar": "⥒", "leg": "⋚", "lEg": "⪋", "leq": "≤", "leqq": "≦", "leqslant": "⩽", "les": "⩽", "lescc": "⪨", "lesdot": "⩿", "lesdoto": "⪁", "lesdotor": "⪃", "lesg": "⋚︀", "lesges": "⪓", "lessapprox": "⪅", "lessdot": "⋖", "lesseqgtr": "⋚", "lesseqqgtr": "⪋", "LessEqualGreater": "⋚", "LessFullEqual": "≦", "LessGreater": "≶", "lessgtr": "≶", "LessLess": "⪡", "lesssim": "≲", "LessSlantEqual": "⩽", "LessTilde": "≲", "lfisht": "⥼", "lfloor": "⌊", "lfr": "𝔩", "Lfr": "𝔏", "lg": "≶", "lgE": "⪑", "lHar": "⥢", "lhard": "↽", "lharu": "↼", "lharul": "⥪", "lhblk": "▄", "ljcy": "љ", "LJcy": "Љ", "ll": "≪", "Ll": "⋘", "llarr": "⇇", "llcorner": "⌞", "Lleftarrow": "⇚", "llhard": "⥫", "lltri": "◺", "lmidot": "ŀ", "Lmidot": "Ŀ", "lmoust": "⎰", "lmoustache": "⎰", "lnap": "⪉", "lnapprox": "⪉", "lne": "⪇", "lnE": "≨", "lneq": "⪇", "lneqq": "≨", "lnsim": "⋦", "loang": "⟬", "loarr": "⇽", "lobrk": "⟦", "longleftarrow": "⟵", "Longleftarrow": "⟸", "LongLeftArrow": "⟵", "longleftrightarrow": "⟷", "Longleftrightarrow": "⟺", "LongLeftRightArrow": "⟷", "longmapsto": "⟼", "longrightarrow": "⟶", "Longrightarrow": "⟹", "LongRightArrow": "⟶", "looparrowleft": "↫", "looparrowright": "↬", "lopar": "⦅", "lopf": "𝕝", "Lopf": "𝕃", "loplus": "⨭", "lotimes": "⨴", "lowast": "∗", "lowbar": "_", "LowerLeftArrow": "↙", "LowerRightArrow": "↘", "loz": "◊", "lozenge": "◊", "lozf": "⧫", "lpar": "(", "lparlt": "⦓", "lrarr": "⇆", "lrcorner": "⌟", "lrhar": "⇋", "lrhard": "⥭", "lrm": "‎", "lrtri": "⊿", "lsaquo": "‹", "lscr": "𝓁", "Lscr": "ℒ", "lsh": "↰", "Lsh": "↰", "lsim": "≲", "lsime": "⪍", "lsimg": "⪏", "lsqb": "[", "lsquo": "‘", "lsquor": "‚", "lstrok": "ł", "Lstrok": "Ł", "lt": "<", "Lt": "≪", "LT": "<", "ltcc": "⪦", "ltcir": "⩹", "ltdot": "⋖", "lthree": "⋋", "ltimes": "⋉", "ltlarr": "⥶", "ltquest": "⩻", "ltri": "◃", "ltrie": "⊴", "ltrif": "◂", "ltrPar": "⦖", "lurdshar": "⥊", "luruhar": "⥦", "lvertneqq": "≨︀", "lvnE": "≨︀", "macr": "¯", "male": "♂", "malt": "✠", "maltese": "✠", "map": "↦", "Map": "⤅", "mapsto": "↦", "mapstodown": "↧", "mapstoleft": "↤", "mapstoup": "↥", "marker": "▮", "mcomma": "⨩", "mcy": "м", "Mcy": "М", "mdash": "—", "mDDot": "∺", "measuredangle": "∡", "MediumSpace": " ", "Mellintrf": "ℳ", "mfr": "𝔪", "Mfr": "𝔐", "mho": "℧", "micro": "µ", "mid": "∣", "midast": "*", "midcir": "⫰", "middot": "·", "minus": "−", "minusb": "⊟", "minusd": "∸", "minusdu": "⨪", "MinusPlus": "∓", "mlcp": "⫛", "mldr": "…", "mnplus": "∓", "models": "⊧", "mopf": "𝕞", "Mopf": "𝕄", "mp": "∓", "mscr": "𝓂", "Mscr": "ℳ", "mstpos": "∾", "mu": "μ", "Mu": "Μ", "multimap": "⊸", "mumap": "⊸", "nabla": "∇", "nacute": "ń", "Nacute": "Ń", "nang": "∠⃒", "nap": "≉", "napE": "⩰̸", "napid": "≋̸", "napos": "ŉ", "napprox": "≉", "natur": "♮", "natural": "♮", "naturals": "ℕ", "nbsp": " ", "nbump": "≎̸", "nbumpe": "≏̸", "ncap": "⩃", "ncaron": "ň", "Ncaron": "Ň", "ncedil": "ņ", "Ncedil": "Ņ", "ncong": "≇", "ncongdot": "⩭̸", "ncup": "⩂", "ncy": "н", "Ncy": "Н", "ndash": "–", "ne": "≠", "nearhk": "⤤", "nearr": "↗", "neArr": "⇗", "nearrow": "↗", "nedot": "≐̸", "NegativeMediumSpace": "​", "NegativeThickSpace": "​", "NegativeThinSpace": "​", "NegativeVeryThinSpace": "​", "nequiv": "≢", "nesear": "⤨", "nesim": "≂̸", "NestedGreaterGreater": "≫", "NestedLessLess": "≪", "NewLine": "\n", "nexist": "∄", "nexists": "∄", "nfr": "𝔫", "Nfr": "𝔑", "nge": "≱", "ngE": "≧̸", "ngeq": "≱", "ngeqq": "≧̸", "ngeqslant": "⩾̸", "nges": "⩾̸", "nGg": "⋙̸", "ngsim": "≵", "ngt": "≯", "nGt": "≫⃒", "ngtr": "≯", "nGtv": "≫̸", "nharr": "↮", "nhArr": "⇎", "nhpar": "⫲", "ni": "∋", "nis": "⋼", "nisd": "⋺", "niv": "∋", "njcy": "њ", "NJcy": "Њ", "nlarr": "↚", "nlArr": "⇍", "nldr": "‥", "nle": "≰", "nlE": "≦̸", "nleftarrow": "↚", "nLeftarrow": "⇍", "nleftrightarrow": "↮", "nLeftrightarrow": "⇎", "nleq": "≰", "nleqq": "≦̸", "nleqslant": "⩽̸", "nles": "⩽̸", "nless": "≮", "nLl": "⋘̸", "nlsim": "≴", "nlt": "≮", "nLt": "≪⃒", "nltri": "⋪", "nltrie": "⋬", "nLtv": "≪̸", "nmid": "∤", "NoBreak": "⁠", "NonBreakingSpace": " ", "nopf": "𝕟", "Nopf": "ℕ", "not": "¬", "Not": "⫬", "NotCongruent": "≢", "NotCupCap": "≭", "NotDoubleVerticalBar": "∦", "NotElement": "∉", "NotEqual": "≠", "NotEqualTilde": "≂̸", "NotExists": "∄", "NotGreater": "≯", "NotGreaterEqual": "≱", "NotGreaterFullEqual": "≧̸", "NotGreaterGreater": "≫̸", "NotGreaterLess": "≹", "NotGreaterSlantEqual": "⩾̸", "NotGreaterTilde": "≵", "NotHumpDownHump": "≎̸", "NotHumpEqual": "≏̸", "notin": "∉", "notindot": "⋵̸", "notinE": "⋹̸", "notinva": "∉", "notinvb": "⋷", "notinvc": "⋶", "NotLeftTriangle": "⋪", "NotLeftTriangleBar": "⧏̸", "NotLeftTriangleEqual": "⋬", "NotLess": "≮", "NotLessEqual": "≰", "NotLessGreater": "≸", "NotLessLess": "≪̸", "NotLessSlantEqual": "⩽̸", "NotLessTilde": "≴", "NotNestedGreaterGreater": "⪢̸", "NotNestedLessLess": "⪡̸", "notni": "∌", "notniva": "∌", "notnivb": "⋾", "notnivc": "⋽", "NotPrecedes": "⊀", "NotPrecedesEqual": "⪯̸", "NotPrecedesSlantEqual": "⋠", "NotReverseElement": "∌", "NotRightTriangle": "⋫", "NotRightTriangleBar": "⧐̸", "NotRightTriangleEqual": "⋭", "NotSquareSubset": "⊏̸", "NotSquareSubsetEqual": "⋢", "NotSquareSuperset": "⊐̸", "NotSquareSupersetEqual": "⋣", "NotSubset": "⊂⃒", "NotSubsetEqual": "⊈", "NotSucceeds": "⊁", "NotSucceedsEqual": "⪰̸", "NotSucceedsSlantEqual": "⋡", "NotSucceedsTilde": "≿̸", "NotSuperset": "⊃⃒", "NotSupersetEqual": "⊉", "NotTilde": "≁", "NotTildeEqual": "≄", "NotTildeFullEqual": "≇", "NotTildeTilde": "≉", "NotVerticalBar": "∤", "npar": "∦", "nparallel": "∦", "nparsl": "⫽⃥", "npart": "∂̸", "npolint": "⨔", "npr": "⊀", "nprcue": "⋠", "npre": "⪯̸", "nprec": "⊀", "npreceq": "⪯̸", "nrarr": "↛", "nrArr": "⇏", "nrarrc": "⤳̸", "nrarrw": "↝̸", "nrightarrow": "↛", "nRightarrow": "⇏", "nrtri": "⋫", "nrtrie": "⋭", "nsc": "⊁", "nsccue": "⋡", "nsce": "⪰̸", "nscr": "𝓃", "Nscr": "𝒩", "nshortmid": "∤", "nshortparallel": "∦", "nsim": "≁", "nsime": "≄", "nsimeq": "≄", "nsmid": "∤", "nspar": "∦", "nsqsube": "⋢", "nsqsupe": "⋣", "nsub": "⊄", "nsube": "⊈", "nsubE": "⫅̸", "nsubset": "⊂⃒", "nsubseteq": "⊈", "nsubseteqq": "⫅̸", "nsucc": "⊁", "nsucceq": "⪰̸", "nsup": "⊅", "nsupe": "⊉", "nsupE": "⫆̸", "nsupset": "⊃⃒", "nsupseteq": "⊉", "nsupseteqq": "⫆̸", "ntgl": "≹", "ntilde": "ñ", "Ntilde": "Ñ", "ntlg": "≸", "ntriangleleft": "⋪", "ntrianglelefteq": "⋬", "ntriangleright": "⋫", "ntrianglerighteq": "⋭", "nu": "ν", "Nu": "Ν", "num": "#", "numero": "№", "numsp": " ", "nvap": "≍⃒", "nvdash": "⊬", "nvDash": "⊭", "nVdash": "⊮", "nVDash": "⊯", "nvge": "≥⃒", "nvgt": ">⃒", "nvHarr": "⤄", "nvinfin": "⧞", "nvlArr": "⤂", "nvle": "≤⃒", "nvlt": "<⃒", "nvltrie": "⊴⃒", "nvrArr": "⤃", "nvrtrie": "⊵⃒", "nvsim": "∼⃒", "nwarhk": "⤣", "nwarr": "↖", "nwArr": "⇖", "nwarrow": "↖", "nwnear": "⤧", "oacute": "ó", "Oacute": "Ó", "oast": "⊛", "ocir": "⊚", "ocirc": "ô", "Ocirc": "Ô", "ocy": "о", "Ocy": "О", "odash": "⊝", "odblac": "ő", "Odblac": "Ő", "odiv": "⨸", "odot": "⊙", "odsold": "⦼", "oelig": "œ", "OElig": "Œ", "ofcir": "⦿", "ofr": "𝔬", "Ofr": "𝔒", "ogon": "˛", "ograve": "ò", "Ograve": "Ò", "ogt": "⧁", "ohbar": "⦵", "ohm": "Ω", "oint": "∮", "olarr": "↺", "olcir": "⦾", "olcross": "⦻", "oline": "‾", "olt": "⧀", "omacr": "ō", "Omacr": "Ō", "omega": "ω", "Omega": "Ω", "omicron": "ο", "Omicron": "Ο", "omid": "⦶", "ominus": "⊖", "oopf": "𝕠", "Oopf": "𝕆", "opar": "⦷", "OpenCurlyDoubleQuote": "“", "OpenCurlyQuote": "‘", "operp": "⦹", "oplus": "⊕", "or": "∨", "Or": "⩔", "orarr": "↻", "ord": "⩝", "order": "ℴ", "orderof": "ℴ", "ordf": "ª", "ordm": "º", "origof": "⊶", "oror": "⩖", "orslope": "⩗", "orv": "⩛", "oS": "Ⓢ", "oscr": "ℴ", "Oscr": "𝒪", "oslash": "ø", "Oslash": "Ø", "osol": "⊘", "otilde": "õ", "Otilde": "Õ", "otimes": "⊗", "Otimes": "⨷", "otimesas": "⨶", "ouml": "ö", "Ouml": "Ö", "ovbar": "⌽", "OverBar": "‾", "OverBrace": "⏞", "OverBracket": "⎴", "OverParenthesis": "⏜", "par": "∥", "para": "¶", "parallel": "∥", "parsim": "⫳", "parsl": "⫽", "part": "∂", "PartialD": "∂", "pcy": "п", "Pcy": "П", "percnt": "%", "period": ".", "permil": "‰", "perp": "⊥", "pertenk": "‱", "pfr": "𝔭", "Pfr": "𝔓", "phi": "φ", "Phi": "Φ", "phiv": "ϕ", "phmmat": "ℳ", "phone": "☎", "pi": "π", "Pi": "Π", "pitchfork": "⋔", "piv": "ϖ", "planck": "ℏ", "planckh": "ℎ", "plankv": "ℏ", "plus": "+", "plusacir": "⨣", "plusb": "⊞", "pluscir": "⨢", "plusdo": "∔", "plusdu": "⨥", "pluse": "⩲", "PlusMinus": "±", "plusmn": "±", "plussim": "⨦", "plustwo": "⨧", "pm": "±", "Poincareplane": "ℌ", "pointint": "⨕", "popf": "𝕡", "Popf": "ℙ", "pound": "£", "pr": "≺", "Pr": "⪻", "prap": "⪷", "prcue": "≼", "pre": "⪯", "prE": "⪳", "prec": "≺", "precapprox": "⪷", "preccurlyeq": "≼", "Precedes": "≺", "PrecedesEqual": "⪯", "PrecedesSlantEqual": "≼", "PrecedesTilde": "≾", "preceq": "⪯", "precnapprox": "⪹", "precneqq": "⪵", "precnsim": "⋨", "precsim": "≾", "prime": "′", "Prime": "″", "primes": "ℙ", "prnap": "⪹", "prnE": "⪵", "prnsim": "⋨", "prod": "∏", "Product": "∏", "profalar": "⌮", "profline": "⌒", "profsurf": "⌓", "prop": "∝", "Proportion": "∷", "Proportional": "∝", "propto": "∝", "prsim": "≾", "prurel": "⊰", "pscr": "𝓅", "Pscr": "𝒫", "psi": "ψ", "Psi": "Ψ", "puncsp": " ", "qfr": "𝔮", "Qfr": "𝔔", "qint": "⨌", "qopf": "𝕢", "Qopf": "ℚ", "qprime": "⁗", "qscr": "𝓆", "Qscr": "𝒬", "quaternions": "ℍ", "quatint": "⨖", "quest": "?", "questeq": "≟", "quot": '"', "QUOT": '"', "rAarr": "⇛", "race": "∽̱", "racute": "ŕ", "Racute": "Ŕ", "radic": "√", "raemptyv": "⦳", "rang": "⟩", "Rang": "⟫", "rangd": "⦒", "range": "⦥", "rangle": "⟩", "raquo": "»", "rarr": "→", "rArr": "⇒", "Rarr": "↠", "rarrap": "⥵", "rarrb": "⇥", "rarrbfs": "⤠", "rarrc": "⤳", "rarrfs": "⤞", "rarrhk": "↪", "rarrlp": "↬", "rarrpl": "⥅", "rarrsim": "⥴", "rarrtl": "↣", "Rarrtl": "⤖", "rarrw": "↝", "ratail": "⤚", "rAtail": "⤜", "ratio": "∶", "rationals": "ℚ", "rbarr": "⤍", "rBarr": "⤏", "RBarr": "⤐", "rbbrk": "❳", "rbrace": "}", "rbrack": "]", "rbrke": "⦌", "rbrksld": "⦎", "rbrkslu": "⦐", "rcaron": "ř", "Rcaron": "Ř", "rcedil": "ŗ", "Rcedil": "Ŗ", "rceil": "⌉", "rcub": "}", "rcy": "р", "Rcy": "Р", "rdca": "⤷", "rdldhar": "⥩", "rdquo": "”", "rdquor": "”", "rdsh": "↳", "Re": "ℜ", "real": "ℜ", "realine": "ℛ", "realpart": "ℜ", "reals": "ℝ", "rect": "▭", "reg": "®", "REG": "®", "ReverseElement": "∋", "ReverseEquilibrium": "⇋", "ReverseUpEquilibrium": "⥯", "rfisht": "⥽", "rfloor": "⌋", "rfr": "𝔯", "Rfr": "ℜ", "rHar": "⥤", "rhard": "⇁", "rharu": "⇀", "rharul": "⥬", "rho": "ρ", "Rho": "Ρ", "rhov": "ϱ", "RightAngleBracket": "⟩", "rightarrow": "→", "Rightarrow": "⇒", "RightArrow": "→", "RightArrowBar": "⇥", "RightArrowLeftArrow": "⇄", "rightarrowtail": "↣", "RightCeiling": "⌉", "RightDoubleBracket": "⟧", "RightDownTeeVector": "⥝", "RightDownVector": "⇂", "RightDownVectorBar": "⥕", "RightFloor": "⌋", "rightharpoondown": "⇁", "rightharpoonup": "⇀", "rightleftarrows": "⇄", "rightleftharpoons": "⇌", "rightrightarrows": "⇉", "rightsquigarrow": "↝", "RightTee": "⊢", "RightTeeArrow": "↦", "RightTeeVector": "⥛", "rightthreetimes": "⋌", "RightTriangle": "⊳", "RightTriangleBar": "⧐", "RightTriangleEqual": "⊵", "RightUpDownVector": "⥏", "RightUpTeeVector": "⥜", "RightUpVector": "↾", "RightUpVectorBar": "⥔", "RightVector": "⇀", "RightVectorBar": "⥓", "ring": "˚", "risingdotseq": "≓", "rlarr": "⇄", "rlhar": "⇌", "rlm": "‏", "rmoust": "⎱", "rmoustache": "⎱", "rnmid": "⫮", "roang": "⟭", "roarr": "⇾", "robrk": "⟧", "ropar": "⦆", "ropf": "𝕣", "Ropf": "ℝ", "roplus": "⨮", "rotimes": "⨵", "RoundImplies": "⥰", "rpar": ")", "rpargt": "⦔", "rppolint": "⨒", "rrarr": "⇉", "Rrightarrow": "⇛", "rsaquo": "›", "rscr": "𝓇", "Rscr": "ℛ", "rsh": "↱", "Rsh": "↱", "rsqb": "]", "rsquo": "’", "rsquor": "’", "rthree": "⋌", "rtimes": "⋊", "rtri": "▹", "rtrie": "⊵", "rtrif": "▸", "rtriltri": "⧎", "RuleDelayed": "⧴", "ruluhar": "⥨", "rx": "℞", "sacute": "ś", "Sacute": "Ś", "sbquo": "‚", "sc": "≻", "Sc": "⪼", "scap": "⪸", "scaron": "š", "Scaron": "Š", "sccue": "≽", "sce": "⪰", "scE": "⪴", "scedil": "ş", "Scedil": "Ş", "scirc": "ŝ", "Scirc": "Ŝ", "scnap": "⪺", "scnE": "⪶", "scnsim": "⋩", "scpolint": "⨓", "scsim": "≿", "scy": "с", "Scy": "С", "sdot": "⋅", "sdotb": "⊡", "sdote": "⩦", "searhk": "⤥", "searr": "↘", "seArr": "⇘", "searrow": "↘", "sect": "§", "semi": ";", "seswar": "⤩", "setminus": "∖", "setmn": "∖", "sext": "✶", "sfr": "𝔰", "Sfr": "𝔖", "sfrown": "⌢", "sharp": "♯", "shchcy": "щ", "SHCHcy": "Щ", "shcy": "ш", "SHcy": "Ш", "ShortDownArrow": "↓", "ShortLeftArrow": "←", "shortmid": "∣", "shortparallel": "∥", "ShortRightArrow": "→", "ShortUpArrow": "↑", "shy": "­", "sigma": "σ", "Sigma": "Σ", "sigmaf": "ς", "sigmav": "ς", "sim": "∼", "simdot": "⩪", "sime": "≃", "simeq": "≃", "simg": "⪞", "simgE": "⪠", "siml": "⪝", "simlE": "⪟", "simne": "≆", "simplus": "⨤", "simrarr": "⥲", "slarr": "←", "SmallCircle": "∘", "smallsetminus": "∖", "smashp": "⨳", "smeparsl": "⧤", "smid": "∣", "smile": "⌣", "smt": "⪪", "smte": "⪬", "smtes": "⪬︀", "softcy": "ь", "SOFTcy": "Ь", "sol": "/", "solb": "⧄", "solbar": "⌿", "sopf": "𝕤", "Sopf": "𝕊", "spades": "♠", "spadesuit": "♠", "spar": "∥", "sqcap": "⊓", "sqcaps": "⊓︀", "sqcup": "⊔", "sqcups": "⊔︀", "Sqrt": "√", "sqsub": "⊏", "sqsube": "⊑", "sqsubset": "⊏", "sqsubseteq": "⊑", "sqsup": "⊐", "sqsupe": "⊒", "sqsupset": "⊐", "sqsupseteq": "⊒", "squ": "□", "square": "□", "Square": "□", "SquareIntersection": "⊓", "SquareSubset": "⊏", "SquareSubsetEqual": "⊑", "SquareSuperset": "⊐", "SquareSupersetEqual": "⊒", "SquareUnion": "⊔", "squarf": "▪", "squf": "▪", "srarr": "→", "sscr": "𝓈", "Sscr": "𝒮", "ssetmn": "∖", "ssmile": "⌣", "sstarf": "⋆", "star": "☆", "Star": "⋆", "starf": "★", "straightepsilon": "ϵ", "straightphi": "ϕ", "strns": "¯", "sub": "⊂", "Sub": "⋐", "subdot": "⪽", "sube": "⊆", "subE": "⫅", "subedot": "⫃", "submult": "⫁", "subne": "⊊", "subnE": "⫋", "subplus": "⪿", "subrarr": "⥹", "subset": "⊂", "Subset": "⋐", "subseteq": "⊆", "subseteqq": "⫅", "SubsetEqual": "⊆", "subsetneq": "⊊", "subsetneqq": "⫋", "subsim": "⫇", "subsub": "⫕", "subsup": "⫓", "succ": "≻", "succapprox": "⪸", "succcurlyeq": "≽", "Succeeds": "≻", "SucceedsEqual": "⪰", "SucceedsSlantEqual": "≽", "SucceedsTilde": "≿", "succeq": "⪰", "succnapprox": "⪺", "succneqq": "⪶", "succnsim": "⋩", "succsim": "≿", "SuchThat": "∋", "sum": "∑", "Sum": "∑", "sung": "♪", "sup": "⊃", "Sup": "⋑", "sup1": "¹", "sup2": "²", "sup3": "³", "supdot": "⪾", "supdsub": "⫘", "supe": "⊇", "supE": "⫆", "supedot": "⫄", "Superset": "⊃", "SupersetEqual": "⊇", "suphsol": "⟉", "suphsub": "⫗", "suplarr": "⥻", "supmult": "⫂", "supne": "⊋", "supnE": "⫌", "supplus": "⫀", "supset": "⊃", "Supset": "⋑", "supseteq": "⊇", "supseteqq": "⫆", "supsetneq": "⊋", "supsetneqq": "⫌", "supsim": "⫈", "supsub": "⫔", "supsup": "⫖", "swarhk": "⤦", "swarr": "↙", "swArr": "⇙", "swarrow": "↙", "swnwar": "⤪", "szlig": "ß", "Tab": "	", "target": "⌖", "tau": "τ", "Tau": "Τ", "tbrk": "⎴", "tcaron": "ť", "Tcaron": "Ť", "tcedil": "ţ", "Tcedil": "Ţ", "tcy": "т", "Tcy": "Т", "tdot": "⃛", "telrec": "⌕", "tfr": "𝔱", "Tfr": "𝔗", "there4": "∴", "therefore": "∴", "Therefore": "∴", "theta": "θ", "Theta": "Θ", "thetasym": "ϑ", "thetav": "ϑ", "thickapprox": "≈", "thicksim": "∼", "ThickSpace": "  ", "thinsp": " ", "ThinSpace": " ", "thkap": "≈", "thksim": "∼", "thorn": "þ", "THORN": "Þ", "tilde": "˜", "Tilde": "∼", "TildeEqual": "≃", "TildeFullEqual": "≅", "TildeTilde": "≈", "times": "×", "timesb": "⊠", "timesbar": "⨱", "timesd": "⨰", "tint": "∭", "toea": "⤨", "top": "⊤", "topbot": "⌶", "topcir": "⫱", "topf": "𝕥", "Topf": "𝕋", "topfork": "⫚", "tosa": "⤩", "tprime": "‴", "trade": "™", "TRADE": "™", "triangle": "▵", "triangledown": "▿", "triangleleft": "◃", "trianglelefteq": "⊴", "triangleq": "≜", "triangleright": "▹", "trianglerighteq": "⊵", "tridot": "◬", "trie": "≜", "triminus": "⨺", "TripleDot": "⃛", "triplus": "⨹", "trisb": "⧍", "tritime": "⨻", "trpezium": "⏢", "tscr": "𝓉", "Tscr": "𝒯", "tscy": "ц", "TScy": "Ц", "tshcy": "ћ", "TSHcy": "Ћ", "tstrok": "ŧ", "Tstrok": "Ŧ", "twixt": "≬", "twoheadleftarrow": "↞", "twoheadrightarrow": "↠", "uacute": "ú", "Uacute": "Ú", "uarr": "↑", "uArr": "⇑", "Uarr": "↟", "Uarrocir": "⥉", "ubrcy": "ў", "Ubrcy": "Ў", "ubreve": "ŭ", "Ubreve": "Ŭ", "ucirc": "û", "Ucirc": "Û", "ucy": "у", "Ucy": "У", "udarr": "⇅", "udblac": "ű", "Udblac": "Ű", "udhar": "⥮", "ufisht": "⥾", "ufr": "𝔲", "Ufr": "𝔘", "ugrave": "ù", "Ugrave": "Ù", "uHar": "⥣", "uharl": "↿", "uharr": "↾", "uhblk": "▀", "ulcorn": "⌜", "ulcorner": "⌜", "ulcrop": "⌏", "ultri": "◸", "umacr": "ū", "Umacr": "Ū", "uml": "¨", "UnderBar": "_", "UnderBrace": "⏟", "UnderBracket": "⎵", "UnderParenthesis": "⏝", "Union": "⋃", "UnionPlus": "⊎", "uogon": "ų", "Uogon": "Ų", "uopf": "𝕦", "Uopf": "𝕌", "uparrow": "↑", "Uparrow": "⇑", "UpArrow": "↑", "UpArrowBar": "⤒", "UpArrowDownArrow": "⇅", "updownarrow": "↕", "Updownarrow": "⇕", "UpDownArrow": "↕", "UpEquilibrium": "⥮", "upharpoonleft": "↿", "upharpoonright": "↾", "uplus": "⊎", "UpperLeftArrow": "↖", "UpperRightArrow": "↗", "upsi": "υ", "Upsi": "ϒ", "upsih": "ϒ", "upsilon": "υ", "Upsilon": "Υ", "UpTee": "⊥", "UpTeeArrow": "↥", "upuparrows": "⇈", "urcorn": "⌝", "urcorner": "⌝", "urcrop": "⌎", "uring": "ů", "Uring": "Ů", "urtri": "◹", "uscr": "𝓊", "Uscr": "𝒰", "utdot": "⋰", "utilde": "ũ", "Utilde": "Ũ", "utri": "▵", "utrif": "▴", "uuarr": "⇈", "uuml": "ü", "Uuml": "Ü", "uwangle": "⦧", "vangrt": "⦜", "varepsilon": "ϵ", "varkappa": "ϰ", "varnothing": "∅", "varphi": "ϕ", "varpi": "ϖ", "varpropto": "∝", "varr": "↕", "vArr": "⇕", "varrho": "ϱ", "varsigma": "ς", "varsubsetneq": "⊊︀", "varsubsetneqq": "⫋︀", "varsupsetneq": "⊋︀", "varsupsetneqq": "⫌︀", "vartheta": "ϑ", "vartriangleleft": "⊲", "vartriangleright": "⊳", "vBar": "⫨", "Vbar": "⫫", "vBarv": "⫩", "vcy": "в", "Vcy": "В", "vdash": "⊢", "vDash": "⊨", "Vdash": "⊩", "VDash": "⊫", "Vdashl": "⫦", "vee": "∨", "Vee": "⋁", "veebar": "⊻", "veeeq": "≚", "vellip": "⋮", "verbar": "|", "Verbar": "‖", "vert": "|", "Vert": "‖", "VerticalBar": "∣", "VerticalLine": "|", "VerticalSeparator": "❘", "VerticalTilde": "≀", "VeryThinSpace": " ", "vfr": "𝔳", "Vfr": "𝔙", "vltri": "⊲", "vnsub": "⊂⃒", "vnsup": "⊃⃒", "vopf": "𝕧", "Vopf": "𝕍", "vprop": "∝", "vrtri": "⊳", "vscr": "𝓋", "Vscr": "𝒱", "vsubne": "⊊︀", "vsubnE": "⫋︀", "vsupne": "⊋︀", "vsupnE": "⫌︀", "Vvdash": "⊪", "vzigzag": "⦚", "wcirc": "ŵ", "Wcirc": "Ŵ", "wedbar": "⩟", "wedge": "∧", "Wedge": "⋀", "wedgeq": "≙", "weierp": "℘", "wfr": "𝔴", "Wfr": "𝔚", "wopf": "𝕨", "Wopf": "𝕎", "wp": "℘", "wr": "≀", "wreath": "≀", "wscr": "𝓌", "Wscr": "𝒲", "xcap": "⋂", "xcirc": "◯", "xcup": "⋃", "xdtri": "▽", "xfr": "𝔵", "Xfr": "𝔛", "xharr": "⟷", "xhArr": "⟺", "xi": "ξ", "Xi": "Ξ", "xlarr": "⟵", "xlArr": "⟸", "xmap": "⟼", "xnis": "⋻", "xodot": "⨀", "xopf": "𝕩", "Xopf": "𝕏", "xoplus": "⨁", "xotime": "⨂", "xrarr": "⟶", "xrArr": "⟹", "xscr": "𝓍", "Xscr": "𝒳", "xsqcup": "⨆", "xuplus": "⨄", "xutri": "△", "xvee": "⋁", "xwedge": "⋀", "yacute": "ý", "Yacute": "Ý", "yacy": "я", "YAcy": "Я", "ycirc": "ŷ", "Ycirc": "Ŷ", "ycy": "ы", "Ycy": "Ы", "yen": "¥", "yfr": "𝔶", "Yfr": "𝔜", "yicy": "ї", "YIcy": "Ї", "yopf": "𝕪", "Yopf": "𝕐", "yscr": "𝓎", "Yscr": "𝒴", "yucy": "ю", "YUcy": "Ю", "yuml": "ÿ", "Yuml": "Ÿ", "zacute": "ź", "Zacute": "Ź", "zcaron": "ž", "Zcaron": "Ž", "zcy": "з", "Zcy": "З", "zdot": "ż", "Zdot": "Ż", "zeetrf": "ℨ", "ZeroWidthSpace": "​", "zeta": "ζ", "Zeta": "Ζ", "zfr": "𝔷", "Zfr": "ℨ", "zhcy": "ж", "ZHcy": "Ж", "zigrarr": "⇝", "zopf": "𝕫", "Zopf": "ℤ", "zscr": "𝓏", "Zscr": "𝒵", "zwj": "‍", "zwnj": "‌" };
      var decodeMapLegacy = { "aacute": "á", "Aacute": "Á", "acirc": "â", "Acirc": "Â", "acute": "´", "aelig": "æ", "AElig": "Æ", "agrave": "à", "Agrave": "À", "amp": "&", "AMP": "&", "aring": "å", "Aring": "Å", "atilde": "ã", "Atilde": "Ã", "auml": "ä", "Auml": "Ä", "brvbar": "¦", "ccedil": "ç", "Ccedil": "Ç", "cedil": "¸", "cent": "¢", "copy": "©", "COPY": "©", "curren": "¤", "deg": "°", "divide": "÷", "eacute": "é", "Eacute": "É", "ecirc": "ê", "Ecirc": "Ê", "egrave": "è", "Egrave": "È", "eth": "ð", "ETH": "Ð", "euml": "ë", "Euml": "Ë", "frac12": "½", "frac14": "¼", "frac34": "¾", "gt": ">", "GT": ">", "iacute": "í", "Iacute": "Í", "icirc": "î", "Icirc": "Î", "iexcl": "¡", "igrave": "ì", "Igrave": "Ì", "iquest": "¿", "iuml": "ï", "Iuml": "Ï", "laquo": "«", "lt": "<", "LT": "<", "macr": "¯", "micro": "µ", "middot": "·", "nbsp": " ", "not": "¬", "ntilde": "ñ", "Ntilde": "Ñ", "oacute": "ó", "Oacute": "Ó", "ocirc": "ô", "Ocirc": "Ô", "ograve": "ò", "Ograve": "Ò", "ordf": "ª", "ordm": "º", "oslash": "ø", "Oslash": "Ø", "otilde": "õ", "Otilde": "Õ", "ouml": "ö", "Ouml": "Ö", "para": "¶", "plusmn": "±", "pound": "£", "quot": '"', "QUOT": '"', "raquo": "»", "reg": "®", "REG": "®", "sect": "§", "shy": "­", "sup1": "¹", "sup2": "²", "sup3": "³", "szlig": "ß", "thorn": "þ", "THORN": "Þ", "times": "×", "uacute": "ú", "Uacute": "Ú", "ucirc": "û", "Ucirc": "Û", "ugrave": "ù", "Ugrave": "Ù", "uml": "¨", "uuml": "ü", "Uuml": "Ü", "yacute": "ý", "Yacute": "Ý", "yen": "¥", "yuml": "ÿ" };
      var decodeMapNumeric = { "0": "�", "128": "€", "130": "‚", "131": "ƒ", "132": "„", "133": "…", "134": "†", "135": "‡", "136": "ˆ", "137": "‰", "138": "Š", "139": "‹", "140": "Œ", "142": "Ž", "145": "‘", "146": "’", "147": "“", "148": "”", "149": "•", "150": "–", "151": "—", "152": "˜", "153": "™", "154": "š", "155": "›", "156": "œ", "158": "ž", "159": "Ÿ" };
      var invalidReferenceCodePoints = [1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 64976, 64977, 64978, 64979, 64980, 64981, 64982, 64983, 64984, 64985, 64986, 64987, 64988, 64989, 64990, 64991, 64992, 64993, 64994, 64995, 64996, 64997, 64998, 64999, 65e3, 65001, 65002, 65003, 65004, 65005, 65006, 65007, 65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111];
      var stringFromCharCode = String.fromCharCode;
      var object = {};
      var hasOwnProperty2 = object.hasOwnProperty;
      var has = function(object2, propertyName) {
        return hasOwnProperty2.call(object2, propertyName);
      };
      var contains = function(array, value) {
        var index = -1;
        var length = array.length;
        while (++index < length) {
          if (array[index] == value) {
            return true;
          }
        }
        return false;
      };
      var merge = function(options, defaults) {
        if (!options) {
          return defaults;
        }
        var result = {};
        var key2;
        for (key2 in defaults) {
          result[key2] = has(options, key2) ? options[key2] : defaults[key2];
        }
        return result;
      };
      var codePointToSymbol = function(codePoint, strict) {
        var output = "";
        if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
          if (strict) {
            parseError("character reference outside the permissible Unicode range");
          }
          return "�";
        }
        if (has(decodeMapNumeric, codePoint)) {
          if (strict) {
            parseError("disallowed character reference");
          }
          return decodeMapNumeric[codePoint];
        }
        if (strict && contains(invalidReferenceCodePoints, codePoint)) {
          parseError("disallowed character reference");
        }
        if (codePoint > 65535) {
          codePoint -= 65536;
          output += stringFromCharCode(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        output += stringFromCharCode(codePoint);
        return output;
      };
      var hexEscape = function(codePoint) {
        return "&#x" + codePoint.toString(16).toUpperCase() + ";";
      };
      var decEscape = function(codePoint) {
        return "&#" + codePoint + ";";
      };
      var parseError = function(message) {
        throw Error("Parse error: " + message);
      };
      var encode = function(string, options) {
        options = merge(options, encode.options);
        var strict = options.strict;
        if (strict && regexInvalidRawCodePoint.test(string)) {
          parseError("forbidden code point");
        }
        var encodeEverything = options.encodeEverything;
        var useNamedReferences = options.useNamedReferences;
        var allowUnsafeSymbols = options.allowUnsafeSymbols;
        var escapeCodePoint = options.decimal ? decEscape : hexEscape;
        var escapeBmpSymbol = function(symbol) {
          return escapeCodePoint(symbol.charCodeAt(0));
        };
        if (encodeEverything) {
          string = string.replace(regexAsciiWhitelist, function(symbol) {
            if (useNamedReferences && has(encodeMap, symbol)) {
              return "&" + encodeMap[symbol] + ";";
            }
            return escapeBmpSymbol(symbol);
          });
          if (useNamedReferences) {
            string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;").replace(/&#x66;&#x6A;/g, "&fjlig;");
          }
          if (useNamedReferences) {
            string = string.replace(regexEncodeNonAscii, function(string2) {
              return "&" + encodeMap[string2] + ";";
            });
          }
        } else if (useNamedReferences) {
          if (!allowUnsafeSymbols) {
            string = string.replace(regexEscape, function(string2) {
              return "&" + encodeMap[string2] + ";";
            });
          }
          string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;");
          string = string.replace(regexEncodeNonAscii, function(string2) {
            return "&" + encodeMap[string2] + ";";
          });
        } else if (!allowUnsafeSymbols) {
          string = string.replace(regexEscape, escapeBmpSymbol);
        }
        return string.replace(regexAstralSymbols, function($02) {
          var high = $02.charCodeAt(0);
          var low = $02.charCodeAt(1);
          var codePoint = (high - 55296) * 1024 + low - 56320 + 65536;
          return escapeCodePoint(codePoint);
        }).replace(regexBmpWhitelist, escapeBmpSymbol);
      };
      encode.options = {
        "allowUnsafeSymbols": false,
        "encodeEverything": false,
        "strict": false,
        "useNamedReferences": false,
        "decimal": false
      };
      var decode = function(html, options) {
        options = merge(options, decode.options);
        var strict = options.strict;
        if (strict && regexInvalidEntity.test(html)) {
          parseError("malformed character reference");
        }
        return html.replace(regexDecode, function($02, $1, $2, $3, $4, $5, $6, $7, $8) {
          var codePoint;
          var semicolon;
          var decDigits;
          var hexDigits;
          var reference;
          var next;
          if ($1) {
            reference = $1;
            return decodeMap[reference];
          }
          if ($2) {
            reference = $2;
            next = $3;
            if (next && options.isAttributeValue) {
              if (strict && next == "=") {
                parseError("`&` did not start a character reference");
              }
              return $02;
            } else {
              if (strict) {
                parseError(
                  "named character reference was not terminated by a semicolon"
                );
              }
              return decodeMapLegacy[reference] + (next || "");
            }
          }
          if ($4) {
            decDigits = $4;
            semicolon = $5;
            if (strict && !semicolon) {
              parseError("character reference was not terminated by a semicolon");
            }
            codePoint = parseInt(decDigits, 10);
            return codePointToSymbol(codePoint, strict);
          }
          if ($6) {
            hexDigits = $6;
            semicolon = $7;
            if (strict && !semicolon) {
              parseError("character reference was not terminated by a semicolon");
            }
            codePoint = parseInt(hexDigits, 16);
            return codePointToSymbol(codePoint, strict);
          }
          if (strict) {
            parseError(
              "named character reference was not terminated by a semicolon"
            );
          }
          return $02;
        });
      };
      decode.options = {
        "isAttributeValue": false,
        "strict": false
      };
      var escape = function(string) {
        return string.replace(regexEscape, function($02) {
          return escapeMap[$02];
        });
      };
      var he3 = {
        "version": "1.2.0",
        "encode": encode,
        "decode": decode,
        "escape": escape,
        "unescape": decode
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define(function() {
          return he3;
        });
      } else if (freeExports && !freeExports.nodeType) {
        if (freeModule) {
          freeModule.exports = he3;
        } else {
          for (var key in he3) {
            has(he3, key) && (freeExports[key] = he3[key]);
          }
        }
      } else {
        root.he = he3;
      }
    })(exports);
  }
});

// node_modules/node-html-parser/dist/nodes/node.js
var require_node = __commonJS({
  "node_modules/node-html-parser/dist/nodes/node.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var he_1 = require_he();
    var Node2 = (
      /** @class */
      function() {
        function Node3(parentNode, range) {
          if (parentNode === void 0) {
            parentNode = null;
          }
          this.parentNode = parentNode;
          this.childNodes = [];
          Object.defineProperty(this, "range", {
            enumerable: false,
            writable: true,
            configurable: true,
            value: range !== null && range !== void 0 ? range : [-1, -1]
          });
        }
        Node3.prototype.remove = function() {
          var _this = this;
          if (this.parentNode) {
            var children = this.parentNode.childNodes;
            this.parentNode.childNodes = children.filter(function(child) {
              return _this !== child;
            });
            this.parentNode = null;
          }
          return this;
        };
        Object.defineProperty(Node3.prototype, "innerText", {
          get: function() {
            return this.rawText;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node3.prototype, "textContent", {
          get: function() {
            return (0, he_1.decode)(this.rawText);
          },
          set: function(val) {
            this.rawText = (0, he_1.encode)(val);
          },
          enumerable: false,
          configurable: true
        });
        return Node3;
      }()
    );
    exports.default = Node2;
  }
});

// node_modules/node-html-parser/dist/nodes/type.js
var require_type = __commonJS({
  "node_modules/node-html-parser/dist/nodes/type.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NodeType2;
    (function(NodeType3) {
      NodeType3[NodeType3["ELEMENT_NODE"] = 1] = "ELEMENT_NODE";
      NodeType3[NodeType3["TEXT_NODE"] = 3] = "TEXT_NODE";
      NodeType3[NodeType3["COMMENT_NODE"] = 8] = "COMMENT_NODE";
    })(NodeType2 || (NodeType2 = {}));
    exports.default = NodeType2;
  }
});

// node_modules/node-html-parser/dist/nodes/comment.js
var require_comment = __commonJS({
  "node_modules/node-html-parser/dist/nodes/comment.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d2, b3) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b4) {
          d3.__proto__ = b4;
        } || function(d3, b4) {
          for (var p2 in b4)
            if (Object.prototype.hasOwnProperty.call(b4, p2))
              d3[p2] = b4[p2];
        };
        return extendStatics(d2, b3);
      };
      return function(d2, b3) {
        if (typeof b3 !== "function" && b3 !== null)
          throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
        extendStatics(d2, b3);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var node_1 = __importDefault(require_node());
    var type_1 = __importDefault(require_type());
    var CommentNode = (
      /** @class */
      function(_super) {
        __extends(CommentNode2, _super);
        function CommentNode2(rawText, parentNode, range, rawTagName) {
          if (parentNode === void 0) {
            parentNode = null;
          }
          if (rawTagName === void 0) {
            rawTagName = "!--";
          }
          var _this = _super.call(this, parentNode, range) || this;
          _this.rawText = rawText;
          _this.rawTagName = rawTagName;
          _this.nodeType = type_1.default.COMMENT_NODE;
          return _this;
        }
        CommentNode2.prototype.clone = function() {
          return new CommentNode2(this.rawText, null, void 0, this.rawTagName);
        };
        Object.defineProperty(CommentNode2.prototype, "text", {
          /**
           * Get unescaped text value of current node and its children.
           * @return {string} text content
           */
          get: function() {
            return this.rawText;
          },
          enumerable: false,
          configurable: true
        });
        CommentNode2.prototype.toString = function() {
          return "<!--".concat(this.rawText, "-->");
        };
        return CommentNode2;
      }(node_1.default)
    );
    exports.default = CommentNode;
  }
});

// node_modules/domelementtype/lib/index.js
var require_lib = __commonJS({
  "node_modules/domelementtype/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;
    var ElementType2;
    (function(ElementType3) {
      ElementType3["Root"] = "root";
      ElementType3["Text"] = "text";
      ElementType3["Directive"] = "directive";
      ElementType3["Comment"] = "comment";
      ElementType3["Script"] = "script";
      ElementType3["Style"] = "style";
      ElementType3["Tag"] = "tag";
      ElementType3["CDATA"] = "cdata";
      ElementType3["Doctype"] = "doctype";
    })(ElementType2 = exports.ElementType || (exports.ElementType = {}));
    function isTag(elem) {
      return elem.type === ElementType2.Tag || elem.type === ElementType2.Script || elem.type === ElementType2.Style;
    }
    exports.isTag = isTag;
    exports.Root = ElementType2.Root;
    exports.Text = ElementType2.Text;
    exports.Directive = ElementType2.Directive;
    exports.Comment = ElementType2.Comment;
    exports.Script = ElementType2.Script;
    exports.Style = ElementType2.Style;
    exports.Tag = ElementType2.Tag;
    exports.CDATA = ElementType2.CDATA;
    exports.Doctype = ElementType2.Doctype;
  }
});

// node_modules/domhandler/lib/node.js
var require_node2 = __commonJS({
  "node_modules/domhandler/lib/node.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d2, b3) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b4) {
          d3.__proto__ = b4;
        } || function(d3, b4) {
          for (var p2 in b4)
            if (Object.prototype.hasOwnProperty.call(b4, p2))
              d3[p2] = b4[p2];
        };
        return extendStatics(d2, b3);
      };
      return function(d2, b3) {
        if (typeof b3 !== "function" && b3 !== null)
          throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
        extendStatics(d2, b3);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cloneNode = exports.hasChildren = exports.isDocument = exports.isDirective = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = exports.Element = exports.Document = exports.CDATA = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = void 0;
    var domelementtype_1 = require_lib();
    var Node2 = (
      /** @class */
      function() {
        function Node3() {
          this.parent = null;
          this.prev = null;
          this.next = null;
          this.startIndex = null;
          this.endIndex = null;
        }
        Object.defineProperty(Node3.prototype, "parentNode", {
          // Read-write aliases for properties
          /**
           * Same as {@link parent}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.parent;
          },
          set: function(parent) {
            this.parent = parent;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node3.prototype, "previousSibling", {
          /**
           * Same as {@link prev}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.prev;
          },
          set: function(prev) {
            this.prev = prev;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node3.prototype, "nextSibling", {
          /**
           * Same as {@link next}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.next;
          },
          set: function(next) {
            this.next = next;
          },
          enumerable: false,
          configurable: true
        });
        Node3.prototype.cloneNode = function(recursive) {
          if (recursive === void 0) {
            recursive = false;
          }
          return cloneNode(this, recursive);
        };
        return Node3;
      }()
    );
    exports.Node = Node2;
    var DataNode = (
      /** @class */
      function(_super) {
        __extends(DataNode2, _super);
        function DataNode2(data) {
          var _this = _super.call(this) || this;
          _this.data = data;
          return _this;
        }
        Object.defineProperty(DataNode2.prototype, "nodeValue", {
          /**
           * Same as {@link data}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.data;
          },
          set: function(data) {
            this.data = data;
          },
          enumerable: false,
          configurable: true
        });
        return DataNode2;
      }(Node2)
    );
    exports.DataNode = DataNode;
    var Text2 = (
      /** @class */
      function(_super) {
        __extends(Text3, _super);
        function Text3() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Text;
          return _this;
        }
        Object.defineProperty(Text3.prototype, "nodeType", {
          get: function() {
            return 3;
          },
          enumerable: false,
          configurable: true
        });
        return Text3;
      }(DataNode)
    );
    exports.Text = Text2;
    var Comment = (
      /** @class */
      function(_super) {
        __extends(Comment2, _super);
        function Comment2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Comment;
          return _this;
        }
        Object.defineProperty(Comment2.prototype, "nodeType", {
          get: function() {
            return 8;
          },
          enumerable: false,
          configurable: true
        });
        return Comment2;
      }(DataNode)
    );
    exports.Comment = Comment;
    var ProcessingInstruction = (
      /** @class */
      function(_super) {
        __extends(ProcessingInstruction2, _super);
        function ProcessingInstruction2(name, data) {
          var _this = _super.call(this, data) || this;
          _this.name = name;
          _this.type = domelementtype_1.ElementType.Directive;
          return _this;
        }
        Object.defineProperty(ProcessingInstruction2.prototype, "nodeType", {
          get: function() {
            return 1;
          },
          enumerable: false,
          configurable: true
        });
        return ProcessingInstruction2;
      }(DataNode)
    );
    exports.ProcessingInstruction = ProcessingInstruction;
    var NodeWithChildren = (
      /** @class */
      function(_super) {
        __extends(NodeWithChildren2, _super);
        function NodeWithChildren2(children) {
          var _this = _super.call(this) || this;
          _this.children = children;
          return _this;
        }
        Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
          // Aliases
          /** First child of the node. */
          get: function() {
            var _a;
            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
          /** Last child of the node. */
          get: function() {
            return this.children.length > 0 ? this.children[this.children.length - 1] : null;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
          /**
           * Same as {@link children}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.children;
          },
          set: function(children) {
            this.children = children;
          },
          enumerable: false,
          configurable: true
        });
        return NodeWithChildren2;
      }(Node2)
    );
    exports.NodeWithChildren = NodeWithChildren;
    var CDATA = (
      /** @class */
      function(_super) {
        __extends(CDATA2, _super);
        function CDATA2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.CDATA;
          return _this;
        }
        Object.defineProperty(CDATA2.prototype, "nodeType", {
          get: function() {
            return 4;
          },
          enumerable: false,
          configurable: true
        });
        return CDATA2;
      }(NodeWithChildren)
    );
    exports.CDATA = CDATA;
    var Document = (
      /** @class */
      function(_super) {
        __extends(Document2, _super);
        function Document2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Root;
          return _this;
        }
        Object.defineProperty(Document2.prototype, "nodeType", {
          get: function() {
            return 9;
          },
          enumerable: false,
          configurable: true
        });
        return Document2;
      }(NodeWithChildren)
    );
    exports.Document = Document;
    var Element = (
      /** @class */
      function(_super) {
        __extends(Element2, _super);
        function Element2(name, attribs, children, type) {
          if (children === void 0) {
            children = [];
          }
          if (type === void 0) {
            type = name === "script" ? domelementtype_1.ElementType.Script : name === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
          }
          var _this = _super.call(this, children) || this;
          _this.name = name;
          _this.attribs = attribs;
          _this.type = type;
          return _this;
        }
        Object.defineProperty(Element2.prototype, "nodeType", {
          get: function() {
            return 1;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Element2.prototype, "tagName", {
          // DOM Level 1 aliases
          /**
           * Same as {@link name}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.name;
          },
          set: function(name) {
            this.name = name;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Element2.prototype, "attributes", {
          get: function() {
            var _this = this;
            return Object.keys(this.attribs).map(function(name) {
              var _a, _b;
              return {
                name,
                value: _this.attribs[name],
                namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
                prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
              };
            });
          },
          enumerable: false,
          configurable: true
        });
        return Element2;
      }(NodeWithChildren)
    );
    exports.Element = Element;
    function isTag(node) {
      return (0, domelementtype_1.isTag)(node);
    }
    exports.isTag = isTag;
    function isCDATA(node) {
      return node.type === domelementtype_1.ElementType.CDATA;
    }
    exports.isCDATA = isCDATA;
    function isText(node) {
      return node.type === domelementtype_1.ElementType.Text;
    }
    exports.isText = isText;
    function isComment(node) {
      return node.type === domelementtype_1.ElementType.Comment;
    }
    exports.isComment = isComment;
    function isDirective(node) {
      return node.type === domelementtype_1.ElementType.Directive;
    }
    exports.isDirective = isDirective;
    function isDocument(node) {
      return node.type === domelementtype_1.ElementType.Root;
    }
    exports.isDocument = isDocument;
    function hasChildren(node) {
      return Object.prototype.hasOwnProperty.call(node, "children");
    }
    exports.hasChildren = hasChildren;
    function cloneNode(node, recursive) {
      if (recursive === void 0) {
        recursive = false;
      }
      var result;
      if (isText(node)) {
        result = new Text2(node.data);
      } else if (isComment(node)) {
        result = new Comment(node.data);
      } else if (isTag(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_1 = new Element(node.name, __assign({}, node.attribs), children);
        children.forEach(function(child) {
          return child.parent = clone_1;
        });
        if (node.namespace != null) {
          clone_1.namespace = node.namespace;
        }
        if (node["x-attribsNamespace"]) {
          clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
        }
        if (node["x-attribsPrefix"]) {
          clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
        }
        result = clone_1;
      } else if (isCDATA(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_2 = new CDATA(children);
        children.forEach(function(child) {
          return child.parent = clone_2;
        });
        result = clone_2;
      } else if (isDocument(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_3 = new Document(children);
        children.forEach(function(child) {
          return child.parent = clone_3;
        });
        if (node["x-mode"]) {
          clone_3["x-mode"] = node["x-mode"];
        }
        result = clone_3;
      } else if (isDirective(node)) {
        var instruction = new ProcessingInstruction(node.name, node.data);
        if (node["x-name"] != null) {
          instruction["x-name"] = node["x-name"];
          instruction["x-publicId"] = node["x-publicId"];
          instruction["x-systemId"] = node["x-systemId"];
        }
        result = instruction;
      } else {
        throw new Error("Not implemented yet: ".concat(node.type));
      }
      result.startIndex = node.startIndex;
      result.endIndex = node.endIndex;
      if (node.sourceCodeLocation != null) {
        result.sourceCodeLocation = node.sourceCodeLocation;
      }
      return result;
    }
    exports.cloneNode = cloneNode;
    function cloneChildren(childs) {
      var children = childs.map(function(child) {
        return cloneNode(child, true);
      });
      for (var i2 = 1; i2 < children.length; i2++) {
        children[i2].prev = children[i2 - 1];
        children[i2 - 1].next = children[i2];
      }
      return children;
    }
  }
});

// node_modules/domhandler/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/domhandler/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p2 in m)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DomHandler = void 0;
    var domelementtype_1 = require_lib();
    var node_js_1 = require_node2();
    __exportStar(require_node2(), exports);
    var defaultOpts = {
      withStartIndices: false,
      withEndIndices: false,
      xmlMode: false
    };
    var DomHandler = (
      /** @class */
      function() {
        function DomHandler2(callback, options, elementCB) {
          this.dom = [];
          this.root = new node_js_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
          if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts;
          }
          if (typeof callback === "object") {
            options = callback;
            callback = void 0;
          }
          this.callback = callback !== null && callback !== void 0 ? callback : null;
          this.options = options !== null && options !== void 0 ? options : defaultOpts;
          this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
        }
        DomHandler2.prototype.onparserinit = function(parser) {
          this.parser = parser;
        };
        DomHandler2.prototype.onreset = function() {
          this.dom = [];
          this.root = new node_js_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
        };
        DomHandler2.prototype.onend = function() {
          if (this.done)
            return;
          this.done = true;
          this.parser = null;
          this.handleCallback(null);
        };
        DomHandler2.prototype.onerror = function(error) {
          this.handleCallback(error);
        };
        DomHandler2.prototype.onclosetag = function() {
          this.lastNode = null;
          var elem = this.tagStack.pop();
          if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
          }
          if (this.elementCB)
            this.elementCB(elem);
        };
        DomHandler2.prototype.onopentag = function(name, attribs) {
          var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : void 0;
          var element = new node_js_1.Element(name, attribs, void 0, type);
          this.addNode(element);
          this.tagStack.push(element);
        };
        DomHandler2.prototype.ontext = function(data) {
          var lastNode = this.lastNode;
          if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
            lastNode.data += data;
            if (this.options.withEndIndices) {
              lastNode.endIndex = this.parser.endIndex;
            }
          } else {
            var node = new node_js_1.Text(data);
            this.addNode(node);
            this.lastNode = node;
          }
        };
        DomHandler2.prototype.oncomment = function(data) {
          if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
            this.lastNode.data += data;
            return;
          }
          var node = new node_js_1.Comment(data);
          this.addNode(node);
          this.lastNode = node;
        };
        DomHandler2.prototype.oncommentend = function() {
          this.lastNode = null;
        };
        DomHandler2.prototype.oncdatastart = function() {
          var text = new node_js_1.Text("");
          var node = new node_js_1.CDATA([text]);
          this.addNode(node);
          text.parent = node;
          this.lastNode = text;
        };
        DomHandler2.prototype.oncdataend = function() {
          this.lastNode = null;
        };
        DomHandler2.prototype.onprocessinginstruction = function(name, data) {
          var node = new node_js_1.ProcessingInstruction(name, data);
          this.addNode(node);
        };
        DomHandler2.prototype.handleCallback = function(error) {
          if (typeof this.callback === "function") {
            this.callback(error, this.dom);
          } else if (error) {
            throw error;
          }
        };
        DomHandler2.prototype.addNode = function(node) {
          var parent = this.tagStack[this.tagStack.length - 1];
          var previousSibling = parent.children[parent.children.length - 1];
          if (this.options.withStartIndices) {
            node.startIndex = this.parser.startIndex;
          }
          if (this.options.withEndIndices) {
            node.endIndex = this.parser.endIndex;
          }
          parent.children.push(node);
          if (previousSibling) {
            node.prev = previousSibling;
            previousSibling.next = node;
          }
          node.parent = parent;
          this.lastNode = null;
        };
        return DomHandler2;
      }()
    );
    exports.DomHandler = DomHandler;
    exports.default = DomHandler;
  }
});

// node_modules/entities/lib/generated/decode-data-html.js
var require_decode_data_html = __commonJS({
  "node_modules/entities/lib/generated/decode-data-html.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new Uint16Array(
      // prettier-ignore
      'ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'.split("").map(function(c2) {
        return c2.charCodeAt(0);
      })
    );
  }
});

// node_modules/entities/lib/generated/decode-data-xml.js
var require_decode_data_xml = __commonJS({
  "node_modules/entities/lib/generated/decode-data-xml.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new Uint16Array(
      // prettier-ignore
      "Ȁaglq	\x1Bɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map(function(c2) {
        return c2.charCodeAt(0);
      })
    );
  }
});

// node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint = __commonJS({
  "node_modules/entities/lib/decode_codepoint.js"(exports) {
    "use strict";
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.replaceCodePoint = exports.fromCodePoint = void 0;
    var decodeMap = /* @__PURE__ */ new Map([
      [0, 65533],
      // C1 Unicode control character reference replacements
      [128, 8364],
      [130, 8218],
      [131, 402],
      [132, 8222],
      [133, 8230],
      [134, 8224],
      [135, 8225],
      [136, 710],
      [137, 8240],
      [138, 352],
      [139, 8249],
      [140, 338],
      [142, 381],
      [145, 8216],
      [146, 8217],
      [147, 8220],
      [148, 8221],
      [149, 8226],
      [150, 8211],
      [151, 8212],
      [152, 732],
      [153, 8482],
      [154, 353],
      [155, 8250],
      [156, 339],
      [158, 382],
      [159, 376]
    ]);
    exports.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
    (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
      var output = "";
      if (codePoint > 65535) {
        codePoint -= 65536;
        output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      output += String.fromCharCode(codePoint);
      return output;
    };
    function replaceCodePoint(codePoint) {
      var _a2;
      if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
        return 65533;
      }
      return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
    }
    exports.replaceCodePoint = replaceCodePoint;
    function decodeCodePoint(codePoint) {
      return (0, exports.fromCodePoint)(replaceCodePoint(codePoint));
    }
    exports.default = decodeCodePoint;
  }
});

// node_modules/entities/lib/decode.js
var require_decode = __commonJS({
  "node_modules/entities/lib/decode.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeXML = exports.decodeHTMLStrict = exports.decodeHTMLAttribute = exports.decodeHTML = exports.determineBranch = exports.EntityDecoder = exports.DecodingMode = exports.BinTrieFlags = exports.fromCodePoint = exports.replaceCodePoint = exports.decodeCodePoint = exports.xmlDecodeTree = exports.htmlDecodeTree = void 0;
    var decode_data_html_js_1 = __importDefault(require_decode_data_html());
    exports.htmlDecodeTree = decode_data_html_js_1.default;
    var decode_data_xml_js_1 = __importDefault(require_decode_data_xml());
    exports.xmlDecodeTree = decode_data_xml_js_1.default;
    var decode_codepoint_js_1 = __importStar(require_decode_codepoint());
    exports.decodeCodePoint = decode_codepoint_js_1.default;
    var decode_codepoint_js_2 = require_decode_codepoint();
    Object.defineProperty(exports, "replaceCodePoint", { enumerable: true, get: function() {
      return decode_codepoint_js_2.replaceCodePoint;
    } });
    Object.defineProperty(exports, "fromCodePoint", { enumerable: true, get: function() {
      return decode_codepoint_js_2.fromCodePoint;
    } });
    var CharCodes;
    (function(CharCodes2) {
      CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
      CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
      CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
      CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
      CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
      CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
      CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
      CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
      CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
      CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
      CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
      CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
    })(CharCodes || (CharCodes = {}));
    var TO_LOWER_BIT = 32;
    var BinTrieFlags;
    (function(BinTrieFlags2) {
      BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
      BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
      BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
    })(BinTrieFlags = exports.BinTrieFlags || (exports.BinTrieFlags = {}));
    function isNumber(code) {
      return code >= CharCodes.ZERO && code <= CharCodes.NINE;
    }
    function isHexadecimalCharacter(code) {
      return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
    }
    function isAsciiAlphaNumeric(code) {
      return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
    }
    function isEntityInAttributeInvalidEnd(code) {
      return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
    }
    var EntityDecoderState;
    (function(EntityDecoderState2) {
      EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
      EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
      EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
      EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
      EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
    })(EntityDecoderState || (EntityDecoderState = {}));
    var DecodingMode;
    (function(DecodingMode2) {
      DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
      DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
      DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
    })(DecodingMode = exports.DecodingMode || (exports.DecodingMode = {}));
    var EntityDecoder = (
      /** @class */
      function() {
        function EntityDecoder2(decodeTree, emitCodePoint, errors) {
          this.decodeTree = decodeTree;
          this.emitCodePoint = emitCodePoint;
          this.errors = errors;
          this.state = EntityDecoderState.EntityStart;
          this.consumed = 1;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.decodeMode = DecodingMode.Strict;
        }
        EntityDecoder2.prototype.startEntity = function(decodeMode) {
          this.decodeMode = decodeMode;
          this.state = EntityDecoderState.EntityStart;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.consumed = 1;
        };
        EntityDecoder2.prototype.write = function(str, offset) {
          switch (this.state) {
            case EntityDecoderState.EntityStart: {
              if (str.charCodeAt(offset) === CharCodes.NUM) {
                this.state = EntityDecoderState.NumericStart;
                this.consumed += 1;
                return this.stateNumericStart(str, offset + 1);
              }
              this.state = EntityDecoderState.NamedEntity;
              return this.stateNamedEntity(str, offset);
            }
            case EntityDecoderState.NumericStart: {
              return this.stateNumericStart(str, offset);
            }
            case EntityDecoderState.NumericDecimal: {
              return this.stateNumericDecimal(str, offset);
            }
            case EntityDecoderState.NumericHex: {
              return this.stateNumericHex(str, offset);
            }
            case EntityDecoderState.NamedEntity: {
              return this.stateNamedEntity(str, offset);
            }
          }
        };
        EntityDecoder2.prototype.stateNumericStart = function(str, offset) {
          if (offset >= str.length) {
            return -1;
          }
          if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
            this.state = EntityDecoderState.NumericHex;
            this.consumed += 1;
            return this.stateNumericHex(str, offset + 1);
          }
          this.state = EntityDecoderState.NumericDecimal;
          return this.stateNumericDecimal(str, offset);
        };
        EntityDecoder2.prototype.addToNumericResult = function(str, start, end, base) {
          if (start !== end) {
            var digitCount = end - start;
            this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
            this.consumed += digitCount;
          }
        };
        EntityDecoder2.prototype.stateNumericHex = function(str, offset) {
          var startIdx = offset;
          while (offset < str.length) {
            var char = str.charCodeAt(offset);
            if (isNumber(char) || isHexadecimalCharacter(char)) {
              offset += 1;
            } else {
              this.addToNumericResult(str, startIdx, offset, 16);
              return this.emitNumericEntity(char, 3);
            }
          }
          this.addToNumericResult(str, startIdx, offset, 16);
          return -1;
        };
        EntityDecoder2.prototype.stateNumericDecimal = function(str, offset) {
          var startIdx = offset;
          while (offset < str.length) {
            var char = str.charCodeAt(offset);
            if (isNumber(char)) {
              offset += 1;
            } else {
              this.addToNumericResult(str, startIdx, offset, 10);
              return this.emitNumericEntity(char, 2);
            }
          }
          this.addToNumericResult(str, startIdx, offset, 10);
          return -1;
        };
        EntityDecoder2.prototype.emitNumericEntity = function(lastCp, expectedLength) {
          var _a;
          if (this.consumed <= expectedLength) {
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
          }
          if (lastCp === CharCodes.SEMI) {
            this.consumed += 1;
          } else if (this.decodeMode === DecodingMode.Strict) {
            return 0;
          }
          this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
          if (this.errors) {
            if (lastCp !== CharCodes.SEMI) {
              this.errors.missingSemicolonAfterCharacterReference();
            }
            this.errors.validateNumericCharacterReference(this.result);
          }
          return this.consumed;
        };
        EntityDecoder2.prototype.stateNamedEntity = function(str, offset) {
          var decodeTree = this.decodeTree;
          var current = decodeTree[this.treeIndex];
          var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
          for (; offset < str.length; offset++, this.excess++) {
            var char = str.charCodeAt(offset);
            this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
            if (this.treeIndex < 0) {
              return this.result === 0 || // If we are parsing an attribute
              this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
              (valueLength === 0 || // And there should be no invalid characters.
              isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
            }
            current = decodeTree[this.treeIndex];
            valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
            if (valueLength !== 0) {
              if (char === CharCodes.SEMI) {
                return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
              }
              if (this.decodeMode !== DecodingMode.Strict) {
                this.result = this.treeIndex;
                this.consumed += this.excess;
                this.excess = 0;
              }
            }
          }
          return -1;
        };
        EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function() {
          var _a;
          var _b = this, result = _b.result, decodeTree = _b.decodeTree;
          var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
          this.emitNamedEntityData(result, valueLength, this.consumed);
          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
          return this.consumed;
        };
        EntityDecoder2.prototype.emitNamedEntityData = function(result, valueLength, consumed) {
          var decodeTree = this.decodeTree;
          this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
          if (valueLength === 3) {
            this.emitCodePoint(decodeTree[result + 2], consumed);
          }
          return consumed;
        };
        EntityDecoder2.prototype.end = function() {
          var _a;
          switch (this.state) {
            case EntityDecoderState.NamedEntity: {
              return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
            }
            case EntityDecoderState.NumericDecimal: {
              return this.emitNumericEntity(0, 2);
            }
            case EntityDecoderState.NumericHex: {
              return this.emitNumericEntity(0, 3);
            }
            case EntityDecoderState.NumericStart: {
              (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
              return 0;
            }
            case EntityDecoderState.EntityStart: {
              return 0;
            }
          }
        };
        return EntityDecoder2;
      }()
    );
    exports.EntityDecoder = EntityDecoder;
    function getDecoder(decodeTree) {
      var ret = "";
      var decoder = new EntityDecoder(decodeTree, function(str) {
        return ret += (0, decode_codepoint_js_1.fromCodePoint)(str);
      });
      return function decodeWithTrie(str, decodeMode) {
        var lastIndex = 0;
        var offset = 0;
        while ((offset = str.indexOf("&", offset)) >= 0) {
          ret += str.slice(lastIndex, offset);
          decoder.startEntity(decodeMode);
          var len = decoder.write(
            str,
            // Skip the "&"
            offset + 1
          );
          if (len < 0) {
            lastIndex = offset + decoder.end();
            break;
          }
          lastIndex = offset + len;
          offset = len === 0 ? lastIndex + 1 : lastIndex;
        }
        var result = ret + str.slice(lastIndex);
        ret = "";
        return result;
      };
    }
    function determineBranch(decodeTree, current, nodeIdx, char) {
      var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
      var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
      if (branchCount === 0) {
        return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
      }
      if (jumpOffset) {
        var value = char - jumpOffset;
        return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
      }
      var lo2 = nodeIdx;
      var hi3 = lo2 + branchCount - 1;
      while (lo2 <= hi3) {
        var mid = lo2 + hi3 >>> 1;
        var midVal = decodeTree[mid];
        if (midVal < char) {
          lo2 = mid + 1;
        } else if (midVal > char) {
          hi3 = mid - 1;
        } else {
          return decodeTree[mid + branchCount];
        }
      }
      return -1;
    }
    exports.determineBranch = determineBranch;
    var htmlDecoder = getDecoder(decode_data_html_js_1.default);
    var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
    function decodeHTML(str, mode) {
      if (mode === void 0) {
        mode = DecodingMode.Legacy;
      }
      return htmlDecoder(str, mode);
    }
    exports.decodeHTML = decodeHTML;
    function decodeHTMLAttribute(str) {
      return htmlDecoder(str, DecodingMode.Attribute);
    }
    exports.decodeHTMLAttribute = decodeHTMLAttribute;
    function decodeHTMLStrict(str) {
      return htmlDecoder(str, DecodingMode.Strict);
    }
    exports.decodeHTMLStrict = decodeHTMLStrict;
    function decodeXML(str) {
      return xmlDecoder(str, DecodingMode.Strict);
    }
    exports.decodeXML = decodeXML;
  }
});

// node_modules/entities/lib/generated/encode-html.js
var require_encode_html = __commonJS({
  "node_modules/entities/lib/generated/encode-html.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function restoreDiff(arr) {
      for (var i2 = 1; i2 < arr.length; i2++) {
        arr[i2][0] += arr[i2 - 1][0] + 1;
      }
      return arr;
    }
    exports.default = new Map(restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));
  }
});

// node_modules/entities/lib/escape.js
var require_escape = __commonJS({
  "node_modules/entities/lib/escape.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.getCodePoint = exports.xmlReplacer = void 0;
    exports.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
    var xmlCodeMap = /* @__PURE__ */ new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [39, "&apos;"],
      [60, "&lt;"],
      [62, "&gt;"]
    ]);
    exports.getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.prototype.codePointAt != null ? function(str, index) {
      return str.codePointAt(index);
    } : (
      // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      function(c2, index) {
        return (c2.charCodeAt(index) & 64512) === 55296 ? (c2.charCodeAt(index) - 55296) * 1024 + c2.charCodeAt(index + 1) - 56320 + 65536 : c2.charCodeAt(index);
      }
    );
    function encodeXML(str) {
      var ret = "";
      var lastIdx = 0;
      var match;
      while ((match = exports.xmlReplacer.exec(str)) !== null) {
        var i2 = match.index;
        var char = str.charCodeAt(i2);
        var next = xmlCodeMap.get(char);
        if (next !== void 0) {
          ret += str.substring(lastIdx, i2) + next;
          lastIdx = i2 + 1;
        } else {
          ret += "".concat(str.substring(lastIdx, i2), "&#x").concat((0, exports.getCodePoint)(str, i2).toString(16), ";");
          lastIdx = exports.xmlReplacer.lastIndex += Number((char & 64512) === 55296);
        }
      }
      return ret + str.substr(lastIdx);
    }
    exports.encodeXML = encodeXML;
    exports.escape = encodeXML;
    function getEscaper(regex, map) {
      return function escape(data) {
        var match;
        var lastIdx = 0;
        var result = "";
        while (match = regex.exec(data)) {
          if (lastIdx !== match.index) {
            result += data.substring(lastIdx, match.index);
          }
          result += map.get(match[0].charCodeAt(0));
          lastIdx = match.index + 1;
        }
        return result + data.substring(lastIdx);
      };
    }
    exports.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
    exports.escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [160, "&nbsp;"]
    ]));
    exports.escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
      [38, "&amp;"],
      [60, "&lt;"],
      [62, "&gt;"],
      [160, "&nbsp;"]
    ]));
  }
});

// node_modules/entities/lib/encode.js
var require_encode = __commonJS({
  "node_modules/entities/lib/encode.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeNonAsciiHTML = exports.encodeHTML = void 0;
    var encode_html_js_1 = __importDefault(require_encode_html());
    var escape_js_1 = require_escape();
    var htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
    function encodeHTML(data) {
      return encodeHTMLTrieRe(htmlReplacer, data);
    }
    exports.encodeHTML = encodeHTML;
    function encodeNonAsciiHTML(data) {
      return encodeHTMLTrieRe(escape_js_1.xmlReplacer, data);
    }
    exports.encodeNonAsciiHTML = encodeNonAsciiHTML;
    function encodeHTMLTrieRe(regExp, str) {
      var ret = "";
      var lastIdx = 0;
      var match;
      while ((match = regExp.exec(str)) !== null) {
        var i2 = match.index;
        ret += str.substring(lastIdx, i2);
        var char = str.charCodeAt(i2);
        var next = encode_html_js_1.default.get(char);
        if (typeof next === "object") {
          if (i2 + 1 < str.length) {
            var nextChar = str.charCodeAt(i2 + 1);
            var value = typeof next.n === "number" ? next.n === nextChar ? next.o : void 0 : next.n.get(nextChar);
            if (value !== void 0) {
              ret += value;
              lastIdx = regExp.lastIndex += 1;
              continue;
            }
          }
          next = next.v;
        }
        if (next !== void 0) {
          ret += next;
          lastIdx = i2 + 1;
        } else {
          var cp = (0, escape_js_1.getCodePoint)(str, i2);
          ret += "&#x".concat(cp.toString(16), ";");
          lastIdx = regExp.lastIndex += Number(cp !== char);
        }
      }
      return ret + str.substr(lastIdx);
    }
  }
});

// node_modules/entities/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/entities/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLAttribute = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.DecodingMode = exports.EntityDecoder = exports.encodeHTML5 = exports.encodeHTML4 = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = exports.EncodingMode = exports.EntityLevel = void 0;
    var decode_js_1 = require_decode();
    var encode_js_1 = require_encode();
    var escape_js_1 = require_escape();
    var EntityLevel;
    (function(EntityLevel2) {
      EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
      EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
    })(EntityLevel = exports.EntityLevel || (exports.EntityLevel = {}));
    var EncodingMode;
    (function(EncodingMode2) {
      EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
      EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
      EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
      EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
      EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
    })(EncodingMode = exports.EncodingMode || (exports.EncodingMode = {}));
    function decode(data, options) {
      if (options === void 0) {
        options = EntityLevel.XML;
      }
      var level = typeof options === "number" ? options : options.level;
      if (level === EntityLevel.HTML) {
        var mode = typeof options === "object" ? options.mode : void 0;
        return (0, decode_js_1.decodeHTML)(data, mode);
      }
      return (0, decode_js_1.decodeXML)(data);
    }
    exports.decode = decode;
    function decodeStrict(data, options) {
      var _a;
      if (options === void 0) {
        options = EntityLevel.XML;
      }
      var opts = typeof options === "number" ? { level: options } : options;
      (_a = opts.mode) !== null && _a !== void 0 ? _a : opts.mode = decode_js_1.DecodingMode.Strict;
      return decode(data, opts);
    }
    exports.decodeStrict = decodeStrict;
    function encode(data, options) {
      if (options === void 0) {
        options = EntityLevel.XML;
      }
      var opts = typeof options === "number" ? { level: options } : options;
      if (opts.mode === EncodingMode.UTF8)
        return (0, escape_js_1.escapeUTF8)(data);
      if (opts.mode === EncodingMode.Attribute)
        return (0, escape_js_1.escapeAttribute)(data);
      if (opts.mode === EncodingMode.Text)
        return (0, escape_js_1.escapeText)(data);
      if (opts.level === EntityLevel.HTML) {
        if (opts.mode === EncodingMode.ASCII) {
          return (0, encode_js_1.encodeNonAsciiHTML)(data);
        }
        return (0, encode_js_1.encodeHTML)(data);
      }
      return (0, escape_js_1.encodeXML)(data);
    }
    exports.encode = encode;
    var escape_js_2 = require_escape();
    Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function() {
      return escape_js_2.encodeXML;
    } });
    Object.defineProperty(exports, "escape", { enumerable: true, get: function() {
      return escape_js_2.escape;
    } });
    Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function() {
      return escape_js_2.escapeUTF8;
    } });
    Object.defineProperty(exports, "escapeAttribute", { enumerable: true, get: function() {
      return escape_js_2.escapeAttribute;
    } });
    Object.defineProperty(exports, "escapeText", { enumerable: true, get: function() {
      return escape_js_2.escapeText;
    } });
    var encode_js_2 = require_encode();
    Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function() {
      return encode_js_2.encodeHTML;
    } });
    Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function() {
      return encode_js_2.encodeNonAsciiHTML;
    } });
    Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function() {
      return encode_js_2.encodeHTML;
    } });
    Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function() {
      return encode_js_2.encodeHTML;
    } });
    var decode_js_2 = require_decode();
    Object.defineProperty(exports, "EntityDecoder", { enumerable: true, get: function() {
      return decode_js_2.EntityDecoder;
    } });
    Object.defineProperty(exports, "DecodingMode", { enumerable: true, get: function() {
      return decode_js_2.DecodingMode;
    } });
    Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function() {
      return decode_js_2.decodeXML;
    } });
    Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function() {
      return decode_js_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeHTMLAttribute", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLAttribute;
    } });
    Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function() {
      return decode_js_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function() {
      return decode_js_2.decodeHTML;
    } });
    Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function() {
      return decode_js_2.decodeXML;
    } });
  }
});

// node_modules/dom-serializer/lib/foreignNames.js
var require_foreignNames = __commonJS({
  "node_modules/dom-serializer/lib/foreignNames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.attributeNames = exports.elementNames = void 0;
    exports.elementNames = new Map([
      "altGlyph",
      "altGlyphDef",
      "altGlyphItem",
      "animateColor",
      "animateMotion",
      "animateTransform",
      "clipPath",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feDropShadow",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence",
      "foreignObject",
      "glyphRef",
      "linearGradient",
      "radialGradient",
      "textPath"
    ].map(function(val) {
      return [val.toLowerCase(), val];
    }));
    exports.attributeNames = new Map([
      "definitionURL",
      "attributeName",
      "attributeType",
      "baseFrequency",
      "baseProfile",
      "calcMode",
      "clipPathUnits",
      "diffuseConstant",
      "edgeMode",
      "filterUnits",
      "glyphRef",
      "gradientTransform",
      "gradientUnits",
      "kernelMatrix",
      "kernelUnitLength",
      "keyPoints",
      "keySplines",
      "keyTimes",
      "lengthAdjust",
      "limitingConeAngle",
      "markerHeight",
      "markerUnits",
      "markerWidth",
      "maskContentUnits",
      "maskUnits",
      "numOctaves",
      "pathLength",
      "patternContentUnits",
      "patternTransform",
      "patternUnits",
      "pointsAtX",
      "pointsAtY",
      "pointsAtZ",
      "preserveAlpha",
      "preserveAspectRatio",
      "primitiveUnits",
      "refX",
      "refY",
      "repeatCount",
      "repeatDur",
      "requiredExtensions",
      "requiredFeatures",
      "specularConstant",
      "specularExponent",
      "spreadMethod",
      "startOffset",
      "stdDeviation",
      "stitchTiles",
      "surfaceScale",
      "systemLanguage",
      "tableValues",
      "targetX",
      "targetY",
      "textLength",
      "viewBox",
      "viewTarget",
      "xChannelSelector",
      "yChannelSelector",
      "zoomAndPan"
    ].map(function(val) {
      return [val.toLowerCase(), val];
    }));
  }
});

// node_modules/dom-serializer/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/dom-serializer/lib/index.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.render = void 0;
    var ElementType2 = __importStar(require_lib());
    var entities_1 = require_lib3();
    var foreignNames_js_1 = require_foreignNames();
    var unencodedElements = /* @__PURE__ */ new Set([
      "style",
      "script",
      "xmp",
      "iframe",
      "noembed",
      "noframes",
      "plaintext",
      "noscript"
    ]);
    function replaceQuotes(value) {
      return value.replace(/"/g, "&quot;");
    }
    function formatAttributes(attributes, opts) {
      var _a;
      if (!attributes)
        return;
      var encode = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? entities_1.encodeXML : entities_1.escapeAttribute;
      return Object.keys(attributes).map(function(key) {
        var _a2, _b;
        var value = (_a2 = attributes[key]) !== null && _a2 !== void 0 ? _a2 : "";
        if (opts.xmlMode === "foreign") {
          key = (_b = foreignNames_js_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
        }
        if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
          return key;
        }
        return "".concat(key, '="').concat(encode(value), '"');
      }).join(" ");
    }
    var singleTag = /* @__PURE__ */ new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    function render(node, options) {
      if (options === void 0) {
        options = {};
      }
      var nodes = "length" in node ? node : [node];
      var output = "";
      for (var i2 = 0; i2 < nodes.length; i2++) {
        output += renderNode(nodes[i2], options);
      }
      return output;
    }
    exports.render = render;
    exports.default = render;
    function renderNode(node, options) {
      switch (node.type) {
        case ElementType2.Root:
          return render(node.children, options);
        case ElementType2.Doctype:
        case ElementType2.Directive:
          return renderDirective(node);
        case ElementType2.Comment:
          return renderComment(node);
        case ElementType2.CDATA:
          return renderCdata(node);
        case ElementType2.Script:
        case ElementType2.Style:
        case ElementType2.Tag:
          return renderTag(node, options);
        case ElementType2.Text:
          return renderText(node, options);
      }
    }
    var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignObject",
      "desc",
      "title"
    ]);
    var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
    function renderTag(elem, opts) {
      var _a;
      if (opts.xmlMode === "foreign") {
        elem.name = (_a = foreignNames_js_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
        if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
          opts = __assign(__assign({}, opts), { xmlMode: false });
        }
      }
      if (!opts.xmlMode && foreignElements.has(elem.name)) {
        opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
      }
      var tag = "<".concat(elem.name);
      var attribs = formatAttributes(elem.attribs, opts);
      if (attribs) {
        tag += " ".concat(attribs);
      }
      if (elem.children.length === 0 && (opts.xmlMode ? (
        // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
        opts.selfClosingTags !== false
      ) : (
        // User explicitly asked for self-closing tags, even in HTML mode
        opts.selfClosingTags && singleTag.has(elem.name)
      ))) {
        if (!opts.xmlMode)
          tag += " ";
        tag += "/>";
      } else {
        tag += ">";
        if (elem.children.length > 0) {
          tag += render(elem.children, opts);
        }
        if (opts.xmlMode || !singleTag.has(elem.name)) {
          tag += "</".concat(elem.name, ">");
        }
      }
      return tag;
    }
    function renderDirective(elem) {
      return "<".concat(elem.data, ">");
    }
    function renderText(elem, opts) {
      var _a;
      var data = elem.data || "";
      if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
        data = opts.xmlMode || opts.encodeEntities !== "utf8" ? (0, entities_1.encodeXML)(data) : (0, entities_1.escapeText)(data);
      }
      return data;
    }
    function renderCdata(elem) {
      return "<![CDATA[".concat(elem.children[0].data, "]]>");
    }
    function renderComment(elem) {
      return "<!--".concat(elem.data, "-->");
    }
  }
});

// node_modules/domutils/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/domutils/lib/stringify.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.innerText = exports.textContent = exports.getText = exports.getInnerHTML = exports.getOuterHTML = void 0;
    var domhandler_1 = require_lib2();
    var dom_serializer_1 = __importDefault(require_lib4());
    var domelementtype_1 = require_lib();
    function getOuterHTML(node, options) {
      return (0, dom_serializer_1.default)(node, options);
    }
    exports.getOuterHTML = getOuterHTML;
    function getInnerHTML(node, options) {
      return (0, domhandler_1.hasChildren)(node) ? node.children.map(function(node2) {
        return getOuterHTML(node2, options);
      }).join("") : "";
    }
    exports.getInnerHTML = getInnerHTML;
    function getText(node) {
      if (Array.isArray(node))
        return node.map(getText).join("");
      if ((0, domhandler_1.isTag)(node))
        return node.name === "br" ? "\n" : getText(node.children);
      if ((0, domhandler_1.isCDATA)(node))
        return getText(node.children);
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports.getText = getText;
    function textContent(node) {
      if (Array.isArray(node))
        return node.map(textContent).join("");
      if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
        return textContent(node.children);
      }
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports.textContent = textContent;
    function innerText(node) {
      if (Array.isArray(node))
        return node.map(innerText).join("");
      if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
        return innerText(node.children);
      }
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports.innerText = innerText;
  }
});

// node_modules/domutils/lib/traversal.js
var require_traversal = __commonJS({
  "node_modules/domutils/lib/traversal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prevElementSibling = exports.nextElementSibling = exports.getName = exports.hasAttrib = exports.getAttributeValue = exports.getSiblings = exports.getParent = exports.getChildren = void 0;
    var domhandler_1 = require_lib2();
    function getChildren(elem) {
      return (0, domhandler_1.hasChildren)(elem) ? elem.children : [];
    }
    exports.getChildren = getChildren;
    function getParent(elem) {
      return elem.parent || null;
    }
    exports.getParent = getParent;
    function getSiblings(elem) {
      var _a, _b;
      var parent = getParent(elem);
      if (parent != null)
        return getChildren(parent);
      var siblings = [elem];
      var prev = elem.prev, next = elem.next;
      while (prev != null) {
        siblings.unshift(prev);
        _a = prev, prev = _a.prev;
      }
      while (next != null) {
        siblings.push(next);
        _b = next, next = _b.next;
      }
      return siblings;
    }
    exports.getSiblings = getSiblings;
    function getAttributeValue(elem, name) {
      var _a;
      return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
    }
    exports.getAttributeValue = getAttributeValue;
    function hasAttrib(elem, name) {
      return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
    }
    exports.hasAttrib = hasAttrib;
    function getName(elem) {
      return elem.name;
    }
    exports.getName = getName;
    function nextElementSibling(elem) {
      var _a;
      var next = elem.next;
      while (next !== null && !(0, domhandler_1.isTag)(next))
        _a = next, next = _a.next;
      return next;
    }
    exports.nextElementSibling = nextElementSibling;
    function prevElementSibling(elem) {
      var _a;
      var prev = elem.prev;
      while (prev !== null && !(0, domhandler_1.isTag)(prev))
        _a = prev, prev = _a.prev;
      return prev;
    }
    exports.prevElementSibling = prevElementSibling;
  }
});

// node_modules/domutils/lib/manipulation.js
var require_manipulation = __commonJS({
  "node_modules/domutils/lib/manipulation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prepend = exports.prependChild = exports.append = exports.appendChild = exports.replaceElement = exports.removeElement = void 0;
    function removeElement(elem) {
      if (elem.prev)
        elem.prev.next = elem.next;
      if (elem.next)
        elem.next.prev = elem.prev;
      if (elem.parent) {
        var childs = elem.parent.children;
        var childsIndex = childs.lastIndexOf(elem);
        if (childsIndex >= 0) {
          childs.splice(childsIndex, 1);
        }
      }
      elem.next = null;
      elem.prev = null;
      elem.parent = null;
    }
    exports.removeElement = removeElement;
    function replaceElement(elem, replacement) {
      var prev = replacement.prev = elem.prev;
      if (prev) {
        prev.next = replacement;
      }
      var next = replacement.next = elem.next;
      if (next) {
        next.prev = replacement;
      }
      var parent = replacement.parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs[childs.lastIndexOf(elem)] = replacement;
        elem.parent = null;
      }
    }
    exports.replaceElement = replaceElement;
    function appendChild(parent, child) {
      removeElement(child);
      child.next = null;
      child.parent = parent;
      if (parent.children.push(child) > 1) {
        var sibling = parent.children[parent.children.length - 2];
        sibling.next = child;
        child.prev = sibling;
      } else {
        child.prev = null;
      }
    }
    exports.appendChild = appendChild;
    function append(elem, next) {
      removeElement(next);
      var parent = elem.parent;
      var currNext = elem.next;
      next.next = currNext;
      next.prev = elem;
      elem.next = next;
      next.parent = parent;
      if (currNext) {
        currNext.prev = next;
        if (parent) {
          var childs = parent.children;
          childs.splice(childs.lastIndexOf(currNext), 0, next);
        }
      } else if (parent) {
        parent.children.push(next);
      }
    }
    exports.append = append;
    function prependChild(parent, child) {
      removeElement(child);
      child.parent = parent;
      child.prev = null;
      if (parent.children.unshift(child) !== 1) {
        var sibling = parent.children[1];
        sibling.prev = child;
        child.next = sibling;
      } else {
        child.next = null;
      }
    }
    exports.prependChild = prependChild;
    function prepend(elem, prev) {
      removeElement(prev);
      var parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs.splice(childs.indexOf(elem), 0, prev);
      }
      if (elem.prev) {
        elem.prev.next = prev;
      }
      prev.parent = parent;
      prev.prev = elem.prev;
      prev.next = elem;
      elem.prev = prev;
    }
    exports.prepend = prepend;
  }
});

// node_modules/domutils/lib/querying.js
var require_querying = __commonJS({
  "node_modules/domutils/lib/querying.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findAll = exports.existsOne = exports.findOne = exports.findOneChild = exports.find = exports.filter = void 0;
    var domhandler_1 = require_lib2();
    function filter(test, node, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return find(test, Array.isArray(node) ? node : [node], recurse, limit);
    }
    exports.filter = filter;
    function find(test, nodes, recurse, limit) {
      var result = [];
      var nodeStack = [nodes];
      var indexStack = [0];
      for (; ; ) {
        if (indexStack[0] >= nodeStack[0].length) {
          if (indexStack.length === 1) {
            return result;
          }
          nodeStack.shift();
          indexStack.shift();
          continue;
        }
        var elem = nodeStack[0][indexStack[0]++];
        if (test(elem)) {
          result.push(elem);
          if (--limit <= 0)
            return result;
        }
        if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
          indexStack.unshift(0);
          nodeStack.unshift(elem.children);
        }
      }
    }
    exports.find = find;
    function findOneChild(test, nodes) {
      return nodes.find(test);
    }
    exports.findOneChild = findOneChild;
    function findOne(test, nodes, recurse) {
      if (recurse === void 0) {
        recurse = true;
      }
      var elem = null;
      for (var i2 = 0; i2 < nodes.length && !elem; i2++) {
        var node = nodes[i2];
        if (!(0, domhandler_1.isTag)(node)) {
          continue;
        } else if (test(node)) {
          elem = node;
        } else if (recurse && node.children.length > 0) {
          elem = findOne(test, node.children, true);
        }
      }
      return elem;
    }
    exports.findOne = findOne;
    function existsOne(test, nodes) {
      return nodes.some(function(checked) {
        return (0, domhandler_1.isTag)(checked) && (test(checked) || existsOne(test, checked.children));
      });
    }
    exports.existsOne = existsOne;
    function findAll(test, nodes) {
      var result = [];
      var nodeStack = [nodes];
      var indexStack = [0];
      for (; ; ) {
        if (indexStack[0] >= nodeStack[0].length) {
          if (nodeStack.length === 1) {
            return result;
          }
          nodeStack.shift();
          indexStack.shift();
          continue;
        }
        var elem = nodeStack[0][indexStack[0]++];
        if (!(0, domhandler_1.isTag)(elem))
          continue;
        if (test(elem))
          result.push(elem);
        if (elem.children.length > 0) {
          indexStack.unshift(0);
          nodeStack.unshift(elem.children);
        }
      }
    }
    exports.findAll = findAll;
  }
});

// node_modules/domutils/lib/legacy.js
var require_legacy = __commonJS({
  "node_modules/domutils/lib/legacy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getElementsByTagType = exports.getElementsByTagName = exports.getElementById = exports.getElements = exports.testElement = void 0;
    var domhandler_1 = require_lib2();
    var querying_js_1 = require_querying();
    var Checks = {
      tag_name: function(name) {
        if (typeof name === "function") {
          return function(elem) {
            return (0, domhandler_1.isTag)(elem) && name(elem.name);
          };
        } else if (name === "*") {
          return domhandler_1.isTag;
        }
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && elem.name === name;
        };
      },
      tag_type: function(type) {
        if (typeof type === "function") {
          return function(elem) {
            return type(elem.type);
          };
        }
        return function(elem) {
          return elem.type === type;
        };
      },
      tag_contains: function(data) {
        if (typeof data === "function") {
          return function(elem) {
            return (0, domhandler_1.isText)(elem) && data(elem.data);
          };
        }
        return function(elem) {
          return (0, domhandler_1.isText)(elem) && elem.data === data;
        };
      }
    };
    function getAttribCheck(attrib, value) {
      if (typeof value === "function") {
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
        };
      }
      return function(elem) {
        return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value;
      };
    }
    function combineFuncs(a2, b3) {
      return function(elem) {
        return a2(elem) || b3(elem);
      };
    }
    function compileTest(options) {
      var funcs = Object.keys(options).map(function(key) {
        var value = options[key];
        return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
      });
      return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
    }
    function testElement(options, node) {
      var test = compileTest(options);
      return test ? test(node) : true;
    }
    exports.testElement = testElement;
    function getElements(options, nodes, recurse, limit) {
      if (limit === void 0) {
        limit = Infinity;
      }
      var test = compileTest(options);
      return test ? (0, querying_js_1.filter)(test, nodes, recurse, limit) : [];
    }
    exports.getElements = getElements;
    function getElementById(id, nodes, recurse) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (!Array.isArray(nodes))
        nodes = [nodes];
      return (0, querying_js_1.findOne)(getAttribCheck("id", id), nodes, recurse);
    }
    exports.getElementById = getElementById;
    function getElementsByTagName(tagName, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_js_1.filter)(Checks["tag_name"](tagName), nodes, recurse, limit);
    }
    exports.getElementsByTagName = getElementsByTagName;
    function getElementsByTagType(type, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_js_1.filter)(Checks["tag_type"](type), nodes, recurse, limit);
    }
    exports.getElementsByTagType = getElementsByTagType;
  }
});

// node_modules/domutils/lib/helpers.js
var require_helpers = __commonJS({
  "node_modules/domutils/lib/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uniqueSort = exports.compareDocumentPosition = exports.DocumentPosition = exports.removeSubsets = void 0;
    var domhandler_1 = require_lib2();
    function removeSubsets(nodes) {
      var idx = nodes.length;
      while (--idx >= 0) {
        var node = nodes[idx];
        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
          nodes.splice(idx, 1);
          continue;
        }
        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
          if (nodes.includes(ancestor)) {
            nodes.splice(idx, 1);
            break;
          }
        }
      }
      return nodes;
    }
    exports.removeSubsets = removeSubsets;
    var DocumentPosition;
    (function(DocumentPosition2) {
      DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
      DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
      DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
      DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
      DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
    })(DocumentPosition = exports.DocumentPosition || (exports.DocumentPosition = {}));
    function compareDocumentPosition(nodeA, nodeB) {
      var aParents = [];
      var bParents = [];
      if (nodeA === nodeB) {
        return 0;
      }
      var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
      while (current) {
        aParents.unshift(current);
        current = current.parent;
      }
      current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
      while (current) {
        bParents.unshift(current);
        current = current.parent;
      }
      var maxIdx = Math.min(aParents.length, bParents.length);
      var idx = 0;
      while (idx < maxIdx && aParents[idx] === bParents[idx]) {
        idx++;
      }
      if (idx === 0) {
        return DocumentPosition.DISCONNECTED;
      }
      var sharedParent = aParents[idx - 1];
      var siblings = sharedParent.children;
      var aSibling = aParents[idx];
      var bSibling = bParents[idx];
      if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
          return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
        }
        return DocumentPosition.FOLLOWING;
      }
      if (sharedParent === nodeA) {
        return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
      }
      return DocumentPosition.PRECEDING;
    }
    exports.compareDocumentPosition = compareDocumentPosition;
    function uniqueSort(nodes) {
      nodes = nodes.filter(function(node, i2, arr) {
        return !arr.includes(node, i2 + 1);
      });
      nodes.sort(function(a2, b3) {
        var relative = compareDocumentPosition(a2, b3);
        if (relative & DocumentPosition.PRECEDING) {
          return -1;
        } else if (relative & DocumentPosition.FOLLOWING) {
          return 1;
        }
        return 0;
      });
      return nodes;
    }
    exports.uniqueSort = uniqueSort;
  }
});

// node_modules/domutils/lib/feeds.js
var require_feeds = __commonJS({
  "node_modules/domutils/lib/feeds.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFeed = void 0;
    var stringify_js_1 = require_stringify();
    var legacy_js_1 = require_legacy();
    function getFeed(doc) {
      var feedRoot = getOneElement(isValidFeed, doc);
      return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
    }
    exports.getFeed = getFeed;
    function getAtomFeed(feedRoot) {
      var _a;
      var childs = feedRoot.children;
      var feed = {
        type: "atom",
        items: (0, legacy_js_1.getElementsByTagName)("entry", childs).map(function(item) {
          var _a2;
          var children = item.children;
          var entry = { media: getMediaElements(children) };
          addConditionally(entry, "id", "id", children);
          addConditionally(entry, "title", "title", children);
          var href2 = (_a2 = getOneElement("link", children)) === null || _a2 === void 0 ? void 0 : _a2.attribs["href"];
          if (href2) {
            entry.link = href2;
          }
          var description = fetch2("summary", children) || fetch2("content", children);
          if (description) {
            entry.description = description;
          }
          var pubDate = fetch2("updated", children);
          if (pubDate) {
            entry.pubDate = new Date(pubDate);
          }
          return entry;
        })
      };
      addConditionally(feed, "id", "id", childs);
      addConditionally(feed, "title", "title", childs);
      var href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
      if (href) {
        feed.link = href;
      }
      addConditionally(feed, "description", "subtitle", childs);
      var updated = fetch2("updated", childs);
      if (updated) {
        feed.updated = new Date(updated);
      }
      addConditionally(feed, "author", "email", childs, true);
      return feed;
    }
    function getRssFeed(feedRoot) {
      var _a, _b;
      var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
      var feed = {
        type: feedRoot.name.substr(0, 3),
        id: "",
        items: (0, legacy_js_1.getElementsByTagName)("item", feedRoot.children).map(function(item) {
          var children = item.children;
          var entry = { media: getMediaElements(children) };
          addConditionally(entry, "id", "guid", children);
          addConditionally(entry, "title", "title", children);
          addConditionally(entry, "link", "link", children);
          addConditionally(entry, "description", "description", children);
          var pubDate = fetch2("pubDate", children) || fetch2("dc:date", children);
          if (pubDate)
            entry.pubDate = new Date(pubDate);
          return entry;
        })
      };
      addConditionally(feed, "title", "title", childs);
      addConditionally(feed, "link", "link", childs);
      addConditionally(feed, "description", "description", childs);
      var updated = fetch2("lastBuildDate", childs);
      if (updated) {
        feed.updated = new Date(updated);
      }
      addConditionally(feed, "author", "managingEditor", childs, true);
      return feed;
    }
    var MEDIA_KEYS_STRING = ["url", "type", "lang"];
    var MEDIA_KEYS_INT = [
      "fileSize",
      "bitrate",
      "framerate",
      "samplingrate",
      "channels",
      "duration",
      "height",
      "width"
    ];
    function getMediaElements(where) {
      return (0, legacy_js_1.getElementsByTagName)("media:content", where).map(function(elem) {
        var attribs = elem.attribs;
        var media = {
          medium: attribs["medium"],
          isDefault: !!attribs["isDefault"]
        };
        for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
          var attrib = MEDIA_KEYS_STRING_1[_i];
          if (attribs[attrib]) {
            media[attrib] = attribs[attrib];
          }
        }
        for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {
          var attrib = MEDIA_KEYS_INT_1[_a];
          if (attribs[attrib]) {
            media[attrib] = parseInt(attribs[attrib], 10);
          }
        }
        if (attribs["expression"]) {
          media.expression = attribs["expression"];
        }
        return media;
      });
    }
    function getOneElement(tagName, node) {
      return (0, legacy_js_1.getElementsByTagName)(tagName, node, true, 1)[0];
    }
    function fetch2(tagName, where, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      return (0, stringify_js_1.textContent)((0, legacy_js_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
    }
    function addConditionally(obj, prop, tagName, where, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      var val = fetch2(tagName, where, recurse);
      if (val)
        obj[prop] = val;
    }
    function isValidFeed(value) {
      return value === "rss" || value === "feed" || value === "rdf:RDF";
    }
  }
});

// node_modules/domutils/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/domutils/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p2 in m)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;
    __exportStar(require_stringify(), exports);
    __exportStar(require_traversal(), exports);
    __exportStar(require_manipulation(), exports);
    __exportStar(require_querying(), exports);
    __exportStar(require_legacy(), exports);
    __exportStar(require_helpers(), exports);
    __exportStar(require_feeds(), exports);
    var domhandler_1 = require_lib2();
    Object.defineProperty(exports, "isTag", { enumerable: true, get: function() {
      return domhandler_1.isTag;
    } });
    Object.defineProperty(exports, "isCDATA", { enumerable: true, get: function() {
      return domhandler_1.isCDATA;
    } });
    Object.defineProperty(exports, "isText", { enumerable: true, get: function() {
      return domhandler_1.isText;
    } });
    Object.defineProperty(exports, "isComment", { enumerable: true, get: function() {
      return domhandler_1.isComment;
    } });
    Object.defineProperty(exports, "isDocument", { enumerable: true, get: function() {
      return domhandler_1.isDocument;
    } });
    Object.defineProperty(exports, "hasChildren", { enumerable: true, get: function() {
      return domhandler_1.hasChildren;
    } });
  }
});

// node_modules/boolbase/index.js
var require_boolbase = __commonJS({
  "node_modules/boolbase/index.js"(exports, module) {
    module.exports = {
      trueFunc: function trueFunc() {
        return true;
      },
      falseFunc: function falseFunc() {
        return false;
      }
    };
  }
});

// node_modules/css-what/lib/es/types.js
var SelectorType, IgnoreCaseMode, AttributeAction;
var init_types = __esm({
  "node_modules/css-what/lib/es/types.js"() {
    (function(SelectorType2) {
      SelectorType2["Attribute"] = "attribute";
      SelectorType2["Pseudo"] = "pseudo";
      SelectorType2["PseudoElement"] = "pseudo-element";
      SelectorType2["Tag"] = "tag";
      SelectorType2["Universal"] = "universal";
      SelectorType2["Adjacent"] = "adjacent";
      SelectorType2["Child"] = "child";
      SelectorType2["Descendant"] = "descendant";
      SelectorType2["Parent"] = "parent";
      SelectorType2["Sibling"] = "sibling";
      SelectorType2["ColumnCombinator"] = "column-combinator";
    })(SelectorType || (SelectorType = {}));
    IgnoreCaseMode = {
      Unknown: null,
      QuirksMode: "quirks",
      IgnoreCase: true,
      CaseSensitive: false
    };
    (function(AttributeAction2) {
      AttributeAction2["Any"] = "any";
      AttributeAction2["Element"] = "element";
      AttributeAction2["End"] = "end";
      AttributeAction2["Equals"] = "equals";
      AttributeAction2["Exists"] = "exists";
      AttributeAction2["Hyphen"] = "hyphen";
      AttributeAction2["Not"] = "not";
      AttributeAction2["Start"] = "start";
    })(AttributeAction || (AttributeAction = {}));
  }
});

// node_modules/css-what/lib/es/parse.js
function isTraversal(selector) {
  switch (selector.type) {
    case SelectorType.Adjacent:
    case SelectorType.Child:
    case SelectorType.Descendant:
    case SelectorType.Parent:
    case SelectorType.Sibling:
    case SelectorType.ColumnCombinator:
      return true;
    default:
      return false;
  }
}
function funescape(_3, escaped, escapedWhitespace) {
  const high = parseInt(escaped, 16) - 65536;
  return high !== high || escapedWhitespace ? escaped : high < 0 ? (
    // BMP codepoint
    String.fromCharCode(high + 65536)
  ) : (
    // Supplemental Plane codepoint (surrogate pair)
    String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
  );
}
function unescapeCSS(str) {
  return str.replace(reEscape, funescape);
}
function isQuote(c2) {
  return c2 === 39 || c2 === 34;
}
function isWhitespace(c2) {
  return c2 === 32 || c2 === 9 || c2 === 10 || c2 === 12 || c2 === 13;
}
function parse(selector) {
  const subselects = [];
  const endIndex = parseSelector(subselects, `${selector}`, 0);
  if (endIndex < selector.length) {
    throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);
  }
  return subselects;
}
function parseSelector(subselects, selector, selectorIndex) {
  let tokens = [];
  function getName(offset) {
    const match = selector.slice(selectorIndex + offset).match(reName);
    if (!match) {
      throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);
    }
    const [name] = match;
    selectorIndex += offset + name.length;
    return unescapeCSS(name);
  }
  function stripWhitespace(offset) {
    selectorIndex += offset;
    while (selectorIndex < selector.length && isWhitespace(selector.charCodeAt(selectorIndex))) {
      selectorIndex++;
    }
  }
  function readValueWithParenthesis() {
    selectorIndex += 1;
    const start = selectorIndex;
    let counter = 1;
    for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
      if (selector.charCodeAt(selectorIndex) === 40 && !isEscaped(selectorIndex)) {
        counter++;
      } else if (selector.charCodeAt(selectorIndex) === 41 && !isEscaped(selectorIndex)) {
        counter--;
      }
    }
    if (counter) {
      throw new Error("Parenthesis not matched");
    }
    return unescapeCSS(selector.slice(start, selectorIndex - 1));
  }
  function isEscaped(pos) {
    let slashCount = 0;
    while (selector.charCodeAt(--pos) === 92)
      slashCount++;
    return (slashCount & 1) === 1;
  }
  function ensureNotTraversal() {
    if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {
      throw new Error("Did not expect successive traversals.");
    }
  }
  function addTraversal(type) {
    if (tokens.length > 0 && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens[tokens.length - 1].type = type;
      return;
    }
    ensureNotTraversal();
    tokens.push({ type });
  }
  function addSpecialAttribute(name, action) {
    tokens.push({
      type: SelectorType.Attribute,
      name,
      action,
      value: getName(1),
      namespace: null,
      ignoreCase: "quirks"
    });
  }
  function finalizeSubselector() {
    if (tokens.length && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens.pop();
    }
    if (tokens.length === 0) {
      throw new Error("Empty sub-selector");
    }
    subselects.push(tokens);
  }
  stripWhitespace(0);
  if (selector.length === selectorIndex) {
    return selectorIndex;
  }
  loop:
    while (selectorIndex < selector.length) {
      const firstChar = selector.charCodeAt(selectorIndex);
      switch (firstChar) {
        case 32:
        case 9:
        case 10:
        case 12:
        case 13: {
          if (tokens.length === 0 || tokens[0].type !== SelectorType.Descendant) {
            ensureNotTraversal();
            tokens.push({ type: SelectorType.Descendant });
          }
          stripWhitespace(1);
          break;
        }
        case 62: {
          addTraversal(SelectorType.Child);
          stripWhitespace(1);
          break;
        }
        case 60: {
          addTraversal(SelectorType.Parent);
          stripWhitespace(1);
          break;
        }
        case 126: {
          addTraversal(SelectorType.Sibling);
          stripWhitespace(1);
          break;
        }
        case 43: {
          addTraversal(SelectorType.Adjacent);
          stripWhitespace(1);
          break;
        }
        case 46: {
          addSpecialAttribute("class", AttributeAction.Element);
          break;
        }
        case 35: {
          addSpecialAttribute("id", AttributeAction.Equals);
          break;
        }
        case 91: {
          stripWhitespace(1);
          let name;
          let namespace = null;
          if (selector.charCodeAt(selectorIndex) === 124) {
            name = getName(1);
          } else if (selector.startsWith("*|", selectorIndex)) {
            namespace = "*";
            name = getName(2);
          } else {
            name = getName(0);
            if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 61) {
              namespace = name;
              name = getName(1);
            }
          }
          stripWhitespace(0);
          let action = AttributeAction.Exists;
          const possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));
          if (possibleAction) {
            action = possibleAction;
            if (selector.charCodeAt(selectorIndex + 1) !== 61) {
              throw new Error("Expected `=`");
            }
            stripWhitespace(2);
          } else if (selector.charCodeAt(selectorIndex) === 61) {
            action = AttributeAction.Equals;
            stripWhitespace(1);
          }
          let value = "";
          let ignoreCase = null;
          if (action !== "exists") {
            if (isQuote(selector.charCodeAt(selectorIndex))) {
              const quote = selector.charCodeAt(selectorIndex);
              let sectionEnd = selectorIndex + 1;
              while (sectionEnd < selector.length && (selector.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd))) {
                sectionEnd += 1;
              }
              if (selector.charCodeAt(sectionEnd) !== quote) {
                throw new Error("Attribute value didn't end");
              }
              value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
              selectorIndex = sectionEnd + 1;
            } else {
              const valueStart = selectorIndex;
              while (selectorIndex < selector.length && (!isWhitespace(selector.charCodeAt(selectorIndex)) && selector.charCodeAt(selectorIndex) !== 93 || isEscaped(selectorIndex))) {
                selectorIndex += 1;
              }
              value = unescapeCSS(selector.slice(valueStart, selectorIndex));
            }
            stripWhitespace(0);
            const forceIgnore = selector.charCodeAt(selectorIndex) | 32;
            if (forceIgnore === 115) {
              ignoreCase = false;
              stripWhitespace(1);
            } else if (forceIgnore === 105) {
              ignoreCase = true;
              stripWhitespace(1);
            }
          }
          if (selector.charCodeAt(selectorIndex) !== 93) {
            throw new Error("Attribute selector didn't terminate");
          }
          selectorIndex += 1;
          const attributeSelector = {
            type: SelectorType.Attribute,
            name,
            action,
            value,
            namespace,
            ignoreCase
          };
          tokens.push(attributeSelector);
          break;
        }
        case 58: {
          if (selector.charCodeAt(selectorIndex + 1) === 58) {
            tokens.push({
              type: SelectorType.PseudoElement,
              name: getName(2).toLowerCase(),
              data: selector.charCodeAt(selectorIndex) === 40 ? readValueWithParenthesis() : null
            });
            continue;
          }
          const name = getName(1).toLowerCase();
          let data = null;
          if (selector.charCodeAt(selectorIndex) === 40) {
            if (unpackPseudos.has(name)) {
              if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
                throw new Error(`Pseudo-selector ${name} cannot be quoted`);
              }
              data = [];
              selectorIndex = parseSelector(data, selector, selectorIndex + 1);
              if (selector.charCodeAt(selectorIndex) !== 41) {
                throw new Error(`Missing closing parenthesis in :${name} (${selector})`);
              }
              selectorIndex += 1;
            } else {
              data = readValueWithParenthesis();
              if (stripQuotesFromPseudos.has(name)) {
                const quot = data.charCodeAt(0);
                if (quot === data.charCodeAt(data.length - 1) && isQuote(quot)) {
                  data = data.slice(1, -1);
                }
              }
              data = unescapeCSS(data);
            }
          }
          tokens.push({ type: SelectorType.Pseudo, name, data });
          break;
        }
        case 44: {
          finalizeSubselector();
          tokens = [];
          stripWhitespace(1);
          break;
        }
        default: {
          if (selector.startsWith("/*", selectorIndex)) {
            const endIndex = selector.indexOf("*/", selectorIndex + 2);
            if (endIndex < 0) {
              throw new Error("Comment was not terminated");
            }
            selectorIndex = endIndex + 2;
            if (tokens.length === 0) {
              stripWhitespace(0);
            }
            break;
          }
          let namespace = null;
          let name;
          if (firstChar === 42) {
            selectorIndex += 1;
            name = "*";
          } else if (firstChar === 124) {
            name = "";
            if (selector.charCodeAt(selectorIndex + 1) === 124) {
              addTraversal(SelectorType.ColumnCombinator);
              stripWhitespace(2);
              break;
            }
          } else if (reName.test(selector.slice(selectorIndex))) {
            name = getName(0);
          } else {
            break loop;
          }
          if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 124) {
            namespace = name;
            if (selector.charCodeAt(selectorIndex + 1) === 42) {
              name = "*";
              selectorIndex += 2;
            } else {
              name = getName(1);
            }
          }
          tokens.push(name === "*" ? { type: SelectorType.Universal, namespace } : { type: SelectorType.Tag, name, namespace });
        }
      }
    }
  finalizeSubselector();
  return selectorIndex;
}
var reName, reEscape, actionTypes, unpackPseudos, stripQuotesFromPseudos;
var init_parse = __esm({
  "node_modules/css-what/lib/es/parse.js"() {
    init_types();
    reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
    reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
    actionTypes = /* @__PURE__ */ new Map([
      [126, AttributeAction.Element],
      [94, AttributeAction.Start],
      [36, AttributeAction.End],
      [42, AttributeAction.Any],
      [33, AttributeAction.Not],
      [124, AttributeAction.Hyphen]
    ]);
    unpackPseudos = /* @__PURE__ */ new Set([
      "has",
      "not",
      "matches",
      "is",
      "where",
      "host",
      "host-context"
    ]);
    stripQuotesFromPseudos = /* @__PURE__ */ new Set(["contains", "icontains"]);
  }
});

// node_modules/css-what/lib/es/stringify.js
function stringify(selector) {
  return selector.map((token) => token.map(stringifyToken).join("")).join(", ");
}
function stringifyToken(token, index, arr) {
  switch (token.type) {
    case SelectorType.Child:
      return index === 0 ? "> " : " > ";
    case SelectorType.Parent:
      return index === 0 ? "< " : " < ";
    case SelectorType.Sibling:
      return index === 0 ? "~ " : " ~ ";
    case SelectorType.Adjacent:
      return index === 0 ? "+ " : " + ";
    case SelectorType.Descendant:
      return " ";
    case SelectorType.ColumnCombinator:
      return index === 0 ? "|| " : " || ";
    case SelectorType.Universal:
      return token.namespace === "*" && index + 1 < arr.length && "name" in arr[index + 1] ? "" : `${getNamespace(token.namespace)}*`;
    case SelectorType.Tag:
      return getNamespacedName(token);
    case SelectorType.PseudoElement:
      return `::${escapeName(token.name, charsToEscapeInName)}${token.data === null ? "" : `(${escapeName(token.data, charsToEscapeInPseudoValue)})`}`;
    case SelectorType.Pseudo:
      return `:${escapeName(token.name, charsToEscapeInName)}${token.data === null ? "" : `(${typeof token.data === "string" ? escapeName(token.data, charsToEscapeInPseudoValue) : stringify(token.data)})`}`;
    case SelectorType.Attribute: {
      if (token.name === "id" && token.action === AttributeAction.Equals && token.ignoreCase === "quirks" && !token.namespace) {
        return `#${escapeName(token.value, charsToEscapeInName)}`;
      }
      if (token.name === "class" && token.action === AttributeAction.Element && token.ignoreCase === "quirks" && !token.namespace) {
        return `.${escapeName(token.value, charsToEscapeInName)}`;
      }
      const name = getNamespacedName(token);
      if (token.action === AttributeAction.Exists) {
        return `[${name}]`;
      }
      return `[${name}${getActionValue(token.action)}="${escapeName(token.value, charsToEscapeInAttributeValue)}"${token.ignoreCase === null ? "" : token.ignoreCase ? " i" : " s"}]`;
    }
  }
}
function getActionValue(action) {
  switch (action) {
    case AttributeAction.Equals:
      return "";
    case AttributeAction.Element:
      return "~";
    case AttributeAction.Start:
      return "^";
    case AttributeAction.End:
      return "$";
    case AttributeAction.Any:
      return "*";
    case AttributeAction.Not:
      return "!";
    case AttributeAction.Hyphen:
      return "|";
    case AttributeAction.Exists:
      throw new Error("Shouldn't be here");
  }
}
function getNamespacedName(token) {
  return `${getNamespace(token.namespace)}${escapeName(token.name, charsToEscapeInName)}`;
}
function getNamespace(namespace) {
  return namespace !== null ? `${namespace === "*" ? "*" : escapeName(namespace, charsToEscapeInName)}|` : "";
}
function escapeName(str, charsToEscape) {
  let lastIdx = 0;
  let ret = "";
  for (let i2 = 0; i2 < str.length; i2++) {
    if (charsToEscape.has(str.charCodeAt(i2))) {
      ret += `${str.slice(lastIdx, i2)}\\${str.charAt(i2)}`;
      lastIdx = i2 + 1;
    }
  }
  return ret.length > 0 ? ret + str.slice(lastIdx) : str;
}
var attribValChars, pseudoValChars, charsToEscapeInAttributeValue, charsToEscapeInPseudoValue, charsToEscapeInName;
var init_stringify = __esm({
  "node_modules/css-what/lib/es/stringify.js"() {
    init_types();
    attribValChars = ["\\", '"'];
    pseudoValChars = [...attribValChars, "(", ")"];
    charsToEscapeInAttributeValue = new Set(attribValChars.map((c2) => c2.charCodeAt(0)));
    charsToEscapeInPseudoValue = new Set(pseudoValChars.map((c2) => c2.charCodeAt(0)));
    charsToEscapeInName = new Set([
      ...pseudoValChars,
      "~",
      "^",
      "$",
      "*",
      "+",
      "!",
      "|",
      ":",
      "[",
      "]",
      " ",
      "."
    ].map((c2) => c2.charCodeAt(0)));
  }
});

// node_modules/css-what/lib/es/index.js
var es_exports = {};
__export(es_exports, {
  AttributeAction: () => AttributeAction,
  IgnoreCaseMode: () => IgnoreCaseMode,
  SelectorType: () => SelectorType,
  isTraversal: () => isTraversal,
  parse: () => parse,
  stringify: () => stringify
});
var init_es = __esm({
  "node_modules/css-what/lib/es/index.js"() {
    init_types();
    init_parse();
    init_stringify();
  }
});

// node_modules/css-select/lib/sort.js
var require_sort = __commonJS({
  "node_modules/css-select/lib/sort.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTraversal = void 0;
    var css_what_1 = (init_es(), __toCommonJS(es_exports));
    var procedure = /* @__PURE__ */ new Map([
      [css_what_1.SelectorType.Universal, 50],
      [css_what_1.SelectorType.Tag, 30],
      [css_what_1.SelectorType.Attribute, 1],
      [css_what_1.SelectorType.Pseudo, 0]
    ]);
    function isTraversal2(token) {
      return !procedure.has(token.type);
    }
    exports.isTraversal = isTraversal2;
    var attributes = /* @__PURE__ */ new Map([
      [css_what_1.AttributeAction.Exists, 10],
      [css_what_1.AttributeAction.Equals, 8],
      [css_what_1.AttributeAction.Not, 7],
      [css_what_1.AttributeAction.Start, 6],
      [css_what_1.AttributeAction.End, 6],
      [css_what_1.AttributeAction.Any, 5]
    ]);
    function sortByProcedure(arr) {
      var procs = arr.map(getProcedure);
      for (var i2 = 1; i2 < arr.length; i2++) {
        var procNew = procs[i2];
        if (procNew < 0)
          continue;
        for (var j2 = i2 - 1; j2 >= 0 && procNew < procs[j2]; j2--) {
          var token = arr[j2 + 1];
          arr[j2 + 1] = arr[j2];
          arr[j2] = token;
          procs[j2 + 1] = procs[j2];
          procs[j2] = procNew;
        }
      }
    }
    exports.default = sortByProcedure;
    function getProcedure(token) {
      var _a, _b;
      var proc = (_a = procedure.get(token.type)) !== null && _a !== void 0 ? _a : -1;
      if (token.type === css_what_1.SelectorType.Attribute) {
        proc = (_b = attributes.get(token.action)) !== null && _b !== void 0 ? _b : 4;
        if (token.action === css_what_1.AttributeAction.Equals && token.name === "id") {
          proc = 9;
        }
        if (token.ignoreCase) {
          proc >>= 1;
        }
      } else if (token.type === css_what_1.SelectorType.Pseudo) {
        if (!token.data) {
          proc = 3;
        } else if (token.name === "has" || token.name === "contains") {
          proc = 0;
        } else if (Array.isArray(token.data)) {
          proc = Math.min.apply(Math, token.data.map(function(d2) {
            return Math.min.apply(Math, d2.map(getProcedure));
          }));
          if (proc < 0) {
            proc = 0;
          }
        } else {
          proc = 2;
        }
      }
      return proc;
    }
  }
});

// node_modules/css-select/lib/attributes.js
var require_attributes = __commonJS({
  "node_modules/css-select/lib/attributes.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.attributeRules = void 0;
    var boolbase_1 = __importDefault(require_boolbase());
    var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
    function escapeRegex(value) {
      return value.replace(reChars, "\\$&");
    }
    var caseInsensitiveAttributes = /* @__PURE__ */ new Set([
      "accept",
      "accept-charset",
      "align",
      "alink",
      "axis",
      "bgcolor",
      "charset",
      "checked",
      "clear",
      "codetype",
      "color",
      "compact",
      "declare",
      "defer",
      "dir",
      "direction",
      "disabled",
      "enctype",
      "face",
      "frame",
      "hreflang",
      "http-equiv",
      "lang",
      "language",
      "link",
      "media",
      "method",
      "multiple",
      "nohref",
      "noresize",
      "noshade",
      "nowrap",
      "readonly",
      "rel",
      "rev",
      "rules",
      "scope",
      "scrolling",
      "selected",
      "shape",
      "target",
      "text",
      "type",
      "valign",
      "valuetype",
      "vlink"
    ]);
    function shouldIgnoreCase(selector, options) {
      return typeof selector.ignoreCase === "boolean" ? selector.ignoreCase : selector.ignoreCase === "quirks" ? !!options.quirksMode : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);
    }
    exports.attributeRules = {
      equals: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && attr.length === value.length && attr.toLowerCase() === value && next(elem);
          };
        }
        return function(elem) {
          return adapter.getAttributeValue(elem, name) === value && next(elem);
        };
      },
      hyphen: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        var len = value.length;
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function hyphenIC(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len).toLowerCase() === value && next(elem);
          };
        }
        return function hyphen(elem) {
          var attr = adapter.getAttributeValue(elem, name);
          return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len) === value && next(elem);
        };
      },
      element: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name, value = data.value;
        if (/\s/.test(value)) {
          return boolbase_1.default.falseFunc;
        }
        var regex = new RegExp("(?:^|\\s)".concat(escapeRegex(value), "(?:$|\\s)"), shouldIgnoreCase(data, options) ? "i" : "");
        return function element(elem) {
          var attr = adapter.getAttributeValue(elem, name);
          return attr != null && attr.length >= value.length && regex.test(attr) && next(elem);
        };
      },
      exists: function(next, _a, _b) {
        var name = _a.name;
        var adapter = _b.adapter;
        return function(elem) {
          return adapter.hasAttrib(elem, name) && next(elem);
        };
      },
      start: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        var len = value.length;
        if (len === 0) {
          return boolbase_1.default.falseFunc;
        }
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && attr.length >= len && attr.substr(0, len).toLowerCase() === value && next(elem);
          };
        }
        return function(elem) {
          var _a;
          return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.startsWith(value)) && next(elem);
        };
      },
      end: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        var len = -value.length;
        if (len === 0) {
          return boolbase_1.default.falseFunc;
        }
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function(elem) {
            var _a;
            return ((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.substr(len).toLowerCase()) === value && next(elem);
          };
        }
        return function(elem) {
          var _a;
          return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.endsWith(value)) && next(elem);
        };
      },
      any: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name, value = data.value;
        if (value === "") {
          return boolbase_1.default.falseFunc;
        }
        if (shouldIgnoreCase(data, options)) {
          var regex_1 = new RegExp(escapeRegex(value), "i");
          return function anyIC(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && attr.length >= value.length && regex_1.test(attr) && next(elem);
          };
        }
        return function(elem) {
          var _a;
          return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.includes(value)) && next(elem);
        };
      },
      not: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        if (value === "") {
          return function(elem) {
            return !!adapter.getAttributeValue(elem, name) && next(elem);
          };
        } else if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return (attr == null || attr.length !== value.length || attr.toLowerCase() !== value) && next(elem);
          };
        }
        return function(elem) {
          return adapter.getAttributeValue(elem, name) !== value && next(elem);
        };
      }
    };
  }
});

// node_modules/nth-check/lib/parse.js
var require_parse = __commonJS({
  "node_modules/nth-check/lib/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = void 0;
    var whitespace = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]);
    var ZERO = "0".charCodeAt(0);
    var NINE = "9".charCodeAt(0);
    function parse2(formula) {
      formula = formula.trim().toLowerCase();
      if (formula === "even") {
        return [2, 0];
      } else if (formula === "odd") {
        return [2, 1];
      }
      var idx = 0;
      var a2 = 0;
      var sign2 = readSign();
      var number = readNumber();
      if (idx < formula.length && formula.charAt(idx) === "n") {
        idx++;
        a2 = sign2 * (number !== null && number !== void 0 ? number : 1);
        skipWhitespace2();
        if (idx < formula.length) {
          sign2 = readSign();
          skipWhitespace2();
          number = readNumber();
        } else {
          sign2 = number = 0;
        }
      }
      if (number === null || idx < formula.length) {
        throw new Error("n-th rule couldn't be parsed ('".concat(formula, "')"));
      }
      return [a2, sign2 * number];
      function readSign() {
        if (formula.charAt(idx) === "-") {
          idx++;
          return -1;
        }
        if (formula.charAt(idx) === "+") {
          idx++;
        }
        return 1;
      }
      function readNumber() {
        var start = idx;
        var value = 0;
        while (idx < formula.length && formula.charCodeAt(idx) >= ZERO && formula.charCodeAt(idx) <= NINE) {
          value = value * 10 + (formula.charCodeAt(idx) - ZERO);
          idx++;
        }
        return idx === start ? null : value;
      }
      function skipWhitespace2() {
        while (idx < formula.length && whitespace.has(formula.charCodeAt(idx))) {
          idx++;
        }
      }
    }
    exports.parse = parse2;
  }
});

// node_modules/nth-check/lib/compile.js
var require_compile = __commonJS({
  "node_modules/nth-check/lib/compile.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generate = exports.compile = void 0;
    var boolbase_1 = __importDefault(require_boolbase());
    function compile(parsed) {
      var a2 = parsed[0];
      var b3 = parsed[1] - 1;
      if (b3 < 0 && a2 <= 0)
        return boolbase_1.default.falseFunc;
      if (a2 === -1)
        return function(index) {
          return index <= b3;
        };
      if (a2 === 0)
        return function(index) {
          return index === b3;
        };
      if (a2 === 1)
        return b3 < 0 ? boolbase_1.default.trueFunc : function(index) {
          return index >= b3;
        };
      var absA = Math.abs(a2);
      var bMod = (b3 % absA + absA) % absA;
      return a2 > 1 ? function(index) {
        return index >= b3 && index % absA === bMod;
      } : function(index) {
        return index <= b3 && index % absA === bMod;
      };
    }
    exports.compile = compile;
    function generate(parsed) {
      var a2 = parsed[0];
      var b3 = parsed[1] - 1;
      var n2 = 0;
      if (a2 < 0) {
        var aPos_1 = -a2;
        var minValue_1 = (b3 % aPos_1 + aPos_1) % aPos_1;
        return function() {
          var val = minValue_1 + aPos_1 * n2++;
          return val > b3 ? null : val;
        };
      }
      if (a2 === 0)
        return b3 < 0 ? (
          // There are no result — always return `null`
          function() {
            return null;
          }
        ) : (
          // Return `b` exactly once
          function() {
            return n2++ === 0 ? b3 : null;
          }
        );
      if (b3 < 0) {
        b3 += a2 * Math.ceil(-b3 / a2);
      }
      return function() {
        return a2 * n2++ + b3;
      };
    }
    exports.generate = generate;
  }
});

// node_modules/nth-check/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/nth-check/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sequence = exports.generate = exports.compile = exports.parse = void 0;
    var parse_js_1 = require_parse();
    Object.defineProperty(exports, "parse", { enumerable: true, get: function() {
      return parse_js_1.parse;
    } });
    var compile_js_1 = require_compile();
    Object.defineProperty(exports, "compile", { enumerable: true, get: function() {
      return compile_js_1.compile;
    } });
    Object.defineProperty(exports, "generate", { enumerable: true, get: function() {
      return compile_js_1.generate;
    } });
    function nthCheck(formula) {
      return (0, compile_js_1.compile)((0, parse_js_1.parse)(formula));
    }
    exports.default = nthCheck;
    function sequence(formula) {
      return (0, compile_js_1.generate)((0, parse_js_1.parse)(formula));
    }
    exports.sequence = sequence;
  }
});

// node_modules/css-select/lib/pseudo-selectors/filters.js
var require_filters = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/filters.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.filters = void 0;
    var nth_check_1 = __importDefault(require_lib6());
    var boolbase_1 = __importDefault(require_boolbase());
    function getChildFunc(next, adapter) {
      return function(elem) {
        var parent = adapter.getParent(elem);
        return parent != null && adapter.isTag(parent) && next(elem);
      };
    }
    exports.filters = {
      contains: function(next, text, _a) {
        var adapter = _a.adapter;
        return function contains(elem) {
          return next(elem) && adapter.getText(elem).includes(text);
        };
      },
      icontains: function(next, text, _a) {
        var adapter = _a.adapter;
        var itext = text.toLowerCase();
        return function icontains(elem) {
          return next(elem) && adapter.getText(elem).toLowerCase().includes(itext);
        };
      },
      // Location specific methods
      "nth-child": function(next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        if (func === boolbase_1.default.trueFunc)
          return getChildFunc(next, adapter);
        return function nthChild(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i2 = 0; i2 < siblings.length; i2++) {
            if (equals(elem, siblings[i2]))
              break;
            if (adapter.isTag(siblings[i2])) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      "nth-last-child": function(next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        if (func === boolbase_1.default.trueFunc)
          return getChildFunc(next, adapter);
        return function nthLastChild(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i2 = siblings.length - 1; i2 >= 0; i2--) {
            if (equals(elem, siblings[i2]))
              break;
            if (adapter.isTag(siblings[i2])) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      "nth-of-type": function(next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        if (func === boolbase_1.default.trueFunc)
          return getChildFunc(next, adapter);
        return function nthOfType(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i2 = 0; i2 < siblings.length; i2++) {
            var currentSibling = siblings[i2];
            if (equals(elem, currentSibling))
              break;
            if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      "nth-last-of-type": function(next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        if (func === boolbase_1.default.trueFunc)
          return getChildFunc(next, adapter);
        return function nthLastOfType(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i2 = siblings.length - 1; i2 >= 0; i2--) {
            var currentSibling = siblings[i2];
            if (equals(elem, currentSibling))
              break;
            if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      // TODO determine the actual root element
      root: function(next, _rule, _a) {
        var adapter = _a.adapter;
        return function(elem) {
          var parent = adapter.getParent(elem);
          return (parent == null || !adapter.isTag(parent)) && next(elem);
        };
      },
      scope: function(next, rule, options, context2) {
        var equals = options.equals;
        if (!context2 || context2.length === 0) {
          return exports.filters["root"](next, rule, options);
        }
        if (context2.length === 1) {
          return function(elem) {
            return equals(context2[0], elem) && next(elem);
          };
        }
        return function(elem) {
          return context2.includes(elem) && next(elem);
        };
      },
      hover: dynamicStatePseudo("isHovered"),
      visited: dynamicStatePseudo("isVisited"),
      active: dynamicStatePseudo("isActive")
    };
    function dynamicStatePseudo(name) {
      return function dynamicPseudo(next, _rule, _a) {
        var adapter = _a.adapter;
        var func = adapter[name];
        if (typeof func !== "function") {
          return boolbase_1.default.falseFunc;
        }
        return function active(elem) {
          return func(elem) && next(elem);
        };
      };
    }
  }
});

// node_modules/css-select/lib/pseudo-selectors/pseudos.js
var require_pseudos = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/pseudos.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyPseudoArgs = exports.pseudos = void 0;
    exports.pseudos = {
      empty: function(elem, _a) {
        var adapter = _a.adapter;
        return !adapter.getChildren(elem).some(function(elem2) {
          return adapter.isTag(elem2) || adapter.getText(elem2) !== "";
        });
      },
      "first-child": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        if (adapter.prevElementSibling) {
          return adapter.prevElementSibling(elem) == null;
        }
        var firstChild = adapter.getSiblings(elem).find(function(elem2) {
          return adapter.isTag(elem2);
        });
        return firstChild != null && equals(elem, firstChild);
      },
      "last-child": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        for (var i2 = siblings.length - 1; i2 >= 0; i2--) {
          if (equals(elem, siblings[i2]))
            return true;
          if (adapter.isTag(siblings[i2]))
            break;
        }
        return false;
      },
      "first-of-type": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        var elemName = adapter.getName(elem);
        for (var i2 = 0; i2 < siblings.length; i2++) {
          var currentSibling = siblings[i2];
          if (equals(elem, currentSibling))
            return true;
          if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
            break;
          }
        }
        return false;
      },
      "last-of-type": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        var elemName = adapter.getName(elem);
        for (var i2 = siblings.length - 1; i2 >= 0; i2--) {
          var currentSibling = siblings[i2];
          if (equals(elem, currentSibling))
            return true;
          if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
            break;
          }
        }
        return false;
      },
      "only-of-type": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var elemName = adapter.getName(elem);
        return adapter.getSiblings(elem).every(function(sibling) {
          return equals(elem, sibling) || !adapter.isTag(sibling) || adapter.getName(sibling) !== elemName;
        });
      },
      "only-child": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        return adapter.getSiblings(elem).every(function(sibling) {
          return equals(elem, sibling) || !adapter.isTag(sibling);
        });
      }
    };
    function verifyPseudoArgs(func, name, subselect, argIndex) {
      if (subselect === null) {
        if (func.length > argIndex) {
          throw new Error("Pseudo-class :".concat(name, " requires an argument"));
        }
      } else if (func.length === argIndex) {
        throw new Error("Pseudo-class :".concat(name, " doesn't have any arguments"));
      }
    }
    exports.verifyPseudoArgs = verifyPseudoArgs;
  }
});

// node_modules/css-select/lib/pseudo-selectors/aliases.js
var require_aliases = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/aliases.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.aliases = void 0;
    exports.aliases = {
      // Links
      "any-link": ":is(a, area, link)[href]",
      link: ":any-link:not(:visited)",
      // Forms
      // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
      disabled: ":is(\n        :is(button, input, select, textarea, optgroup, option)[disabled],\n        optgroup[disabled] > option,\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\n    )",
      enabled: ":not(:disabled)",
      checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
      required: ":is(input, select, textarea)[required]",
      optional: ":is(input, select, textarea):not([required])",
      // JQuery extensions
      // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
      selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
      checkbox: "[type=checkbox]",
      file: "[type=file]",
      password: "[type=password]",
      radio: "[type=radio]",
      reset: "[type=reset]",
      image: "[type=image]",
      submit: "[type=submit]",
      parent: ":not(:empty)",
      header: ":is(h1, h2, h3, h4, h5, h6)",
      button: ":is(button, input[type=button])",
      input: ":is(input, textarea, select, button)",
      text: "input:is(:not([type!='']), [type=text])"
    };
  }
});

// node_modules/css-select/lib/pseudo-selectors/subselects.js
var require_subselects = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/subselects.js"(exports) {
    "use strict";
    var __spreadArray = exports && exports.__spreadArray || function(to2, from, pack) {
      if (pack || arguments.length === 2)
        for (var i2 = 0, l2 = from.length, ar3; i2 < l2; i2++) {
          if (ar3 || !(i2 in from)) {
            if (!ar3)
              ar3 = Array.prototype.slice.call(from, 0, i2);
            ar3[i2] = from[i2];
          }
        }
      return to2.concat(ar3 || Array.prototype.slice.call(from));
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.subselects = exports.getNextSiblings = exports.ensureIsTag = exports.PLACEHOLDER_ELEMENT = void 0;
    var boolbase_1 = __importDefault(require_boolbase());
    var sort_js_1 = require_sort();
    exports.PLACEHOLDER_ELEMENT = {};
    function ensureIsTag(next, adapter) {
      if (next === boolbase_1.default.falseFunc)
        return boolbase_1.default.falseFunc;
      return function(elem) {
        return adapter.isTag(elem) && next(elem);
      };
    }
    exports.ensureIsTag = ensureIsTag;
    function getNextSiblings(elem, adapter) {
      var siblings = adapter.getSiblings(elem);
      if (siblings.length <= 1)
        return [];
      var elemIndex = siblings.indexOf(elem);
      if (elemIndex < 0 || elemIndex === siblings.length - 1)
        return [];
      return siblings.slice(elemIndex + 1).filter(adapter.isTag);
    }
    exports.getNextSiblings = getNextSiblings;
    function copyOptions(options) {
      return {
        xmlMode: !!options.xmlMode,
        lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,
        lowerCaseTags: !!options.lowerCaseTags,
        quirksMode: !!options.quirksMode,
        cacheResults: !!options.cacheResults,
        pseudos: options.pseudos,
        adapter: options.adapter,
        equals: options.equals
      };
    }
    var is = function(next, token, options, context2, compileToken) {
      var func = compileToken(token, copyOptions(options), context2);
      return func === boolbase_1.default.trueFunc ? next : func === boolbase_1.default.falseFunc ? boolbase_1.default.falseFunc : function(elem) {
        return func(elem) && next(elem);
      };
    };
    exports.subselects = {
      is,
      /**
       * `:matches` and `:where` are aliases for `:is`.
       */
      matches: is,
      where: is,
      not: function(next, token, options, context2, compileToken) {
        var func = compileToken(token, copyOptions(options), context2);
        return func === boolbase_1.default.falseFunc ? next : func === boolbase_1.default.trueFunc ? boolbase_1.default.falseFunc : function(elem) {
          return !func(elem) && next(elem);
        };
      },
      has: function(next, subselect, options, _context, compileToken) {
        var adapter = options.adapter;
        var opts = copyOptions(options);
        opts.relativeSelector = true;
        var context2 = subselect.some(function(s2) {
          return s2.some(sort_js_1.isTraversal);
        }) ? (
          // Used as a placeholder. Will be replaced with the actual element.
          [exports.PLACEHOLDER_ELEMENT]
        ) : void 0;
        var compiled = compileToken(subselect, opts, context2);
        if (compiled === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        var hasElement = ensureIsTag(compiled, adapter);
        if (context2 && compiled !== boolbase_1.default.trueFunc) {
          var _a = compiled.shouldTestNextSiblings, shouldTestNextSiblings_1 = _a === void 0 ? false : _a;
          return function(elem) {
            if (!next(elem))
              return false;
            context2[0] = elem;
            var childs = adapter.getChildren(elem);
            var nextElements = shouldTestNextSiblings_1 ? __spreadArray(__spreadArray([], childs, true), getNextSiblings(elem, adapter), true) : childs;
            return adapter.existsOne(hasElement, nextElements);
          };
        }
        return function(elem) {
          return next(elem) && adapter.existsOne(hasElement, adapter.getChildren(elem));
        };
      }
    };
  }
});

// node_modules/css-select/lib/pseudo-selectors/index.js
var require_pseudo_selectors = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compilePseudoSelector = exports.aliases = exports.pseudos = exports.filters = void 0;
    var css_what_1 = (init_es(), __toCommonJS(es_exports));
    var filters_js_1 = require_filters();
    Object.defineProperty(exports, "filters", { enumerable: true, get: function() {
      return filters_js_1.filters;
    } });
    var pseudos_js_1 = require_pseudos();
    Object.defineProperty(exports, "pseudos", { enumerable: true, get: function() {
      return pseudos_js_1.pseudos;
    } });
    var aliases_js_1 = require_aliases();
    Object.defineProperty(exports, "aliases", { enumerable: true, get: function() {
      return aliases_js_1.aliases;
    } });
    var subselects_js_1 = require_subselects();
    function compilePseudoSelector(next, selector, options, context2, compileToken) {
      var _a;
      var name = selector.name, data = selector.data;
      if (Array.isArray(data)) {
        if (!(name in subselects_js_1.subselects)) {
          throw new Error("Unknown pseudo-class :".concat(name, "(").concat(data, ")"));
        }
        return subselects_js_1.subselects[name](next, data, options, context2, compileToken);
      }
      var userPseudo = (_a = options.pseudos) === null || _a === void 0 ? void 0 : _a[name];
      var stringPseudo = typeof userPseudo === "string" ? userPseudo : aliases_js_1.aliases[name];
      if (typeof stringPseudo === "string") {
        if (data != null) {
          throw new Error("Pseudo ".concat(name, " doesn't have any arguments"));
        }
        var alias = (0, css_what_1.parse)(stringPseudo);
        return subselects_js_1.subselects["is"](next, alias, options, context2, compileToken);
      }
      if (typeof userPseudo === "function") {
        (0, pseudos_js_1.verifyPseudoArgs)(userPseudo, name, data, 1);
        return function(elem) {
          return userPseudo(elem, data) && next(elem);
        };
      }
      if (name in filters_js_1.filters) {
        return filters_js_1.filters[name](next, data, options, context2);
      }
      if (name in pseudos_js_1.pseudos) {
        var pseudo_1 = pseudos_js_1.pseudos[name];
        (0, pseudos_js_1.verifyPseudoArgs)(pseudo_1, name, data, 2);
        return function(elem) {
          return pseudo_1(elem, options, data) && next(elem);
        };
      }
      throw new Error("Unknown pseudo-class :".concat(name));
    }
    exports.compilePseudoSelector = compilePseudoSelector;
  }
});

// node_modules/css-select/lib/general.js
var require_general = __commonJS({
  "node_modules/css-select/lib/general.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compileGeneralSelector = void 0;
    var attributes_js_1 = require_attributes();
    var index_js_1 = require_pseudo_selectors();
    var css_what_1 = (init_es(), __toCommonJS(es_exports));
    function getElementParent(node, adapter) {
      var parent = adapter.getParent(node);
      if (parent && adapter.isTag(parent)) {
        return parent;
      }
      return null;
    }
    function compileGeneralSelector(next, selector, options, context2, compileToken) {
      var adapter = options.adapter, equals = options.equals;
      switch (selector.type) {
        case css_what_1.SelectorType.PseudoElement: {
          throw new Error("Pseudo-elements are not supported by css-select");
        }
        case css_what_1.SelectorType.ColumnCombinator: {
          throw new Error("Column combinators are not yet supported by css-select");
        }
        case css_what_1.SelectorType.Attribute: {
          if (selector.namespace != null) {
            throw new Error("Namespaced attributes are not yet supported by css-select");
          }
          if (!options.xmlMode || options.lowerCaseAttributeNames) {
            selector.name = selector.name.toLowerCase();
          }
          return attributes_js_1.attributeRules[selector.action](next, selector, options);
        }
        case css_what_1.SelectorType.Pseudo: {
          return (0, index_js_1.compilePseudoSelector)(next, selector, options, context2, compileToken);
        }
        case css_what_1.SelectorType.Tag: {
          if (selector.namespace != null) {
            throw new Error("Namespaced tag names are not yet supported by css-select");
          }
          var name_1 = selector.name;
          if (!options.xmlMode || options.lowerCaseTags) {
            name_1 = name_1.toLowerCase();
          }
          return function tag(elem) {
            return adapter.getName(elem) === name_1 && next(elem);
          };
        }
        case css_what_1.SelectorType.Descendant: {
          if (options.cacheResults === false || typeof WeakSet === "undefined") {
            return function descendant(elem) {
              var current = elem;
              while (current = getElementParent(current, adapter)) {
                if (next(current)) {
                  return true;
                }
              }
              return false;
            };
          }
          var isFalseCache_1 = /* @__PURE__ */ new WeakSet();
          return function cachedDescendant(elem) {
            var current = elem;
            while (current = getElementParent(current, adapter)) {
              if (!isFalseCache_1.has(current)) {
                if (adapter.isTag(current) && next(current)) {
                  return true;
                }
                isFalseCache_1.add(current);
              }
            }
            return false;
          };
        }
        case "_flexibleDescendant": {
          return function flexibleDescendant(elem) {
            var current = elem;
            do {
              if (next(current))
                return true;
            } while (current = getElementParent(current, adapter));
            return false;
          };
        }
        case css_what_1.SelectorType.Parent: {
          return function parent(elem) {
            return adapter.getChildren(elem).some(function(elem2) {
              return adapter.isTag(elem2) && next(elem2);
            });
          };
        }
        case css_what_1.SelectorType.Child: {
          return function child(elem) {
            var parent = adapter.getParent(elem);
            return parent != null && adapter.isTag(parent) && next(parent);
          };
        }
        case css_what_1.SelectorType.Sibling: {
          return function sibling(elem) {
            var siblings = adapter.getSiblings(elem);
            for (var i2 = 0; i2 < siblings.length; i2++) {
              var currentSibling = siblings[i2];
              if (equals(elem, currentSibling))
                break;
              if (adapter.isTag(currentSibling) && next(currentSibling)) {
                return true;
              }
            }
            return false;
          };
        }
        case css_what_1.SelectorType.Adjacent: {
          if (adapter.prevElementSibling) {
            return function adjacent(elem) {
              var previous = adapter.prevElementSibling(elem);
              return previous != null && next(previous);
            };
          }
          return function adjacent(elem) {
            var siblings = adapter.getSiblings(elem);
            var lastElement;
            for (var i2 = 0; i2 < siblings.length; i2++) {
              var currentSibling = siblings[i2];
              if (equals(elem, currentSibling))
                break;
              if (adapter.isTag(currentSibling)) {
                lastElement = currentSibling;
              }
            }
            return !!lastElement && next(lastElement);
          };
        }
        case css_what_1.SelectorType.Universal: {
          if (selector.namespace != null && selector.namespace !== "*") {
            throw new Error("Namespaced universal selectors are not yet supported by css-select");
          }
          return next;
        }
      }
    }
    exports.compileGeneralSelector = compileGeneralSelector;
  }
});

// node_modules/css-select/lib/compile.js
var require_compile2 = __commonJS({
  "node_modules/css-select/lib/compile.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compileToken = exports.compileUnsafe = exports.compile = void 0;
    var css_what_1 = (init_es(), __toCommonJS(es_exports));
    var boolbase_1 = __importDefault(require_boolbase());
    var sort_js_1 = __importStar(require_sort());
    var general_js_1 = require_general();
    var subselects_js_1 = require_subselects();
    function compile(selector, options, context2) {
      var next = compileUnsafe(selector, options, context2);
      return (0, subselects_js_1.ensureIsTag)(next, options.adapter);
    }
    exports.compile = compile;
    function compileUnsafe(selector, options, context2) {
      var token = typeof selector === "string" ? (0, css_what_1.parse)(selector) : selector;
      return compileToken(token, options, context2);
    }
    exports.compileUnsafe = compileUnsafe;
    function includesScopePseudo(t2) {
      return t2.type === css_what_1.SelectorType.Pseudo && (t2.name === "scope" || Array.isArray(t2.data) && t2.data.some(function(data) {
        return data.some(includesScopePseudo);
      }));
    }
    var DESCENDANT_TOKEN = { type: css_what_1.SelectorType.Descendant };
    var FLEXIBLE_DESCENDANT_TOKEN = {
      type: "_flexibleDescendant"
    };
    var SCOPE_TOKEN = {
      type: css_what_1.SelectorType.Pseudo,
      name: "scope",
      data: null
    };
    function absolutize(token, _a, context2) {
      var adapter = _a.adapter;
      var hasContext = !!(context2 === null || context2 === void 0 ? void 0 : context2.every(function(e2) {
        var parent = adapter.isTag(e2) && adapter.getParent(e2);
        return e2 === subselects_js_1.PLACEHOLDER_ELEMENT || parent && adapter.isTag(parent);
      }));
      for (var _i = 0, token_1 = token; _i < token_1.length; _i++) {
        var t2 = token_1[_i];
        if (t2.length > 0 && (0, sort_js_1.isTraversal)(t2[0]) && t2[0].type !== css_what_1.SelectorType.Descendant) {
        } else if (hasContext && !t2.some(includesScopePseudo)) {
          t2.unshift(DESCENDANT_TOKEN);
        } else {
          continue;
        }
        t2.unshift(SCOPE_TOKEN);
      }
    }
    function compileToken(token, options, context2) {
      var _a;
      token.forEach(sort_js_1.default);
      context2 = (_a = options.context) !== null && _a !== void 0 ? _a : context2;
      var isArrayContext = Array.isArray(context2);
      var finalContext = context2 && (Array.isArray(context2) ? context2 : [context2]);
      if (options.relativeSelector !== false) {
        absolutize(token, options, finalContext);
      } else if (token.some(function(t2) {
        return t2.length > 0 && (0, sort_js_1.isTraversal)(t2[0]);
      })) {
        throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");
      }
      var shouldTestNextSiblings = false;
      var query = token.map(function(rules) {
        if (rules.length >= 2) {
          var first = rules[0], second = rules[1];
          if (first.type !== css_what_1.SelectorType.Pseudo || first.name !== "scope") {
          } else if (isArrayContext && second.type === css_what_1.SelectorType.Descendant) {
            rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
          } else if (second.type === css_what_1.SelectorType.Adjacent || second.type === css_what_1.SelectorType.Sibling) {
            shouldTestNextSiblings = true;
          }
        }
        return compileRules(rules, options, finalContext);
      }).reduce(reduceRules, boolbase_1.default.falseFunc);
      query.shouldTestNextSiblings = shouldTestNextSiblings;
      return query;
    }
    exports.compileToken = compileToken;
    function compileRules(rules, options, context2) {
      var _a;
      return rules.reduce(function(previous, rule) {
        return previous === boolbase_1.default.falseFunc ? boolbase_1.default.falseFunc : (0, general_js_1.compileGeneralSelector)(previous, rule, options, context2, compileToken);
      }, (_a = options.rootFunc) !== null && _a !== void 0 ? _a : boolbase_1.default.trueFunc);
    }
    function reduceRules(a2, b3) {
      if (b3 === boolbase_1.default.falseFunc || a2 === boolbase_1.default.trueFunc) {
        return a2;
      }
      if (a2 === boolbase_1.default.falseFunc || b3 === boolbase_1.default.trueFunc) {
        return b3;
      }
      return function combine(elem) {
        return a2(elem) || b3(elem);
      };
    }
  }
});

// node_modules/css-select/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/css-select/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o2, k2, desc);
    } : function(o2, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o2[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.aliases = exports.pseudos = exports.filters = exports.is = exports.selectOne = exports.selectAll = exports.prepareContext = exports._compileToken = exports._compileUnsafe = exports.compile = void 0;
    var DomUtils = __importStar(require_lib5());
    var boolbase_1 = __importDefault(require_boolbase());
    var compile_js_1 = require_compile2();
    var subselects_js_1 = require_subselects();
    var defaultEquals = function(a2, b3) {
      return a2 === b3;
    };
    var defaultOptions = {
      adapter: DomUtils,
      equals: defaultEquals
    };
    function convertOptionFormats(options) {
      var _a, _b, _c, _d;
      var opts = options !== null && options !== void 0 ? options : defaultOptions;
      (_a = opts.adapter) !== null && _a !== void 0 ? _a : opts.adapter = DomUtils;
      (_b = opts.equals) !== null && _b !== void 0 ? _b : opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals;
      return opts;
    }
    function wrapCompile(func) {
      return function addAdapter(selector, options, context2) {
        var opts = convertOptionFormats(options);
        return func(selector, opts, context2);
      };
    }
    exports.compile = wrapCompile(compile_js_1.compile);
    exports._compileUnsafe = wrapCompile(compile_js_1.compileUnsafe);
    exports._compileToken = wrapCompile(compile_js_1.compileToken);
    function getSelectorFunc(searchFunc) {
      return function select(query, elements, options) {
        var opts = convertOptionFormats(options);
        if (typeof query !== "function") {
          query = (0, compile_js_1.compileUnsafe)(query, opts, elements);
        }
        var filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);
        return searchFunc(query, filteredElements, opts);
      };
    }
    function prepareContext(elems, adapter, shouldTestNextSiblings) {
      if (shouldTestNextSiblings === void 0) {
        shouldTestNextSiblings = false;
      }
      if (shouldTestNextSiblings) {
        elems = appendNextSiblings(elems, adapter);
      }
      return Array.isArray(elems) ? adapter.removeSubsets(elems) : adapter.getChildren(elems);
    }
    exports.prepareContext = prepareContext;
    function appendNextSiblings(elem, adapter) {
      var elems = Array.isArray(elem) ? elem.slice(0) : [elem];
      var elemsLength = elems.length;
      for (var i2 = 0; i2 < elemsLength; i2++) {
        var nextSiblings = (0, subselects_js_1.getNextSiblings)(elems[i2], adapter);
        elems.push.apply(elems, nextSiblings);
      }
      return elems;
    }
    exports.selectAll = getSelectorFunc(function(query, elems, options) {
      return query === boolbase_1.default.falseFunc || !elems || elems.length === 0 ? [] : options.adapter.findAll(query, elems);
    });
    exports.selectOne = getSelectorFunc(function(query, elems, options) {
      return query === boolbase_1.default.falseFunc || !elems || elems.length === 0 ? null : options.adapter.findOne(query, elems);
    });
    function is(elem, query, options) {
      var opts = convertOptionFormats(options);
      return (typeof query === "function" ? query : (0, compile_js_1.compile)(query, opts))(elem);
    }
    exports.is = is;
    exports.default = exports.selectAll;
    var index_js_1 = require_pseudo_selectors();
    Object.defineProperty(exports, "filters", { enumerable: true, get: function() {
      return index_js_1.filters;
    } });
    Object.defineProperty(exports, "pseudos", { enumerable: true, get: function() {
      return index_js_1.pseudos;
    } });
    Object.defineProperty(exports, "aliases", { enumerable: true, get: function() {
      return index_js_1.aliases;
    } });
  }
});

// node_modules/node-html-parser/dist/back.js
var require_back = __commonJS({
  "node_modules/node-html-parser/dist/back.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function arr_back(arr) {
      return arr[arr.length - 1];
    }
    exports.default = arr_back;
  }
});

// node_modules/node-html-parser/dist/matcher.js
var require_matcher = __commonJS({
  "node_modules/node-html-parser/dist/matcher.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var type_1 = __importDefault(require_type());
    function isTag(node) {
      return node && node.nodeType === type_1.default.ELEMENT_NODE;
    }
    function getAttributeValue(elem, name) {
      return isTag(elem) ? elem.getAttribute(name) : void 0;
    }
    function getName(elem) {
      return (elem && elem.rawTagName || "").toLowerCase();
    }
    function getChildren(node) {
      return node && node.childNodes;
    }
    function getParent(node) {
      return node ? node.parentNode : null;
    }
    function getText(node) {
      return node.text;
    }
    function removeSubsets(nodes) {
      var idx = nodes.length;
      var node;
      var ancestor;
      var replace;
      while (--idx > -1) {
        node = ancestor = nodes[idx];
        nodes[idx] = null;
        replace = true;
        while (ancestor) {
          if (nodes.indexOf(ancestor) > -1) {
            replace = false;
            nodes.splice(idx, 1);
            break;
          }
          ancestor = getParent(ancestor);
        }
        if (replace) {
          nodes[idx] = node;
        }
      }
      return nodes;
    }
    function existsOne(test, elems) {
      return elems.some(function(elem) {
        return isTag(elem) ? test(elem) || existsOne(test, getChildren(elem)) : false;
      });
    }
    function getSiblings(node) {
      var parent = getParent(node);
      return parent ? getChildren(parent) : [];
    }
    function hasAttrib(elem, name) {
      return getAttributeValue(elem, name) !== void 0;
    }
    function findOne(test, elems) {
      var elem = null;
      for (var i2 = 0, l2 = elems === null || elems === void 0 ? void 0 : elems.length; i2 < l2 && !elem; i2++) {
        var el2 = elems[i2];
        if (test(el2)) {
          elem = el2;
        } else {
          var childs = getChildren(el2);
          if (childs && childs.length > 0) {
            elem = findOne(test, childs);
          }
        }
      }
      return elem;
    }
    function findAll(test, nodes) {
      var result = [];
      for (var i2 = 0, j2 = nodes.length; i2 < j2; i2++) {
        if (!isTag(nodes[i2]))
          continue;
        if (test(nodes[i2]))
          result.push(nodes[i2]);
        var childs = getChildren(nodes[i2]);
        if (childs)
          result = result.concat(findAll(test, childs));
      }
      return result;
    }
    exports.default = {
      isTag,
      getAttributeValue,
      getName,
      getChildren,
      getParent,
      getText,
      removeSubsets,
      existsOne,
      getSiblings,
      hasAttrib,
      findOne,
      findAll
    };
  }
});

// node_modules/node-html-parser/dist/void-tag.js
var require_void_tag = __commonJS({
  "node_modules/node-html-parser/dist/void-tag.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var VoidTag = (
      /** @class */
      function() {
        function VoidTag2(addClosingSlash, tags) {
          if (addClosingSlash === void 0) {
            addClosingSlash = false;
          }
          this.addClosingSlash = addClosingSlash;
          if (Array.isArray(tags)) {
            this.voidTags = tags.reduce(function(set, tag) {
              return set.add(tag.toLowerCase()).add(tag.toUpperCase()).add(tag);
            }, /* @__PURE__ */ new Set());
          } else {
            this.voidTags = ["area", "base", "br", "col", "embed", "hr", "img", "input", "link", "meta", "param", "source", "track", "wbr"].reduce(function(set, tag) {
              return set.add(tag.toLowerCase()).add(tag.toUpperCase()).add(tag);
            }, /* @__PURE__ */ new Set());
          }
        }
        VoidTag2.prototype.formatNode = function(tag, attrs, innerHTML) {
          var addClosingSlash = this.addClosingSlash;
          var closingSpace = addClosingSlash && attrs && !attrs.endsWith(" ") ? " " : "";
          var closingSlash = addClosingSlash ? "".concat(closingSpace, "/") : "";
          return this.isVoidElement(tag.toLowerCase()) ? "<".concat(tag).concat(attrs).concat(closingSlash, ">") : "<".concat(tag).concat(attrs, ">").concat(innerHTML, "</").concat(tag, ">");
        };
        VoidTag2.prototype.isVoidElement = function(tag) {
          return this.voidTags.has(tag);
        };
        return VoidTag2;
      }()
    );
    exports.default = VoidTag;
  }
});

// node_modules/node-html-parser/dist/nodes/text.js
var require_text = __commonJS({
  "node_modules/node-html-parser/dist/nodes/text.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d2, b3) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b4) {
          d3.__proto__ = b4;
        } || function(d3, b4) {
          for (var p2 in b4)
            if (Object.prototype.hasOwnProperty.call(b4, p2))
              d3[p2] = b4[p2];
        };
        return extendStatics(d2, b3);
      };
      return function(d2, b3) {
        if (typeof b3 !== "function" && b3 !== null)
          throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
        extendStatics(d2, b3);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var he_1 = require_he();
    var node_1 = __importDefault(require_node());
    var type_1 = __importDefault(require_type());
    var TextNode2 = (
      /** @class */
      function(_super) {
        __extends(TextNode3, _super);
        function TextNode3(rawText, parentNode, range) {
          if (parentNode === void 0) {
            parentNode = null;
          }
          var _this = _super.call(this, parentNode, range) || this;
          _this.nodeType = type_1.default.TEXT_NODE;
          _this.rawTagName = "";
          _this._rawText = rawText;
          return _this;
        }
        TextNode3.prototype.clone = function() {
          return new TextNode3(this._rawText, null);
        };
        Object.defineProperty(TextNode3.prototype, "rawText", {
          get: function() {
            return this._rawText;
          },
          /**
           * Set rawText and invalidate trimmed caches
           */
          set: function(text) {
            this._rawText = text;
            this._trimmedRawText = void 0;
            this._trimmedText = void 0;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(TextNode3.prototype, "trimmedRawText", {
          /**
           * Returns raw text with all whitespace trimmed except single leading/trailing non-breaking space
           */
          get: function() {
            if (this._trimmedRawText !== void 0)
              return this._trimmedRawText;
            this._trimmedRawText = trimText(this.rawText);
            return this._trimmedRawText;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(TextNode3.prototype, "trimmedText", {
          /**
           * Returns text with all whitespace trimmed except single leading/trailing non-breaking space
           */
          get: function() {
            if (this._trimmedText !== void 0)
              return this._trimmedText;
            this._trimmedText = trimText(this.text);
            return this._trimmedText;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(TextNode3.prototype, "text", {
          /**
           * Get unescaped text value of current node and its children.
           * @return {string} text content
           */
          get: function() {
            return (0, he_1.decode)(this.rawText);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(TextNode3.prototype, "isWhitespace", {
          /**
           * Detect if the node contains only white space.
           * @return {boolean}
           */
          get: function() {
            return /^(\s|&nbsp;)*$/.test(this.rawText);
          },
          enumerable: false,
          configurable: true
        });
        TextNode3.prototype.toString = function() {
          return this.rawText;
        };
        return TextNode3;
      }(node_1.default)
    );
    exports.default = TextNode2;
    function trimText(text) {
      var i2 = 0;
      var startPos;
      var endPos;
      while (i2 >= 0 && i2 < text.length) {
        if (/\S/.test(text[i2])) {
          if (startPos === void 0) {
            startPos = i2;
            i2 = text.length;
          } else {
            endPos = i2;
            i2 = void 0;
          }
        }
        if (startPos === void 0)
          i2++;
        else
          i2--;
      }
      if (startPos === void 0)
        startPos = 0;
      if (endPos === void 0)
        endPos = text.length - 1;
      var hasLeadingSpace = startPos > 0 && /[^\S\r\n]/.test(text[startPos - 1]);
      var hasTrailingSpace = endPos < text.length - 1 && /[^\S\r\n]/.test(text[endPos + 1]);
      return (hasLeadingSpace ? " " : "") + text.slice(startPos, endPos + 1) + (hasTrailingSpace ? " " : "");
    }
  }
});

// node_modules/node-html-parser/dist/nodes/html.js
var require_html = __commonJS({
  "node_modules/node-html-parser/dist/nodes/html.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d2, b3) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b4) {
          d3.__proto__ = b4;
        } || function(d3, b4) {
          for (var p2 in b4)
            if (Object.prototype.hasOwnProperty.call(b4, p2))
              d3[p2] = b4[p2];
        };
        return extendStatics(d2, b3);
      };
      return function(d2, b3) {
        if (typeof b3 !== "function" && b3 !== null)
          throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
        extendStatics(d2, b3);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    var __spreadArray = exports && exports.__spreadArray || function(to2, from, pack) {
      if (pack || arguments.length === 2)
        for (var i2 = 0, l2 = from.length, ar3; i2 < l2; i2++) {
          if (ar3 || !(i2 in from)) {
            if (!ar3)
              ar3 = Array.prototype.slice.call(from, 0, i2);
            ar3[i2] = from[i2];
          }
        }
      return to2.concat(ar3 || Array.prototype.slice.call(from));
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = exports.base_parse = void 0;
    var css_select_1 = require_lib7();
    var he_1 = __importDefault(require_he());
    var back_1 = __importDefault(require_back());
    var matcher_1 = __importDefault(require_matcher());
    var void_tag_1 = __importDefault(require_void_tag());
    var comment_1 = __importDefault(require_comment());
    var node_1 = __importDefault(require_node());
    var text_1 = __importDefault(require_text());
    var type_1 = __importDefault(require_type());
    function decode(val) {
      return JSON.parse(JSON.stringify(he_1.default.decode(val)));
    }
    var Htags = ["h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup"];
    var Dtags = ["details", "dialog", "dd", "div", "dt"];
    var Ftags = ["fieldset", "figcaption", "figure", "footer", "form"];
    var tableTags = ["table", "td", "tr"];
    var htmlTags = ["address", "article", "aside", "blockquote", "br", "hr", "li", "main", "nav", "ol", "p", "pre", "section", "ul"];
    var kBlockElements = /* @__PURE__ */ new Set();
    function addToKBlockElement() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var addToSet = function(array) {
        for (var index = 0; index < array.length; index++) {
          var element = array[index];
          kBlockElements.add(element);
          kBlockElements.add(element.toUpperCase());
        }
      };
      for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
        var arg = args_1[_a];
        addToSet(arg);
      }
    }
    addToKBlockElement(Htags, Dtags, Ftags, tableTags, htmlTags);
    var DOMTokenList = (
      /** @class */
      function() {
        function DOMTokenList2(valuesInit, afterUpdate) {
          if (valuesInit === void 0) {
            valuesInit = [];
          }
          if (afterUpdate === void 0) {
            afterUpdate = function() {
              return null;
            };
          }
          this._set = new Set(valuesInit);
          this._afterUpdate = afterUpdate;
        }
        DOMTokenList2.prototype._validate = function(c2) {
          if (/\s/.test(c2)) {
            throw new Error("DOMException in DOMTokenList.add: The token '".concat(c2, "' contains HTML space characters, which are not valid in tokens."));
          }
        };
        DOMTokenList2.prototype.add = function(c2) {
          this._validate(c2);
          this._set.add(c2);
          this._afterUpdate(this);
        };
        DOMTokenList2.prototype.replace = function(c1, c2) {
          this._validate(c2);
          this._set.delete(c1);
          this._set.add(c2);
          this._afterUpdate(this);
        };
        DOMTokenList2.prototype.remove = function(c2) {
          this._set.delete(c2) && this._afterUpdate(this);
        };
        DOMTokenList2.prototype.toggle = function(c2) {
          this._validate(c2);
          if (this._set.has(c2))
            this._set.delete(c2);
          else
            this._set.add(c2);
          this._afterUpdate(this);
        };
        DOMTokenList2.prototype.contains = function(c2) {
          return this._set.has(c2);
        };
        Object.defineProperty(DOMTokenList2.prototype, "length", {
          get: function() {
            return this._set.size;
          },
          enumerable: false,
          configurable: true
        });
        DOMTokenList2.prototype.values = function() {
          return this._set.values();
        };
        Object.defineProperty(DOMTokenList2.prototype, "value", {
          get: function() {
            return Array.from(this._set.values());
          },
          enumerable: false,
          configurable: true
        });
        DOMTokenList2.prototype.toString = function() {
          return Array.from(this._set.values()).join(" ");
        };
        return DOMTokenList2;
      }()
    );
    var HTMLElement4 = (
      /** @class */
      function(_super) {
        __extends(HTMLElement5, _super);
        function HTMLElement5(tagName, keyAttrs, rawAttrs, parentNode, range, voidTag, _parseOptions) {
          if (rawAttrs === void 0) {
            rawAttrs = "";
          }
          if (parentNode === void 0) {
            parentNode = null;
          }
          if (voidTag === void 0) {
            voidTag = new void_tag_1.default();
          }
          if (_parseOptions === void 0) {
            _parseOptions = {};
          }
          var _this = _super.call(this, parentNode, range) || this;
          _this.rawAttrs = rawAttrs;
          _this.voidTag = voidTag;
          _this.nodeType = type_1.default.ELEMENT_NODE;
          _this.rawTagName = tagName;
          _this.rawAttrs = rawAttrs || "";
          _this.id = keyAttrs.id || "";
          _this.childNodes = [];
          _this._parseOptions = _parseOptions;
          _this.classList = new DOMTokenList(
            keyAttrs.class ? keyAttrs.class.split(/\s+/) : [],
            function(classList) {
              return _this.setAttribute("class", classList.toString());
            }
            // eslint-disable-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
          );
          if (keyAttrs.id) {
            if (!rawAttrs) {
              _this.rawAttrs = 'id="'.concat(keyAttrs.id, '"');
            }
          }
          if (keyAttrs.class) {
            if (!rawAttrs) {
              var cls = 'class="'.concat(_this.classList.toString(), '"');
              if (_this.rawAttrs) {
                _this.rawAttrs += " ".concat(cls);
              } else {
                _this.rawAttrs = cls;
              }
            }
          }
          return _this;
        }
        HTMLElement5.prototype.quoteAttribute = function(attr) {
          if (attr == null) {
            return "null";
          }
          return JSON.stringify(attr.replace(/"/g, "&quot;")).replace(/\\t/g, "	").replace(/\\n/g, "\n").replace(/\\r/g, "\r").replace(/\\/g, "");
        };
        HTMLElement5.prototype.removeChild = function(node) {
          this.childNodes = this.childNodes.filter(function(child) {
            return child !== node;
          });
          return this;
        };
        HTMLElement5.prototype.exchangeChild = function(oldNode, newNode) {
          var children = this.childNodes;
          this.childNodes = children.map(function(child) {
            if (child === oldNode) {
              return newNode;
            }
            return child;
          });
          return this;
        };
        Object.defineProperty(HTMLElement5.prototype, "tagName", {
          get: function() {
            return this.rawTagName ? this.rawTagName.toUpperCase() : this.rawTagName;
          },
          set: function(newname) {
            this.rawTagName = newname.toLowerCase();
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(HTMLElement5.prototype, "localName", {
          get: function() {
            return this.rawTagName.toLowerCase();
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(HTMLElement5.prototype, "isVoidElement", {
          get: function() {
            return this.voidTag.isVoidElement(this.localName);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(HTMLElement5.prototype, "rawText", {
          /**
           * Get escpaed (as-it) text value of current node and its children.
           * @return {string} text content
           */
          get: function() {
            if (/^br$/i.test(this.rawTagName)) {
              return "\n";
            }
            return this.childNodes.reduce(function(pre, cur) {
              return pre += cur.rawText;
            }, "");
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(HTMLElement5.prototype, "textContent", {
          get: function() {
            return decode(this.rawText);
          },
          set: function(val) {
            var content = [new text_1.default(val, this)];
            this.childNodes = content;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(HTMLElement5.prototype, "text", {
          /**
           * Get unescaped text value of current node and its children.
           * @return {string} text content
           */
          get: function() {
            return decode(this.rawText);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(HTMLElement5.prototype, "structuredText", {
          /**
           * Get structured Text (with '\n' etc.)
           * @return {string} structured text
           */
          get: function() {
            var currentBlock = [];
            var blocks = [currentBlock];
            function dfs(node) {
              if (node.nodeType === type_1.default.ELEMENT_NODE) {
                if (kBlockElements.has(node.rawTagName)) {
                  if (currentBlock.length > 0) {
                    blocks.push(currentBlock = []);
                  }
                  node.childNodes.forEach(dfs);
                  if (currentBlock.length > 0) {
                    blocks.push(currentBlock = []);
                  }
                } else {
                  node.childNodes.forEach(dfs);
                }
              } else if (node.nodeType === type_1.default.TEXT_NODE) {
                if (node.isWhitespace) {
                  currentBlock.prependWhitespace = true;
                } else {
                  var text = node.trimmedText;
                  if (currentBlock.prependWhitespace) {
                    text = " ".concat(text);
                    currentBlock.prependWhitespace = false;
                  }
                  currentBlock.push(text);
                }
              }
            }
            dfs(this);
            return blocks.map(function(block) {
              return block.join("").replace(/\s{2,}/g, " ");
            }).join("\n").replace(/\s+$/, "");
          },
          enumerable: false,
          configurable: true
        });
        HTMLElement5.prototype.toString = function() {
          var tag = this.rawTagName;
          if (tag) {
            var attrs = this.rawAttrs ? " ".concat(this.rawAttrs) : "";
            return this.voidTag.formatNode(tag, attrs, this.innerHTML);
          }
          return this.innerHTML;
        };
        Object.defineProperty(HTMLElement5.prototype, "innerHTML", {
          get: function() {
            return this.childNodes.map(function(child) {
              return child.toString();
            }).join("");
          },
          set: function(content) {
            var r2 = parse2(content, this._parseOptions);
            var nodes = r2.childNodes.length ? r2.childNodes : [new text_1.default(content, this)];
            resetParent(nodes, this);
            resetParent(this.childNodes, null);
            this.childNodes = nodes;
          },
          enumerable: false,
          configurable: true
        });
        HTMLElement5.prototype.set_content = function(content, options) {
          if (options === void 0) {
            options = {};
          }
          if (content instanceof node_1.default) {
            content = [content];
          } else if (typeof content == "string") {
            options = __assign(__assign({}, this._parseOptions), options);
            var r2 = parse2(content, options);
            content = r2.childNodes.length ? r2.childNodes : [new text_1.default(r2.innerHTML, this)];
          }
          resetParent(this.childNodes, null);
          resetParent(content, this);
          this.childNodes = content;
          return this;
        };
        HTMLElement5.prototype.replaceWith = function() {
          var _this = this;
          var nodes = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
          }
          var parent = this.parentNode;
          var content = nodes.map(function(node) {
            if (node instanceof node_1.default) {
              return [node];
            } else if (typeof node == "string") {
              var r2 = parse2(node, _this._parseOptions);
              return r2.childNodes.length ? r2.childNodes : [new text_1.default(node, _this)];
            }
            return [];
          }).flat();
          var idx = parent.childNodes.findIndex(function(child) {
            return child === _this;
          });
          resetParent([this], null);
          parent.childNodes = __spreadArray(__spreadArray(__spreadArray([], parent.childNodes.slice(0, idx), true), resetParent(content, parent), true), parent.childNodes.slice(idx + 1), true);
          return this;
        };
        Object.defineProperty(HTMLElement5.prototype, "outerHTML", {
          get: function() {
            return this.toString();
          },
          enumerable: false,
          configurable: true
        });
        HTMLElement5.prototype.trimRight = function(pattern) {
          for (var i2 = 0; i2 < this.childNodes.length; i2++) {
            var childNode = this.childNodes[i2];
            if (childNode.nodeType === type_1.default.ELEMENT_NODE) {
              childNode.trimRight(pattern);
            } else {
              var index = childNode.rawText.search(pattern);
              if (index > -1) {
                childNode.rawText = childNode.rawText.substr(0, index);
                this.childNodes.length = i2 + 1;
              }
            }
          }
          return this;
        };
        Object.defineProperty(HTMLElement5.prototype, "structure", {
          /**
           * Get DOM structure
           * @return {string} structure
           */
          get: function() {
            var res = [];
            var indention = 0;
            function write(str) {
              res.push("  ".repeat(indention) + str);
            }
            function dfs(node) {
              var idStr = node.id ? "#".concat(node.id) : "";
              var classStr = node.classList.length ? ".".concat(node.classList.value.join(".")) : "";
              write("".concat(node.rawTagName).concat(idStr).concat(classStr));
              indention++;
              node.childNodes.forEach(function(childNode) {
                if (childNode.nodeType === type_1.default.ELEMENT_NODE) {
                  dfs(childNode);
                } else if (childNode.nodeType === type_1.default.TEXT_NODE) {
                  if (!childNode.isWhitespace) {
                    write("#text");
                  }
                }
              });
              indention--;
            }
            dfs(this);
            return res.join("\n");
          },
          enumerable: false,
          configurable: true
        });
        HTMLElement5.prototype.removeWhitespace = function() {
          var _this = this;
          var o2 = 0;
          this.childNodes.forEach(function(node) {
            if (node.nodeType === type_1.default.TEXT_NODE) {
              if (node.isWhitespace) {
                return;
              }
              node.rawText = node.trimmedRawText;
            } else if (node.nodeType === type_1.default.ELEMENT_NODE) {
              node.removeWhitespace();
            }
            _this.childNodes[o2++] = node;
          });
          this.childNodes.length = o2;
          return this;
        };
        HTMLElement5.prototype.querySelectorAll = function(selector) {
          return (0, css_select_1.selectAll)(selector, this, {
            xmlMode: true,
            adapter: matcher_1.default
          });
        };
        HTMLElement5.prototype.querySelector = function(selector) {
          return (0, css_select_1.selectOne)(selector, this, {
            xmlMode: true,
            adapter: matcher_1.default
          });
        };
        HTMLElement5.prototype.getElementsByTagName = function(tagName) {
          var upperCasedTagName = tagName.toUpperCase();
          var re3 = [];
          var stack = [];
          var currentNodeReference = this;
          var index = 0;
          while (index !== void 0) {
            var child = void 0;
            do {
              child = currentNodeReference.childNodes[index++];
            } while (index < currentNodeReference.childNodes.length && child === void 0);
            if (child === void 0) {
              currentNodeReference = currentNodeReference.parentNode;
              index = stack.pop();
              continue;
            }
            if (child.nodeType === type_1.default.ELEMENT_NODE) {
              if (tagName === "*" || child.tagName === upperCasedTagName)
                re3.push(child);
              if (child.childNodes.length > 0) {
                stack.push(index);
                currentNodeReference = child;
                index = 0;
              }
            }
          }
          return re3;
        };
        HTMLElement5.prototype.getElementById = function(id) {
          var stack = [];
          var currentNodeReference = this;
          var index = 0;
          while (index !== void 0) {
            var child = void 0;
            do {
              child = currentNodeReference.childNodes[index++];
            } while (index < currentNodeReference.childNodes.length && child === void 0);
            if (child === void 0) {
              currentNodeReference = currentNodeReference.parentNode;
              index = stack.pop();
              continue;
            }
            if (child.nodeType === type_1.default.ELEMENT_NODE) {
              if (child.id === id) {
                return child;
              }
              ;
              if (child.childNodes.length > 0) {
                stack.push(index);
                currentNodeReference = child;
                index = 0;
              }
            }
          }
          return null;
        };
        HTMLElement5.prototype.closest = function(selector) {
          var mapChild = /* @__PURE__ */ new Map();
          var el2 = this;
          var old = null;
          function findOne(test, elems) {
            var elem = null;
            for (var i2 = 0, l2 = elems.length; i2 < l2 && !elem; i2++) {
              var el_1 = elems[i2];
              if (test(el_1)) {
                elem = el_1;
              } else {
                var child = mapChild.get(el_1);
                if (child) {
                  elem = findOne(test, [child]);
                }
              }
            }
            return elem;
          }
          while (el2) {
            mapChild.set(el2, old);
            old = el2;
            el2 = el2.parentNode;
          }
          el2 = this;
          while (el2) {
            var e2 = (0, css_select_1.selectOne)(selector, el2, {
              xmlMode: true,
              adapter: __assign(__assign({}, matcher_1.default), { getChildren: function(node) {
                var child = mapChild.get(node);
                return child && [child];
              }, getSiblings: function(node) {
                return [node];
              }, findOne, findAll: function() {
                return [];
              } })
            });
            if (e2) {
              return e2;
            }
            el2 = el2.parentNode;
          }
          return null;
        };
        HTMLElement5.prototype.appendChild = function(node) {
          node.remove();
          this.childNodes.push(node);
          node.parentNode = this;
          return node;
        };
        Object.defineProperty(HTMLElement5.prototype, "firstChild", {
          /**
           * Get first child node
           * @return {Node | undefined} first child node; or undefined if none
           */
          get: function() {
            return this.childNodes[0];
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(HTMLElement5.prototype, "lastChild", {
          /**
           * Get last child node
           * @return {Node | undefined} last child node; or undefined if none
           */
          get: function() {
            return (0, back_1.default)(this.childNodes);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(HTMLElement5.prototype, "attrs", {
          /**
           * Get attributes
           * @access private
           * @return {Object} parsed and unescaped attributes
           */
          get: function() {
            if (this._attrs) {
              return this._attrs;
            }
            this._attrs = {};
            var attrs = this.rawAttributes;
            for (var key in attrs) {
              var val = attrs[key] || "";
              this._attrs[key.toLowerCase()] = decode(val);
            }
            return this._attrs;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(HTMLElement5.prototype, "attributes", {
          get: function() {
            var ret_attrs = {};
            var attrs = this.rawAttributes;
            for (var key in attrs) {
              var val = attrs[key] || "";
              ret_attrs[key] = decode(val);
            }
            return ret_attrs;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(HTMLElement5.prototype, "rawAttributes", {
          /**
           * Get escaped (as-is) attributes
           * @return {Object} parsed attributes
           */
          get: function() {
            if (this._rawAttrs) {
              return this._rawAttrs;
            }
            var attrs = {};
            if (this.rawAttrs) {
              var re3 = /([a-zA-Z()[\]#@$.?:][a-zA-Z0-9-_:()[\]#]*)(?:\s*=\s*((?:'[^']*')|(?:"[^"]*")|\S+))?/g;
              var match = void 0;
              while (match = re3.exec(this.rawAttrs)) {
                var key = match[1];
                var val = match[2] || null;
                if (val && (val[0] === "'" || val[0] === '"'))
                  val = val.slice(1, val.length - 1);
                attrs[key] = attrs[key] || val;
              }
            }
            this._rawAttrs = attrs;
            return attrs;
          },
          enumerable: false,
          configurable: true
        });
        HTMLElement5.prototype.removeAttribute = function(key) {
          var _this = this;
          var attrs = this.rawAttributes;
          delete attrs[key];
          if (this._attrs) {
            delete this._attrs[key];
          }
          this.rawAttrs = Object.keys(attrs).map(function(name) {
            var val = _this.quoteAttribute(attrs[name]);
            if (val === "null" || val === '""')
              return name;
            return "".concat(name, "=").concat(val);
          }).join(" ");
          if (key === "id") {
            this.id = "";
          }
          return this;
        };
        HTMLElement5.prototype.hasAttribute = function(key) {
          return key.toLowerCase() in this.attrs;
        };
        HTMLElement5.prototype.getAttribute = function(key) {
          return this.attrs[key.toLowerCase()];
        };
        HTMLElement5.prototype.setAttribute = function(key, value) {
          var _this = this;
          if (arguments.length < 2) {
            throw new Error("Failed to execute 'setAttribute' on 'Element'");
          }
          var k2 = key.toLowerCase();
          var attrs = this.rawAttributes;
          for (var k in attrs) {
            if (k.toLowerCase() === k2) {
              key = k;
              break;
            }
          }
          attrs[key] = String(value);
          if (this._attrs) {
            this._attrs[k2] = decode(attrs[key]);
          }
          this.rawAttrs = Object.keys(attrs).map(function(name) {
            var val = _this.quoteAttribute(attrs[name]);
            if (val === "null" || val === '""')
              return name;
            return "".concat(name, "=").concat(val);
          }).join(" ");
          if (key === "id") {
            this.id = value;
          }
          return this;
        };
        HTMLElement5.prototype.setAttributes = function(attributes) {
          var _this = this;
          if (this._attrs) {
            delete this._attrs;
          }
          if (this._rawAttrs) {
            delete this._rawAttrs;
          }
          this.rawAttrs = Object.keys(attributes).map(function(name) {
            var val = attributes[name];
            if (val === "null" || val === '""')
              return name;
            return "".concat(name, "=").concat(_this.quoteAttribute(String(val)));
          }).join(" ");
          return this;
        };
        HTMLElement5.prototype.insertAdjacentHTML = function(where, html) {
          var _a, _b, _c;
          var _this = this;
          if (arguments.length < 2) {
            throw new Error("2 arguments required");
          }
          var p2 = parse2(html, this._parseOptions);
          if (where === "afterend") {
            var idx = this.parentNode.childNodes.findIndex(function(child) {
              return child === _this;
            });
            resetParent(p2.childNodes, this.parentNode);
            (_a = this.parentNode.childNodes).splice.apply(_a, __spreadArray([idx + 1, 0], p2.childNodes, false));
          } else if (where === "afterbegin") {
            resetParent(p2.childNodes, this);
            (_b = this.childNodes).unshift.apply(_b, p2.childNodes);
          } else if (where === "beforeend") {
            p2.childNodes.forEach(function(n2) {
              _this.appendChild(n2);
            });
          } else if (where === "beforebegin") {
            var idx = this.parentNode.childNodes.findIndex(function(child) {
              return child === _this;
            });
            resetParent(p2.childNodes, this.parentNode);
            (_c = this.parentNode.childNodes).splice.apply(_c, __spreadArray([idx, 0], p2.childNodes, false));
          } else {
            throw new Error("The value provided ('".concat(where, "') is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'"));
          }
          return this;
        };
        Object.defineProperty(HTMLElement5.prototype, "nextSibling", {
          get: function() {
            if (this.parentNode) {
              var children = this.parentNode.childNodes;
              var i2 = 0;
              while (i2 < children.length) {
                var child = children[i2++];
                if (this === child)
                  return children[i2] || null;
              }
              return null;
            }
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(HTMLElement5.prototype, "nextElementSibling", {
          get: function() {
            if (this.parentNode) {
              var children = this.parentNode.childNodes;
              var i2 = 0;
              var find = false;
              while (i2 < children.length) {
                var child = children[i2++];
                if (find) {
                  if (child instanceof HTMLElement5) {
                    return child || null;
                  }
                } else if (this === child) {
                  find = true;
                }
              }
              return null;
            }
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(HTMLElement5.prototype, "previousSibling", {
          get: function() {
            if (this.parentNode) {
              var children = this.parentNode.childNodes;
              var i2 = children.length;
              while (i2 > 0) {
                var child = children[--i2];
                if (this === child)
                  return children[i2 - 1] || null;
              }
              return null;
            }
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(HTMLElement5.prototype, "previousElementSibling", {
          get: function() {
            if (this.parentNode) {
              var children = this.parentNode.childNodes;
              var i2 = children.length;
              var find = false;
              while (i2 > 0) {
                var child = children[--i2];
                if (find) {
                  if (child instanceof HTMLElement5) {
                    return child || null;
                  }
                } else if (this === child) {
                  find = true;
                }
              }
              return null;
            }
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(HTMLElement5.prototype, "classNames", {
          get: function() {
            return this.classList.toString();
          },
          enumerable: false,
          configurable: true
        });
        HTMLElement5.prototype.clone = function() {
          return parse2(this.toString(), this._parseOptions).firstChild;
        };
        return HTMLElement5;
      }(node_1.default)
    );
    exports.default = HTMLElement4;
    var kMarkupPattern = /<!--[\s\S]*?-->|<(\/?)([a-zA-Z][-.:0-9_a-zA-Z]*)((?:\s+[^>]*?(?:(?:'[^']*')|(?:"[^"]*"))?)*)\s*(\/?)>/g;
    var kAttributePattern = /(?:^|\s)(id|class)\s*=\s*((?:'[^']*')|(?:"[^"]*")|\S+)/gi;
    var kElementsClosedByOpening = {
      li: { li: true, LI: true },
      LI: { li: true, LI: true },
      p: { p: true, div: true, P: true, DIV: true },
      P: { p: true, div: true, P: true, DIV: true },
      b: { div: true, DIV: true },
      B: { div: true, DIV: true },
      td: { td: true, th: true, TD: true, TH: true },
      TD: { td: true, th: true, TD: true, TH: true },
      th: { td: true, th: true, TD: true, TH: true },
      TH: { td: true, th: true, TD: true, TH: true },
      h1: { h1: true, H1: true },
      H1: { h1: true, H1: true },
      h2: { h2: true, H2: true },
      H2: { h2: true, H2: true },
      h3: { h3: true, H3: true },
      H3: { h3: true, H3: true },
      h4: { h4: true, H4: true },
      H4: { h4: true, H4: true },
      h5: { h5: true, H5: true },
      H5: { h5: true, H5: true },
      h6: { h6: true, H6: true },
      H6: { h6: true, H6: true }
    };
    var kElementsClosedByClosing = {
      li: { ul: true, ol: true, UL: true, OL: true },
      LI: { ul: true, ol: true, UL: true, OL: true },
      a: { div: true, DIV: true },
      A: { div: true, DIV: true },
      b: { div: true, DIV: true },
      B: { div: true, DIV: true },
      i: { div: true, DIV: true },
      I: { div: true, DIV: true },
      p: { div: true, DIV: true },
      P: { div: true, DIV: true },
      td: { tr: true, table: true, TR: true, TABLE: true },
      TD: { tr: true, table: true, TR: true, TABLE: true },
      th: { tr: true, table: true, TR: true, TABLE: true },
      TH: { tr: true, table: true, TR: true, TABLE: true }
    };
    var frameflag = "documentfragmentcontainer";
    function base_parse(data, options) {
      var _a, _b;
      if (options === void 0) {
        options = {};
      }
      var voidTag = new void_tag_1.default((_a = options === null || options === void 0 ? void 0 : options.voidTag) === null || _a === void 0 ? void 0 : _a.closingSlash, (_b = options === null || options === void 0 ? void 0 : options.voidTag) === null || _b === void 0 ? void 0 : _b.tags);
      var elements = options.blockTextElements || {
        script: true,
        noscript: true,
        style: true,
        pre: true
      };
      var element_names = Object.keys(elements);
      var kBlockTextElements = element_names.map(function(it3) {
        return new RegExp("^".concat(it3, "$"), "i");
      });
      var kIgnoreElements = element_names.filter(function(it3) {
        return Boolean(elements[it3]);
      }).map(function(it3) {
        return new RegExp("^".concat(it3, "$"), "i");
      });
      function element_should_be_ignore(tag) {
        return kIgnoreElements.some(function(it3) {
          return it3.test(tag);
        });
      }
      function is_block_text_element(tag) {
        return kBlockTextElements.some(function(it3) {
          return it3.test(tag);
        });
      }
      var createRange = function(startPos, endPos) {
        return [startPos - frameFlagOffset, endPos - frameFlagOffset];
      };
      var root = new HTMLElement4(null, {}, "", null, [0, data.length], voidTag, options);
      var currentParent = root;
      var stack = [root];
      var lastTextPos = -1;
      var noNestedTagIndex = void 0;
      var match;
      data = "<".concat(frameflag, ">").concat(data, "</").concat(frameflag, ">");
      var lowerCaseTagName = options.lowerCaseTagName, fixNestedATags = options.fixNestedATags;
      var dataEndPos = data.length - (frameflag.length + 2);
      var frameFlagOffset = frameflag.length + 2;
      while (match = kMarkupPattern.exec(data)) {
        var matchText = match[0], leadingSlash = match[1], tagName = match[2], attributes = match[3], closingSlash = match[4];
        var matchLength = matchText.length;
        var tagStartPos = kMarkupPattern.lastIndex - matchLength;
        var tagEndPos = kMarkupPattern.lastIndex;
        if (lastTextPos > -1) {
          if (lastTextPos + matchLength < tagEndPos) {
            var text = data.substring(lastTextPos, tagStartPos);
            currentParent.appendChild(new text_1.default(text, currentParent, createRange(lastTextPos, tagStartPos)));
          }
        }
        lastTextPos = kMarkupPattern.lastIndex;
        if (tagName === frameflag)
          continue;
        if (matchText[1] === "!") {
          if (options.comment) {
            var text = data.substring(tagStartPos + 4, tagEndPos - 3);
            currentParent.appendChild(new comment_1.default(text, currentParent, createRange(tagStartPos, tagEndPos)));
          }
          continue;
        }
        if (lowerCaseTagName)
          tagName = tagName.toLowerCase();
        if (!leadingSlash) {
          var attrs = {};
          for (var attMatch = void 0; attMatch = kAttributePattern.exec(attributes); ) {
            var key = attMatch[1], val = attMatch[2];
            var isQuoted = val[0] === "'" || val[0] === '"';
            attrs[key.toLowerCase()] = isQuoted ? val.slice(1, val.length - 1) : val;
          }
          var parentTagName = currentParent.rawTagName;
          if (!closingSlash && kElementsClosedByOpening[parentTagName]) {
            if (kElementsClosedByOpening[parentTagName][tagName]) {
              stack.pop();
              currentParent = (0, back_1.default)(stack);
            }
          }
          if (fixNestedATags && (tagName === "a" || tagName === "A")) {
            if (noNestedTagIndex !== void 0) {
              stack.splice(noNestedTagIndex);
              currentParent = (0, back_1.default)(stack);
            }
            noNestedTagIndex = stack.length;
          }
          var tagEndPos_1 = kMarkupPattern.lastIndex;
          var tagStartPos_1 = tagEndPos_1 - matchLength;
          currentParent = currentParent.appendChild(
            // Initialize range (end position updated later for closed tags)
            new HTMLElement4(tagName, attrs, attributes.slice(1), null, createRange(tagStartPos_1, tagEndPos_1), voidTag, options)
          );
          stack.push(currentParent);
          if (is_block_text_element(tagName)) {
            var closeMarkup = "</".concat(tagName, ">");
            var closeIndex = lowerCaseTagName ? data.toLocaleLowerCase().indexOf(closeMarkup, kMarkupPattern.lastIndex) : data.indexOf(closeMarkup, kMarkupPattern.lastIndex);
            var textEndPos = closeIndex === -1 ? dataEndPos : closeIndex;
            if (element_should_be_ignore(tagName)) {
              var text = data.substring(tagEndPos_1, textEndPos);
              if (text.length > 0 && /\S/.test(text)) {
                currentParent.appendChild(new text_1.default(text, currentParent, createRange(tagEndPos_1, textEndPos)));
              }
            }
            if (closeIndex === -1) {
              lastTextPos = kMarkupPattern.lastIndex = data.length + 1;
            } else {
              lastTextPos = kMarkupPattern.lastIndex = closeIndex + closeMarkup.length;
              leadingSlash = "/";
            }
          }
        }
        if (leadingSlash || closingSlash || voidTag.isVoidElement(tagName)) {
          while (true) {
            if (noNestedTagIndex != null && (tagName === "a" || tagName === "A"))
              noNestedTagIndex = void 0;
            if (currentParent.rawTagName === tagName) {
              currentParent.range[1] = createRange(-1, Math.max(lastTextPos, tagEndPos))[1];
              stack.pop();
              currentParent = (0, back_1.default)(stack);
              break;
            } else {
              var parentTagName = currentParent.tagName;
              if (kElementsClosedByClosing[parentTagName]) {
                if (kElementsClosedByClosing[parentTagName][tagName]) {
                  stack.pop();
                  currentParent = (0, back_1.default)(stack);
                  continue;
                }
              }
              break;
            }
          }
        }
      }
      return stack;
    }
    exports.base_parse = base_parse;
    function parse2(data, options) {
      if (options === void 0) {
        options = {};
      }
      var stack = base_parse(data, options);
      var root = stack[0];
      var _loop_1 = function() {
        var last = stack.pop();
        var oneBefore = (0, back_1.default)(stack);
        if (last.parentNode && last.parentNode.parentNode) {
          if (last.parentNode === oneBefore && last.tagName === oneBefore.tagName) {
            if (options.parseNoneClosedTags !== true) {
              oneBefore.removeChild(last);
              last.childNodes.forEach(function(child) {
                oneBefore.parentNode.appendChild(child);
              });
              stack.pop();
            }
          } else {
            if (options.parseNoneClosedTags !== true) {
              oneBefore.removeChild(last);
              last.childNodes.forEach(function(child) {
                oneBefore.appendChild(child);
              });
            }
          }
        } else {
        }
      };
      while (stack.length > 1) {
        _loop_1();
      }
      return root;
    }
    exports.parse = parse2;
    function resetParent(nodes, parent) {
      return nodes.map(function(node) {
        node.parentNode = parent;
        return node;
      });
    }
  }
});

// node_modules/node-html-parser/dist/parse.js
var require_parse2 = __commonJS({
  "node_modules/node-html-parser/dist/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = void 0;
    var html_1 = require_html();
    Object.defineProperty(exports, "default", { enumerable: true, get: function() {
      return html_1.parse;
    } });
  }
});

// node_modules/node-html-parser/dist/valid.js
var require_valid = __commonJS({
  "node_modules/node-html-parser/dist/valid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var html_1 = require_html();
    function valid(data, options) {
      if (options === void 0) {
        options = {};
      }
      var stack = (0, html_1.base_parse)(data, options);
      return Boolean(stack.length === 1);
    }
    exports.default = valid;
  }
});

// node_modules/node-html-parser/dist/index.js
var require_dist = __commonJS({
  "node_modules/node-html-parser/dist/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NodeType = exports.TextNode = exports.Node = exports.valid = exports.CommentNode = exports.HTMLElement = exports.parse = void 0;
    var comment_1 = __importDefault(require_comment());
    exports.CommentNode = comment_1.default;
    var html_1 = __importDefault(require_html());
    exports.HTMLElement = html_1.default;
    var node_1 = __importDefault(require_node());
    exports.Node = node_1.default;
    var text_1 = __importDefault(require_text());
    exports.TextNode = text_1.default;
    var type_1 = __importDefault(require_type());
    exports.NodeType = type_1.default;
    var parse_1 = __importDefault(require_parse2());
    var valid_1 = __importDefault(require_valid());
    exports.valid = valid_1.default;
    function parse2(data, options) {
      if (options === void 0) {
        options = {};
      }
      return (0, parse_1.default)(data, options);
    }
    exports.default = parse2;
    exports.parse = parse2;
    parse2.parse = parse_1.default;
    parse2.HTMLElement = html_1.default;
    parse2.CommentNode = comment_1.default;
    parse2.valid = valid_1.default;
    parse2.Node = node_1.default;
    parse2.TextNode = text_1.default;
    parse2.NodeType = type_1.default;
  }
});

// node_modules/inline-style-parser/index.js
var require_inline_style_parser = __commonJS({
  "node_modules/inline-style-parser/index.js"(exports, module) {
    var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
    var NEWLINE_REGEX = /\n/g;
    var WHITESPACE_REGEX = /^\s*/;
    var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
    var COLON_REGEX = /^:\s*/;
    var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
    var SEMICOLON_REGEX = /^[;\s]*/;
    var TRIM_REGEX = /^\s+|\s+$/g;
    var NEWLINE = "\n";
    var FORWARD_SLASH = "/";
    var ASTERISK = "*";
    var EMPTY_STRING = "";
    var TYPE_COMMENT = "comment";
    var TYPE_DECLARATION = "declaration";
    module.exports = function(style, options) {
      if (typeof style !== "string") {
        throw new TypeError("First argument must be a string");
      }
      if (!style)
        return [];
      options = options || {};
      var lineno = 1;
      var column = 1;
      function updatePosition(str) {
        var lines = str.match(NEWLINE_REGEX);
        if (lines)
          lineno += lines.length;
        var i2 = str.lastIndexOf(NEWLINE);
        column = ~i2 ? str.length - i2 : column + str.length;
      }
      function position() {
        var start = { line: lineno, column };
        return function(node) {
          node.position = new Position(start);
          whitespace();
          return node;
        };
      }
      function Position(start) {
        this.start = start;
        this.end = { line: lineno, column };
        this.source = options.source;
      }
      Position.prototype.content = style;
      var errorsList = [];
      function error(msg) {
        var err = new Error(
          options.source + ":" + lineno + ":" + column + ": " + msg
        );
        err.reason = msg;
        err.filename = options.source;
        err.line = lineno;
        err.column = column;
        err.source = style;
        if (options.silent) {
          errorsList.push(err);
        } else {
          throw err;
        }
      }
      function match(re3) {
        var m = re3.exec(style);
        if (!m)
          return;
        var str = m[0];
        updatePosition(str);
        style = style.slice(str.length);
        return m;
      }
      function whitespace() {
        match(WHITESPACE_REGEX);
      }
      function comments(rules) {
        var c2;
        rules = rules || [];
        while (c2 = comment()) {
          if (c2 !== false) {
            rules.push(c2);
          }
        }
        return rules;
      }
      function comment() {
        var pos = position();
        if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1))
          return;
        var i2 = 2;
        while (EMPTY_STRING != style.charAt(i2) && (ASTERISK != style.charAt(i2) || FORWARD_SLASH != style.charAt(i2 + 1))) {
          ++i2;
        }
        i2 += 2;
        if (EMPTY_STRING === style.charAt(i2 - 1)) {
          return error("End of comment missing");
        }
        var str = style.slice(2, i2 - 2);
        column += 2;
        updatePosition(str);
        style = style.slice(i2);
        column += 2;
        return pos({
          type: TYPE_COMMENT,
          comment: str
        });
      }
      function declaration() {
        var pos = position();
        var prop = match(PROPERTY_REGEX);
        if (!prop)
          return;
        comment();
        if (!match(COLON_REGEX))
          return error("property missing ':'");
        var val = match(VALUE_REGEX);
        var ret = pos({
          type: TYPE_DECLARATION,
          property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
          value: val ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
        });
        match(SEMICOLON_REGEX);
        return ret;
      }
      function declarations() {
        var decls = [];
        comments(decls);
        var decl;
        while (decl = declaration()) {
          if (decl !== false) {
            decls.push(decl);
            comments(decls);
          }
        }
        return decls;
      }
      whitespace();
      return declarations();
    };
    function trim(str) {
      return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
    }
  }
});

// node_modules/@react-three/uikit/node_modules/prettier/plugins/babel.js
var require_babel = __commonJS({
  "node_modules/@react-three/uikit/node_modules/prettier/plugins/babel.js"(exports, module) {
    (function(f2) {
      function e2() {
        var i2 = f2();
        return i2.default || i2;
      }
      if (typeof exports == "object" && typeof module == "object")
        module.exports = e2();
      else if (typeof define == "function" && define.amd)
        define(e2);
      else {
        var t2 = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
        t2.prettierPlugins = t2.prettierPlugins || {}, t2.prettierPlugins.babel = e2();
      }
    })(function() {
      "use strict";
      var $s2 = Object.create;
      var Se3 = Object.defineProperty;
      var Vs2 = Object.getOwnPropertyDescriptor;
      var qs2 = Object.getOwnPropertyNames;
      var zs2 = Object.getPrototypeOf, Ks = Object.prototype.hasOwnProperty;
      var Hs2 = (a2, t2) => () => (t2 || a2((t2 = { exports: {} }).exports, t2), t2.exports), Ws2 = (a2, t2) => {
        for (var e2 in t2)
          Se3(a2, e2, { get: t2[e2], enumerable: true });
      }, kt3 = (a2, t2, e2, s2) => {
        if (t2 && typeof t2 == "object" || typeof t2 == "function")
          for (let i2 of qs2(t2))
            !Ks.call(a2, i2) && i2 !== e2 && Se3(a2, i2, { get: () => t2[i2], enumerable: !(s2 = Vs2(t2, i2)) || s2.enumerable });
        return a2;
      };
      var vt2 = (a2, t2, e2) => (e2 = a2 != null ? $s2(zs2(a2)) : {}, kt3(t2 || !a2 || !a2.__esModule ? Se3(e2, "default", { value: a2, enumerable: true }) : e2, a2)), Js2 = (a2) => kt3(Se3({}, "__esModule", { value: true }), a2);
      var At3 = Hs2((xe3) => {
        "use strict";
        Object.defineProperty(xe3, "__esModule", { value: true });
        function Ht2(a2, t2) {
          if (a2 == null)
            return {};
          var e2 = {}, s2 = Object.keys(a2), i2, r2;
          for (r2 = 0; r2 < s2.length; r2++)
            i2 = s2[r2], !(t2.indexOf(i2) >= 0) && (e2[i2] = a2[i2]);
          return e2;
        }
        var F = class {
          constructor(t2, e2, s2) {
            this.line = void 0, this.column = void 0, this.index = void 0, this.line = t2, this.column = e2, this.index = s2;
          }
        }, ee3 = class {
          constructor(t2, e2) {
            this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = t2, this.end = e2;
          }
        };
        function v2(a2, t2) {
          let { line: e2, column: s2, index: i2 } = a2;
          return new F(e2, s2 + t2, i2 + t2);
        }
        var Lt2 = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", Xs2 = { ImportMetaOutsideModule: { message: `import.meta may appear only with 'sourceType: "module"'`, code: Lt2 }, ImportOutsideModule: { message: `'import' and 'export' may appear only with 'sourceType: "module"'`, code: Lt2 } }, Dt2 = { ArrayPattern: "array destructuring pattern", AssignmentExpression: "assignment expression", AssignmentPattern: "assignment expression", ArrowFunctionExpression: "arrow function expression", ConditionalExpression: "conditional expression", CatchClause: "catch clause", ForOfStatement: "for-of statement", ForInStatement: "for-in statement", ForStatement: "for-loop", FormalParameters: "function parameter list", Identifier: "identifier", ImportSpecifier: "import specifier", ImportDefaultSpecifier: "import default specifier", ImportNamespaceSpecifier: "import namespace specifier", ObjectPattern: "object destructuring pattern", ParenthesizedExpression: "parenthesized expression", RestElement: "rest element", UpdateExpression: { true: "prefix operation", false: "postfix operation" }, VariableDeclarator: "variable declaration", YieldExpression: "yield expression" }, Ee2 = (a2) => a2.type === "UpdateExpression" ? Dt2.UpdateExpression[`${a2.prefix}`] : Dt2[a2.type], Gs2 = { AccessorIsGenerator: ({ kind: a2 }) => `A ${a2}ter cannot be a generator.`, ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accessor must not have any formal parameters.", BadSetterArity: "A 'set' accessor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: ({ kind: a2 }) => `Missing initializer in ${a2} declaration.`, DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.", DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.', DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: ({ exportName: a2 }) => `\`${a2}\` has already been exported. Exported identifiers must be unique.`, DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", DynamicImportPhaseRequiresImportExpressions: ({ phase: a2 }) => `'import.${a2}(...)' can only be parsed when using the 'createImportExpressions' option.`, ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: ({ localName: a2, exportName: t2 }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${a2}' as '${t2}' } from 'some-module'\`?`, ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: ({ type: a2 }) => `'${a2 === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, ForInUsing: "For-in loop may not start with 'using' declaration.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: ({ type: a2 }) => `Unsyntactic ${a2 === "BreakStatement" ? "break" : "continue"}.`, IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.", ImportBindingIsString: ({ importName: a2 }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${a2}" as foo }\`?`, ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.", ImportCallArity: ({ maxArgumentCount: a2 }) => `\`import()\` requires exactly ${a2 === 1 ? "one argument" : "one or two arguments"}.`, ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.", ImportReflectionHasAssertion: "`import module x` cannot have assertions.", ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.', IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidCoverInitializedName: "Invalid shorthand property initializer.", InvalidDecimal: "Invalid decimal.", InvalidDigit: ({ radix: a2 }) => `Expected number in radix ${a2}.`, InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: ({ reservedWord: a2 }) => `Escape sequence in keyword ${a2}.`, InvalidIdentifier: ({ identifierName: a2 }) => `Invalid identifier ${a2}.`, InvalidLhs: ({ ancestor: a2 }) => `Invalid left-hand side in ${Ee2(a2)}.`, InvalidLhsBinding: ({ ancestor: a2 }) => `Binding invalid left-hand side in ${Ee2(a2)}.`, InvalidLhsOptionalChaining: ({ ancestor: a2 }) => `Invalid optional chaining in the left-hand side of ${Ee2(a2)}.`, InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: ({ unexpected: a2 }) => `Unexpected character '${a2}'.`, InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: ({ identifierName: a2 }) => `Private name #${a2} is not defined.`, InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: ({ labelName: a2 }) => `Label '${a2}' is already declared.`, LetInLexicalBinding: "'let' is disallowed as a lexically bound name.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingPlugin: ({ missingPlugin: a2 }) => `This experimental syntax requires enabling the parser plugin: ${a2.map((t2) => JSON.stringify(t2)).join(", ")}.`, MissingOneOfPlugins: ({ missingPlugin: a2 }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${a2.map((t2) => JSON.stringify(t2)).join(", ")}.`, MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: ({ key: a2 }) => `Duplicate key "${a2}" is not allowed in module attributes.`, ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode: a2 }) => `An export name cannot include a lone surrogate, found '\\u${a2.toString(16)}'.`, ModuleExportUndefined: ({ localName: a2 }) => `Export '${a2}' is not defined.`, MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PrivateInExpectedIn: ({ identifierName: a2 }) => `Private names are only allowed in property accesses (\`obj.#${a2}\`) or in \`in\` expressions (\`#${a2} in obj\`).`, PrivateNameRedeclaration: ({ identifierName: a2 }) => `Duplicate private name #${a2}.`, RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.", SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.', StaticPrototype: "Classes may not have static property named prototype.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: ({ keyword: a2 }) => `Unexpected keyword '${a2}'.`, UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Unexpected private name.", UnexpectedReservedWord: ({ reservedWord: a2 }) => `Unexpected reserved word '${a2}'.`, UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: ({ expected: a2, unexpected: t2 }) => `Unexpected token${t2 ? ` '${t2}'.` : ""}${a2 ? `, expected "${a2}"` : ""}`, UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: ({ target: a2, onlyValidPropertyName: t2 }) => `The only valid meta property for ${a2} is ${a2}.${t2}.`, UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", UsingDeclarationExport: "Using declaration cannot be exported.", UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.", VarRedeclaration: ({ identifierName: a2 }) => `Identifier '${a2}' has already been declared.`, YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." }, Ys2 = { StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: ({ referenceName: a2 }) => `Assigning to '${a2}' in strict mode.`, StrictEvalArgumentsBinding: ({ bindingName: a2 }) => `Binding '${a2}' in strict mode.`, StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode." }, Qs2 = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), Zs = { PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: ({ token: a2 }) => `Invalid topic token ${a2}. In order to use ${a2} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${a2}" }.`, PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipeUnparenthesizedBody: ({ type: a2 }) => `Hack-style pipe body cannot be an unparenthesized ${Ee2({ type: a2 })}; please wrap it in parentheses.`, PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.' }, ei3 = ["toMessage"], ti2 = ["message"];
        function Mt2(a2, t2, e2) {
          Object.defineProperty(a2, t2, { enumerable: false, configurable: true, value: e2 });
        }
        function si2(a2) {
          let { toMessage: t2 } = a2, e2 = Ht2(a2, ei3);
          return function s2(i2, r2) {
            let n2 = new SyntaxError();
            return Object.assign(n2, e2, { loc: i2, pos: i2.index }), "missingPlugin" in r2 && Object.assign(n2, { missingPlugin: r2.missingPlugin }), Mt2(n2, "clone", function(h2 = {}) {
              var c2;
              let { line: l2, column: u2, index: f2 } = (c2 = h2.loc) != null ? c2 : i2;
              return s2(new F(l2, u2, f2), Object.assign({}, r2, h2.details));
            }), Mt2(n2, "details", r2), Object.defineProperty(n2, "message", { configurable: true, get() {
              let o2 = `${t2(r2)} (${i2.line}:${i2.column})`;
              return this.message = o2, o2;
            }, set(o2) {
              Object.defineProperty(this, "message", { value: o2, writable: true });
            } }), n2;
          };
        }
        function j2(a2, t2) {
          if (Array.isArray(a2))
            return (s2) => j2(s2, a2[0]);
          let e2 = {};
          for (let s2 of Object.keys(a2)) {
            let i2 = a2[s2], r2 = typeof i2 == "string" ? { message: () => i2 } : typeof i2 == "function" ? { message: i2 } : i2, { message: n2 } = r2, o2 = Ht2(r2, ti2), h2 = typeof n2 == "string" ? () => n2 : n2;
            e2[s2] = si2(Object.assign({ code: "BABEL_PARSER_SYNTAX_ERROR", reasonCode: s2, toMessage: h2 }, t2 ? { syntaxPlugin: t2 } : {}, o2));
          }
          return e2;
        }
        var p2 = Object.assign({}, j2(Xs2), j2(Gs2), j2(Ys2), j2`pipelineOperator`(Zs)), { defineProperty: ii2 } = Object, Ot2 = (a2, t2) => {
          a2 && ii2(a2, t2, { enumerable: false, value: a2[t2] });
        };
        function oe3(a2) {
          return Ot2(a2.loc.start, "index"), Ot2(a2.loc.end, "index"), a2;
        }
        var ri3 = (a2) => class extends a2 {
          parse() {
            let e2 = oe3(super.parse());
            return this.options.tokens && (e2.tokens = e2.tokens.map(oe3)), e2;
          }
          parseRegExpLiteral({ pattern: e2, flags: s2 }) {
            let i2 = null;
            try {
              i2 = new RegExp(e2, s2);
            } catch {
            }
            let r2 = this.estreeParseLiteral(i2);
            return r2.regex = { pattern: e2, flags: s2 }, r2;
          }
          parseBigIntLiteral(e2) {
            let s2;
            try {
              s2 = BigInt(e2);
            } catch {
              s2 = null;
            }
            let i2 = this.estreeParseLiteral(s2);
            return i2.bigint = String(i2.value || e2), i2;
          }
          parseDecimalLiteral(e2) {
            let i2 = this.estreeParseLiteral(null);
            return i2.decimal = String(i2.value || e2), i2;
          }
          estreeParseLiteral(e2) {
            return this.parseLiteral(e2, "Literal");
          }
          parseStringLiteral(e2) {
            return this.estreeParseLiteral(e2);
          }
          parseNumericLiteral(e2) {
            return this.estreeParseLiteral(e2);
          }
          parseNullLiteral() {
            return this.estreeParseLiteral(null);
          }
          parseBooleanLiteral(e2) {
            return this.estreeParseLiteral(e2);
          }
          directiveToStmt(e2) {
            let s2 = e2.value;
            delete e2.value, s2.type = "Literal", s2.raw = s2.extra.raw, s2.value = s2.extra.expressionValue;
            let i2 = e2;
            return i2.type = "ExpressionStatement", i2.expression = s2, i2.directive = s2.extra.rawValue, delete s2.extra, i2;
          }
          initFunction(e2, s2) {
            super.initFunction(e2, s2), e2.expression = false;
          }
          checkDeclaration(e2) {
            e2 != null && this.isObjectProperty(e2) ? this.checkDeclaration(e2.value) : super.checkDeclaration(e2);
          }
          getObjectOrClassMethodParams(e2) {
            return e2.value.params;
          }
          isValidDirective(e2) {
            var s2;
            return e2.type === "ExpressionStatement" && e2.expression.type === "Literal" && typeof e2.expression.value == "string" && !((s2 = e2.expression.extra) != null && s2.parenthesized);
          }
          parseBlockBody(e2, s2, i2, r2, n2) {
            super.parseBlockBody(e2, s2, i2, r2, n2);
            let o2 = e2.directives.map((h2) => this.directiveToStmt(h2));
            e2.body = o2.concat(e2.body), delete e2.directives;
          }
          pushClassMethod(e2, s2, i2, r2, n2, o2) {
            this.parseMethod(s2, i2, r2, n2, o2, "ClassMethod", true), s2.typeParameters && (s2.value.typeParameters = s2.typeParameters, delete s2.typeParameters), e2.body.push(s2);
          }
          parsePrivateName() {
            let e2 = super.parsePrivateName();
            return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(e2) : e2;
          }
          convertPrivateNameToPrivateIdentifier(e2) {
            let s2 = super.getPrivateNameSV(e2);
            return e2 = e2, delete e2.id, e2.name = s2, e2.type = "PrivateIdentifier", e2;
          }
          isPrivateName(e2) {
            return this.getPluginOption("estree", "classFeatures") ? e2.type === "PrivateIdentifier" : super.isPrivateName(e2);
          }
          getPrivateNameSV(e2) {
            return this.getPluginOption("estree", "classFeatures") ? e2.name : super.getPrivateNameSV(e2);
          }
          parseLiteral(e2, s2) {
            let i2 = super.parseLiteral(e2, s2);
            return i2.raw = i2.extra.raw, delete i2.extra, i2;
          }
          parseFunctionBody(e2, s2, i2 = false) {
            super.parseFunctionBody(e2, s2, i2), e2.expression = e2.body.type !== "BlockStatement";
          }
          parseMethod(e2, s2, i2, r2, n2, o2, h2 = false) {
            let c2 = this.startNode();
            return c2.kind = e2.kind, c2 = super.parseMethod(c2, s2, i2, r2, n2, o2, h2), c2.type = "FunctionExpression", delete c2.kind, e2.value = c2, o2 === "ClassPrivateMethod" && (e2.computed = false), this.finishNode(e2, "MethodDefinition");
          }
          nameIsConstructor(e2) {
            return e2.type === "Literal" ? e2.value === "constructor" : super.nameIsConstructor(e2);
          }
          parseClassProperty(...e2) {
            let s2 = super.parseClassProperty(...e2);
            return this.getPluginOption("estree", "classFeatures") && (s2.type = "PropertyDefinition"), s2;
          }
          parseClassPrivateProperty(...e2) {
            let s2 = super.parseClassPrivateProperty(...e2);
            return this.getPluginOption("estree", "classFeatures") && (s2.type = "PropertyDefinition", s2.computed = false), s2;
          }
          parseObjectMethod(e2, s2, i2, r2, n2) {
            let o2 = super.parseObjectMethod(e2, s2, i2, r2, n2);
            return o2 && (o2.type = "Property", o2.kind === "method" && (o2.kind = "init"), o2.shorthand = false), o2;
          }
          parseObjectProperty(e2, s2, i2, r2) {
            let n2 = super.parseObjectProperty(e2, s2, i2, r2);
            return n2 && (n2.kind = "init", n2.type = "Property"), n2;
          }
          isValidLVal(e2, s2, i2) {
            return e2 === "Property" ? "value" : super.isValidLVal(e2, s2, i2);
          }
          isAssignable(e2, s2) {
            return e2 != null && this.isObjectProperty(e2) ? this.isAssignable(e2.value, s2) : super.isAssignable(e2, s2);
          }
          toAssignable(e2, s2 = false) {
            if (e2 != null && this.isObjectProperty(e2)) {
              let { key: i2, value: r2 } = e2;
              this.isPrivateName(i2) && this.classScope.usePrivateName(this.getPrivateNameSV(i2), i2.loc.start), this.toAssignable(r2, s2);
            } else
              super.toAssignable(e2, s2);
          }
          toAssignableObjectExpressionProp(e2, s2, i2) {
            e2.type === "Property" && (e2.kind === "get" || e2.kind === "set") ? this.raise(p2.PatternHasAccessor, e2.key) : e2.type === "Property" && e2.method ? this.raise(p2.PatternHasMethod, e2.key) : super.toAssignableObjectExpressionProp(e2, s2, i2);
          }
          finishCallExpression(e2, s2) {
            let i2 = super.finishCallExpression(e2, s2);
            if (i2.callee.type === "Import") {
              if (i2.type = "ImportExpression", i2.source = i2.arguments[0], this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
                var r2, n2;
                i2.options = (r2 = i2.arguments[1]) != null ? r2 : null, i2.attributes = (n2 = i2.arguments[1]) != null ? n2 : null;
              }
              delete i2.arguments, delete i2.callee;
            }
            return i2;
          }
          toReferencedArguments(e2) {
            e2.type !== "ImportExpression" && super.toReferencedArguments(e2);
          }
          parseExport(e2, s2) {
            let i2 = this.state.lastTokStartLoc, r2 = super.parseExport(e2, s2);
            switch (r2.type) {
              case "ExportAllDeclaration":
                r2.exported = null;
                break;
              case "ExportNamedDeclaration":
                r2.specifiers.length === 1 && r2.specifiers[0].type === "ExportNamespaceSpecifier" && (r2.type = "ExportAllDeclaration", r2.exported = r2.specifiers[0].exported, delete r2.specifiers);
              case "ExportDefaultDeclaration":
                {
                  var n2;
                  let { declaration: o2 } = r2;
                  (o2 == null ? void 0 : o2.type) === "ClassDeclaration" && ((n2 = o2.decorators) == null ? void 0 : n2.length) > 0 && o2.start === r2.start && this.resetStartLocation(r2, i2);
                }
                break;
            }
            return r2;
          }
          parseSubscript(e2, s2, i2, r2) {
            let n2 = super.parseSubscript(e2, s2, i2, r2);
            if (r2.optionalChainMember) {
              if ((n2.type === "OptionalMemberExpression" || n2.type === "OptionalCallExpression") && (n2.type = n2.type.substring(8)), r2.stop) {
                let o2 = this.startNodeAtNode(n2);
                return o2.expression = n2, this.finishNode(o2, "ChainExpression");
              }
            } else
              (n2.type === "MemberExpression" || n2.type === "CallExpression") && (n2.optional = false);
            return n2;
          }
          isOptionalMemberExpression(e2) {
            return e2.type === "ChainExpression" ? e2.expression.type === "MemberExpression" : super.isOptionalMemberExpression(e2);
          }
          hasPropertyAsPrivateName(e2) {
            return e2.type === "ChainExpression" && (e2 = e2.expression), super.hasPropertyAsPrivateName(e2);
          }
          isObjectProperty(e2) {
            return e2.type === "Property" && e2.kind === "init" && !e2.method;
          }
          isObjectMethod(e2) {
            return e2.type === "Property" && (e2.method || e2.kind === "get" || e2.kind === "set");
          }
          finishNodeAt(e2, s2, i2) {
            return oe3(super.finishNodeAt(e2, s2, i2));
          }
          resetStartLocation(e2, s2) {
            super.resetStartLocation(e2, s2), oe3(e2);
          }
          resetEndLocation(e2, s2 = this.state.lastTokEndLoc) {
            super.resetEndLocation(e2, s2), oe3(e2);
          }
        }, X3 = class {
          constructor(t2, e2) {
            this.token = void 0, this.preserveSpace = void 0, this.token = t2, this.preserveSpace = !!e2;
          }
        }, C = { brace: new X3("{"), j_oTag: new X3("<tag"), j_cTag: new X3("</tag"), j_expr: new X3("<tag>...</tag>", true) };
        C.template = new X3("`", true);
        var b3 = true, m = true, $e3 = true, he3 = true, q2 = true, ai2 = true, ve3 = class {
          constructor(t2, e2 = {}) {
            this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = t2, this.keyword = e2.keyword, this.beforeExpr = !!e2.beforeExpr, this.startsExpr = !!e2.startsExpr, this.rightAssociative = !!e2.rightAssociative, this.isLoop = !!e2.isLoop, this.isAssign = !!e2.isAssign, this.prefix = !!e2.prefix, this.postfix = !!e2.postfix, this.binop = e2.binop != null ? e2.binop : null, this.updateContext = null;
          }
        }, ut3 = /* @__PURE__ */ new Map();
        function A(a2, t2 = {}) {
          t2.keyword = a2;
          let e2 = P2(a2, t2);
          return ut3.set(a2, e2), e2;
        }
        function k(a2, t2) {
          return P2(a2, { beforeExpr: b3, binop: t2 });
        }
        var ue2 = -1, U2 = [], ft2 = [], dt3 = [], mt3 = [], yt2 = [], xt3 = [];
        function P2(a2, t2 = {}) {
          var e2, s2, i2, r2;
          return ++ue2, ft2.push(a2), dt3.push((e2 = t2.binop) != null ? e2 : -1), mt3.push((s2 = t2.beforeExpr) != null ? s2 : false), yt2.push((i2 = t2.startsExpr) != null ? i2 : false), xt3.push((r2 = t2.prefix) != null ? r2 : false), U2.push(new ve3(a2, t2)), ue2;
        }
        function T3(a2, t2 = {}) {
          var e2, s2, i2, r2;
          return ++ue2, ut3.set(a2, ue2), ft2.push(a2), dt3.push((e2 = t2.binop) != null ? e2 : -1), mt3.push((s2 = t2.beforeExpr) != null ? s2 : false), yt2.push((i2 = t2.startsExpr) != null ? i2 : false), xt3.push((r2 = t2.prefix) != null ? r2 : false), U2.push(new ve3("name", t2)), ue2;
        }
        var ni2 = { bracketL: P2("[", { beforeExpr: b3, startsExpr: m }), bracketHashL: P2("#[", { beforeExpr: b3, startsExpr: m }), bracketBarL: P2("[|", { beforeExpr: b3, startsExpr: m }), bracketR: P2("]"), bracketBarR: P2("|]"), braceL: P2("{", { beforeExpr: b3, startsExpr: m }), braceBarL: P2("{|", { beforeExpr: b3, startsExpr: m }), braceHashL: P2("#{", { beforeExpr: b3, startsExpr: m }), braceR: P2("}"), braceBarR: P2("|}"), parenL: P2("(", { beforeExpr: b3, startsExpr: m }), parenR: P2(")"), comma: P2(",", { beforeExpr: b3 }), semi: P2(";", { beforeExpr: b3 }), colon: P2(":", { beforeExpr: b3 }), doubleColon: P2("::", { beforeExpr: b3 }), dot: P2("."), question: P2("?", { beforeExpr: b3 }), questionDot: P2("?."), arrow: P2("=>", { beforeExpr: b3 }), template: P2("template"), ellipsis: P2("...", { beforeExpr: b3 }), backQuote: P2("`", { startsExpr: m }), dollarBraceL: P2("${", { beforeExpr: b3, startsExpr: m }), templateTail: P2("...`", { startsExpr: m }), templateNonTail: P2("...${", { beforeExpr: b3, startsExpr: m }), at: P2("@"), hash: P2("#", { startsExpr: m }), interpreterDirective: P2("#!..."), eq: P2("=", { beforeExpr: b3, isAssign: he3 }), assign: P2("_=", { beforeExpr: b3, isAssign: he3 }), slashAssign: P2("_=", { beforeExpr: b3, isAssign: he3 }), xorAssign: P2("_=", { beforeExpr: b3, isAssign: he3 }), moduloAssign: P2("_=", { beforeExpr: b3, isAssign: he3 }), incDec: P2("++/--", { prefix: q2, postfix: ai2, startsExpr: m }), bang: P2("!", { beforeExpr: b3, prefix: q2, startsExpr: m }), tilde: P2("~", { beforeExpr: b3, prefix: q2, startsExpr: m }), doubleCaret: P2("^^", { startsExpr: m }), doubleAt: P2("@@", { startsExpr: m }), pipeline: k("|>", 0), nullishCoalescing: k("??", 1), logicalOR: k("||", 1), logicalAND: k("&&", 2), bitwiseOR: k("|", 3), bitwiseXOR: k("^", 4), bitwiseAND: k("&", 5), equality: k("==/!=/===/!==", 6), lt: k("</>/<=/>=", 7), gt: k("</>/<=/>=", 7), relational: k("</>/<=/>=", 7), bitShift: k("<</>>/>>>", 8), bitShiftL: k("<</>>/>>>", 8), bitShiftR: k("<</>>/>>>", 8), plusMin: P2("+/-", { beforeExpr: b3, binop: 9, prefix: q2, startsExpr: m }), modulo: P2("%", { binop: 10, startsExpr: m }), star: P2("*", { binop: 10 }), slash: k("/", 10), exponent: P2("**", { beforeExpr: b3, binop: 11, rightAssociative: true }), _in: A("in", { beforeExpr: b3, binop: 7 }), _instanceof: A("instanceof", { beforeExpr: b3, binop: 7 }), _break: A("break"), _case: A("case", { beforeExpr: b3 }), _catch: A("catch"), _continue: A("continue"), _debugger: A("debugger"), _default: A("default", { beforeExpr: b3 }), _else: A("else", { beforeExpr: b3 }), _finally: A("finally"), _function: A("function", { startsExpr: m }), _if: A("if"), _return: A("return", { beforeExpr: b3 }), _switch: A("switch"), _throw: A("throw", { beforeExpr: b3, prefix: q2, startsExpr: m }), _try: A("try"), _var: A("var"), _const: A("const"), _with: A("with"), _new: A("new", { beforeExpr: b3, startsExpr: m }), _this: A("this", { startsExpr: m }), _super: A("super", { startsExpr: m }), _class: A("class", { startsExpr: m }), _extends: A("extends", { beforeExpr: b3 }), _export: A("export"), _import: A("import", { startsExpr: m }), _null: A("null", { startsExpr: m }), _true: A("true", { startsExpr: m }), _false: A("false", { startsExpr: m }), _typeof: A("typeof", { beforeExpr: b3, prefix: q2, startsExpr: m }), _void: A("void", { beforeExpr: b3, prefix: q2, startsExpr: m }), _delete: A("delete", { beforeExpr: b3, prefix: q2, startsExpr: m }), _do: A("do", { isLoop: $e3, beforeExpr: b3 }), _for: A("for", { isLoop: $e3 }), _while: A("while", { isLoop: $e3 }), _as: T3("as", { startsExpr: m }), _assert: T3("assert", { startsExpr: m }), _async: T3("async", { startsExpr: m }), _await: T3("await", { startsExpr: m }), _defer: T3("defer", { startsExpr: m }), _from: T3("from", { startsExpr: m }), _get: T3("get", { startsExpr: m }), _let: T3("let", { startsExpr: m }), _meta: T3("meta", { startsExpr: m }), _of: T3("of", { startsExpr: m }), _sent: T3("sent", { startsExpr: m }), _set: T3("set", { startsExpr: m }), _source: T3("source", { startsExpr: m }), _static: T3("static", { startsExpr: m }), _using: T3("using", { startsExpr: m }), _yield: T3("yield", { startsExpr: m }), _asserts: T3("asserts", { startsExpr: m }), _checks: T3("checks", { startsExpr: m }), _exports: T3("exports", { startsExpr: m }), _global: T3("global", { startsExpr: m }), _implements: T3("implements", { startsExpr: m }), _intrinsic: T3("intrinsic", { startsExpr: m }), _infer: T3("infer", { startsExpr: m }), _is: T3("is", { startsExpr: m }), _mixins: T3("mixins", { startsExpr: m }), _proto: T3("proto", { startsExpr: m }), _require: T3("require", { startsExpr: m }), _satisfies: T3("satisfies", { startsExpr: m }), _keyof: T3("keyof", { startsExpr: m }), _readonly: T3("readonly", { startsExpr: m }), _unique: T3("unique", { startsExpr: m }), _abstract: T3("abstract", { startsExpr: m }), _declare: T3("declare", { startsExpr: m }), _enum: T3("enum", { startsExpr: m }), _module: T3("module", { startsExpr: m }), _namespace: T3("namespace", { startsExpr: m }), _interface: T3("interface", { startsExpr: m }), _type: T3("type", { startsExpr: m }), _opaque: T3("opaque", { startsExpr: m }), name: P2("name", { startsExpr: m }), string: P2("string", { startsExpr: m }), num: P2("num", { startsExpr: m }), bigint: P2("bigint", { startsExpr: m }), decimal: P2("decimal", { startsExpr: m }), regexp: P2("regexp", { startsExpr: m }), privateName: P2("#name", { startsExpr: m }), eof: P2("eof"), jsxName: P2("jsxName"), jsxText: P2("jsxText", { beforeExpr: true }), jsxTagStart: P2("jsxTagStart", { startsExpr: true }), jsxTagEnd: P2("jsxTagEnd"), placeholder: P2("%%", { startsExpr: true }) };
        function w2(a2) {
          return a2 >= 93 && a2 <= 132;
        }
        function oi2(a2) {
          return a2 <= 92;
        }
        function M3(a2) {
          return a2 >= 58 && a2 <= 132;
        }
        function Wt2(a2) {
          return a2 >= 58 && a2 <= 136;
        }
        function hi3(a2) {
          return mt3[a2];
        }
        function He2(a2) {
          return yt2[a2];
        }
        function li3(a2) {
          return a2 >= 29 && a2 <= 33;
        }
        function Ft3(a2) {
          return a2 >= 129 && a2 <= 131;
        }
        function ci3(a2) {
          return a2 >= 90 && a2 <= 92;
        }
        function Pt2(a2) {
          return a2 >= 58 && a2 <= 92;
        }
        function pi3(a2) {
          return a2 >= 39 && a2 <= 59;
        }
        function ui2(a2) {
          return a2 === 34;
        }
        function fi2(a2) {
          return xt3[a2];
        }
        function di2(a2) {
          return a2 >= 121 && a2 <= 123;
        }
        function mi(a2) {
          return a2 >= 124 && a2 <= 130;
        }
        function K2(a2) {
          return ft2[a2];
        }
        function Ie3(a2) {
          return dt3[a2];
        }
        function yi(a2) {
          return a2 === 57;
        }
        function Le3(a2) {
          return a2 >= 24 && a2 <= 25;
        }
        function R3(a2) {
          return U2[a2];
        }
        U2[8].updateContext = (a2) => {
          a2.pop();
        }, U2[5].updateContext = U2[7].updateContext = U2[23].updateContext = (a2) => {
          a2.push(C.brace);
        }, U2[22].updateContext = (a2) => {
          a2[a2.length - 1] === C.template ? a2.pop() : a2.push(C.template);
        }, U2[142].updateContext = (a2) => {
          a2.push(C.j_expr, C.j_oTag);
        };
        var gt2 = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", Jt2 = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･", xi = new RegExp("[" + gt2 + "]"), Pi = new RegExp("[" + gt2 + Jt2 + "]");
        gt2 = Jt2 = null;
        var Xt = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], gi = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
        function We2(a2, t2) {
          let e2 = 65536;
          for (let s2 = 0, i2 = t2.length; s2 < i2; s2 += 2) {
            if (e2 += t2[s2], e2 > a2)
              return false;
            if (e2 += t2[s2 + 1], e2 >= a2)
              return true;
          }
          return false;
        }
        function _3(a2) {
          return a2 < 65 ? a2 === 36 : a2 <= 90 ? true : a2 < 97 ? a2 === 95 : a2 <= 122 ? true : a2 <= 65535 ? a2 >= 170 && xi.test(String.fromCharCode(a2)) : We2(a2, Xt);
        }
        function Q3(a2) {
          return a2 < 48 ? a2 === 36 : a2 < 58 ? true : a2 < 65 ? false : a2 <= 90 ? true : a2 < 97 ? a2 === 95 : a2 <= 122 ? true : a2 <= 65535 ? a2 >= 170 && Pi.test(String.fromCharCode(a2)) : We2(a2, Xt) || We2(a2, gi);
        }
        var Tt2 = { keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"], strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], strictBind: ["eval", "arguments"] }, Ti2 = new Set(Tt2.keyword), bi = new Set(Tt2.strict), Ai2 = new Set(Tt2.strictBind);
        function Gt2(a2, t2) {
          return t2 && a2 === "await" || a2 === "enum";
        }
        function Yt2(a2, t2) {
          return Gt2(a2, t2) || bi.has(a2);
        }
        function Qt2(a2) {
          return Ai2.has(a2);
        }
        function Zt(a2, t2) {
          return Yt2(a2, t2) || Qt2(a2);
        }
        function Si2(a2) {
          return Ti2.has(a2);
        }
        function wi(a2, t2, e2) {
          return a2 === 64 && t2 === 64 && _3(e2);
        }
        var Ci = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
        function Ei(a2) {
          return Ci.has(a2);
        }
        var de2 = class {
          constructor(t2) {
            this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = t2;
          }
        }, me2 = class {
          constructor(t2, e2) {
            this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = t2, this.inModule = e2;
          }
          get inTopLevel() {
            return (this.currentScope().flags & 1) > 0;
          }
          get inFunction() {
            return (this.currentVarScopeFlags() & 2) > 0;
          }
          get allowSuper() {
            return (this.currentThisScopeFlags() & 16) > 0;
          }
          get allowDirectSuper() {
            return (this.currentThisScopeFlags() & 32) > 0;
          }
          get inClass() {
            return (this.currentThisScopeFlags() & 64) > 0;
          }
          get inClassAndNotInNonArrowFunction() {
            let t2 = this.currentThisScopeFlags();
            return (t2 & 64) > 0 && (t2 & 2) === 0;
          }
          get inStaticBlock() {
            for (let t2 = this.scopeStack.length - 1; ; t2--) {
              let { flags: e2 } = this.scopeStack[t2];
              if (e2 & 128)
                return true;
              if (e2 & 451)
                return false;
            }
          }
          get inNonArrowFunction() {
            return (this.currentThisScopeFlags() & 2) > 0;
          }
          get treatFunctionsAsVar() {
            return this.treatFunctionsAsVarInScope(this.currentScope());
          }
          createScope(t2) {
            return new de2(t2);
          }
          enter(t2) {
            this.scopeStack.push(this.createScope(t2));
          }
          exit() {
            return this.scopeStack.pop().flags;
          }
          treatFunctionsAsVarInScope(t2) {
            return !!(t2.flags & 130 || !this.parser.inModule && t2.flags & 1);
          }
          declareName(t2, e2, s2) {
            let i2 = this.currentScope();
            if (e2 & 8 || e2 & 16) {
              this.checkRedeclarationInScope(i2, t2, e2, s2);
              let r2 = i2.names.get(t2) || 0;
              e2 & 16 ? r2 = r2 | 4 : (i2.firstLexicalName || (i2.firstLexicalName = t2), r2 = r2 | 2), i2.names.set(t2, r2), e2 & 8 && this.maybeExportDefined(i2, t2);
            } else if (e2 & 4)
              for (let r2 = this.scopeStack.length - 1; r2 >= 0 && (i2 = this.scopeStack[r2], this.checkRedeclarationInScope(i2, t2, e2, s2), i2.names.set(t2, (i2.names.get(t2) || 0) | 1), this.maybeExportDefined(i2, t2), !(i2.flags & 387)); --r2)
                ;
            this.parser.inModule && i2.flags & 1 && this.undefinedExports.delete(t2);
          }
          maybeExportDefined(t2, e2) {
            this.parser.inModule && t2.flags & 1 && this.undefinedExports.delete(e2);
          }
          checkRedeclarationInScope(t2, e2, s2, i2) {
            this.isRedeclaredInScope(t2, e2, s2) && this.parser.raise(p2.VarRedeclaration, i2, { identifierName: e2 });
          }
          isRedeclaredInScope(t2, e2, s2) {
            if (!(s2 & 1))
              return false;
            if (s2 & 8)
              return t2.names.has(e2);
            let i2 = t2.names.get(e2);
            return s2 & 16 ? (i2 & 2) > 0 || !this.treatFunctionsAsVarInScope(t2) && (i2 & 1) > 0 : (i2 & 2) > 0 && !(t2.flags & 8 && t2.firstLexicalName === e2) || !this.treatFunctionsAsVarInScope(t2) && (i2 & 4) > 0;
          }
          checkLocalExport(t2) {
            let { name: e2 } = t2;
            this.scopeStack[0].names.has(e2) || this.undefinedExports.set(e2, t2.loc.start);
          }
          currentScope() {
            return this.scopeStack[this.scopeStack.length - 1];
          }
          currentVarScopeFlags() {
            for (let t2 = this.scopeStack.length - 1; ; t2--) {
              let { flags: e2 } = this.scopeStack[t2];
              if (e2 & 387)
                return e2;
            }
          }
          currentThisScopeFlags() {
            for (let t2 = this.scopeStack.length - 1; ; t2--) {
              let { flags: e2 } = this.scopeStack[t2];
              if (e2 & 451 && !(e2 & 4))
                return e2;
            }
          }
        }, Je2 = class extends de2 {
          constructor(...t2) {
            super(...t2), this.declareFunctions = /* @__PURE__ */ new Set();
          }
        }, Xe2 = class extends me2 {
          createScope(t2) {
            return new Je2(t2);
          }
          declareName(t2, e2, s2) {
            let i2 = this.currentScope();
            if (e2 & 2048) {
              this.checkRedeclarationInScope(i2, t2, e2, s2), this.maybeExportDefined(i2, t2), i2.declareFunctions.add(t2);
              return;
            }
            super.declareName(t2, e2, s2);
          }
          isRedeclaredInScope(t2, e2, s2) {
            if (super.isRedeclaredInScope(t2, e2, s2))
              return true;
            if (s2 & 2048 && !t2.declareFunctions.has(e2)) {
              let i2 = t2.names.get(e2);
              return (i2 & 4) > 0 || (i2 & 2) > 0;
            }
            return false;
          }
          checkLocalExport(t2) {
            this.scopeStack[0].declareFunctions.has(t2.name) || super.checkLocalExport(t2);
          }
        }, Ge3 = class {
          constructor() {
            this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
          }
          hasPlugin(t2) {
            if (typeof t2 == "string")
              return this.plugins.has(t2);
            {
              let [e2, s2] = t2;
              if (!this.hasPlugin(e2))
                return false;
              let i2 = this.plugins.get(e2);
              for (let r2 of Object.keys(s2))
                if ((i2 == null ? void 0 : i2[r2]) !== s2[r2])
                  return false;
              return true;
            }
          }
          getPluginOption(t2, e2) {
            var s2;
            return (s2 = this.plugins.get(t2)) == null ? void 0 : s2[e2];
          }
        };
        function es(a2, t2) {
          a2.trailingComments === void 0 ? a2.trailingComments = t2 : a2.trailingComments.unshift(...t2);
        }
        function Ii2(a2, t2) {
          a2.leadingComments === void 0 ? a2.leadingComments = t2 : a2.leadingComments.unshift(...t2);
        }
        function ye(a2, t2) {
          a2.innerComments === void 0 ? a2.innerComments = t2 : a2.innerComments.unshift(...t2);
        }
        function le2(a2, t2, e2) {
          let s2 = null, i2 = t2.length;
          for (; s2 === null && i2 > 0; )
            s2 = t2[--i2];
          s2 === null || s2.start > e2.start ? ye(a2, e2.comments) : es(s2, e2.comments);
        }
        var Ye2 = class extends Ge3 {
          addComment(t2) {
            this.filename && (t2.loc.filename = this.filename);
            let { commentsLen: e2 } = this.state;
            this.comments.length !== e2 && (this.comments.length = e2), this.comments.push(t2), this.state.commentsLen++;
          }
          processComment(t2) {
            let { commentStack: e2 } = this.state, s2 = e2.length;
            if (s2 === 0)
              return;
            let i2 = s2 - 1, r2 = e2[i2];
            r2.start === t2.end && (r2.leadingNode = t2, i2--);
            let { start: n2 } = t2;
            for (; i2 >= 0; i2--) {
              let o2 = e2[i2], h2 = o2.end;
              if (h2 > n2)
                o2.containingNode = t2, this.finalizeComment(o2), e2.splice(i2, 1);
              else {
                h2 === n2 && (o2.trailingNode = t2);
                break;
              }
            }
          }
          finalizeComment(t2) {
            let { comments: e2 } = t2;
            if (t2.leadingNode !== null || t2.trailingNode !== null)
              t2.leadingNode !== null && es(t2.leadingNode, e2), t2.trailingNode !== null && Ii2(t2.trailingNode, e2);
            else {
              let { containingNode: s2, start: i2 } = t2;
              if (this.input.charCodeAt(i2 - 1) === 44)
                switch (s2.type) {
                  case "ObjectExpression":
                  case "ObjectPattern":
                  case "RecordExpression":
                    le2(s2, s2.properties, t2);
                    break;
                  case "CallExpression":
                  case "OptionalCallExpression":
                    le2(s2, s2.arguments, t2);
                    break;
                  case "FunctionDeclaration":
                  case "FunctionExpression":
                  case "ArrowFunctionExpression":
                  case "ObjectMethod":
                  case "ClassMethod":
                  case "ClassPrivateMethod":
                    le2(s2, s2.params, t2);
                    break;
                  case "ArrayExpression":
                  case "ArrayPattern":
                  case "TupleExpression":
                    le2(s2, s2.elements, t2);
                    break;
                  case "ExportNamedDeclaration":
                  case "ImportDeclaration":
                    le2(s2, s2.specifiers, t2);
                    break;
                  default:
                    ye(s2, e2);
                }
              else
                ye(s2, e2);
            }
          }
          finalizeRemainingComments() {
            let { commentStack: t2 } = this.state;
            for (let e2 = t2.length - 1; e2 >= 0; e2--)
              this.finalizeComment(t2[e2]);
            this.state.commentStack = [];
          }
          resetPreviousNodeTrailingComments(t2) {
            let { commentStack: e2 } = this.state, { length: s2 } = e2;
            if (s2 === 0)
              return;
            let i2 = e2[s2 - 1];
            i2.leadingNode === t2 && (i2.leadingNode = null);
          }
          resetPreviousIdentifierLeadingComments(t2) {
            let { commentStack: e2 } = this.state, { length: s2 } = e2;
            s2 !== 0 && (e2[s2 - 1].trailingNode === t2 ? e2[s2 - 1].trailingNode = null : s2 >= 2 && e2[s2 - 2].trailingNode === t2 && (e2[s2 - 2].trailingNode = null));
          }
          takeSurroundingComments(t2, e2, s2) {
            let { commentStack: i2 } = this.state, r2 = i2.length;
            if (r2 === 0)
              return;
            let n2 = r2 - 1;
            for (; n2 >= 0; n2--) {
              let o2 = i2[n2], h2 = o2.end;
              if (o2.start === s2)
                o2.leadingNode = t2;
              else if (h2 === e2)
                o2.trailingNode = t2;
              else if (h2 < e2)
                break;
            }
          }
        }, ts = /\r\n?|[\n\u2028\u2029]/, we3 = new RegExp(ts.source, "g");
        function fe2(a2) {
          switch (a2) {
            case 10:
            case 13:
            case 8232:
            case 8233:
              return true;
            default:
              return false;
          }
        }
        var Ve2 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Ne2 = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, Bt2 = new RegExp("(?=(" + Ne2.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
        function Ni(a2) {
          switch (a2) {
            case 9:
            case 11:
            case 12:
            case 32:
            case 160:
            case 5760:
            case 8192:
            case 8193:
            case 8194:
            case 8195:
            case 8196:
            case 8197:
            case 8198:
            case 8199:
            case 8200:
            case 8201:
            case 8202:
            case 8239:
            case 8287:
            case 12288:
            case 65279:
              return true;
            default:
              return false;
          }
        }
        var Qe3 = class a2 {
          constructor() {
            this.flags = 1024, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 139, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [C.brace], this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
          }
          get strict() {
            return (this.flags & 1) > 0;
          }
          set strict(t2) {
            t2 ? this.flags |= 1 : this.flags &= -2;
          }
          init({ strictMode: t2, sourceType: e2, startLine: s2, startColumn: i2 }) {
            this.strict = t2 === false ? false : t2 === true ? true : e2 === "module", this.curLine = s2, this.lineStart = -i2, this.startLoc = this.endLoc = new F(s2, i2, 0);
          }
          get maybeInArrowParameters() {
            return (this.flags & 2) > 0;
          }
          set maybeInArrowParameters(t2) {
            t2 ? this.flags |= 2 : this.flags &= -3;
          }
          get inType() {
            return (this.flags & 4) > 0;
          }
          set inType(t2) {
            t2 ? this.flags |= 4 : this.flags &= -5;
          }
          get noAnonFunctionType() {
            return (this.flags & 8) > 0;
          }
          set noAnonFunctionType(t2) {
            t2 ? this.flags |= 8 : this.flags &= -9;
          }
          get hasFlowComment() {
            return (this.flags & 16) > 0;
          }
          set hasFlowComment(t2) {
            t2 ? this.flags |= 16 : this.flags &= -17;
          }
          get isAmbientContext() {
            return (this.flags & 32) > 0;
          }
          set isAmbientContext(t2) {
            t2 ? this.flags |= 32 : this.flags &= -33;
          }
          get inAbstractClass() {
            return (this.flags & 64) > 0;
          }
          set inAbstractClass(t2) {
            t2 ? this.flags |= 64 : this.flags &= -65;
          }
          get inDisallowConditionalTypesContext() {
            return (this.flags & 128) > 0;
          }
          set inDisallowConditionalTypesContext(t2) {
            t2 ? this.flags |= 128 : this.flags &= -129;
          }
          get soloAwait() {
            return (this.flags & 256) > 0;
          }
          set soloAwait(t2) {
            t2 ? this.flags |= 256 : this.flags &= -257;
          }
          get inFSharpPipelineDirectBody() {
            return (this.flags & 512) > 0;
          }
          set inFSharpPipelineDirectBody(t2) {
            t2 ? this.flags |= 512 : this.flags &= -513;
          }
          get canStartJSXElement() {
            return (this.flags & 1024) > 0;
          }
          set canStartJSXElement(t2) {
            t2 ? this.flags |= 1024 : this.flags &= -1025;
          }
          get containsEsc() {
            return (this.flags & 2048) > 0;
          }
          set containsEsc(t2) {
            t2 ? this.flags |= 2048 : this.flags &= -2049;
          }
          curPosition() {
            return new F(this.curLine, this.pos - this.lineStart, this.pos);
          }
          clone() {
            let t2 = new a2();
            return t2.flags = this.flags, t2.curLine = this.curLine, t2.lineStart = this.lineStart, t2.startLoc = this.startLoc, t2.endLoc = this.endLoc, t2.errors = this.errors.slice(), t2.potentialArrowAt = this.potentialArrowAt, t2.noArrowAt = this.noArrowAt.slice(), t2.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), t2.topicContext = this.topicContext, t2.labels = this.labels.slice(), t2.commentsLen = this.commentsLen, t2.commentStack = this.commentStack.slice(), t2.pos = this.pos, t2.type = this.type, t2.value = this.value, t2.start = this.start, t2.end = this.end, t2.lastTokEndLoc = this.lastTokEndLoc, t2.lastTokStartLoc = this.lastTokStartLoc, t2.context = this.context.slice(), t2.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, t2.strictErrors = this.strictErrors, t2.tokensLength = this.tokensLength, t2;
          }
        }, ki = function(t2) {
          return t2 >= 48 && t2 <= 57;
        }, Rt2 = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, Ce3 = { bin: (a2) => a2 === 48 || a2 === 49, oct: (a2) => a2 >= 48 && a2 <= 55, dec: (a2) => a2 >= 48 && a2 <= 57, hex: (a2) => a2 >= 48 && a2 <= 57 || a2 >= 65 && a2 <= 70 || a2 >= 97 && a2 <= 102 };
        function Ut2(a2, t2, e2, s2, i2, r2) {
          let n2 = e2, o2 = s2, h2 = i2, c2 = "", l2 = null, u2 = e2, { length: f2 } = t2;
          for (; ; ) {
            if (e2 >= f2) {
              r2.unterminated(n2, o2, h2), c2 += t2.slice(u2, e2);
              break;
            }
            let d2 = t2.charCodeAt(e2);
            if (vi2(a2, d2, t2, e2)) {
              c2 += t2.slice(u2, e2);
              break;
            }
            if (d2 === 92) {
              c2 += t2.slice(u2, e2);
              let y3 = Li2(t2, e2, s2, i2, a2 === "template", r2);
              y3.ch === null && !l2 ? l2 = { pos: e2, lineStart: s2, curLine: i2 } : c2 += y3.ch, { pos: e2, lineStart: s2, curLine: i2 } = y3, u2 = e2;
            } else
              d2 === 8232 || d2 === 8233 ? (++e2, ++i2, s2 = e2) : d2 === 10 || d2 === 13 ? a2 === "template" ? (c2 += t2.slice(u2, e2) + `
`, ++e2, d2 === 13 && t2.charCodeAt(e2) === 10 && ++e2, ++i2, u2 = s2 = e2) : r2.unterminated(n2, o2, h2) : ++e2;
          }
          return { pos: e2, str: c2, firstInvalidLoc: l2, lineStart: s2, curLine: i2, containsInvalid: !!l2 };
        }
        function vi2(a2, t2, e2, s2) {
          return a2 === "template" ? t2 === 96 || t2 === 36 && e2.charCodeAt(s2 + 1) === 123 : t2 === (a2 === "double" ? 34 : 39);
        }
        function Li2(a2, t2, e2, s2, i2, r2) {
          let n2 = !i2;
          t2++;
          let o2 = (c2) => ({ pos: t2, ch: c2, lineStart: e2, curLine: s2 }), h2 = a2.charCodeAt(t2++);
          switch (h2) {
            case 110:
              return o2(`
`);
            case 114:
              return o2("\r");
            case 120: {
              let c2;
              return { code: c2, pos: t2 } = Ze2(a2, t2, e2, s2, 2, false, n2, r2), o2(c2 === null ? null : String.fromCharCode(c2));
            }
            case 117: {
              let c2;
              return { code: c2, pos: t2 } = is(a2, t2, e2, s2, n2, r2), o2(c2 === null ? null : String.fromCodePoint(c2));
            }
            case 116:
              return o2("	");
            case 98:
              return o2("\b");
            case 118:
              return o2("\v");
            case 102:
              return o2("\f");
            case 13:
              a2.charCodeAt(t2) === 10 && ++t2;
            case 10:
              e2 = t2, ++s2;
            case 8232:
            case 8233:
              return o2("");
            case 56:
            case 57:
              if (i2)
                return o2(null);
              r2.strictNumericEscape(t2 - 1, e2, s2);
            default:
              if (h2 >= 48 && h2 <= 55) {
                let c2 = t2 - 1, u2 = /^[0-7]+/.exec(a2.slice(c2, t2 + 2))[0], f2 = parseInt(u2, 8);
                f2 > 255 && (u2 = u2.slice(0, -1), f2 = parseInt(u2, 8)), t2 += u2.length - 1;
                let d2 = a2.charCodeAt(t2);
                if (u2 !== "0" || d2 === 56 || d2 === 57) {
                  if (i2)
                    return o2(null);
                  r2.strictNumericEscape(c2, e2, s2);
                }
                return o2(String.fromCharCode(f2));
              }
              return o2(String.fromCharCode(h2));
          }
        }
        function Ze2(a2, t2, e2, s2, i2, r2, n2, o2) {
          let h2 = t2, c2;
          return { n: c2, pos: t2 } = ss(a2, t2, e2, s2, 16, i2, r2, false, o2, !n2), c2 === null && (n2 ? o2.invalidEscapeSequence(h2, e2, s2) : t2 = h2 - 1), { code: c2, pos: t2 };
        }
        function ss(a2, t2, e2, s2, i2, r2, n2, o2, h2, c2) {
          let l2 = t2, u2 = i2 === 16 ? Rt2.hex : Rt2.decBinOct, f2 = i2 === 16 ? Ce3.hex : i2 === 10 ? Ce3.dec : i2 === 8 ? Ce3.oct : Ce3.bin, d2 = false, y3 = 0;
          for (let E2 = 0, L3 = r2 ?? 1 / 0; E2 < L3; ++E2) {
            let S3 = a2.charCodeAt(t2), I2;
            if (S3 === 95 && o2 !== "bail") {
              let Ae3 = a2.charCodeAt(t2 - 1), ne3 = a2.charCodeAt(t2 + 1);
              if (o2) {
                if (Number.isNaN(ne3) || !f2(ne3) || u2.has(Ae3) || u2.has(ne3)) {
                  if (c2)
                    return { n: null, pos: t2 };
                  h2.unexpectedNumericSeparator(t2, e2, s2);
                }
              } else {
                if (c2)
                  return { n: null, pos: t2 };
                h2.numericSeparatorInEscapeSequence(t2, e2, s2);
              }
              ++t2;
              continue;
            }
            if (S3 >= 97 ? I2 = S3 - 97 + 10 : S3 >= 65 ? I2 = S3 - 65 + 10 : ki(S3) ? I2 = S3 - 48 : I2 = 1 / 0, I2 >= i2) {
              if (I2 <= 9 && c2)
                return { n: null, pos: t2 };
              if (I2 <= 9 && h2.invalidDigit(t2, e2, s2, i2))
                I2 = 0;
              else if (n2)
                I2 = 0, d2 = true;
              else
                break;
            }
            ++t2, y3 = y3 * i2 + I2;
          }
          return t2 === l2 || r2 != null && t2 - l2 !== r2 || d2 ? { n: null, pos: t2 } : { n: y3, pos: t2 };
        }
        function is(a2, t2, e2, s2, i2, r2) {
          let n2 = a2.charCodeAt(t2), o2;
          if (n2 === 123) {
            if (++t2, { code: o2, pos: t2 } = Ze2(a2, t2, e2, s2, a2.indexOf("}", t2) - t2, true, i2, r2), ++t2, o2 !== null && o2 > 1114111)
              if (i2)
                r2.invalidCodePoint(t2, e2, s2);
              else
                return { code: null, pos: t2 };
          } else
            ({ code: o2, pos: t2 } = Ze2(a2, t2, e2, s2, 4, false, i2, r2));
          return { code: o2, pos: t2 };
        }
        function ce3(a2, t2, e2) {
          return new F(e2, a2 - t2, a2);
        }
        var Di2 = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), O2 = class {
          constructor(t2) {
            this.type = t2.type, this.value = t2.value, this.start = t2.start, this.end = t2.end, this.loc = new ee3(t2.startLoc, t2.endLoc);
          }
        }, et2 = class extends Ye2 {
          constructor(t2, e2) {
            super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = { invalidDigit: (s2, i2, r2, n2) => this.options.errorRecovery ? (this.raise(p2.InvalidDigit, ce3(s2, i2, r2), { radix: n2 }), true) : false, numericSeparatorInEscapeSequence: this.errorBuilder(p2.NumericSeparatorInEscapeSequence), unexpectedNumericSeparator: this.errorBuilder(p2.UnexpectedNumericSeparator) }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, { invalidEscapeSequence: this.errorBuilder(p2.InvalidEscapeSequence), invalidCodePoint: this.errorBuilder(p2.InvalidCodePoint) }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: (s2, i2, r2) => {
              this.recordStrictModeErrors(p2.StrictNumericEscape, ce3(s2, i2, r2));
            }, unterminated: (s2, i2, r2) => {
              throw this.raise(p2.UnterminatedString, ce3(s2 - 1, i2, r2));
            } }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: this.errorBuilder(p2.StrictNumericEscape), unterminated: (s2, i2, r2) => {
              throw this.raise(p2.UnterminatedTemplate, ce3(s2, i2, r2));
            } }), this.state = new Qe3(), this.state.init(t2), this.input = e2, this.length = e2.length, this.comments = [], this.isLookahead = false;
          }
          pushToken(t2) {
            this.tokens.length = this.state.tokensLength, this.tokens.push(t2), ++this.state.tokensLength;
          }
          next() {
            this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new O2(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
          }
          eat(t2) {
            return this.match(t2) ? (this.next(), true) : false;
          }
          match(t2) {
            return this.state.type === t2;
          }
          createLookaheadState(t2) {
            return { pos: t2.pos, value: null, type: t2.type, start: t2.start, end: t2.end, context: [this.curContext()], inType: t2.inType, startLoc: t2.startLoc, lastTokEndLoc: t2.lastTokEndLoc, curLine: t2.curLine, lineStart: t2.lineStart, curPosition: t2.curPosition };
          }
          lookahead() {
            let t2 = this.state;
            this.state = this.createLookaheadState(t2), this.isLookahead = true, this.nextToken(), this.isLookahead = false;
            let e2 = this.state;
            return this.state = t2, e2;
          }
          nextTokenStart() {
            return this.nextTokenStartSince(this.state.pos);
          }
          nextTokenStartSince(t2) {
            return Ve2.lastIndex = t2, Ve2.test(this.input) ? Ve2.lastIndex : t2;
          }
          lookaheadCharCode() {
            return this.input.charCodeAt(this.nextTokenStart());
          }
          nextTokenInLineStart() {
            return this.nextTokenInLineStartSince(this.state.pos);
          }
          nextTokenInLineStartSince(t2) {
            return Ne2.lastIndex = t2, Ne2.test(this.input) ? Ne2.lastIndex : t2;
          }
          lookaheadInLineCharCode() {
            return this.input.charCodeAt(this.nextTokenInLineStart());
          }
          codePointAtPos(t2) {
            let e2 = this.input.charCodeAt(t2);
            if ((e2 & 64512) === 55296 && ++t2 < this.input.length) {
              let s2 = this.input.charCodeAt(t2);
              (s2 & 64512) === 56320 && (e2 = 65536 + ((e2 & 1023) << 10) + (s2 & 1023));
            }
            return e2;
          }
          setStrict(t2) {
            this.state.strict = t2, t2 && (this.state.strictErrors.forEach(([e2, s2]) => this.raise(e2, s2)), this.state.strictErrors.clear());
          }
          curContext() {
            return this.state.context[this.state.context.length - 1];
          }
          nextToken() {
            if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
              this.finishToken(139);
              return;
            }
            this.getTokenFromCode(this.codePointAtPos(this.state.pos));
          }
          skipBlockComment(t2) {
            let e2;
            this.isLookahead || (e2 = this.state.curPosition());
            let s2 = this.state.pos, i2 = this.input.indexOf(t2, s2 + 2);
            if (i2 === -1)
              throw this.raise(p2.UnterminatedComment, this.state.curPosition());
            for (this.state.pos = i2 + t2.length, we3.lastIndex = s2 + 2; we3.test(this.input) && we3.lastIndex <= i2; )
              ++this.state.curLine, this.state.lineStart = we3.lastIndex;
            if (this.isLookahead)
              return;
            let r2 = { type: "CommentBlock", value: this.input.slice(s2 + 2, i2), start: s2, end: i2 + t2.length, loc: new ee3(e2, this.state.curPosition()) };
            return this.options.tokens && this.pushToken(r2), r2;
          }
          skipLineComment(t2) {
            let e2 = this.state.pos, s2;
            this.isLookahead || (s2 = this.state.curPosition());
            let i2 = this.input.charCodeAt(this.state.pos += t2);
            if (this.state.pos < this.length)
              for (; !fe2(i2) && ++this.state.pos < this.length; )
                i2 = this.input.charCodeAt(this.state.pos);
            if (this.isLookahead)
              return;
            let r2 = this.state.pos, o2 = { type: "CommentLine", value: this.input.slice(e2 + t2, r2), start: e2, end: r2, loc: new ee3(s2, this.state.curPosition()) };
            return this.options.tokens && this.pushToken(o2), o2;
          }
          skipSpace() {
            let t2 = this.state.pos, e2 = [];
            e:
              for (; this.state.pos < this.length; ) {
                let s2 = this.input.charCodeAt(this.state.pos);
                switch (s2) {
                  case 32:
                  case 160:
                  case 9:
                    ++this.state.pos;
                    break;
                  case 13:
                    this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
                  case 10:
                  case 8232:
                  case 8233:
                    ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
                    break;
                  case 47:
                    switch (this.input.charCodeAt(this.state.pos + 1)) {
                      case 42: {
                        let i2 = this.skipBlockComment("*/");
                        i2 !== void 0 && (this.addComment(i2), this.options.attachComment && e2.push(i2));
                        break;
                      }
                      case 47: {
                        let i2 = this.skipLineComment(2);
                        i2 !== void 0 && (this.addComment(i2), this.options.attachComment && e2.push(i2));
                        break;
                      }
                      default:
                        break e;
                    }
                    break;
                  default:
                    if (Ni(s2))
                      ++this.state.pos;
                    else if (s2 === 45 && !this.inModule && this.options.annexB) {
                      let i2 = this.state.pos;
                      if (this.input.charCodeAt(i2 + 1) === 45 && this.input.charCodeAt(i2 + 2) === 62 && (t2 === 0 || this.state.lineStart > t2)) {
                        let r2 = this.skipLineComment(3);
                        r2 !== void 0 && (this.addComment(r2), this.options.attachComment && e2.push(r2));
                      } else
                        break e;
                    } else if (s2 === 60 && !this.inModule && this.options.annexB) {
                      let i2 = this.state.pos;
                      if (this.input.charCodeAt(i2 + 1) === 33 && this.input.charCodeAt(i2 + 2) === 45 && this.input.charCodeAt(i2 + 3) === 45) {
                        let r2 = this.skipLineComment(4);
                        r2 !== void 0 && (this.addComment(r2), this.options.attachComment && e2.push(r2));
                      } else
                        break e;
                    } else
                      break e;
                }
              }
            if (e2.length > 0) {
              let s2 = this.state.pos, i2 = { start: t2, end: s2, comments: e2, leadingNode: null, trailingNode: null, containingNode: null };
              this.state.commentStack.push(i2);
            }
          }
          finishToken(t2, e2) {
            this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
            let s2 = this.state.type;
            this.state.type = t2, this.state.value = e2, this.isLookahead || this.updateContext(s2);
          }
          replaceToken(t2) {
            this.state.type = t2, this.updateContext();
          }
          readToken_numberSign() {
            if (this.state.pos === 0 && this.readToken_interpreter())
              return;
            let t2 = this.state.pos + 1, e2 = this.codePointAtPos(t2);
            if (e2 >= 48 && e2 <= 57)
              throw this.raise(p2.UnexpectedDigitAfterHash, this.state.curPosition());
            if (e2 === 123 || e2 === 91 && this.hasPlugin("recordAndTuple")) {
              if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
                throw this.raise(e2 === 123 ? p2.RecordExpressionHashIncorrectStartSyntaxType : p2.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
              this.state.pos += 2, e2 === 123 ? this.finishToken(7) : this.finishToken(1);
            } else
              _3(e2) ? (++this.state.pos, this.finishToken(138, this.readWord1(e2))) : e2 === 92 ? (++this.state.pos, this.finishToken(138, this.readWord1())) : this.finishOp(27, 1);
          }
          readToken_dot() {
            let t2 = this.input.charCodeAt(this.state.pos + 1);
            if (t2 >= 48 && t2 <= 57) {
              this.readNumber(true);
              return;
            }
            t2 === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
          }
          readToken_slash() {
            this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
          }
          readToken_interpreter() {
            if (this.state.pos !== 0 || this.length < 2)
              return false;
            let t2 = this.input.charCodeAt(this.state.pos + 1);
            if (t2 !== 33)
              return false;
            let e2 = this.state.pos;
            for (this.state.pos += 1; !fe2(t2) && ++this.state.pos < this.length; )
              t2 = this.input.charCodeAt(this.state.pos);
            let s2 = this.input.slice(e2 + 2, this.state.pos);
            return this.finishToken(28, s2), true;
          }
          readToken_mult_modulo(t2) {
            let e2 = t2 === 42 ? 55 : 54, s2 = 1, i2 = this.input.charCodeAt(this.state.pos + 1);
            t2 === 42 && i2 === 42 && (s2++, i2 = this.input.charCodeAt(this.state.pos + 2), e2 = 57), i2 === 61 && !this.state.inType && (s2++, e2 = t2 === 37 ? 33 : 30), this.finishOp(e2, s2);
          }
          readToken_pipe_amp(t2) {
            let e2 = this.input.charCodeAt(this.state.pos + 1);
            if (e2 === t2) {
              this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(t2 === 124 ? 41 : 42, 2);
              return;
            }
            if (t2 === 124) {
              if (e2 === 62) {
                this.finishOp(39, 2);
                return;
              }
              if (this.hasPlugin("recordAndTuple") && e2 === 125) {
                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                  throw this.raise(p2.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
                this.state.pos += 2, this.finishToken(9);
                return;
              }
              if (this.hasPlugin("recordAndTuple") && e2 === 93) {
                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                  throw this.raise(p2.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
                this.state.pos += 2, this.finishToken(4);
                return;
              }
            }
            if (e2 === 61) {
              this.finishOp(30, 2);
              return;
            }
            this.finishOp(t2 === 124 ? 43 : 45, 1);
          }
          readToken_caret() {
            let t2 = this.input.charCodeAt(this.state.pos + 1);
            t2 === 61 && !this.state.inType ? this.finishOp(32, 2) : t2 === 94 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "^^" }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
          }
          readToken_atSign() {
            this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "@@" }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
          }
          readToken_plus_min(t2) {
            let e2 = this.input.charCodeAt(this.state.pos + 1);
            if (e2 === t2) {
              this.finishOp(34, 2);
              return;
            }
            e2 === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
          }
          readToken_lt() {
            let { pos: t2 } = this.state, e2 = this.input.charCodeAt(t2 + 1);
            if (e2 === 60) {
              if (this.input.charCodeAt(t2 + 2) === 61) {
                this.finishOp(30, 3);
                return;
              }
              this.finishOp(51, 2);
              return;
            }
            if (e2 === 61) {
              this.finishOp(49, 2);
              return;
            }
            this.finishOp(47, 1);
          }
          readToken_gt() {
            let { pos: t2 } = this.state, e2 = this.input.charCodeAt(t2 + 1);
            if (e2 === 62) {
              let s2 = this.input.charCodeAt(t2 + 2) === 62 ? 3 : 2;
              if (this.input.charCodeAt(t2 + s2) === 61) {
                this.finishOp(30, s2 + 1);
                return;
              }
              this.finishOp(52, s2);
              return;
            }
            if (e2 === 61) {
              this.finishOp(49, 2);
              return;
            }
            this.finishOp(48, 1);
          }
          readToken_eq_excl(t2) {
            let e2 = this.input.charCodeAt(this.state.pos + 1);
            if (e2 === 61) {
              this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
              return;
            }
            if (t2 === 61 && e2 === 62) {
              this.state.pos += 2, this.finishToken(19);
              return;
            }
            this.finishOp(t2 === 61 ? 29 : 35, 1);
          }
          readToken_question() {
            let t2 = this.input.charCodeAt(this.state.pos + 1), e2 = this.input.charCodeAt(this.state.pos + 2);
            t2 === 63 ? e2 === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : t2 === 46 && !(e2 >= 48 && e2 <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
          }
          getTokenFromCode(t2) {
            switch (t2) {
              case 46:
                this.readToken_dot();
                return;
              case 40:
                ++this.state.pos, this.finishToken(10);
                return;
              case 41:
                ++this.state.pos, this.finishToken(11);
                return;
              case 59:
                ++this.state.pos, this.finishToken(13);
                return;
              case 44:
                ++this.state.pos, this.finishToken(12);
                return;
              case 91:
                if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                    throw this.raise(p2.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
                  this.state.pos += 2, this.finishToken(2);
                } else
                  ++this.state.pos, this.finishToken(0);
                return;
              case 93:
                ++this.state.pos, this.finishToken(3);
                return;
              case 123:
                if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                    throw this.raise(p2.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
                  this.state.pos += 2, this.finishToken(6);
                } else
                  ++this.state.pos, this.finishToken(5);
                return;
              case 125:
                ++this.state.pos, this.finishToken(8);
                return;
              case 58:
                this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
                return;
              case 63:
                this.readToken_question();
                return;
              case 96:
                this.readTemplateToken();
                return;
              case 48: {
                let e2 = this.input.charCodeAt(this.state.pos + 1);
                if (e2 === 120 || e2 === 88) {
                  this.readRadixNumber(16);
                  return;
                }
                if (e2 === 111 || e2 === 79) {
                  this.readRadixNumber(8);
                  return;
                }
                if (e2 === 98 || e2 === 66) {
                  this.readRadixNumber(2);
                  return;
                }
              }
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
                this.readNumber(false);
                return;
              case 34:
              case 39:
                this.readString(t2);
                return;
              case 47:
                this.readToken_slash();
                return;
              case 37:
              case 42:
                this.readToken_mult_modulo(t2);
                return;
              case 124:
              case 38:
                this.readToken_pipe_amp(t2);
                return;
              case 94:
                this.readToken_caret();
                return;
              case 43:
              case 45:
                this.readToken_plus_min(t2);
                return;
              case 60:
                this.readToken_lt();
                return;
              case 62:
                this.readToken_gt();
                return;
              case 61:
              case 33:
                this.readToken_eq_excl(t2);
                return;
              case 126:
                this.finishOp(36, 1);
                return;
              case 64:
                this.readToken_atSign();
                return;
              case 35:
                this.readToken_numberSign();
                return;
              case 92:
                this.readWord();
                return;
              default:
                if (_3(t2)) {
                  this.readWord(t2);
                  return;
                }
            }
            throw this.raise(p2.InvalidOrUnexpectedToken, this.state.curPosition(), { unexpected: String.fromCodePoint(t2) });
          }
          finishOp(t2, e2) {
            let s2 = this.input.slice(this.state.pos, this.state.pos + e2);
            this.state.pos += e2, this.finishToken(t2, s2);
          }
          readRegexp() {
            let t2 = this.state.startLoc, e2 = this.state.start + 1, s2, i2, { pos: r2 } = this.state;
            for (; ; ++r2) {
              if (r2 >= this.length)
                throw this.raise(p2.UnterminatedRegExp, v2(t2, 1));
              let c2 = this.input.charCodeAt(r2);
              if (fe2(c2))
                throw this.raise(p2.UnterminatedRegExp, v2(t2, 1));
              if (s2)
                s2 = false;
              else {
                if (c2 === 91)
                  i2 = true;
                else if (c2 === 93 && i2)
                  i2 = false;
                else if (c2 === 47 && !i2)
                  break;
                s2 = c2 === 92;
              }
            }
            let n2 = this.input.slice(e2, r2);
            ++r2;
            let o2 = "", h2 = () => v2(t2, r2 + 2 - e2);
            for (; r2 < this.length; ) {
              let c2 = this.codePointAtPos(r2), l2 = String.fromCharCode(c2);
              if (Di2.has(c2))
                c2 === 118 ? o2.includes("u") && this.raise(p2.IncompatibleRegExpUVFlags, h2()) : c2 === 117 && o2.includes("v") && this.raise(p2.IncompatibleRegExpUVFlags, h2()), o2.includes(l2) && this.raise(p2.DuplicateRegExpFlags, h2());
              else if (Q3(c2) || c2 === 92)
                this.raise(p2.MalformedRegExpFlags, h2());
              else
                break;
              ++r2, o2 += l2;
            }
            this.state.pos = r2, this.finishToken(137, { pattern: n2, flags: o2 });
          }
          readInt(t2, e2, s2 = false, i2 = true) {
            let { n: r2, pos: n2 } = ss(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t2, e2, s2, i2, this.errorHandlers_readInt, false);
            return this.state.pos = n2, r2;
          }
          readRadixNumber(t2) {
            let e2 = this.state.curPosition(), s2 = false;
            this.state.pos += 2;
            let i2 = this.readInt(t2);
            i2 == null && this.raise(p2.InvalidDigit, v2(e2, 2), { radix: t2 });
            let r2 = this.input.charCodeAt(this.state.pos);
            if (r2 === 110)
              ++this.state.pos, s2 = true;
            else if (r2 === 109)
              throw this.raise(p2.InvalidDecimal, e2);
            if (_3(this.codePointAtPos(this.state.pos)))
              throw this.raise(p2.NumberIdentifier, this.state.curPosition());
            if (s2) {
              let n2 = this.input.slice(e2.index, this.state.pos).replace(/[_n]/g, "");
              this.finishToken(135, n2);
              return;
            }
            this.finishToken(134, i2);
          }
          readNumber(t2) {
            let e2 = this.state.pos, s2 = this.state.curPosition(), i2 = false, r2 = false, n2 = false, o2 = false, h2 = false;
            !t2 && this.readInt(10) === null && this.raise(p2.InvalidNumber, this.state.curPosition());
            let c2 = this.state.pos - e2 >= 2 && this.input.charCodeAt(e2) === 48;
            if (c2) {
              let d2 = this.input.slice(e2, this.state.pos);
              if (this.recordStrictModeErrors(p2.StrictOctalLiteral, s2), !this.state.strict) {
                let y3 = d2.indexOf("_");
                y3 > 0 && this.raise(p2.ZeroDigitNumericSeparator, v2(s2, y3));
              }
              h2 = c2 && !/[89]/.test(d2);
            }
            let l2 = this.input.charCodeAt(this.state.pos);
            if (l2 === 46 && !h2 && (++this.state.pos, this.readInt(10), i2 = true, l2 = this.input.charCodeAt(this.state.pos)), (l2 === 69 || l2 === 101) && !h2 && (l2 = this.input.charCodeAt(++this.state.pos), (l2 === 43 || l2 === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(p2.InvalidOrMissingExponent, s2), i2 = true, o2 = true, l2 = this.input.charCodeAt(this.state.pos)), l2 === 110 && ((i2 || c2) && this.raise(p2.InvalidBigIntLiteral, s2), ++this.state.pos, r2 = true), l2 === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (o2 || c2) && this.raise(p2.InvalidDecimal, s2), ++this.state.pos, n2 = true), _3(this.codePointAtPos(this.state.pos)))
              throw this.raise(p2.NumberIdentifier, this.state.curPosition());
            let u2 = this.input.slice(e2, this.state.pos).replace(/[_mn]/g, "");
            if (r2) {
              this.finishToken(135, u2);
              return;
            }
            if (n2) {
              this.finishToken(136, u2);
              return;
            }
            let f2 = h2 ? parseInt(u2, 8) : parseFloat(u2);
            this.finishToken(134, f2);
          }
          readCodePoint(t2) {
            let { code: e2, pos: s2 } = is(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t2, this.errorHandlers_readCodePoint);
            return this.state.pos = s2, e2;
          }
          readString(t2) {
            let { str: e2, pos: s2, curLine: i2, lineStart: r2 } = Ut2(t2 === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
            this.state.pos = s2 + 1, this.state.lineStart = r2, this.state.curLine = i2, this.finishToken(133, e2);
          }
          readTemplateContinuation() {
            this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
          }
          readTemplateToken() {
            let t2 = this.input[this.state.pos], { str: e2, firstInvalidLoc: s2, pos: i2, curLine: r2, lineStart: n2 } = Ut2("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
            this.state.pos = i2 + 1, this.state.lineStart = n2, this.state.curLine = r2, s2 && (this.state.firstInvalidTemplateEscapePos = new F(s2.curLine, s2.pos - s2.lineStart, s2.pos)), this.input.codePointAt(i2) === 96 ? this.finishToken(24, s2 ? null : t2 + e2 + "`") : (this.state.pos++, this.finishToken(25, s2 ? null : t2 + e2 + "${"));
          }
          recordStrictModeErrors(t2, e2) {
            let s2 = e2.index;
            this.state.strict && !this.state.strictErrors.has(s2) ? this.raise(t2, e2) : this.state.strictErrors.set(s2, [t2, e2]);
          }
          readWord1(t2) {
            this.state.containsEsc = false;
            let e2 = "", s2 = this.state.pos, i2 = this.state.pos;
            for (t2 !== void 0 && (this.state.pos += t2 <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
              let r2 = this.codePointAtPos(this.state.pos);
              if (Q3(r2))
                this.state.pos += r2 <= 65535 ? 1 : 2;
              else if (r2 === 92) {
                this.state.containsEsc = true, e2 += this.input.slice(i2, this.state.pos);
                let n2 = this.state.curPosition(), o2 = this.state.pos === s2 ? _3 : Q3;
                if (this.input.charCodeAt(++this.state.pos) !== 117) {
                  this.raise(p2.MissingUnicodeEscape, this.state.curPosition()), i2 = this.state.pos - 1;
                  continue;
                }
                ++this.state.pos;
                let h2 = this.readCodePoint(true);
                h2 !== null && (o2(h2) || this.raise(p2.EscapedCharNotAnIdentifier, n2), e2 += String.fromCodePoint(h2)), i2 = this.state.pos;
              } else
                break;
            }
            return e2 + this.input.slice(i2, this.state.pos);
          }
          readWord(t2) {
            let e2 = this.readWord1(t2), s2 = ut3.get(e2);
            s2 !== void 0 ? this.finishToken(s2, K2(s2)) : this.finishToken(132, e2);
          }
          checkKeywordEscapes() {
            let { type: t2 } = this.state;
            Pt2(t2) && this.state.containsEsc && this.raise(p2.InvalidEscapedReservedWord, this.state.startLoc, { reservedWord: K2(t2) });
          }
          raise(t2, e2, s2 = {}) {
            let i2 = e2 instanceof F ? e2 : e2.loc.start, r2 = t2(i2, s2);
            if (!this.options.errorRecovery)
              throw r2;
            return this.isLookahead || this.state.errors.push(r2), r2;
          }
          raiseOverwrite(t2, e2, s2 = {}) {
            let i2 = e2 instanceof F ? e2 : e2.loc.start, r2 = i2.index, n2 = this.state.errors;
            for (let o2 = n2.length - 1; o2 >= 0; o2--) {
              let h2 = n2[o2];
              if (h2.loc.index === r2)
                return n2[o2] = t2(i2, s2);
              if (h2.loc.index < r2)
                break;
            }
            return this.raise(t2, e2, s2);
          }
          updateContext(t2) {
          }
          unexpected(t2, e2) {
            throw this.raise(p2.UnexpectedToken, t2 ?? this.state.startLoc, { expected: e2 ? K2(e2) : null });
          }
          expectPlugin(t2, e2) {
            if (this.hasPlugin(t2))
              return true;
            throw this.raise(p2.MissingPlugin, e2 ?? this.state.startLoc, { missingPlugin: [t2] });
          }
          expectOnePlugin(t2) {
            if (!t2.some((e2) => this.hasPlugin(e2)))
              throw this.raise(p2.MissingOneOfPlugins, this.state.startLoc, { missingPlugin: t2 });
          }
          errorBuilder(t2) {
            return (e2, s2, i2) => {
              this.raise(t2, ce3(e2, s2, i2));
            };
          }
        }, tt2 = class {
          constructor() {
            this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
          }
        }, st3 = class {
          constructor(t2) {
            this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = t2;
          }
          current() {
            return this.stack[this.stack.length - 1];
          }
          enter() {
            this.stack.push(new tt2());
          }
          exit() {
            let t2 = this.stack.pop(), e2 = this.current();
            for (let [s2, i2] of Array.from(t2.undefinedPrivateNames))
              e2 ? e2.undefinedPrivateNames.has(s2) || e2.undefinedPrivateNames.set(s2, i2) : this.parser.raise(p2.InvalidPrivateFieldResolution, i2, { identifierName: s2 });
          }
          declarePrivateName(t2, e2, s2) {
            let { privateNames: i2, loneAccessors: r2, undefinedPrivateNames: n2 } = this.current(), o2 = i2.has(t2);
            if (e2 & 3) {
              let h2 = o2 && r2.get(t2);
              if (h2) {
                let c2 = h2 & 4, l2 = e2 & 4, u2 = h2 & 3, f2 = e2 & 3;
                o2 = u2 === f2 || c2 !== l2, o2 || r2.delete(t2);
              } else
                o2 || r2.set(t2, e2);
            }
            o2 && this.parser.raise(p2.PrivateNameRedeclaration, s2, { identifierName: t2 }), i2.add(t2), n2.delete(t2);
          }
          usePrivateName(t2, e2) {
            let s2;
            for (s2 of this.stack)
              if (s2.privateNames.has(t2))
                return;
            s2 ? s2.undefinedPrivateNames.set(t2, e2) : this.parser.raise(p2.InvalidPrivateFieldResolution, e2, { identifierName: t2 });
          }
        }, te2 = class {
          constructor(t2 = 0) {
            this.type = t2;
          }
          canBeArrowParameterDeclaration() {
            return this.type === 2 || this.type === 1;
          }
          isCertainlyParameterDeclaration() {
            return this.type === 3;
          }
        }, De3 = class extends te2 {
          constructor(t2) {
            super(t2), this.declarationErrors = /* @__PURE__ */ new Map();
          }
          recordDeclarationError(t2, e2) {
            let s2 = e2.index;
            this.declarationErrors.set(s2, [t2, e2]);
          }
          clearDeclarationError(t2) {
            this.declarationErrors.delete(t2);
          }
          iterateErrors(t2) {
            this.declarationErrors.forEach(t2);
          }
        }, it3 = class {
          constructor(t2) {
            this.parser = void 0, this.stack = [new te2()], this.parser = t2;
          }
          enter(t2) {
            this.stack.push(t2);
          }
          exit() {
            this.stack.pop();
          }
          recordParameterInitializerError(t2, e2) {
            let s2 = e2.loc.start, { stack: i2 } = this, r2 = i2.length - 1, n2 = i2[r2];
            for (; !n2.isCertainlyParameterDeclaration(); ) {
              if (n2.canBeArrowParameterDeclaration())
                n2.recordDeclarationError(t2, s2);
              else
                return;
              n2 = i2[--r2];
            }
            this.parser.raise(t2, s2);
          }
          recordArrowParameterBindingError(t2, e2) {
            let { stack: s2 } = this, i2 = s2[s2.length - 1], r2 = e2.loc.start;
            if (i2.isCertainlyParameterDeclaration())
              this.parser.raise(t2, r2);
            else if (i2.canBeArrowParameterDeclaration())
              i2.recordDeclarationError(t2, r2);
            else
              return;
          }
          recordAsyncArrowParametersError(t2) {
            let { stack: e2 } = this, s2 = e2.length - 1, i2 = e2[s2];
            for (; i2.canBeArrowParameterDeclaration(); )
              i2.type === 2 && i2.recordDeclarationError(p2.AwaitBindingIdentifier, t2), i2 = e2[--s2];
          }
          validateAsPattern() {
            let { stack: t2 } = this, e2 = t2[t2.length - 1];
            e2.canBeArrowParameterDeclaration() && e2.iterateErrors(([s2, i2]) => {
              this.parser.raise(s2, i2);
              let r2 = t2.length - 2, n2 = t2[r2];
              for (; n2.canBeArrowParameterDeclaration(); )
                n2.clearDeclarationError(i2.index), n2 = t2[--r2];
            });
          }
        };
        function Mi2() {
          return new te2(3);
        }
        function Oi2() {
          return new De3(1);
        }
        function Fi() {
          return new De3(2);
        }
        function rs() {
          return new te2();
        }
        var rt3 = class {
          constructor() {
            this.stacks = [];
          }
          enter(t2) {
            this.stacks.push(t2);
          }
          exit() {
            this.stacks.pop();
          }
          currentFlags() {
            return this.stacks[this.stacks.length - 1];
          }
          get hasAwait() {
            return (this.currentFlags() & 2) > 0;
          }
          get hasYield() {
            return (this.currentFlags() & 1) > 0;
          }
          get hasReturn() {
            return (this.currentFlags() & 4) > 0;
          }
          get hasIn() {
            return (this.currentFlags() & 8) > 0;
          }
        };
        function ke3(a2, t2) {
          return (a2 ? 2 : 0) | (t2 ? 1 : 0);
        }
        var at3 = class extends et2 {
          addExtra(t2, e2, s2, i2 = true) {
            if (!t2)
              return;
            let r2 = t2.extra = t2.extra || {};
            i2 ? r2[e2] = s2 : Object.defineProperty(r2, e2, { enumerable: i2, value: s2 });
          }
          isContextual(t2) {
            return this.state.type === t2 && !this.state.containsEsc;
          }
          isUnparsedContextual(t2, e2) {
            let s2 = t2 + e2.length;
            if (this.input.slice(t2, s2) === e2) {
              let i2 = this.input.charCodeAt(s2);
              return !(Q3(i2) || (i2 & 64512) === 55296);
            }
            return false;
          }
          isLookaheadContextual(t2) {
            let e2 = this.nextTokenStart();
            return this.isUnparsedContextual(e2, t2);
          }
          eatContextual(t2) {
            return this.isContextual(t2) ? (this.next(), true) : false;
          }
          expectContextual(t2, e2) {
            if (!this.eatContextual(t2)) {
              if (e2 != null)
                throw this.raise(e2, this.state.startLoc);
              this.unexpected(null, t2);
            }
          }
          canInsertSemicolon() {
            return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
          }
          hasPrecedingLineBreak() {
            return ts.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
          }
          hasFollowingLineBreak() {
            return Bt2.lastIndex = this.state.end, Bt2.test(this.input);
          }
          isLineTerminator() {
            return this.eat(13) || this.canInsertSemicolon();
          }
          semicolon(t2 = true) {
            (t2 ? this.isLineTerminator() : this.eat(13)) || this.raise(p2.MissingSemicolon, this.state.lastTokEndLoc);
          }
          expect(t2, e2) {
            this.eat(t2) || this.unexpected(e2, t2);
          }
          tryParse(t2, e2 = this.state.clone()) {
            let s2 = { node: null };
            try {
              let i2 = t2((r2 = null) => {
                throw s2.node = r2, s2;
              });
              if (this.state.errors.length > e2.errors.length) {
                let r2 = this.state;
                return this.state = e2, this.state.tokensLength = r2.tokensLength, { node: i2, error: r2.errors[e2.errors.length], thrown: false, aborted: false, failState: r2 };
              }
              return { node: i2, error: null, thrown: false, aborted: false, failState: null };
            } catch (i2) {
              let r2 = this.state;
              if (this.state = e2, i2 instanceof SyntaxError)
                return { node: null, error: i2, thrown: true, aborted: false, failState: r2 };
              if (i2 === s2)
                return { node: s2.node, error: null, thrown: false, aborted: true, failState: r2 };
              throw i2;
            }
          }
          checkExpressionErrors(t2, e2) {
            if (!t2)
              return false;
            let { shorthandAssignLoc: s2, doubleProtoLoc: i2, privateKeyLoc: r2, optionalParametersLoc: n2 } = t2, o2 = !!s2 || !!i2 || !!n2 || !!r2;
            if (!e2)
              return o2;
            s2 != null && this.raise(p2.InvalidCoverInitializedName, s2), i2 != null && this.raise(p2.DuplicateProto, i2), r2 != null && this.raise(p2.UnexpectedPrivateField, r2), n2 != null && this.unexpected(n2);
          }
          isLiteralPropertyName() {
            return Wt2(this.state.type);
          }
          isPrivateName(t2) {
            return t2.type === "PrivateName";
          }
          getPrivateNameSV(t2) {
            return t2.id.name;
          }
          hasPropertyAsPrivateName(t2) {
            return (t2.type === "MemberExpression" || t2.type === "OptionalMemberExpression") && this.isPrivateName(t2.property);
          }
          isObjectProperty(t2) {
            return t2.type === "ObjectProperty";
          }
          isObjectMethod(t2) {
            return t2.type === "ObjectMethod";
          }
          initializeScopes(t2 = this.options.sourceType === "module") {
            let e2 = this.state.labels;
            this.state.labels = [];
            let s2 = this.exportedIdentifiers;
            this.exportedIdentifiers = /* @__PURE__ */ new Set();
            let i2 = this.inModule;
            this.inModule = t2;
            let r2 = this.scope, n2 = this.getScopeHandler();
            this.scope = new n2(this, t2);
            let o2 = this.prodParam;
            this.prodParam = new rt3();
            let h2 = this.classScope;
            this.classScope = new st3(this);
            let c2 = this.expressionScope;
            return this.expressionScope = new it3(this), () => {
              this.state.labels = e2, this.exportedIdentifiers = s2, this.inModule = i2, this.scope = r2, this.prodParam = o2, this.classScope = h2, this.expressionScope = c2;
            };
          }
          enterInitialScopes() {
            let t2 = 0;
            this.inModule && (t2 |= 2), this.scope.enter(1), this.prodParam.enter(t2);
          }
          checkDestructuringPrivate(t2) {
            let { privateKeyLoc: e2 } = t2;
            e2 !== null && this.expectPlugin("destructuringPrivate", e2);
          }
        }, Z3 = class {
          constructor() {
            this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
          }
        }, se2 = class {
          constructor(t2, e2, s2) {
            this.type = "", this.start = e2, this.end = 0, this.loc = new ee3(s2), t2 != null && t2.options.ranges && (this.range = [e2, 0]), t2 != null && t2.filename && (this.loc.filename = t2.filename);
          }
        }, bt2 = se2.prototype;
        bt2.__clone = function() {
          let a2 = new se2(void 0, this.start, this.loc.start), t2 = Object.keys(this);
          for (let e2 = 0, s2 = t2.length; e2 < s2; e2++) {
            let i2 = t2[e2];
            i2 !== "leadingComments" && i2 !== "trailingComments" && i2 !== "innerComments" && (a2[i2] = this[i2]);
          }
          return a2;
        };
        function Bi2(a2) {
          return $2(a2);
        }
        function $2(a2) {
          let { type: t2, start: e2, end: s2, loc: i2, range: r2, extra: n2, name: o2 } = a2, h2 = Object.create(bt2);
          return h2.type = t2, h2.start = e2, h2.end = s2, h2.loc = i2, h2.range = r2, h2.extra = n2, h2.name = o2, t2 === "Placeholder" && (h2.expectedNode = a2.expectedNode), h2;
        }
        function Ri(a2) {
          let { type: t2, start: e2, end: s2, loc: i2, range: r2, extra: n2 } = a2;
          if (t2 === "Placeholder")
            return Bi2(a2);
          let o2 = Object.create(bt2);
          return o2.type = t2, o2.start = e2, o2.end = s2, o2.loc = i2, o2.range = r2, a2.raw !== void 0 ? o2.raw = a2.raw : o2.extra = n2, o2.value = a2.value, o2;
        }
        var nt3 = class extends at3 {
          startNode() {
            let t2 = this.state.startLoc;
            return new se2(this, t2.index, t2);
          }
          startNodeAt(t2) {
            return new se2(this, t2.index, t2);
          }
          startNodeAtNode(t2) {
            return this.startNodeAt(t2.loc.start);
          }
          finishNode(t2, e2) {
            return this.finishNodeAt(t2, e2, this.state.lastTokEndLoc);
          }
          finishNodeAt(t2, e2, s2) {
            return t2.type = e2, t2.end = s2.index, t2.loc.end = s2, this.options.ranges && (t2.range[1] = s2.index), this.options.attachComment && this.processComment(t2), t2;
          }
          resetStartLocation(t2, e2) {
            t2.start = e2.index, t2.loc.start = e2, this.options.ranges && (t2.range[0] = e2.index);
          }
          resetEndLocation(t2, e2 = this.state.lastTokEndLoc) {
            t2.end = e2.index, t2.loc.end = e2, this.options.ranges && (t2.range[1] = e2.index);
          }
          resetStartLocationFromNode(t2, e2) {
            this.resetStartLocation(t2, e2.loc.start);
          }
        }, Ui = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), g2 = j2`flow`({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: ({ reservedType: a2 }) => `Cannot overwrite reserved type ${a2}.`, DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: ({ memberName: a2, enumName: t2 }) => `Boolean enum members need to be initialized. Use either \`${a2} = true,\` or \`${a2} = false,\` in enum \`${t2}\`.`, EnumDuplicateMemberName: ({ memberName: a2, enumName: t2 }) => `Enum member names need to be unique, but the name \`${a2}\` has already been used before in enum \`${t2}\`.`, EnumInconsistentMemberValues: ({ enumName: a2 }) => `Enum \`${a2}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`, EnumInvalidExplicitType: ({ invalidEnumType: a2, enumName: t2 }) => `Enum type \`${a2}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t2}\`.`, EnumInvalidExplicitTypeUnknownSupplied: ({ enumName: a2 }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${a2}\`.`, EnumInvalidMemberInitializerPrimaryType: ({ enumName: a2, memberName: t2, explicitType: e2 }) => `Enum \`${a2}\` has type \`${e2}\`, so the initializer of \`${t2}\` needs to be a ${e2} literal.`, EnumInvalidMemberInitializerSymbolType: ({ enumName: a2, memberName: t2 }) => `Symbol enum members cannot be initialized. Use \`${t2},\` in enum \`${a2}\`.`, EnumInvalidMemberInitializerUnknownType: ({ enumName: a2, memberName: t2 }) => `The enum member initializer for \`${t2}\` needs to be a literal (either a boolean, number, or string) in enum \`${a2}\`.`, EnumInvalidMemberName: ({ enumName: a2, memberName: t2, suggestion: e2 }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t2}\`, consider using \`${e2}\`, in enum \`${a2}\`.`, EnumNumberMemberNotInitialized: ({ enumName: a2, memberName: t2 }) => `Number enum members need to be initialized, e.g. \`${t2} = 1\` in enum \`${a2}\`.`, EnumStringMemberInconsistentlyInitialized: ({ enumName: a2 }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${a2}\`.`, GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: Object.assign({ message: "A binding pattern parameter cannot be optional in an implementation signature." }, { reasonCode: "OptionalBindingPattern" }), SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: ({ reservedType: a2 }) => `Unexpected reserved type ${a2}.`, UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: ({ unsupportedExportKind: a2, suggestion: t2 }) => `\`declare export ${a2}\` is not supported. Use \`${t2}\` instead.`, UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." });
        function _i(a2) {
          return a2.type === "DeclareExportAllDeclaration" || a2.type === "DeclareExportDeclaration" && (!a2.declaration || a2.declaration.type !== "TypeAlias" && a2.declaration.type !== "InterfaceDeclaration");
        }
        function _t2(a2) {
          return a2.importKind === "type" || a2.importKind === "typeof";
        }
        var ji = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" };
        function $i(a2, t2) {
          let e2 = [], s2 = [];
          for (let i2 = 0; i2 < a2.length; i2++)
            (t2(a2[i2], i2, a2) ? e2 : s2).push(a2[i2]);
          return [e2, s2];
        }
        var Vi = /\*?\s*@((?:no)?flow)\b/, qi2 = (a2) => class extends a2 {
          constructor(...e2) {
            super(...e2), this.flowPragma = void 0;
          }
          getScopeHandler() {
            return Xe2;
          }
          shouldParseTypes() {
            return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
          }
          shouldParseEnums() {
            return !!this.getPluginOption("flow", "enums");
          }
          finishToken(e2, s2) {
            e2 !== 133 && e2 !== 13 && e2 !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(e2, s2);
          }
          addComment(e2) {
            if (this.flowPragma === void 0) {
              let s2 = Vi.exec(e2.value);
              if (s2)
                if (s2[1] === "flow")
                  this.flowPragma = "flow";
                else if (s2[1] === "noflow")
                  this.flowPragma = "noflow";
                else
                  throw new Error("Unexpected flow pragma");
            }
            super.addComment(e2);
          }
          flowParseTypeInitialiser(e2) {
            let s2 = this.state.inType;
            this.state.inType = true, this.expect(e2 || 14);
            let i2 = this.flowParseType();
            return this.state.inType = s2, i2;
          }
          flowParsePredicate() {
            let e2 = this.startNode(), s2 = this.state.startLoc;
            return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > s2.index + 1 && this.raise(g2.UnexpectedSpaceBetweenModuloChecks, s2), this.eat(10) ? (e2.value = super.parseExpression(), this.expect(11), this.finishNode(e2, "DeclaredPredicate")) : this.finishNode(e2, "InferredPredicate");
          }
          flowParseTypeAndPredicateInitialiser() {
            let e2 = this.state.inType;
            this.state.inType = true, this.expect(14);
            let s2 = null, i2 = null;
            return this.match(54) ? (this.state.inType = e2, i2 = this.flowParsePredicate()) : (s2 = this.flowParseType(), this.state.inType = e2, this.match(54) && (i2 = this.flowParsePredicate())), [s2, i2];
          }
          flowParseDeclareClass(e2) {
            return this.next(), this.flowParseInterfaceish(e2, true), this.finishNode(e2, "DeclareClass");
          }
          flowParseDeclareFunction(e2) {
            this.next();
            let s2 = e2.id = this.parseIdentifier(), i2 = this.startNode(), r2 = this.startNode();
            this.match(47) ? i2.typeParameters = this.flowParseTypeParameterDeclaration() : i2.typeParameters = null, this.expect(10);
            let n2 = this.flowParseFunctionTypeParams();
            return i2.params = n2.params, i2.rest = n2.rest, i2.this = n2._this, this.expect(11), [i2.returnType, e2.predicate] = this.flowParseTypeAndPredicateInitialiser(), r2.typeAnnotation = this.finishNode(i2, "FunctionTypeAnnotation"), s2.typeAnnotation = this.finishNode(r2, "TypeAnnotation"), this.resetEndLocation(s2), this.semicolon(), this.scope.declareName(e2.id.name, 2048, e2.id.loc.start), this.finishNode(e2, "DeclareFunction");
          }
          flowParseDeclare(e2, s2) {
            if (this.match(80))
              return this.flowParseDeclareClass(e2);
            if (this.match(68))
              return this.flowParseDeclareFunction(e2);
            if (this.match(74))
              return this.flowParseDeclareVariable(e2);
            if (this.eatContextual(127))
              return this.match(16) ? this.flowParseDeclareModuleExports(e2) : (s2 && this.raise(g2.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(e2));
            if (this.isContextual(130))
              return this.flowParseDeclareTypeAlias(e2);
            if (this.isContextual(131))
              return this.flowParseDeclareOpaqueType(e2);
            if (this.isContextual(129))
              return this.flowParseDeclareInterface(e2);
            if (this.match(82))
              return this.flowParseDeclareExportDeclaration(e2, s2);
            this.unexpected();
          }
          flowParseDeclareVariable(e2) {
            return this.next(), e2.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(e2.id.name, 5, e2.id.loc.start), this.semicolon(), this.finishNode(e2, "DeclareVariable");
          }
          flowParseDeclareModule(e2) {
            this.scope.enter(0), this.match(133) ? e2.id = super.parseExprAtom() : e2.id = this.parseIdentifier();
            let s2 = e2.body = this.startNode(), i2 = s2.body = [];
            for (this.expect(5); !this.match(8); ) {
              let o2 = this.startNode();
              this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(g2.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), super.parseImport(o2)) : (this.expectContextual(125, g2.UnsupportedStatementInDeclareModule), o2 = this.flowParseDeclare(o2, true)), i2.push(o2);
            }
            this.scope.exit(), this.expect(8), this.finishNode(s2, "BlockStatement");
            let r2 = null, n2 = false;
            return i2.forEach((o2) => {
              _i(o2) ? (r2 === "CommonJS" && this.raise(g2.AmbiguousDeclareModuleKind, o2), r2 = "ES") : o2.type === "DeclareModuleExports" && (n2 && this.raise(g2.DuplicateDeclareModuleExports, o2), r2 === "ES" && this.raise(g2.AmbiguousDeclareModuleKind, o2), r2 = "CommonJS", n2 = true);
            }), e2.kind = r2 || "CommonJS", this.finishNode(e2, "DeclareModule");
          }
          flowParseDeclareExportDeclaration(e2, s2) {
            if (this.expect(82), this.eat(65))
              return this.match(68) || this.match(80) ? e2.declaration = this.flowParseDeclare(this.startNode()) : (e2.declaration = this.flowParseType(), this.semicolon()), e2.default = true, this.finishNode(e2, "DeclareExportDeclaration");
            if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !s2) {
              let i2 = this.state.value;
              throw this.raise(g2.UnsupportedDeclareExportKind, this.state.startLoc, { unsupportedExportKind: i2, suggestion: ji[i2] });
            }
            if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
              return e2.declaration = this.flowParseDeclare(this.startNode()), e2.default = false, this.finishNode(e2, "DeclareExportDeclaration");
            if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
              return e2 = this.parseExport(e2, null), e2.type === "ExportNamedDeclaration" && (e2.type = "ExportDeclaration", e2.default = false, delete e2.exportKind), e2.type = "Declare" + e2.type, e2;
            this.unexpected();
          }
          flowParseDeclareModuleExports(e2) {
            return this.next(), this.expectContextual(111), e2.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(e2, "DeclareModuleExports");
          }
          flowParseDeclareTypeAlias(e2) {
            this.next();
            let s2 = this.flowParseTypeAlias(e2);
            return s2.type = "DeclareTypeAlias", s2;
          }
          flowParseDeclareOpaqueType(e2) {
            this.next();
            let s2 = this.flowParseOpaqueType(e2, true);
            return s2.type = "DeclareOpaqueType", s2;
          }
          flowParseDeclareInterface(e2) {
            return this.next(), this.flowParseInterfaceish(e2, false), this.finishNode(e2, "DeclareInterface");
          }
          flowParseInterfaceish(e2, s2) {
            if (e2.id = this.flowParseRestrictedIdentifier(!s2, true), this.scope.declareName(e2.id.name, s2 ? 17 : 8201, e2.id.loc.start), this.match(47) ? e2.typeParameters = this.flowParseTypeParameterDeclaration() : e2.typeParameters = null, e2.extends = [], this.eat(81))
              do
                e2.extends.push(this.flowParseInterfaceExtends());
              while (!s2 && this.eat(12));
            if (s2) {
              if (e2.implements = [], e2.mixins = [], this.eatContextual(117))
                do
                  e2.mixins.push(this.flowParseInterfaceExtends());
                while (this.eat(12));
              if (this.eatContextual(113))
                do
                  e2.implements.push(this.flowParseInterfaceExtends());
                while (this.eat(12));
            }
            e2.body = this.flowParseObjectType({ allowStatic: s2, allowExact: false, allowSpread: false, allowProto: s2, allowInexact: false });
          }
          flowParseInterfaceExtends() {
            let e2 = this.startNode();
            return e2.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? e2.typeParameters = this.flowParseTypeParameterInstantiation() : e2.typeParameters = null, this.finishNode(e2, "InterfaceExtends");
          }
          flowParseInterface(e2) {
            return this.flowParseInterfaceish(e2, false), this.finishNode(e2, "InterfaceDeclaration");
          }
          checkNotUnderscore(e2) {
            e2 === "_" && this.raise(g2.UnexpectedReservedUnderscore, this.state.startLoc);
          }
          checkReservedType(e2, s2, i2) {
            Ui.has(e2) && this.raise(i2 ? g2.AssignReservedType : g2.UnexpectedReservedType, s2, { reservedType: e2 });
          }
          flowParseRestrictedIdentifier(e2, s2) {
            return this.checkReservedType(this.state.value, this.state.startLoc, s2), this.parseIdentifier(e2);
          }
          flowParseTypeAlias(e2) {
            return e2.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(e2.id.name, 8201, e2.id.loc.start), this.match(47) ? e2.typeParameters = this.flowParseTypeParameterDeclaration() : e2.typeParameters = null, e2.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(e2, "TypeAlias");
          }
          flowParseOpaqueType(e2, s2) {
            return this.expectContextual(130), e2.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(e2.id.name, 8201, e2.id.loc.start), this.match(47) ? e2.typeParameters = this.flowParseTypeParameterDeclaration() : e2.typeParameters = null, e2.supertype = null, this.match(14) && (e2.supertype = this.flowParseTypeInitialiser(14)), e2.impltype = null, s2 || (e2.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e2, "OpaqueType");
          }
          flowParseTypeParameter(e2 = false) {
            let s2 = this.state.startLoc, i2 = this.startNode(), r2 = this.flowParseVariance(), n2 = this.flowParseTypeAnnotatableIdentifier();
            return i2.name = n2.name, i2.variance = r2, i2.bound = n2.typeAnnotation, this.match(29) ? (this.eat(29), i2.default = this.flowParseType()) : e2 && this.raise(g2.MissingTypeParamDefault, s2), this.finishNode(i2, "TypeParameter");
          }
          flowParseTypeParameterDeclaration() {
            let e2 = this.state.inType, s2 = this.startNode();
            s2.params = [], this.state.inType = true, this.match(47) || this.match(142) ? this.next() : this.unexpected();
            let i2 = false;
            do {
              let r2 = this.flowParseTypeParameter(i2);
              s2.params.push(r2), r2.default && (i2 = true), this.match(48) || this.expect(12);
            } while (!this.match(48));
            return this.expect(48), this.state.inType = e2, this.finishNode(s2, "TypeParameterDeclaration");
          }
          flowParseTypeParameterInstantiation() {
            let e2 = this.startNode(), s2 = this.state.inType;
            e2.params = [], this.state.inType = true, this.expect(47);
            let i2 = this.state.noAnonFunctionType;
            for (this.state.noAnonFunctionType = false; !this.match(48); )
              e2.params.push(this.flowParseType()), this.match(48) || this.expect(12);
            return this.state.noAnonFunctionType = i2, this.expect(48), this.state.inType = s2, this.finishNode(e2, "TypeParameterInstantiation");
          }
          flowParseTypeParameterInstantiationCallOrNew() {
            let e2 = this.startNode(), s2 = this.state.inType;
            for (e2.params = [], this.state.inType = true, this.expect(47); !this.match(48); )
              e2.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
            return this.expect(48), this.state.inType = s2, this.finishNode(e2, "TypeParameterInstantiation");
          }
          flowParseInterfaceType() {
            let e2 = this.startNode();
            if (this.expectContextual(129), e2.extends = [], this.eat(81))
              do
                e2.extends.push(this.flowParseInterfaceExtends());
              while (this.eat(12));
            return e2.body = this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: false, allowProto: false, allowInexact: false }), this.finishNode(e2, "InterfaceTypeAnnotation");
          }
          flowParseObjectPropertyKey() {
            return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(true);
          }
          flowParseObjectTypeIndexer(e2, s2, i2) {
            return e2.static = s2, this.lookahead().type === 14 ? (e2.id = this.flowParseObjectPropertyKey(), e2.key = this.flowParseTypeInitialiser()) : (e2.id = null, e2.key = this.flowParseType()), this.expect(3), e2.value = this.flowParseTypeInitialiser(), e2.variance = i2, this.finishNode(e2, "ObjectTypeIndexer");
          }
          flowParseObjectTypeInternalSlot(e2, s2) {
            return e2.static = s2, e2.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (e2.method = true, e2.optional = false, e2.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e2.loc.start))) : (e2.method = false, this.eat(17) && (e2.optional = true), e2.value = this.flowParseTypeInitialiser()), this.finishNode(e2, "ObjectTypeInternalSlot");
          }
          flowParseObjectTypeMethodish(e2) {
            for (e2.params = [], e2.rest = null, e2.typeParameters = null, e2.this = null, this.match(47) && (e2.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (e2.this = this.flowParseFunctionTypeParam(true), e2.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
              e2.params.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
            return this.eat(21) && (e2.rest = this.flowParseFunctionTypeParam(false)), this.expect(11), e2.returnType = this.flowParseTypeInitialiser(), this.finishNode(e2, "FunctionTypeAnnotation");
          }
          flowParseObjectTypeCallProperty(e2, s2) {
            let i2 = this.startNode();
            return e2.static = s2, e2.value = this.flowParseObjectTypeMethodish(i2), this.finishNode(e2, "ObjectTypeCallProperty");
          }
          flowParseObjectType({ allowStatic: e2, allowExact: s2, allowSpread: i2, allowProto: r2, allowInexact: n2 }) {
            let o2 = this.state.inType;
            this.state.inType = true;
            let h2 = this.startNode();
            h2.callProperties = [], h2.properties = [], h2.indexers = [], h2.internalSlots = [];
            let c2, l2, u2 = false;
            for (s2 && this.match(6) ? (this.expect(6), c2 = 9, l2 = true) : (this.expect(5), c2 = 8, l2 = false), h2.exact = l2; !this.match(c2); ) {
              let d2 = false, y3 = null, E2 = null, L3 = this.startNode();
              if (r2 && this.isContextual(118)) {
                let I2 = this.lookahead();
                I2.type !== 14 && I2.type !== 17 && (this.next(), y3 = this.state.startLoc, e2 = false);
              }
              if (e2 && this.isContextual(106)) {
                let I2 = this.lookahead();
                I2.type !== 14 && I2.type !== 17 && (this.next(), d2 = true);
              }
              let S3 = this.flowParseVariance();
              if (this.eat(0))
                y3 != null && this.unexpected(y3), this.eat(0) ? (S3 && this.unexpected(S3.loc.start), h2.internalSlots.push(this.flowParseObjectTypeInternalSlot(L3, d2))) : h2.indexers.push(this.flowParseObjectTypeIndexer(L3, d2, S3));
              else if (this.match(10) || this.match(47))
                y3 != null && this.unexpected(y3), S3 && this.unexpected(S3.loc.start), h2.callProperties.push(this.flowParseObjectTypeCallProperty(L3, d2));
              else {
                let I2 = "init";
                if (this.isContextual(99) || this.isContextual(104)) {
                  let ne3 = this.lookahead();
                  Wt2(ne3.type) && (I2 = this.state.value, this.next());
                }
                let Ae3 = this.flowParseObjectTypeProperty(L3, d2, y3, S3, I2, i2, n2 ?? !l2);
                Ae3 === null ? (u2 = true, E2 = this.state.lastTokStartLoc) : h2.properties.push(Ae3);
              }
              this.flowObjectTypeSemicolon(), E2 && !this.match(8) && !this.match(9) && this.raise(g2.UnexpectedExplicitInexactInObject, E2);
            }
            this.expect(c2), i2 && (h2.inexact = u2);
            let f2 = this.finishNode(h2, "ObjectTypeAnnotation");
            return this.state.inType = o2, f2;
          }
          flowParseObjectTypeProperty(e2, s2, i2, r2, n2, o2, h2) {
            if (this.eat(21))
              return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (o2 ? h2 || this.raise(g2.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(g2.InexactInsideNonObject, this.state.lastTokStartLoc), r2 && this.raise(g2.InexactVariance, r2), null) : (o2 || this.raise(g2.UnexpectedSpreadType, this.state.lastTokStartLoc), i2 != null && this.unexpected(i2), r2 && this.raise(g2.SpreadVariance, r2), e2.argument = this.flowParseType(), this.finishNode(e2, "ObjectTypeSpreadProperty"));
            {
              e2.key = this.flowParseObjectPropertyKey(), e2.static = s2, e2.proto = i2 != null, e2.kind = n2;
              let c2 = false;
              return this.match(47) || this.match(10) ? (e2.method = true, i2 != null && this.unexpected(i2), r2 && this.unexpected(r2.loc.start), e2.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e2.loc.start)), (n2 === "get" || n2 === "set") && this.flowCheckGetterSetterParams(e2), !o2 && e2.key.name === "constructor" && e2.value.this && this.raise(g2.ThisParamBannedInConstructor, e2.value.this)) : (n2 !== "init" && this.unexpected(), e2.method = false, this.eat(17) && (c2 = true), e2.value = this.flowParseTypeInitialiser(), e2.variance = r2), e2.optional = c2, this.finishNode(e2, "ObjectTypeProperty");
            }
          }
          flowCheckGetterSetterParams(e2) {
            let s2 = e2.kind === "get" ? 0 : 1, i2 = e2.value.params.length + (e2.value.rest ? 1 : 0);
            e2.value.this && this.raise(e2.kind === "get" ? g2.GetterMayNotHaveThisParam : g2.SetterMayNotHaveThisParam, e2.value.this), i2 !== s2 && this.raise(e2.kind === "get" ? p2.BadGetterArity : p2.BadSetterArity, e2), e2.kind === "set" && e2.value.rest && this.raise(p2.BadSetterRestParameter, e2);
          }
          flowObjectTypeSemicolon() {
            !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
          }
          flowParseQualifiedTypeIdentifier(e2, s2) {
            var i2;
            (i2 = e2) != null || (e2 = this.state.startLoc);
            let r2 = s2 || this.flowParseRestrictedIdentifier(true);
            for (; this.eat(16); ) {
              let n2 = this.startNodeAt(e2);
              n2.qualification = r2, n2.id = this.flowParseRestrictedIdentifier(true), r2 = this.finishNode(n2, "QualifiedTypeIdentifier");
            }
            return r2;
          }
          flowParseGenericType(e2, s2) {
            let i2 = this.startNodeAt(e2);
            return i2.typeParameters = null, i2.id = this.flowParseQualifiedTypeIdentifier(e2, s2), this.match(47) && (i2.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(i2, "GenericTypeAnnotation");
          }
          flowParseTypeofType() {
            let e2 = this.startNode();
            return this.expect(87), e2.argument = this.flowParsePrimaryType(), this.finishNode(e2, "TypeofTypeAnnotation");
          }
          flowParseTupleType() {
            let e2 = this.startNode();
            for (e2.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (e2.types.push(this.flowParseType()), !this.match(3)); )
              this.expect(12);
            return this.expect(3), this.finishNode(e2, "TupleTypeAnnotation");
          }
          flowParseFunctionTypeParam(e2) {
            let s2 = null, i2 = false, r2 = null, n2 = this.startNode(), o2 = this.lookahead(), h2 = this.state.type === 78;
            return o2.type === 14 || o2.type === 17 ? (h2 && !e2 && this.raise(g2.ThisParamMustBeFirst, n2), s2 = this.parseIdentifier(h2), this.eat(17) && (i2 = true, h2 && this.raise(g2.ThisParamMayNotBeOptional, n2)), r2 = this.flowParseTypeInitialiser()) : r2 = this.flowParseType(), n2.name = s2, n2.optional = i2, n2.typeAnnotation = r2, this.finishNode(n2, "FunctionTypeParam");
          }
          reinterpretTypeAsFunctionTypeParam(e2) {
            let s2 = this.startNodeAt(e2.loc.start);
            return s2.name = null, s2.optional = false, s2.typeAnnotation = e2, this.finishNode(s2, "FunctionTypeParam");
          }
          flowParseFunctionTypeParams(e2 = []) {
            let s2 = null, i2 = null;
            for (this.match(78) && (i2 = this.flowParseFunctionTypeParam(true), i2.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
              e2.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
            return this.eat(21) && (s2 = this.flowParseFunctionTypeParam(false)), { params: e2, rest: s2, _this: i2 };
          }
          flowIdentToTypeAnnotation(e2, s2, i2) {
            switch (i2.name) {
              case "any":
                return this.finishNode(s2, "AnyTypeAnnotation");
              case "bool":
              case "boolean":
                return this.finishNode(s2, "BooleanTypeAnnotation");
              case "mixed":
                return this.finishNode(s2, "MixedTypeAnnotation");
              case "empty":
                return this.finishNode(s2, "EmptyTypeAnnotation");
              case "number":
                return this.finishNode(s2, "NumberTypeAnnotation");
              case "string":
                return this.finishNode(s2, "StringTypeAnnotation");
              case "symbol":
                return this.finishNode(s2, "SymbolTypeAnnotation");
              default:
                return this.checkNotUnderscore(i2.name), this.flowParseGenericType(e2, i2);
            }
          }
          flowParsePrimaryType() {
            let e2 = this.state.startLoc, s2 = this.startNode(), i2, r2, n2 = false, o2 = this.state.noAnonFunctionType;
            switch (this.state.type) {
              case 5:
                return this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: true, allowProto: false, allowInexact: true });
              case 6:
                return this.flowParseObjectType({ allowStatic: false, allowExact: true, allowSpread: true, allowProto: false, allowInexact: false });
              case 0:
                return this.state.noAnonFunctionType = false, r2 = this.flowParseTupleType(), this.state.noAnonFunctionType = o2, r2;
              case 47: {
                let h2 = this.startNode();
                return h2.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), i2 = this.flowParseFunctionTypeParams(), h2.params = i2.params, h2.rest = i2.rest, h2.this = i2._this, this.expect(11), this.expect(19), h2.returnType = this.flowParseType(), this.finishNode(h2, "FunctionTypeAnnotation");
              }
              case 10: {
                let h2 = this.startNode();
                if (this.next(), !this.match(11) && !this.match(21))
                  if (w2(this.state.type) || this.match(78)) {
                    let c2 = this.lookahead().type;
                    n2 = c2 !== 17 && c2 !== 14;
                  } else
                    n2 = true;
                if (n2) {
                  if (this.state.noAnonFunctionType = false, r2 = this.flowParseType(), this.state.noAnonFunctionType = o2, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19))
                    return this.expect(11), r2;
                  this.eat(12);
                }
                return r2 ? i2 = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(r2)]) : i2 = this.flowParseFunctionTypeParams(), h2.params = i2.params, h2.rest = i2.rest, h2.this = i2._this, this.expect(11), this.expect(19), h2.returnType = this.flowParseType(), h2.typeParameters = null, this.finishNode(h2, "FunctionTypeAnnotation");
              }
              case 133:
                return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
              case 85:
              case 86:
                return s2.value = this.match(85), this.next(), this.finishNode(s2, "BooleanLiteralTypeAnnotation");
              case 53:
                if (this.state.value === "-") {
                  if (this.next(), this.match(134))
                    return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", s2);
                  if (this.match(135))
                    return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", s2);
                  throw this.raise(g2.UnexpectedSubtractionOperand, this.state.startLoc);
                }
                this.unexpected();
                return;
              case 134:
                return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
              case 135:
                return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
              case 88:
                return this.next(), this.finishNode(s2, "VoidTypeAnnotation");
              case 84:
                return this.next(), this.finishNode(s2, "NullLiteralTypeAnnotation");
              case 78:
                return this.next(), this.finishNode(s2, "ThisTypeAnnotation");
              case 55:
                return this.next(), this.finishNode(s2, "ExistsTypeAnnotation");
              case 87:
                return this.flowParseTypeofType();
              default:
                if (Pt2(this.state.type)) {
                  let h2 = K2(this.state.type);
                  return this.next(), super.createIdentifier(s2, h2);
                } else if (w2(this.state.type))
                  return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(e2, s2, this.parseIdentifier());
            }
            this.unexpected();
          }
          flowParsePostfixType() {
            let e2 = this.state.startLoc, s2 = this.flowParsePrimaryType(), i2 = false;
            for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
              let r2 = this.startNodeAt(e2), n2 = this.eat(18);
              i2 = i2 || n2, this.expect(0), !n2 && this.match(3) ? (r2.elementType = s2, this.next(), s2 = this.finishNode(r2, "ArrayTypeAnnotation")) : (r2.objectType = s2, r2.indexType = this.flowParseType(), this.expect(3), i2 ? (r2.optional = n2, s2 = this.finishNode(r2, "OptionalIndexedAccessType")) : s2 = this.finishNode(r2, "IndexedAccessType"));
            }
            return s2;
          }
          flowParsePrefixType() {
            let e2 = this.startNode();
            return this.eat(17) ? (e2.typeAnnotation = this.flowParsePrefixType(), this.finishNode(e2, "NullableTypeAnnotation")) : this.flowParsePostfixType();
          }
          flowParseAnonFunctionWithoutParens() {
            let e2 = this.flowParsePrefixType();
            if (!this.state.noAnonFunctionType && this.eat(19)) {
              let s2 = this.startNodeAt(e2.loc.start);
              return s2.params = [this.reinterpretTypeAsFunctionTypeParam(e2)], s2.rest = null, s2.this = null, s2.returnType = this.flowParseType(), s2.typeParameters = null, this.finishNode(s2, "FunctionTypeAnnotation");
            }
            return e2;
          }
          flowParseIntersectionType() {
            let e2 = this.startNode();
            this.eat(45);
            let s2 = this.flowParseAnonFunctionWithoutParens();
            for (e2.types = [s2]; this.eat(45); )
              e2.types.push(this.flowParseAnonFunctionWithoutParens());
            return e2.types.length === 1 ? s2 : this.finishNode(e2, "IntersectionTypeAnnotation");
          }
          flowParseUnionType() {
            let e2 = this.startNode();
            this.eat(43);
            let s2 = this.flowParseIntersectionType();
            for (e2.types = [s2]; this.eat(43); )
              e2.types.push(this.flowParseIntersectionType());
            return e2.types.length === 1 ? s2 : this.finishNode(e2, "UnionTypeAnnotation");
          }
          flowParseType() {
            let e2 = this.state.inType;
            this.state.inType = true;
            let s2 = this.flowParseUnionType();
            return this.state.inType = e2, s2;
          }
          flowParseTypeOrImplicitInstantiation() {
            if (this.state.type === 132 && this.state.value === "_") {
              let e2 = this.state.startLoc, s2 = this.parseIdentifier();
              return this.flowParseGenericType(e2, s2);
            } else
              return this.flowParseType();
          }
          flowParseTypeAnnotation() {
            let e2 = this.startNode();
            return e2.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(e2, "TypeAnnotation");
          }
          flowParseTypeAnnotatableIdentifier(e2) {
            let s2 = e2 ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
            return this.match(14) && (s2.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(s2)), s2;
          }
          typeCastToParameter(e2) {
            return e2.expression.typeAnnotation = e2.typeAnnotation, this.resetEndLocation(e2.expression, e2.typeAnnotation.loc.end), e2.expression;
          }
          flowParseVariance() {
            let e2 = null;
            return this.match(53) ? (e2 = this.startNode(), this.state.value === "+" ? e2.kind = "plus" : e2.kind = "minus", this.next(), this.finishNode(e2, "Variance")) : e2;
          }
          parseFunctionBody(e2, s2, i2 = false) {
            if (s2) {
              this.forwardNoArrowParamsConversionAt(e2, () => super.parseFunctionBody(e2, true, i2));
              return;
            }
            super.parseFunctionBody(e2, false, i2);
          }
          parseFunctionBodyAndFinish(e2, s2, i2 = false) {
            if (this.match(14)) {
              let r2 = this.startNode();
              [r2.typeAnnotation, e2.predicate] = this.flowParseTypeAndPredicateInitialiser(), e2.returnType = r2.typeAnnotation ? this.finishNode(r2, "TypeAnnotation") : null;
            }
            return super.parseFunctionBodyAndFinish(e2, s2, i2);
          }
          parseStatementLike(e2) {
            if (this.state.strict && this.isContextual(129)) {
              let i2 = this.lookahead();
              if (M3(i2.type)) {
                let r2 = this.startNode();
                return this.next(), this.flowParseInterface(r2);
              }
            } else if (this.shouldParseEnums() && this.isContextual(126)) {
              let i2 = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(i2);
            }
            let s2 = super.parseStatementLike(e2);
            return this.flowPragma === void 0 && !this.isValidDirective(s2) && (this.flowPragma = null), s2;
          }
          parseExpressionStatement(e2, s2, i2) {
            if (s2.type === "Identifier") {
              if (s2.name === "declare") {
                if (this.match(80) || w2(this.state.type) || this.match(68) || this.match(74) || this.match(82))
                  return this.flowParseDeclare(e2);
              } else if (w2(this.state.type)) {
                if (s2.name === "interface")
                  return this.flowParseInterface(e2);
                if (s2.name === "type")
                  return this.flowParseTypeAlias(e2);
                if (s2.name === "opaque")
                  return this.flowParseOpaqueType(e2, false);
              }
            }
            return super.parseExpressionStatement(e2, s2, i2);
          }
          shouldParseExportDeclaration() {
            let { type: e2 } = this.state;
            return Ft3(e2) || this.shouldParseEnums() && e2 === 126 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
          }
          isExportDefaultSpecifier() {
            let { type: e2 } = this.state;
            return Ft3(e2) || this.shouldParseEnums() && e2 === 126 ? this.state.containsEsc : super.isExportDefaultSpecifier();
          }
          parseExportDefaultExpression() {
            if (this.shouldParseEnums() && this.isContextual(126)) {
              let e2 = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(e2);
            }
            return super.parseExportDefaultExpression();
          }
          parseConditional(e2, s2, i2) {
            if (!this.match(17))
              return e2;
            if (this.state.maybeInArrowParameters) {
              let f2 = this.lookaheadCharCode();
              if (f2 === 44 || f2 === 61 || f2 === 58 || f2 === 41)
                return this.setOptionalParametersError(i2), e2;
            }
            this.expect(17);
            let r2 = this.state.clone(), n2 = this.state.noArrowAt, o2 = this.startNodeAt(s2), { consequent: h2, failed: c2 } = this.tryParseConditionalConsequent(), [l2, u2] = this.getArrowLikeExpressions(h2);
            if (c2 || u2.length > 0) {
              let f2 = [...n2];
              if (u2.length > 0) {
                this.state = r2, this.state.noArrowAt = f2;
                for (let d2 = 0; d2 < u2.length; d2++)
                  f2.push(u2[d2].start);
                ({ consequent: h2, failed: c2 } = this.tryParseConditionalConsequent()), [l2, u2] = this.getArrowLikeExpressions(h2);
              }
              c2 && l2.length > 1 && this.raise(g2.AmbiguousConditionalArrow, r2.startLoc), c2 && l2.length === 1 && (this.state = r2, f2.push(l2[0].start), this.state.noArrowAt = f2, { consequent: h2, failed: c2 } = this.tryParseConditionalConsequent());
            }
            return this.getArrowLikeExpressions(h2, true), this.state.noArrowAt = n2, this.expect(14), o2.test = e2, o2.consequent = h2, o2.alternate = this.forwardNoArrowParamsConversionAt(o2, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(o2, "ConditionalExpression");
          }
          tryParseConditionalConsequent() {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            let e2 = this.parseMaybeAssignAllowIn(), s2 = !this.match(14);
            return this.state.noArrowParamsConversionAt.pop(), { consequent: e2, failed: s2 };
          }
          getArrowLikeExpressions(e2, s2) {
            let i2 = [e2], r2 = [];
            for (; i2.length !== 0; ) {
              let n2 = i2.pop();
              n2.type === "ArrowFunctionExpression" && n2.body.type !== "BlockStatement" ? (n2.typeParameters || !n2.returnType ? this.finishArrowValidation(n2) : r2.push(n2), i2.push(n2.body)) : n2.type === "ConditionalExpression" && (i2.push(n2.consequent), i2.push(n2.alternate));
            }
            return s2 ? (r2.forEach((n2) => this.finishArrowValidation(n2)), [r2, []]) : $i(r2, (n2) => n2.params.every((o2) => this.isAssignable(o2, true)));
          }
          finishArrowValidation(e2) {
            var s2;
            this.toAssignableList(e2.params, (s2 = e2.extra) == null ? void 0 : s2.trailingCommaLoc, false), this.scope.enter(6), super.checkParams(e2, false, true), this.scope.exit();
          }
          forwardNoArrowParamsConversionAt(e2, s2) {
            let i2;
            return this.state.noArrowParamsConversionAt.includes(e2.start) ? (this.state.noArrowParamsConversionAt.push(this.state.start), i2 = s2(), this.state.noArrowParamsConversionAt.pop()) : i2 = s2(), i2;
          }
          parseParenItem(e2, s2) {
            let i2 = super.parseParenItem(e2, s2);
            if (this.eat(17) && (i2.optional = true, this.resetEndLocation(e2)), this.match(14)) {
              let r2 = this.startNodeAt(s2);
              return r2.expression = i2, r2.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(r2, "TypeCastExpression");
            }
            return i2;
          }
          assertModuleNodeAllowed(e2) {
            e2.type === "ImportDeclaration" && (e2.importKind === "type" || e2.importKind === "typeof") || e2.type === "ExportNamedDeclaration" && e2.exportKind === "type" || e2.type === "ExportAllDeclaration" && e2.exportKind === "type" || super.assertModuleNodeAllowed(e2);
          }
          parseExportDeclaration(e2) {
            if (this.isContextual(130)) {
              e2.exportKind = "type";
              let s2 = this.startNode();
              return this.next(), this.match(5) ? (e2.specifiers = this.parseExportSpecifiers(true), super.parseExportFrom(e2), null) : this.flowParseTypeAlias(s2);
            } else if (this.isContextual(131)) {
              e2.exportKind = "type";
              let s2 = this.startNode();
              return this.next(), this.flowParseOpaqueType(s2, false);
            } else if (this.isContextual(129)) {
              e2.exportKind = "type";
              let s2 = this.startNode();
              return this.next(), this.flowParseInterface(s2);
            } else if (this.shouldParseEnums() && this.isContextual(126)) {
              e2.exportKind = "value";
              let s2 = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(s2);
            } else
              return super.parseExportDeclaration(e2);
          }
          eatExportStar(e2) {
            return super.eatExportStar(e2) ? true : this.isContextual(130) && this.lookahead().type === 55 ? (e2.exportKind = "type", this.next(), this.next(), true) : false;
          }
          maybeParseExportNamespaceSpecifier(e2) {
            let { startLoc: s2 } = this.state, i2 = super.maybeParseExportNamespaceSpecifier(e2);
            return i2 && e2.exportKind === "type" && this.unexpected(s2), i2;
          }
          parseClassId(e2, s2, i2) {
            super.parseClassId(e2, s2, i2), this.match(47) && (e2.typeParameters = this.flowParseTypeParameterDeclaration());
          }
          parseClassMember(e2, s2, i2) {
            let { startLoc: r2 } = this.state;
            if (this.isContextual(125)) {
              if (super.parseClassMemberFromModifier(e2, s2))
                return;
              s2.declare = true;
            }
            super.parseClassMember(e2, s2, i2), s2.declare && (s2.type !== "ClassProperty" && s2.type !== "ClassPrivateProperty" && s2.type !== "PropertyDefinition" ? this.raise(g2.DeclareClassElement, r2) : s2.value && this.raise(g2.DeclareClassFieldInitializer, s2.value));
          }
          isIterator(e2) {
            return e2 === "iterator" || e2 === "asyncIterator";
          }
          readIterator() {
            let e2 = super.readWord1(), s2 = "@@" + e2;
            (!this.isIterator(e2) || !this.state.inType) && this.raise(p2.InvalidIdentifier, this.state.curPosition(), { identifierName: s2 }), this.finishToken(132, s2);
          }
          getTokenFromCode(e2) {
            let s2 = this.input.charCodeAt(this.state.pos + 1);
            e2 === 123 && s2 === 124 ? this.finishOp(6, 2) : this.state.inType && (e2 === 62 || e2 === 60) ? this.finishOp(e2 === 62 ? 48 : 47, 1) : this.state.inType && e2 === 63 ? s2 === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : wi(e2, s2, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(e2);
          }
          isAssignable(e2, s2) {
            return e2.type === "TypeCastExpression" ? this.isAssignable(e2.expression, s2) : super.isAssignable(e2, s2);
          }
          toAssignable(e2, s2 = false) {
            !s2 && e2.type === "AssignmentExpression" && e2.left.type === "TypeCastExpression" && (e2.left = this.typeCastToParameter(e2.left)), super.toAssignable(e2, s2);
          }
          toAssignableList(e2, s2, i2) {
            for (let r2 = 0; r2 < e2.length; r2++) {
              let n2 = e2[r2];
              (n2 == null ? void 0 : n2.type) === "TypeCastExpression" && (e2[r2] = this.typeCastToParameter(n2));
            }
            super.toAssignableList(e2, s2, i2);
          }
          toReferencedList(e2, s2) {
            for (let r2 = 0; r2 < e2.length; r2++) {
              var i2;
              let n2 = e2[r2];
              n2 && n2.type === "TypeCastExpression" && !((i2 = n2.extra) != null && i2.parenthesized) && (e2.length > 1 || !s2) && this.raise(g2.TypeCastInPattern, n2.typeAnnotation);
            }
            return e2;
          }
          parseArrayLike(e2, s2, i2, r2) {
            let n2 = super.parseArrayLike(e2, s2, i2, r2);
            return s2 && !this.state.maybeInArrowParameters && this.toReferencedList(n2.elements), n2;
          }
          isValidLVal(e2, s2, i2) {
            return e2 === "TypeCastExpression" || super.isValidLVal(e2, s2, i2);
          }
          parseClassProperty(e2) {
            return this.match(14) && (e2.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e2);
          }
          parseClassPrivateProperty(e2) {
            return this.match(14) && (e2.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e2);
          }
          isClassMethod() {
            return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(14) || super.isClassProperty();
          }
          isNonstaticConstructor(e2) {
            return !this.match(14) && super.isNonstaticConstructor(e2);
          }
          pushClassMethod(e2, s2, i2, r2, n2, o2) {
            if (s2.variance && this.unexpected(s2.variance.loc.start), delete s2.variance, this.match(47) && (s2.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e2, s2, i2, r2, n2, o2), s2.params && n2) {
              let h2 = s2.params;
              h2.length > 0 && this.isThisParam(h2[0]) && this.raise(g2.ThisParamBannedInConstructor, s2);
            } else if (s2.type === "MethodDefinition" && n2 && s2.value.params) {
              let h2 = s2.value.params;
              h2.length > 0 && this.isThisParam(h2[0]) && this.raise(g2.ThisParamBannedInConstructor, s2);
            }
          }
          pushClassPrivateMethod(e2, s2, i2, r2) {
            s2.variance && this.unexpected(s2.variance.loc.start), delete s2.variance, this.match(47) && (s2.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e2, s2, i2, r2);
          }
          parseClassSuper(e2) {
            if (super.parseClassSuper(e2), e2.superClass && this.match(47) && (e2.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(113)) {
              this.next();
              let s2 = e2.implements = [];
              do {
                let i2 = this.startNode();
                i2.id = this.flowParseRestrictedIdentifier(true), this.match(47) ? i2.typeParameters = this.flowParseTypeParameterInstantiation() : i2.typeParameters = null, s2.push(this.finishNode(i2, "ClassImplements"));
              } while (this.eat(12));
            }
          }
          checkGetterSetterParams(e2) {
            super.checkGetterSetterParams(e2);
            let s2 = this.getObjectOrClassMethodParams(e2);
            if (s2.length > 0) {
              let i2 = s2[0];
              this.isThisParam(i2) && e2.kind === "get" ? this.raise(g2.GetterMayNotHaveThisParam, i2) : this.isThisParam(i2) && this.raise(g2.SetterMayNotHaveThisParam, i2);
            }
          }
          parsePropertyNamePrefixOperator(e2) {
            e2.variance = this.flowParseVariance();
          }
          parseObjPropValue(e2, s2, i2, r2, n2, o2, h2) {
            e2.variance && this.unexpected(e2.variance.loc.start), delete e2.variance;
            let c2;
            this.match(47) && !o2 && (c2 = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
            let l2 = super.parseObjPropValue(e2, s2, i2, r2, n2, o2, h2);
            return c2 && ((l2.value || l2).typeParameters = c2), l2;
          }
          parseAssignableListItemTypes(e2) {
            return this.eat(17) && (e2.type !== "Identifier" && this.raise(g2.PatternIsOptional, e2), this.isThisParam(e2) && this.raise(g2.ThisParamMayNotBeOptional, e2), e2.optional = true), this.match(14) ? e2.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(e2) && this.raise(g2.ThisParamAnnotationRequired, e2), this.match(29) && this.isThisParam(e2) && this.raise(g2.ThisParamNoDefault, e2), this.resetEndLocation(e2), e2;
          }
          parseMaybeDefault(e2, s2) {
            let i2 = super.parseMaybeDefault(e2, s2);
            return i2.type === "AssignmentPattern" && i2.typeAnnotation && i2.right.start < i2.typeAnnotation.start && this.raise(g2.TypeBeforeInitializer, i2.typeAnnotation), i2;
          }
          checkImportReflection(e2) {
            super.checkImportReflection(e2), e2.module && e2.importKind !== "value" && this.raise(g2.ImportReflectionHasImportType, e2.specifiers[0].loc.start);
          }
          parseImportSpecifierLocal(e2, s2, i2) {
            s2.local = _t2(e2) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), e2.specifiers.push(this.finishImportSpecifier(s2, i2));
          }
          isPotentialImportPhase(e2) {
            if (super.isPotentialImportPhase(e2))
              return true;
            if (this.isContextual(130)) {
              if (!e2)
                return true;
              let s2 = this.lookaheadCharCode();
              return s2 === 123 || s2 === 42;
            }
            return !e2 && this.isContextual(87);
          }
          applyImportPhase(e2, s2, i2, r2) {
            if (super.applyImportPhase(e2, s2, i2, r2), s2) {
              if (!i2 && this.match(65))
                return;
              e2.exportKind = i2 === "type" ? i2 : "value";
            } else
              i2 === "type" && this.match(55) && this.unexpected(), e2.importKind = i2 === "type" || i2 === "typeof" ? i2 : "value";
          }
          parseImportSpecifier(e2, s2, i2, r2, n2) {
            let o2 = e2.imported, h2 = null;
            o2.type === "Identifier" && (o2.name === "type" ? h2 = "type" : o2.name === "typeof" && (h2 = "typeof"));
            let c2 = false;
            if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
              let u2 = this.parseIdentifier(true);
              h2 !== null && !M3(this.state.type) ? (e2.imported = u2, e2.importKind = h2, e2.local = $2(u2)) : (e2.imported = o2, e2.importKind = null, e2.local = this.parseIdentifier());
            } else {
              if (h2 !== null && M3(this.state.type))
                e2.imported = this.parseIdentifier(true), e2.importKind = h2;
              else {
                if (s2)
                  throw this.raise(p2.ImportBindingIsString, e2, { importName: o2.value });
                e2.imported = o2, e2.importKind = null;
              }
              this.eatContextual(93) ? e2.local = this.parseIdentifier() : (c2 = true, e2.local = $2(e2.imported));
            }
            let l2 = _t2(e2);
            return i2 && l2 && this.raise(g2.ImportTypeShorthandOnlyInPureImport, e2), (i2 || l2) && this.checkReservedType(e2.local.name, e2.local.loc.start, true), c2 && !i2 && !l2 && this.checkReservedWord(e2.local.name, e2.loc.start, true, true), this.finishImportSpecifier(e2, "ImportSpecifier");
          }
          parseBindingAtom() {
            switch (this.state.type) {
              case 78:
                return this.parseIdentifier(true);
              default:
                return super.parseBindingAtom();
            }
          }
          parseFunctionParams(e2, s2) {
            let i2 = e2.kind;
            i2 !== "get" && i2 !== "set" && this.match(47) && (e2.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e2, s2);
          }
          parseVarId(e2, s2) {
            super.parseVarId(e2, s2), this.match(14) && (e2.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e2.id));
          }
          parseAsyncArrowFromCallExpression(e2, s2) {
            if (this.match(14)) {
              let i2 = this.state.noAnonFunctionType;
              this.state.noAnonFunctionType = true, e2.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = i2;
            }
            return super.parseAsyncArrowFromCallExpression(e2, s2);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          parseMaybeAssign(e2, s2) {
            var i2;
            let r2 = null, n2;
            if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
              if (r2 = this.state.clone(), n2 = this.tryParse(() => super.parseMaybeAssign(e2, s2), r2), !n2.error)
                return n2.node;
              let { context: c2 } = this.state, l2 = c2[c2.length - 1];
              (l2 === C.j_oTag || l2 === C.j_expr) && c2.pop();
            }
            if ((i2 = n2) != null && i2.error || this.match(47)) {
              var o2, h2;
              r2 = r2 || this.state.clone();
              let c2, l2 = this.tryParse((f2) => {
                var d2;
                c2 = this.flowParseTypeParameterDeclaration();
                let y3 = this.forwardNoArrowParamsConversionAt(c2, () => {
                  let L3 = super.parseMaybeAssign(e2, s2);
                  return this.resetStartLocationFromNode(L3, c2), L3;
                });
                (d2 = y3.extra) != null && d2.parenthesized && f2();
                let E2 = this.maybeUnwrapTypeCastExpression(y3);
                return E2.type !== "ArrowFunctionExpression" && f2(), E2.typeParameters = c2, this.resetStartLocationFromNode(E2, c2), y3;
              }, r2), u2 = null;
              if (l2.node && this.maybeUnwrapTypeCastExpression(l2.node).type === "ArrowFunctionExpression") {
                if (!l2.error && !l2.aborted)
                  return l2.node.async && this.raise(g2.UnexpectedTypeParameterBeforeAsyncArrowFunction, c2), l2.node;
                u2 = l2.node;
              }
              if ((o2 = n2) != null && o2.node)
                return this.state = n2.failState, n2.node;
              if (u2)
                return this.state = l2.failState, u2;
              throw (h2 = n2) != null && h2.thrown ? n2.error : l2.thrown ? l2.error : this.raise(g2.UnexpectedTokenAfterTypeParameter, c2);
            }
            return super.parseMaybeAssign(e2, s2);
          }
          parseArrow(e2) {
            if (this.match(14)) {
              let s2 = this.tryParse(() => {
                let i2 = this.state.noAnonFunctionType;
                this.state.noAnonFunctionType = true;
                let r2 = this.startNode();
                return [r2.typeAnnotation, e2.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = i2, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), r2;
              });
              if (s2.thrown)
                return null;
              s2.error && (this.state = s2.failState), e2.returnType = s2.node.typeAnnotation ? this.finishNode(s2.node, "TypeAnnotation") : null;
            }
            return super.parseArrow(e2);
          }
          shouldParseArrow(e2) {
            return this.match(14) || super.shouldParseArrow(e2);
          }
          setArrowFunctionParameters(e2, s2) {
            this.state.noArrowParamsConversionAt.includes(e2.start) ? e2.params = s2 : super.setArrowFunctionParameters(e2, s2);
          }
          checkParams(e2, s2, i2, r2 = true) {
            if (!(i2 && this.state.noArrowParamsConversionAt.includes(e2.start))) {
              for (let n2 = 0; n2 < e2.params.length; n2++)
                this.isThisParam(e2.params[n2]) && n2 > 0 && this.raise(g2.ThisParamMustBeFirst, e2.params[n2]);
              super.checkParams(e2, s2, i2, r2);
            }
          }
          parseParenAndDistinguishExpression(e2) {
            return super.parseParenAndDistinguishExpression(e2 && !this.state.noArrowAt.includes(this.state.start));
          }
          parseSubscripts(e2, s2, i2) {
            if (e2.type === "Identifier" && e2.name === "async" && this.state.noArrowAt.includes(s2.index)) {
              this.next();
              let r2 = this.startNodeAt(s2);
              r2.callee = e2, r2.arguments = super.parseCallExpressionArguments(11, false), e2 = this.finishNode(r2, "CallExpression");
            } else if (e2.type === "Identifier" && e2.name === "async" && this.match(47)) {
              let r2 = this.state.clone(), n2 = this.tryParse((h2) => this.parseAsyncArrowWithTypeParameters(s2) || h2(), r2);
              if (!n2.error && !n2.aborted)
                return n2.node;
              let o2 = this.tryParse(() => super.parseSubscripts(e2, s2, i2), r2);
              if (o2.node && !o2.error)
                return o2.node;
              if (n2.node)
                return this.state = n2.failState, n2.node;
              if (o2.node)
                return this.state = o2.failState, o2.node;
              throw n2.error || o2.error;
            }
            return super.parseSubscripts(e2, s2, i2);
          }
          parseSubscript(e2, s2, i2, r2) {
            if (this.match(18) && this.isLookaheadToken_lt()) {
              if (r2.optionalChainMember = true, i2)
                return r2.stop = true, e2;
              this.next();
              let n2 = this.startNodeAt(s2);
              return n2.callee = e2, n2.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), n2.arguments = this.parseCallExpressionArguments(11, false), n2.optional = true, this.finishCallExpression(n2, true);
            } else if (!i2 && this.shouldParseTypes() && this.match(47)) {
              let n2 = this.startNodeAt(s2);
              n2.callee = e2;
              let o2 = this.tryParse(() => (n2.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), n2.arguments = super.parseCallExpressionArguments(11, false), r2.optionalChainMember && (n2.optional = false), this.finishCallExpression(n2, r2.optionalChainMember)));
              if (o2.node)
                return o2.error && (this.state = o2.failState), o2.node;
            }
            return super.parseSubscript(e2, s2, i2, r2);
          }
          parseNewCallee(e2) {
            super.parseNewCallee(e2);
            let s2 = null;
            this.shouldParseTypes() && this.match(47) && (s2 = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), e2.typeArguments = s2;
          }
          parseAsyncArrowWithTypeParameters(e2) {
            let s2 = this.startNodeAt(e2);
            if (this.parseFunctionParams(s2, false), !!this.parseArrow(s2))
              return super.parseArrowExpression(s2, void 0, true);
          }
          readToken_mult_modulo(e2) {
            let s2 = this.input.charCodeAt(this.state.pos + 1);
            if (e2 === 42 && s2 === 47 && this.state.hasFlowComment) {
              this.state.hasFlowComment = false, this.state.pos += 2, this.nextToken();
              return;
            }
            super.readToken_mult_modulo(e2);
          }
          readToken_pipe_amp(e2) {
            let s2 = this.input.charCodeAt(this.state.pos + 1);
            if (e2 === 124 && s2 === 125) {
              this.finishOp(9, 2);
              return;
            }
            super.readToken_pipe_amp(e2);
          }
          parseTopLevel(e2, s2) {
            let i2 = super.parseTopLevel(e2, s2);
            return this.state.hasFlowComment && this.raise(g2.UnterminatedFlowComment, this.state.curPosition()), i2;
          }
          skipBlockComment() {
            if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
              if (this.state.hasFlowComment)
                throw this.raise(g2.NestedFlowComment, this.state.startLoc);
              this.hasFlowCommentCompletion();
              let e2 = this.skipFlowComment();
              e2 && (this.state.pos += e2, this.state.hasFlowComment = true);
              return;
            }
            return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
          }
          skipFlowComment() {
            let { pos: e2 } = this.state, s2 = 2;
            for (; [32, 9].includes(this.input.charCodeAt(e2 + s2)); )
              s2++;
            let i2 = this.input.charCodeAt(s2 + e2), r2 = this.input.charCodeAt(s2 + e2 + 1);
            return i2 === 58 && r2 === 58 ? s2 + 2 : this.input.slice(s2 + e2, s2 + e2 + 12) === "flow-include" ? s2 + 12 : i2 === 58 && r2 !== 58 ? s2 : false;
          }
          hasFlowCommentCompletion() {
            if (this.input.indexOf("*/", this.state.pos) === -1)
              throw this.raise(p2.UnterminatedComment, this.state.curPosition());
          }
          flowEnumErrorBooleanMemberNotInitialized(e2, { enumName: s2, memberName: i2 }) {
            this.raise(g2.EnumBooleanMemberNotInitialized, e2, { memberName: i2, enumName: s2 });
          }
          flowEnumErrorInvalidMemberInitializer(e2, s2) {
            return this.raise(s2.explicitType ? s2.explicitType === "symbol" ? g2.EnumInvalidMemberInitializerSymbolType : g2.EnumInvalidMemberInitializerPrimaryType : g2.EnumInvalidMemberInitializerUnknownType, e2, s2);
          }
          flowEnumErrorNumberMemberNotInitialized(e2, s2) {
            this.raise(g2.EnumNumberMemberNotInitialized, e2, s2);
          }
          flowEnumErrorStringMemberInconsistentlyInitialized(e2, s2) {
            this.raise(g2.EnumStringMemberInconsistentlyInitialized, e2, s2);
          }
          flowEnumMemberInit() {
            let e2 = this.state.startLoc, s2 = () => this.match(12) || this.match(8);
            switch (this.state.type) {
              case 134: {
                let i2 = this.parseNumericLiteral(this.state.value);
                return s2() ? { type: "number", loc: i2.loc.start, value: i2 } : { type: "invalid", loc: e2 };
              }
              case 133: {
                let i2 = this.parseStringLiteral(this.state.value);
                return s2() ? { type: "string", loc: i2.loc.start, value: i2 } : { type: "invalid", loc: e2 };
              }
              case 85:
              case 86: {
                let i2 = this.parseBooleanLiteral(this.match(85));
                return s2() ? { type: "boolean", loc: i2.loc.start, value: i2 } : { type: "invalid", loc: e2 };
              }
              default:
                return { type: "invalid", loc: e2 };
            }
          }
          flowEnumMemberRaw() {
            let e2 = this.state.startLoc, s2 = this.parseIdentifier(true), i2 = this.eat(29) ? this.flowEnumMemberInit() : { type: "none", loc: e2 };
            return { id: s2, init: i2 };
          }
          flowEnumCheckExplicitTypeMismatch(e2, s2, i2) {
            let { explicitType: r2 } = s2;
            r2 !== null && r2 !== i2 && this.flowEnumErrorInvalidMemberInitializer(e2, s2);
          }
          flowEnumMembers({ enumName: e2, explicitType: s2 }) {
            let i2 = /* @__PURE__ */ new Set(), r2 = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] }, n2 = false;
            for (; !this.match(8); ) {
              if (this.eat(21)) {
                n2 = true;
                break;
              }
              let o2 = this.startNode(), { id: h2, init: c2 } = this.flowEnumMemberRaw(), l2 = h2.name;
              if (l2 === "")
                continue;
              /^[a-z]/.test(l2) && this.raise(g2.EnumInvalidMemberName, h2, { memberName: l2, suggestion: l2[0].toUpperCase() + l2.slice(1), enumName: e2 }), i2.has(l2) && this.raise(g2.EnumDuplicateMemberName, h2, { memberName: l2, enumName: e2 }), i2.add(l2);
              let u2 = { enumName: e2, explicitType: s2, memberName: l2 };
              switch (o2.id = h2, c2.type) {
                case "boolean": {
                  this.flowEnumCheckExplicitTypeMismatch(c2.loc, u2, "boolean"), o2.init = c2.value, r2.booleanMembers.push(this.finishNode(o2, "EnumBooleanMember"));
                  break;
                }
                case "number": {
                  this.flowEnumCheckExplicitTypeMismatch(c2.loc, u2, "number"), o2.init = c2.value, r2.numberMembers.push(this.finishNode(o2, "EnumNumberMember"));
                  break;
                }
                case "string": {
                  this.flowEnumCheckExplicitTypeMismatch(c2.loc, u2, "string"), o2.init = c2.value, r2.stringMembers.push(this.finishNode(o2, "EnumStringMember"));
                  break;
                }
                case "invalid":
                  throw this.flowEnumErrorInvalidMemberInitializer(c2.loc, u2);
                case "none":
                  switch (s2) {
                    case "boolean":
                      this.flowEnumErrorBooleanMemberNotInitialized(c2.loc, u2);
                      break;
                    case "number":
                      this.flowEnumErrorNumberMemberNotInitialized(c2.loc, u2);
                      break;
                    default:
                      r2.defaultedMembers.push(this.finishNode(o2, "EnumDefaultedMember"));
                  }
              }
              this.match(8) || this.expect(12);
            }
            return { members: r2, hasUnknownMembers: n2 };
          }
          flowEnumStringMembers(e2, s2, { enumName: i2 }) {
            if (e2.length === 0)
              return s2;
            if (s2.length === 0)
              return e2;
            if (s2.length > e2.length) {
              for (let r2 of e2)
                this.flowEnumErrorStringMemberInconsistentlyInitialized(r2, { enumName: i2 });
              return s2;
            } else {
              for (let r2 of s2)
                this.flowEnumErrorStringMemberInconsistentlyInitialized(r2, { enumName: i2 });
              return e2;
            }
          }
          flowEnumParseExplicitType({ enumName: e2 }) {
            if (!this.eatContextual(102))
              return null;
            if (!w2(this.state.type))
              throw this.raise(g2.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, { enumName: e2 });
            let { value: s2 } = this.state;
            return this.next(), s2 !== "boolean" && s2 !== "number" && s2 !== "string" && s2 !== "symbol" && this.raise(g2.EnumInvalidExplicitType, this.state.startLoc, { enumName: e2, invalidEnumType: s2 }), s2;
          }
          flowEnumBody(e2, s2) {
            let i2 = s2.name, r2 = s2.loc.start, n2 = this.flowEnumParseExplicitType({ enumName: i2 });
            this.expect(5);
            let { members: o2, hasUnknownMembers: h2 } = this.flowEnumMembers({ enumName: i2, explicitType: n2 });
            switch (e2.hasUnknownMembers = h2, n2) {
              case "boolean":
                return e2.explicitType = true, e2.members = o2.booleanMembers, this.expect(8), this.finishNode(e2, "EnumBooleanBody");
              case "number":
                return e2.explicitType = true, e2.members = o2.numberMembers, this.expect(8), this.finishNode(e2, "EnumNumberBody");
              case "string":
                return e2.explicitType = true, e2.members = this.flowEnumStringMembers(o2.stringMembers, o2.defaultedMembers, { enumName: i2 }), this.expect(8), this.finishNode(e2, "EnumStringBody");
              case "symbol":
                return e2.members = o2.defaultedMembers, this.expect(8), this.finishNode(e2, "EnumSymbolBody");
              default: {
                let c2 = () => (e2.members = [], this.expect(8), this.finishNode(e2, "EnumStringBody"));
                e2.explicitType = false;
                let l2 = o2.booleanMembers.length, u2 = o2.numberMembers.length, f2 = o2.stringMembers.length, d2 = o2.defaultedMembers.length;
                if (!l2 && !u2 && !f2 && !d2)
                  return c2();
                if (!l2 && !u2)
                  return e2.members = this.flowEnumStringMembers(o2.stringMembers, o2.defaultedMembers, { enumName: i2 }), this.expect(8), this.finishNode(e2, "EnumStringBody");
                if (!u2 && !f2 && l2 >= d2) {
                  for (let y3 of o2.defaultedMembers)
                    this.flowEnumErrorBooleanMemberNotInitialized(y3.loc.start, { enumName: i2, memberName: y3.id.name });
                  return e2.members = o2.booleanMembers, this.expect(8), this.finishNode(e2, "EnumBooleanBody");
                } else if (!l2 && !f2 && u2 >= d2) {
                  for (let y3 of o2.defaultedMembers)
                    this.flowEnumErrorNumberMemberNotInitialized(y3.loc.start, { enumName: i2, memberName: y3.id.name });
                  return e2.members = o2.numberMembers, this.expect(8), this.finishNode(e2, "EnumNumberBody");
                } else
                  return this.raise(g2.EnumInconsistentMemberValues, r2, { enumName: i2 }), c2();
              }
            }
          }
          flowParseEnumDeclaration(e2) {
            let s2 = this.parseIdentifier();
            return e2.id = s2, e2.body = this.flowEnumBody(this.startNode(), s2), this.finishNode(e2, "EnumDeclaration");
          }
          isLookaheadToken_lt() {
            let e2 = this.nextTokenStart();
            if (this.input.charCodeAt(e2) === 60) {
              let s2 = this.input.charCodeAt(e2 + 1);
              return s2 !== 60 && s2 !== 61;
            }
            return false;
          }
          maybeUnwrapTypeCastExpression(e2) {
            return e2.type === "TypeCastExpression" ? e2.expression : e2;
          }
        }, W2 = j2`jsx`({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: ({ openingTagName: a2 }) => `Expected corresponding JSX closing tag for <${a2}>.`, MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnexpectedToken: ({ unexpected: a2, HTMLEntity: t2 }) => `Unexpected token \`${a2}\`. Did you mean \`${t2}\` or \`{'${a2}'}\`?`, UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" });
        function z3(a2) {
          return a2 ? a2.type === "JSXOpeningFragment" || a2.type === "JSXClosingFragment" : false;
        }
        function Y2(a2) {
          if (a2.type === "JSXIdentifier")
            return a2.name;
          if (a2.type === "JSXNamespacedName")
            return a2.namespace.name + ":" + a2.name.name;
          if (a2.type === "JSXMemberExpression")
            return Y2(a2.object) + "." + Y2(a2.property);
          throw new Error("Node had unexpected type: " + a2.type);
        }
        var zi = (a2) => class extends a2 {
          jsxReadToken() {
            let e2 = "", s2 = this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length)
                throw this.raise(W2.UnterminatedJsxContent, this.state.startLoc);
              let i2 = this.input.charCodeAt(this.state.pos);
              switch (i2) {
                case 60:
                case 123:
                  if (this.state.pos === this.state.start) {
                    i2 === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(142)) : super.getTokenFromCode(i2);
                    return;
                  }
                  e2 += this.input.slice(s2, this.state.pos), this.finishToken(141, e2);
                  return;
                case 38:
                  e2 += this.input.slice(s2, this.state.pos), e2 += this.jsxReadEntity(), s2 = this.state.pos;
                  break;
                case 62:
                case 125:
                default:
                  fe2(i2) ? (e2 += this.input.slice(s2, this.state.pos), e2 += this.jsxReadNewLine(true), s2 = this.state.pos) : ++this.state.pos;
              }
            }
          }
          jsxReadNewLine(e2) {
            let s2 = this.input.charCodeAt(this.state.pos), i2;
            return ++this.state.pos, s2 === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, i2 = e2 ? `
` : `\r
`) : i2 = String.fromCharCode(s2), ++this.state.curLine, this.state.lineStart = this.state.pos, i2;
          }
          jsxReadString(e2) {
            let s2 = "", i2 = ++this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length)
                throw this.raise(p2.UnterminatedString, this.state.startLoc);
              let r2 = this.input.charCodeAt(this.state.pos);
              if (r2 === e2)
                break;
              r2 === 38 ? (s2 += this.input.slice(i2, this.state.pos), s2 += this.jsxReadEntity(), i2 = this.state.pos) : fe2(r2) ? (s2 += this.input.slice(i2, this.state.pos), s2 += this.jsxReadNewLine(false), i2 = this.state.pos) : ++this.state.pos;
            }
            s2 += this.input.slice(i2, this.state.pos++), this.finishToken(133, s2);
          }
          jsxReadEntity() {
            let e2 = ++this.state.pos;
            if (this.codePointAtPos(this.state.pos) === 35) {
              ++this.state.pos;
              let s2 = 10;
              this.codePointAtPos(this.state.pos) === 120 && (s2 = 16, ++this.state.pos);
              let i2 = this.readInt(s2, void 0, false, "bail");
              if (i2 !== null && this.codePointAtPos(this.state.pos) === 59)
                return ++this.state.pos, String.fromCodePoint(i2);
            } else {
              let s2 = 0, i2 = false;
              for (; s2++ < 10 && this.state.pos < this.length && !(i2 = this.codePointAtPos(this.state.pos) === 59); )
                ++this.state.pos;
              if (i2) {
                let r2 = this.input.slice(e2, this.state.pos), n2 = void 0;
                if (++this.state.pos, n2)
                  return n2;
              }
            }
            return this.state.pos = e2, "&";
          }
          jsxReadWord() {
            let e2, s2 = this.state.pos;
            do
              e2 = this.input.charCodeAt(++this.state.pos);
            while (Q3(e2) || e2 === 45);
            this.finishToken(140, this.input.slice(s2, this.state.pos));
          }
          jsxParseIdentifier() {
            let e2 = this.startNode();
            return this.match(140) ? e2.name = this.state.value : Pt2(this.state.type) ? e2.name = K2(this.state.type) : this.unexpected(), this.next(), this.finishNode(e2, "JSXIdentifier");
          }
          jsxParseNamespacedName() {
            let e2 = this.state.startLoc, s2 = this.jsxParseIdentifier();
            if (!this.eat(14))
              return s2;
            let i2 = this.startNodeAt(e2);
            return i2.namespace = s2, i2.name = this.jsxParseIdentifier(), this.finishNode(i2, "JSXNamespacedName");
          }
          jsxParseElementName() {
            let e2 = this.state.startLoc, s2 = this.jsxParseNamespacedName();
            if (s2.type === "JSXNamespacedName")
              return s2;
            for (; this.eat(16); ) {
              let i2 = this.startNodeAt(e2);
              i2.object = s2, i2.property = this.jsxParseIdentifier(), s2 = this.finishNode(i2, "JSXMemberExpression");
            }
            return s2;
          }
          jsxParseAttributeValue() {
            let e2;
            switch (this.state.type) {
              case 5:
                return e2 = this.startNode(), this.setContext(C.brace), this.next(), e2 = this.jsxParseExpressionContainer(e2, C.j_oTag), e2.expression.type === "JSXEmptyExpression" && this.raise(W2.AttributeIsEmpty, e2), e2;
              case 142:
              case 133:
                return this.parseExprAtom();
              default:
                throw this.raise(W2.UnsupportedJsxValue, this.state.startLoc);
            }
          }
          jsxParseEmptyExpression() {
            let e2 = this.startNodeAt(this.state.lastTokEndLoc);
            return this.finishNodeAt(e2, "JSXEmptyExpression", this.state.startLoc);
          }
          jsxParseSpreadChild(e2) {
            return this.next(), e2.expression = this.parseExpression(), this.setContext(C.j_expr), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e2, "JSXSpreadChild");
          }
          jsxParseExpressionContainer(e2, s2) {
            if (this.match(8))
              e2.expression = this.jsxParseEmptyExpression();
            else {
              let i2 = this.parseExpression();
              e2.expression = i2;
            }
            return this.setContext(s2), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e2, "JSXExpressionContainer");
          }
          jsxParseAttribute() {
            let e2 = this.startNode();
            return this.match(5) ? (this.setContext(C.brace), this.next(), this.expect(21), e2.argument = this.parseMaybeAssignAllowIn(), this.setContext(C.j_oTag), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e2, "JSXSpreadAttribute")) : (e2.name = this.jsxParseNamespacedName(), e2.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(e2, "JSXAttribute"));
          }
          jsxParseOpeningElementAt(e2) {
            let s2 = this.startNodeAt(e2);
            return this.eat(143) ? this.finishNode(s2, "JSXOpeningFragment") : (s2.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(s2));
          }
          jsxParseOpeningElementAfterName(e2) {
            let s2 = [];
            for (; !this.match(56) && !this.match(143); )
              s2.push(this.jsxParseAttribute());
            return e2.attributes = s2, e2.selfClosing = this.eat(56), this.expect(143), this.finishNode(e2, "JSXOpeningElement");
          }
          jsxParseClosingElementAt(e2) {
            let s2 = this.startNodeAt(e2);
            return this.eat(143) ? this.finishNode(s2, "JSXClosingFragment") : (s2.name = this.jsxParseElementName(), this.expect(143), this.finishNode(s2, "JSXClosingElement"));
          }
          jsxParseElementAt(e2) {
            let s2 = this.startNodeAt(e2), i2 = [], r2 = this.jsxParseOpeningElementAt(e2), n2 = null;
            if (!r2.selfClosing) {
              e:
                for (; ; )
                  switch (this.state.type) {
                    case 142:
                      if (e2 = this.state.startLoc, this.next(), this.eat(56)) {
                        n2 = this.jsxParseClosingElementAt(e2);
                        break e;
                      }
                      i2.push(this.jsxParseElementAt(e2));
                      break;
                    case 141:
                      i2.push(this.parseLiteral(this.state.value, "JSXText"));
                      break;
                    case 5: {
                      let o2 = this.startNode();
                      this.setContext(C.brace), this.next(), this.match(21) ? i2.push(this.jsxParseSpreadChild(o2)) : i2.push(this.jsxParseExpressionContainer(o2, C.j_expr));
                      break;
                    }
                    default:
                      this.unexpected();
                  }
              z3(r2) && !z3(n2) && n2 !== null ? this.raise(W2.MissingClosingTagFragment, n2) : !z3(r2) && z3(n2) ? this.raise(W2.MissingClosingTagElement, n2, { openingTagName: Y2(r2.name) }) : !z3(r2) && !z3(n2) && Y2(n2.name) !== Y2(r2.name) && this.raise(W2.MissingClosingTagElement, n2, { openingTagName: Y2(r2.name) });
            }
            if (z3(r2) ? (s2.openingFragment = r2, s2.closingFragment = n2) : (s2.openingElement = r2, s2.closingElement = n2), s2.children = i2, this.match(47))
              throw this.raise(W2.UnwrappedAdjacentJSXElements, this.state.startLoc);
            return z3(r2) ? this.finishNode(s2, "JSXFragment") : this.finishNode(s2, "JSXElement");
          }
          jsxParseElement() {
            let e2 = this.state.startLoc;
            return this.next(), this.jsxParseElementAt(e2);
          }
          setContext(e2) {
            let { context: s2 } = this.state;
            s2[s2.length - 1] = e2;
          }
          parseExprAtom(e2) {
            return this.match(142) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(142), this.jsxParseElement()) : super.parseExprAtom(e2);
          }
          skipSpace() {
            this.curContext().preserveSpace || super.skipSpace();
          }
          getTokenFromCode(e2) {
            let s2 = this.curContext();
            if (s2 === C.j_expr) {
              this.jsxReadToken();
              return;
            }
            if (s2 === C.j_oTag || s2 === C.j_cTag) {
              if (_3(e2)) {
                this.jsxReadWord();
                return;
              }
              if (e2 === 62) {
                ++this.state.pos, this.finishToken(143);
                return;
              }
              if ((e2 === 34 || e2 === 39) && s2 === C.j_oTag) {
                this.jsxReadString(e2);
                return;
              }
            }
            if (e2 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
              ++this.state.pos, this.finishToken(142);
              return;
            }
            super.getTokenFromCode(e2);
          }
          updateContext(e2) {
            let { context: s2, type: i2 } = this.state;
            if (i2 === 56 && e2 === 142)
              s2.splice(-2, 2, C.j_cTag), this.state.canStartJSXElement = false;
            else if (i2 === 142)
              s2.push(C.j_oTag);
            else if (i2 === 143) {
              let r2 = s2[s2.length - 1];
              r2 === C.j_oTag && e2 === 56 || r2 === C.j_cTag ? (s2.pop(), this.state.canStartJSXElement = s2[s2.length - 1] === C.j_expr) : (this.setContext(C.j_expr), this.state.canStartJSXElement = true);
            } else
              this.state.canStartJSXElement = hi3(i2);
          }
        }, ot3 = class extends de2 {
          constructor(...t2) {
            super(...t2), this.tsNames = /* @__PURE__ */ new Map();
          }
        }, ht3 = class extends me2 {
          constructor(...t2) {
            super(...t2), this.importsStack = [];
          }
          createScope(t2) {
            return this.importsStack.push(/* @__PURE__ */ new Set()), new ot3(t2);
          }
          enter(t2) {
            t2 === 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(t2);
          }
          exit() {
            let t2 = super.exit();
            return t2 === 256 && this.importsStack.pop(), t2;
          }
          hasImport(t2, e2) {
            let s2 = this.importsStack.length;
            if (this.importsStack[s2 - 1].has(t2))
              return true;
            if (!e2 && s2 > 1) {
              for (let i2 = 0; i2 < s2 - 1; i2++)
                if (this.importsStack[i2].has(t2))
                  return true;
            }
            return false;
          }
          declareName(t2, e2, s2) {
            if (e2 & 4096) {
              this.hasImport(t2, true) && this.parser.raise(p2.VarRedeclaration, s2, { identifierName: t2 }), this.importsStack[this.importsStack.length - 1].add(t2);
              return;
            }
            let i2 = this.currentScope(), r2 = i2.tsNames.get(t2) || 0;
            if (e2 & 1024) {
              this.maybeExportDefined(i2, t2), i2.tsNames.set(t2, r2 | 16);
              return;
            }
            super.declareName(t2, e2, s2), e2 & 2 && (e2 & 1 || (this.checkRedeclarationInScope(i2, t2, e2, s2), this.maybeExportDefined(i2, t2)), r2 = r2 | 1), e2 & 256 && (r2 = r2 | 2), e2 & 512 && (r2 = r2 | 4), e2 & 128 && (r2 = r2 | 8), r2 && i2.tsNames.set(t2, r2);
          }
          isRedeclaredInScope(t2, e2, s2) {
            let i2 = t2.tsNames.get(e2);
            if ((i2 & 2) > 0) {
              if (s2 & 256) {
                let r2 = !!(s2 & 512), n2 = (i2 & 4) > 0;
                return r2 !== n2;
              }
              return true;
            }
            return s2 & 128 && (i2 & 8) > 0 ? t2.names.get(e2) & 2 ? !!(s2 & 1) : false : s2 & 2 && (i2 & 1) > 0 ? true : super.isRedeclaredInScope(t2, e2, s2);
          }
          checkLocalExport(t2) {
            let { name: e2 } = t2;
            if (this.hasImport(e2))
              return;
            let s2 = this.scopeStack.length;
            for (let i2 = s2 - 1; i2 >= 0; i2--) {
              let n2 = this.scopeStack[i2].tsNames.get(e2);
              if ((n2 & 1) > 0 || (n2 & 16) > 0)
                return;
            }
            super.checkLocalExport(t2);
          }
        }, Ki2 = (a2, t2) => hasOwnProperty.call(a2, t2) && a2[t2], as = (a2) => a2.type === "ParenthesizedExpression" ? as(a2.expression) : a2, lt3 = class extends nt3 {
          toAssignable(t2, e2 = false) {
            var s2, i2;
            let r2;
            switch ((t2.type === "ParenthesizedExpression" || (s2 = t2.extra) != null && s2.parenthesized) && (r2 = as(t2), e2 ? r2.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(p2.InvalidParenthesizedAssignment, t2) : r2.type !== "MemberExpression" && !this.isOptionalMemberExpression(r2) && this.raise(p2.InvalidParenthesizedAssignment, t2) : this.raise(p2.InvalidParenthesizedAssignment, t2)), t2.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                break;
              case "ObjectExpression":
                t2.type = "ObjectPattern";
                for (let o2 = 0, h2 = t2.properties.length, c2 = h2 - 1; o2 < h2; o2++) {
                  var n2;
                  let l2 = t2.properties[o2], u2 = o2 === c2;
                  this.toAssignableObjectExpressionProp(l2, u2, e2), u2 && l2.type === "RestElement" && (n2 = t2.extra) != null && n2.trailingCommaLoc && this.raise(p2.RestTrailingComma, t2.extra.trailingCommaLoc);
                }
                break;
              case "ObjectProperty": {
                let { key: o2, value: h2 } = t2;
                this.isPrivateName(o2) && this.classScope.usePrivateName(this.getPrivateNameSV(o2), o2.loc.start), this.toAssignable(h2, e2);
                break;
              }
              case "SpreadElement":
                throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
              case "ArrayExpression":
                t2.type = "ArrayPattern", this.toAssignableList(t2.elements, (i2 = t2.extra) == null ? void 0 : i2.trailingCommaLoc, e2);
                break;
              case "AssignmentExpression":
                t2.operator !== "=" && this.raise(p2.MissingEqInAssignment, t2.left.loc.end), t2.type = "AssignmentPattern", delete t2.operator, this.toAssignable(t2.left, e2);
                break;
              case "ParenthesizedExpression":
                this.toAssignable(r2, e2);
                break;
            }
          }
          toAssignableObjectExpressionProp(t2, e2, s2) {
            if (t2.type === "ObjectMethod")
              this.raise(t2.kind === "get" || t2.kind === "set" ? p2.PatternHasAccessor : p2.PatternHasMethod, t2.key);
            else if (t2.type === "SpreadElement") {
              t2.type = "RestElement";
              let i2 = t2.argument;
              this.checkToRestConversion(i2, false), this.toAssignable(i2, s2), e2 || this.raise(p2.RestTrailingComma, t2);
            } else
              this.toAssignable(t2, s2);
          }
          toAssignableList(t2, e2, s2) {
            let i2 = t2.length - 1;
            for (let r2 = 0; r2 <= i2; r2++) {
              let n2 = t2[r2];
              if (n2) {
                if (n2.type === "SpreadElement") {
                  n2.type = "RestElement";
                  let o2 = n2.argument;
                  this.checkToRestConversion(o2, true), this.toAssignable(o2, s2);
                } else
                  this.toAssignable(n2, s2);
                n2.type === "RestElement" && (r2 < i2 ? this.raise(p2.RestTrailingComma, n2) : e2 && this.raise(p2.RestTrailingComma, e2));
              }
            }
          }
          isAssignable(t2, e2) {
            switch (t2.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                return true;
              case "ObjectExpression": {
                let s2 = t2.properties.length - 1;
                return t2.properties.every((i2, r2) => i2.type !== "ObjectMethod" && (r2 === s2 || i2.type !== "SpreadElement") && this.isAssignable(i2));
              }
              case "ObjectProperty":
                return this.isAssignable(t2.value);
              case "SpreadElement":
                return this.isAssignable(t2.argument);
              case "ArrayExpression":
                return t2.elements.every((s2) => s2 === null || this.isAssignable(s2));
              case "AssignmentExpression":
                return t2.operator === "=";
              case "ParenthesizedExpression":
                return this.isAssignable(t2.expression);
              case "MemberExpression":
              case "OptionalMemberExpression":
                return !e2;
              default:
                return false;
            }
          }
          toReferencedList(t2, e2) {
            return t2;
          }
          toReferencedListDeep(t2, e2) {
            this.toReferencedList(t2, e2);
            for (let s2 of t2)
              (s2 == null ? void 0 : s2.type) === "ArrayExpression" && this.toReferencedListDeep(s2.elements);
          }
          parseSpread(t2) {
            let e2 = this.startNode();
            return this.next(), e2.argument = this.parseMaybeAssignAllowIn(t2, void 0), this.finishNode(e2, "SpreadElement");
          }
          parseRestBinding() {
            let t2 = this.startNode();
            return this.next(), t2.argument = this.parseBindingAtom(), this.finishNode(t2, "RestElement");
          }
          parseBindingAtom() {
            switch (this.state.type) {
              case 0: {
                let t2 = this.startNode();
                return this.next(), t2.elements = this.parseBindingList(3, 93, 1), this.finishNode(t2, "ArrayPattern");
              }
              case 5:
                return this.parseObjectLike(8, true);
            }
            return this.parseIdentifier();
          }
          parseBindingList(t2, e2, s2) {
            let i2 = s2 & 1, r2 = [], n2 = true;
            for (; !this.eat(t2); )
              if (n2 ? n2 = false : this.expect(12), i2 && this.match(12))
                r2.push(null);
              else {
                if (this.eat(t2))
                  break;
                if (this.match(21)) {
                  if (r2.push(this.parseAssignableListItemTypes(this.parseRestBinding(), s2)), !this.checkCommaAfterRest(e2)) {
                    this.expect(t2);
                    break;
                  }
                } else {
                  let o2 = [];
                  for (this.match(26) && this.hasPlugin("decorators") && this.raise(p2.UnsupportedParameterDecorator, this.state.startLoc); this.match(26); )
                    o2.push(this.parseDecorator());
                  r2.push(this.parseAssignableListItem(s2, o2));
                }
              }
            return r2;
          }
          parseBindingRestProperty(t2) {
            return this.next(), t2.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(t2, "RestElement");
          }
          parseBindingProperty() {
            let { type: t2, startLoc: e2 } = this.state;
            if (t2 === 21)
              return this.parseBindingRestProperty(this.startNode());
            let s2 = this.startNode();
            return t2 === 138 ? (this.expectPlugin("destructuringPrivate", e2), this.classScope.usePrivateName(this.state.value, e2), s2.key = this.parsePrivateName()) : this.parsePropertyName(s2), s2.method = false, this.parseObjPropValue(s2, e2, false, false, true, false);
          }
          parseAssignableListItem(t2, e2) {
            let s2 = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(s2, t2);
            let i2 = this.parseMaybeDefault(s2.loc.start, s2);
            return e2.length && (s2.decorators = e2), i2;
          }
          parseAssignableListItemTypes(t2, e2) {
            return t2;
          }
          parseMaybeDefault(t2, e2) {
            var s2, i2;
            if ((s2 = t2) != null || (t2 = this.state.startLoc), e2 = (i2 = e2) != null ? i2 : this.parseBindingAtom(), !this.eat(29))
              return e2;
            let r2 = this.startNodeAt(t2);
            return r2.left = e2, r2.right = this.parseMaybeAssignAllowIn(), this.finishNode(r2, "AssignmentPattern");
          }
          isValidLVal(t2, e2, s2) {
            return Ki2({ AssignmentPattern: "left", RestElement: "argument", ObjectProperty: "value", ParenthesizedExpression: "expression", ArrayPattern: "elements", ObjectPattern: "properties" }, t2);
          }
          isOptionalMemberExpression(t2) {
            return t2.type === "OptionalMemberExpression";
          }
          checkLVal(t2, { in: e2, binding: s2 = 64, checkClashes: i2 = false, strictModeChanged: r2 = false, hasParenthesizedAncestor: n2 = false }) {
            var o2;
            let h2 = t2.type;
            if (this.isObjectMethod(t2))
              return;
            let c2 = this.isOptionalMemberExpression(t2);
            if (c2 || h2 === "MemberExpression") {
              c2 && (this.expectPlugin("optionalChainingAssign", t2.loc.start), e2.type !== "AssignmentExpression" && this.raise(p2.InvalidLhsOptionalChaining, t2, { ancestor: e2 })), s2 !== 64 && this.raise(p2.InvalidPropertyBindingPattern, t2);
              return;
            }
            if (h2 === "Identifier") {
              this.checkIdentifier(t2, s2, r2);
              let { name: y3 } = t2;
              i2 && (i2.has(y3) ? this.raise(p2.ParamDupe, t2) : i2.add(y3));
              return;
            }
            let l2 = this.isValidLVal(h2, !(n2 || (o2 = t2.extra) != null && o2.parenthesized) && e2.type === "AssignmentExpression", s2);
            if (l2 === true)
              return;
            if (l2 === false) {
              let y3 = s2 === 64 ? p2.InvalidLhs : p2.InvalidLhsBinding;
              this.raise(y3, t2, { ancestor: e2 });
              return;
            }
            let [u2, f2] = Array.isArray(l2) ? l2 : [l2, h2 === "ParenthesizedExpression"], d2 = h2 === "ArrayPattern" || h2 === "ObjectPattern" ? { type: h2 } : e2;
            for (let y3 of [].concat(t2[u2]))
              y3 && this.checkLVal(y3, { in: d2, binding: s2, checkClashes: i2, strictModeChanged: r2, hasParenthesizedAncestor: f2 });
          }
          checkIdentifier(t2, e2, s2 = false) {
            this.state.strict && (s2 ? Zt(t2.name, this.inModule) : Qt2(t2.name)) && (e2 === 64 ? this.raise(p2.StrictEvalArguments, t2, { referenceName: t2.name }) : this.raise(p2.StrictEvalArgumentsBinding, t2, { bindingName: t2.name })), e2 & 8192 && t2.name === "let" && this.raise(p2.LetInLexicalBinding, t2), e2 & 64 || this.declareNameFromIdentifier(t2, e2);
          }
          declareNameFromIdentifier(t2, e2) {
            this.scope.declareName(t2.name, e2, t2.loc.start);
          }
          checkToRestConversion(t2, e2) {
            switch (t2.type) {
              case "ParenthesizedExpression":
                this.checkToRestConversion(t2.expression, e2);
                break;
              case "Identifier":
              case "MemberExpression":
                break;
              case "ArrayExpression":
              case "ObjectExpression":
                if (e2)
                  break;
              default:
                this.raise(p2.InvalidRestAssignmentPattern, t2);
            }
          }
          checkCommaAfterRest(t2) {
            return this.match(12) ? (this.raise(this.lookaheadCharCode() === t2 ? p2.RestTrailingComma : p2.ElementAfterRest, this.state.startLoc), true) : false;
          }
        }, Hi = (a2, t2) => hasOwnProperty.call(a2, t2) && a2[t2];
        function Wi(a2) {
          if (a2 == null)
            throw new Error(`Unexpected ${a2} value.`);
          return a2;
        }
        function jt2(a2) {
          if (!a2)
            throw new Error("Assert fail");
        }
        var x2 = j2`typescript`({ AbstractMethodHasImplementation: ({ methodName: a2 }) => `Method '${a2}' cannot have an implementation because it is marked abstract.`, AbstractPropertyHasInitializer: ({ propertyName: a2 }) => `Property '${a2}' cannot have an initializer because it is marked abstract.`, AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: ({ kind: a2 }) => `'declare' is not allowed in ${a2}ters.`, DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: ({ modifier: a2 }) => "Accessibility modifier already seen.", DuplicateModifier: ({ modifier: a2 }) => `Duplicate modifier: '${a2}'.`, EmptyHeritageClauseType: ({ token: a2 }) => `'${a2}' list cannot be empty.`, EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier", IncompatibleModifiers: ({ modifiers: a2 }) => `'${a2[0]}' modifier cannot be used with '${a2[1]}' modifier.`, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: ({ modifier: a2 }) => `Index signatures cannot have an accessibility modifier ('${a2}').`, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.", InvalidModifierOnTypeMember: ({ modifier: a2 }) => `'${a2}' modifier cannot appear on a type member.`, InvalidModifierOnTypeParameter: ({ modifier: a2 }) => `'${a2}' modifier cannot appear on a type parameter.`, InvalidModifierOnTypeParameterPositions: ({ modifier: a2 }) => `'${a2}' modifier can only appear on a type parameter of a class, interface or type alias.`, InvalidModifiersOrder: ({ orderedModifiers: a2 }) => `'${a2[0]}' modifier must precede '${a2[1]}' modifier.`, InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: ({ modifier: a2 }) => `Private elements cannot have an accessibility modifier ('${a2}').`, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.", ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: a2 }) => `Single type parameter ${a2} should have a trailing comma. Example usage: <${a2},>.`, StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: ({ type: a2 }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${a2}.` });
        function Ji(a2) {
          switch (a2) {
            case "any":
              return "TSAnyKeyword";
            case "boolean":
              return "TSBooleanKeyword";
            case "bigint":
              return "TSBigIntKeyword";
            case "never":
              return "TSNeverKeyword";
            case "number":
              return "TSNumberKeyword";
            case "object":
              return "TSObjectKeyword";
            case "string":
              return "TSStringKeyword";
            case "symbol":
              return "TSSymbolKeyword";
            case "undefined":
              return "TSUndefinedKeyword";
            case "unknown":
              return "TSUnknownKeyword";
            default:
              return;
          }
        }
        function $t2(a2) {
          return a2 === "private" || a2 === "public" || a2 === "protected";
        }
        function Xi2(a2) {
          return a2 === "in" || a2 === "out";
        }
        var Gi = (a2) => class extends a2 {
          constructor(...e2) {
            super(...e2), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out"], disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: x2.InvalidModifierOnTypeParameter }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, { allowedModifiers: ["const"], disallowedModifiers: ["in", "out"], errorTemplate: x2.InvalidModifierOnTypeParameterPositions }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out", "const"], disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: x2.InvalidModifierOnTypeParameter });
          }
          getScopeHandler() {
            return ht3;
          }
          tsIsIdentifier() {
            return w2(this.state.type);
          }
          tsTokenCanFollowModifier() {
            return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
          }
          tsNextTokenCanFollowModifier() {
            return this.next(), this.tsTokenCanFollowModifier();
          }
          tsParseModifier(e2, s2) {
            if (!w2(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
              return;
            let i2 = this.state.value;
            if (e2.includes(i2)) {
              if (s2 && this.tsIsStartOfStaticBlocks())
                return;
              if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
                return i2;
            }
          }
          tsParseModifiers({ allowedModifiers: e2, disallowedModifiers: s2, stopOnStartOfClassStaticBlock: i2, errorTemplate: r2 = x2.InvalidModifierOnTypeMember }, n2) {
            let o2 = (c2, l2, u2, f2) => {
              l2 === u2 && n2[f2] && this.raise(x2.InvalidModifiersOrder, c2, { orderedModifiers: [u2, f2] });
            }, h2 = (c2, l2, u2, f2) => {
              (n2[u2] && l2 === f2 || n2[f2] && l2 === u2) && this.raise(x2.IncompatibleModifiers, c2, { modifiers: [u2, f2] });
            };
            for (; ; ) {
              let { startLoc: c2 } = this.state, l2 = this.tsParseModifier(e2.concat(s2 ?? []), i2);
              if (!l2)
                break;
              $t2(l2) ? n2.accessibility ? this.raise(x2.DuplicateAccessibilityModifier, c2, { modifier: l2 }) : (o2(c2, l2, l2, "override"), o2(c2, l2, l2, "static"), o2(c2, l2, l2, "readonly"), n2.accessibility = l2) : Xi2(l2) ? (n2[l2] && this.raise(x2.DuplicateModifier, c2, { modifier: l2 }), n2[l2] = true, o2(c2, l2, "in", "out")) : (hasOwnProperty.call(n2, l2) ? this.raise(x2.DuplicateModifier, c2, { modifier: l2 }) : (o2(c2, l2, "static", "readonly"), o2(c2, l2, "static", "override"), o2(c2, l2, "override", "readonly"), o2(c2, l2, "abstract", "override"), h2(c2, l2, "declare", "override"), h2(c2, l2, "static", "abstract")), n2[l2] = true), s2 != null && s2.includes(l2) && this.raise(r2, c2, { modifier: l2 });
            }
          }
          tsIsListTerminator(e2) {
            switch (e2) {
              case "EnumMembers":
              case "TypeMembers":
                return this.match(8);
              case "HeritageClauseElement":
                return this.match(5);
              case "TupleElementTypes":
                return this.match(3);
              case "TypeParametersOrArguments":
                return this.match(48);
            }
          }
          tsParseList(e2, s2) {
            let i2 = [];
            for (; !this.tsIsListTerminator(e2); )
              i2.push(s2());
            return i2;
          }
          tsParseDelimitedList(e2, s2, i2) {
            return Wi(this.tsParseDelimitedListWorker(e2, s2, true, i2));
          }
          tsParseDelimitedListWorker(e2, s2, i2, r2) {
            let n2 = [], o2 = -1;
            for (; !this.tsIsListTerminator(e2); ) {
              o2 = -1;
              let h2 = s2();
              if (h2 == null)
                return;
              if (n2.push(h2), this.eat(12)) {
                o2 = this.state.lastTokStartLoc.index;
                continue;
              }
              if (this.tsIsListTerminator(e2))
                break;
              i2 && this.expect(12);
              return;
            }
            return r2 && (r2.value = o2), n2;
          }
          tsParseBracketedList(e2, s2, i2, r2, n2) {
            r2 || (i2 ? this.expect(0) : this.expect(47));
            let o2 = this.tsParseDelimitedList(e2, s2, n2);
            return i2 ? this.expect(3) : this.expect(48), o2;
          }
          tsParseImportType() {
            let e2 = this.startNode();
            return this.expect(83), this.expect(10), this.match(133) || this.raise(x2.UnsupportedImportTypeArgument, this.state.startLoc), e2.argument = super.parseExprAtom(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (e2.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (e2.options = super.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11), this.eat(16) && (e2.qualifier = this.tsParseEntityName()), this.match(47) && (e2.typeParameters = this.tsParseTypeArguments()), this.finishNode(e2, "TSImportType");
          }
          tsParseEntityName(e2 = true) {
            let s2 = this.parseIdentifier(e2);
            for (; this.eat(16); ) {
              let i2 = this.startNodeAtNode(s2);
              i2.left = s2, i2.right = this.parseIdentifier(e2), s2 = this.finishNode(i2, "TSQualifiedName");
            }
            return s2;
          }
          tsParseTypeReference() {
            let e2 = this.startNode();
            return e2.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e2.typeParameters = this.tsParseTypeArguments()), this.finishNode(e2, "TSTypeReference");
          }
          tsParseThisTypePredicate(e2) {
            this.next();
            let s2 = this.startNodeAtNode(e2);
            return s2.parameterName = e2, s2.typeAnnotation = this.tsParseTypeAnnotation(false), s2.asserts = false, this.finishNode(s2, "TSTypePredicate");
          }
          tsParseThisTypeNode() {
            let e2 = this.startNode();
            return this.next(), this.finishNode(e2, "TSThisType");
          }
          tsParseTypeQuery() {
            let e2 = this.startNode();
            return this.expect(87), this.match(83) ? e2.exprName = this.tsParseImportType() : e2.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e2.typeParameters = this.tsParseTypeArguments()), this.finishNode(e2, "TSTypeQuery");
          }
          tsParseTypeParameter(e2) {
            let s2 = this.startNode();
            return e2(s2), s2.name = this.tsParseTypeParameterName(), s2.constraint = this.tsEatThenParseType(81), s2.default = this.tsEatThenParseType(29), this.finishNode(s2, "TSTypeParameter");
          }
          tsTryParseTypeParameters(e2) {
            if (this.match(47))
              return this.tsParseTypeParameters(e2);
          }
          tsParseTypeParameters(e2) {
            let s2 = this.startNode();
            this.match(47) || this.match(142) ? this.next() : this.unexpected();
            let i2 = { value: -1 };
            return s2.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, e2), false, true, i2), s2.params.length === 0 && this.raise(x2.EmptyTypeParameters, s2), i2.value !== -1 && this.addExtra(s2, "trailingComma", i2.value), this.finishNode(s2, "TSTypeParameterDeclaration");
          }
          tsFillSignature(e2, s2) {
            let i2 = e2 === 19, r2 = "parameters", n2 = "typeAnnotation";
            s2.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), s2[r2] = this.tsParseBindingListForSignature(), i2 ? s2[n2] = this.tsParseTypeOrTypePredicateAnnotation(e2) : this.match(e2) && (s2[n2] = this.tsParseTypeOrTypePredicateAnnotation(e2));
          }
          tsParseBindingListForSignature() {
            let e2 = super.parseBindingList(11, 41, 2);
            for (let s2 of e2) {
              let { type: i2 } = s2;
              (i2 === "AssignmentPattern" || i2 === "TSParameterProperty") && this.raise(x2.UnsupportedSignatureParameterKind, s2, { type: i2 });
            }
            return e2;
          }
          tsParseTypeMemberSemicolon() {
            !this.eat(12) && !this.isLineTerminator() && this.expect(13);
          }
          tsParseSignatureMember(e2, s2) {
            return this.tsFillSignature(14, s2), this.tsParseTypeMemberSemicolon(), this.finishNode(s2, e2);
          }
          tsIsUnambiguouslyIndexSignature() {
            return this.next(), w2(this.state.type) ? (this.next(), this.match(14)) : false;
          }
          tsTryParseIndexSignature(e2) {
            if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
              return;
            this.expect(0);
            let s2 = this.parseIdentifier();
            s2.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(s2), this.expect(3), e2.parameters = [s2];
            let i2 = this.tsTryParseTypeAnnotation();
            return i2 && (e2.typeAnnotation = i2), this.tsParseTypeMemberSemicolon(), this.finishNode(e2, "TSIndexSignature");
          }
          tsParsePropertyOrMethodSignature(e2, s2) {
            this.eat(17) && (e2.optional = true);
            let i2 = e2;
            if (this.match(10) || this.match(47)) {
              s2 && this.raise(x2.ReadonlyForMethodSignature, e2);
              let r2 = i2;
              r2.kind && this.match(47) && this.raise(x2.AccesorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, r2), this.tsParseTypeMemberSemicolon();
              let n2 = "parameters", o2 = "typeAnnotation";
              if (r2.kind === "get")
                r2[n2].length > 0 && (this.raise(p2.BadGetterArity, this.state.curPosition()), this.isThisParam(r2[n2][0]) && this.raise(x2.AccesorCannotDeclareThisParameter, this.state.curPosition()));
              else if (r2.kind === "set") {
                if (r2[n2].length !== 1)
                  this.raise(p2.BadSetterArity, this.state.curPosition());
                else {
                  let h2 = r2[n2][0];
                  this.isThisParam(h2) && this.raise(x2.AccesorCannotDeclareThisParameter, this.state.curPosition()), h2.type === "Identifier" && h2.optional && this.raise(x2.SetAccesorCannotHaveOptionalParameter, this.state.curPosition()), h2.type === "RestElement" && this.raise(x2.SetAccesorCannotHaveRestParameter, this.state.curPosition());
                }
                r2[o2] && this.raise(x2.SetAccesorCannotHaveReturnType, r2[o2]);
              } else
                r2.kind = "method";
              return this.finishNode(r2, "TSMethodSignature");
            } else {
              let r2 = i2;
              s2 && (r2.readonly = true);
              let n2 = this.tsTryParseTypeAnnotation();
              return n2 && (r2.typeAnnotation = n2), this.tsParseTypeMemberSemicolon(), this.finishNode(r2, "TSPropertySignature");
            }
          }
          tsParseTypeMember() {
            let e2 = this.startNode();
            if (this.match(10) || this.match(47))
              return this.tsParseSignatureMember("TSCallSignatureDeclaration", e2);
            if (this.match(77)) {
              let i2 = this.startNode();
              return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", e2) : (e2.key = this.createIdentifier(i2, "new"), this.tsParsePropertyOrMethodSignature(e2, false));
            }
            this.tsParseModifiers({ allowedModifiers: ["readonly"], disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"] }, e2);
            let s2 = this.tsTryParseIndexSignature(e2);
            return s2 || (super.parsePropertyName(e2), !e2.computed && e2.key.type === "Identifier" && (e2.key.name === "get" || e2.key.name === "set") && this.tsTokenCanFollowModifier() && (e2.kind = e2.key.name, super.parsePropertyName(e2)), this.tsParsePropertyOrMethodSignature(e2, !!e2.readonly));
          }
          tsParseTypeLiteral() {
            let e2 = this.startNode();
            return e2.members = this.tsParseObjectTypeMembers(), this.finishNode(e2, "TSTypeLiteral");
          }
          tsParseObjectTypeMembers() {
            this.expect(5);
            let e2 = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
            return this.expect(8), e2;
          }
          tsIsStartOfMappedType() {
            return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? false : (this.next(), this.match(58)));
          }
          tsParseMappedTypeParameter() {
            let e2 = this.startNode();
            return e2.name = this.tsParseTypeParameterName(), e2.constraint = this.tsExpectThenParseType(58), this.finishNode(e2, "TSTypeParameter");
          }
          tsParseMappedType() {
            let e2 = this.startNode();
            return this.expect(5), this.match(53) ? (e2.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) && (e2.readonly = true), this.expect(0), e2.typeParameter = this.tsParseMappedTypeParameter(), e2.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (e2.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (e2.optional = true), e2.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(e2, "TSMappedType");
          }
          tsParseTupleType() {
            let e2 = this.startNode();
            e2.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
            let s2 = false;
            return e2.elementTypes.forEach((i2) => {
              let { type: r2 } = i2;
              s2 && r2 !== "TSRestType" && r2 !== "TSOptionalType" && !(r2 === "TSNamedTupleMember" && i2.optional) && this.raise(x2.OptionalTypeBeforeRequired, i2), s2 || (s2 = r2 === "TSNamedTupleMember" && i2.optional || r2 === "TSOptionalType");
            }), this.finishNode(e2, "TSTupleType");
          }
          tsParseTupleElementType() {
            let { startLoc: e2 } = this.state, s2 = this.eat(21), i2, r2, n2, o2, c2 = M3(this.state.type) ? this.lookaheadCharCode() : null;
            if (c2 === 58)
              i2 = true, n2 = false, r2 = this.parseIdentifier(true), this.expect(14), o2 = this.tsParseType();
            else if (c2 === 63) {
              n2 = true;
              let l2 = this.state.startLoc, u2 = this.state.value, f2 = this.tsParseNonArrayType();
              this.lookaheadCharCode() === 58 ? (i2 = true, r2 = this.createIdentifier(this.startNodeAt(l2), u2), this.expect(17), this.expect(14), o2 = this.tsParseType()) : (i2 = false, o2 = f2, this.expect(17));
            } else
              o2 = this.tsParseType(), n2 = this.eat(17), i2 = this.eat(14);
            if (i2) {
              let l2;
              r2 ? (l2 = this.startNodeAtNode(r2), l2.optional = n2, l2.label = r2, l2.elementType = o2, this.eat(17) && (l2.optional = true, this.raise(x2.TupleOptionalAfterType, this.state.lastTokStartLoc))) : (l2 = this.startNodeAtNode(o2), l2.optional = n2, this.raise(x2.InvalidTupleMemberLabel, o2), l2.label = o2, l2.elementType = this.tsParseType()), o2 = this.finishNode(l2, "TSNamedTupleMember");
            } else if (n2) {
              let l2 = this.startNodeAtNode(o2);
              l2.typeAnnotation = o2, o2 = this.finishNode(l2, "TSOptionalType");
            }
            if (s2) {
              let l2 = this.startNodeAt(e2);
              l2.typeAnnotation = o2, o2 = this.finishNode(l2, "TSRestType");
            }
            return o2;
          }
          tsParseParenthesizedType() {
            let e2 = this.startNode();
            return this.expect(10), e2.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(e2, "TSParenthesizedType");
          }
          tsParseFunctionOrConstructorType(e2, s2) {
            let i2 = this.startNode();
            return e2 === "TSConstructorType" && (i2.abstract = !!s2, s2 && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, i2)), this.finishNode(i2, e2);
          }
          tsParseLiteralTypeNode() {
            let e2 = this.startNode();
            switch (this.state.type) {
              case 134:
              case 135:
              case 133:
              case 85:
              case 86:
                e2.literal = super.parseExprAtom();
                break;
              default:
                this.unexpected();
            }
            return this.finishNode(e2, "TSLiteralType");
          }
          tsParseTemplateLiteralType() {
            let e2 = this.startNode();
            return e2.literal = super.parseTemplate(false), this.finishNode(e2, "TSLiteralType");
          }
          parseTemplateSubstitution() {
            return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
          }
          tsParseThisTypeOrThisTypePredicate() {
            let e2 = this.tsParseThisTypeNode();
            return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e2) : e2;
          }
          tsParseNonArrayType() {
            switch (this.state.type) {
              case 133:
              case 134:
              case 135:
              case 85:
              case 86:
                return this.tsParseLiteralTypeNode();
              case 53:
                if (this.state.value === "-") {
                  let e2 = this.startNode(), s2 = this.lookahead();
                  return s2.type !== 134 && s2.type !== 135 && this.unexpected(), e2.literal = this.parseMaybeUnary(), this.finishNode(e2, "TSLiteralType");
                }
                break;
              case 78:
                return this.tsParseThisTypeOrThisTypePredicate();
              case 87:
                return this.tsParseTypeQuery();
              case 83:
                return this.tsParseImportType();
              case 5:
                return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
              case 0:
                return this.tsParseTupleType();
              case 10:
                return this.tsParseParenthesizedType();
              case 25:
              case 24:
                return this.tsParseTemplateLiteralType();
              default: {
                let { type: e2 } = this.state;
                if (w2(e2) || e2 === 88 || e2 === 84) {
                  let s2 = e2 === 88 ? "TSVoidKeyword" : e2 === 84 ? "TSNullKeyword" : Ji(this.state.value);
                  if (s2 !== void 0 && this.lookaheadCharCode() !== 46) {
                    let i2 = this.startNode();
                    return this.next(), this.finishNode(i2, s2);
                  }
                  return this.tsParseTypeReference();
                }
              }
            }
            this.unexpected();
          }
          tsParseArrayTypeOrHigher() {
            let e2 = this.tsParseNonArrayType();
            for (; !this.hasPrecedingLineBreak() && this.eat(0); )
              if (this.match(3)) {
                let s2 = this.startNodeAtNode(e2);
                s2.elementType = e2, this.expect(3), e2 = this.finishNode(s2, "TSArrayType");
              } else {
                let s2 = this.startNodeAtNode(e2);
                s2.objectType = e2, s2.indexType = this.tsParseType(), this.expect(3), e2 = this.finishNode(s2, "TSIndexedAccessType");
              }
            return e2;
          }
          tsParseTypeOperator() {
            let e2 = this.startNode(), s2 = this.state.value;
            return this.next(), e2.operator = s2, e2.typeAnnotation = this.tsParseTypeOperatorOrHigher(), s2 === "readonly" && this.tsCheckTypeAnnotationForReadOnly(e2), this.finishNode(e2, "TSTypeOperator");
          }
          tsCheckTypeAnnotationForReadOnly(e2) {
            switch (e2.typeAnnotation.type) {
              case "TSTupleType":
              case "TSArrayType":
                return;
              default:
                this.raise(x2.UnexpectedReadonly, e2);
            }
          }
          tsParseInferType() {
            let e2 = this.startNode();
            this.expectContextual(115);
            let s2 = this.startNode();
            return s2.name = this.tsParseTypeParameterName(), s2.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), e2.typeParameter = this.finishNode(s2, "TSTypeParameter"), this.finishNode(e2, "TSInferType");
          }
          tsParseConstraintForInferType() {
            if (this.eat(81)) {
              let e2 = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
              if (this.state.inDisallowConditionalTypesContext || !this.match(17))
                return e2;
            }
          }
          tsParseTypeOperatorOrHigher() {
            return di2(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
          }
          tsParseUnionOrIntersectionType(e2, s2, i2) {
            let r2 = this.startNode(), n2 = this.eat(i2), o2 = [];
            do
              o2.push(s2());
            while (this.eat(i2));
            return o2.length === 1 && !n2 ? o2[0] : (r2.types = o2, this.finishNode(r2, e2));
          }
          tsParseIntersectionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
          }
          tsParseUnionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
          }
          tsIsStartOfFunctionType() {
            return this.match(47) ? true : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
          }
          tsSkipParameterStart() {
            if (w2(this.state.type) || this.match(78))
              return this.next(), true;
            if (this.match(5)) {
              let { errors: e2 } = this.state, s2 = e2.length;
              try {
                return this.parseObjectLike(8, true), e2.length === s2;
              } catch {
                return false;
              }
            }
            if (this.match(0)) {
              this.next();
              let { errors: e2 } = this.state, s2 = e2.length;
              try {
                return super.parseBindingList(3, 93, 1), e2.length === s2;
              } catch {
                return false;
              }
            }
            return false;
          }
          tsIsUnambiguouslyStartOfFunctionType() {
            return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
          }
          tsParseTypeOrTypePredicateAnnotation(e2) {
            return this.tsInType(() => {
              let s2 = this.startNode();
              this.expect(e2);
              let i2 = this.startNode(), r2 = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
              if (r2 && this.match(78)) {
                let h2 = this.tsParseThisTypeOrThisTypePredicate();
                return h2.type === "TSThisType" ? (i2.parameterName = h2, i2.asserts = true, i2.typeAnnotation = null, h2 = this.finishNode(i2, "TSTypePredicate")) : (this.resetStartLocationFromNode(h2, i2), h2.asserts = true), s2.typeAnnotation = h2, this.finishNode(s2, "TSTypeAnnotation");
              }
              let n2 = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
              if (!n2)
                return r2 ? (i2.parameterName = this.parseIdentifier(), i2.asserts = r2, i2.typeAnnotation = null, s2.typeAnnotation = this.finishNode(i2, "TSTypePredicate"), this.finishNode(s2, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, s2);
              let o2 = this.tsParseTypeAnnotation(false);
              return i2.parameterName = n2, i2.typeAnnotation = o2, i2.asserts = r2, s2.typeAnnotation = this.finishNode(i2, "TSTypePredicate"), this.finishNode(s2, "TSTypeAnnotation");
            });
          }
          tsTryParseTypeOrTypePredicateAnnotation() {
            if (this.match(14))
              return this.tsParseTypeOrTypePredicateAnnotation(14);
          }
          tsTryParseTypeAnnotation() {
            if (this.match(14))
              return this.tsParseTypeAnnotation();
          }
          tsTryParseType() {
            return this.tsEatThenParseType(14);
          }
          tsParseTypePredicatePrefix() {
            let e2 = this.parseIdentifier();
            if (this.isContextual(116) && !this.hasPrecedingLineBreak())
              return this.next(), e2;
          }
          tsParseTypePredicateAsserts() {
            if (this.state.type !== 109)
              return false;
            let e2 = this.state.containsEsc;
            return this.next(), !w2(this.state.type) && !this.match(78) ? false : (e2 && this.raise(p2.InvalidEscapedReservedWord, this.state.lastTokStartLoc, { reservedWord: "asserts" }), true);
          }
          tsParseTypeAnnotation(e2 = true, s2 = this.startNode()) {
            return this.tsInType(() => {
              e2 && this.expect(14), s2.typeAnnotation = this.tsParseType();
            }), this.finishNode(s2, "TSTypeAnnotation");
          }
          tsParseType() {
            jt2(this.state.inType);
            let e2 = this.tsParseNonConditionalType();
            if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
              return e2;
            let s2 = this.startNodeAtNode(e2);
            return s2.checkType = e2, s2.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), s2.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), s2.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(s2, "TSConditionalType");
          }
          isAbstractConstructorSignature() {
            return this.isContextual(124) && this.lookahead().type === 77;
          }
          tsParseNonConditionalType() {
            return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
          }
          tsParseTypeAssertion() {
            this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(x2.ReservedTypeAssertion, this.state.startLoc);
            let e2 = this.startNode();
            return e2.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), e2.expression = this.parseMaybeUnary(), this.finishNode(e2, "TSTypeAssertion");
          }
          tsParseHeritageClause(e2) {
            let s2 = this.state.startLoc, i2 = this.tsParseDelimitedList("HeritageClauseElement", () => {
              let r2 = this.startNode();
              return r2.expression = this.tsParseEntityName(), this.match(47) && (r2.typeParameters = this.tsParseTypeArguments()), this.finishNode(r2, "TSExpressionWithTypeArguments");
            });
            return i2.length || this.raise(x2.EmptyHeritageClauseType, s2, { token: e2 }), i2;
          }
          tsParseInterfaceDeclaration(e2, s2 = {}) {
            if (this.hasFollowingLineBreak())
              return null;
            this.expectContextual(129), s2.declare && (e2.declare = true), w2(this.state.type) ? (e2.id = this.parseIdentifier(), this.checkIdentifier(e2.id, 130)) : (e2.id = null, this.raise(x2.MissingInterfaceName, this.state.startLoc)), e2.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (e2.extends = this.tsParseHeritageClause("extends"));
            let i2 = this.startNode();
            return i2.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), e2.body = this.finishNode(i2, "TSInterfaceBody"), this.finishNode(e2, "TSInterfaceDeclaration");
          }
          tsParseTypeAliasDeclaration(e2) {
            return e2.id = this.parseIdentifier(), this.checkIdentifier(e2.id, 2), e2.typeAnnotation = this.tsInType(() => {
              if (e2.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().type !== 16) {
                let s2 = this.startNode();
                return this.next(), this.finishNode(s2, "TSIntrinsicKeyword");
              }
              return this.tsParseType();
            }), this.semicolon(), this.finishNode(e2, "TSTypeAliasDeclaration");
          }
          tsInNoContext(e2) {
            let s2 = this.state.context;
            this.state.context = [s2[0]];
            try {
              return e2();
            } finally {
              this.state.context = s2;
            }
          }
          tsInType(e2) {
            let s2 = this.state.inType;
            this.state.inType = true;
            try {
              return e2();
            } finally {
              this.state.inType = s2;
            }
          }
          tsInDisallowConditionalTypesContext(e2) {
            let s2 = this.state.inDisallowConditionalTypesContext;
            this.state.inDisallowConditionalTypesContext = true;
            try {
              return e2();
            } finally {
              this.state.inDisallowConditionalTypesContext = s2;
            }
          }
          tsInAllowConditionalTypesContext(e2) {
            let s2 = this.state.inDisallowConditionalTypesContext;
            this.state.inDisallowConditionalTypesContext = false;
            try {
              return e2();
            } finally {
              this.state.inDisallowConditionalTypesContext = s2;
            }
          }
          tsEatThenParseType(e2) {
            if (this.match(e2))
              return this.tsNextThenParseType();
          }
          tsExpectThenParseType(e2) {
            return this.tsInType(() => (this.expect(e2), this.tsParseType()));
          }
          tsNextThenParseType() {
            return this.tsInType(() => (this.next(), this.tsParseType()));
          }
          tsParseEnumMember() {
            let e2 = this.startNode();
            return e2.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true), this.eat(29) && (e2.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(e2, "TSEnumMember");
          }
          tsParseEnumDeclaration(e2, s2 = {}) {
            return s2.const && (e2.const = true), s2.declare && (e2.declare = true), this.expectContextual(126), e2.id = this.parseIdentifier(), this.checkIdentifier(e2.id, e2.const ? 8971 : 8459), this.expect(5), e2.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(e2, "TSEnumDeclaration");
          }
          tsParseModuleBlock() {
            let e2 = this.startNode();
            return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(e2.body = [], void 0, true, 8), this.scope.exit(), this.finishNode(e2, "TSModuleBlock");
          }
          tsParseModuleOrNamespaceDeclaration(e2, s2 = false) {
            if (e2.id = this.parseIdentifier(), s2 || this.checkIdentifier(e2.id, 1024), this.eat(16)) {
              let i2 = this.startNode();
              this.tsParseModuleOrNamespaceDeclaration(i2, true), e2.body = i2;
            } else
              this.scope.enter(256), this.prodParam.enter(0), e2.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
            return this.finishNode(e2, "TSModuleDeclaration");
          }
          tsParseAmbientExternalModuleDeclaration(e2) {
            return this.isContextual(112) ? (e2.global = true, e2.id = this.parseIdentifier()) : this.match(133) ? e2.id = super.parseStringLiteral(this.state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), e2.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e2, "TSModuleDeclaration");
          }
          tsParseImportEqualsDeclaration(e2, s2, i2) {
            e2.isExport = i2 || false, e2.id = s2 || this.parseIdentifier(), this.checkIdentifier(e2.id, 4096), this.expect(29);
            let r2 = this.tsParseModuleReference();
            return e2.importKind === "type" && r2.type !== "TSExternalModuleReference" && this.raise(x2.ImportAliasHasImportType, r2), e2.moduleReference = r2, this.semicolon(), this.finishNode(e2, "TSImportEqualsDeclaration");
          }
          tsIsExternalModuleReference() {
            return this.isContextual(119) && this.lookaheadCharCode() === 40;
          }
          tsParseModuleReference() {
            return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
          }
          tsParseExternalModuleReference() {
            let e2 = this.startNode();
            return this.expectContextual(119), this.expect(10), this.match(133) || this.unexpected(), e2.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = true, this.finishNode(e2, "TSExternalModuleReference");
          }
          tsLookAhead(e2) {
            let s2 = this.state.clone(), i2 = e2();
            return this.state = s2, i2;
          }
          tsTryParseAndCatch(e2) {
            let s2 = this.tryParse((i2) => e2() || i2());
            if (!(s2.aborted || !s2.node))
              return s2.error && (this.state = s2.failState), s2.node;
          }
          tsTryParse(e2) {
            let s2 = this.state.clone(), i2 = e2();
            if (i2 !== void 0 && i2 !== false)
              return i2;
            this.state = s2;
          }
          tsTryParseDeclare(e2) {
            if (this.isLineTerminator())
              return;
            let s2 = this.state.type, i2;
            return this.isContextual(100) && (s2 = 74, i2 = "let"), this.tsInAmbientContext(() => {
              switch (s2) {
                case 68:
                  return e2.declare = true, super.parseFunctionStatement(e2, false, false);
                case 80:
                  return e2.declare = true, this.parseClass(e2, true, false);
                case 126:
                  return this.tsParseEnumDeclaration(e2, { declare: true });
                case 112:
                  return this.tsParseAmbientExternalModuleDeclaration(e2);
                case 75:
                case 74:
                  return !this.match(75) || !this.isLookaheadContextual("enum") ? (e2.declare = true, this.parseVarStatement(e2, i2 || this.state.value, true)) : (this.expect(75), this.tsParseEnumDeclaration(e2, { const: true, declare: true }));
                case 129: {
                  let r2 = this.tsParseInterfaceDeclaration(e2, { declare: true });
                  if (r2)
                    return r2;
                }
                default:
                  if (w2(s2))
                    return this.tsParseDeclaration(e2, this.state.value, true, null);
              }
            });
          }
          tsTryParseExportDeclaration() {
            return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
          }
          tsParseExpressionStatement(e2, s2, i2) {
            switch (s2.name) {
              case "declare": {
                let r2 = this.tsTryParseDeclare(e2);
                return r2 && (r2.declare = true), r2;
              }
              case "global":
                if (this.match(5)) {
                  this.scope.enter(256), this.prodParam.enter(0);
                  let r2 = e2;
                  return r2.global = true, r2.id = s2, r2.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(r2, "TSModuleDeclaration");
                }
                break;
              default:
                return this.tsParseDeclaration(e2, s2.name, false, i2);
            }
          }
          tsParseDeclaration(e2, s2, i2, r2) {
            switch (s2) {
              case "abstract":
                if (this.tsCheckLineTerminator(i2) && (this.match(80) || w2(this.state.type)))
                  return this.tsParseAbstractDeclaration(e2, r2);
                break;
              case "module":
                if (this.tsCheckLineTerminator(i2)) {
                  if (this.match(133))
                    return this.tsParseAmbientExternalModuleDeclaration(e2);
                  if (w2(this.state.type))
                    return this.tsParseModuleOrNamespaceDeclaration(e2);
                }
                break;
              case "namespace":
                if (this.tsCheckLineTerminator(i2) && w2(this.state.type))
                  return this.tsParseModuleOrNamespaceDeclaration(e2);
                break;
              case "type":
                if (this.tsCheckLineTerminator(i2) && w2(this.state.type))
                  return this.tsParseTypeAliasDeclaration(e2);
                break;
            }
          }
          tsCheckLineTerminator(e2) {
            return e2 ? this.hasFollowingLineBreak() ? false : (this.next(), true) : !this.isLineTerminator();
          }
          tsTryParseGenericAsyncArrowFunction(e2) {
            if (!this.match(47))
              return;
            let s2 = this.state.maybeInArrowParameters;
            this.state.maybeInArrowParameters = true;
            let i2 = this.tsTryParseAndCatch(() => {
              let r2 = this.startNodeAt(e2);
              return r2.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(r2), r2.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), r2;
            });
            if (this.state.maybeInArrowParameters = s2, !!i2)
              return super.parseArrowExpression(i2, null, true);
          }
          tsParseTypeArgumentsInExpression() {
            if (this.reScan_lt() === 47)
              return this.tsParseTypeArguments();
          }
          tsParseTypeArguments() {
            let e2 = this.startNode();
            return e2.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), e2.params.length === 0 ? this.raise(x2.EmptyTypeArguments, e2) : !this.state.inType && this.curContext() === C.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(e2, "TSTypeParameterInstantiation");
          }
          tsIsDeclarationStart() {
            return mi(this.state.type);
          }
          isExportDefaultSpecifier() {
            return this.tsIsDeclarationStart() ? false : super.isExportDefaultSpecifier();
          }
          parseAssignableListItem(e2, s2) {
            let i2 = this.state.startLoc, r2 = {};
            this.tsParseModifiers({ allowedModifiers: ["public", "private", "protected", "override", "readonly"] }, r2);
            let n2 = r2.accessibility, o2 = r2.override, h2 = r2.readonly;
            !(e2 & 4) && (n2 || h2 || o2) && this.raise(x2.UnexpectedParameterModifier, i2);
            let c2 = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(c2, e2);
            let l2 = this.parseMaybeDefault(c2.loc.start, c2);
            if (n2 || h2 || o2) {
              let u2 = this.startNodeAt(i2);
              return s2.length && (u2.decorators = s2), n2 && (u2.accessibility = n2), h2 && (u2.readonly = h2), o2 && (u2.override = o2), l2.type !== "Identifier" && l2.type !== "AssignmentPattern" && this.raise(x2.UnsupportedParameterPropertyKind, u2), u2.parameter = l2, this.finishNode(u2, "TSParameterProperty");
            }
            return s2.length && (c2.decorators = s2), l2;
          }
          isSimpleParameter(e2) {
            return e2.type === "TSParameterProperty" && super.isSimpleParameter(e2.parameter) || super.isSimpleParameter(e2);
          }
          tsDisallowOptionalPattern(e2) {
            for (let s2 of e2.params)
              s2.type !== "Identifier" && s2.optional && !this.state.isAmbientContext && this.raise(x2.PatternIsOptional, s2);
          }
          setArrowFunctionParameters(e2, s2, i2) {
            super.setArrowFunctionParameters(e2, s2, i2), this.tsDisallowOptionalPattern(e2);
          }
          parseFunctionBodyAndFinish(e2, s2, i2 = false) {
            this.match(14) && (e2.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
            let r2 = s2 === "FunctionDeclaration" ? "TSDeclareFunction" : s2 === "ClassMethod" || s2 === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
            return r2 && !this.match(5) && this.isLineTerminator() ? this.finishNode(e2, r2) : r2 === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(x2.DeclareFunctionHasImplementation, e2), e2.declare) ? super.parseFunctionBodyAndFinish(e2, r2, i2) : (this.tsDisallowOptionalPattern(e2), super.parseFunctionBodyAndFinish(e2, s2, i2));
          }
          registerFunctionStatementId(e2) {
            !e2.body && e2.id ? this.checkIdentifier(e2.id, 1024) : super.registerFunctionStatementId(e2);
          }
          tsCheckForInvalidTypeCasts(e2) {
            e2.forEach((s2) => {
              (s2 == null ? void 0 : s2.type) === "TSTypeCastExpression" && this.raise(x2.UnexpectedTypeAnnotation, s2.typeAnnotation);
            });
          }
          toReferencedList(e2, s2) {
            return this.tsCheckForInvalidTypeCasts(e2), e2;
          }
          parseArrayLike(e2, s2, i2, r2) {
            let n2 = super.parseArrayLike(e2, s2, i2, r2);
            return n2.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(n2.elements), n2;
          }
          parseSubscript(e2, s2, i2, r2) {
            if (!this.hasPrecedingLineBreak() && this.match(35)) {
              this.state.canStartJSXElement = false, this.next();
              let o2 = this.startNodeAt(s2);
              return o2.expression = e2, this.finishNode(o2, "TSNonNullExpression");
            }
            let n2 = false;
            if (this.match(18) && this.lookaheadCharCode() === 60) {
              if (i2)
                return r2.stop = true, e2;
              r2.optionalChainMember = n2 = true, this.next();
            }
            if (this.match(47) || this.match(51)) {
              let o2, h2 = this.tsTryParseAndCatch(() => {
                if (!i2 && this.atPossibleAsyncArrow(e2)) {
                  let f2 = this.tsTryParseGenericAsyncArrowFunction(s2);
                  if (f2)
                    return f2;
                }
                let c2 = this.tsParseTypeArgumentsInExpression();
                if (!c2)
                  return;
                if (n2 && !this.match(10)) {
                  o2 = this.state.curPosition();
                  return;
                }
                if (Le3(this.state.type)) {
                  let f2 = super.parseTaggedTemplateExpression(e2, s2, r2);
                  return f2.typeParameters = c2, f2;
                }
                if (!i2 && this.eat(10)) {
                  let f2 = this.startNodeAt(s2);
                  return f2.callee = e2, f2.arguments = this.parseCallExpressionArguments(11, false), this.tsCheckForInvalidTypeCasts(f2.arguments), f2.typeParameters = c2, r2.optionalChainMember && (f2.optional = n2), this.finishCallExpression(f2, r2.optionalChainMember);
                }
                let l2 = this.state.type;
                if (l2 === 48 || l2 === 52 || l2 !== 10 && He2(l2) && !this.hasPrecedingLineBreak())
                  return;
                let u2 = this.startNodeAt(s2);
                return u2.expression = e2, u2.typeParameters = c2, this.finishNode(u2, "TSInstantiationExpression");
              });
              if (o2 && this.unexpected(o2, 10), h2)
                return h2.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(x2.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), h2;
            }
            return super.parseSubscript(e2, s2, i2, r2);
          }
          parseNewCallee(e2) {
            var s2;
            super.parseNewCallee(e2);
            let { callee: i2 } = e2;
            i2.type === "TSInstantiationExpression" && !((s2 = i2.extra) != null && s2.parenthesized) && (e2.typeParameters = i2.typeParameters, e2.callee = i2.expression);
          }
          parseExprOp(e2, s2, i2) {
            let r2;
            if (Ie3(58) > i2 && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (r2 = this.isContextual(120)))) {
              let n2 = this.startNodeAt(s2);
              return n2.expression = e2, n2.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (r2 && this.raise(p2.UnexpectedKeyword, this.state.startLoc, { keyword: "const" }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(n2, r2 ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(n2, s2, i2);
            }
            return super.parseExprOp(e2, s2, i2);
          }
          checkReservedWord(e2, s2, i2, r2) {
            this.state.isAmbientContext || super.checkReservedWord(e2, s2, i2, r2);
          }
          checkImportReflection(e2) {
            super.checkImportReflection(e2), e2.module && e2.importKind !== "value" && this.raise(x2.ImportReflectionHasImportType, e2.specifiers[0].loc.start);
          }
          checkDuplicateExports() {
          }
          isPotentialImportPhase(e2) {
            if (super.isPotentialImportPhase(e2))
              return true;
            if (this.isContextual(130)) {
              let s2 = this.lookaheadCharCode();
              return e2 ? s2 === 123 || s2 === 42 : s2 !== 61;
            }
            return !e2 && this.isContextual(87);
          }
          applyImportPhase(e2, s2, i2, r2) {
            super.applyImportPhase(e2, s2, i2, r2), s2 ? e2.exportKind = i2 === "type" ? "type" : "value" : e2.importKind = i2 === "type" || i2 === "typeof" ? i2 : "value";
          }
          parseImport(e2) {
            if (this.match(133))
              return e2.importKind = "value", super.parseImport(e2);
            let s2;
            if (w2(this.state.type) && this.lookaheadCharCode() === 61)
              return e2.importKind = "value", this.tsParseImportEqualsDeclaration(e2);
            if (this.isContextual(130)) {
              let i2 = this.parseMaybeImportPhase(e2, false);
              if (this.lookaheadCharCode() === 61)
                return this.tsParseImportEqualsDeclaration(e2, i2);
              s2 = super.parseImportSpecifiersAndAfter(e2, i2);
            } else
              s2 = super.parseImport(e2);
            return s2.importKind === "type" && s2.specifiers.length > 1 && s2.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(x2.TypeImportCannotSpecifyDefaultAndNamed, s2), s2;
          }
          parseExport(e2, s2) {
            if (this.match(83)) {
              this.next();
              let i2 = e2, r2 = null;
              return this.isContextual(130) && this.isPotentialImportPhase(false) ? r2 = this.parseMaybeImportPhase(i2, false) : i2.importKind = "value", this.tsParseImportEqualsDeclaration(i2, r2, true);
            } else if (this.eat(29)) {
              let i2 = e2;
              return i2.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = true, this.finishNode(i2, "TSExportAssignment");
            } else if (this.eatContextual(93)) {
              let i2 = e2;
              return this.expectContextual(128), i2.id = this.parseIdentifier(), this.semicolon(), this.finishNode(i2, "TSNamespaceExportDeclaration");
            } else
              return super.parseExport(e2, s2);
          }
          isAbstractClass() {
            return this.isContextual(124) && this.lookahead().type === 80;
          }
          parseExportDefaultExpression() {
            if (this.isAbstractClass()) {
              let e2 = this.startNode();
              return this.next(), e2.abstract = true, this.parseClass(e2, true, true);
            }
            if (this.match(129)) {
              let e2 = this.tsParseInterfaceDeclaration(this.startNode());
              if (e2)
                return e2;
            }
            return super.parseExportDefaultExpression();
          }
          parseVarStatement(e2, s2, i2 = false) {
            let { isAmbientContext: r2 } = this.state, n2 = super.parseVarStatement(e2, s2, i2 || r2);
            if (!r2)
              return n2;
            for (let { id: o2, init: h2 } of n2.declarations)
              h2 && (s2 !== "const" || o2.typeAnnotation ? this.raise(x2.InitializerNotAllowedInAmbientContext, h2) : Qi2(h2, this.hasPlugin("estree")) || this.raise(x2.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, h2));
            return n2;
          }
          parseStatementContent(e2, s2) {
            if (this.match(75) && this.isLookaheadContextual("enum")) {
              let i2 = this.startNode();
              return this.expect(75), this.tsParseEnumDeclaration(i2, { const: true });
            }
            if (this.isContextual(126))
              return this.tsParseEnumDeclaration(this.startNode());
            if (this.isContextual(129)) {
              let i2 = this.tsParseInterfaceDeclaration(this.startNode());
              if (i2)
                return i2;
            }
            return super.parseStatementContent(e2, s2);
          }
          parseAccessModifier() {
            return this.tsParseModifier(["public", "protected", "private"]);
          }
          tsHasSomeModifiers(e2, s2) {
            return s2.some((i2) => $t2(i2) ? e2.accessibility === i2 : !!e2[i2]);
          }
          tsIsStartOfStaticBlocks() {
            return this.isContextual(106) && this.lookaheadCharCode() === 123;
          }
          parseClassMember(e2, s2, i2) {
            let r2 = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
            this.tsParseModifiers({ allowedModifiers: r2, disallowedModifiers: ["in", "out"], stopOnStartOfClassStaticBlock: true, errorTemplate: x2.InvalidModifierOnTypeParameterPositions }, s2);
            let n2 = () => {
              this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(s2, r2) && this.raise(x2.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(e2, s2)) : this.parseClassMemberWithIsStatic(e2, s2, i2, !!s2.static);
            };
            s2.declare ? this.tsInAmbientContext(n2) : n2();
          }
          parseClassMemberWithIsStatic(e2, s2, i2, r2) {
            let n2 = this.tsTryParseIndexSignature(s2);
            if (n2) {
              e2.body.push(n2), s2.abstract && this.raise(x2.IndexSignatureHasAbstract, s2), s2.accessibility && this.raise(x2.IndexSignatureHasAccessibility, s2, { modifier: s2.accessibility }), s2.declare && this.raise(x2.IndexSignatureHasDeclare, s2), s2.override && this.raise(x2.IndexSignatureHasOverride, s2);
              return;
            }
            !this.state.inAbstractClass && s2.abstract && this.raise(x2.NonAbstractClassHasAbstractMethod, s2), s2.override && (i2.hadSuperClass || this.raise(x2.OverrideNotInSubClass, s2)), super.parseClassMemberWithIsStatic(e2, s2, i2, r2);
          }
          parsePostMemberNameModifiers(e2) {
            this.eat(17) && (e2.optional = true), e2.readonly && this.match(10) && this.raise(x2.ClassMethodHasReadonly, e2), e2.declare && this.match(10) && this.raise(x2.ClassMethodHasDeclare, e2);
          }
          parseExpressionStatement(e2, s2, i2) {
            return (s2.type === "Identifier" ? this.tsParseExpressionStatement(e2, s2, i2) : void 0) || super.parseExpressionStatement(e2, s2, i2);
          }
          shouldParseExportDeclaration() {
            return this.tsIsDeclarationStart() ? true : super.shouldParseExportDeclaration();
          }
          parseConditional(e2, s2, i2) {
            if (!this.state.maybeInArrowParameters || !this.match(17))
              return super.parseConditional(e2, s2, i2);
            let r2 = this.tryParse(() => super.parseConditional(e2, s2));
            return r2.node ? (r2.error && (this.state = r2.failState), r2.node) : (r2.error && super.setOptionalParametersError(i2, r2.error), e2);
          }
          parseParenItem(e2, s2) {
            let i2 = super.parseParenItem(e2, s2);
            if (this.eat(17) && (i2.optional = true, this.resetEndLocation(e2)), this.match(14)) {
              let r2 = this.startNodeAt(s2);
              return r2.expression = e2, r2.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(r2, "TSTypeCastExpression");
            }
            return e2;
          }
          parseExportDeclaration(e2) {
            if (!this.state.isAmbientContext && this.isContextual(125))
              return this.tsInAmbientContext(() => this.parseExportDeclaration(e2));
            let s2 = this.state.startLoc, i2 = this.eatContextual(125);
            if (i2 && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
              throw this.raise(x2.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
            let n2 = w2(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(e2);
            return n2 ? ((n2.type === "TSInterfaceDeclaration" || n2.type === "TSTypeAliasDeclaration" || i2) && (e2.exportKind = "type"), i2 && (this.resetStartLocation(n2, s2), n2.declare = true), n2) : null;
          }
          parseClassId(e2, s2, i2, r2) {
            if ((!s2 || i2) && this.isContextual(113))
              return;
            super.parseClassId(e2, s2, i2, e2.declare ? 1024 : 8331);
            let n2 = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
            n2 && (e2.typeParameters = n2);
          }
          parseClassPropertyAnnotation(e2) {
            e2.optional || (this.eat(35) ? e2.definite = true : this.eat(17) && (e2.optional = true));
            let s2 = this.tsTryParseTypeAnnotation();
            s2 && (e2.typeAnnotation = s2);
          }
          parseClassProperty(e2) {
            if (this.parseClassPropertyAnnotation(e2), this.state.isAmbientContext && !(e2.readonly && !e2.typeAnnotation) && this.match(29) && this.raise(x2.DeclareClassFieldHasInitializer, this.state.startLoc), e2.abstract && this.match(29)) {
              let { key: s2 } = e2;
              this.raise(x2.AbstractPropertyHasInitializer, this.state.startLoc, { propertyName: s2.type === "Identifier" && !e2.computed ? s2.name : `[${this.input.slice(s2.start, s2.end)}]` });
            }
            return super.parseClassProperty(e2);
          }
          parseClassPrivateProperty(e2) {
            return e2.abstract && this.raise(x2.PrivateElementHasAbstract, e2), e2.accessibility && this.raise(x2.PrivateElementHasAccessibility, e2, { modifier: e2.accessibility }), this.parseClassPropertyAnnotation(e2), super.parseClassPrivateProperty(e2);
          }
          parseClassAccessorProperty(e2) {
            return this.parseClassPropertyAnnotation(e2), e2.optional && this.raise(x2.AccessorCannotBeOptional, e2), super.parseClassAccessorProperty(e2);
          }
          pushClassMethod(e2, s2, i2, r2, n2, o2) {
            let h2 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            h2 && n2 && this.raise(x2.ConstructorHasTypeParameters, h2);
            let { declare: c2 = false, kind: l2 } = s2;
            c2 && (l2 === "get" || l2 === "set") && this.raise(x2.DeclareAccessor, s2, { kind: l2 }), h2 && (s2.typeParameters = h2), super.pushClassMethod(e2, s2, i2, r2, n2, o2);
          }
          pushClassPrivateMethod(e2, s2, i2, r2) {
            let n2 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            n2 && (s2.typeParameters = n2), super.pushClassPrivateMethod(e2, s2, i2, r2);
          }
          declareClassPrivateMethodInScope(e2, s2) {
            e2.type !== "TSDeclareMethod" && (e2.type === "MethodDefinition" && !hasOwnProperty.call(e2.value, "body") || super.declareClassPrivateMethodInScope(e2, s2));
          }
          parseClassSuper(e2) {
            super.parseClassSuper(e2), e2.superClass && (this.match(47) || this.match(51)) && (e2.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (e2.implements = this.tsParseHeritageClause("implements"));
          }
          parseObjPropValue(e2, s2, i2, r2, n2, o2, h2) {
            let c2 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            return c2 && (e2.typeParameters = c2), super.parseObjPropValue(e2, s2, i2, r2, n2, o2, h2);
          }
          parseFunctionParams(e2, s2) {
            let i2 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            i2 && (e2.typeParameters = i2), super.parseFunctionParams(e2, s2);
          }
          parseVarId(e2, s2) {
            super.parseVarId(e2, s2), e2.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (e2.definite = true);
            let i2 = this.tsTryParseTypeAnnotation();
            i2 && (e2.id.typeAnnotation = i2, this.resetEndLocation(e2.id));
          }
          parseAsyncArrowFromCallExpression(e2, s2) {
            return this.match(14) && (e2.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e2, s2);
          }
          parseMaybeAssign(e2, s2) {
            var i2, r2, n2, o2, h2;
            let c2, l2, u2;
            if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
              if (c2 = this.state.clone(), l2 = this.tryParse(() => super.parseMaybeAssign(e2, s2), c2), !l2.error)
                return l2.node;
              let { context: y3 } = this.state, E2 = y3[y3.length - 1];
              (E2 === C.j_oTag || E2 === C.j_expr) && y3.pop();
            }
            if (!((i2 = l2) != null && i2.error) && !this.match(47))
              return super.parseMaybeAssign(e2, s2);
            (!c2 || c2 === this.state) && (c2 = this.state.clone());
            let f2, d2 = this.tryParse((y3) => {
              var E2, L3;
              f2 = this.tsParseTypeParameters(this.tsParseConstModifier);
              let S3 = super.parseMaybeAssign(e2, s2);
              return (S3.type !== "ArrowFunctionExpression" || (E2 = S3.extra) != null && E2.parenthesized) && y3(), ((L3 = f2) == null ? void 0 : L3.params.length) !== 0 && this.resetStartLocationFromNode(S3, f2), S3.typeParameters = f2, S3;
            }, c2);
            if (!d2.error && !d2.aborted)
              return f2 && this.reportReservedArrowTypeParam(f2), d2.node;
            if (!l2 && (jt2(!this.hasPlugin("jsx")), u2 = this.tryParse(() => super.parseMaybeAssign(e2, s2), c2), !u2.error))
              return u2.node;
            if ((r2 = l2) != null && r2.node)
              return this.state = l2.failState, l2.node;
            if (d2.node)
              return this.state = d2.failState, f2 && this.reportReservedArrowTypeParam(f2), d2.node;
            if ((n2 = u2) != null && n2.node)
              return this.state = u2.failState, u2.node;
            throw ((o2 = l2) == null ? void 0 : o2.error) || d2.error || ((h2 = u2) == null ? void 0 : h2.error);
          }
          reportReservedArrowTypeParam(e2) {
            var s2;
            e2.params.length === 1 && !e2.params[0].constraint && !((s2 = e2.extra) != null && s2.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(x2.ReservedArrowTypeParam, e2);
          }
          parseMaybeUnary(e2, s2) {
            return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e2, s2);
          }
          parseArrow(e2) {
            if (this.match(14)) {
              let s2 = this.tryParse((i2) => {
                let r2 = this.tsParseTypeOrTypePredicateAnnotation(14);
                return (this.canInsertSemicolon() || !this.match(19)) && i2(), r2;
              });
              if (s2.aborted)
                return;
              s2.thrown || (s2.error && (this.state = s2.failState), e2.returnType = s2.node);
            }
            return super.parseArrow(e2);
          }
          parseAssignableListItemTypes(e2, s2) {
            if (!(s2 & 2))
              return e2;
            this.eat(17) && (e2.optional = true);
            let i2 = this.tsTryParseTypeAnnotation();
            return i2 && (e2.typeAnnotation = i2), this.resetEndLocation(e2), e2;
          }
          isAssignable(e2, s2) {
            switch (e2.type) {
              case "TSTypeCastExpression":
                return this.isAssignable(e2.expression, s2);
              case "TSParameterProperty":
                return true;
              default:
                return super.isAssignable(e2, s2);
            }
          }
          toAssignable(e2, s2 = false) {
            switch (e2.type) {
              case "ParenthesizedExpression":
                this.toAssignableParenthesizedExpression(e2, s2);
                break;
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSNonNullExpression":
              case "TSTypeAssertion":
                s2 ? this.expressionScope.recordArrowParameterBindingError(x2.UnexpectedTypeCastInParameter, e2) : this.raise(x2.UnexpectedTypeCastInParameter, e2), this.toAssignable(e2.expression, s2);
                break;
              case "AssignmentExpression":
                !s2 && e2.left.type === "TSTypeCastExpression" && (e2.left = this.typeCastToParameter(e2.left));
              default:
                super.toAssignable(e2, s2);
            }
          }
          toAssignableParenthesizedExpression(e2, s2) {
            switch (e2.expression.type) {
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSNonNullExpression":
              case "TSTypeAssertion":
              case "ParenthesizedExpression":
                this.toAssignable(e2.expression, s2);
                break;
              default:
                super.toAssignable(e2, s2);
            }
          }
          checkToRestConversion(e2, s2) {
            switch (e2.type) {
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSTypeAssertion":
              case "TSNonNullExpression":
                this.checkToRestConversion(e2.expression, false);
                break;
              default:
                super.checkToRestConversion(e2, s2);
            }
          }
          isValidLVal(e2, s2, i2) {
            return Hi({ TSTypeCastExpression: true, TSParameterProperty: "parameter", TSNonNullExpression: "expression", TSInstantiationExpression: "expression", TSAsExpression: (i2 !== 64 || !s2) && ["expression", true], TSSatisfiesExpression: (i2 !== 64 || !s2) && ["expression", true], TSTypeAssertion: (i2 !== 64 || !s2) && ["expression", true] }, e2) || super.isValidLVal(e2, s2, i2);
          }
          parseBindingAtom() {
            return this.state.type === 78 ? this.parseIdentifier(true) : super.parseBindingAtom();
          }
          parseMaybeDecoratorArguments(e2) {
            if (this.match(47) || this.match(51)) {
              let s2 = this.tsParseTypeArgumentsInExpression();
              if (this.match(10)) {
                let i2 = super.parseMaybeDecoratorArguments(e2);
                return i2.typeParameters = s2, i2;
              }
              this.unexpected(null, 10);
            }
            return super.parseMaybeDecoratorArguments(e2);
          }
          checkCommaAfterRest(e2) {
            return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e2 ? (this.next(), false) : super.checkCommaAfterRest(e2);
          }
          isClassMethod() {
            return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(35) || this.match(14) || super.isClassProperty();
          }
          parseMaybeDefault(e2, s2) {
            let i2 = super.parseMaybeDefault(e2, s2);
            return i2.type === "AssignmentPattern" && i2.typeAnnotation && i2.right.start < i2.typeAnnotation.start && this.raise(x2.TypeAnnotationAfterAssign, i2.typeAnnotation), i2;
          }
          getTokenFromCode(e2) {
            if (this.state.inType) {
              if (e2 === 62) {
                this.finishOp(48, 1);
                return;
              }
              if (e2 === 60) {
                this.finishOp(47, 1);
                return;
              }
            }
            super.getTokenFromCode(e2);
          }
          reScan_lt_gt() {
            let { type: e2 } = this.state;
            e2 === 47 ? (this.state.pos -= 1, this.readToken_lt()) : e2 === 48 && (this.state.pos -= 1, this.readToken_gt());
          }
          reScan_lt() {
            let { type: e2 } = this.state;
            return e2 === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : e2;
          }
          toAssignableList(e2, s2, i2) {
            for (let r2 = 0; r2 < e2.length; r2++) {
              let n2 = e2[r2];
              (n2 == null ? void 0 : n2.type) === "TSTypeCastExpression" && (e2[r2] = this.typeCastToParameter(n2));
            }
            super.toAssignableList(e2, s2, i2);
          }
          typeCastToParameter(e2) {
            return e2.expression.typeAnnotation = e2.typeAnnotation, this.resetEndLocation(e2.expression, e2.typeAnnotation.loc.end), e2.expression;
          }
          shouldParseArrow(e2) {
            return this.match(14) ? e2.every((s2) => this.isAssignable(s2, true)) : super.shouldParseArrow(e2);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          canHaveLeadingDecorator() {
            return super.canHaveLeadingDecorator() || this.isAbstractClass();
          }
          jsxParseOpeningElementAfterName(e2) {
            if (this.match(47) || this.match(51)) {
              let s2 = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
              s2 && (e2.typeParameters = s2);
            }
            return super.jsxParseOpeningElementAfterName(e2);
          }
          getGetterSetterExpectedParamCount(e2) {
            let s2 = super.getGetterSetterExpectedParamCount(e2), r2 = this.getObjectOrClassMethodParams(e2)[0];
            return r2 && this.isThisParam(r2) ? s2 + 1 : s2;
          }
          parseCatchClauseParam() {
            let e2 = super.parseCatchClauseParam(), s2 = this.tsTryParseTypeAnnotation();
            return s2 && (e2.typeAnnotation = s2, this.resetEndLocation(e2)), e2;
          }
          tsInAmbientContext(e2) {
            let { isAmbientContext: s2, strict: i2 } = this.state;
            this.state.isAmbientContext = true, this.state.strict = false;
            try {
              return e2();
            } finally {
              this.state.isAmbientContext = s2, this.state.strict = i2;
            }
          }
          parseClass(e2, s2, i2) {
            let r2 = this.state.inAbstractClass;
            this.state.inAbstractClass = !!e2.abstract;
            try {
              return super.parseClass(e2, s2, i2);
            } finally {
              this.state.inAbstractClass = r2;
            }
          }
          tsParseAbstractDeclaration(e2, s2) {
            if (this.match(80))
              return e2.abstract = true, this.maybeTakeDecorators(s2, this.parseClass(e2, true, false));
            if (this.isContextual(129)) {
              if (!this.hasFollowingLineBreak())
                return e2.abstract = true, this.raise(x2.NonClassMethodPropertyHasAbstractModifer, e2), this.tsParseInterfaceDeclaration(e2);
            } else
              this.unexpected(null, 80);
          }
          parseMethod(e2, s2, i2, r2, n2, o2, h2) {
            let c2 = super.parseMethod(e2, s2, i2, r2, n2, o2, h2);
            if (c2.abstract && (this.hasPlugin("estree") ? !!c2.value.body : !!c2.body)) {
              let { key: u2 } = c2;
              this.raise(x2.AbstractMethodHasImplementation, c2, { methodName: u2.type === "Identifier" && !c2.computed ? u2.name : `[${this.input.slice(u2.start, u2.end)}]` });
            }
            return c2;
          }
          tsParseTypeParameterName() {
            return this.parseIdentifier().name;
          }
          shouldParseAsAmbientContext() {
            return !!this.getPluginOption("typescript", "dts");
          }
          parse() {
            return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
          }
          getExpression() {
            return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
          }
          parseExportSpecifier(e2, s2, i2, r2) {
            return !s2 && r2 ? (this.parseTypeOnlyImportExportSpecifier(e2, false, i2), this.finishNode(e2, "ExportSpecifier")) : (e2.exportKind = "value", super.parseExportSpecifier(e2, s2, i2, r2));
          }
          parseImportSpecifier(e2, s2, i2, r2, n2) {
            return !s2 && r2 ? (this.parseTypeOnlyImportExportSpecifier(e2, true, i2), this.finishNode(e2, "ImportSpecifier")) : (e2.importKind = "value", super.parseImportSpecifier(e2, s2, i2, r2, i2 ? 4098 : 4096));
          }
          parseTypeOnlyImportExportSpecifier(e2, s2, i2) {
            let r2 = s2 ? "imported" : "local", n2 = s2 ? "local" : "exported", o2 = e2[r2], h2, c2 = false, l2 = true, u2 = o2.loc.start;
            if (this.isContextual(93)) {
              let d2 = this.parseIdentifier();
              if (this.isContextual(93)) {
                let y3 = this.parseIdentifier();
                M3(this.state.type) ? (c2 = true, o2 = d2, h2 = s2 ? this.parseIdentifier() : this.parseModuleExportName(), l2 = false) : (h2 = y3, l2 = false);
              } else
                M3(this.state.type) ? (l2 = false, h2 = s2 ? this.parseIdentifier() : this.parseModuleExportName()) : (c2 = true, o2 = d2);
            } else
              M3(this.state.type) && (c2 = true, s2 ? (o2 = this.parseIdentifier(true), this.isContextual(93) || this.checkReservedWord(o2.name, o2.loc.start, true, true)) : o2 = this.parseModuleExportName());
            c2 && i2 && this.raise(s2 ? x2.TypeModifierIsUsedInTypeImports : x2.TypeModifierIsUsedInTypeExports, u2), e2[r2] = o2, e2[n2] = h2;
            let f2 = s2 ? "importKind" : "exportKind";
            e2[f2] = c2 ? "type" : "value", l2 && this.eatContextual(93) && (e2[n2] = s2 ? this.parseIdentifier() : this.parseModuleExportName()), e2[n2] || (e2[n2] = $2(e2[r2])), s2 && this.checkIdentifier(e2[n2], c2 ? 4098 : 4096);
          }
        };
        function Yi2(a2) {
          if (a2.type !== "MemberExpression")
            return false;
          let { computed: t2, property: e2 } = a2;
          return t2 && e2.type !== "StringLiteral" && (e2.type !== "TemplateLiteral" || e2.expressions.length > 0) ? false : os(a2.object);
        }
        function Qi2(a2, t2) {
          var e2;
          let { type: s2 } = a2;
          if ((e2 = a2.extra) != null && e2.parenthesized)
            return false;
          if (t2) {
            if (s2 === "Literal") {
              let { value: i2 } = a2;
              if (typeof i2 == "string" || typeof i2 == "boolean")
                return true;
            }
          } else if (s2 === "StringLiteral" || s2 === "BooleanLiteral")
            return true;
          return !!(ns(a2, t2) || Zi(a2, t2) || s2 === "TemplateLiteral" && a2.expressions.length === 0 || Yi2(a2));
        }
        function ns(a2, t2) {
          return t2 ? a2.type === "Literal" && (typeof a2.value == "number" || "bigint" in a2) : a2.type === "NumericLiteral" || a2.type === "BigIntLiteral";
        }
        function Zi(a2, t2) {
          if (a2.type === "UnaryExpression") {
            let { operator: e2, argument: s2 } = a2;
            if (e2 === "-" && ns(s2, t2))
              return true;
          }
          return false;
        }
        function os(a2) {
          return a2.type === "Identifier" ? true : a2.type !== "MemberExpression" || a2.computed ? false : os(a2.object);
        }
        var Vt2 = j2`placeholders`({ ClassNameIsRequired: "A class name is required.", UnexpectedSpace: "Unexpected space in placeholder." }), er2 = (a2) => class extends a2 {
          parsePlaceholder(e2) {
            if (this.match(144)) {
              let s2 = this.startNode();
              return this.next(), this.assertNoSpace(), s2.name = super.parseIdentifier(true), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(s2, e2);
            }
          }
          finishPlaceholder(e2, s2) {
            let i2 = e2;
            return (!i2.expectedNode || !i2.type) && (i2 = this.finishNode(i2, "Placeholder")), i2.expectedNode = s2, i2;
          }
          getTokenFromCode(e2) {
            e2 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(144, 2) : super.getTokenFromCode(e2);
          }
          parseExprAtom(e2) {
            return this.parsePlaceholder("Expression") || super.parseExprAtom(e2);
          }
          parseIdentifier(e2) {
            return this.parsePlaceholder("Identifier") || super.parseIdentifier(e2);
          }
          checkReservedWord(e2, s2, i2, r2) {
            e2 !== void 0 && super.checkReservedWord(e2, s2, i2, r2);
          }
          parseBindingAtom() {
            return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
          }
          isValidLVal(e2, s2, i2) {
            return e2 === "Placeholder" || super.isValidLVal(e2, s2, i2);
          }
          toAssignable(e2, s2) {
            e2 && e2.type === "Placeholder" && e2.expectedNode === "Expression" ? e2.expectedNode = "Pattern" : super.toAssignable(e2, s2);
          }
          chStartsBindingIdentifier(e2, s2) {
            return !!(super.chStartsBindingIdentifier(e2, s2) || this.lookahead().type === 144);
          }
          verifyBreakContinue(e2, s2) {
            e2.label && e2.label.type === "Placeholder" || super.verifyBreakContinue(e2, s2);
          }
          parseExpressionStatement(e2, s2) {
            var i2;
            if (s2.type !== "Placeholder" || (i2 = s2.extra) != null && i2.parenthesized)
              return super.parseExpressionStatement(e2, s2);
            if (this.match(14)) {
              let n2 = e2;
              return n2.label = this.finishPlaceholder(s2, "Identifier"), this.next(), n2.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(n2, "LabeledStatement");
            }
            this.semicolon();
            let r2 = e2;
            return r2.name = s2.name, this.finishPlaceholder(r2, "Statement");
          }
          parseBlock(e2, s2, i2) {
            return this.parsePlaceholder("BlockStatement") || super.parseBlock(e2, s2, i2);
          }
          parseFunctionId(e2) {
            return this.parsePlaceholder("Identifier") || super.parseFunctionId(e2);
          }
          parseClass(e2, s2, i2) {
            let r2 = s2 ? "ClassDeclaration" : "ClassExpression";
            this.next();
            let n2 = this.state.strict, o2 = this.parsePlaceholder("Identifier");
            if (o2)
              if (this.match(81) || this.match(144) || this.match(5))
                e2.id = o2;
              else {
                if (i2 || !s2)
                  return e2.id = null, e2.body = this.finishPlaceholder(o2, "ClassBody"), this.finishNode(e2, r2);
                throw this.raise(Vt2.ClassNameIsRequired, this.state.startLoc);
              }
            else
              this.parseClassId(e2, s2, i2);
            return super.parseClassSuper(e2), e2.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!e2.superClass, n2), this.finishNode(e2, r2);
          }
          parseExport(e2, s2) {
            let i2 = this.parsePlaceholder("Identifier");
            if (!i2)
              return super.parseExport(e2, s2);
            let r2 = e2;
            if (!this.isContextual(98) && !this.match(12))
              return r2.specifiers = [], r2.source = null, r2.declaration = this.finishPlaceholder(i2, "Declaration"), this.finishNode(r2, "ExportNamedDeclaration");
            this.expectPlugin("exportDefaultFrom");
            let n2 = this.startNode();
            return n2.exported = i2, r2.specifiers = [this.finishNode(n2, "ExportDefaultSpecifier")], super.parseExport(r2, s2);
          }
          isExportDefaultSpecifier() {
            if (this.match(65)) {
              let e2 = this.nextTokenStart();
              if (this.isUnparsedContextual(e2, "from") && this.input.startsWith(K2(144), this.nextTokenStartSince(e2 + 4)))
                return true;
            }
            return super.isExportDefaultSpecifier();
          }
          maybeParseExportDefaultSpecifier(e2, s2) {
            var i2;
            return (i2 = e2.specifiers) != null && i2.length ? true : super.maybeParseExportDefaultSpecifier(e2, s2);
          }
          checkExport(e2) {
            let { specifiers: s2 } = e2;
            s2 != null && s2.length && (e2.specifiers = s2.filter((i2) => i2.exported.type === "Placeholder")), super.checkExport(e2), e2.specifiers = s2;
          }
          parseImport(e2) {
            let s2 = this.parsePlaceholder("Identifier");
            if (!s2)
              return super.parseImport(e2);
            if (e2.specifiers = [], !this.isContextual(98) && !this.match(12))
              return e2.source = this.finishPlaceholder(s2, "StringLiteral"), this.semicolon(), this.finishNode(e2, "ImportDeclaration");
            let i2 = this.startNodeAtNode(s2);
            return i2.local = s2, e2.specifiers.push(this.finishNode(i2, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(e2) || this.parseNamedImportSpecifiers(e2)), this.expectContextual(98), e2.source = this.parseImportSource(), this.semicolon(), this.finishNode(e2, "ImportDeclaration");
          }
          parseImportSource() {
            return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
          }
          assertNoSpace() {
            this.state.start > this.state.lastTokEndLoc.index && this.raise(Vt2.UnexpectedSpace, this.state.lastTokEndLoc);
          }
        }, tr2 = (a2) => class extends a2 {
          parseV8Intrinsic() {
            if (this.match(54)) {
              let e2 = this.state.startLoc, s2 = this.startNode();
              if (this.next(), w2(this.state.type)) {
                let i2 = this.parseIdentifierName(), r2 = this.createIdentifier(s2, i2);
                if (r2.type = "V8IntrinsicIdentifier", this.match(10))
                  return r2;
              }
              this.unexpected(e2);
            }
          }
          parseExprAtom(e2) {
            return this.parseV8Intrinsic() || super.parseExprAtom(e2);
          }
        };
        function N2(a2, t2) {
          let [e2, s2] = typeof t2 == "string" ? [t2, {}] : t2, i2 = Object.keys(s2), r2 = i2.length === 0;
          return a2.some((n2) => {
            if (typeof n2 == "string")
              return r2 && n2 === e2;
            {
              let [o2, h2] = n2;
              if (o2 !== e2)
                return false;
              for (let c2 of i2)
                if (h2[c2] !== s2[c2])
                  return false;
              return true;
            }
          });
        }
        function J3(a2, t2, e2) {
          let s2 = a2.find((i2) => Array.isArray(i2) ? i2[0] === t2 : i2 === t2);
          return s2 && Array.isArray(s2) && s2.length > 1 ? s2[1][e2] : null;
        }
        var qt2 = ["minimal", "fsharp", "hack", "smart"], zt2 = ["^^", "@@", "^", "%", "#"];
        function sr3(a2) {
          if (N2(a2, "decorators")) {
            if (N2(a2, "decorators-legacy"))
              throw new Error("Cannot use the decorators and decorators-legacy plugin together");
            let t2 = J3(a2, "decorators", "decoratorsBeforeExport");
            if (t2 != null && typeof t2 != "boolean")
              throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
            let e2 = J3(a2, "decorators", "allowCallParenthesized");
            if (e2 != null && typeof e2 != "boolean")
              throw new Error("'allowCallParenthesized' must be a boolean.");
          }
          if (N2(a2, "flow") && N2(a2, "typescript"))
            throw new Error("Cannot combine flow and typescript plugins.");
          if (N2(a2, "placeholders") && N2(a2, "v8intrinsic"))
            throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
          if (N2(a2, "pipelineOperator")) {
            let t2 = J3(a2, "pipelineOperator", "proposal");
            if (!qt2.includes(t2)) {
              let i2 = qt2.map((r2) => `"${r2}"`).join(", ");
              throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${i2}.`);
            }
            let e2 = ["recordAndTuple", { syntaxType: "hash" }], s2 = N2(a2, e2);
            if (t2 === "hack") {
              if (N2(a2, "placeholders"))
                throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
              if (N2(a2, "v8intrinsic"))
                throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
              let i2 = J3(a2, "pipelineOperator", "topicToken");
              if (!zt2.includes(i2)) {
                let r2 = zt2.map((n2) => `"${n2}"`).join(", ");
                throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${r2}.`);
              }
              if (i2 === "#" && s2)
                throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(e2)}\`.`);
            } else if (t2 === "smart" && s2)
              throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(e2)}\`.`);
          }
          if (N2(a2, "moduleAttributes")) {
            if (N2(a2, "importAssertions") || N2(a2, "importAttributes"))
              throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
            if (J3(a2, "moduleAttributes", "version") !== "may-2020")
              throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
          }
          if (N2(a2, "importAssertions") && N2(a2, "importAttributes"))
            throw new Error("Cannot combine importAssertions and importAttributes plugins.");
          if (N2(a2, "recordAndTuple")) {
            let t2 = J3(a2, "recordAndTuple", "syntaxType");
            if (t2 != null) {
              let e2 = ["hash", "bar"];
              if (!e2.includes(t2))
                throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + e2.map((s2) => `'${s2}'`).join(", "));
            }
          }
          if (N2(a2, "asyncDoExpressions") && !N2(a2, "doExpressions")) {
            let t2 = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
            throw t2.missingPlugins = "doExpressions", t2;
          }
          if (N2(a2, "optionalChainingAssign") && J3(a2, "optionalChainingAssign", "version") !== "2023-07")
            throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
        }
        var hs = { estree: ri3, jsx: zi, flow: qi2, typescript: Gi, v8intrinsic: tr2, placeholders: er2 }, ir3 = Object.keys(hs), qe2 = { sourceType: "script", sourceFilename: void 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: false, allowReturnOutsideFunction: false, allowNewTargetOutsideFunction: false, allowImportExportEverywhere: false, allowSuperOutsideMethod: false, allowUndeclaredExports: false, plugins: [], strictMode: null, ranges: false, tokens: false, createImportExpressions: false, createParenthesizedExpressions: false, errorRecovery: false, attachComment: true, annexB: true };
        function rr2(a2) {
          if (a2 == null)
            return Object.assign({}, qe2);
          if (a2.annexB != null && a2.annexB !== false)
            throw new Error("The `annexB` option can only be set to `false`.");
          let t2 = {};
          for (let s2 of Object.keys(qe2)) {
            var e2;
            t2[s2] = (e2 = a2[s2]) != null ? e2 : qe2[s2];
          }
          return t2;
        }
        var ct3 = class extends lt3 {
          checkProto(t2, e2, s2, i2) {
            if (t2.type === "SpreadElement" || this.isObjectMethod(t2) || t2.computed || t2.shorthand)
              return;
            let r2 = t2.key;
            if ((r2.type === "Identifier" ? r2.name : r2.value) === "__proto__") {
              if (e2) {
                this.raise(p2.RecordNoProto, r2);
                return;
              }
              s2.used && (i2 ? i2.doubleProtoLoc === null && (i2.doubleProtoLoc = r2.loc.start) : this.raise(p2.DuplicateProto, r2)), s2.used = true;
            }
          }
          shouldExitDescending(t2, e2) {
            return t2.type === "ArrowFunctionExpression" && t2.start === e2;
          }
          getExpression() {
            this.enterInitialScopes(), this.nextToken();
            let t2 = this.parseExpression();
            return this.match(139) || this.unexpected(), this.finalizeRemainingComments(), t2.comments = this.comments, t2.errors = this.state.errors, this.options.tokens && (t2.tokens = this.tokens), t2;
          }
          parseExpression(t2, e2) {
            return t2 ? this.disallowInAnd(() => this.parseExpressionBase(e2)) : this.allowInAnd(() => this.parseExpressionBase(e2));
          }
          parseExpressionBase(t2) {
            let e2 = this.state.startLoc, s2 = this.parseMaybeAssign(t2);
            if (this.match(12)) {
              let i2 = this.startNodeAt(e2);
              for (i2.expressions = [s2]; this.eat(12); )
                i2.expressions.push(this.parseMaybeAssign(t2));
              return this.toReferencedList(i2.expressions), this.finishNode(i2, "SequenceExpression");
            }
            return s2;
          }
          parseMaybeAssignDisallowIn(t2, e2) {
            return this.disallowInAnd(() => this.parseMaybeAssign(t2, e2));
          }
          parseMaybeAssignAllowIn(t2, e2) {
            return this.allowInAnd(() => this.parseMaybeAssign(t2, e2));
          }
          setOptionalParametersError(t2, e2) {
            var s2;
            t2.optionalParametersLoc = (s2 = e2 == null ? void 0 : e2.loc) != null ? s2 : this.state.startLoc;
          }
          parseMaybeAssign(t2, e2) {
            let s2 = this.state.startLoc;
            if (this.isContextual(108) && this.prodParam.hasYield) {
              let o2 = this.parseYield();
              return e2 && (o2 = e2.call(this, o2, s2)), o2;
            }
            let i2;
            t2 ? i2 = false : (t2 = new Z3(), i2 = true);
            let { type: r2 } = this.state;
            (r2 === 10 || w2(r2)) && (this.state.potentialArrowAt = this.state.start);
            let n2 = this.parseMaybeConditional(t2);
            if (e2 && (n2 = e2.call(this, n2, s2)), li3(this.state.type)) {
              let o2 = this.startNodeAt(s2), h2 = this.state.value;
              if (o2.operator = h2, this.match(29)) {
                this.toAssignable(n2, true), o2.left = n2;
                let c2 = s2.index;
                t2.doubleProtoLoc != null && t2.doubleProtoLoc.index >= c2 && (t2.doubleProtoLoc = null), t2.shorthandAssignLoc != null && t2.shorthandAssignLoc.index >= c2 && (t2.shorthandAssignLoc = null), t2.privateKeyLoc != null && t2.privateKeyLoc.index >= c2 && (this.checkDestructuringPrivate(t2), t2.privateKeyLoc = null);
              } else
                o2.left = n2;
              return this.next(), o2.right = this.parseMaybeAssign(), this.checkLVal(n2, { in: this.finishNode(o2, "AssignmentExpression") }), o2;
            } else
              i2 && this.checkExpressionErrors(t2, true);
            return n2;
          }
          parseMaybeConditional(t2) {
            let e2 = this.state.startLoc, s2 = this.state.potentialArrowAt, i2 = this.parseExprOps(t2);
            return this.shouldExitDescending(i2, s2) ? i2 : this.parseConditional(i2, e2, t2);
          }
          parseConditional(t2, e2, s2) {
            if (this.eat(17)) {
              let i2 = this.startNodeAt(e2);
              return i2.test = t2, i2.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), i2.alternate = this.parseMaybeAssign(), this.finishNode(i2, "ConditionalExpression");
            }
            return t2;
          }
          parseMaybeUnaryOrPrivate(t2) {
            return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(t2);
          }
          parseExprOps(t2) {
            let e2 = this.state.startLoc, s2 = this.state.potentialArrowAt, i2 = this.parseMaybeUnaryOrPrivate(t2);
            return this.shouldExitDescending(i2, s2) ? i2 : this.parseExprOp(i2, e2, -1);
          }
          parseExprOp(t2, e2, s2) {
            if (this.isPrivateName(t2)) {
              let r2 = this.getPrivateNameSV(t2);
              (s2 >= Ie3(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(p2.PrivateInExpectedIn, t2, { identifierName: r2 }), this.classScope.usePrivateName(r2, t2.loc.start);
            }
            let i2 = this.state.type;
            if (pi3(i2) && (this.prodParam.hasIn || !this.match(58))) {
              let r2 = Ie3(i2);
              if (r2 > s2) {
                if (i2 === 39) {
                  if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
                    return t2;
                  this.checkPipelineAtInfixOperator(t2, e2);
                }
                let n2 = this.startNodeAt(e2);
                n2.left = t2, n2.operator = this.state.value;
                let o2 = i2 === 41 || i2 === 42, h2 = i2 === 40;
                if (h2 && (r2 = Ie3(42)), this.next(), i2 === 39 && this.hasPlugin(["pipelineOperator", { proposal: "minimal" }]) && this.state.type === 96 && this.prodParam.hasAwait)
                  throw this.raise(p2.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
                n2.right = this.parseExprOpRightExpr(i2, r2);
                let c2 = this.finishNode(n2, o2 || h2 ? "LogicalExpression" : "BinaryExpression"), l2 = this.state.type;
                if (h2 && (l2 === 41 || l2 === 42) || o2 && l2 === 40)
                  throw this.raise(p2.MixingCoalesceWithLogical, this.state.startLoc);
                return this.parseExprOp(c2, e2, s2);
              }
            }
            return t2;
          }
          parseExprOpRightExpr(t2, e2) {
            let s2 = this.state.startLoc;
            switch (t2) {
              case 39:
                switch (this.getPluginOption("pipelineOperator", "proposal")) {
                  case "hack":
                    return this.withTopicBindingContext(() => this.parseHackPipeBody());
                  case "smart":
                    return this.withTopicBindingContext(() => {
                      if (this.prodParam.hasYield && this.isContextual(108))
                        throw this.raise(p2.PipeBodyIsTighter, this.state.startLoc);
                      return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(t2, e2), s2);
                    });
                  case "fsharp":
                    return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(e2));
                }
              default:
                return this.parseExprOpBaseRightExpr(t2, e2);
            }
          }
          parseExprOpBaseRightExpr(t2, e2) {
            let s2 = this.state.startLoc;
            return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), s2, yi(t2) ? e2 - 1 : e2);
          }
          parseHackPipeBody() {
            var t2;
            let { startLoc: e2 } = this.state, s2 = this.parseMaybeAssign();
            return Qs2.has(s2.type) && !((t2 = s2.extra) != null && t2.parenthesized) && this.raise(p2.PipeUnparenthesizedBody, e2, { type: s2.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(p2.PipeTopicUnused, e2), s2;
          }
          checkExponentialAfterUnary(t2) {
            this.match(57) && this.raise(p2.UnexpectedTokenUnaryExponentiation, t2.argument);
          }
          parseMaybeUnary(t2, e2) {
            let s2 = this.state.startLoc, i2 = this.isContextual(96);
            if (i2 && this.isAwaitAllowed()) {
              this.next();
              let h2 = this.parseAwait(s2);
              return e2 || this.checkExponentialAfterUnary(h2), h2;
            }
            let r2 = this.match(34), n2 = this.startNode();
            if (fi2(this.state.type)) {
              n2.operator = this.state.value, n2.prefix = true, this.match(72) && this.expectPlugin("throwExpressions");
              let h2 = this.match(89);
              if (this.next(), n2.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(t2, true), this.state.strict && h2) {
                let c2 = n2.argument;
                c2.type === "Identifier" ? this.raise(p2.StrictDelete, n2) : this.hasPropertyAsPrivateName(c2) && this.raise(p2.DeletePrivateField, n2);
              }
              if (!r2)
                return e2 || this.checkExponentialAfterUnary(n2), this.finishNode(n2, "UnaryExpression");
            }
            let o2 = this.parseUpdate(n2, r2, t2);
            if (i2) {
              let { type: h2 } = this.state;
              if ((this.hasPlugin("v8intrinsic") ? He2(h2) : He2(h2) && !this.match(54)) && !this.isAmbiguousAwait())
                return this.raiseOverwrite(p2.AwaitNotInAsyncContext, s2), this.parseAwait(s2);
            }
            return o2;
          }
          parseUpdate(t2, e2, s2) {
            if (e2) {
              let n2 = t2;
              return this.checkLVal(n2.argument, { in: this.finishNode(n2, "UpdateExpression") }), t2;
            }
            let i2 = this.state.startLoc, r2 = this.parseExprSubscripts(s2);
            if (this.checkExpressionErrors(s2, false))
              return r2;
            for (; ui2(this.state.type) && !this.canInsertSemicolon(); ) {
              let n2 = this.startNodeAt(i2);
              n2.operator = this.state.value, n2.prefix = false, n2.argument = r2, this.next(), this.checkLVal(r2, { in: r2 = this.finishNode(n2, "UpdateExpression") });
            }
            return r2;
          }
          parseExprSubscripts(t2) {
            let e2 = this.state.startLoc, s2 = this.state.potentialArrowAt, i2 = this.parseExprAtom(t2);
            return this.shouldExitDescending(i2, s2) ? i2 : this.parseSubscripts(i2, e2);
          }
          parseSubscripts(t2, e2, s2) {
            let i2 = { optionalChainMember: false, maybeAsyncArrow: this.atPossibleAsyncArrow(t2), stop: false };
            do
              t2 = this.parseSubscript(t2, e2, s2, i2), i2.maybeAsyncArrow = false;
            while (!i2.stop);
            return t2;
          }
          parseSubscript(t2, e2, s2, i2) {
            let { type: r2 } = this.state;
            if (!s2 && r2 === 15)
              return this.parseBind(t2, e2, s2, i2);
            if (Le3(r2))
              return this.parseTaggedTemplateExpression(t2, e2, i2);
            let n2 = false;
            if (r2 === 18) {
              if (s2 && (this.raise(p2.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
                return i2.stop = true, t2;
              i2.optionalChainMember = n2 = true, this.next();
            }
            if (!s2 && this.match(10))
              return this.parseCoverCallAndAsyncArrowHead(t2, e2, i2, n2);
            {
              let o2 = this.eat(0);
              return o2 || n2 || this.eat(16) ? this.parseMember(t2, e2, i2, o2, n2) : (i2.stop = true, t2);
            }
          }
          parseMember(t2, e2, s2, i2, r2) {
            let n2 = this.startNodeAt(e2);
            return n2.object = t2, n2.computed = i2, i2 ? (n2.property = this.parseExpression(), this.expect(3)) : this.match(138) ? (t2.type === "Super" && this.raise(p2.SuperPrivateField, e2), this.classScope.usePrivateName(this.state.value, this.state.startLoc), n2.property = this.parsePrivateName()) : n2.property = this.parseIdentifier(true), s2.optionalChainMember ? (n2.optional = r2, this.finishNode(n2, "OptionalMemberExpression")) : this.finishNode(n2, "MemberExpression");
          }
          parseBind(t2, e2, s2, i2) {
            let r2 = this.startNodeAt(e2);
            return r2.object = t2, this.next(), r2.callee = this.parseNoCallExpr(), i2.stop = true, this.parseSubscripts(this.finishNode(r2, "BindExpression"), e2, s2);
          }
          parseCoverCallAndAsyncArrowHead(t2, e2, s2, i2) {
            let r2 = this.state.maybeInArrowParameters, n2 = null;
            this.state.maybeInArrowParameters = true, this.next();
            let o2 = this.startNodeAt(e2);
            o2.callee = t2;
            let { maybeAsyncArrow: h2, optionalChainMember: c2 } = s2;
            h2 && (this.expressionScope.enter(Fi()), n2 = new Z3()), c2 && (o2.optional = i2), i2 ? o2.arguments = this.parseCallExpressionArguments(11) : o2.arguments = this.parseCallExpressionArguments(11, t2.type === "Import", t2.type !== "Super", o2, n2);
            let l2 = this.finishCallExpression(o2, c2);
            return h2 && this.shouldParseAsyncArrow() && !i2 ? (s2.stop = true, this.checkDestructuringPrivate(n2), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), l2 = this.parseAsyncArrowFromCallExpression(this.startNodeAt(e2), l2)) : (h2 && (this.checkExpressionErrors(n2, true), this.expressionScope.exit()), this.toReferencedArguments(l2)), this.state.maybeInArrowParameters = r2, l2;
          }
          toReferencedArguments(t2, e2) {
            this.toReferencedListDeep(t2.arguments, e2);
          }
          parseTaggedTemplateExpression(t2, e2, s2) {
            let i2 = this.startNodeAt(e2);
            return i2.tag = t2, i2.quasi = this.parseTemplate(true), s2.optionalChainMember && this.raise(p2.OptionalChainingNoTemplate, e2), this.finishNode(i2, "TaggedTemplateExpression");
          }
          atPossibleAsyncArrow(t2) {
            return t2.type === "Identifier" && t2.name === "async" && this.state.lastTokEndLoc.index === t2.end && !this.canInsertSemicolon() && t2.end - t2.start === 5 && t2.start === this.state.potentialArrowAt;
          }
          expectImportAttributesPlugin() {
            this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
          }
          finishCallExpression(t2, e2) {
            if (t2.callee.type === "Import")
              if (t2.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), t2.arguments.length === 0 || t2.arguments.length > 2)
                this.raise(p2.ImportCallArity, t2, { maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1 });
              else
                for (let s2 of t2.arguments)
                  s2.type === "SpreadElement" && this.raise(p2.ImportCallSpreadArgument, s2);
            return this.finishNode(t2, e2 ? "OptionalCallExpression" : "CallExpression");
          }
          parseCallExpressionArguments(t2, e2, s2, i2, r2) {
            let n2 = [], o2 = true, h2 = this.state.inFSharpPipelineDirectBody;
            for (this.state.inFSharpPipelineDirectBody = false; !this.eat(t2); ) {
              if (o2)
                o2 = false;
              else if (this.expect(12), this.match(t2)) {
                e2 && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(p2.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc), i2 && this.addTrailingCommaExtraToNode(i2), this.next();
                break;
              }
              n2.push(this.parseExprListItem(false, r2, s2));
            }
            return this.state.inFSharpPipelineDirectBody = h2, n2;
          }
          shouldParseAsyncArrow() {
            return this.match(19) && !this.canInsertSemicolon();
          }
          parseAsyncArrowFromCallExpression(t2, e2) {
            var s2;
            return this.resetPreviousNodeTrailingComments(e2), this.expect(19), this.parseArrowExpression(t2, e2.arguments, true, (s2 = e2.extra) == null ? void 0 : s2.trailingCommaLoc), e2.innerComments && ye(t2, e2.innerComments), e2.callee.trailingComments && ye(t2, e2.callee.trailingComments), t2;
          }
          parseNoCallExpr() {
            let t2 = this.state.startLoc;
            return this.parseSubscripts(this.parseExprAtom(), t2, true);
          }
          parseExprAtom(t2) {
            let e2, s2 = null, { type: i2 } = this.state;
            switch (i2) {
              case 79:
                return this.parseSuper();
              case 83:
                return e2 = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(e2) : this.match(10) ? this.options.createImportExpressions ? this.parseImportCall(e2) : this.finishNode(e2, "Import") : (this.raise(p2.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(e2, "Import"));
              case 78:
                return e2 = this.startNode(), this.next(), this.finishNode(e2, "ThisExpression");
              case 90:
                return this.parseDo(this.startNode(), false);
              case 56:
              case 31:
                return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
              case 134:
                return this.parseNumericLiteral(this.state.value);
              case 135:
                return this.parseBigIntLiteral(this.state.value);
              case 136:
                return this.parseDecimalLiteral(this.state.value);
              case 133:
                return this.parseStringLiteral(this.state.value);
              case 84:
                return this.parseNullLiteral();
              case 85:
                return this.parseBooleanLiteral(true);
              case 86:
                return this.parseBooleanLiteral(false);
              case 10: {
                let r2 = this.state.potentialArrowAt === this.state.start;
                return this.parseParenAndDistinguishExpression(r2);
              }
              case 2:
              case 1:
                return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
              case 0:
                return this.parseArrayLike(3, true, false, t2);
              case 6:
              case 7:
                return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
              case 5:
                return this.parseObjectLike(8, false, false, t2);
              case 68:
                return this.parseFunctionOrFunctionSent();
              case 26:
                s2 = this.parseDecorators();
              case 80:
                return this.parseClass(this.maybeTakeDecorators(s2, this.startNode()), false);
              case 77:
                return this.parseNewOrNewTarget();
              case 25:
              case 24:
                return this.parseTemplate(false);
              case 15: {
                e2 = this.startNode(), this.next(), e2.object = null;
                let r2 = e2.callee = this.parseNoCallExpr();
                if (r2.type === "MemberExpression")
                  return this.finishNode(e2, "BindExpression");
                throw this.raise(p2.UnsupportedBind, r2);
              }
              case 138:
                return this.raise(p2.PrivateInExpectedIn, this.state.startLoc, { identifierName: this.state.value }), this.parsePrivateName();
              case 33:
                return this.parseTopicReferenceThenEqualsSign(54, "%");
              case 32:
                return this.parseTopicReferenceThenEqualsSign(44, "^");
              case 37:
              case 38:
                return this.parseTopicReference("hack");
              case 44:
              case 54:
              case 27: {
                let r2 = this.getPluginOption("pipelineOperator", "proposal");
                if (r2)
                  return this.parseTopicReference(r2);
                this.unexpected();
                break;
              }
              case 47: {
                let r2 = this.input.codePointAt(this.nextTokenStart());
                _3(r2) || r2 === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
                break;
              }
              default:
                if (w2(i2)) {
                  if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
                    return this.parseModuleExpression();
                  let r2 = this.state.potentialArrowAt === this.state.start, n2 = this.state.containsEsc, o2 = this.parseIdentifier();
                  if (!n2 && o2.name === "async" && !this.canInsertSemicolon()) {
                    let { type: h2 } = this.state;
                    if (h2 === 68)
                      return this.resetPreviousNodeTrailingComments(o2), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(o2));
                    if (w2(h2))
                      return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(o2)) : o2;
                    if (h2 === 90)
                      return this.resetPreviousNodeTrailingComments(o2), this.parseDo(this.startNodeAtNode(o2), true);
                  }
                  return r2 && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(o2), [o2], false)) : o2;
                } else
                  this.unexpected();
            }
          }
          parseTopicReferenceThenEqualsSign(t2, e2) {
            let s2 = this.getPluginOption("pipelineOperator", "proposal");
            if (s2)
              return this.state.type = t2, this.state.value = e2, this.state.pos--, this.state.end--, this.state.endLoc = v2(this.state.endLoc, -1), this.parseTopicReference(s2);
            this.unexpected();
          }
          parseTopicReference(t2) {
            let e2 = this.startNode(), s2 = this.state.startLoc, i2 = this.state.type;
            return this.next(), this.finishTopicReference(e2, s2, t2, i2);
          }
          finishTopicReference(t2, e2, s2, i2) {
            if (this.testTopicReferenceConfiguration(s2, e2, i2)) {
              let r2 = s2 === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
              return this.topicReferenceIsAllowedInCurrentContext() || this.raise(s2 === "smart" ? p2.PrimaryTopicNotAllowed : p2.PipeTopicUnbound, e2), this.registerTopicReference(), this.finishNode(t2, r2);
            } else
              throw this.raise(p2.PipeTopicUnconfiguredToken, e2, { token: K2(i2) });
          }
          testTopicReferenceConfiguration(t2, e2, s2) {
            switch (t2) {
              case "hack":
                return this.hasPlugin(["pipelineOperator", { topicToken: K2(s2) }]);
              case "smart":
                return s2 === 27;
              default:
                throw this.raise(p2.PipeTopicRequiresHackPipes, e2);
            }
          }
          parseAsyncArrowUnaryFunction(t2) {
            this.prodParam.enter(ke3(true, this.prodParam.hasYield));
            let e2 = [this.parseIdentifier()];
            return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(p2.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(t2, e2, true);
          }
          parseDo(t2, e2) {
            this.expectPlugin("doExpressions"), e2 && this.expectPlugin("asyncDoExpressions"), t2.async = e2, this.next();
            let s2 = this.state.labels;
            return this.state.labels = [], e2 ? (this.prodParam.enter(2), t2.body = this.parseBlock(), this.prodParam.exit()) : t2.body = this.parseBlock(), this.state.labels = s2, this.finishNode(t2, "DoExpression");
          }
          parseSuper() {
            let t2 = this.startNode();
            return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(p2.SuperNotAllowed, t2) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(p2.UnexpectedSuper, t2), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(p2.UnsupportedSuper, t2), this.finishNode(t2, "Super");
          }
          parsePrivateName() {
            let t2 = this.startNode(), e2 = this.startNodeAt(v2(this.state.startLoc, 1)), s2 = this.state.value;
            return this.next(), t2.id = this.createIdentifier(e2, s2), this.finishNode(t2, "PrivateName");
          }
          parseFunctionOrFunctionSent() {
            let t2 = this.startNode();
            if (this.next(), this.prodParam.hasYield && this.match(16)) {
              let e2 = this.createIdentifier(this.startNodeAtNode(t2), "function");
              return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(t2, e2, "sent");
            }
            return this.parseFunction(t2);
          }
          parseMetaProperty(t2, e2, s2) {
            t2.meta = e2;
            let i2 = this.state.containsEsc;
            return t2.property = this.parseIdentifier(true), (t2.property.name !== s2 || i2) && this.raise(p2.UnsupportedMetaProperty, t2.property, { target: e2.name, onlyValidPropertyName: s2 }), this.finishNode(t2, "MetaProperty");
          }
          parseImportMetaProperty(t2) {
            let e2 = this.createIdentifier(this.startNodeAtNode(t2), "import");
            if (this.next(), this.isContextual(101))
              this.inModule || this.raise(p2.ImportMetaOutsideModule, e2), this.sawUnambiguousESM = true;
            else if (this.isContextual(105) || this.isContextual(97)) {
              let s2 = this.isContextual(105);
              if (s2 || this.unexpected(), this.expectPlugin(s2 ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions)
                throw this.raise(p2.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, { phase: this.state.value });
              return this.next(), t2.phase = s2 ? "source" : "defer", this.parseImportCall(t2);
            }
            return this.parseMetaProperty(t2, e2, "meta");
          }
          parseLiteralAtNode(t2, e2, s2) {
            return this.addExtra(s2, "rawValue", t2), this.addExtra(s2, "raw", this.input.slice(s2.start, this.state.end)), s2.value = t2, this.next(), this.finishNode(s2, e2);
          }
          parseLiteral(t2, e2) {
            let s2 = this.startNode();
            return this.parseLiteralAtNode(t2, e2, s2);
          }
          parseStringLiteral(t2) {
            return this.parseLiteral(t2, "StringLiteral");
          }
          parseNumericLiteral(t2) {
            return this.parseLiteral(t2, "NumericLiteral");
          }
          parseBigIntLiteral(t2) {
            return this.parseLiteral(t2, "BigIntLiteral");
          }
          parseDecimalLiteral(t2) {
            return this.parseLiteral(t2, "DecimalLiteral");
          }
          parseRegExpLiteral(t2) {
            let e2 = this.startNode();
            return this.addExtra(e2, "raw", this.input.slice(e2.start, this.state.end)), e2.pattern = t2.pattern, e2.flags = t2.flags, this.next(), this.finishNode(e2, "RegExpLiteral");
          }
          parseBooleanLiteral(t2) {
            let e2 = this.startNode();
            return e2.value = t2, this.next(), this.finishNode(e2, "BooleanLiteral");
          }
          parseNullLiteral() {
            let t2 = this.startNode();
            return this.next(), this.finishNode(t2, "NullLiteral");
          }
          parseParenAndDistinguishExpression(t2) {
            let e2 = this.state.startLoc, s2;
            this.next(), this.expressionScope.enter(Oi2());
            let i2 = this.state.maybeInArrowParameters, r2 = this.state.inFSharpPipelineDirectBody;
            this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
            let n2 = this.state.startLoc, o2 = [], h2 = new Z3(), c2 = true, l2, u2;
            for (; !this.match(11); ) {
              if (c2)
                c2 = false;
              else if (this.expect(12, h2.optionalParametersLoc === null ? null : h2.optionalParametersLoc), this.match(11)) {
                u2 = this.state.startLoc;
                break;
              }
              if (this.match(21)) {
                let y3 = this.state.startLoc;
                if (l2 = this.state.startLoc, o2.push(this.parseParenItem(this.parseRestBinding(), y3)), !this.checkCommaAfterRest(41))
                  break;
              } else
                o2.push(this.parseMaybeAssignAllowIn(h2, this.parseParenItem));
            }
            let f2 = this.state.lastTokEndLoc;
            this.expect(11), this.state.maybeInArrowParameters = i2, this.state.inFSharpPipelineDirectBody = r2;
            let d2 = this.startNodeAt(e2);
            return t2 && this.shouldParseArrow(o2) && (d2 = this.parseArrow(d2)) ? (this.checkDestructuringPrivate(h2), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(d2, o2, false), d2) : (this.expressionScope.exit(), o2.length || this.unexpected(this.state.lastTokStartLoc), u2 && this.unexpected(u2), l2 && this.unexpected(l2), this.checkExpressionErrors(h2, true), this.toReferencedListDeep(o2, true), o2.length > 1 ? (s2 = this.startNodeAt(n2), s2.expressions = o2, this.finishNode(s2, "SequenceExpression"), this.resetEndLocation(s2, f2)) : s2 = o2[0], this.wrapParenthesis(e2, s2));
          }
          wrapParenthesis(t2, e2) {
            if (!this.options.createParenthesizedExpressions)
              return this.addExtra(e2, "parenthesized", true), this.addExtra(e2, "parenStart", t2.index), this.takeSurroundingComments(e2, t2.index, this.state.lastTokEndLoc.index), e2;
            let s2 = this.startNodeAt(t2);
            return s2.expression = e2, this.finishNode(s2, "ParenthesizedExpression");
          }
          shouldParseArrow(t2) {
            return !this.canInsertSemicolon();
          }
          parseArrow(t2) {
            if (this.eat(19))
              return t2;
          }
          parseParenItem(t2, e2) {
            return t2;
          }
          parseNewOrNewTarget() {
            let t2 = this.startNode();
            if (this.next(), this.match(16)) {
              let e2 = this.createIdentifier(this.startNodeAtNode(t2), "new");
              this.next();
              let s2 = this.parseMetaProperty(t2, e2, "target");
              return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(p2.UnexpectedNewTarget, s2), s2;
            }
            return this.parseNew(t2);
          }
          parseNew(t2) {
            if (this.parseNewCallee(t2), this.eat(10)) {
              let e2 = this.parseExprList(11);
              this.toReferencedList(e2), t2.arguments = e2;
            } else
              t2.arguments = [];
            return this.finishNode(t2, "NewExpression");
          }
          parseNewCallee(t2) {
            let e2 = this.match(83), s2 = this.parseNoCallExpr();
            t2.callee = s2, e2 && (s2.type === "Import" || s2.type === "ImportExpression") && this.raise(p2.ImportCallNotNewExpression, s2);
          }
          parseTemplateElement(t2) {
            let { start: e2, startLoc: s2, end: i2, value: r2 } = this.state, n2 = e2 + 1, o2 = this.startNodeAt(v2(s2, 1));
            r2 === null && (t2 || this.raise(p2.InvalidEscapeSequenceTemplate, v2(this.state.firstInvalidTemplateEscapePos, 1)));
            let h2 = this.match(24), c2 = h2 ? -1 : -2, l2 = i2 + c2;
            o2.value = { raw: this.input.slice(n2, l2).replace(/\r\n?/g, `
`), cooked: r2 === null ? null : r2.slice(1, c2) }, o2.tail = h2, this.next();
            let u2 = this.finishNode(o2, "TemplateElement");
            return this.resetEndLocation(u2, v2(this.state.lastTokEndLoc, c2)), u2;
          }
          parseTemplate(t2) {
            let e2 = this.startNode(), s2 = this.parseTemplateElement(t2), i2 = [s2], r2 = [];
            for (; !s2.tail; )
              r2.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), i2.push(s2 = this.parseTemplateElement(t2));
            return e2.expressions = r2, e2.quasis = i2, this.finishNode(e2, "TemplateLiteral");
          }
          parseTemplateSubstitution() {
            return this.parseExpression();
          }
          parseObjectLike(t2, e2, s2, i2) {
            s2 && this.expectPlugin("recordAndTuple");
            let r2 = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            let n2 = /* @__PURE__ */ Object.create(null), o2 = true, h2 = this.startNode();
            for (h2.properties = [], this.next(); !this.match(t2); ) {
              if (o2)
                o2 = false;
              else if (this.expect(12), this.match(t2)) {
                this.addTrailingCommaExtraToNode(h2);
                break;
              }
              let l2;
              e2 ? l2 = this.parseBindingProperty() : (l2 = this.parsePropertyDefinition(i2), this.checkProto(l2, s2, n2, i2)), s2 && !this.isObjectProperty(l2) && l2.type !== "SpreadElement" && this.raise(p2.InvalidRecordProperty, l2), l2.shorthand && this.addExtra(l2, "shorthand", true), h2.properties.push(l2);
            }
            this.next(), this.state.inFSharpPipelineDirectBody = r2;
            let c2 = "ObjectExpression";
            return e2 ? c2 = "ObjectPattern" : s2 && (c2 = "RecordExpression"), this.finishNode(h2, c2);
          }
          addTrailingCommaExtraToNode(t2) {
            this.addExtra(t2, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(t2, "trailingCommaLoc", this.state.lastTokStartLoc, false);
          }
          maybeAsyncOrAccessorProp(t2) {
            return !t2.computed && t2.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
          }
          parsePropertyDefinition(t2) {
            let e2 = [];
            if (this.match(26))
              for (this.hasPlugin("decorators") && this.raise(p2.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
                e2.push(this.parseDecorator());
            let s2 = this.startNode(), i2 = false, r2 = false, n2;
            if (this.match(21))
              return e2.length && this.unexpected(), this.parseSpread();
            e2.length && (s2.decorators = e2, e2 = []), s2.method = false, t2 && (n2 = this.state.startLoc);
            let o2 = this.eat(55);
            this.parsePropertyNamePrefixOperator(s2);
            let h2 = this.state.containsEsc;
            if (this.parsePropertyName(s2, t2), !o2 && !h2 && this.maybeAsyncOrAccessorProp(s2)) {
              let { key: c2 } = s2, l2 = c2.name;
              l2 === "async" && !this.hasPrecedingLineBreak() && (i2 = true, this.resetPreviousNodeTrailingComments(c2), o2 = this.eat(55), this.parsePropertyName(s2)), (l2 === "get" || l2 === "set") && (r2 = true, this.resetPreviousNodeTrailingComments(c2), s2.kind = l2, this.match(55) && (o2 = true, this.raise(p2.AccessorIsGenerator, this.state.curPosition(), { kind: l2 }), this.next()), this.parsePropertyName(s2));
            }
            return this.parseObjPropValue(s2, n2, o2, i2, false, r2, t2);
          }
          getGetterSetterExpectedParamCount(t2) {
            return t2.kind === "get" ? 0 : 1;
          }
          getObjectOrClassMethodParams(t2) {
            return t2.params;
          }
          checkGetterSetterParams(t2) {
            var e2;
            let s2 = this.getGetterSetterExpectedParamCount(t2), i2 = this.getObjectOrClassMethodParams(t2);
            i2.length !== s2 && this.raise(t2.kind === "get" ? p2.BadGetterArity : p2.BadSetterArity, t2), t2.kind === "set" && ((e2 = i2[i2.length - 1]) == null ? void 0 : e2.type) === "RestElement" && this.raise(p2.BadSetterRestParameter, t2);
          }
          parseObjectMethod(t2, e2, s2, i2, r2) {
            if (r2) {
              let n2 = this.parseMethod(t2, e2, false, false, false, "ObjectMethod");
              return this.checkGetterSetterParams(n2), n2;
            }
            if (s2 || e2 || this.match(10))
              return i2 && this.unexpected(), t2.kind = "method", t2.method = true, this.parseMethod(t2, e2, s2, false, false, "ObjectMethod");
          }
          parseObjectProperty(t2, e2, s2, i2) {
            if (t2.shorthand = false, this.eat(14))
              return t2.value = s2 ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(i2), this.finishNode(t2, "ObjectProperty");
            if (!t2.computed && t2.key.type === "Identifier") {
              if (this.checkReservedWord(t2.key.name, t2.key.loc.start, true, false), s2)
                t2.value = this.parseMaybeDefault(e2, $2(t2.key));
              else if (this.match(29)) {
                let r2 = this.state.startLoc;
                i2 != null ? i2.shorthandAssignLoc === null && (i2.shorthandAssignLoc = r2) : this.raise(p2.InvalidCoverInitializedName, r2), t2.value = this.parseMaybeDefault(e2, $2(t2.key));
              } else
                t2.value = $2(t2.key);
              return t2.shorthand = true, this.finishNode(t2, "ObjectProperty");
            }
          }
          parseObjPropValue(t2, e2, s2, i2, r2, n2, o2) {
            let h2 = this.parseObjectMethod(t2, s2, i2, r2, n2) || this.parseObjectProperty(t2, e2, r2, o2);
            return h2 || this.unexpected(), h2;
          }
          parsePropertyName(t2, e2) {
            if (this.eat(0))
              t2.computed = true, t2.key = this.parseMaybeAssignAllowIn(), this.expect(3);
            else {
              let { type: s2, value: i2 } = this.state, r2;
              if (M3(s2))
                r2 = this.parseIdentifier(true);
              else
                switch (s2) {
                  case 134:
                    r2 = this.parseNumericLiteral(i2);
                    break;
                  case 133:
                    r2 = this.parseStringLiteral(i2);
                    break;
                  case 135:
                    r2 = this.parseBigIntLiteral(i2);
                    break;
                  case 136:
                    r2 = this.parseDecimalLiteral(i2);
                    break;
                  case 138: {
                    let n2 = this.state.startLoc;
                    e2 != null ? e2.privateKeyLoc === null && (e2.privateKeyLoc = n2) : this.raise(p2.UnexpectedPrivateField, n2), r2 = this.parsePrivateName();
                    break;
                  }
                  default:
                    this.unexpected();
                }
              t2.key = r2, s2 !== 138 && (t2.computed = false);
            }
          }
          initFunction(t2, e2) {
            t2.id = null, t2.generator = false, t2.async = e2;
          }
          parseMethod(t2, e2, s2, i2, r2, n2, o2 = false) {
            this.initFunction(t2, s2), t2.generator = e2, this.scope.enter(18 | (o2 ? 64 : 0) | (r2 ? 32 : 0)), this.prodParam.enter(ke3(s2, t2.generator)), this.parseFunctionParams(t2, i2);
            let h2 = this.parseFunctionBodyAndFinish(t2, n2, true);
            return this.prodParam.exit(), this.scope.exit(), h2;
          }
          parseArrayLike(t2, e2, s2, i2) {
            s2 && this.expectPlugin("recordAndTuple");
            let r2 = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            let n2 = this.startNode();
            return this.next(), n2.elements = this.parseExprList(t2, !s2, i2, n2), this.state.inFSharpPipelineDirectBody = r2, this.finishNode(n2, s2 ? "TupleExpression" : "ArrayExpression");
          }
          parseArrowExpression(t2, e2, s2, i2) {
            this.scope.enter(6);
            let r2 = ke3(s2, false);
            !this.match(5) && this.prodParam.hasIn && (r2 |= 8), this.prodParam.enter(r2), this.initFunction(t2, s2);
            let n2 = this.state.maybeInArrowParameters;
            return e2 && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(t2, e2, i2)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(t2, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = n2, this.finishNode(t2, "ArrowFunctionExpression");
          }
          setArrowFunctionParameters(t2, e2, s2) {
            this.toAssignableList(e2, s2, false), t2.params = e2;
          }
          parseFunctionBodyAndFinish(t2, e2, s2 = false) {
            return this.parseFunctionBody(t2, false, s2), this.finishNode(t2, e2);
          }
          parseFunctionBody(t2, e2, s2 = false) {
            let i2 = e2 && !this.match(5);
            if (this.expressionScope.enter(rs()), i2)
              t2.body = this.parseMaybeAssign(), this.checkParams(t2, false, e2, false);
            else {
              let r2 = this.state.strict, n2 = this.state.labels;
              this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), t2.body = this.parseBlock(true, false, (o2) => {
                let h2 = !this.isSimpleParamList(t2.params);
                o2 && h2 && this.raise(p2.IllegalLanguageModeDirective, (t2.kind === "method" || t2.kind === "constructor") && t2.key ? t2.key.loc.end : t2);
                let c2 = !r2 && this.state.strict;
                this.checkParams(t2, !this.state.strict && !e2 && !s2 && !h2, e2, c2), this.state.strict && t2.id && this.checkIdentifier(t2.id, 65, c2);
              }), this.prodParam.exit(), this.state.labels = n2;
            }
            this.expressionScope.exit();
          }
          isSimpleParameter(t2) {
            return t2.type === "Identifier";
          }
          isSimpleParamList(t2) {
            for (let e2 = 0, s2 = t2.length; e2 < s2; e2++)
              if (!this.isSimpleParameter(t2[e2]))
                return false;
            return true;
          }
          checkParams(t2, e2, s2, i2 = true) {
            let r2 = !e2 && /* @__PURE__ */ new Set(), n2 = { type: "FormalParameters" };
            for (let o2 of t2.params)
              this.checkLVal(o2, { in: n2, binding: 5, checkClashes: r2, strictModeChanged: i2 });
          }
          parseExprList(t2, e2, s2, i2) {
            let r2 = [], n2 = true;
            for (; !this.eat(t2); ) {
              if (n2)
                n2 = false;
              else if (this.expect(12), this.match(t2)) {
                i2 && this.addTrailingCommaExtraToNode(i2), this.next();
                break;
              }
              r2.push(this.parseExprListItem(e2, s2));
            }
            return r2;
          }
          parseExprListItem(t2, e2, s2) {
            let i2;
            if (this.match(12))
              t2 || this.raise(p2.UnexpectedToken, this.state.curPosition(), { unexpected: "," }), i2 = null;
            else if (this.match(21)) {
              let r2 = this.state.startLoc;
              i2 = this.parseParenItem(this.parseSpread(e2), r2);
            } else if (this.match(17)) {
              this.expectPlugin("partialApplication"), s2 || this.raise(p2.UnexpectedArgumentPlaceholder, this.state.startLoc);
              let r2 = this.startNode();
              this.next(), i2 = this.finishNode(r2, "ArgumentPlaceholder");
            } else
              i2 = this.parseMaybeAssignAllowIn(e2, this.parseParenItem);
            return i2;
          }
          parseIdentifier(t2) {
            let e2 = this.startNode(), s2 = this.parseIdentifierName(t2);
            return this.createIdentifier(e2, s2);
          }
          createIdentifier(t2, e2) {
            return t2.name = e2, t2.loc.identifierName = e2, this.finishNode(t2, "Identifier");
          }
          parseIdentifierName(t2) {
            let e2, { startLoc: s2, type: i2 } = this.state;
            M3(i2) ? e2 = this.state.value : this.unexpected();
            let r2 = oi2(i2);
            return t2 ? r2 && this.replaceToken(132) : this.checkReservedWord(e2, s2, r2, false), this.next(), e2;
          }
          checkReservedWord(t2, e2, s2, i2) {
            if (t2.length > 10 || !Ei(t2))
              return;
            if (s2 && Si2(t2)) {
              this.raise(p2.UnexpectedKeyword, e2, { keyword: t2 });
              return;
            }
            if ((this.state.strict ? i2 ? Zt : Yt2 : Gt2)(t2, this.inModule)) {
              this.raise(p2.UnexpectedReservedWord, e2, { reservedWord: t2 });
              return;
            } else if (t2 === "yield") {
              if (this.prodParam.hasYield) {
                this.raise(p2.YieldBindingIdentifier, e2);
                return;
              }
            } else if (t2 === "await") {
              if (this.prodParam.hasAwait) {
                this.raise(p2.AwaitBindingIdentifier, e2);
                return;
              }
              if (this.scope.inStaticBlock) {
                this.raise(p2.AwaitBindingIdentifierInStaticBlock, e2);
                return;
              }
              this.expressionScope.recordAsyncArrowParametersError(e2);
            } else if (t2 === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
              this.raise(p2.ArgumentsInClass, e2);
              return;
            }
          }
          isAwaitAllowed() {
            return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
          }
          parseAwait(t2) {
            let e2 = this.startNodeAt(t2);
            return this.expressionScope.recordParameterInitializerError(p2.AwaitExpressionFormalParameter, e2), this.eat(55) && this.raise(p2.ObsoleteAwaitStar, e2), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (e2.argument = this.parseMaybeUnary(null, true)), this.finishNode(e2, "AwaitExpression");
          }
          isAmbiguousAwait() {
            if (this.hasPrecedingLineBreak())
              return true;
            let { type: t2 } = this.state;
            return t2 === 53 || t2 === 10 || t2 === 0 || Le3(t2) || t2 === 102 && !this.state.containsEsc || t2 === 137 || t2 === 56 || this.hasPlugin("v8intrinsic") && t2 === 54;
          }
          parseYield() {
            let t2 = this.startNode();
            this.expressionScope.recordParameterInitializerError(p2.YieldInParameter, t2), this.next();
            let e2 = false, s2 = null;
            if (!this.hasPrecedingLineBreak())
              switch (e2 = this.eat(55), this.state.type) {
                case 13:
                case 139:
                case 8:
                case 11:
                case 3:
                case 9:
                case 14:
                case 12:
                  if (!e2)
                    break;
                default:
                  s2 = this.parseMaybeAssign();
              }
            return t2.delegate = e2, t2.argument = s2, this.finishNode(t2, "YieldExpression");
          }
          parseImportCall(t2) {
            return this.next(), t2.source = this.parseMaybeAssignAllowIn(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (t2.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (t2.options = this.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11), this.finishNode(t2, "ImportExpression");
          }
          checkPipelineAtInfixOperator(t2, e2) {
            this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) && t2.type === "SequenceExpression" && this.raise(p2.PipelineHeadSequenceExpression, e2);
          }
          parseSmartPipelineBodyInStyle(t2, e2) {
            if (this.isSimpleReference(t2)) {
              let s2 = this.startNodeAt(e2);
              return s2.callee = t2, this.finishNode(s2, "PipelineBareFunction");
            } else {
              let s2 = this.startNodeAt(e2);
              return this.checkSmartPipeTopicBodyEarlyErrors(e2), s2.expression = t2, this.finishNode(s2, "PipelineTopicExpression");
            }
          }
          isSimpleReference(t2) {
            switch (t2.type) {
              case "MemberExpression":
                return !t2.computed && this.isSimpleReference(t2.object);
              case "Identifier":
                return true;
              default:
                return false;
            }
          }
          checkSmartPipeTopicBodyEarlyErrors(t2) {
            if (this.match(19))
              throw this.raise(p2.PipelineBodyNoArrow, this.state.startLoc);
            this.topicReferenceWasUsedInCurrentContext() || this.raise(p2.PipelineTopicUnused, t2);
          }
          withTopicBindingContext(t2) {
            let e2 = this.state.topicContext;
            this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
            try {
              return t2();
            } finally {
              this.state.topicContext = e2;
            }
          }
          withSmartMixTopicForbiddingContext(t2) {
            if (this.hasPlugin(["pipelineOperator", { proposal: "smart" }])) {
              let e2 = this.state.topicContext;
              this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
              try {
                return t2();
              } finally {
                this.state.topicContext = e2;
              }
            } else
              return t2();
          }
          withSoloAwaitPermittingContext(t2) {
            let e2 = this.state.soloAwait;
            this.state.soloAwait = true;
            try {
              return t2();
            } finally {
              this.state.soloAwait = e2;
            }
          }
          allowInAnd(t2) {
            let e2 = this.prodParam.currentFlags();
            if (8 & ~e2) {
              this.prodParam.enter(e2 | 8);
              try {
                return t2();
              } finally {
                this.prodParam.exit();
              }
            }
            return t2();
          }
          disallowInAnd(t2) {
            let e2 = this.prodParam.currentFlags();
            if (8 & e2) {
              this.prodParam.enter(e2 & -9);
              try {
                return t2();
              } finally {
                this.prodParam.exit();
              }
            }
            return t2();
          }
          registerTopicReference() {
            this.state.topicContext.maxTopicIndex = 0;
          }
          topicReferenceIsAllowedInCurrentContext() {
            return this.state.topicContext.maxNumOfResolvableTopics >= 1;
          }
          topicReferenceWasUsedInCurrentContext() {
            return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
          }
          parseFSharpPipelineBody(t2) {
            let e2 = this.state.startLoc;
            this.state.potentialArrowAt = this.state.start;
            let s2 = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = true;
            let i2 = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), e2, t2);
            return this.state.inFSharpPipelineDirectBody = s2, i2;
          }
          parseModuleExpression() {
            this.expectPlugin("moduleBlocks");
            let t2 = this.startNode();
            this.next(), this.match(5) || this.unexpected(null, 5);
            let e2 = this.startNodeAt(this.state.endLoc);
            this.next();
            let s2 = this.initializeScopes(true);
            this.enterInitialScopes();
            try {
              t2.body = this.parseProgram(e2, 8, "module");
            } finally {
              s2();
            }
            return this.finishNode(t2, "ModuleExpression");
          }
          parsePropertyNamePrefixOperator(t2) {
          }
        }, ze2 = { kind: 1 }, ar3 = { kind: 2 }, nr2 = /[\uD800-\uDFFF]/u, Ke3 = /in(?:stanceof)?/y;
        function or3(a2, t2) {
          for (let e2 = 0; e2 < a2.length; e2++) {
            let s2 = a2[e2], { type: i2 } = s2;
            if (typeof i2 == "number") {
              {
                if (i2 === 138) {
                  let { loc: r2, start: n2, value: o2, end: h2 } = s2, c2 = n2 + 1, l2 = v2(r2.start, 1);
                  a2.splice(e2, 1, new O2({ type: R3(27), value: "#", start: n2, end: c2, startLoc: r2.start, endLoc: l2 }), new O2({ type: R3(132), value: o2, start: c2, end: h2, startLoc: l2, endLoc: r2.end })), e2++;
                  continue;
                }
                if (Le3(i2)) {
                  let { loc: r2, start: n2, value: o2, end: h2 } = s2, c2 = n2 + 1, l2 = v2(r2.start, 1), u2;
                  t2.charCodeAt(n2) === 96 ? u2 = new O2({ type: R3(22), value: "`", start: n2, end: c2, startLoc: r2.start, endLoc: l2 }) : u2 = new O2({ type: R3(8), value: "}", start: n2, end: c2, startLoc: r2.start, endLoc: l2 });
                  let f2, d2, y3, E2;
                  i2 === 24 ? (d2 = h2 - 1, y3 = v2(r2.end, -1), f2 = o2 === null ? null : o2.slice(1, -1), E2 = new O2({ type: R3(22), value: "`", start: d2, end: h2, startLoc: y3, endLoc: r2.end })) : (d2 = h2 - 2, y3 = v2(r2.end, -2), f2 = o2 === null ? null : o2.slice(1, -2), E2 = new O2({ type: R3(23), value: "${", start: d2, end: h2, startLoc: y3, endLoc: r2.end })), a2.splice(e2, 1, u2, new O2({ type: R3(20), value: f2, start: c2, end: d2, startLoc: l2, endLoc: y3 }), E2), e2 += 2;
                  continue;
                }
              }
              s2.type = R3(i2);
            }
          }
          return a2;
        }
        var pt3 = class extends ct3 {
          parseTopLevel(t2, e2) {
            return t2.program = this.parseProgram(e2), t2.comments = this.comments, this.options.tokens && (t2.tokens = or3(this.tokens, this.input)), this.finishNode(t2, "File");
          }
          parseProgram(t2, e2 = 139, s2 = this.options.sourceType) {
            if (t2.sourceType = s2, t2.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(t2, true, true, e2), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
              for (let [r2, n2] of Array.from(this.scope.undefinedExports))
                this.raise(p2.ModuleExportUndefined, n2, { localName: r2 });
            let i2;
            return e2 === 139 ? i2 = this.finishNode(t2, "Program") : i2 = this.finishNodeAt(t2, "Program", v2(this.state.startLoc, -1)), i2;
          }
          stmtToDirective(t2) {
            let e2 = t2;
            e2.type = "Directive", e2.value = e2.expression, delete e2.expression;
            let s2 = e2.value, i2 = s2.value, r2 = this.input.slice(s2.start, s2.end), n2 = s2.value = r2.slice(1, -1);
            return this.addExtra(s2, "raw", r2), this.addExtra(s2, "rawValue", n2), this.addExtra(s2, "expressionValue", i2), s2.type = "DirectiveLiteral", e2;
          }
          parseInterpreterDirective() {
            if (!this.match(28))
              return null;
            let t2 = this.startNode();
            return t2.value = this.state.value, this.next(), this.finishNode(t2, "InterpreterDirective");
          }
          isLet() {
            return this.isContextual(100) ? this.hasFollowingBindingAtom() : false;
          }
          chStartsBindingIdentifier(t2, e2) {
            if (_3(t2)) {
              if (Ke3.lastIndex = e2, Ke3.test(this.input)) {
                let s2 = this.codePointAtPos(Ke3.lastIndex);
                if (!Q3(s2) && s2 !== 92)
                  return false;
              }
              return true;
            } else
              return t2 === 92;
          }
          chStartsBindingPattern(t2) {
            return t2 === 91 || t2 === 123;
          }
          hasFollowingBindingAtom() {
            let t2 = this.nextTokenStart(), e2 = this.codePointAtPos(t2);
            return this.chStartsBindingPattern(e2) || this.chStartsBindingIdentifier(e2, t2);
          }
          hasInLineFollowingBindingIdentifierOrBrace() {
            let t2 = this.nextTokenInLineStart(), e2 = this.codePointAtPos(t2);
            return e2 === 123 || this.chStartsBindingIdentifier(e2, t2);
          }
          startsUsingForOf() {
            let { type: t2, containsEsc: e2 } = this.lookahead();
            if (t2 === 102 && !e2)
              return false;
            if (w2(t2) && !this.hasFollowingLineBreak())
              return this.expectPlugin("explicitResourceManagement"), true;
          }
          startsAwaitUsing() {
            let t2 = this.nextTokenInLineStart();
            if (this.isUnparsedContextual(t2, "using")) {
              t2 = this.nextTokenInLineStartSince(t2 + 5);
              let e2 = this.codePointAtPos(t2);
              if (this.chStartsBindingIdentifier(e2, t2))
                return this.expectPlugin("explicitResourceManagement"), true;
            }
            return false;
          }
          parseModuleItem() {
            return this.parseStatementLike(15);
          }
          parseStatementListItem() {
            return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
          }
          parseStatementOrSloppyAnnexBFunctionDeclaration(t2 = false) {
            let e2 = 0;
            return this.options.annexB && !this.state.strict && (e2 |= 4, t2 && (e2 |= 8)), this.parseStatementLike(e2);
          }
          parseStatement() {
            return this.parseStatementLike(0);
          }
          parseStatementLike(t2) {
            let e2 = null;
            return this.match(26) && (e2 = this.parseDecorators(true)), this.parseStatementContent(t2, e2);
          }
          parseStatementContent(t2, e2) {
            let s2 = this.state.type, i2 = this.startNode(), r2 = !!(t2 & 2), n2 = !!(t2 & 4), o2 = t2 & 1;
            switch (s2) {
              case 60:
                return this.parseBreakContinueStatement(i2, true);
              case 63:
                return this.parseBreakContinueStatement(i2, false);
              case 64:
                return this.parseDebuggerStatement(i2);
              case 90:
                return this.parseDoWhileStatement(i2);
              case 91:
                return this.parseForStatement(i2);
              case 68:
                if (this.lookaheadCharCode() === 46)
                  break;
                return n2 || this.raise(this.state.strict ? p2.StrictFunction : this.options.annexB ? p2.SloppyFunctionAnnexB : p2.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(i2, false, !r2 && n2);
              case 80:
                return r2 || this.unexpected(), this.parseClass(this.maybeTakeDecorators(e2, i2), true);
              case 69:
                return this.parseIfStatement(i2);
              case 70:
                return this.parseReturnStatement(i2);
              case 71:
                return this.parseSwitchStatement(i2);
              case 72:
                return this.parseThrowStatement(i2);
              case 73:
                return this.parseTryStatement(i2);
              case 96:
                if (!this.state.containsEsc && this.startsAwaitUsing())
                  return this.isAwaitAllowed() ? r2 || this.raise(p2.UnexpectedLexicalDeclaration, i2) : this.raise(p2.AwaitUsingNotInAsyncContext, i2), this.next(), this.parseVarStatement(i2, "await using");
                break;
              case 107:
                if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace())
                  break;
                return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(p2.UnexpectedUsingDeclaration, this.state.startLoc) : r2 || this.raise(p2.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(i2, "using");
              case 100: {
                if (this.state.containsEsc)
                  break;
                let l2 = this.nextTokenStart(), u2 = this.codePointAtPos(l2);
                if (u2 !== 91 && (!r2 && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(u2, l2) && u2 !== 123))
                  break;
              }
              case 75:
                r2 || this.raise(p2.UnexpectedLexicalDeclaration, this.state.startLoc);
              case 74: {
                let l2 = this.state.value;
                return this.parseVarStatement(i2, l2);
              }
              case 92:
                return this.parseWhileStatement(i2);
              case 76:
                return this.parseWithStatement(i2);
              case 5:
                return this.parseBlock();
              case 13:
                return this.parseEmptyStatement(i2);
              case 83: {
                let l2 = this.lookaheadCharCode();
                if (l2 === 40 || l2 === 46)
                  break;
              }
              case 82: {
                !this.options.allowImportExportEverywhere && !o2 && this.raise(p2.UnexpectedImportExport, this.state.startLoc), this.next();
                let l2;
                return s2 === 83 ? (l2 = this.parseImport(i2), l2.type === "ImportDeclaration" && (!l2.importKind || l2.importKind === "value") && (this.sawUnambiguousESM = true)) : (l2 = this.parseExport(i2, e2), (l2.type === "ExportNamedDeclaration" && (!l2.exportKind || l2.exportKind === "value") || l2.type === "ExportAllDeclaration" && (!l2.exportKind || l2.exportKind === "value") || l2.type === "ExportDefaultDeclaration") && (this.sawUnambiguousESM = true)), this.assertModuleNodeAllowed(l2), l2;
              }
              default:
                if (this.isAsyncFunction())
                  return r2 || this.raise(p2.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(i2, true, !r2 && n2);
            }
            let h2 = this.state.value, c2 = this.parseExpression();
            return w2(s2) && c2.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(i2, h2, c2, t2) : this.parseExpressionStatement(i2, c2, e2);
          }
          assertModuleNodeAllowed(t2) {
            !this.options.allowImportExportEverywhere && !this.inModule && this.raise(p2.ImportOutsideModule, t2);
          }
          decoratorsEnabledBeforeExport() {
            return this.hasPlugin("decorators-legacy") ? true : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
          }
          maybeTakeDecorators(t2, e2, s2) {
            return t2 && (e2.decorators && e2.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(p2.DecoratorsBeforeAfterExport, e2.decorators[0]), e2.decorators.unshift(...t2)) : e2.decorators = t2, this.resetStartLocationFromNode(e2, t2[0]), s2 && this.resetStartLocationFromNode(s2, e2)), e2;
          }
          canHaveLeadingDecorator() {
            return this.match(80);
          }
          parseDecorators(t2) {
            let e2 = [];
            do
              e2.push(this.parseDecorator());
            while (this.match(26));
            if (this.match(82))
              t2 || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(p2.DecoratorExportClass, this.state.startLoc);
            else if (!this.canHaveLeadingDecorator())
              throw this.raise(p2.UnexpectedLeadingDecorator, this.state.startLoc);
            return e2;
          }
          parseDecorator() {
            this.expectOnePlugin(["decorators", "decorators-legacy"]);
            let t2 = this.startNode();
            if (this.next(), this.hasPlugin("decorators")) {
              let e2 = this.state.startLoc, s2;
              if (this.match(10)) {
                let i2 = this.state.startLoc;
                this.next(), s2 = this.parseExpression(), this.expect(11), s2 = this.wrapParenthesis(i2, s2);
                let r2 = this.state.startLoc;
                t2.expression = this.parseMaybeDecoratorArguments(s2), this.getPluginOption("decorators", "allowCallParenthesized") === false && t2.expression !== s2 && this.raise(p2.DecoratorArgumentsOutsideParentheses, r2);
              } else {
                for (s2 = this.parseIdentifier(false); this.eat(16); ) {
                  let i2 = this.startNodeAt(e2);
                  i2.object = s2, this.match(138) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), i2.property = this.parsePrivateName()) : i2.property = this.parseIdentifier(true), i2.computed = false, s2 = this.finishNode(i2, "MemberExpression");
                }
                t2.expression = this.parseMaybeDecoratorArguments(s2);
              }
            } else
              t2.expression = this.parseExprSubscripts();
            return this.finishNode(t2, "Decorator");
          }
          parseMaybeDecoratorArguments(t2) {
            if (this.eat(10)) {
              let e2 = this.startNodeAtNode(t2);
              return e2.callee = t2, e2.arguments = this.parseCallExpressionArguments(11, false), this.toReferencedList(e2.arguments), this.finishNode(e2, "CallExpression");
            }
            return t2;
          }
          parseBreakContinueStatement(t2, e2) {
            return this.next(), this.isLineTerminator() ? t2.label = null : (t2.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(t2, e2), this.finishNode(t2, e2 ? "BreakStatement" : "ContinueStatement");
          }
          verifyBreakContinue(t2, e2) {
            let s2;
            for (s2 = 0; s2 < this.state.labels.length; ++s2) {
              let i2 = this.state.labels[s2];
              if ((t2.label == null || i2.name === t2.label.name) && (i2.kind != null && (e2 || i2.kind === 1) || t2.label && e2))
                break;
            }
            if (s2 === this.state.labels.length) {
              let i2 = e2 ? "BreakStatement" : "ContinueStatement";
              this.raise(p2.IllegalBreakContinue, t2, { type: i2 });
            }
          }
          parseDebuggerStatement(t2) {
            return this.next(), this.semicolon(), this.finishNode(t2, "DebuggerStatement");
          }
          parseHeaderExpression() {
            this.expect(10);
            let t2 = this.parseExpression();
            return this.expect(11), t2;
          }
          parseDoWhileStatement(t2) {
            return this.next(), this.state.labels.push(ze2), t2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), t2.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(t2, "DoWhileStatement");
          }
          parseForStatement(t2) {
            this.next(), this.state.labels.push(ze2);
            let e2 = null;
            if (this.isAwaitAllowed() && this.eatContextual(96) && (e2 = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(13))
              return e2 !== null && this.unexpected(e2), this.parseFor(t2, null);
            let s2 = this.isContextual(100);
            {
              let h2 = this.isContextual(96) && this.startsAwaitUsing(), c2 = h2 || this.isContextual(107) && this.startsUsingForOf(), l2 = s2 && this.hasFollowingBindingAtom() || c2;
              if (this.match(74) || this.match(75) || l2) {
                let u2 = this.startNode(), f2;
                h2 ? (f2 = "await using", this.isAwaitAllowed() || this.raise(p2.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : f2 = this.state.value, this.next(), this.parseVar(u2, true, f2);
                let d2 = this.finishNode(u2, "VariableDeclaration"), y3 = this.match(58);
                return y3 && c2 && this.raise(p2.ForInUsing, d2), (y3 || this.isContextual(102)) && d2.declarations.length === 1 ? this.parseForIn(t2, d2, e2) : (e2 !== null && this.unexpected(e2), this.parseFor(t2, d2));
              }
            }
            let i2 = this.isContextual(95), r2 = new Z3(), n2 = this.parseExpression(true, r2), o2 = this.isContextual(102);
            if (o2 && (s2 && this.raise(p2.ForOfLet, n2), e2 === null && i2 && n2.type === "Identifier" && this.raise(p2.ForOfAsync, n2)), o2 || this.match(58)) {
              this.checkDestructuringPrivate(r2), this.toAssignable(n2, true);
              let h2 = o2 ? "ForOfStatement" : "ForInStatement";
              return this.checkLVal(n2, { in: { type: h2 } }), this.parseForIn(t2, n2, e2);
            } else
              this.checkExpressionErrors(r2, true);
            return e2 !== null && this.unexpected(e2), this.parseFor(t2, n2);
          }
          parseFunctionStatement(t2, e2, s2) {
            return this.next(), this.parseFunction(t2, 1 | (s2 ? 2 : 0) | (e2 ? 8 : 0));
          }
          parseIfStatement(t2) {
            return this.next(), t2.test = this.parseHeaderExpression(), t2.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), t2.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(t2, "IfStatement");
          }
          parseReturnStatement(t2) {
            return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(p2.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? t2.argument = null : (t2.argument = this.parseExpression(), this.semicolon()), this.finishNode(t2, "ReturnStatement");
          }
          parseSwitchStatement(t2) {
            this.next(), t2.discriminant = this.parseHeaderExpression();
            let e2 = t2.cases = [];
            this.expect(5), this.state.labels.push(ar3), this.scope.enter(0);
            let s2;
            for (let i2; !this.match(8); )
              if (this.match(61) || this.match(65)) {
                let r2 = this.match(61);
                s2 && this.finishNode(s2, "SwitchCase"), e2.push(s2 = this.startNode()), s2.consequent = [], this.next(), r2 ? s2.test = this.parseExpression() : (i2 && this.raise(p2.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), i2 = true, s2.test = null), this.expect(14);
              } else
                s2 ? s2.consequent.push(this.parseStatementListItem()) : this.unexpected();
            return this.scope.exit(), s2 && this.finishNode(s2, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t2, "SwitchStatement");
          }
          parseThrowStatement(t2) {
            return this.next(), this.hasPrecedingLineBreak() && this.raise(p2.NewlineAfterThrow, this.state.lastTokEndLoc), t2.argument = this.parseExpression(), this.semicolon(), this.finishNode(t2, "ThrowStatement");
          }
          parseCatchClauseParam() {
            let t2 = this.parseBindingAtom();
            return this.scope.enter(this.options.annexB && t2.type === "Identifier" ? 8 : 0), this.checkLVal(t2, { in: { type: "CatchClause" }, binding: 9 }), t2;
          }
          parseTryStatement(t2) {
            if (this.next(), t2.block = this.parseBlock(), t2.handler = null, this.match(62)) {
              let e2 = this.startNode();
              this.next(), this.match(10) ? (this.expect(10), e2.param = this.parseCatchClauseParam(), this.expect(11)) : (e2.param = null, this.scope.enter(0)), e2.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), t2.handler = this.finishNode(e2, "CatchClause");
            }
            return t2.finalizer = this.eat(67) ? this.parseBlock() : null, !t2.handler && !t2.finalizer && this.raise(p2.NoCatchOrFinally, t2), this.finishNode(t2, "TryStatement");
          }
          parseVarStatement(t2, e2, s2 = false) {
            return this.next(), this.parseVar(t2, false, e2, s2), this.semicolon(), this.finishNode(t2, "VariableDeclaration");
          }
          parseWhileStatement(t2) {
            return this.next(), t2.test = this.parseHeaderExpression(), this.state.labels.push(ze2), t2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(t2, "WhileStatement");
          }
          parseWithStatement(t2) {
            return this.state.strict && this.raise(p2.StrictWith, this.state.startLoc), this.next(), t2.object = this.parseHeaderExpression(), t2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(t2, "WithStatement");
          }
          parseEmptyStatement(t2) {
            return this.next(), this.finishNode(t2, "EmptyStatement");
          }
          parseLabeledStatement(t2, e2, s2, i2) {
            for (let n2 of this.state.labels)
              n2.name === e2 && this.raise(p2.LabelRedeclaration, s2, { labelName: e2 });
            let r2 = ci3(this.state.type) ? 1 : this.match(71) ? 2 : null;
            for (let n2 = this.state.labels.length - 1; n2 >= 0; n2--) {
              let o2 = this.state.labels[n2];
              if (o2.statementStart === t2.start)
                o2.statementStart = this.state.start, o2.kind = r2;
              else
                break;
            }
            return this.state.labels.push({ name: e2, kind: r2, statementStart: this.state.start }), t2.body = i2 & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement(), this.state.labels.pop(), t2.label = s2, this.finishNode(t2, "LabeledStatement");
          }
          parseExpressionStatement(t2, e2, s2) {
            return t2.expression = e2, this.semicolon(), this.finishNode(t2, "ExpressionStatement");
          }
          parseBlock(t2 = false, e2 = true, s2) {
            let i2 = this.startNode();
            return t2 && this.state.strictErrors.clear(), this.expect(5), e2 && this.scope.enter(0), this.parseBlockBody(i2, t2, false, 8, s2), e2 && this.scope.exit(), this.finishNode(i2, "BlockStatement");
          }
          isValidDirective(t2) {
            return t2.type === "ExpressionStatement" && t2.expression.type === "StringLiteral" && !t2.expression.extra.parenthesized;
          }
          parseBlockBody(t2, e2, s2, i2, r2) {
            let n2 = t2.body = [], o2 = t2.directives = [];
            this.parseBlockOrModuleBlockBody(n2, e2 ? o2 : void 0, s2, i2, r2);
          }
          parseBlockOrModuleBlockBody(t2, e2, s2, i2, r2) {
            let n2 = this.state.strict, o2 = false, h2 = false;
            for (; !this.match(i2); ) {
              let c2 = s2 ? this.parseModuleItem() : this.parseStatementListItem();
              if (e2 && !h2) {
                if (this.isValidDirective(c2)) {
                  let l2 = this.stmtToDirective(c2);
                  e2.push(l2), !o2 && l2.value.value === "use strict" && (o2 = true, this.setStrict(true));
                  continue;
                }
                h2 = true, this.state.strictErrors.clear();
              }
              t2.push(c2);
            }
            r2 == null || r2.call(this, o2), n2 || this.setStrict(false), this.next();
          }
          parseFor(t2, e2) {
            return t2.init = e2, this.semicolon(false), t2.test = this.match(13) ? null : this.parseExpression(), this.semicolon(false), t2.update = this.match(11) ? null : this.parseExpression(), this.expect(11), t2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t2, "ForStatement");
          }
          parseForIn(t2, e2, s2) {
            let i2 = this.match(58);
            return this.next(), i2 ? s2 !== null && this.unexpected(s2) : t2.await = s2 !== null, e2.type === "VariableDeclaration" && e2.declarations[0].init != null && (!i2 || !this.options.annexB || this.state.strict || e2.kind !== "var" || e2.declarations[0].id.type !== "Identifier") && this.raise(p2.ForInOfLoopInitializer, e2, { type: i2 ? "ForInStatement" : "ForOfStatement" }), e2.type === "AssignmentPattern" && this.raise(p2.InvalidLhs, e2, { ancestor: { type: "ForStatement" } }), t2.left = e2, t2.right = i2 ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), t2.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t2, i2 ? "ForInStatement" : "ForOfStatement");
          }
          parseVar(t2, e2, s2, i2 = false) {
            let r2 = t2.declarations = [];
            for (t2.kind = s2; ; ) {
              let n2 = this.startNode();
              if (this.parseVarId(n2, s2), n2.init = this.eat(29) ? e2 ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, n2.init === null && !i2 && (n2.id.type !== "Identifier" && !(e2 && (this.match(58) || this.isContextual(102))) ? this.raise(p2.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: "destructuring" }) : (s2 === "const" || s2 === "using" || s2 === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(p2.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: s2 })), r2.push(this.finishNode(n2, "VariableDeclarator")), !this.eat(12))
                break;
            }
            return t2;
          }
          parseVarId(t2, e2) {
            let s2 = this.parseBindingAtom();
            (e2 === "using" || e2 === "await using") && (s2.type === "ArrayPattern" || s2.type === "ObjectPattern") && this.raise(p2.UsingDeclarationHasBindingPattern, s2.loc.start), this.checkLVal(s2, { in: { type: "VariableDeclarator" }, binding: e2 === "var" ? 5 : 8201 }), t2.id = s2;
          }
          parseAsyncFunctionExpression(t2) {
            return this.parseFunction(t2, 8);
          }
          parseFunction(t2, e2 = 0) {
            let s2 = e2 & 2, i2 = !!(e2 & 1), r2 = i2 && !(e2 & 4), n2 = !!(e2 & 8);
            this.initFunction(t2, n2), this.match(55) && (s2 && this.raise(p2.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), t2.generator = true), i2 && (t2.id = this.parseFunctionId(r2));
            let o2 = this.state.maybeInArrowParameters;
            return this.state.maybeInArrowParameters = false, this.scope.enter(2), this.prodParam.enter(ke3(n2, t2.generator)), i2 || (t2.id = this.parseFunctionId()), this.parseFunctionParams(t2, false), this.withSmartMixTopicForbiddingContext(() => {
              this.parseFunctionBodyAndFinish(t2, i2 ? "FunctionDeclaration" : "FunctionExpression");
            }), this.prodParam.exit(), this.scope.exit(), i2 && !s2 && this.registerFunctionStatementId(t2), this.state.maybeInArrowParameters = o2, t2;
          }
          parseFunctionId(t2) {
            return t2 || w2(this.state.type) ? this.parseIdentifier() : null;
          }
          parseFunctionParams(t2, e2) {
            this.expect(10), this.expressionScope.enter(Mi2()), t2.params = this.parseBindingList(11, 41, 2 | (e2 ? 4 : 0)), this.expressionScope.exit();
          }
          registerFunctionStatementId(t2) {
            t2.id && this.scope.declareName(t2.id.name, !this.options.annexB || this.state.strict || t2.generator || t2.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, t2.id.loc.start);
          }
          parseClass(t2, e2, s2) {
            this.next();
            let i2 = this.state.strict;
            return this.state.strict = true, this.parseClassId(t2, e2, s2), this.parseClassSuper(t2), t2.body = this.parseClassBody(!!t2.superClass, i2), this.finishNode(t2, e2 ? "ClassDeclaration" : "ClassExpression");
          }
          isClassProperty() {
            return this.match(29) || this.match(13) || this.match(8);
          }
          isClassMethod() {
            return this.match(10);
          }
          nameIsConstructor(t2) {
            return t2.type === "Identifier" && t2.name === "constructor" || t2.type === "StringLiteral" && t2.value === "constructor";
          }
          isNonstaticConstructor(t2) {
            return !t2.computed && !t2.static && this.nameIsConstructor(t2.key);
          }
          parseClassBody(t2, e2) {
            this.classScope.enter();
            let s2 = { hadConstructor: false, hadSuperClass: t2 }, i2 = [], r2 = this.startNode();
            if (r2.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
              for (; !this.match(8); ) {
                if (this.eat(13)) {
                  if (i2.length > 0)
                    throw this.raise(p2.DecoratorSemicolon, this.state.lastTokEndLoc);
                  continue;
                }
                if (this.match(26)) {
                  i2.push(this.parseDecorator());
                  continue;
                }
                let n2 = this.startNode();
                i2.length && (n2.decorators = i2, this.resetStartLocationFromNode(n2, i2[0]), i2 = []), this.parseClassMember(r2, n2, s2), n2.kind === "constructor" && n2.decorators && n2.decorators.length > 0 && this.raise(p2.DecoratorConstructor, n2);
              }
            }), this.state.strict = e2, this.next(), i2.length)
              throw this.raise(p2.TrailingDecorator, this.state.startLoc);
            return this.classScope.exit(), this.finishNode(r2, "ClassBody");
          }
          parseClassMemberFromModifier(t2, e2) {
            let s2 = this.parseIdentifier(true);
            if (this.isClassMethod()) {
              let i2 = e2;
              return i2.kind = "method", i2.computed = false, i2.key = s2, i2.static = false, this.pushClassMethod(t2, i2, false, false, false, false), true;
            } else if (this.isClassProperty()) {
              let i2 = e2;
              return i2.computed = false, i2.key = s2, i2.static = false, t2.body.push(this.parseClassProperty(i2)), true;
            }
            return this.resetPreviousNodeTrailingComments(s2), false;
          }
          parseClassMember(t2, e2, s2) {
            let i2 = this.isContextual(106);
            if (i2) {
              if (this.parseClassMemberFromModifier(t2, e2))
                return;
              if (this.eat(5)) {
                this.parseClassStaticBlock(t2, e2);
                return;
              }
            }
            this.parseClassMemberWithIsStatic(t2, e2, s2, i2);
          }
          parseClassMemberWithIsStatic(t2, e2, s2, i2) {
            let r2 = e2, n2 = e2, o2 = e2, h2 = e2, c2 = e2, l2 = r2, u2 = r2;
            if (e2.static = i2, this.parsePropertyNamePrefixOperator(e2), this.eat(55)) {
              l2.kind = "method";
              let S3 = this.match(138);
              if (this.parseClassElementName(l2), S3) {
                this.pushClassPrivateMethod(t2, n2, true, false);
                return;
              }
              this.isNonstaticConstructor(r2) && this.raise(p2.ConstructorIsGenerator, r2.key), this.pushClassMethod(t2, r2, true, false, false, false);
              return;
            }
            let f2 = !this.state.containsEsc && w2(this.state.type), d2 = this.parseClassElementName(e2), y3 = f2 ? d2.name : null, E2 = this.isPrivateName(d2), L3 = this.state.startLoc;
            if (this.parsePostMemberNameModifiers(u2), this.isClassMethod()) {
              if (l2.kind = "method", E2) {
                this.pushClassPrivateMethod(t2, n2, false, false);
                return;
              }
              let S3 = this.isNonstaticConstructor(r2), I2 = false;
              S3 && (r2.kind = "constructor", s2.hadConstructor && !this.hasPlugin("typescript") && this.raise(p2.DuplicateConstructor, d2), S3 && this.hasPlugin("typescript") && e2.override && this.raise(p2.OverrideOnConstructor, d2), s2.hadConstructor = true, I2 = s2.hadSuperClass), this.pushClassMethod(t2, r2, false, false, S3, I2);
            } else if (this.isClassProperty())
              E2 ? this.pushClassPrivateProperty(t2, h2) : this.pushClassProperty(t2, o2);
            else if (y3 === "async" && !this.isLineTerminator()) {
              this.resetPreviousNodeTrailingComments(d2);
              let S3 = this.eat(55);
              u2.optional && this.unexpected(L3), l2.kind = "method";
              let I2 = this.match(138);
              this.parseClassElementName(l2), this.parsePostMemberNameModifiers(u2), I2 ? this.pushClassPrivateMethod(t2, n2, S3, true) : (this.isNonstaticConstructor(r2) && this.raise(p2.ConstructorIsAsync, r2.key), this.pushClassMethod(t2, r2, S3, true, false, false));
            } else if ((y3 === "get" || y3 === "set") && !(this.match(55) && this.isLineTerminator())) {
              this.resetPreviousNodeTrailingComments(d2), l2.kind = y3;
              let S3 = this.match(138);
              this.parseClassElementName(r2), S3 ? this.pushClassPrivateMethod(t2, n2, false, false) : (this.isNonstaticConstructor(r2) && this.raise(p2.ConstructorIsAccessor, r2.key), this.pushClassMethod(t2, r2, false, false, false, false)), this.checkGetterSetterParams(r2);
            } else if (y3 === "accessor" && !this.isLineTerminator()) {
              this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(d2);
              let S3 = this.match(138);
              this.parseClassElementName(o2), this.pushClassAccessorProperty(t2, c2, S3);
            } else
              this.isLineTerminator() ? E2 ? this.pushClassPrivateProperty(t2, h2) : this.pushClassProperty(t2, o2) : this.unexpected();
          }
          parseClassElementName(t2) {
            let { type: e2, value: s2 } = this.state;
            if ((e2 === 132 || e2 === 133) && t2.static && s2 === "prototype" && this.raise(p2.StaticPrototype, this.state.startLoc), e2 === 138) {
              s2 === "constructor" && this.raise(p2.ConstructorClassPrivateField, this.state.startLoc);
              let i2 = this.parsePrivateName();
              return t2.key = i2, i2;
            }
            return this.parsePropertyName(t2), t2.key;
          }
          parseClassStaticBlock(t2, e2) {
            var s2;
            this.scope.enter(208);
            let i2 = this.state.labels;
            this.state.labels = [], this.prodParam.enter(0);
            let r2 = e2.body = [];
            this.parseBlockOrModuleBlockBody(r2, void 0, false, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = i2, t2.body.push(this.finishNode(e2, "StaticBlock")), (s2 = e2.decorators) != null && s2.length && this.raise(p2.DecoratorStaticBlock, e2);
          }
          pushClassProperty(t2, e2) {
            !e2.computed && this.nameIsConstructor(e2.key) && this.raise(p2.ConstructorClassField, e2.key), t2.body.push(this.parseClassProperty(e2));
          }
          pushClassPrivateProperty(t2, e2) {
            let s2 = this.parseClassPrivateProperty(e2);
            t2.body.push(s2), this.classScope.declarePrivateName(this.getPrivateNameSV(s2.key), 0, s2.key.loc.start);
          }
          pushClassAccessorProperty(t2, e2, s2) {
            !s2 && !e2.computed && this.nameIsConstructor(e2.key) && this.raise(p2.ConstructorClassField, e2.key);
            let i2 = this.parseClassAccessorProperty(e2);
            t2.body.push(i2), s2 && this.classScope.declarePrivateName(this.getPrivateNameSV(i2.key), 0, i2.key.loc.start);
          }
          pushClassMethod(t2, e2, s2, i2, r2, n2) {
            t2.body.push(this.parseMethod(e2, s2, i2, r2, n2, "ClassMethod", true));
          }
          pushClassPrivateMethod(t2, e2, s2, i2) {
            let r2 = this.parseMethod(e2, s2, i2, false, false, "ClassPrivateMethod", true);
            t2.body.push(r2);
            let n2 = r2.kind === "get" ? r2.static ? 6 : 2 : r2.kind === "set" ? r2.static ? 5 : 1 : 0;
            this.declareClassPrivateMethodInScope(r2, n2);
          }
          declareClassPrivateMethodInScope(t2, e2) {
            this.classScope.declarePrivateName(this.getPrivateNameSV(t2.key), e2, t2.key.loc.start);
          }
          parsePostMemberNameModifiers(t2) {
          }
          parseClassPrivateProperty(t2) {
            return this.parseInitializer(t2), this.semicolon(), this.finishNode(t2, "ClassPrivateProperty");
          }
          parseClassProperty(t2) {
            return this.parseInitializer(t2), this.semicolon(), this.finishNode(t2, "ClassProperty");
          }
          parseClassAccessorProperty(t2) {
            return this.parseInitializer(t2), this.semicolon(), this.finishNode(t2, "ClassAccessorProperty");
          }
          parseInitializer(t2) {
            this.scope.enter(80), this.expressionScope.enter(rs()), this.prodParam.enter(0), t2.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
          }
          parseClassId(t2, e2, s2, i2 = 8331) {
            if (w2(this.state.type))
              t2.id = this.parseIdentifier(), e2 && this.declareNameFromIdentifier(t2.id, i2);
            else if (s2 || !e2)
              t2.id = null;
            else
              throw this.raise(p2.MissingClassName, this.state.startLoc);
          }
          parseClassSuper(t2) {
            t2.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
          }
          parseExport(t2, e2) {
            let s2 = this.parseMaybeImportPhase(t2, true), i2 = this.maybeParseExportDefaultSpecifier(t2, s2), r2 = !i2 || this.eat(12), n2 = r2 && this.eatExportStar(t2), o2 = n2 && this.maybeParseExportNamespaceSpecifier(t2), h2 = r2 && (!o2 || this.eat(12)), c2 = i2 || n2;
            if (n2 && !o2) {
              if (i2 && this.unexpected(), e2)
                throw this.raise(p2.UnsupportedDecoratorExport, t2);
              return this.parseExportFrom(t2, true), this.finishNode(t2, "ExportAllDeclaration");
            }
            let l2 = this.maybeParseExportNamedSpecifiers(t2);
            i2 && r2 && !n2 && !l2 && this.unexpected(null, 5), o2 && h2 && this.unexpected(null, 98);
            let u2;
            if (c2 || l2) {
              if (u2 = false, e2)
                throw this.raise(p2.UnsupportedDecoratorExport, t2);
              this.parseExportFrom(t2, c2);
            } else
              u2 = this.maybeParseExportDeclaration(t2);
            if (c2 || l2 || u2) {
              var f2;
              let d2 = t2;
              if (this.checkExport(d2, true, false, !!d2.source), ((f2 = d2.declaration) == null ? void 0 : f2.type) === "ClassDeclaration")
                this.maybeTakeDecorators(e2, d2.declaration, d2);
              else if (e2)
                throw this.raise(p2.UnsupportedDecoratorExport, t2);
              return this.finishNode(d2, "ExportNamedDeclaration");
            }
            if (this.eat(65)) {
              let d2 = t2, y3 = this.parseExportDefaultExpression();
              if (d2.declaration = y3, y3.type === "ClassDeclaration")
                this.maybeTakeDecorators(e2, y3, d2);
              else if (e2)
                throw this.raise(p2.UnsupportedDecoratorExport, t2);
              return this.checkExport(d2, true, true), this.finishNode(d2, "ExportDefaultDeclaration");
            }
            this.unexpected(null, 5);
          }
          eatExportStar(t2) {
            return this.eat(55);
          }
          maybeParseExportDefaultSpecifier(t2, e2) {
            if (e2 || this.isExportDefaultSpecifier()) {
              this.expectPlugin("exportDefaultFrom", e2 == null ? void 0 : e2.loc.start);
              let s2 = e2 || this.parseIdentifier(true), i2 = this.startNodeAtNode(s2);
              return i2.exported = s2, t2.specifiers = [this.finishNode(i2, "ExportDefaultSpecifier")], true;
            }
            return false;
          }
          maybeParseExportNamespaceSpecifier(t2) {
            if (this.isContextual(93)) {
              var e2, s2;
              (s2 = (e2 = t2).specifiers) != null || (e2.specifiers = []);
              let i2 = this.startNodeAt(this.state.lastTokStartLoc);
              return this.next(), i2.exported = this.parseModuleExportName(), t2.specifiers.push(this.finishNode(i2, "ExportNamespaceSpecifier")), true;
            }
            return false;
          }
          maybeParseExportNamedSpecifiers(t2) {
            if (this.match(5)) {
              let e2 = t2;
              e2.specifiers || (e2.specifiers = []);
              let s2 = e2.exportKind === "type";
              return e2.specifiers.push(...this.parseExportSpecifiers(s2)), e2.source = null, e2.declaration = null, this.hasPlugin("importAssertions") && (e2.assertions = []), true;
            }
            return false;
          }
          maybeParseExportDeclaration(t2) {
            return this.shouldParseExportDeclaration() ? (t2.specifiers = [], t2.source = null, this.hasPlugin("importAssertions") && (t2.assertions = []), t2.declaration = this.parseExportDeclaration(t2), true) : false;
          }
          isAsyncFunction() {
            if (!this.isContextual(95))
              return false;
            let t2 = this.nextTokenInLineStart();
            return this.isUnparsedContextual(t2, "function");
          }
          parseExportDefaultExpression() {
            let t2 = this.startNode();
            if (this.match(68))
              return this.next(), this.parseFunction(t2, 5);
            if (this.isAsyncFunction())
              return this.next(), this.next(), this.parseFunction(t2, 13);
            if (this.match(80))
              return this.parseClass(t2, true, true);
            if (this.match(26))
              return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true && this.raise(p2.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
            if (this.match(75) || this.match(74) || this.isLet())
              throw this.raise(p2.UnsupportedDefaultExport, this.state.startLoc);
            let e2 = this.parseMaybeAssignAllowIn();
            return this.semicolon(), e2;
          }
          parseExportDeclaration(t2) {
            return this.match(80) ? this.parseClass(this.startNode(), true, false) : this.parseStatementListItem();
          }
          isExportDefaultSpecifier() {
            let { type: t2 } = this.state;
            if (w2(t2)) {
              if (t2 === 95 && !this.state.containsEsc || t2 === 100)
                return false;
              if ((t2 === 130 || t2 === 129) && !this.state.containsEsc) {
                let { type: i2 } = this.lookahead();
                if (w2(i2) && i2 !== 98 || i2 === 5)
                  return this.expectOnePlugin(["flow", "typescript"]), false;
              }
            } else if (!this.match(65))
              return false;
            let e2 = this.nextTokenStart(), s2 = this.isUnparsedContextual(e2, "from");
            if (this.input.charCodeAt(e2) === 44 || w2(this.state.type) && s2)
              return true;
            if (this.match(65) && s2) {
              let i2 = this.input.charCodeAt(this.nextTokenStartSince(e2 + 4));
              return i2 === 34 || i2 === 39;
            }
            return false;
          }
          parseExportFrom(t2, e2) {
            this.eatContextual(98) ? (t2.source = this.parseImportSource(), this.checkExport(t2), this.maybeParseImportAttributes(t2), this.checkJSONModuleImport(t2)) : e2 && this.unexpected(), this.semicolon();
          }
          shouldParseExportDeclaration() {
            let { type: t2 } = this.state;
            return t2 === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("decorators", "decoratorsBeforeExport") === true && this.raise(p2.DecoratorBeforeExport, this.state.startLoc), true) : this.isContextual(107) ? (this.raise(p2.UsingDeclarationExport, this.state.startLoc), true) : this.isContextual(96) && this.startsAwaitUsing() ? (this.raise(p2.UsingDeclarationExport, this.state.startLoc), true) : t2 === 74 || t2 === 75 || t2 === 68 || t2 === 80 || this.isLet() || this.isAsyncFunction();
          }
          checkExport(t2, e2, s2, i2) {
            if (e2) {
              var r2;
              if (s2) {
                if (this.checkDuplicateExports(t2, "default"), this.hasPlugin("exportDefaultFrom")) {
                  var n2;
                  let o2 = t2.declaration;
                  o2.type === "Identifier" && o2.name === "from" && o2.end - o2.start === 4 && !((n2 = o2.extra) != null && n2.parenthesized) && this.raise(p2.ExportDefaultFromAsIdentifier, o2);
                }
              } else if ((r2 = t2.specifiers) != null && r2.length)
                for (let o2 of t2.specifiers) {
                  let { exported: h2 } = o2, c2 = h2.type === "Identifier" ? h2.name : h2.value;
                  if (this.checkDuplicateExports(o2, c2), !i2 && o2.local) {
                    let { local: l2 } = o2;
                    l2.type !== "Identifier" ? this.raise(p2.ExportBindingIsString, o2, { localName: l2.value, exportName: c2 }) : (this.checkReservedWord(l2.name, l2.loc.start, true, false), this.scope.checkLocalExport(l2));
                  }
                }
              else if (t2.declaration) {
                let o2 = t2.declaration;
                if (o2.type === "FunctionDeclaration" || o2.type === "ClassDeclaration") {
                  let { id: h2 } = o2;
                  if (!h2)
                    throw new Error("Assertion failure");
                  this.checkDuplicateExports(t2, h2.name);
                } else if (o2.type === "VariableDeclaration")
                  for (let h2 of o2.declarations)
                    this.checkDeclaration(h2.id);
              }
            }
          }
          checkDeclaration(t2) {
            if (t2.type === "Identifier")
              this.checkDuplicateExports(t2, t2.name);
            else if (t2.type === "ObjectPattern")
              for (let e2 of t2.properties)
                this.checkDeclaration(e2);
            else if (t2.type === "ArrayPattern")
              for (let e2 of t2.elements)
                e2 && this.checkDeclaration(e2);
            else
              t2.type === "ObjectProperty" ? this.checkDeclaration(t2.value) : t2.type === "RestElement" ? this.checkDeclaration(t2.argument) : t2.type === "AssignmentPattern" && this.checkDeclaration(t2.left);
          }
          checkDuplicateExports(t2, e2) {
            this.exportedIdentifiers.has(e2) && (e2 === "default" ? this.raise(p2.DuplicateDefaultExport, t2) : this.raise(p2.DuplicateExport, t2, { exportName: e2 })), this.exportedIdentifiers.add(e2);
          }
          parseExportSpecifiers(t2) {
            let e2 = [], s2 = true;
            for (this.expect(5); !this.eat(8); ) {
              if (s2)
                s2 = false;
              else if (this.expect(12), this.eat(8))
                break;
              let i2 = this.isContextual(130), r2 = this.match(133), n2 = this.startNode();
              n2.local = this.parseModuleExportName(), e2.push(this.parseExportSpecifier(n2, r2, t2, i2));
            }
            return e2;
          }
          parseExportSpecifier(t2, e2, s2, i2) {
            return this.eatContextual(93) ? t2.exported = this.parseModuleExportName() : e2 ? t2.exported = Ri(t2.local) : t2.exported || (t2.exported = $2(t2.local)), this.finishNode(t2, "ExportSpecifier");
          }
          parseModuleExportName() {
            if (this.match(133)) {
              let t2 = this.parseStringLiteral(this.state.value), e2 = nr2.exec(t2.value);
              return e2 && this.raise(p2.ModuleExportNameHasLoneSurrogate, t2, { surrogateCharCode: e2[0].charCodeAt(0) }), t2;
            }
            return this.parseIdentifier(true);
          }
          isJSONModuleImport(t2) {
            return t2.assertions != null ? t2.assertions.some(({ key: e2, value: s2 }) => s2.value === "json" && (e2.type === "Identifier" ? e2.name === "type" : e2.value === "type")) : false;
          }
          checkImportReflection(t2) {
            let { specifiers: e2 } = t2, s2 = e2.length === 1 ? e2[0].type : null;
            if (t2.phase === "source")
              s2 !== "ImportDefaultSpecifier" && this.raise(p2.SourcePhaseImportRequiresDefault, e2[0].loc.start);
            else if (t2.phase === "defer")
              s2 !== "ImportNamespaceSpecifier" && this.raise(p2.DeferImportRequiresNamespace, e2[0].loc.start);
            else if (t2.module) {
              var i2;
              s2 !== "ImportDefaultSpecifier" && this.raise(p2.ImportReflectionNotBinding, e2[0].loc.start), ((i2 = t2.assertions) == null ? void 0 : i2.length) > 0 && this.raise(p2.ImportReflectionHasAssertion, e2[0].loc.start);
            }
          }
          checkJSONModuleImport(t2) {
            if (this.isJSONModuleImport(t2) && t2.type !== "ExportAllDeclaration") {
              let { specifiers: e2 } = t2;
              if (e2 != null) {
                let s2 = e2.find((i2) => {
                  let r2;
                  if (i2.type === "ExportSpecifier" ? r2 = i2.local : i2.type === "ImportSpecifier" && (r2 = i2.imported), r2 !== void 0)
                    return r2.type === "Identifier" ? r2.name !== "default" : r2.value !== "default";
                });
                s2 !== void 0 && this.raise(p2.ImportJSONBindingNotDefault, s2.loc.start);
              }
            }
          }
          isPotentialImportPhase(t2) {
            return t2 ? false : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
          }
          applyImportPhase(t2, e2, s2, i2) {
            e2 || (s2 === "module" ? (this.expectPlugin("importReflection", i2), t2.module = true) : this.hasPlugin("importReflection") && (t2.module = false), s2 === "source" ? (this.expectPlugin("sourcePhaseImports", i2), t2.phase = "source") : s2 === "defer" ? (this.expectPlugin("deferredImportEvaluation", i2), t2.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (t2.phase = null));
          }
          parseMaybeImportPhase(t2, e2) {
            if (!this.isPotentialImportPhase(e2))
              return this.applyImportPhase(t2, e2, null), null;
            let s2 = this.parseIdentifier(true), { type: i2 } = this.state;
            return (M3(i2) ? i2 !== 98 || this.lookaheadCharCode() === 102 : i2 !== 12) ? (this.resetPreviousIdentifierLeadingComments(s2), this.applyImportPhase(t2, e2, s2.name, s2.loc.start), null) : (this.applyImportPhase(t2, e2, null), s2);
          }
          isPrecedingIdImportPhase(t2) {
            let { type: e2 } = this.state;
            return w2(e2) ? e2 !== 98 || this.lookaheadCharCode() === 102 : e2 !== 12;
          }
          parseImport(t2) {
            return this.match(133) ? this.parseImportSourceAndAttributes(t2) : this.parseImportSpecifiersAndAfter(t2, this.parseMaybeImportPhase(t2, false));
          }
          parseImportSpecifiersAndAfter(t2, e2) {
            t2.specifiers = [];
            let i2 = !this.maybeParseDefaultImportSpecifier(t2, e2) || this.eat(12), r2 = i2 && this.maybeParseStarImportSpecifier(t2);
            return i2 && !r2 && this.parseNamedImportSpecifiers(t2), this.expectContextual(98), this.parseImportSourceAndAttributes(t2);
          }
          parseImportSourceAndAttributes(t2) {
            var e2;
            return (e2 = t2.specifiers) != null || (t2.specifiers = []), t2.source = this.parseImportSource(), this.maybeParseImportAttributes(t2), this.checkImportReflection(t2), this.checkJSONModuleImport(t2), this.semicolon(), this.finishNode(t2, "ImportDeclaration");
          }
          parseImportSource() {
            return this.match(133) || this.unexpected(), this.parseExprAtom();
          }
          parseImportSpecifierLocal(t2, e2, s2) {
            e2.local = this.parseIdentifier(), t2.specifiers.push(this.finishImportSpecifier(e2, s2));
          }
          finishImportSpecifier(t2, e2, s2 = 8201) {
            return this.checkLVal(t2.local, { in: { type: e2 }, binding: s2 }), this.finishNode(t2, e2);
          }
          parseImportAttributes() {
            this.expect(5);
            let t2 = [], e2 = /* @__PURE__ */ new Set();
            do {
              if (this.match(8))
                break;
              let s2 = this.startNode(), i2 = this.state.value;
              if (e2.has(i2) && this.raise(p2.ModuleAttributesWithDuplicateKeys, this.state.startLoc, { key: i2 }), e2.add(i2), this.match(133) ? s2.key = this.parseStringLiteral(i2) : s2.key = this.parseIdentifier(true), this.expect(14), !this.match(133))
                throw this.raise(p2.ModuleAttributeInvalidValue, this.state.startLoc);
              s2.value = this.parseStringLiteral(this.state.value), t2.push(this.finishNode(s2, "ImportAttribute"));
            } while (this.eat(12));
            return this.expect(8), t2;
          }
          parseModuleAttributes() {
            let t2 = [], e2 = /* @__PURE__ */ new Set();
            do {
              let s2 = this.startNode();
              if (s2.key = this.parseIdentifier(true), s2.key.name !== "type" && this.raise(p2.ModuleAttributeDifferentFromType, s2.key), e2.has(s2.key.name) && this.raise(p2.ModuleAttributesWithDuplicateKeys, s2.key, { key: s2.key.name }), e2.add(s2.key.name), this.expect(14), !this.match(133))
                throw this.raise(p2.ModuleAttributeInvalidValue, this.state.startLoc);
              s2.value = this.parseStringLiteral(this.state.value), t2.push(this.finishNode(s2, "ImportAttribute"));
            } while (this.eat(12));
            return t2;
          }
          maybeParseImportAttributes(t2) {
            let e2, s2 = false;
            if (this.match(76)) {
              if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
                return;
              this.next(), this.hasPlugin("moduleAttributes") ? e2 = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), e2 = this.parseImportAttributes()), s2 = true;
            } else if (this.isContextual(94) && !this.hasPrecedingLineBreak())
              this.hasPlugin("importAttributes") ? (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== true && this.raise(p2.ImportAttributesUseAssert, this.state.startLoc), this.addExtra(t2, "deprecatedAssertSyntax", true)) : this.expectOnePlugin(["importAttributes", "importAssertions"]), this.next(), e2 = this.parseImportAttributes();
            else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions"))
              e2 = [];
            else if (this.hasPlugin("moduleAttributes"))
              e2 = [];
            else
              return;
            !s2 && this.hasPlugin("importAssertions") ? t2.assertions = e2 : t2.attributes = e2;
          }
          maybeParseDefaultImportSpecifier(t2, e2) {
            if (e2) {
              let s2 = this.startNodeAtNode(e2);
              return s2.local = e2, t2.specifiers.push(this.finishImportSpecifier(s2, "ImportDefaultSpecifier")), true;
            } else if (M3(this.state.type))
              return this.parseImportSpecifierLocal(t2, this.startNode(), "ImportDefaultSpecifier"), true;
            return false;
          }
          maybeParseStarImportSpecifier(t2) {
            if (this.match(55)) {
              let e2 = this.startNode();
              return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(t2, e2, "ImportNamespaceSpecifier"), true;
            }
            return false;
          }
          parseNamedImportSpecifiers(t2) {
            let e2 = true;
            for (this.expect(5); !this.eat(8); ) {
              if (e2)
                e2 = false;
              else {
                if (this.eat(14))
                  throw this.raise(p2.DestructureNamedImport, this.state.startLoc);
                if (this.expect(12), this.eat(8))
                  break;
              }
              let s2 = this.startNode(), i2 = this.match(133), r2 = this.isContextual(130);
              s2.imported = this.parseModuleExportName();
              let n2 = this.parseImportSpecifier(s2, i2, t2.importKind === "type" || t2.importKind === "typeof", r2, void 0);
              t2.specifiers.push(n2);
            }
          }
          parseImportSpecifier(t2, e2, s2, i2, r2) {
            if (this.eatContextual(93))
              t2.local = this.parseIdentifier();
            else {
              let { imported: n2 } = t2;
              if (e2)
                throw this.raise(p2.ImportBindingIsString, t2, { importName: n2.value });
              this.checkReservedWord(n2.name, t2.loc.start, true, true), t2.local || (t2.local = $2(n2));
            }
            return this.finishImportSpecifier(t2, "ImportSpecifier", r2);
          }
          isThisParam(t2) {
            return t2.type === "Identifier" && t2.name === "this";
          }
        }, Me3 = class extends pt3 {
          constructor(t2, e2) {
            t2 = rr2(t2), super(t2, e2), this.options = t2, this.initializeScopes(), this.plugins = hr2(this.options.plugins), this.filename = t2.sourceFilename;
          }
          getScopeHandler() {
            return me2;
          }
          parse() {
            this.enterInitialScopes();
            let t2 = this.startNode(), e2 = this.startNode();
            return this.nextToken(), t2.errors = null, this.parseTopLevel(t2, e2), t2.errors = this.state.errors, t2.comments.length = this.state.commentsLen, t2;
          }
        };
        function hr2(a2) {
          let t2 = /* @__PURE__ */ new Map();
          for (let e2 of a2) {
            let [s2, i2] = Array.isArray(e2) ? e2 : [e2, {}];
            t2.has(s2) || t2.set(s2, i2 || {});
          }
          return t2;
        }
        function lr3(a2, t2) {
          var e2;
          if (((e2 = t2) == null ? void 0 : e2.sourceType) === "unambiguous") {
            t2 = Object.assign({}, t2);
            try {
              t2.sourceType = "module";
              let s2 = pe2(t2, a2), i2 = s2.parse();
              if (s2.sawUnambiguousESM)
                return i2;
              if (s2.ambiguousScriptDifferentAst)
                try {
                  return t2.sourceType = "script", pe2(t2, a2).parse();
                } catch {
                }
              else
                i2.program.sourceType = "script";
              return i2;
            } catch (s2) {
              try {
                return t2.sourceType = "script", pe2(t2, a2).parse();
              } catch {
              }
              throw s2;
            }
          } else
            return pe2(t2, a2).parse();
        }
        function cr3(a2, t2) {
          let e2 = pe2(t2, a2);
          return e2.options.strictMode && (e2.state.strict = true), e2.getExpression();
        }
        function pr3(a2) {
          let t2 = {};
          for (let e2 of Object.keys(a2))
            t2[e2] = R3(a2[e2]);
          return t2;
        }
        var ur3 = pr3(ni2);
        function pe2(a2, t2) {
          let e2 = Me3;
          return a2 != null && a2.plugins && (sr3(a2.plugins), e2 = fr3(a2.plugins)), new e2(a2, t2);
        }
        var Kt2 = {};
        function fr3(a2) {
          let t2 = ir3.filter((i2) => N2(a2, i2)), e2 = t2.join("/"), s2 = Kt2[e2];
          if (!s2) {
            s2 = Me3;
            for (let i2 of t2)
              s2 = hs[i2](s2);
            Kt2[e2] = s2;
          }
          return s2;
        }
        xe3.parse = lr3;
        xe3.parseExpression = cr3;
        xe3.tokTypes = ur3;
      });
      var Zr2 = {};
      Ws2(Zr2, { parsers: () => Qr2 });
      var je2 = vt2(At3(), 1);
      function Oe3(a2) {
        return (t2, e2, s2) => {
          let i2 = !!(s2 != null && s2.backwards);
          if (e2 === false)
            return false;
          let { length: r2 } = t2, n2 = e2;
          for (; n2 >= 0 && n2 < r2; ) {
            let o2 = t2.charAt(n2);
            if (a2 instanceof RegExp) {
              if (!a2.test(o2))
                return n2;
            } else if (!a2.includes(o2))
              return n2;
            i2 ? n2-- : n2++;
          }
          return n2 === -1 || n2 === r2 ? n2 : false;
        };
      }
      var ha2 = Oe3(/\s/u), ls = Oe3(" 	"), la2 = Oe3(",; 	"), cs = Oe3(/[^\n\r]/u);
      function dr3(a2, t2) {
        if (t2 === false)
          return false;
        if (a2.charAt(t2) === "/" && a2.charAt(t2 + 1) === "*") {
          for (let e2 = t2 + 2; e2 < a2.length; ++e2)
            if (a2.charAt(e2) === "*" && a2.charAt(e2 + 1) === "/")
              return e2 + 2;
        }
        return t2;
      }
      var ps = dr3;
      function mr2(a2, t2, e2) {
        let s2 = !!(e2 != null && e2.backwards);
        if (t2 === false)
          return false;
        let i2 = a2.charAt(t2);
        if (s2) {
          if (a2.charAt(t2 - 1) === "\r" && i2 === `
`)
            return t2 - 2;
          if (i2 === `
` || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
            return t2 - 1;
        } else {
          if (i2 === "\r" && a2.charAt(t2 + 1) === `
`)
            return t2 + 2;
          if (i2 === `
` || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
            return t2 + 1;
        }
        return t2;
      }
      var us = mr2;
      function yr3(a2, t2) {
        return t2 === false ? false : a2.charAt(t2) === "/" && a2.charAt(t2 + 1) === "/" ? cs(a2, t2) : t2;
      }
      var fs = yr3;
      function xr3(a2, t2) {
        let e2 = null, s2 = t2;
        for (; s2 !== e2; )
          e2 = s2, s2 = ls(a2, s2), s2 = ps(a2, s2), s2 = fs(a2, s2), s2 = us(a2, s2);
        return s2;
      }
      var ds = xr3;
      function Pr2(a2) {
        let t2 = [];
        for (let e2 of a2)
          try {
            return e2();
          } catch (s2) {
            t2.push(s2);
          }
        throw Object.assign(new Error("All combinations failed"), { errors: t2 });
      }
      var ms = Pr2;
      function gr3(a2) {
        if (!a2.startsWith("#!"))
          return "";
        let t2 = a2.indexOf(`
`);
        return t2 === -1 ? a2 : a2.slice(0, t2);
      }
      var Fe3 = gr3;
      var Tr2 = (a2, t2, e2) => {
        if (!(a2 && t2 == null))
          return Array.isArray(t2) || typeof t2 == "string" ? t2[e2 < 0 ? t2.length + e2 : e2] : t2.at(e2);
      }, St3 = Tr2;
      function br3(a2) {
        return Array.isArray(a2) && a2.length > 0;
      }
      var Pe3 = br3;
      function D(a2) {
        var s2, i2, r2;
        let t2 = ((s2 = a2.range) == null ? void 0 : s2[0]) ?? a2.start, e2 = (r2 = ((i2 = a2.declaration) == null ? void 0 : i2.decorators) ?? a2.decorators) == null ? void 0 : r2[0];
        return e2 ? Math.min(D(e2), t2) : t2;
      }
      function B2(a2) {
        var t2;
        return ((t2 = a2.range) == null ? void 0 : t2[1]) ?? a2.end;
      }
      function Ar3(a2) {
        let t2 = new Set(a2);
        return (e2) => t2.has(e2 == null ? void 0 : e2.type);
      }
      var ys = Ar3;
      var Sr2 = ys(["Block", "CommentBlock", "MultiLine"]), ge2 = Sr2;
      function wr2(a2) {
        let t2 = `*${a2.value}*`.split(`
`);
        return t2.length > 1 && t2.every((e2) => e2.trimStart()[0] === "*");
      }
      var wt3 = wr2;
      function Cr2(a2) {
        return ge2(a2) && a2.value[0] === "*" && /@(?:type|satisfies)\b/u.test(a2.value);
      }
      var xs = Cr2;
      var Te2 = null;
      function be3(a2) {
        if (Te2 !== null && typeof Te2.property) {
          let t2 = Te2;
          return Te2 = be3.prototype = null, t2;
        }
        return Te2 = be3.prototype = a2 ?? /* @__PURE__ */ Object.create(null), new be3();
      }
      var Er2 = 10;
      for (let a2 = 0; a2 <= Er2; a2++)
        be3();
      function Ct(a2) {
        return be3(a2);
      }
      function Ir2(a2, t2 = "type") {
        Ct(a2);
        function e2(s2) {
          let i2 = s2[t2], r2 = a2[i2];
          if (!Array.isArray(r2))
            throw Object.assign(new Error(`Missing visitor keys for '${i2}'.`), { node: s2 });
          return r2;
        }
        return e2;
      }
      var Ps2 = Ir2;
      var gs = { ArrayExpression: ["elements"], AssignmentExpression: ["left", "right"], BinaryExpression: ["left", "right"], InterpreterDirective: [], Directive: ["value"], DirectiveLiteral: [], BlockStatement: ["directives", "body"], BreakStatement: ["label"], CallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], CatchClause: ["param", "body"], ConditionalExpression: ["test", "consequent", "alternate"], ContinueStatement: ["label"], DebuggerStatement: [], DoWhileStatement: ["test", "body"], EmptyStatement: [], ExpressionStatement: ["expression"], File: ["program"], ForInStatement: ["left", "right", "body"], ForStatement: ["init", "test", "update", "body"], FunctionDeclaration: ["id", "params", "body", "returnType", "typeParameters", "predicate"], FunctionExpression: ["id", "params", "body", "returnType", "typeParameters"], Identifier: ["typeAnnotation", "decorators"], IfStatement: ["test", "consequent", "alternate"], LabeledStatement: ["label", "body"], StringLiteral: [], NumericLiteral: [], NullLiteral: [], BooleanLiteral: [], RegExpLiteral: [], LogicalExpression: ["left", "right"], MemberExpression: ["object", "property"], NewExpression: ["callee", "arguments", "typeParameters", "typeArguments"], Program: ["directives", "body"], ObjectExpression: ["properties"], ObjectMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectProperty: ["key", "value", "decorators"], RestElement: ["argument", "typeAnnotation", "decorators"], ReturnStatement: ["argument"], SequenceExpression: ["expressions"], ParenthesizedExpression: ["expression"], SwitchCase: ["test", "consequent"], SwitchStatement: ["discriminant", "cases"], ThisExpression: [], ThrowStatement: ["argument"], TryStatement: ["block", "handler", "finalizer"], UnaryExpression: ["argument"], UpdateExpression: ["argument"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id", "init"], WhileStatement: ["test", "body"], WithStatement: ["object", "body"], AssignmentPattern: ["left", "right", "decorators", "typeAnnotation"], ArrayPattern: ["elements", "typeAnnotation", "decorators"], ArrowFunctionExpression: ["params", "body", "returnType", "typeParameters", "predicate"], ClassBody: ["body"], ClassExpression: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ClassDeclaration: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ExportAllDeclaration: ["source", "attributes", "exported"], ExportDefaultDeclaration: ["declaration"], ExportNamedDeclaration: ["declaration", "specifiers", "source", "attributes"], ExportSpecifier: ["local", "exported"], ForOfStatement: ["left", "right", "body"], ImportDeclaration: ["specifiers", "source", "attributes"], ImportDefaultSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportSpecifier: ["local", "imported"], ImportExpression: ["source", "options", "attributes"], MetaProperty: ["meta", "property"], ClassMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectPattern: ["properties", "typeAnnotation", "decorators"], SpreadElement: ["argument"], Super: [], TaggedTemplateExpression: ["tag", "quasi", "typeParameters", "typeArguments"], TemplateElement: [], TemplateLiteral: ["quasis", "expressions"], YieldExpression: ["argument"], AwaitExpression: ["argument"], Import: [], BigIntLiteral: [], ExportNamespaceSpecifier: ["exported"], OptionalMemberExpression: ["object", "property"], OptionalCallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], ClassProperty: ["key", "value", "typeAnnotation", "decorators", "variance"], ClassAccessorProperty: ["key", "value", "typeAnnotation", "decorators"], ClassPrivateProperty: ["key", "value", "decorators", "typeAnnotation", "variance"], ClassPrivateMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], PrivateName: ["id"], StaticBlock: ["body"], AnyTypeAnnotation: [], ArrayTypeAnnotation: ["elementType"], BooleanTypeAnnotation: [], BooleanLiteralTypeAnnotation: [], NullLiteralTypeAnnotation: [], ClassImplements: ["id", "typeParameters"], DeclareClass: ["id", "typeParameters", "extends", "mixins", "implements", "body"], DeclareFunction: ["id", "predicate"], DeclareInterface: ["id", "typeParameters", "extends", "body"], DeclareModule: ["id", "body"], DeclareModuleExports: ["typeAnnotation"], DeclareTypeAlias: ["id", "typeParameters", "right"], DeclareOpaqueType: ["id", "typeParameters", "supertype"], DeclareVariable: ["id"], DeclareExportDeclaration: ["declaration", "specifiers", "source"], DeclareExportAllDeclaration: ["source"], DeclaredPredicate: ["value"], ExistsTypeAnnotation: [], FunctionTypeAnnotation: ["typeParameters", "params", "rest", "returnType", "this"], FunctionTypeParam: ["name", "typeAnnotation"], GenericTypeAnnotation: ["id", "typeParameters"], InferredPredicate: [], InterfaceExtends: ["id", "typeParameters"], InterfaceDeclaration: ["id", "typeParameters", "extends", "body"], InterfaceTypeAnnotation: ["extends", "body"], IntersectionTypeAnnotation: ["types"], MixedTypeAnnotation: [], EmptyTypeAnnotation: [], NullableTypeAnnotation: ["typeAnnotation"], NumberLiteralTypeAnnotation: [], NumberTypeAnnotation: [], ObjectTypeAnnotation: ["properties", "indexers", "callProperties", "internalSlots"], ObjectTypeInternalSlot: ["id", "value"], ObjectTypeCallProperty: ["value"], ObjectTypeIndexer: ["id", "key", "value", "variance"], ObjectTypeProperty: ["key", "value", "variance"], ObjectTypeSpreadProperty: ["argument"], OpaqueType: ["id", "typeParameters", "supertype", "impltype"], QualifiedTypeIdentifier: ["id", "qualification"], StringLiteralTypeAnnotation: [], StringTypeAnnotation: [], SymbolTypeAnnotation: [], ThisTypeAnnotation: [], TupleTypeAnnotation: ["types", "elementTypes"], TypeofTypeAnnotation: ["argument", "typeArguments"], TypeAlias: ["id", "typeParameters", "right"], TypeAnnotation: ["typeAnnotation"], TypeCastExpression: ["expression", "typeAnnotation"], TypeParameter: ["bound", "default", "variance"], TypeParameterDeclaration: ["params"], TypeParameterInstantiation: ["params"], UnionTypeAnnotation: ["types"], Variance: [], VoidTypeAnnotation: [], EnumDeclaration: ["id", "body"], EnumBooleanBody: ["members"], EnumNumberBody: ["members"], EnumStringBody: ["members"], EnumSymbolBody: ["members"], EnumBooleanMember: ["id", "init"], EnumNumberMember: ["id", "init"], EnumStringMember: ["id", "init"], EnumDefaultedMember: ["id"], IndexedAccessType: ["objectType", "indexType"], OptionalIndexedAccessType: ["objectType", "indexType"], JSXAttribute: ["name", "value"], JSXClosingElement: ["name"], JSXElement: ["openingElement", "children", "closingElement"], JSXEmptyExpression: [], JSXExpressionContainer: ["expression"], JSXSpreadChild: ["expression"], JSXIdentifier: [], JSXMemberExpression: ["object", "property"], JSXNamespacedName: ["namespace", "name"], JSXOpeningElement: ["name", "attributes", "typeArguments", "typeParameters"], JSXSpreadAttribute: ["argument"], JSXText: [], JSXFragment: ["openingFragment", "children", "closingFragment"], JSXOpeningFragment: [], JSXClosingFragment: [], Noop: [], Placeholder: [], V8IntrinsicIdentifier: [], ArgumentPlaceholder: [], BindExpression: ["object", "callee"], ImportAttribute: ["key", "value"], Decorator: ["expression"], DoExpression: ["body"], ExportDefaultSpecifier: ["exported"], RecordExpression: ["properties"], TupleExpression: ["elements"], DecimalLiteral: [], ModuleExpression: ["body"], TopicReference: [], PipelineTopicExpression: ["expression"], PipelineBareFunction: ["callee"], PipelinePrimaryTopicReference: [], TSParameterProperty: ["parameter", "decorators"], TSDeclareFunction: ["id", "typeParameters", "params", "returnType", "body"], TSDeclareMethod: ["decorators", "key", "typeParameters", "params", "returnType"], TSQualifiedName: ["left", "right"], TSCallSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSPropertySignature: ["key", "typeAnnotation"], TSMethodSignature: ["key", "typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSIndexSignature: ["parameters", "typeAnnotation"], TSAnyKeyword: [], TSBooleanKeyword: [], TSBigIntKeyword: [], TSIntrinsicKeyword: [], TSNeverKeyword: [], TSNullKeyword: [], TSNumberKeyword: [], TSObjectKeyword: [], TSStringKeyword: [], TSSymbolKeyword: [], TSUndefinedKeyword: [], TSUnknownKeyword: [], TSVoidKeyword: [], TSThisType: [], TSFunctionType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructorType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSTypeReference: ["typeName", "typeParameters", "typeArguments"], TSTypePredicate: ["parameterName", "typeAnnotation"], TSTypeQuery: ["exprName", "typeParameters", "typeArguments"], TSTypeLiteral: ["members"], TSArrayType: ["elementType"], TSTupleType: ["elementTypes"], TSOptionalType: ["typeAnnotation"], TSRestType: ["typeAnnotation"], TSNamedTupleMember: ["label", "elementType"], TSUnionType: ["types"], TSIntersectionType: ["types"], TSConditionalType: ["checkType", "extendsType", "trueType", "falseType"], TSInferType: ["typeParameter"], TSParenthesizedType: ["typeAnnotation"], TSTypeOperator: ["typeAnnotation"], TSIndexedAccessType: ["objectType", "indexType"], TSMappedType: ["typeParameter", "typeAnnotation", "nameType"], TSLiteralType: ["literal"], TSExpressionWithTypeArguments: ["expression", "typeParameters"], TSInterfaceDeclaration: ["id", "typeParameters", "extends", "body"], TSInterfaceBody: ["body"], TSTypeAliasDeclaration: ["id", "typeParameters", "typeAnnotation"], TSInstantiationExpression: ["expression", "typeParameters", "typeArguments"], TSAsExpression: ["expression", "typeAnnotation"], TSSatisfiesExpression: ["expression", "typeAnnotation"], TSTypeAssertion: ["typeAnnotation", "expression"], TSEnumDeclaration: ["id", "members"], TSEnumMember: ["id", "initializer"], TSModuleDeclaration: ["id", "body"], TSModuleBlock: ["body"], TSImportType: ["argument", "qualifier", "typeParameters", "typeArguments"], TSImportEqualsDeclaration: ["id", "moduleReference"], TSExternalModuleReference: ["expression"], TSNonNullExpression: ["expression"], TSExportAssignment: ["expression"], TSNamespaceExportDeclaration: ["id"], TSTypeAnnotation: ["typeAnnotation"], TSTypeParameterInstantiation: ["params"], TSTypeParameterDeclaration: ["params"], TSTypeParameter: ["constraint", "default", "name"], ChainExpression: ["expression"], ExperimentalRestProperty: ["argument"], ExperimentalSpreadProperty: ["argument"], Literal: [], MethodDefinition: ["decorators", "key", "value"], PrivateIdentifier: [], Property: ["key", "value"], PropertyDefinition: ["decorators", "key", "typeAnnotation", "value", "variance"], AccessorProperty: ["decorators", "key", "typeAnnotation", "value"], TSAbstractAccessorProperty: ["decorators", "key", "typeAnnotation"], TSAbstractKeyword: [], TSAbstractMethodDefinition: ["key", "value"], TSAbstractPropertyDefinition: ["decorators", "key", "typeAnnotation"], TSAsyncKeyword: [], TSClassImplements: ["expression", "typeArguments", "typeParameters"], TSDeclareKeyword: [], TSEmptyBodyFunctionExpression: ["id", "typeParameters", "params", "returnType"], TSEnumBody: ["members"], TSExportKeyword: [], TSInterfaceHeritage: ["expression", "typeArguments", "typeParameters"], TSPrivateKeyword: [], TSProtectedKeyword: [], TSPublicKeyword: [], TSReadonlyKeyword: [], TSStaticKeyword: [], TSTemplateLiteralType: ["quasis", "types"], AsConstExpression: ["expression"], AsExpression: ["expression", "typeAnnotation"], BigIntLiteralTypeAnnotation: [], BigIntTypeAnnotation: [], ComponentDeclaration: ["id", "params", "body", "typeParameters", "rendersType"], ComponentParameter: ["name", "local"], ComponentTypeAnnotation: ["params", "rest", "typeParameters", "rendersType"], ComponentTypeParameter: ["name", "typeAnnotation"], ConditionalTypeAnnotation: ["checkType", "extendsType", "trueType", "falseType"], DeclareComponent: ["id", "params", "rest", "typeParameters", "rendersType"], DeclareEnum: ["id", "body"], DeclareHook: ["id"], DeclareNamespace: ["id", "body"], EnumBigIntBody: ["members"], EnumBigIntMember: ["id", "init"], HookDeclaration: ["id", "params", "body", "typeParameters", "returnType"], HookTypeAnnotation: ["params", "returnType", "rest", "typeParameters"], InferTypeAnnotation: ["typeParameter"], KeyofTypeAnnotation: ["argument"], ObjectTypeMappedTypeProperty: ["keyTparam", "propType", "sourceType", "variance"], QualifiedTypeofIdentifier: ["qualification", "id"], TupleTypeLabeledElement: ["label", "elementType", "variance"], TupleTypeSpreadElement: ["label", "typeAnnotation"], TypeOperator: ["typeAnnotation"], TypePredicate: ["parameterName", "typeAnnotation", "asserts"], NGRoot: ["node"], NGPipeExpression: ["left", "right", "arguments"], NGChainedExpression: ["expressions"], NGEmptyExpression: [], NGMicrosyntax: ["body"], NGMicrosyntaxKey: [], NGMicrosyntaxExpression: ["expression", "alias"], NGMicrosyntaxKeyedExpression: ["key", "expression"], NGMicrosyntaxLet: ["key", "value"], NGMicrosyntaxAs: ["key", "alias"], JsExpressionRoot: ["node"], JsonRoot: ["node"], TSJSDocAllType: [], TSJSDocUnknownType: [], TSJSDocNullableType: ["typeAnnotation"], TSJSDocNonNullableType: ["typeAnnotation"], NeverTypeAnnotation: [], UndefinedTypeAnnotation: [], UnknownTypeAnnotation: [], SatisfiesExpression: ["expression", "typeAnnotation"] };
      var Nr3 = Ps2(gs), Ts2 = Nr3;
      function Et3(a2, t2) {
        if (!(a2 !== null && typeof a2 == "object"))
          return a2;
        if (Array.isArray(a2)) {
          for (let s2 = 0; s2 < a2.length; s2++)
            a2[s2] = Et3(a2[s2], t2);
          return a2;
        }
        let e2 = Ts2(a2);
        for (let s2 = 0; s2 < e2.length; s2++)
          a2[e2[s2]] = Et3(a2[e2[s2]], t2);
        return t2(a2) || a2;
      }
      var Be3 = Et3;
      function kr3(a2, t2) {
        let { parser: e2, text: s2 } = t2;
        if (a2.type === "File" && a2.program.interpreter) {
          let { program: { interpreter: i2 }, comments: r2 } = a2;
          delete a2.program.interpreter, r2.unshift(i2);
        }
        if (e2 === "babel") {
          let i2 = /* @__PURE__ */ new Set();
          a2 = Be3(a2, (r2) => {
            var n2;
            (n2 = r2.leadingComments) != null && n2.some(xs) && i2.add(D(r2));
          }), a2 = Be3(a2, (r2) => {
            if (r2.type === "ParenthesizedExpression") {
              let { expression: n2 } = r2;
              if (n2.type === "TypeCastExpression")
                return n2.range = [...r2.range], n2;
              let o2 = D(r2);
              if (!i2.has(o2))
                return n2.extra = { ...n2.extra, parenthesized: true }, n2;
            }
          });
        }
        if (a2 = Be3(a2, (i2) => {
          var r2;
          switch (i2.type) {
            case "LogicalExpression":
              if (bs2(i2))
                return It2(i2);
              break;
            case "VariableDeclaration": {
              let n2 = St3(false, i2.declarations, -1);
              n2 != null && n2.init && s2[B2(n2)] !== ";" && (i2.range = [D(i2), B2(n2)]);
              break;
            }
            case "TSParenthesizedType":
              return i2.typeAnnotation;
            case "TSTypeParameter":
              if (typeof i2.name == "string") {
                let n2 = D(i2);
                i2.name = { type: "Identifier", name: i2.name, range: [n2, n2 + i2.name.length] };
              }
              break;
            case "TopicReference":
              a2.extra = { ...a2.extra, __isUsingHackPipeline: true };
              break;
            case "ExportAllDeclaration":
              if (e2 === "meriyah" && ((r2 = i2.exported) == null ? void 0 : r2.type) === "Identifier") {
                let { exported: n2 } = i2, o2 = s2.slice(D(n2), B2(n2));
                (o2.startsWith('"') || o2.startsWith("'")) && (i2.exported = { ...i2.exported, type: "Literal", value: i2.exported.name, raw: o2 });
              }
              break;
            case "TSUnionType":
            case "TSIntersectionType":
              if (i2.types.length === 1)
                return i2.types[0];
              break;
          }
        }), Pe3(a2.comments)) {
          let i2 = St3(false, a2.comments, -1);
          for (let r2 = a2.comments.length - 2; r2 >= 0; r2--) {
            let n2 = a2.comments[r2];
            B2(n2) === D(i2) && ge2(n2) && ge2(i2) && wt3(n2) && wt3(i2) && (a2.comments.splice(r2 + 1, 1), n2.value += "*//*" + i2.value, n2.range = [D(n2), B2(i2)]), i2 = n2;
          }
        }
        return a2.type === "Program" && (a2.range = [0, s2.length]), a2;
      }
      function bs2(a2) {
        return a2.type === "LogicalExpression" && a2.right.type === "LogicalExpression" && a2.operator === a2.right.operator;
      }
      function It2(a2) {
        return bs2(a2) ? It2({ type: "LogicalExpression", operator: a2.operator, left: It2({ type: "LogicalExpression", operator: a2.operator, left: a2.left, right: a2.right.left, range: [D(a2.left), B2(a2.right.left)] }), right: a2.right.right, range: [D(a2), B2(a2)] }) : a2;
      }
      var As2 = kr3;
      function vr3(a2, t2) {
        let e2 = new SyntaxError(a2 + " (" + t2.loc.start.line + ":" + t2.loc.start.column + ")");
        return Object.assign(e2, t2);
      }
      var Re3 = vr3;
      function Lr3(a2) {
        let { message: t2, loc: { line: e2, column: s2 }, reasonCode: i2 } = a2, r2 = a2;
        (i2 === "MissingPlugin" || i2 === "MissingOneOfPlugins") && (t2 = "Unexpected token.", r2 = void 0);
        let n2 = ` (${e2}:${s2})`;
        return t2.endsWith(n2) && (t2 = t2.slice(0, -n2.length)), Re3(t2, { loc: { start: { line: e2, column: s2 + 1 } }, cause: r2 });
      }
      var Ue2 = Lr3;
      var Dr2 = (a2, t2, e2, s2) => {
        if (!(a2 && t2 == null))
          return t2.replaceAll ? t2.replaceAll(e2, s2) : e2.global ? t2.replace(e2, s2) : t2.split(e2).join(s2);
      }, ie2 = Dr2;
      var Mr2 = /\*\/$/, Or2 = /^\/\*\*?/, Fr2 = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, Br2 = /(^|\s+)\/\/([^\n\r]*)/g, Ss2 = /^(\r?\n)+/, Rr2 = /(?:^|\r?\n) *(@[^\n\r]*?) *\r?\n *(?![^\n\r@]*\/\/[^]*)([^\s@][^\n\r@]+?) *\r?\n/g, ws = /(?:^|\r?\n) *@(\S+) *([^\n\r]*)/g, Ur2 = /(\r?\n|^) *\* ?/g, _r3 = [];
      function Cs2(a2) {
        let t2 = a2.match(Fr2);
        return t2 ? t2[0].trimStart() : "";
      }
      function Es2(a2) {
        let t2 = `
`;
        a2 = ie2(false, a2.replace(Or2, "").replace(Mr2, ""), Ur2, "$1");
        let e2 = "";
        for (; e2 !== a2; )
          e2 = a2, a2 = ie2(false, a2, Rr2, `${t2}$1 $2${t2}`);
        a2 = a2.replace(Ss2, "").trimEnd();
        let s2 = /* @__PURE__ */ Object.create(null), i2 = ie2(false, a2, ws, "").replace(Ss2, "").trimEnd(), r2;
        for (; r2 = ws.exec(a2); ) {
          let n2 = ie2(false, r2[2], Br2, "");
          if (typeof s2[r2[1]] == "string" || Array.isArray(s2[r2[1]])) {
            let o2 = s2[r2[1]];
            s2[r2[1]] = [..._r3, ...Array.isArray(o2) ? o2 : [o2], n2];
          } else
            s2[r2[1]] = n2;
        }
        return { comments: i2, pragmas: s2 };
      }
      function jr3(a2) {
        let t2 = Fe3(a2);
        t2 && (a2 = a2.slice(t2.length + 1));
        let e2 = Cs2(a2), { pragmas: s2, comments: i2 } = Es2(e2);
        return { shebang: t2, text: a2, pragmas: s2, comments: i2 };
      }
      function Is2(a2) {
        let { pragmas: t2 } = jr3(a2);
        return Object.prototype.hasOwnProperty.call(t2, "prettier") || Object.prototype.hasOwnProperty.call(t2, "format");
      }
      function $r3(a2) {
        return a2 = typeof a2 == "function" ? { parse: a2 } : a2, { astFormat: "estree", hasPragma: Is2, locStart: D, locEnd: B2, ...a2 };
      }
      var G3 = $r3;
      function Vr2(a2) {
        let { filepath: t2 } = a2;
        if (t2) {
          if (t2 = t2.toLowerCase(), t2.endsWith(".cjs"))
            return "script";
          if (t2.endsWith(".mjs"))
            return "module";
        }
      }
      var Ns = Vr2;
      function qr2(a2, t2) {
        let { type: e2 = "JsExpressionRoot", rootMarker: s2, text: i2 } = t2, { tokens: r2, comments: n2 } = a2;
        return delete a2.tokens, delete a2.comments, { tokens: r2, comments: n2, type: e2, node: a2, range: [0, i2.length], rootMarker: s2 };
      }
      var _e3 = qr2;
      var re3 = (a2) => G3(Jr2(a2)), zr2 = { sourceType: "module", allowImportExportEverywhere: true, allowReturnOutsideFunction: true, allowNewTargetOutsideFunction: true, allowSuperOutsideMethod: true, allowUndeclaredExports: true, errorRecovery: true, createParenthesizedExpressions: true, createImportExpressions: true, plugins: ["doExpressions", "exportDefaultFrom", "functionBind", "functionSent", "throwExpressions", "partialApplication", "decorators", "decimal", "moduleBlocks", "asyncDoExpressions", "destructuringPrivate", "decoratorAutoAccessors", "importReflection", "explicitResourceManagement", ["importAttributes", { deprecatedAssertSyntax: true }], "sourcePhaseImports", "deferredImportEvaluation", ["optionalChainingAssign", { version: "2023-07" }], "recordAndTuple"], tokens: true, ranges: true }, ks2 = "v8intrinsic", vs = [["pipelineOperator", { proposal: "hack", topicToken: "%" }], ["pipelineOperator", { proposal: "minimal" }], ["pipelineOperator", { proposal: "fsharp" }]], V2 = (a2, t2 = zr2) => ({ ...t2, plugins: [...t2.plugins, ...a2] }), Kr2 = /@(?:no)?flow\b/u;
      function Hr3(a2, t2) {
        var i2;
        if ((i2 = t2.filepath) != null && i2.endsWith(".js.flow"))
          return true;
        let e2 = Fe3(a2);
        e2 && (a2 = a2.slice(e2.length));
        let s2 = ds(a2, 0);
        return s2 !== false && (a2 = a2.slice(0, s2)), Kr2.test(a2);
      }
      function Wr2(a2, t2, e2) {
        let s2 = a2(t2, e2), i2 = s2.errors.find((r2) => !Xr2.has(r2.reasonCode));
        if (i2)
          throw i2;
        return s2;
      }
      function Jr2({ isExpression: a2 = false, optionsCombinations: t2 }) {
        return (e2, s2 = {}) => {
          if ((s2.parser === "babel" || s2.parser === "__babel_estree") && Hr3(e2, s2))
            return s2.parser = "babel-flow", Bs2.parse(e2, s2);
          let i2 = t2;
          (s2.__babelSourceType ?? Ns(s2)) === "script" && (i2 = i2.map((c2) => ({ ...c2, sourceType: "script" })));
          let n2 = /%[A-Z]/u.test(e2);
          e2.includes("|>") ? i2 = (n2 ? [...vs, ks2] : vs).flatMap((l2) => i2.map((u2) => V2([l2], u2))) : n2 && (i2 = i2.map((c2) => V2([ks2], c2)));
          let o2 = a2 ? je2.parseExpression : je2.parse, h2;
          try {
            h2 = ms(i2.map((c2) => () => Wr2(o2, e2, c2)));
          } catch ({ errors: [c2] }) {
            throw Ue2(c2);
          }
          return a2 && (h2 = _e3(h2, { text: e2, rootMarker: s2.rootMarker })), As2(h2, { parser: "babel", text: e2 });
        };
      }
      var Xr2 = /* @__PURE__ */ new Set(["StrictNumericEscape", "StrictWith", "StrictOctalLiteral", "StrictDelete", "StrictEvalArguments", "StrictEvalArgumentsBinding", "StrictFunction", "ForInOfLoopInitializer", "EmptyTypeArguments", "EmptyTypeParameters", "ConstructorHasTypeParameters", "UnsupportedParameterPropertyKind", "DecoratorExportClass", "ParamDupe", "InvalidDecimal", "RestTrailingComma", "UnsupportedParameterDecorator", "UnterminatedJsxContent", "UnexpectedReservedWord", "ModuleAttributesWithDuplicateKeys", "LineTerminatorBeforeArrow", "InvalidEscapeSequenceTemplate", "NonAbstractClassHasAbstractMethod", "OptionalTypeBeforeRequired", "PatternIsOptional", "OptionalBindingPattern", "DeclareClassFieldHasInitializer", "TypeImportCannotSpecifyDefaultAndNamed", "ConstructorClassField", "VarRedeclaration", "InvalidPrivateFieldResolution", "DuplicateExport"]), Fs2 = [V2(["jsx"])], Ls = re3({ optionsCombinations: Fs2 }), Ds2 = re3({ optionsCombinations: [V2(["jsx", "typescript"]), V2(["typescript"])] }), Ms2 = re3({ isExpression: true, optionsCombinations: [V2(["jsx"])] }), Os2 = re3({ isExpression: true, optionsCombinations: [V2(["typescript"])] }), Bs2 = re3({ optionsCombinations: [V2(["jsx", ["flow", { all: true, enums: true }], "flowComments"])] }), Gr3 = re3({ optionsCombinations: Fs2.map((a2) => V2(["estree"], a2)) }), Rs2 = { babel: Ls, "babel-flow": Bs2, "babel-ts": Ds2, __js_expression: Ms2, __ts_expression: Os2, __vue_expression: Ms2, __vue_ts_expression: Os2, __vue_event_binding: Ls, __vue_ts_event_binding: Ds2, __babel_estree: Gr3 };
      var Us2 = vt2(At3(), 1);
      function _s2(a2 = {}) {
        let { allowComments: t2 = true } = a2;
        return function(s2) {
          let i2;
          try {
            i2 = (0, Us2.parseExpression)(s2, { tokens: true, ranges: true, attachComment: false });
          } catch (r2) {
            throw Ue2(r2);
          }
          if (!t2 && Pe3(i2.comments))
            throw H3(i2.comments[0], "Comment");
          return ae2(i2), _e3(i2, { type: "JsonRoot", text: s2 });
        };
      }
      function H3(a2, t2) {
        let [e2, s2] = [a2.loc.start, a2.loc.end].map(({ line: i2, column: r2 }) => ({ line: i2, column: r2 + 1 }));
        return Re3(`${t2} is not allowed in JSON.`, { loc: { start: e2, end: s2 } });
      }
      function ae2(a2) {
        switch (a2.type) {
          case "ArrayExpression":
            for (let t2 of a2.elements)
              t2 !== null && ae2(t2);
            return;
          case "ObjectExpression":
            for (let t2 of a2.properties)
              ae2(t2);
            return;
          case "ObjectProperty":
            if (a2.computed)
              throw H3(a2.key, "Computed key");
            if (a2.shorthand)
              throw H3(a2.key, "Shorthand property");
            a2.key.type !== "Identifier" && ae2(a2.key), ae2(a2.value);
            return;
          case "UnaryExpression": {
            let { operator: t2, argument: e2 } = a2;
            if (t2 !== "+" && t2 !== "-")
              throw H3(a2, `Operator '${a2.operator}'`);
            if (e2.type === "NumericLiteral" || e2.type === "Identifier" && (e2.name === "Infinity" || e2.name === "NaN"))
              return;
            throw H3(e2, `Operator '${t2}' before '${e2.type}'`);
          }
          case "Identifier":
            if (a2.name !== "Infinity" && a2.name !== "NaN" && a2.name !== "undefined")
              throw H3(a2, `Identifier '${a2.name}'`);
            return;
          case "TemplateLiteral":
            if (Pe3(a2.expressions))
              throw H3(a2.expressions[0], "'TemplateLiteral' with expression");
            for (let t2 of a2.quasis)
              ae2(t2);
            return;
          case "NullLiteral":
          case "BooleanLiteral":
          case "NumericLiteral":
          case "StringLiteral":
          case "TemplateElement":
            return;
          default:
            throw H3(a2, `'${a2.type}'`);
        }
      }
      var Nt2 = _s2(), Yr3 = { json: G3({ parse: Nt2, hasPragma() {
        return true;
      } }), json5: G3(Nt2), jsonc: G3(Nt2), "json-stringify": G3({ parse: _s2({ allowComments: false }), astFormat: "estree-json" }) }, js2 = Yr3;
      var Qr2 = { ...Rs2, ...js2 };
      return Js2(Zr2);
    });
  }
});

// node_modules/@react-three/uikit/node_modules/prettier/plugins/estree.js
var require_estree = __commonJS({
  "node_modules/@react-three/uikit/node_modules/prettier/plugins/estree.js"(exports, module) {
    (function(f2) {
      function e2() {
        var i2 = f2();
        return i2.default || i2;
      }
      if (typeof exports == "object" && typeof module == "object")
        module.exports = e2();
      else if (typeof define == "function" && define.amd)
        define(e2);
      else {
        var t2 = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
        t2.prettierPlugins = t2.prettierPlugins || {}, t2.prettierPlugins.estree = e2();
      }
    })(function() {
      "use strict";
      var In2 = Object.defineProperty;
      var Wa = Object.getOwnPropertyDescriptor;
      var Ga = Object.getOwnPropertyNames;
      var Ua2 = Object.prototype.hasOwnProperty;
      var Js2 = (e2) => {
        throw TypeError(e2);
      };
      var Ar3 = (e2, t2) => {
        for (var r2 in t2)
          In2(e2, r2, { get: t2[r2], enumerable: true });
      }, Na2 = (e2, t2, r2, n2) => {
        if (t2 && typeof t2 == "object" || typeof t2 == "function")
          for (let s2 of Ga(t2))
            !Ua2.call(e2, s2) && s2 !== r2 && In2(e2, s2, { get: () => t2[s2], enumerable: !(n2 = Wa(t2, s2)) || n2.enumerable });
        return e2;
      };
      var Xa = (e2) => Na2(In2({}, "__esModule", { value: true }), e2);
      var qs2 = (e2, t2, r2) => t2.has(e2) || Js2("Cannot " + r2);
      var pt3 = (e2, t2, r2) => (qs2(e2, t2, "read from private field"), r2 ? r2.call(e2) : t2.get(e2)), Ws2 = (e2, t2, r2) => t2.has(e2) ? Js2("Cannot add the same private member more than once") : t2 instanceof WeakSet ? t2.add(e2) : t2.set(e2, r2), Gs2 = (e2, t2, r2, n2) => (qs2(e2, t2, "write to private field"), n2 ? n2.call(e2, r2) : t2.set(e2, r2), r2);
      var om = {};
      Ar3(om, { languages: () => am, options: () => va2, printers: () => im });
      var Us2 = [{ linguistLanguageId: 183, name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib", ".wxs"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell", "zx"], parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"] }, { linguistLanguageId: 183, name: "Flow", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: [], extensions: [".js.flow"], filenames: [], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"] }, { linguistLanguageId: 183, name: "JSX", type: "programming", tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0, aliases: void 0, extensions: [".jsx"], filenames: void 0, interpreters: void 0, parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], group: "JavaScript" }, { linguistLanguageId: 378, name: "TypeScript", type: "programming", color: "#3178c6", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts", ".cts", ".mts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"] }, { linguistLanguageId: 94901924, name: "TSX", type: "programming", color: "#3178c6", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] }];
      var Os2 = {};
      Ar3(Os2, { canAttachComment: () => Ap2, embed: () => Qu3, experimentalFeatures: () => em, getCommentChildNodes: () => Tp2, getVisitorKeys: () => gr3, handleComments: () => zn3, insertPragma: () => pi3, isBlockComment: () => re3, isGap: () => dp, massageAstNode: () => Cu3, print: () => Ia2, printComment: () => Pu2, willPrintOwnComments: () => Qn3 });
      var Ya = (e2, t2, r2, n2) => {
        if (!(e2 && t2 == null))
          return t2.replaceAll ? t2.replaceAll(r2, n2) : r2.global ? t2.replace(r2, n2) : t2.split(r2).join(n2);
      }, N2 = Ya;
      var Ha = (e2, t2, r2) => {
        if (!(e2 && t2 == null))
          return Array.isArray(t2) || typeof t2 == "string" ? t2[r2 < 0 ? t2.length + r2 : r2] : t2.at(r2);
      }, O2 = Ha;
      function Va(e2) {
        return e2 !== null && typeof e2 == "object";
      }
      var Ns = Va;
      function* $a2(e2, t2) {
        let { getVisitorKeys: r2, filter: n2 = () => true } = t2, s2 = (u2) => Ns(u2) && n2(u2);
        for (let u2 of r2(e2)) {
          let i2 = e2[u2];
          if (Array.isArray(i2))
            for (let a2 of i2)
              s2(a2) && (yield a2);
          else
            s2(i2) && (yield i2);
        }
      }
      function* Ka(e2, t2) {
        let r2 = [e2];
        for (let n2 = 0; n2 < r2.length; n2++) {
          let s2 = r2[n2];
          for (let u2 of $a2(s2, t2))
            yield u2, r2.push(u2);
        }
      }
      function Xs2(e2, { getVisitorKeys: t2, predicate: r2 }) {
        for (let n2 of Ka(e2, { getVisitorKeys: t2 }))
          if (r2(n2))
            return true;
        return false;
      }
      var Ys2 = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
      function Hs2(e2) {
        return e2 === 12288 || e2 >= 65281 && e2 <= 65376 || e2 >= 65504 && e2 <= 65510;
      }
      function Vs2(e2) {
        return e2 >= 4352 && e2 <= 4447 || e2 === 8986 || e2 === 8987 || e2 === 9001 || e2 === 9002 || e2 >= 9193 && e2 <= 9196 || e2 === 9200 || e2 === 9203 || e2 === 9725 || e2 === 9726 || e2 === 9748 || e2 === 9749 || e2 >= 9800 && e2 <= 9811 || e2 === 9855 || e2 === 9875 || e2 === 9889 || e2 === 9898 || e2 === 9899 || e2 === 9917 || e2 === 9918 || e2 === 9924 || e2 === 9925 || e2 === 9934 || e2 === 9940 || e2 === 9962 || e2 === 9970 || e2 === 9971 || e2 === 9973 || e2 === 9978 || e2 === 9981 || e2 === 9989 || e2 === 9994 || e2 === 9995 || e2 === 10024 || e2 === 10060 || e2 === 10062 || e2 >= 10067 && e2 <= 10069 || e2 === 10071 || e2 >= 10133 && e2 <= 10135 || e2 === 10160 || e2 === 10175 || e2 === 11035 || e2 === 11036 || e2 === 11088 || e2 === 11093 || e2 >= 11904 && e2 <= 11929 || e2 >= 11931 && e2 <= 12019 || e2 >= 12032 && e2 <= 12245 || e2 >= 12272 && e2 <= 12287 || e2 >= 12289 && e2 <= 12350 || e2 >= 12353 && e2 <= 12438 || e2 >= 12441 && e2 <= 12543 || e2 >= 12549 && e2 <= 12591 || e2 >= 12593 && e2 <= 12686 || e2 >= 12688 && e2 <= 12771 || e2 >= 12783 && e2 <= 12830 || e2 >= 12832 && e2 <= 12871 || e2 >= 12880 && e2 <= 19903 || e2 >= 19968 && e2 <= 42124 || e2 >= 42128 && e2 <= 42182 || e2 >= 43360 && e2 <= 43388 || e2 >= 44032 && e2 <= 55203 || e2 >= 63744 && e2 <= 64255 || e2 >= 65040 && e2 <= 65049 || e2 >= 65072 && e2 <= 65106 || e2 >= 65108 && e2 <= 65126 || e2 >= 65128 && e2 <= 65131 || e2 >= 94176 && e2 <= 94180 || e2 === 94192 || e2 === 94193 || e2 >= 94208 && e2 <= 100343 || e2 >= 100352 && e2 <= 101589 || e2 >= 101632 && e2 <= 101640 || e2 >= 110576 && e2 <= 110579 || e2 >= 110581 && e2 <= 110587 || e2 === 110589 || e2 === 110590 || e2 >= 110592 && e2 <= 110882 || e2 === 110898 || e2 >= 110928 && e2 <= 110930 || e2 === 110933 || e2 >= 110948 && e2 <= 110951 || e2 >= 110960 && e2 <= 111355 || e2 === 126980 || e2 === 127183 || e2 === 127374 || e2 >= 127377 && e2 <= 127386 || e2 >= 127488 && e2 <= 127490 || e2 >= 127504 && e2 <= 127547 || e2 >= 127552 && e2 <= 127560 || e2 === 127568 || e2 === 127569 || e2 >= 127584 && e2 <= 127589 || e2 >= 127744 && e2 <= 127776 || e2 >= 127789 && e2 <= 127797 || e2 >= 127799 && e2 <= 127868 || e2 >= 127870 && e2 <= 127891 || e2 >= 127904 && e2 <= 127946 || e2 >= 127951 && e2 <= 127955 || e2 >= 127968 && e2 <= 127984 || e2 === 127988 || e2 >= 127992 && e2 <= 128062 || e2 === 128064 || e2 >= 128066 && e2 <= 128252 || e2 >= 128255 && e2 <= 128317 || e2 >= 128331 && e2 <= 128334 || e2 >= 128336 && e2 <= 128359 || e2 === 128378 || e2 === 128405 || e2 === 128406 || e2 === 128420 || e2 >= 128507 && e2 <= 128591 || e2 >= 128640 && e2 <= 128709 || e2 === 128716 || e2 >= 128720 && e2 <= 128722 || e2 >= 128725 && e2 <= 128727 || e2 >= 128732 && e2 <= 128735 || e2 === 128747 || e2 === 128748 || e2 >= 128756 && e2 <= 128764 || e2 >= 128992 && e2 <= 129003 || e2 === 129008 || e2 >= 129292 && e2 <= 129338 || e2 >= 129340 && e2 <= 129349 || e2 >= 129351 && e2 <= 129535 || e2 >= 129648 && e2 <= 129660 || e2 >= 129664 && e2 <= 129672 || e2 >= 129680 && e2 <= 129725 || e2 >= 129727 && e2 <= 129733 || e2 >= 129742 && e2 <= 129755 || e2 >= 129760 && e2 <= 129768 || e2 >= 129776 && e2 <= 129784 || e2 >= 131072 && e2 <= 196605 || e2 >= 196608 && e2 <= 262141;
      }
      var $s2 = (e2) => !(Hs2(e2) || Vs2(e2));
      var za = /[^\x20-\x7F]/u;
      function Qa(e2) {
        if (!e2)
          return 0;
        if (!za.test(e2))
          return e2.length;
        e2 = e2.replace(Ys2(), "  ");
        let t2 = 0;
        for (let r2 of e2) {
          let n2 = r2.codePointAt(0);
          n2 <= 31 || n2 >= 127 && n2 <= 159 || n2 >= 768 && n2 <= 879 || (t2 += $s2(n2) ? 1 : 2);
        }
        return t2;
      }
      var et2 = Qa;
      function Tr2(e2) {
        return (t2, r2, n2) => {
          let s2 = !!(n2 != null && n2.backwards);
          if (r2 === false)
            return false;
          let { length: u2 } = t2, i2 = r2;
          for (; i2 >= 0 && i2 < u2; ) {
            let a2 = t2.charAt(i2);
            if (e2 instanceof RegExp) {
              if (!e2.test(a2))
                return i2;
            } else if (!e2.includes(a2))
              return i2;
            s2 ? i2-- : i2++;
          }
          return i2 === -1 || i2 === u2 ? i2 : false;
        };
      }
      var Bm = Tr2(/\s/u), Ge3 = Tr2(" 	"), Ks = Tr2(",; 	"), zs2 = Tr2(/[^\n\r]/u);
      function Za(e2, t2, r2) {
        let n2 = !!(r2 != null && r2.backwards);
        if (t2 === false)
          return false;
        let s2 = e2.charAt(t2);
        if (n2) {
          if (e2.charAt(t2 - 1) === "\r" && s2 === `
`)
            return t2 - 2;
          if (s2 === `
` || s2 === "\r" || s2 === "\u2028" || s2 === "\u2029")
            return t2 - 1;
        } else {
          if (s2 === "\r" && e2.charAt(t2 + 1) === `
`)
            return t2 + 2;
          if (s2 === `
` || s2 === "\r" || s2 === "\u2028" || s2 === "\u2029")
            return t2 + 1;
        }
        return t2;
      }
      var Ue2 = Za;
      function eo2(e2, t2, r2 = {}) {
        let n2 = Ge3(e2, r2.backwards ? t2 - 1 : t2, r2), s2 = Ue2(e2, n2, r2);
        return n2 !== s2;
      }
      var te2 = eo2;
      function to2(e2, t2) {
        if (t2 === false)
          return false;
        if (e2.charAt(t2) === "/" && e2.charAt(t2 + 1) === "*") {
          for (let r2 = t2 + 2; r2 < e2.length; ++r2)
            if (e2.charAt(r2) === "*" && e2.charAt(r2 + 1) === "/")
              return r2 + 2;
        }
        return t2;
      }
      var Lt2 = to2;
      function ro2(e2, t2) {
        return t2 === false ? false : e2.charAt(t2) === "/" && e2.charAt(t2 + 1) === "/" ? zs2(e2, t2) : t2;
      }
      var wt3 = ro2;
      function no2(e2, t2) {
        let r2 = null, n2 = t2;
        for (; n2 !== r2; )
          r2 = n2, n2 = Ks(e2, n2), n2 = Lt2(e2, n2), n2 = Ge3(e2, n2);
        return n2 = wt3(e2, n2), n2 = Ue2(e2, n2), n2 !== false && te2(e2, n2);
      }
      var Ot2 = no2;
      function so2(e2) {
        return Array.isArray(e2) && e2.length > 0;
      }
      var w2 = so2;
      var dr3 = "'", Qs2 = '"';
      function uo2(e2, t2) {
        let r2 = t2 === true || t2 === dr3 ? dr3 : Qs2, n2 = r2 === dr3 ? Qs2 : dr3, s2 = 0, u2 = 0;
        for (let i2 of e2)
          i2 === r2 ? s2++ : i2 === n2 && u2++;
        return s2 > u2 ? n2 : r2;
      }
      var xr3 = uo2;
      function io2(e2, t2, r2) {
        let n2 = t2 === '"' ? "'" : '"', u2 = N2(false, e2, /\\(.)|(["'])/gsu, (i2, a2, o2) => a2 === n2 ? a2 : o2 === t2 ? "\\" + o2 : o2 || (r2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(a2) ? a2 : "\\" + a2));
        return t2 + u2 + t2;
      }
      var Zs = io2;
      function ao2(e2, t2) {
        let r2 = e2.slice(1, -1), n2 = t2.parser === "json" || t2.parser === "jsonc" || t2.parser === "json5" && t2.quoteProps === "preserve" && !t2.singleQuote ? '"' : t2.__isInHtmlAttribute ? "'" : xr3(r2, t2.singleQuote);
        return Zs(r2, n2, !(t2.parser === "css" || t2.parser === "less" || t2.parser === "scss" || t2.__embeddedInHtml));
      }
      var tt2 = ao2;
      function R3(e2) {
        var n2, s2, u2;
        let t2 = ((n2 = e2.range) == null ? void 0 : n2[0]) ?? e2.start, r2 = (u2 = ((s2 = e2.declaration) == null ? void 0 : s2.decorators) ?? e2.decorators) == null ? void 0 : u2[0];
        return r2 ? Math.min(R3(r2), t2) : t2;
      }
      function k(e2) {
        var t2;
        return ((t2 = e2.range) == null ? void 0 : t2[1]) ?? e2.end;
      }
      function ht3(e2, t2) {
        let r2 = R3(e2);
        return Number.isInteger(r2) && r2 === R3(t2);
      }
      function oo2(e2, t2) {
        let r2 = k(e2);
        return Number.isInteger(r2) && r2 === k(t2);
      }
      function eu2(e2, t2) {
        return ht3(e2, t2) && oo2(e2, t2);
      }
      var Qt2 = null;
      function Zt(e2) {
        if (Qt2 !== null && typeof Qt2.property) {
          let t2 = Qt2;
          return Qt2 = Zt.prototype = null, t2;
        }
        return Qt2 = Zt.prototype = e2 ?? /* @__PURE__ */ Object.create(null), new Zt();
      }
      var po2 = 10;
      for (let e2 = 0; e2 <= po2; e2++)
        Zt();
      function Ln(e2) {
        return Zt(e2);
      }
      function co2(e2, t2 = "type") {
        Ln(e2);
        function r2(n2) {
          let s2 = n2[t2], u2 = e2[s2];
          if (!Array.isArray(u2))
            throw Object.assign(new Error(`Missing visitor keys for '${s2}'.`), { node: n2 });
          return u2;
        }
        return r2;
      }
      var hr2 = co2;
      var tu2 = { ArrayExpression: ["elements"], AssignmentExpression: ["left", "right"], BinaryExpression: ["left", "right"], InterpreterDirective: [], Directive: ["value"], DirectiveLiteral: [], BlockStatement: ["directives", "body"], BreakStatement: ["label"], CallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], CatchClause: ["param", "body"], ConditionalExpression: ["test", "consequent", "alternate"], ContinueStatement: ["label"], DebuggerStatement: [], DoWhileStatement: ["test", "body"], EmptyStatement: [], ExpressionStatement: ["expression"], File: ["program"], ForInStatement: ["left", "right", "body"], ForStatement: ["init", "test", "update", "body"], FunctionDeclaration: ["id", "params", "body", "returnType", "typeParameters", "predicate"], FunctionExpression: ["id", "params", "body", "returnType", "typeParameters"], Identifier: ["typeAnnotation", "decorators"], IfStatement: ["test", "consequent", "alternate"], LabeledStatement: ["label", "body"], StringLiteral: [], NumericLiteral: [], NullLiteral: [], BooleanLiteral: [], RegExpLiteral: [], LogicalExpression: ["left", "right"], MemberExpression: ["object", "property"], NewExpression: ["callee", "arguments", "typeParameters", "typeArguments"], Program: ["directives", "body"], ObjectExpression: ["properties"], ObjectMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectProperty: ["key", "value", "decorators"], RestElement: ["argument", "typeAnnotation", "decorators"], ReturnStatement: ["argument"], SequenceExpression: ["expressions"], ParenthesizedExpression: ["expression"], SwitchCase: ["test", "consequent"], SwitchStatement: ["discriminant", "cases"], ThisExpression: [], ThrowStatement: ["argument"], TryStatement: ["block", "handler", "finalizer"], UnaryExpression: ["argument"], UpdateExpression: ["argument"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id", "init"], WhileStatement: ["test", "body"], WithStatement: ["object", "body"], AssignmentPattern: ["left", "right", "decorators", "typeAnnotation"], ArrayPattern: ["elements", "typeAnnotation", "decorators"], ArrowFunctionExpression: ["params", "body", "returnType", "typeParameters", "predicate"], ClassBody: ["body"], ClassExpression: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ClassDeclaration: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ExportAllDeclaration: ["source", "attributes", "exported"], ExportDefaultDeclaration: ["declaration"], ExportNamedDeclaration: ["declaration", "specifiers", "source", "attributes"], ExportSpecifier: ["local", "exported"], ForOfStatement: ["left", "right", "body"], ImportDeclaration: ["specifiers", "source", "attributes"], ImportDefaultSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportSpecifier: ["local", "imported"], ImportExpression: ["source", "options", "attributes"], MetaProperty: ["meta", "property"], ClassMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectPattern: ["properties", "typeAnnotation", "decorators"], SpreadElement: ["argument"], Super: [], TaggedTemplateExpression: ["tag", "quasi", "typeParameters", "typeArguments"], TemplateElement: [], TemplateLiteral: ["quasis", "expressions"], YieldExpression: ["argument"], AwaitExpression: ["argument"], Import: [], BigIntLiteral: [], ExportNamespaceSpecifier: ["exported"], OptionalMemberExpression: ["object", "property"], OptionalCallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], ClassProperty: ["key", "value", "typeAnnotation", "decorators", "variance"], ClassAccessorProperty: ["key", "value", "typeAnnotation", "decorators"], ClassPrivateProperty: ["key", "value", "decorators", "typeAnnotation", "variance"], ClassPrivateMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], PrivateName: ["id"], StaticBlock: ["body"], AnyTypeAnnotation: [], ArrayTypeAnnotation: ["elementType"], BooleanTypeAnnotation: [], BooleanLiteralTypeAnnotation: [], NullLiteralTypeAnnotation: [], ClassImplements: ["id", "typeParameters"], DeclareClass: ["id", "typeParameters", "extends", "mixins", "implements", "body"], DeclareFunction: ["id", "predicate"], DeclareInterface: ["id", "typeParameters", "extends", "body"], DeclareModule: ["id", "body"], DeclareModuleExports: ["typeAnnotation"], DeclareTypeAlias: ["id", "typeParameters", "right"], DeclareOpaqueType: ["id", "typeParameters", "supertype"], DeclareVariable: ["id"], DeclareExportDeclaration: ["declaration", "specifiers", "source"], DeclareExportAllDeclaration: ["source"], DeclaredPredicate: ["value"], ExistsTypeAnnotation: [], FunctionTypeAnnotation: ["typeParameters", "params", "rest", "returnType", "this"], FunctionTypeParam: ["name", "typeAnnotation"], GenericTypeAnnotation: ["id", "typeParameters"], InferredPredicate: [], InterfaceExtends: ["id", "typeParameters"], InterfaceDeclaration: ["id", "typeParameters", "extends", "body"], InterfaceTypeAnnotation: ["extends", "body"], IntersectionTypeAnnotation: ["types"], MixedTypeAnnotation: [], EmptyTypeAnnotation: [], NullableTypeAnnotation: ["typeAnnotation"], NumberLiteralTypeAnnotation: [], NumberTypeAnnotation: [], ObjectTypeAnnotation: ["properties", "indexers", "callProperties", "internalSlots"], ObjectTypeInternalSlot: ["id", "value"], ObjectTypeCallProperty: ["value"], ObjectTypeIndexer: ["id", "key", "value", "variance"], ObjectTypeProperty: ["key", "value", "variance"], ObjectTypeSpreadProperty: ["argument"], OpaqueType: ["id", "typeParameters", "supertype", "impltype"], QualifiedTypeIdentifier: ["id", "qualification"], StringLiteralTypeAnnotation: [], StringTypeAnnotation: [], SymbolTypeAnnotation: [], ThisTypeAnnotation: [], TupleTypeAnnotation: ["types", "elementTypes"], TypeofTypeAnnotation: ["argument", "typeArguments"], TypeAlias: ["id", "typeParameters", "right"], TypeAnnotation: ["typeAnnotation"], TypeCastExpression: ["expression", "typeAnnotation"], TypeParameter: ["bound", "default", "variance"], TypeParameterDeclaration: ["params"], TypeParameterInstantiation: ["params"], UnionTypeAnnotation: ["types"], Variance: [], VoidTypeAnnotation: [], EnumDeclaration: ["id", "body"], EnumBooleanBody: ["members"], EnumNumberBody: ["members"], EnumStringBody: ["members"], EnumSymbolBody: ["members"], EnumBooleanMember: ["id", "init"], EnumNumberMember: ["id", "init"], EnumStringMember: ["id", "init"], EnumDefaultedMember: ["id"], IndexedAccessType: ["objectType", "indexType"], OptionalIndexedAccessType: ["objectType", "indexType"], JSXAttribute: ["name", "value"], JSXClosingElement: ["name"], JSXElement: ["openingElement", "children", "closingElement"], JSXEmptyExpression: [], JSXExpressionContainer: ["expression"], JSXSpreadChild: ["expression"], JSXIdentifier: [], JSXMemberExpression: ["object", "property"], JSXNamespacedName: ["namespace", "name"], JSXOpeningElement: ["name", "attributes", "typeArguments", "typeParameters"], JSXSpreadAttribute: ["argument"], JSXText: [], JSXFragment: ["openingFragment", "children", "closingFragment"], JSXOpeningFragment: [], JSXClosingFragment: [], Noop: [], Placeholder: [], V8IntrinsicIdentifier: [], ArgumentPlaceholder: [], BindExpression: ["object", "callee"], ImportAttribute: ["key", "value"], Decorator: ["expression"], DoExpression: ["body"], ExportDefaultSpecifier: ["exported"], RecordExpression: ["properties"], TupleExpression: ["elements"], DecimalLiteral: [], ModuleExpression: ["body"], TopicReference: [], PipelineTopicExpression: ["expression"], PipelineBareFunction: ["callee"], PipelinePrimaryTopicReference: [], TSParameterProperty: ["parameter", "decorators"], TSDeclareFunction: ["id", "typeParameters", "params", "returnType", "body"], TSDeclareMethod: ["decorators", "key", "typeParameters", "params", "returnType"], TSQualifiedName: ["left", "right"], TSCallSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSPropertySignature: ["key", "typeAnnotation"], TSMethodSignature: ["key", "typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSIndexSignature: ["parameters", "typeAnnotation"], TSAnyKeyword: [], TSBooleanKeyword: [], TSBigIntKeyword: [], TSIntrinsicKeyword: [], TSNeverKeyword: [], TSNullKeyword: [], TSNumberKeyword: [], TSObjectKeyword: [], TSStringKeyword: [], TSSymbolKeyword: [], TSUndefinedKeyword: [], TSUnknownKeyword: [], TSVoidKeyword: [], TSThisType: [], TSFunctionType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructorType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSTypeReference: ["typeName", "typeParameters", "typeArguments"], TSTypePredicate: ["parameterName", "typeAnnotation"], TSTypeQuery: ["exprName", "typeParameters", "typeArguments"], TSTypeLiteral: ["members"], TSArrayType: ["elementType"], TSTupleType: ["elementTypes"], TSOptionalType: ["typeAnnotation"], TSRestType: ["typeAnnotation"], TSNamedTupleMember: ["label", "elementType"], TSUnionType: ["types"], TSIntersectionType: ["types"], TSConditionalType: ["checkType", "extendsType", "trueType", "falseType"], TSInferType: ["typeParameter"], TSParenthesizedType: ["typeAnnotation"], TSTypeOperator: ["typeAnnotation"], TSIndexedAccessType: ["objectType", "indexType"], TSMappedType: ["typeParameter", "typeAnnotation", "nameType"], TSLiteralType: ["literal"], TSExpressionWithTypeArguments: ["expression", "typeParameters"], TSInterfaceDeclaration: ["id", "typeParameters", "extends", "body"], TSInterfaceBody: ["body"], TSTypeAliasDeclaration: ["id", "typeParameters", "typeAnnotation"], TSInstantiationExpression: ["expression", "typeParameters", "typeArguments"], TSAsExpression: ["expression", "typeAnnotation"], TSSatisfiesExpression: ["expression", "typeAnnotation"], TSTypeAssertion: ["typeAnnotation", "expression"], TSEnumDeclaration: ["id", "members"], TSEnumMember: ["id", "initializer"], TSModuleDeclaration: ["id", "body"], TSModuleBlock: ["body"], TSImportType: ["argument", "qualifier", "typeParameters", "typeArguments"], TSImportEqualsDeclaration: ["id", "moduleReference"], TSExternalModuleReference: ["expression"], TSNonNullExpression: ["expression"], TSExportAssignment: ["expression"], TSNamespaceExportDeclaration: ["id"], TSTypeAnnotation: ["typeAnnotation"], TSTypeParameterInstantiation: ["params"], TSTypeParameterDeclaration: ["params"], TSTypeParameter: ["constraint", "default", "name"], ChainExpression: ["expression"], ExperimentalRestProperty: ["argument"], ExperimentalSpreadProperty: ["argument"], Literal: [], MethodDefinition: ["decorators", "key", "value"], PrivateIdentifier: [], Property: ["key", "value"], PropertyDefinition: ["decorators", "key", "typeAnnotation", "value", "variance"], AccessorProperty: ["decorators", "key", "typeAnnotation", "value"], TSAbstractAccessorProperty: ["decorators", "key", "typeAnnotation"], TSAbstractKeyword: [], TSAbstractMethodDefinition: ["key", "value"], TSAbstractPropertyDefinition: ["decorators", "key", "typeAnnotation"], TSAsyncKeyword: [], TSClassImplements: ["expression", "typeArguments", "typeParameters"], TSDeclareKeyword: [], TSEmptyBodyFunctionExpression: ["id", "typeParameters", "params", "returnType"], TSEnumBody: ["members"], TSExportKeyword: [], TSInterfaceHeritage: ["expression", "typeArguments", "typeParameters"], TSPrivateKeyword: [], TSProtectedKeyword: [], TSPublicKeyword: [], TSReadonlyKeyword: [], TSStaticKeyword: [], TSTemplateLiteralType: ["quasis", "types"], AsConstExpression: ["expression"], AsExpression: ["expression", "typeAnnotation"], BigIntLiteralTypeAnnotation: [], BigIntTypeAnnotation: [], ComponentDeclaration: ["id", "params", "body", "typeParameters", "rendersType"], ComponentParameter: ["name", "local"], ComponentTypeAnnotation: ["params", "rest", "typeParameters", "rendersType"], ComponentTypeParameter: ["name", "typeAnnotation"], ConditionalTypeAnnotation: ["checkType", "extendsType", "trueType", "falseType"], DeclareComponent: ["id", "params", "rest", "typeParameters", "rendersType"], DeclareEnum: ["id", "body"], DeclareHook: ["id"], DeclareNamespace: ["id", "body"], EnumBigIntBody: ["members"], EnumBigIntMember: ["id", "init"], HookDeclaration: ["id", "params", "body", "typeParameters", "returnType"], HookTypeAnnotation: ["params", "returnType", "rest", "typeParameters"], InferTypeAnnotation: ["typeParameter"], KeyofTypeAnnotation: ["argument"], ObjectTypeMappedTypeProperty: ["keyTparam", "propType", "sourceType", "variance"], QualifiedTypeofIdentifier: ["qualification", "id"], TupleTypeLabeledElement: ["label", "elementType", "variance"], TupleTypeSpreadElement: ["label", "typeAnnotation"], TypeOperator: ["typeAnnotation"], TypePredicate: ["parameterName", "typeAnnotation", "asserts"], NGRoot: ["node"], NGPipeExpression: ["left", "right", "arguments"], NGChainedExpression: ["expressions"], NGEmptyExpression: [], NGMicrosyntax: ["body"], NGMicrosyntaxKey: [], NGMicrosyntaxExpression: ["expression", "alias"], NGMicrosyntaxKeyedExpression: ["key", "expression"], NGMicrosyntaxLet: ["key", "value"], NGMicrosyntaxAs: ["key", "alias"], JsExpressionRoot: ["node"], JsonRoot: ["node"], TSJSDocAllType: [], TSJSDocUnknownType: [], TSJSDocNullableType: ["typeAnnotation"], TSJSDocNonNullableType: ["typeAnnotation"], NeverTypeAnnotation: [], UndefinedTypeAnnotation: [], UnknownTypeAnnotation: [], SatisfiesExpression: ["expression", "typeAnnotation"] };
      var lo2 = hr2(tu2), gr3 = lo2;
      function mo2(e2) {
        let t2 = new Set(e2);
        return (r2) => t2.has(r2 == null ? void 0 : r2.type);
      }
      var v2 = mo2;
      var yo2 = v2(["Block", "CommentBlock", "MultiLine"]), re3 = yo2;
      var Do2 = v2(["AnyTypeAnnotation", "ThisTypeAnnotation", "NumberTypeAnnotation", "VoidTypeAnnotation", "BooleanTypeAnnotation", "BigIntTypeAnnotation", "SymbolTypeAnnotation", "StringTypeAnnotation", "NeverTypeAnnotation", "UndefinedTypeAnnotation", "UnknownTypeAnnotation", "EmptyTypeAnnotation", "MixedTypeAnnotation"]), Sr2 = Do2;
      function fo2(e2, t2) {
        let r2 = t2.split(".");
        for (let n2 = r2.length - 1; n2 >= 0; n2--) {
          let s2 = r2[n2];
          if (n2 === 0)
            return e2.type === "Identifier" && e2.name === s2;
          if (e2.type !== "MemberExpression" || e2.optional || e2.computed || e2.property.type !== "Identifier" || e2.property.name !== s2)
            return false;
          e2 = e2.object;
        }
      }
      function Eo2(e2, t2) {
        return t2.some((r2) => fo2(e2, r2));
      }
      var ru2 = Eo2;
      function Fo2({ type: e2 }) {
        return e2.startsWith("TS") && e2.endsWith("Keyword");
      }
      var Br2 = Fo2;
      function tr2(e2, t2) {
        return t2(e2) || Xs2(e2, { getVisitorKeys: gr3, predicate: t2 });
      }
      function jt2(e2) {
        return e2.type === "AssignmentExpression" || e2.type === "BinaryExpression" || e2.type === "LogicalExpression" || e2.type === "NGPipeExpression" || e2.type === "ConditionalExpression" || L3(e2) || q2(e2) || e2.type === "SequenceExpression" || e2.type === "TaggedTemplateExpression" || e2.type === "BindExpression" || e2.type === "UpdateExpression" && !e2.prefix || Te2(e2) || e2.type === "TSNonNullExpression" || e2.type === "ChainExpression";
      }
      function uu2(e2) {
        return e2.expressions ? e2.expressions[0] : e2.left ?? e2.test ?? e2.callee ?? e2.object ?? e2.tag ?? e2.argument ?? e2.expression;
      }
      function Pr2(e2) {
        if (e2.expressions)
          return ["expressions", 0];
        if (e2.left)
          return ["left"];
        if (e2.test)
          return ["test"];
        if (e2.object)
          return ["object"];
        if (e2.callee)
          return ["callee"];
        if (e2.tag)
          return ["tag"];
        if (e2.argument)
          return ["argument"];
        if (e2.expression)
          return ["expression"];
        throw new Error("Unexpected node has no left side.");
      }
      var vt2 = v2(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose", "Hashbang", "InterpreterDirective"]), iu2 = v2(["ExportDefaultDeclaration", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration", "DeclareExportAllDeclaration"]), U2 = v2(["ArrayExpression", "TupleExpression"]), se2 = v2(["ObjectExpression", "RecordExpression"]);
      function au2(e2) {
        return e2.type === "LogicalExpression" && e2.operator === "??";
      }
      function Ce3(e2) {
        return e2.type === "NumericLiteral" || e2.type === "Literal" && typeof e2.value == "number";
      }
      function vn3(e2) {
        return e2.type === "UnaryExpression" && (e2.operator === "+" || e2.operator === "-") && Ce3(e2.argument);
      }
      function Q3(e2) {
        return !!(e2 && (e2.type === "StringLiteral" || e2.type === "Literal" && typeof e2.value == "string"));
      }
      function Mn2(e2) {
        return e2.type === "RegExpLiteral" || e2.type === "Literal" && !!e2.regex;
      }
      var kr3 = v2(["Literal", "BooleanLiteral", "BigIntLiteral", "DecimalLiteral", "DirectiveLiteral", "NullLiteral", "NumericLiteral", "RegExpLiteral", "StringLiteral"]), Co = v2(["Identifier", "ThisExpression", "Super", "PrivateName", "PrivateIdentifier", "Import"]), we3 = v2(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]), _t2 = v2(["FunctionExpression", "ArrowFunctionExpression"]);
      function Ao2(e2) {
        return e2.type === "FunctionExpression" || e2.type === "ArrowFunctionExpression" && e2.body.type === "BlockStatement";
      }
      function wn3(e2) {
        return L3(e2) && e2.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(e2.callee.name);
      }
      var X3 = v2(["JSXElement", "JSXFragment"]);
      function gt2(e2) {
        return e2.method && e2.kind === "init" || e2.kind === "get" || e2.kind === "set";
      }
      function Ir2(e2) {
        return (e2.type === "ObjectTypeProperty" || e2.type === "ObjectTypeInternalSlot") && !e2.static && !e2.method && e2.kind !== "get" && e2.kind !== "set" && e2.value.type === "FunctionTypeAnnotation";
      }
      function ou3(e2) {
        return (e2.type === "TypeAnnotation" || e2.type === "TSTypeAnnotation") && e2.typeAnnotation.type === "FunctionTypeAnnotation" && !e2.static && !ht3(e2, e2.typeAnnotation);
      }
      var De3 = v2(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
      function Ft3(e2) {
        return q2(e2) || e2.type === "BindExpression" && !!e2.object;
      }
      var To = v2(["TSThisType", "NullLiteralTypeAnnotation", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType"]);
      function Mt2(e2) {
        return Br2(e2) || Sr2(e2) || To(e2) || (e2.type === "GenericTypeAnnotation" || e2.type === "TSTypeReference") && !e2.typeParameters && !e2.typeArguments;
      }
      function xo2(e2) {
        return e2.type === "Identifier" && (e2.name === "beforeEach" || e2.name === "beforeAll" || e2.name === "afterEach" || e2.name === "afterAll");
      }
      var ho2 = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];
      function go2(e2) {
        return ru2(e2, ho2);
      }
      function St3(e2, t2) {
        if ((e2 == null ? void 0 : e2.type) !== "CallExpression" || e2.optional)
          return false;
        let r2 = oe3(e2);
        if (r2.length === 1) {
          if (wn3(e2) && St3(t2))
            return _t2(r2[0]);
          if (xo2(e2.callee))
            return wn3(r2[0]);
        } else if ((r2.length === 2 || r2.length === 3) && (r2[0].type === "TemplateLiteral" || Q3(r2[0])) && go2(e2.callee))
          return r2[2] && !Ce3(r2[2]) ? false : (r2.length === 2 ? _t2(r2[1]) : Ao2(r2[1]) && K2(r2[1]).length <= 1) || wn3(r2[1]);
        return false;
      }
      var pu3 = (e2) => (t2) => ((t2 == null ? void 0 : t2.type) === "ChainExpression" && (t2 = t2.expression), e2(t2)), L3 = pu3(v2(["CallExpression", "OptionalCallExpression"])), q2 = pu3(v2(["MemberExpression", "OptionalMemberExpression"]));
      function Rn2(e2, t2 = 5) {
        return cu2(e2, t2) <= t2;
      }
      function cu2(e2, t2) {
        let r2 = 0;
        for (let n2 in e2) {
          let s2 = e2[n2];
          if (s2 && typeof s2 == "object" && typeof s2.type == "string" && (r2++, r2 += cu2(s2, t2 - r2)), r2 > t2)
            return r2;
        }
        return r2;
      }
      var So = 0.25;
      function rr2(e2, t2) {
        let { printWidth: r2 } = t2;
        if (d2(e2))
          return false;
        let n2 = r2 * So;
        if (e2.type === "ThisExpression" || e2.type === "Identifier" && e2.name.length <= n2 || vn3(e2) && !d2(e2.argument))
          return true;
        let s2 = e2.type === "Literal" && "regex" in e2 && e2.regex.pattern || e2.type === "RegExpLiteral" && e2.pattern;
        return s2 ? s2.length <= n2 : Q3(e2) ? tt2(fe2(e2), t2).length <= n2 : e2.type === "TemplateLiteral" ? e2.expressions.length === 0 && e2.quasis[0].value.raw.length <= n2 && !e2.quasis[0].value.raw.includes(`
`) : e2.type === "UnaryExpression" ? rr2(e2.argument, { printWidth: r2 }) : e2.type === "CallExpression" && e2.arguments.length === 0 && e2.callee.type === "Identifier" ? e2.callee.name.length <= n2 - 2 : kr3(e2);
      }
      function Oe3(e2, t2) {
        return X3(t2) ? Bt2(t2) : d2(t2, g2.Leading, (r2) => te2(e2, k(r2)));
      }
      function nu2(e2) {
        return e2.quasis.some((t2) => t2.value.raw.includes(`
`));
      }
      function Lr3(e2, t2) {
        return (e2.type === "TemplateLiteral" && nu2(e2) || e2.type === "TaggedTemplateExpression" && nu2(e2.quasi)) && !te2(t2, R3(e2), { backwards: true });
      }
      function wr2(e2) {
        if (!d2(e2))
          return false;
        let t2 = O2(false, ct3(e2, g2.Dangling), -1);
        return t2 && !re3(t2);
      }
      function lu3(e2) {
        if (e2.length <= 1)
          return false;
        let t2 = 0;
        for (let r2 of e2)
          if (_t2(r2)) {
            if (t2 += 1, t2 > 1)
              return true;
          } else if (L3(r2)) {
            for (let n2 of oe3(r2))
              if (_t2(n2))
                return true;
          }
        return false;
      }
      function Or2(e2) {
        let { node: t2, parent: r2, key: n2 } = e2;
        return n2 === "callee" && L3(t2) && L3(r2) && r2.arguments.length > 0 && t2.arguments.length > r2.arguments.length;
      }
      var Bo3 = /* @__PURE__ */ new Set(["!", "-", "+", "~"]);
      function be3(e2, t2 = 2) {
        if (t2 <= 0)
          return false;
        if (e2.type === "ChainExpression" || e2.type === "TSNonNullExpression")
          return be3(e2.expression, t2);
        let r2 = (n2) => be3(n2, t2 - 1);
        if (Mn2(e2))
          return et2(e2.pattern ?? e2.regex.pattern) <= 5;
        if (kr3(e2) || Co(e2) || e2.type === "ArgumentPlaceholder")
          return true;
        if (e2.type === "TemplateLiteral")
          return e2.quasis.every((n2) => !n2.value.raw.includes(`
`)) && e2.expressions.every(r2);
        if (se2(e2))
          return e2.properties.every((n2) => !n2.computed && (n2.shorthand || n2.value && r2(n2.value)));
        if (U2(e2))
          return e2.elements.every((n2) => n2 === null || r2(n2));
        if (lt3(e2)) {
          if (e2.type === "ImportExpression" || be3(e2.callee, t2)) {
            let n2 = oe3(e2);
            return n2.length <= t2 && n2.every(r2);
          }
          return false;
        }
        return q2(e2) ? be3(e2.object, t2) && be3(e2.property, t2) : e2.type === "UnaryExpression" && Bo3.has(e2.operator) || e2.type === "UpdateExpression" ? be3(e2.argument, t2) : false;
      }
      function fe2(e2) {
        var t2;
        return ((t2 = e2.extra) == null ? void 0 : t2.raw) ?? e2.raw;
      }
      function mu2(e2) {
        return e2;
      }
      function ae2(e2, t2 = "es5") {
        return e2.trailingComma === "es5" && t2 === "es5" || e2.trailingComma === "all" && (t2 === "all" || t2 === "es5");
      }
      function ie2(e2, t2) {
        switch (e2.type) {
          case "BinaryExpression":
          case "LogicalExpression":
          case "AssignmentExpression":
          case "NGPipeExpression":
            return ie2(e2.left, t2);
          case "MemberExpression":
          case "OptionalMemberExpression":
            return ie2(e2.object, t2);
          case "TaggedTemplateExpression":
            return e2.tag.type === "FunctionExpression" ? false : ie2(e2.tag, t2);
          case "CallExpression":
          case "OptionalCallExpression":
            return e2.callee.type === "FunctionExpression" ? false : ie2(e2.callee, t2);
          case "ConditionalExpression":
            return ie2(e2.test, t2);
          case "UpdateExpression":
            return !e2.prefix && ie2(e2.argument, t2);
          case "BindExpression":
            return e2.object && ie2(e2.object, t2);
          case "SequenceExpression":
            return ie2(e2.expressions[0], t2);
          case "ChainExpression":
          case "TSSatisfiesExpression":
          case "TSAsExpression":
          case "TSNonNullExpression":
          case "AsExpression":
          case "AsConstExpression":
          case "SatisfiesExpression":
            return ie2(e2.expression, t2);
          default:
            return t2(e2);
        }
      }
      var su3 = { "==": true, "!=": true, "===": true, "!==": true }, br3 = { "*": true, "/": true, "%": true }, jn = { ">>": true, ">>>": true, "<<": true };
      function nr2(e2, t2) {
        return !(er2(t2) !== er2(e2) || e2 === "**" || su3[e2] && su3[t2] || t2 === "%" && br3[e2] || e2 === "%" && br3[t2] || t2 !== e2 && br3[t2] && br3[e2] || jn[e2] && jn[t2]);
      }
      var bo = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap((e2, t2) => e2.map((r2) => [r2, t2])));
      function er2(e2) {
        return bo.get(e2);
      }
      function yu2(e2) {
        return !!jn[e2] || e2 === "|" || e2 === "^" || e2 === "&";
      }
      function Du2(e2) {
        var r2;
        if (e2.rest)
          return true;
        let t2 = K2(e2);
        return ((r2 = O2(false, t2, -1)) == null ? void 0 : r2.type) === "RestElement";
      }
      var On2 = /* @__PURE__ */ new WeakMap();
      function K2(e2) {
        if (On2.has(e2))
          return On2.get(e2);
        let t2 = [];
        return e2.this && t2.push(e2.this), Array.isArray(e2.parameters) ? t2.push(...e2.parameters) : Array.isArray(e2.params) && t2.push(...e2.params), e2.rest && t2.push(e2.rest), On2.set(e2, t2), t2;
      }
      function fu2(e2, t2) {
        let { node: r2 } = e2, n2 = 0, s2 = (u2) => t2(u2, n2++);
        r2.this && e2.call(s2, "this"), Array.isArray(r2.parameters) ? e2.each(s2, "parameters") : Array.isArray(r2.params) && e2.each(s2, "params"), r2.rest && e2.call(s2, "rest");
      }
      var _n2 = /* @__PURE__ */ new WeakMap();
      function oe3(e2) {
        if (_n2.has(e2))
          return _n2.get(e2);
        if (e2.type === "ChainExpression")
          return oe3(e2.expression);
        let t2 = e2.arguments;
        return e2.type === "ImportExpression" && (t2 = [e2.source], e2.attributes && t2.push(e2.attributes), e2.options && t2.push(e2.options)), _n2.set(e2, t2), t2;
      }
      function Rt2(e2, t2) {
        let { node: r2 } = e2;
        if (r2.type === "ChainExpression")
          return e2.call(() => Rt2(e2, t2), "expression");
        r2.type === "ImportExpression" ? (e2.call((n2) => t2(n2, 0), "source"), r2.attributes && e2.call((n2) => t2(n2, 1), "attributes"), r2.options && e2.call((n2) => t2(n2, 1), "options")) : e2.each(t2, "arguments");
      }
      function Jn2(e2, t2) {
        let r2 = [];
        if (e2.type === "ChainExpression" && (e2 = e2.expression, r2.push("expression")), e2.type === "ImportExpression") {
          if (t2 === 0 || t2 === (e2.attributes || e2.options ? -2 : -1))
            return [...r2, "source"];
          if (e2.attributes && (t2 === 1 || t2 === -1))
            return [...r2, "attributes"];
          if (e2.options && (t2 === 1 || t2 === -1))
            return [...r2, "options"];
          throw new RangeError("Invalid argument index");
        }
        if (t2 < 0 && (t2 = e2.arguments.length + t2), t2 < 0 || t2 >= e2.arguments.length)
          throw new RangeError("Invalid argument index");
        return [...r2, "arguments", t2];
      }
      function sr3(e2) {
        return e2.value.trim() === "prettier-ignore" && !e2.unignore;
      }
      function Bt2(e2) {
        return (e2 == null ? void 0 : e2.prettierIgnore) || d2(e2, g2.PrettierIgnore);
      }
      var g2 = { Leading: 2, Trailing: 4, Dangling: 8, Block: 16, Line: 32, PrettierIgnore: 64, First: 128, Last: 256 }, Eu2 = (e2, t2) => {
        if (typeof e2 == "function" && (t2 = e2, e2 = 0), e2 || t2)
          return (r2, n2, s2) => !(e2 & g2.Leading && !r2.leading || e2 & g2.Trailing && !r2.trailing || e2 & g2.Dangling && (r2.leading || r2.trailing) || e2 & g2.Block && !re3(r2) || e2 & g2.Line && !vt2(r2) || e2 & g2.First && n2 !== 0 || e2 & g2.Last && n2 !== s2.length - 1 || e2 & g2.PrettierIgnore && !sr3(r2) || t2 && !t2(r2));
      };
      function d2(e2, t2, r2) {
        if (!w2(e2 == null ? void 0 : e2.comments))
          return false;
        let n2 = Eu2(t2, r2);
        return n2 ? e2.comments.some(n2) : true;
      }
      function ct3(e2, t2, r2) {
        if (!Array.isArray(e2 == null ? void 0 : e2.comments))
          return [];
        let n2 = Eu2(t2, r2);
        return n2 ? e2.comments.filter(n2) : e2.comments;
      }
      var pe2 = (e2, { originalText: t2 }) => Ot2(t2, k(e2));
      function lt3(e2) {
        return L3(e2) || e2.type === "NewExpression" || e2.type === "ImportExpression";
      }
      function Ae3(e2) {
        return e2 && (e2.type === "ObjectProperty" || e2.type === "Property" && !gt2(e2));
      }
      var Te2 = v2(["TSAsExpression", "TSSatisfiesExpression", "AsExpression", "AsConstExpression", "SatisfiesExpression"]), Ne2 = v2(["UnionTypeAnnotation", "TSUnionType"]), _r3 = v2(["IntersectionTypeAnnotation", "TSIntersectionType"]);
      var Po2 = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), Jt2 = (e2) => {
        for (let t2 of e2.quasis)
          delete t2.value;
      };
      function Fu2(e2, t2, r2) {
        var s2, u2;
        if (e2.type === "Program" && delete t2.sourceType, (e2.type === "BigIntLiteral" || e2.type === "BigIntLiteralTypeAnnotation") && e2.value && (t2.value = e2.value.toLowerCase()), (e2.type === "BigIntLiteral" || e2.type === "Literal") && e2.bigint && (t2.bigint = e2.bigint.toLowerCase()), e2.type === "DecimalLiteral" && (t2.value = Number(e2.value)), e2.type === "Literal" && t2.decimal && (t2.decimal = Number(e2.decimal)), e2.type === "EmptyStatement" || e2.type === "JSXText" || e2.type === "JSXExpressionContainer" && (e2.expression.type === "Literal" || e2.expression.type === "StringLiteral") && e2.expression.value === " ")
          return null;
        if ((e2.type === "Property" || e2.type === "ObjectProperty" || e2.type === "MethodDefinition" || e2.type === "ClassProperty" || e2.type === "ClassMethod" || e2.type === "PropertyDefinition" || e2.type === "TSDeclareMethod" || e2.type === "TSPropertySignature" || e2.type === "ObjectTypeProperty" || e2.type === "ImportAttribute") && e2.key && !e2.computed) {
          let { key: i2 } = e2;
          Q3(i2) || Ce3(i2) ? t2.key = String(i2.value) : i2.type === "Identifier" && (t2.key = i2.name);
        }
        if (e2.type === "JSXElement" && e2.openingElement.name.name === "style" && e2.openingElement.attributes.some((i2) => i2.type === "JSXAttribute" && i2.name.name === "jsx"))
          for (let { type: i2, expression: a2 } of t2.children)
            i2 === "JSXExpressionContainer" && a2.type === "TemplateLiteral" && Jt2(a2);
        e2.type === "JSXAttribute" && e2.name.name === "css" && e2.value.type === "JSXExpressionContainer" && e2.value.expression.type === "TemplateLiteral" && Jt2(t2.value.expression), e2.type === "JSXAttribute" && ((s2 = e2.value) == null ? void 0 : s2.type) === "Literal" && /["']|&quot;|&apos;/u.test(e2.value.value) && (t2.value.value = N2(false, e2.value.value, /["']|&quot;|&apos;/gu, '"'));
        let n2 = e2.expression || e2.callee;
        if (e2.type === "Decorator" && n2.type === "CallExpression" && n2.callee.name === "Component" && n2.arguments.length === 1) {
          let i2 = e2.expression.arguments[0].properties;
          for (let [a2, o2] of t2.expression.arguments[0].properties.entries())
            switch (i2[a2].key.name) {
              case "styles":
                U2(o2.value) && Jt2(o2.value.elements[0]);
                break;
              case "template":
                o2.value.type === "TemplateLiteral" && Jt2(o2.value);
                break;
            }
        }
        e2.type === "TaggedTemplateExpression" && (e2.tag.type === "MemberExpression" || e2.tag.type === "Identifier" && (e2.tag.name === "gql" || e2.tag.name === "graphql" || e2.tag.name === "css" || e2.tag.name === "md" || e2.tag.name === "markdown" || e2.tag.name === "html") || e2.tag.type === "CallExpression") && Jt2(t2.quasi), e2.type === "TemplateLiteral" && ((u2 = e2.leadingComments) != null && u2.some((a2) => re3(a2) && ["GraphQL", "HTML"].some((o2) => a2.value === ` ${o2} `)) || r2.type === "CallExpression" && r2.callee.name === "graphql" || !e2.leadingComments) && Jt2(t2), e2.type === "ChainExpression" && e2.expression.type === "TSNonNullExpression" && (t2.type = "TSNonNullExpression", t2.expression.type = "ChainExpression"), e2.type === "TSMappedType" && (delete t2.key, delete t2.constraint), e2.type === "TSEnumDeclaration" && delete t2.body;
      }
      Fu2.ignoredProperties = Po2;
      var Cu3 = Fu2;
      var rt3 = "string", _e3 = "array", nt3 = "cursor", Xe2 = "indent", Ye2 = "align", st3 = "trim", le2 = "group", Pe3 = "fill", xe3 = "if-break", He2 = "indent-if-break", Ve2 = "line-suffix", $e3 = "line-suffix-boundary", me2 = "line", je2 = "label", ve3 = "break-parent", jr3 = /* @__PURE__ */ new Set([nt3, Xe2, Ye2, st3, le2, Pe3, xe3, He2, Ve2, $e3, me2, je2, ve3]);
      function ko2(e2) {
        if (typeof e2 == "string")
          return rt3;
        if (Array.isArray(e2))
          return _e3;
        if (!e2)
          return;
        let { type: t2 } = e2;
        if (jr3.has(t2))
          return t2;
      }
      var ut3 = ko2;
      var Io2 = (e2) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(e2);
      function Lo2(e2) {
        let t2 = e2 === null ? "null" : typeof e2;
        if (t2 !== "string" && t2 !== "object")
          return `Unexpected doc '${t2}', 
Expected it to be 'string' or 'object'.`;
        if (ut3(e2))
          throw new Error("doc is valid.");
        let r2 = Object.prototype.toString.call(e2);
        if (r2 !== "[object Object]")
          return `Unexpected doc '${r2}'.`;
        let n2 = Io2([...jr3].map((s2) => `'${s2}'`));
        return `Unexpected doc.type '${e2.type}'.
Expected it to be ${n2}.`;
      }
      var qn2 = class extends Error {
        constructor(t2) {
          super(Lo2(t2));
          __publicField(this, "name", "InvalidDocError");
          this.doc = t2;
        }
      }, Ct = qn2;
      var Au2 = {};
      function wo2(e2, t2, r2, n2) {
        let s2 = [e2];
        for (; s2.length > 0; ) {
          let u2 = s2.pop();
          if (u2 === Au2) {
            r2(s2.pop());
            continue;
          }
          r2 && s2.push(u2, Au2);
          let i2 = ut3(u2);
          if (!i2)
            throw new Ct(u2);
          if ((t2 == null ? void 0 : t2(u2)) !== false)
            switch (i2) {
              case _e3:
              case Pe3: {
                let a2 = i2 === _e3 ? u2 : u2.parts;
                for (let o2 = a2.length, c2 = o2 - 1; c2 >= 0; --c2)
                  s2.push(a2[c2]);
                break;
              }
              case xe3:
                s2.push(u2.flatContents, u2.breakContents);
                break;
              case le2:
                if (n2 && u2.expandedStates)
                  for (let a2 = u2.expandedStates.length, o2 = a2 - 1; o2 >= 0; --o2)
                    s2.push(u2.expandedStates[o2]);
                else
                  s2.push(u2.contents);
                break;
              case Ye2:
              case Xe2:
              case He2:
              case je2:
              case Ve2:
                s2.push(u2.contents);
                break;
              case rt3:
              case nt3:
              case st3:
              case $e3:
              case me2:
              case ve3:
                break;
              default:
                throw new Ct(u2);
            }
        }
      }
      var Wn2 = wo2;
      var Tu2 = () => {
      }, Ke3 = Tu2, vr3 = Tu2;
      function f2(e2) {
        return Ke3(e2), { type: Xe2, contents: e2 };
      }
      function he3(e2, t2) {
        return Ke3(t2), { type: Ye2, contents: t2, n: e2 };
      }
      function l2(e2, t2 = {}) {
        return Ke3(e2), vr3(t2.expandedStates, true), { type: le2, id: t2.id, contents: e2, break: !!t2.shouldBreak, expandedStates: t2.expandedStates };
      }
      function du3(e2) {
        return he3(Number.NEGATIVE_INFINITY, e2);
      }
      function Mr2(e2) {
        return he3(-1, e2);
      }
      function ze2(e2, t2) {
        return l2(e2[0], { ...t2, expandedStates: e2 });
      }
      function qt2(e2) {
        return vr3(e2), { type: Pe3, parts: e2 };
      }
      function b3(e2, t2 = "", r2 = {}) {
        return Ke3(e2), t2 !== "" && Ke3(t2), { type: xe3, breakContents: e2, flatContents: t2, groupId: r2.groupId };
      }
      function At3(e2, t2) {
        return Ke3(e2), { type: He2, contents: e2, groupId: t2.groupId, negate: t2.negate };
      }
      function Gn3(e2) {
        return Ke3(e2), { type: Ve2, contents: e2 };
      }
      var ke3 = { type: $e3 }, Ee2 = { type: ve3 };
      var Un3 = { type: me2, hard: true }, Oo = { type: me2, hard: true, literal: true }, x2 = { type: me2 }, E2 = { type: me2, soft: true }, F = [Un3, Ee2], Rr2 = [Oo, Ee2], Nn2 = { type: nt3 };
      function P2(e2, t2) {
        Ke3(e2), vr3(t2);
        let r2 = [];
        for (let n2 = 0; n2 < t2.length; n2++)
          n2 !== 0 && r2.push(e2), r2.push(t2[n2]);
        return r2;
      }
      function xu2(e2, t2, r2) {
        Ke3(e2);
        let n2 = e2;
        if (t2 > 0) {
          for (let s2 = 0; s2 < Math.floor(t2 / r2); ++s2)
            n2 = f2(n2);
          n2 = he3(t2 % r2, n2), n2 = he3(Number.NEGATIVE_INFINITY, n2);
        }
        return n2;
      }
      function it3(e2, t2) {
        return Ke3(t2), e2 ? { type: je2, label: e2, contents: t2 } : t2;
      }
      function mt3(e2, t2) {
        if (typeof e2 == "string")
          return t2(e2);
        let r2 = /* @__PURE__ */ new Map();
        return n2(e2);
        function n2(u2) {
          if (r2.has(u2))
            return r2.get(u2);
          let i2 = s2(u2);
          return r2.set(u2, i2), i2;
        }
        function s2(u2) {
          switch (ut3(u2)) {
            case _e3:
              return t2(u2.map(n2));
            case Pe3:
              return t2({ ...u2, parts: u2.parts.map(n2) });
            case xe3:
              return t2({ ...u2, breakContents: n2(u2.breakContents), flatContents: n2(u2.flatContents) });
            case le2: {
              let { expandedStates: i2, contents: a2 } = u2;
              return i2 ? (i2 = i2.map(n2), a2 = i2[0]) : a2 = n2(a2), t2({ ...u2, contents: a2, expandedStates: i2 });
            }
            case Ye2:
            case Xe2:
            case He2:
            case je2:
            case Ve2:
              return t2({ ...u2, contents: n2(u2.contents) });
            case rt3:
            case nt3:
            case st3:
            case $e3:
            case me2:
            case ve3:
              return t2(u2);
            default:
              throw new Ct(u2);
          }
        }
      }
      function gu2(e2, t2, r2) {
        let n2 = r2, s2 = false;
        function u2(i2) {
          if (s2)
            return false;
          let a2 = t2(i2);
          a2 !== void 0 && (s2 = true, n2 = a2);
        }
        return Wn2(e2, u2), n2;
      }
      function _o2(e2) {
        if (e2.type === le2 && e2.break || e2.type === me2 && e2.hard || e2.type === ve3)
          return true;
      }
      function ne3(e2) {
        return gu2(e2, _o2, false);
      }
      function hu2(e2) {
        if (e2.length > 0) {
          let t2 = O2(false, e2, -1);
          !t2.expandedStates && !t2.break && (t2.break = "propagated");
        }
        return null;
      }
      function Su3(e2) {
        let t2 = /* @__PURE__ */ new Set(), r2 = [];
        function n2(u2) {
          if (u2.type === ve3 && hu2(r2), u2.type === le2) {
            if (r2.push(u2), t2.has(u2))
              return false;
            t2.add(u2);
          }
        }
        function s2(u2) {
          u2.type === le2 && r2.pop().break && hu2(r2);
        }
        Wn2(e2, n2, s2, true);
      }
      function jo2(e2) {
        return e2.type === me2 && !e2.hard ? e2.soft ? "" : " " : e2.type === xe3 ? e2.flatContents : e2;
      }
      function ur3(e2) {
        return mt3(e2, jo2);
      }
      function vo(e2) {
        switch (ut3(e2)) {
          case Pe3:
            if (e2.parts.every((t2) => t2 === ""))
              return "";
            break;
          case le2:
            if (!e2.contents && !e2.id && !e2.break && !e2.expandedStates)
              return "";
            if (e2.contents.type === le2 && e2.contents.id === e2.id && e2.contents.break === e2.break && e2.contents.expandedStates === e2.expandedStates)
              return e2.contents;
            break;
          case Ye2:
          case Xe2:
          case He2:
          case Ve2:
            if (!e2.contents)
              return "";
            break;
          case xe3:
            if (!e2.flatContents && !e2.breakContents)
              return "";
            break;
          case _e3: {
            let t2 = [];
            for (let r2 of e2) {
              if (!r2)
                continue;
              let [n2, ...s2] = Array.isArray(r2) ? r2 : [r2];
              typeof n2 == "string" && typeof O2(false, t2, -1) == "string" ? t2[t2.length - 1] += n2 : t2.push(n2), t2.push(...s2);
            }
            return t2.length === 0 ? "" : t2.length === 1 ? t2[0] : t2;
          }
          case rt3:
          case nt3:
          case st3:
          case $e3:
          case me2:
          case je2:
          case ve3:
            break;
          default:
            throw new Ct(e2);
        }
        return e2;
      }
      function Wt2(e2) {
        return mt3(e2, (t2) => vo(t2));
      }
      function Ie3(e2, t2 = Rr2) {
        return mt3(e2, (r2) => typeof r2 == "string" ? P2(t2, r2.split(`
`)) : r2);
      }
      function Mo2(e2) {
        if (e2.type === me2)
          return true;
      }
      function Bu3(e2) {
        return gu2(e2, Mo2, false);
      }
      function ir3(e2, t2) {
        return e2.type === je2 ? { ...e2, contents: t2(e2.contents) } : t2(e2);
      }
      function Ro3(e2) {
        let t2 = `*${e2.value}*`.split(`
`);
        return t2.length > 1 && t2.every((r2) => r2.trimStart()[0] === "*");
      }
      var bu2 = Ro3;
      function Pu2(e2, t2) {
        let r2 = e2.node;
        if (vt2(r2))
          return t2.originalText.slice(R3(r2), k(r2)).trimEnd();
        if (re3(r2))
          return bu2(r2) ? Jo2(r2) : ["/*", Ie3(r2.value), "*/"];
        throw new Error("Not a comment: " + JSON.stringify(r2));
      }
      function Jo2(e2) {
        let t2 = e2.value.split(`
`);
        return ["/*", P2(F, t2.map((r2, n2) => n2 === 0 ? r2.trimEnd() : " " + (n2 < t2.length - 1 ? r2.trim() : r2.trimStart()))), "*/"];
      }
      var zn3 = {};
      Ar3(zn3, { endOfLine: () => Yo2, ownLine: () => Xo2, remaining: () => Ho2 });
      function qo2(e2) {
        let t2 = e2.type || e2.kind || "(unknown type)", r2 = String(e2.name || e2.id && (typeof e2.id == "object" ? e2.id.name : e2.id) || e2.key && (typeof e2.key == "object" ? e2.key.name : e2.key) || e2.value && (typeof e2.value == "object" ? "" : String(e2.value)) || e2.operator || "");
        return r2.length > 20 && (r2 = r2.slice(0, 19) + "…"), t2 + (r2 ? " " + r2 : "");
      }
      function Xn2(e2, t2) {
        (e2.comments ?? (e2.comments = [])).push(t2), t2.printed = false, t2.nodeDescription = qo2(e2);
      }
      function ce3(e2, t2) {
        t2.leading = true, t2.trailing = false, Xn2(e2, t2);
      }
      function Le3(e2, t2, r2) {
        t2.leading = false, t2.trailing = false, r2 && (t2.marker = r2), Xn2(e2, t2);
      }
      function z3(e2, t2) {
        t2.leading = false, t2.trailing = true, Xn2(e2, t2);
      }
      function Wo2(e2, t2) {
        let r2 = null, n2 = t2;
        for (; n2 !== r2; )
          r2 = n2, n2 = Ge3(e2, n2), n2 = Lt2(e2, n2), n2 = wt3(e2, n2), n2 = Ue2(e2, n2);
        return n2;
      }
      var yt2 = Wo2;
      function Go2(e2, t2) {
        let r2 = yt2(e2, t2);
        return r2 === false ? "" : e2.charAt(r2);
      }
      var ge2 = Go2;
      function Uo2(e2, t2, r2) {
        for (let n2 = t2; n2 < r2; ++n2)
          if (e2.charAt(n2) === `
`)
            return true;
        return false;
      }
      var de2 = Uo2;
      function No(e2) {
        return re3(e2) && e2.value[0] === "*" && /@(?:type|satisfies)\b/u.test(e2.value);
      }
      var ku2 = No;
      function Xo2(e2) {
        return [Mu3, Lu3, _u2, sp, $o2, Hn, Vn3, Iu2, wu2, op, ip, Kn3, vu2, pp, Ou2, ju3, $n3, Ko3, Fp].some((t2) => t2(e2));
      }
      function Yo2(e2) {
        return [Vo2, _u2, Lu3, vu2, Hn, Vn3, Iu2, wu2, ju3, up, ap, Kn3, mp, $n3, fp, Ep2].some((t2) => t2(e2));
      }
      function Ho2(e2) {
        return [Mu3, Hn, Vn3, zo, np, Ou2, Kn3, rp, tp, Dp2, $n3, yp].some((t2) => t2(e2));
      }
      function bt2(e2, t2) {
        let r2 = (e2.body || e2.properties).find(({ type: n2 }) => n2 !== "EmptyStatement");
        r2 ? ce3(r2, t2) : Le3(e2, t2);
      }
      function Yn2(e2, t2) {
        e2.type === "BlockStatement" ? bt2(e2, t2) : ce3(e2, t2);
      }
      function Vo2({ comment: e2, followingNode: t2 }) {
        return t2 && ku2(e2) ? (ce3(t2, e2), true) : false;
      }
      function Hn({ comment: e2, precedingNode: t2, enclosingNode: r2, followingNode: n2, text: s2 }) {
        if ((r2 == null ? void 0 : r2.type) !== "IfStatement" || !n2)
          return false;
        if (ge2(s2, k(e2)) === ")")
          return z3(t2, e2), true;
        if (t2 === r2.consequent && n2 === r2.alternate) {
          if (t2.type === "BlockStatement")
            z3(t2, e2);
          else {
            let i2 = vt2(e2) || e2.loc.start.line === e2.loc.end.line, a2 = e2.loc.start.line === t2.loc.start.line;
            i2 && a2 ? z3(t2, e2) : Le3(r2, e2);
          }
          return true;
        }
        return n2.type === "BlockStatement" ? (bt2(n2, e2), true) : n2.type === "IfStatement" ? (Yn2(n2.consequent, e2), true) : r2.consequent === n2 ? (ce3(n2, e2), true) : false;
      }
      function Vn3({ comment: e2, precedingNode: t2, enclosingNode: r2, followingNode: n2, text: s2 }) {
        return (r2 == null ? void 0 : r2.type) !== "WhileStatement" || !n2 ? false : ge2(s2, k(e2)) === ")" ? (z3(t2, e2), true) : n2.type === "BlockStatement" ? (bt2(n2, e2), true) : r2.body === n2 ? (ce3(n2, e2), true) : false;
      }
      function Iu2({ comment: e2, precedingNode: t2, enclosingNode: r2, followingNode: n2 }) {
        return (r2 == null ? void 0 : r2.type) !== "TryStatement" && (r2 == null ? void 0 : r2.type) !== "CatchClause" || !n2 ? false : r2.type === "CatchClause" && t2 ? (z3(t2, e2), true) : n2.type === "BlockStatement" ? (bt2(n2, e2), true) : n2.type === "TryStatement" ? (Yn2(n2.finalizer, e2), true) : n2.type === "CatchClause" ? (Yn2(n2.body, e2), true) : false;
      }
      function $o2({ comment: e2, enclosingNode: t2, followingNode: r2 }) {
        return q2(t2) && (r2 == null ? void 0 : r2.type) === "Identifier" ? (ce3(t2, e2), true) : false;
      }
      function Ko3({ comment: e2, enclosingNode: t2, followingNode: r2, options: n2 }) {
        return !n2.experimentalTernaries || !((t2 == null ? void 0 : t2.type) === "ConditionalExpression" || (t2 == null ? void 0 : t2.type) === "ConditionalTypeAnnotation" || (t2 == null ? void 0 : t2.type) === "TSConditionalType") ? false : (r2 == null ? void 0 : r2.type) === "ConditionalExpression" || (r2 == null ? void 0 : r2.type) === "ConditionalTypeAnnotation" || (r2 == null ? void 0 : r2.type) === "TSConditionalType" ? (Le3(t2, e2), true) : false;
      }
      function Lu3({ comment: e2, precedingNode: t2, enclosingNode: r2, followingNode: n2, text: s2, options: u2 }) {
        let i2 = t2 && !de2(s2, k(t2), R3(e2));
        return (!t2 || !i2) && ((r2 == null ? void 0 : r2.type) === "ConditionalExpression" || (r2 == null ? void 0 : r2.type) === "ConditionalTypeAnnotation" || (r2 == null ? void 0 : r2.type) === "TSConditionalType") && n2 ? u2.experimentalTernaries && r2.alternate === n2 && !(re3(e2) && !de2(u2.originalText, R3(e2), k(e2))) ? (Le3(r2, e2), true) : (ce3(n2, e2), true) : false;
      }
      function zo({ comment: e2, precedingNode: t2, enclosingNode: r2 }) {
        return Ae3(r2) && r2.shorthand && r2.key === t2 && r2.value.type === "AssignmentPattern" ? (z3(r2.value.left, e2), true) : false;
      }
      var Qo2 = /* @__PURE__ */ new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
      function wu2({ comment: e2, precedingNode: t2, enclosingNode: r2, followingNode: n2 }) {
        if (Qo2.has(r2 == null ? void 0 : r2.type)) {
          if (w2(r2.decorators) && (n2 == null ? void 0 : n2.type) !== "Decorator")
            return z3(O2(false, r2.decorators, -1), e2), true;
          if (r2.body && n2 === r2.body)
            return bt2(r2.body, e2), true;
          if (n2) {
            if (r2.superClass && n2 === r2.superClass && t2 && (t2 === r2.id || t2 === r2.typeParameters))
              return z3(t2, e2), true;
            for (let s2 of ["implements", "extends", "mixins"])
              if (r2[s2] && n2 === r2[s2][0])
                return t2 && (t2 === r2.id || t2 === r2.typeParameters || t2 === r2.superClass) ? z3(t2, e2) : Le3(r2, e2, s2), true;
          }
        }
        return false;
      }
      var Zo2 = /* @__PURE__ */ new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty"]);
      function Ou2({ comment: e2, precedingNode: t2, enclosingNode: r2, text: n2 }) {
        return r2 && t2 && ge2(n2, k(e2)) === "(" && (r2.type === "Property" || r2.type === "TSDeclareMethod" || r2.type === "TSAbstractMethodDefinition") && t2.type === "Identifier" && r2.key === t2 && ge2(n2, k(t2)) !== ":" ? (z3(t2, e2), true) : (t2 == null ? void 0 : t2.type) === "Decorator" && Zo2.has(r2 == null ? void 0 : r2.type) ? (z3(t2, e2), true) : false;
      }
      var ep = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);
      function tp({ comment: e2, precedingNode: t2, enclosingNode: r2, text: n2 }) {
        return ge2(n2, k(e2)) !== "(" ? false : t2 && ep.has(r2 == null ? void 0 : r2.type) ? (z3(t2, e2), true) : false;
      }
      function rp({ comment: e2, enclosingNode: t2, text: r2 }) {
        if ((t2 == null ? void 0 : t2.type) !== "ArrowFunctionExpression")
          return false;
        let n2 = yt2(r2, k(e2));
        return n2 !== false && r2.slice(n2, n2 + 2) === "=>" ? (Le3(t2, e2), true) : false;
      }
      function np({ comment: e2, enclosingNode: t2, text: r2 }) {
        return ge2(r2, k(e2)) !== ")" ? false : t2 && (Ru2(t2) && K2(t2).length === 0 || lt3(t2) && oe3(t2).length === 0) ? (Le3(t2, e2), true) : ((t2 == null ? void 0 : t2.type) === "MethodDefinition" || (t2 == null ? void 0 : t2.type) === "TSAbstractMethodDefinition") && K2(t2.value).length === 0 ? (Le3(t2.value, e2), true) : false;
      }
      function sp({ comment: e2, precedingNode: t2, enclosingNode: r2, followingNode: n2, text: s2 }) {
        return (t2 == null ? void 0 : t2.type) === "ComponentTypeParameter" && ((r2 == null ? void 0 : r2.type) === "DeclareComponent" || (r2 == null ? void 0 : r2.type) === "ComponentTypeAnnotation") && (n2 == null ? void 0 : n2.type) !== "ComponentTypeParameter" ? (z3(t2, e2), true) : ((t2 == null ? void 0 : t2.type) === "ComponentParameter" || (t2 == null ? void 0 : t2.type) === "RestElement") && (r2 == null ? void 0 : r2.type) === "ComponentDeclaration" && ge2(s2, k(e2)) === ")" ? (z3(t2, e2), true) : false;
      }
      function _u2({ comment: e2, precedingNode: t2, enclosingNode: r2, followingNode: n2, text: s2 }) {
        return (t2 == null ? void 0 : t2.type) === "FunctionTypeParam" && (r2 == null ? void 0 : r2.type) === "FunctionTypeAnnotation" && (n2 == null ? void 0 : n2.type) !== "FunctionTypeParam" ? (z3(t2, e2), true) : ((t2 == null ? void 0 : t2.type) === "Identifier" || (t2 == null ? void 0 : t2.type) === "AssignmentPattern" || (t2 == null ? void 0 : t2.type) === "ObjectPattern" || (t2 == null ? void 0 : t2.type) === "ArrayPattern" || (t2 == null ? void 0 : t2.type) === "RestElement" || (t2 == null ? void 0 : t2.type) === "TSParameterProperty") && Ru2(r2) && ge2(s2, k(e2)) === ")" ? (z3(t2, e2), true) : !re3(e2) && ((r2 == null ? void 0 : r2.type) === "FunctionDeclaration" || (r2 == null ? void 0 : r2.type) === "FunctionExpression" || (r2 == null ? void 0 : r2.type) === "ObjectMethod") && (n2 == null ? void 0 : n2.type) === "BlockStatement" && r2.body === n2 && yt2(s2, k(e2)) === R3(n2) ? (bt2(n2, e2), true) : false;
      }
      function ju3({ comment: e2, enclosingNode: t2 }) {
        return (t2 == null ? void 0 : t2.type) === "LabeledStatement" ? (ce3(t2, e2), true) : false;
      }
      function $n3({ comment: e2, enclosingNode: t2 }) {
        return ((t2 == null ? void 0 : t2.type) === "ContinueStatement" || (t2 == null ? void 0 : t2.type) === "BreakStatement") && !t2.label ? (z3(t2, e2), true) : false;
      }
      function up({ comment: e2, precedingNode: t2, enclosingNode: r2 }) {
        return L3(r2) && t2 && r2.callee === t2 && r2.arguments.length > 0 ? (ce3(r2.arguments[0], e2), true) : false;
      }
      function ip({ comment: e2, precedingNode: t2, enclosingNode: r2, followingNode: n2 }) {
        return Ne2(r2) ? (sr3(e2) && (n2.prettierIgnore = true, e2.unignore = true), t2 ? (z3(t2, e2), true) : false) : (Ne2(n2) && sr3(e2) && (n2.types[0].prettierIgnore = true, e2.unignore = true), false);
      }
      function ap({ comment: e2, enclosingNode: t2 }) {
        return Ae3(t2) ? (ce3(t2, e2), true) : false;
      }
      function Kn3({ comment: e2, enclosingNode: t2, ast: r2, isLastComment: n2 }) {
        var s2;
        return ((s2 = r2 == null ? void 0 : r2.body) == null ? void 0 : s2.length) === 0 ? (n2 ? Le3(r2, e2) : ce3(r2, e2), true) : (t2 == null ? void 0 : t2.type) === "Program" && t2.body.length === 0 && !w2(t2.directives) ? (n2 ? Le3(t2, e2) : ce3(t2, e2), true) : false;
      }
      function op({ comment: e2, enclosingNode: t2 }) {
        return (t2 == null ? void 0 : t2.type) === "ForInStatement" || (t2 == null ? void 0 : t2.type) === "ForOfStatement" ? (ce3(t2, e2), true) : false;
      }
      function vu2({ comment: e2, precedingNode: t2, enclosingNode: r2, text: n2 }) {
        if ((r2 == null ? void 0 : r2.type) === "ImportSpecifier" || (r2 == null ? void 0 : r2.type) === "ExportSpecifier")
          return ce3(r2, e2), true;
        let s2 = (t2 == null ? void 0 : t2.type) === "ImportSpecifier" && (r2 == null ? void 0 : r2.type) === "ImportDeclaration", u2 = (t2 == null ? void 0 : t2.type) === "ExportSpecifier" && (r2 == null ? void 0 : r2.type) === "ExportNamedDeclaration";
        return (s2 || u2) && te2(n2, k(e2)) ? (z3(t2, e2), true) : false;
      }
      function pp({ comment: e2, enclosingNode: t2 }) {
        return (t2 == null ? void 0 : t2.type) === "AssignmentPattern" ? (ce3(t2, e2), true) : false;
      }
      var cp = /* @__PURE__ */ new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]), lp = /* @__PURE__ */ new Set(["ObjectExpression", "RecordExpression", "ArrayExpression", "TupleExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);
      function mp({ comment: e2, enclosingNode: t2, followingNode: r2 }) {
        return cp.has(t2 == null ? void 0 : t2.type) && r2 && (lp.has(r2.type) || re3(e2)) ? (ce3(r2, e2), true) : false;
      }
      function yp({ comment: e2, enclosingNode: t2, followingNode: r2, text: n2 }) {
        return !r2 && ((t2 == null ? void 0 : t2.type) === "TSMethodSignature" || (t2 == null ? void 0 : t2.type) === "TSDeclareFunction" || (t2 == null ? void 0 : t2.type) === "TSAbstractMethodDefinition") && ge2(n2, k(e2)) === ";" ? (z3(t2, e2), true) : false;
      }
      function Mu3({ comment: e2, enclosingNode: t2, followingNode: r2 }) {
        if (sr3(e2) && (t2 == null ? void 0 : t2.type) === "TSMappedType" && (r2 == null ? void 0 : r2.type) === "TSTypeParameter" && r2.constraint)
          return t2.prettierIgnore = true, e2.unignore = true, true;
      }
      function Dp2({ comment: e2, precedingNode: t2, enclosingNode: r2, followingNode: n2 }) {
        return (r2 == null ? void 0 : r2.type) !== "TSMappedType" ? false : (n2 == null ? void 0 : n2.type) === "TSTypeParameter" && n2.name ? (ce3(n2.name, e2), true) : (t2 == null ? void 0 : t2.type) === "TSTypeParameter" && t2.constraint ? (z3(t2.constraint, e2), true) : false;
      }
      function fp({ comment: e2, enclosingNode: t2, followingNode: r2 }) {
        return !t2 || t2.type !== "SwitchCase" || t2.test || !r2 || r2 !== t2.consequent[0] ? false : (r2.type === "BlockStatement" && vt2(e2) ? bt2(r2, e2) : Le3(t2, e2), true);
      }
      function Ep2({ comment: e2, precedingNode: t2, enclosingNode: r2, followingNode: n2 }) {
        return Ne2(t2) && ((r2.type === "TSArrayType" || r2.type === "ArrayTypeAnnotation") && !n2 || _r3(r2)) ? (z3(O2(false, t2.types, -1), e2), true) : false;
      }
      function Fp({ comment: e2, enclosingNode: t2, precedingNode: r2, followingNode: n2 }) {
        if (((t2 == null ? void 0 : t2.type) === "ObjectPattern" || (t2 == null ? void 0 : t2.type) === "ArrayPattern") && (n2 == null ? void 0 : n2.type) === "TSTypeAnnotation")
          return r2 ? z3(r2, e2) : Le3(t2, e2), true;
      }
      var Ru2 = v2(["ArrowFunctionExpression", "FunctionExpression", "FunctionDeclaration", "ObjectMethod", "ClassMethod", "TSDeclareFunction", "TSCallSignatureDeclaration", "TSConstructSignatureDeclaration", "TSMethodSignature", "TSConstructorType", "TSFunctionType", "TSDeclareMethod"]);
      var Cp2 = /* @__PURE__ */ new Set(["EmptyStatement", "TemplateElement", "Import", "TSEmptyBodyFunctionExpression", "ChainExpression"]);
      function Ap2(e2) {
        return !Cp2.has(e2.type);
      }
      function Tp2(e2, t2) {
        var r2;
        if ((t2.parser === "typescript" || t2.parser === "flow" || t2.parser === "acorn" || t2.parser === "espree" || t2.parser === "meriyah" || t2.parser === "__babel_estree") && e2.type === "MethodDefinition" && ((r2 = e2.value) == null ? void 0 : r2.type) === "FunctionExpression" && K2(e2.value).length === 0 && !e2.value.returnType && !w2(e2.value.typeParameters) && e2.value.body)
          return [...e2.decorators || [], e2.key, e2.value.body];
      }
      function Qn3(e2) {
        let { node: t2, parent: r2 } = e2;
        return (X3(t2) || r2 && (r2.type === "JSXSpreadAttribute" || r2.type === "JSXSpreadChild" || Ne2(r2) || (r2.type === "ClassDeclaration" || r2.type === "ClassExpression") && r2.superClass === t2)) && (!Bt2(t2) || Ne2(r2));
      }
      function dp(e2, { parser: t2 }) {
        if (t2 === "flow" || t2 === "babel-flow")
          return e2 = N2(false, e2, /[\s(]/gu, ""), e2 === "" || e2 === "/*" || e2 === "/*::";
      }
      function Ju3(e2) {
        switch (e2) {
          case "cr":
            return "\r";
          case "crlf":
            return `\r
`;
          default:
            return `
`;
        }
      }
      var Se3 = Symbol("MODE_BREAK"), at3 = Symbol("MODE_FLAT"), ar3 = Symbol("cursor");
      function qu3() {
        return { value: "", length: 0, queue: [] };
      }
      function xp2(e2, t2) {
        return Zn3(e2, { type: "indent" }, t2);
      }
      function hp2(e2, t2, r2) {
        return t2 === Number.NEGATIVE_INFINITY ? e2.root || qu3() : t2 < 0 ? Zn3(e2, { type: "dedent" }, r2) : t2 ? t2.type === "root" ? { ...e2, root: e2 } : Zn3(e2, { type: typeof t2 == "string" ? "stringAlign" : "numberAlign", n: t2 }, r2) : e2;
      }
      function Zn3(e2, t2, r2) {
        let n2 = t2.type === "dedent" ? e2.queue.slice(0, -1) : [...e2.queue, t2], s2 = "", u2 = 0, i2 = 0, a2 = 0;
        for (let p2 of n2)
          switch (p2.type) {
            case "indent":
              m(), r2.useTabs ? o2(1) : c2(r2.tabWidth);
              break;
            case "stringAlign":
              m(), s2 += p2.n, u2 += p2.n.length;
              break;
            case "numberAlign":
              i2 += 1, a2 += p2.n;
              break;
            default:
              throw new Error(`Unexpected type '${p2.type}'`);
          }
        return y3(), { ...e2, value: s2, length: u2, queue: n2 };
        function o2(p2) {
          s2 += "	".repeat(p2), u2 += r2.tabWidth * p2;
        }
        function c2(p2) {
          s2 += " ".repeat(p2), u2 += p2;
        }
        function m() {
          r2.useTabs ? D() : y3();
        }
        function D() {
          i2 > 0 && o2(i2), C();
        }
        function y3() {
          a2 > 0 && c2(a2), C();
        }
        function C() {
          i2 = 0, a2 = 0;
        }
      }
      function es(e2) {
        let t2 = 0, r2 = 0, n2 = e2.length;
        e:
          for (; n2--; ) {
            let s2 = e2[n2];
            if (s2 === ar3) {
              r2++;
              continue;
            }
            for (let u2 = s2.length - 1; u2 >= 0; u2--) {
              let i2 = s2[u2];
              if (i2 === " " || i2 === "	")
                t2++;
              else {
                e2[n2] = s2.slice(0, u2 + 1);
                break e;
              }
            }
          }
        if (t2 > 0 || r2 > 0)
          for (e2.length = n2 + 1; r2-- > 0; )
            e2.push(ar3);
        return t2;
      }
      function Jr2(e2, t2, r2, n2, s2, u2) {
        if (r2 === Number.POSITIVE_INFINITY)
          return true;
        let i2 = t2.length, a2 = [e2], o2 = [];
        for (; r2 >= 0; ) {
          if (a2.length === 0) {
            if (i2 === 0)
              return true;
            a2.push(t2[--i2]);
            continue;
          }
          let { mode: c2, doc: m } = a2.pop(), D = ut3(m);
          switch (D) {
            case rt3:
              o2.push(m), r2 -= et2(m);
              break;
            case _e3:
            case Pe3: {
              let y3 = D === _e3 ? m : m.parts;
              for (let C = y3.length - 1; C >= 0; C--)
                a2.push({ mode: c2, doc: y3[C] });
              break;
            }
            case Xe2:
            case Ye2:
            case He2:
            case je2:
              a2.push({ mode: c2, doc: m.contents });
              break;
            case st3:
              r2 += es(o2);
              break;
            case le2: {
              if (u2 && m.break)
                return false;
              let y3 = m.break ? Se3 : c2, C = m.expandedStates && y3 === Se3 ? O2(false, m.expandedStates, -1) : m.contents;
              a2.push({ mode: y3, doc: C });
              break;
            }
            case xe3: {
              let C = (m.groupId ? s2[m.groupId] || at3 : c2) === Se3 ? m.breakContents : m.flatContents;
              C && a2.push({ mode: c2, doc: C });
              break;
            }
            case me2:
              if (c2 === Se3 || m.hard)
                return true;
              m.soft || (o2.push(" "), r2--);
              break;
            case Ve2:
              n2 = true;
              break;
            case $e3:
              if (n2)
                return false;
              break;
          }
        }
        return false;
      }
      function ts(e2, t2) {
        let r2 = {}, n2 = t2.printWidth, s2 = Ju3(t2.endOfLine), u2 = 0, i2 = [{ ind: qu3(), mode: Se3, doc: e2 }], a2 = [], o2 = false, c2 = [], m = 0;
        for (Su3(e2); i2.length > 0; ) {
          let { ind: y3, mode: C, doc: p2 } = i2.pop();
          switch (ut3(p2)) {
            case rt3: {
              let A = s2 !== `
` ? N2(false, p2, `
`, s2) : p2;
              a2.push(A), i2.length > 0 && (u2 += et2(A));
              break;
            }
            case _e3:
              for (let A = p2.length - 1; A >= 0; A--)
                i2.push({ ind: y3, mode: C, doc: p2[A] });
              break;
            case nt3:
              if (m >= 2)
                throw new Error("There are too many 'cursor' in doc.");
              a2.push(ar3), m++;
              break;
            case Xe2:
              i2.push({ ind: xp2(y3, t2), mode: C, doc: p2.contents });
              break;
            case Ye2:
              i2.push({ ind: hp2(y3, p2.n, t2), mode: C, doc: p2.contents });
              break;
            case st3:
              u2 -= es(a2);
              break;
            case le2:
              switch (C) {
                case at3:
                  if (!o2) {
                    i2.push({ ind: y3, mode: p2.break ? Se3 : at3, doc: p2.contents });
                    break;
                  }
                case Se3: {
                  o2 = false;
                  let A = { ind: y3, mode: at3, doc: p2.contents }, T3 = n2 - u2, S3 = c2.length > 0;
                  if (!p2.break && Jr2(A, i2, T3, S3, r2))
                    i2.push(A);
                  else if (p2.expandedStates) {
                    let B2 = O2(false, p2.expandedStates, -1);
                    if (p2.break) {
                      i2.push({ ind: y3, mode: Se3, doc: B2 });
                      break;
                    } else
                      for (let _3 = 1; _3 < p2.expandedStates.length + 1; _3++)
                        if (_3 >= p2.expandedStates.length) {
                          i2.push({ ind: y3, mode: Se3, doc: B2 });
                          break;
                        } else {
                          let J3 = p2.expandedStates[_3], j2 = { ind: y3, mode: at3, doc: J3 };
                          if (Jr2(j2, i2, T3, S3, r2)) {
                            i2.push(j2);
                            break;
                          }
                        }
                  } else
                    i2.push({ ind: y3, mode: Se3, doc: p2.contents });
                  break;
                }
              }
              p2.id && (r2[p2.id] = O2(false, i2, -1).mode);
              break;
            case Pe3: {
              let A = n2 - u2, { parts: T3 } = p2;
              if (T3.length === 0)
                break;
              let [S3, B2] = T3, _3 = { ind: y3, mode: at3, doc: S3 }, J3 = { ind: y3, mode: Se3, doc: S3 }, j2 = Jr2(_3, [], A, c2.length > 0, r2, true);
              if (T3.length === 1) {
                j2 ? i2.push(_3) : i2.push(J3);
                break;
              }
              let h2 = { ind: y3, mode: at3, doc: B2 }, W2 = { ind: y3, mode: Se3, doc: B2 };
              if (T3.length === 2) {
                j2 ? i2.push(h2, _3) : i2.push(W2, J3);
                break;
              }
              T3.splice(0, 2);
              let Fe3 = { ind: y3, mode: C, doc: qt2(T3) }, H3 = T3[0];
              Jr2({ ind: y3, mode: at3, doc: [S3, B2, H3] }, [], A, c2.length > 0, r2, true) ? i2.push(Fe3, h2, _3) : j2 ? i2.push(Fe3, W2, _3) : i2.push(Fe3, W2, J3);
              break;
            }
            case xe3:
            case He2: {
              let A = p2.groupId ? r2[p2.groupId] : C;
              if (A === Se3) {
                let T3 = p2.type === xe3 ? p2.breakContents : p2.negate ? p2.contents : f2(p2.contents);
                T3 && i2.push({ ind: y3, mode: C, doc: T3 });
              }
              if (A === at3) {
                let T3 = p2.type === xe3 ? p2.flatContents : p2.negate ? f2(p2.contents) : p2.contents;
                T3 && i2.push({ ind: y3, mode: C, doc: T3 });
              }
              break;
            }
            case Ve2:
              c2.push({ ind: y3, mode: C, doc: p2.contents });
              break;
            case $e3:
              c2.length > 0 && i2.push({ ind: y3, mode: C, doc: Un3 });
              break;
            case me2:
              switch (C) {
                case at3:
                  if (p2.hard)
                    o2 = true;
                  else {
                    p2.soft || (a2.push(" "), u2 += 1);
                    break;
                  }
                case Se3:
                  if (c2.length > 0) {
                    i2.push({ ind: y3, mode: C, doc: p2 }, ...c2.reverse()), c2.length = 0;
                    break;
                  }
                  p2.literal ? y3.root ? (a2.push(s2, y3.root.value), u2 = y3.root.length) : (a2.push(s2), u2 = 0) : (u2 -= es(a2), a2.push(s2 + y3.value), u2 = y3.length);
                  break;
              }
              break;
            case je2:
              i2.push({ ind: y3, mode: C, doc: p2.contents });
              break;
            case ve3:
              break;
            default:
              throw new Ct(p2);
          }
          i2.length === 0 && c2.length > 0 && (i2.push(...c2.reverse()), c2.length = 0);
        }
        let D = a2.indexOf(ar3);
        if (D !== -1) {
          let y3 = a2.indexOf(ar3, D + 1), C = a2.slice(0, D).join(""), p2 = a2.slice(D + 1, y3).join(""), A = a2.slice(y3 + 1).join("");
          return { formatted: C + p2 + A, cursorNodeStart: C.length, cursorNodeText: p2 };
        }
        return { formatted: a2.join("") };
      }
      function gp(e2, t2, r2 = 0) {
        let n2 = 0;
        for (let s2 = r2; s2 < e2.length; ++s2)
          e2[s2] === "	" ? n2 = n2 + t2 - n2 % t2 : n2++;
        return n2;
      }
      var Wu3 = gp;
      function Sp2(e2, t2) {
        let r2 = e2.lastIndexOf(`
`);
        return r2 === -1 ? 0 : Wu3(e2.slice(r2 + 1).match(/^[\t ]*/u)[0], t2);
      }
      var Gu3 = Sp2;
      function qr2(e2, t2, r2) {
        let { node: n2 } = e2;
        if (n2.type === "TemplateLiteral" && Pp2(e2)) {
          let c2 = Bp(e2, r2, t2);
          if (c2)
            return c2;
        }
        let u2 = "expressions";
        n2.type === "TSTemplateLiteralType" && (u2 = "types");
        let i2 = [], a2 = e2.map(t2, u2);
        i2.push(ke3, "`");
        let o2 = 0;
        return e2.each(({ index: c2, node: m }) => {
          if (i2.push(t2()), m.tail)
            return;
          let { tabWidth: D } = r2, y3 = m.value.raw, C = y3.includes(`
`) ? Gu3(y3, D) : o2;
          o2 = C;
          let p2 = a2[c2], A = n2[u2][c2], T3 = de2(r2.originalText, k(m), R3(n2.quasis[c2 + 1]));
          if (!T3) {
            let B2 = ts(p2, { ...r2, printWidth: Number.POSITIVE_INFINITY }).formatted;
            B2.includes(`
`) ? T3 = true : p2 = B2;
          }
          T3 && (d2(A) || A.type === "Identifier" || q2(A) || A.type === "ConditionalExpression" || A.type === "SequenceExpression" || Te2(A) || De3(A)) && (p2 = [f2([E2, p2]), E2]);
          let S3 = C === 0 && y3.endsWith(`
`) ? he3(Number.NEGATIVE_INFINITY, p2) : xu2(p2, C, D);
          i2.push(l2(["${", S3, ke3, "}"]));
        }, "quasis"), i2.push("`"), i2;
      }
      function Uu3(e2, t2) {
        let r2 = t2("quasi");
        return it3(r2.label && { tagged: true, ...r2.label }, [t2("tag"), t2(e2.node.typeArguments ? "typeArguments" : "typeParameters"), ke3, r2]);
      }
      function Bp(e2, t2, r2) {
        let { node: n2 } = e2, s2 = n2.quasis[0].value.raw.trim().split(/\s*\|\s*/u);
        if (s2.length > 1 || s2.some((u2) => u2.length > 0)) {
          t2.__inJestEach = true;
          let u2 = e2.map(r2, "expressions");
          t2.__inJestEach = false;
          let i2 = [], a2 = u2.map((y3) => "${" + ts(y3, { ...t2, printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" }).formatted + "}"), o2 = [{ hasLineBreak: false, cells: [] }];
          for (let y3 = 1; y3 < n2.quasis.length; y3++) {
            let C = O2(false, o2, -1), p2 = a2[y3 - 1];
            C.cells.push(p2), p2.includes(`
`) && (C.hasLineBreak = true), n2.quasis[y3].value.raw.includes(`
`) && o2.push({ hasLineBreak: false, cells: [] });
          }
          let c2 = Math.max(s2.length, ...o2.map((y3) => y3.cells.length)), m = Array.from({ length: c2 }).fill(0), D = [{ cells: s2 }, ...o2.filter((y3) => y3.cells.length > 0)];
          for (let { cells: y3 } of D.filter((C) => !C.hasLineBreak))
            for (let [C, p2] of y3.entries())
              m[C] = Math.max(m[C], et2(p2));
          return i2.push(ke3, "`", f2([F, P2(F, D.map((y3) => P2(" | ", y3.cells.map((C, p2) => y3.hasLineBreak ? C : C + " ".repeat(m[p2] - et2(C))))))]), F, "`"), i2;
        }
      }
      function bp2(e2, t2) {
        let { node: r2 } = e2, n2 = t2();
        return d2(r2) && (n2 = l2([f2([E2, n2]), E2])), ["${", n2, ke3, "}"];
      }
      function Gt2(e2, t2) {
        return e2.map((r2) => bp2(r2, t2), "expressions");
      }
      function Wr2(e2, t2) {
        return mt3(e2, (r2) => typeof r2 == "string" ? t2 ? N2(false, r2, /(\\*)`/gu, "$1$1\\`") : rs(r2) : r2);
      }
      function rs(e2) {
        return N2(false, e2, /([\\`]|\$\{)/gu, String.raw`\$1`);
      }
      function Pp2({ node: e2, parent: t2 }) {
        let r2 = /^[fx]?(?:describe|it|test)$/u;
        return t2.type === "TaggedTemplateExpression" && t2.quasi === e2 && t2.tag.type === "MemberExpression" && t2.tag.property.type === "Identifier" && t2.tag.property.name === "each" && (t2.tag.object.type === "Identifier" && r2.test(t2.tag.object.name) || t2.tag.object.type === "MemberExpression" && t2.tag.object.property.type === "Identifier" && (t2.tag.object.property.name === "only" || t2.tag.object.property.name === "skip") && t2.tag.object.object.type === "Identifier" && r2.test(t2.tag.object.object.name));
      }
      var ss = [(e2, t2) => e2.type === "ObjectExpression" && t2 === "properties", (e2, t2) => e2.type === "CallExpression" && e2.callee.type === "Identifier" && e2.callee.name === "Component" && t2 === "arguments", (e2, t2) => e2.type === "Decorator" && t2 === "expression"];
      function Nu2(e2) {
        let t2 = (n2) => n2.type === "TemplateLiteral", r2 = (n2, s2) => Ae3(n2) && !n2.computed && n2.key.type === "Identifier" && n2.key.name === "styles" && s2 === "value";
        return e2.match(t2, (n2, s2) => U2(n2) && s2 === "elements", r2, ...ss) || e2.match(t2, r2, ...ss);
      }
      function Xu3(e2) {
        return e2.match((t2) => t2.type === "TemplateLiteral", (t2, r2) => Ae3(t2) && !t2.computed && t2.key.type === "Identifier" && t2.key.name === "template" && r2 === "value", ...ss);
      }
      function ns(e2, t2) {
        return d2(e2, g2.Block | g2.Leading, ({ value: r2 }) => r2 === ` ${t2} `);
      }
      function Gr3({ node: e2, parent: t2 }, r2) {
        return ns(e2, r2) || kp2(t2) && ns(t2, r2) || t2.type === "ExpressionStatement" && ns(t2, r2);
      }
      function kp2(e2) {
        return e2.type === "AsConstExpression" || e2.type === "TSAsExpression" && e2.typeAnnotation.type === "TSTypeReference" && e2.typeAnnotation.typeName.type === "Identifier" && e2.typeAnnotation.typeName.name === "const";
      }
      async function Ip2(e2, t2, r2) {
        let { node: n2 } = r2, s2 = n2.quasis.map((m) => m.value.raw), u2 = 0, i2 = s2.reduce((m, D, y3) => y3 === 0 ? D : m + "@prettier-placeholder-" + u2++ + "-id" + D, ""), a2 = await e2(i2, { parser: "scss" }), o2 = Gt2(r2, t2), c2 = Lp(a2, o2);
        if (!c2)
          throw new Error("Couldn't insert all the expressions");
        return ["`", f2([F, c2]), E2, "`"];
      }
      function Lp(e2, t2) {
        if (!w2(t2))
          return e2;
        let r2 = 0, n2 = mt3(Wt2(e2), (s2) => typeof s2 != "string" || !s2.includes("@prettier-placeholder") ? s2 : s2.split(/@prettier-placeholder-(\d+)-id/u).map((u2, i2) => i2 % 2 === 0 ? Ie3(u2) : (r2++, t2[u2])));
        return t2.length === r2 ? n2 : null;
      }
      function wp2({ node: e2, parent: t2, grandparent: r2 }) {
        return r2 && e2.quasis && t2.type === "JSXExpressionContainer" && r2.type === "JSXElement" && r2.openingElement.name.name === "style" && r2.openingElement.attributes.some((n2) => n2.type === "JSXAttribute" && n2.name.name === "jsx") || (t2 == null ? void 0 : t2.type) === "TaggedTemplateExpression" && t2.tag.type === "Identifier" && t2.tag.name === "css" || (t2 == null ? void 0 : t2.type) === "TaggedTemplateExpression" && t2.tag.type === "MemberExpression" && t2.tag.object.name === "css" && (t2.tag.property.name === "global" || t2.tag.property.name === "resolve");
      }
      function Ur2(e2) {
        return e2.type === "Identifier" && e2.name === "styled";
      }
      function Yu3(e2) {
        return /^[A-Z]/u.test(e2.object.name) && e2.property.name === "extend";
      }
      function Op2({ parent: e2 }) {
        if (!e2 || e2.type !== "TaggedTemplateExpression")
          return false;
        let t2 = e2.tag.type === "ParenthesizedExpression" ? e2.tag.expression : e2.tag;
        switch (t2.type) {
          case "MemberExpression":
            return Ur2(t2.object) || Yu3(t2);
          case "CallExpression":
            return Ur2(t2.callee) || t2.callee.type === "MemberExpression" && (t2.callee.object.type === "MemberExpression" && (Ur2(t2.callee.object.object) || Yu3(t2.callee.object)) || t2.callee.object.type === "CallExpression" && Ur2(t2.callee.object.callee));
          case "Identifier":
            return t2.name === "css";
          default:
            return false;
        }
      }
      function _p2({ parent: e2, grandparent: t2 }) {
        return (t2 == null ? void 0 : t2.type) === "JSXAttribute" && e2.type === "JSXExpressionContainer" && t2.name.type === "JSXIdentifier" && t2.name.name === "css";
      }
      function jp2(e2) {
        if (wp2(e2) || Op2(e2) || _p2(e2) || Nu2(e2))
          return Ip2;
      }
      var Hu3 = jp2;
      async function vp2(e2, t2, r2) {
        let { node: n2 } = r2, s2 = n2.quasis.length, u2 = Gt2(r2, t2), i2 = [];
        for (let a2 = 0; a2 < s2; a2++) {
          let o2 = n2.quasis[a2], c2 = a2 === 0, m = a2 === s2 - 1, D = o2.value.cooked, y3 = D.split(`
`), C = y3.length, p2 = u2[a2], A = C > 2 && y3[0].trim() === "" && y3[1].trim() === "", T3 = C > 2 && y3[C - 1].trim() === "" && y3[C - 2].trim() === "", S3 = y3.every((_3) => /^\s*(?:#[^\n\r]*)?$/u.test(_3));
          if (!m && /#[^\n\r]*$/u.test(y3[C - 1]))
            return null;
          let B2 = null;
          S3 ? B2 = Mp(y3) : B2 = await e2(D, { parser: "graphql" }), B2 ? (B2 = Wr2(B2, false), !c2 && A && i2.push(""), i2.push(B2), !m && T3 && i2.push("")) : !c2 && !m && A && i2.push(""), p2 && i2.push(p2);
        }
        return ["`", f2([F, P2(F, i2)]), F, "`"];
      }
      function Mp(e2) {
        let t2 = [], r2 = false, n2 = e2.map((s2) => s2.trim());
        for (let [s2, u2] of n2.entries())
          u2 !== "" && (n2[s2 - 1] === "" && r2 ? t2.push([F, u2]) : t2.push(u2), r2 = true);
        return t2.length === 0 ? null : P2(F, t2);
      }
      function Rp({ node: e2, parent: t2 }) {
        return Gr3({ node: e2, parent: t2 }, "GraphQL") || t2 && (t2.type === "TaggedTemplateExpression" && (t2.tag.type === "MemberExpression" && t2.tag.object.name === "graphql" && t2.tag.property.name === "experimental" || t2.tag.type === "Identifier" && (t2.tag.name === "gql" || t2.tag.name === "graphql")) || t2.type === "CallExpression" && t2.callee.type === "Identifier" && t2.callee.name === "graphql");
      }
      function Jp(e2) {
        if (Rp(e2))
          return vp2;
      }
      var Vu3 = Jp;
      var us = 0;
      async function $u3(e2, t2, r2, n2, s2) {
        let { node: u2 } = n2, i2 = us;
        us = us + 1 >>> 0;
        let a2 = (S3) => `PRETTIER_HTML_PLACEHOLDER_${S3}_${i2}_IN_JS`, o2 = u2.quasis.map((S3, B2, _3) => B2 === _3.length - 1 ? S3.value.cooked : S3.value.cooked + a2(B2)).join(""), c2 = Gt2(n2, r2), m = new RegExp(a2(String.raw`(\d+)`), "gu"), D = 0, y3 = await t2(o2, { parser: e2, __onHtmlRoot(S3) {
          D = S3.children.length;
        } }), C = mt3(y3, (S3) => {
          if (typeof S3 != "string")
            return S3;
          let B2 = [], _3 = S3.split(m);
          for (let J3 = 0; J3 < _3.length; J3++) {
            let j2 = _3[J3];
            if (J3 % 2 === 0) {
              j2 && (j2 = rs(j2), s2.__embeddedInHtml && (j2 = N2(false, j2, /<\/(?=script\b)/giu, String.raw`<\/`)), B2.push(j2));
              continue;
            }
            let h2 = Number(j2);
            B2.push(c2[h2]);
          }
          return B2;
        }), p2 = /^\s/u.test(o2) ? " " : "", A = /\s$/u.test(o2) ? " " : "", T3 = s2.htmlWhitespaceSensitivity === "ignore" ? F : p2 && A ? x2 : null;
        return T3 ? l2(["`", f2([T3, l2(C)]), T3, "`"]) : it3({ hug: false }, l2(["`", p2, D > 1 ? f2(l2(C)) : l2(C), A, "`"]));
      }
      function qp(e2) {
        return Gr3(e2, "HTML") || e2.match((t2) => t2.type === "TemplateLiteral", (t2, r2) => t2.type === "TaggedTemplateExpression" && t2.tag.type === "Identifier" && t2.tag.name === "html" && r2 === "quasi");
      }
      var Wp = $u3.bind(void 0, "html"), Gp = $u3.bind(void 0, "angular");
      function Up(e2) {
        if (qp(e2))
          return Wp;
        if (Xu3(e2))
          return Gp;
      }
      var Ku3 = Up;
      async function Np(e2, t2, r2) {
        let { node: n2 } = r2, s2 = N2(false, n2.quasis[0].value.raw, /((?:\\\\)*)\\`/gu, (o2, c2) => "\\".repeat(c2.length / 2) + "`"), u2 = Xp(s2), i2 = u2 !== "";
        i2 && (s2 = N2(false, s2, new RegExp(`^${u2}`, "gmu"), ""));
        let a2 = Wr2(await e2(s2, { parser: "markdown", __inJsTemplate: true }), true);
        return ["`", i2 ? f2([E2, a2]) : [Rr2, du3(a2)], E2, "`"];
      }
      function Xp(e2) {
        let t2 = e2.match(/^([^\S\n]*)\S/mu);
        return t2 === null ? "" : t2[1];
      }
      function Yp(e2) {
        if (Hp(e2))
          return Np;
      }
      function Hp({ node: e2, parent: t2 }) {
        return (t2 == null ? void 0 : t2.type) === "TaggedTemplateExpression" && e2.quasis.length === 1 && t2.tag.type === "Identifier" && (t2.tag.name === "md" || t2.tag.name === "markdown");
      }
      var zu3 = Yp;
      function Vp(e2) {
        let { node: t2 } = e2;
        if (t2.type !== "TemplateLiteral" || $p(t2))
          return;
        let r2;
        for (let n2 of [Hu3, Vu3, Ku3, zu3])
          if (r2 = n2(e2), !!r2)
            return t2.quasis.length === 1 && t2.quasis[0].value.raw.trim() === "" ? "``" : async (...s2) => {
              let u2 = await r2(...s2);
              return u2 && it3({ embed: true, ...u2.label }, u2);
            };
      }
      function $p({ quasis: e2 }) {
        return e2.some(({ value: { cooked: t2 } }) => t2 === null);
      }
      var Qu3 = Vp;
      var Kp = /\*\/$/, zp = /^\/\*\*?/, ri3 = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, Qp = /(^|\s+)\/\/([^\n\r]*)/g, Zu3 = /^(\r?\n)+/, Zp = /(?:^|\r?\n) *(@[^\n\r]*?) *\r?\n *(?![^\n\r@]*\/\/[^]*)([^\s@][^\n\r@]+?) *\r?\n/g, ei3 = /(?:^|\r?\n) *@(\S+) *([^\n\r]*)/g, ec = /(\r?\n|^) *\* ?/g, ni2 = [];
      function si2(e2) {
        let t2 = e2.match(ri3);
        return t2 ? t2[0].trimStart() : "";
      }
      function ui2(e2) {
        let t2 = e2.match(ri3), r2 = t2 == null ? void 0 : t2[0];
        return r2 == null ? e2 : e2.slice(r2.length);
      }
      function ii2(e2) {
        let t2 = `
`;
        e2 = N2(false, e2.replace(zp, "").replace(Kp, ""), ec, "$1");
        let r2 = "";
        for (; r2 !== e2; )
          r2 = e2, e2 = N2(false, e2, Zp, `${t2}$1 $2${t2}`);
        e2 = e2.replace(Zu3, "").trimEnd();
        let n2 = /* @__PURE__ */ Object.create(null), s2 = N2(false, e2, ei3, "").replace(Zu3, "").trimEnd(), u2;
        for (; u2 = ei3.exec(e2); ) {
          let i2 = N2(false, u2[2], Qp, "");
          if (typeof n2[u2[1]] == "string" || Array.isArray(n2[u2[1]])) {
            let a2 = n2[u2[1]];
            n2[u2[1]] = [...ni2, ...Array.isArray(a2) ? a2 : [a2], i2];
          } else
            n2[u2[1]] = i2;
        }
        return { comments: s2, pragmas: n2 };
      }
      function ai2({ comments: e2 = "", pragmas: t2 = {} }) {
        let r2 = `
`, n2 = "/**", s2 = " *", u2 = " */", i2 = Object.keys(t2), a2 = i2.flatMap((c2) => ti2(c2, t2[c2])).map((c2) => `${s2} ${c2}${r2}`).join("");
        if (!e2) {
          if (i2.length === 0)
            return "";
          if (i2.length === 1 && !Array.isArray(t2[i2[0]])) {
            let c2 = t2[i2[0]];
            return `${n2} ${ti2(i2[0], c2)[0]}${u2}`;
          }
        }
        let o2 = e2.split(r2).map((c2) => `${s2} ${c2}`).join(r2) + r2;
        return n2 + r2 + (e2 ? o2 : "") + (e2 && i2.length > 0 ? s2 + r2 : "") + a2 + u2;
      }
      function ti2(e2, t2) {
        return [...ni2, ...Array.isArray(t2) ? t2 : [t2]].map((r2) => `@${e2} ${r2}`.trim());
      }
      function tc2(e2) {
        if (!e2.startsWith("#!"))
          return "";
        let t2 = e2.indexOf(`
`);
        return t2 === -1 ? e2 : e2.slice(0, t2);
      }
      var oi2 = tc2;
      function rc(e2) {
        let t2 = oi2(e2);
        t2 && (e2 = e2.slice(t2.length + 1));
        let r2 = si2(e2), { pragmas: n2, comments: s2 } = ii2(r2);
        return { shebang: t2, text: e2, pragmas: n2, comments: s2 };
      }
      function pi3(e2) {
        let { shebang: t2, text: r2, pragmas: n2, comments: s2 } = rc(e2), u2 = ui2(r2), i2 = ai2({ pragmas: { format: "", ...n2 }, comments: s2.trimStart() });
        return (t2 ? `${t2}
` : "") + i2 + (u2.startsWith(`
`) ? `
` : `

`) + u2;
      }
      function nc(e2, t2) {
        let { originalText: r2, [Symbol.for("comments")]: n2, locStart: s2, locEnd: u2, [Symbol.for("printedComments")]: i2 } = t2, { node: a2 } = e2, o2 = s2(a2), c2 = u2(a2);
        for (let m of n2)
          s2(m) >= o2 && u2(m) <= c2 && i2.add(m);
        return r2.slice(o2, c2);
      }
      var ci3 = nc;
      function is(e2, t2) {
        var u2, i2, a2, o2, c2, m, D, y3, C;
        if (e2.isRoot)
          return false;
        let { node: r2, key: n2, parent: s2 } = e2;
        if (t2.__isInHtmlInterpolation && !t2.bracketSpacing && ac2(r2) && or3(e2))
          return true;
        if (sc2(r2))
          return false;
        if (r2.type === "Identifier") {
          if ((u2 = r2.extra) != null && u2.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/u.test(r2.name) || n2 === "left" && (r2.name === "async" && !s2.await || r2.name === "let") && s2.type === "ForOfStatement")
            return true;
          if (r2.name === "let") {
            let p2 = (i2 = e2.findAncestor((A) => A.type === "ForOfStatement")) == null ? void 0 : i2.left;
            if (p2 && ie2(p2, (A) => A === r2))
              return true;
          }
          if (n2 === "object" && r2.name === "let" && s2.type === "MemberExpression" && s2.computed && !s2.optional) {
            let p2 = e2.findAncestor((T3) => T3.type === "ExpressionStatement" || T3.type === "ForStatement" || T3.type === "ForInStatement"), A = p2 ? p2.type === "ExpressionStatement" ? p2.expression : p2.type === "ForStatement" ? p2.init : p2.left : void 0;
            if (A && ie2(A, (T3) => T3 === r2))
              return true;
          }
          if (n2 === "expression")
            switch (r2.name) {
              case "await":
              case "interface":
              case "module":
              case "using":
              case "yield":
              case "let":
              case "component":
              case "hook":
              case "type": {
                let p2 = e2.findAncestor((A) => !Te2(A));
                if (p2 !== s2 && p2.type === "ExpressionStatement")
                  return true;
              }
            }
          return false;
        }
        if (r2.type === "ObjectExpression" || r2.type === "FunctionExpression" || r2.type === "ClassExpression" || r2.type === "DoExpression") {
          let p2 = (a2 = e2.findAncestor((A) => A.type === "ExpressionStatement")) == null ? void 0 : a2.expression;
          if (p2 && ie2(p2, (A) => A === r2))
            return true;
        }
        if (r2.type === "ObjectExpression") {
          let p2 = (o2 = e2.findAncestor((A) => A.type === "ArrowFunctionExpression")) == null ? void 0 : o2.body;
          if (p2 && p2.type !== "SequenceExpression" && p2.type !== "AssignmentExpression" && ie2(p2, (A) => A === r2))
            return true;
        }
        switch (s2.type) {
          case "ParenthesizedExpression":
            return false;
          case "ClassDeclaration":
          case "ClassExpression":
            if (n2 === "superClass" && (r2.type === "ArrowFunctionExpression" || r2.type === "AssignmentExpression" || r2.type === "AwaitExpression" || r2.type === "BinaryExpression" || r2.type === "ConditionalExpression" || r2.type === "LogicalExpression" || r2.type === "NewExpression" || r2.type === "ObjectExpression" || r2.type === "SequenceExpression" || r2.type === "TaggedTemplateExpression" || r2.type === "UnaryExpression" || r2.type === "UpdateExpression" || r2.type === "YieldExpression" || r2.type === "TSNonNullExpression" || r2.type === "ClassExpression" && w2(r2.decorators)))
              return true;
            break;
          case "ExportDefaultDeclaration":
            return li3(e2, t2) || r2.type === "SequenceExpression";
          case "Decorator":
            if (n2 === "expression" && !pc2(r2))
              return true;
            break;
          case "TypeAnnotation":
            if (e2.match(void 0, void 0, (p2, A) => A === "returnType" && p2.type === "ArrowFunctionExpression") && ic(r2))
              return true;
            break;
          case "BinaryExpression":
            if (n2 === "left" && (s2.operator === "in" || s2.operator === "instanceof") && r2.type === "UnaryExpression")
              return true;
            break;
          case "VariableDeclarator":
            if (n2 === "init" && e2.match(void 0, void 0, (p2, A) => A === "declarations" && p2.type === "VariableDeclaration", (p2, A) => A === "left" && p2.type === "ForInStatement"))
              return true;
            break;
        }
        switch (r2.type) {
          case "UpdateExpression":
            if (s2.type === "UnaryExpression")
              return r2.prefix && (r2.operator === "++" && s2.operator === "+" || r2.operator === "--" && s2.operator === "-");
          case "UnaryExpression":
            switch (s2.type) {
              case "UnaryExpression":
                return r2.operator === s2.operator && (r2.operator === "+" || r2.operator === "-");
              case "BindExpression":
                return true;
              case "MemberExpression":
              case "OptionalMemberExpression":
                return n2 === "object";
              case "TaggedTemplateExpression":
                return true;
              case "NewExpression":
              case "CallExpression":
              case "OptionalCallExpression":
                return n2 === "callee";
              case "BinaryExpression":
                return n2 === "left" && s2.operator === "**";
              case "TSNonNullExpression":
                return true;
              default:
                return false;
            }
          case "BinaryExpression":
            if (s2.type === "UpdateExpression" || r2.operator === "in" && uc2(e2))
              return true;
            if (r2.operator === "|>" && ((c2 = r2.extra) != null && c2.parenthesized)) {
              let p2 = e2.grandparent;
              if (p2.type === "BinaryExpression" && p2.operator === "|>")
                return true;
            }
          case "TSTypeAssertion":
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "AsExpression":
          case "AsConstExpression":
          case "SatisfiesExpression":
          case "LogicalExpression":
            switch (s2.type) {
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "AsExpression":
              case "AsConstExpression":
              case "SatisfiesExpression":
                return !Te2(r2);
              case "ConditionalExpression":
                return Te2(r2) || au2(r2);
              case "CallExpression":
              case "NewExpression":
              case "OptionalCallExpression":
                return n2 === "callee";
              case "ClassExpression":
              case "ClassDeclaration":
                return n2 === "superClass";
              case "TSTypeAssertion":
              case "TaggedTemplateExpression":
              case "UnaryExpression":
              case "JSXSpreadAttribute":
              case "SpreadElement":
              case "BindExpression":
              case "AwaitExpression":
              case "TSNonNullExpression":
              case "UpdateExpression":
                return true;
              case "MemberExpression":
              case "OptionalMemberExpression":
                return n2 === "object";
              case "AssignmentExpression":
              case "AssignmentPattern":
                return n2 === "left" && (r2.type === "TSTypeAssertion" || Te2(r2));
              case "LogicalExpression":
                if (r2.type === "LogicalExpression")
                  return s2.operator !== r2.operator;
              case "BinaryExpression": {
                let { operator: p2, type: A } = r2;
                if (!p2 && A !== "TSTypeAssertion")
                  return true;
                let T3 = er2(p2), S3 = s2.operator, B2 = er2(S3);
                return B2 > T3 || n2 === "right" && B2 === T3 || B2 === T3 && !nr2(S3, p2) ? true : B2 < T3 && p2 === "%" ? S3 === "+" || S3 === "-" : !!yu2(S3);
              }
              default:
                return false;
            }
          case "SequenceExpression":
            switch (s2.type) {
              case "ReturnStatement":
                return false;
              case "ForStatement":
                return false;
              case "ExpressionStatement":
                return n2 !== "expression";
              case "ArrowFunctionExpression":
                return n2 !== "body";
              default:
                return true;
            }
          case "YieldExpression":
            if (s2.type === "AwaitExpression" || s2.type === "TSTypeAssertion")
              return true;
          case "AwaitExpression":
            switch (s2.type) {
              case "TaggedTemplateExpression":
              case "UnaryExpression":
              case "LogicalExpression":
              case "SpreadElement":
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSNonNullExpression":
              case "AsExpression":
              case "AsConstExpression":
              case "SatisfiesExpression":
              case "BindExpression":
                return true;
              case "MemberExpression":
              case "OptionalMemberExpression":
                return n2 === "object";
              case "NewExpression":
              case "CallExpression":
              case "OptionalCallExpression":
                return n2 === "callee";
              case "ConditionalExpression":
                return n2 === "test";
              case "BinaryExpression":
                return !(!r2.argument && s2.operator === "|>");
              default:
                return false;
            }
          case "TSFunctionType":
            if (e2.match((p2) => p2.type === "TSFunctionType", (p2, A) => A === "typeAnnotation" && p2.type === "TSTypeAnnotation", (p2, A) => A === "returnType" && p2.type === "ArrowFunctionExpression"))
              return true;
          case "TSConditionalType":
          case "TSConstructorType":
            if (n2 === "extendsType" && s2.type === "TSConditionalType") {
              if (r2.type === "TSConditionalType")
                return true;
              let { typeAnnotation: p2 } = r2.returnType || r2.typeAnnotation;
              if (p2.type === "TSTypePredicate" && p2.typeAnnotation && (p2 = p2.typeAnnotation.typeAnnotation), p2.type === "TSInferType" && p2.typeParameter.constraint)
                return true;
            }
            if (n2 === "checkType" && s2.type === "TSConditionalType")
              return true;
          case "TSUnionType":
          case "TSIntersectionType":
            if ((s2.type === "TSUnionType" || s2.type === "TSIntersectionType") && s2.types.length > 1 && (!r2.types || r2.types.length > 1))
              return true;
          case "TSInferType":
            if (r2.type === "TSInferType") {
              if (s2.type === "TSRestType")
                return false;
              if (n2 === "types" && (s2.type === "TSUnionType" || s2.type === "TSIntersectionType") && r2.typeParameter.type === "TSTypeParameter" && r2.typeParameter.constraint)
                return true;
            }
          case "TSTypeOperator":
            return s2.type === "TSArrayType" || s2.type === "TSOptionalType" || s2.type === "TSRestType" || n2 === "objectType" && s2.type === "TSIndexedAccessType" || s2.type === "TSTypeOperator" || s2.type === "TSTypeAnnotation" && e2.grandparent.type.startsWith("TSJSDoc");
          case "TSTypeQuery":
            return n2 === "objectType" && s2.type === "TSIndexedAccessType" || n2 === "elementType" && s2.type === "TSArrayType";
          case "TypeOperator":
            return s2.type === "ArrayTypeAnnotation" || s2.type === "NullableTypeAnnotation" || n2 === "objectType" && (s2.type === "IndexedAccessType" || s2.type === "OptionalIndexedAccessType") || s2.type === "TypeOperator";
          case "TypeofTypeAnnotation":
            return n2 === "objectType" && (s2.type === "IndexedAccessType" || s2.type === "OptionalIndexedAccessType") || n2 === "elementType" && s2.type === "ArrayTypeAnnotation";
          case "ArrayTypeAnnotation":
            return s2.type === "NullableTypeAnnotation";
          case "IntersectionTypeAnnotation":
          case "UnionTypeAnnotation":
            return s2.type === "TypeOperator" || s2.type === "ArrayTypeAnnotation" || s2.type === "NullableTypeAnnotation" || s2.type === "IntersectionTypeAnnotation" || s2.type === "UnionTypeAnnotation" || n2 === "objectType" && (s2.type === "IndexedAccessType" || s2.type === "OptionalIndexedAccessType");
          case "InferTypeAnnotation":
          case "NullableTypeAnnotation":
            return s2.type === "ArrayTypeAnnotation" || n2 === "objectType" && (s2.type === "IndexedAccessType" || s2.type === "OptionalIndexedAccessType");
          case "ComponentTypeAnnotation":
          case "FunctionTypeAnnotation": {
            if (r2.type === "ComponentTypeAnnotation" && (r2.rendersType === null || r2.rendersType === void 0))
              return false;
            if (e2.match(void 0, (A, T3) => T3 === "typeAnnotation" && A.type === "TypeAnnotation", (A, T3) => T3 === "returnType" && A.type === "ArrowFunctionExpression") || e2.match(void 0, (A, T3) => T3 === "typeAnnotation" && A.type === "TypePredicate", (A, T3) => T3 === "typeAnnotation" && A.type === "TypeAnnotation", (A, T3) => T3 === "returnType" && A.type === "ArrowFunctionExpression"))
              return true;
            let p2 = s2.type === "NullableTypeAnnotation" ? e2.grandparent : s2;
            return p2.type === "UnionTypeAnnotation" || p2.type === "IntersectionTypeAnnotation" || p2.type === "ArrayTypeAnnotation" || n2 === "objectType" && (p2.type === "IndexedAccessType" || p2.type === "OptionalIndexedAccessType") || n2 === "checkType" && s2.type === "ConditionalTypeAnnotation" || n2 === "extendsType" && s2.type === "ConditionalTypeAnnotation" && ((m = r2.returnType) == null ? void 0 : m.type) === "InferTypeAnnotation" && ((D = r2.returnType) == null ? void 0 : D.typeParameter.bound) || p2.type === "NullableTypeAnnotation" || s2.type === "FunctionTypeParam" && s2.name === null && K2(r2).some((A) => {
              var T3;
              return ((T3 = A.typeAnnotation) == null ? void 0 : T3.type) === "NullableTypeAnnotation";
            });
          }
          case "ConditionalTypeAnnotation":
            if (n2 === "extendsType" && s2.type === "ConditionalTypeAnnotation" && r2.type === "ConditionalTypeAnnotation" || n2 === "checkType" && s2.type === "ConditionalTypeAnnotation")
              return true;
          case "OptionalIndexedAccessType":
            return n2 === "objectType" && s2.type === "IndexedAccessType";
          case "StringLiteral":
          case "NumericLiteral":
          case "Literal":
            if (typeof r2.value == "string" && s2.type === "ExpressionStatement" && !s2.directive) {
              let p2 = e2.grandparent;
              return p2.type === "Program" || p2.type === "BlockStatement";
            }
            return n2 === "object" && s2.type === "MemberExpression" && typeof r2.value == "number";
          case "AssignmentExpression": {
            let p2 = e2.grandparent;
            return n2 === "body" && s2.type === "ArrowFunctionExpression" ? true : n2 === "key" && (s2.type === "ClassProperty" || s2.type === "PropertyDefinition") && s2.computed || (n2 === "init" || n2 === "update") && s2.type === "ForStatement" ? false : s2.type === "ExpressionStatement" ? r2.left.type === "ObjectPattern" : !(n2 === "key" && s2.type === "TSPropertySignature" || s2.type === "AssignmentExpression" || s2.type === "SequenceExpression" && p2.type === "ForStatement" && (p2.init === s2 || p2.update === s2) || n2 === "value" && s2.type === "Property" && p2.type === "ObjectPattern" && p2.properties.includes(s2) || s2.type === "NGChainedExpression");
          }
          case "ConditionalExpression":
            switch (s2.type) {
              case "TaggedTemplateExpression":
              case "UnaryExpression":
              case "SpreadElement":
              case "BinaryExpression":
              case "LogicalExpression":
              case "NGPipeExpression":
              case "ExportDefaultDeclaration":
              case "AwaitExpression":
              case "JSXSpreadAttribute":
              case "TSTypeAssertion":
              case "TypeCastExpression":
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "AsExpression":
              case "AsConstExpression":
              case "SatisfiesExpression":
              case "TSNonNullExpression":
                return true;
              case "NewExpression":
              case "CallExpression":
              case "OptionalCallExpression":
                return n2 === "callee";
              case "ConditionalExpression":
                return t2.experimentalTernaries ? false : n2 === "test";
              case "MemberExpression":
              case "OptionalMemberExpression":
                return n2 === "object";
              default:
                return false;
            }
          case "FunctionExpression":
            switch (s2.type) {
              case "NewExpression":
              case "CallExpression":
              case "OptionalCallExpression":
                return n2 === "callee";
              case "TaggedTemplateExpression":
                return true;
              default:
                return false;
            }
          case "ArrowFunctionExpression":
            switch (s2.type) {
              case "BinaryExpression":
                return s2.operator !== "|>" || ((y3 = r2.extra) == null ? void 0 : y3.parenthesized);
              case "NewExpression":
              case "CallExpression":
              case "OptionalCallExpression":
                return n2 === "callee";
              case "MemberExpression":
              case "OptionalMemberExpression":
                return n2 === "object";
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "AsExpression":
              case "AsConstExpression":
              case "SatisfiesExpression":
              case "TSNonNullExpression":
              case "BindExpression":
              case "TaggedTemplateExpression":
              case "UnaryExpression":
              case "LogicalExpression":
              case "AwaitExpression":
              case "TSTypeAssertion":
                return true;
              case "ConditionalExpression":
                return n2 === "test";
              default:
                return false;
            }
          case "ClassExpression":
            switch (s2.type) {
              case "NewExpression":
                return n2 === "callee";
              default:
                return false;
            }
          case "OptionalMemberExpression":
          case "OptionalCallExpression":
          case "CallExpression":
          case "MemberExpression":
            if (oc2(e2))
              return true;
          case "TaggedTemplateExpression":
          case "TSNonNullExpression":
            if (n2 === "callee" && (s2.type === "BindExpression" || s2.type === "NewExpression")) {
              let p2 = r2;
              for (; p2; )
                switch (p2.type) {
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                  case "BindExpression":
                    p2 = p2.object;
                    break;
                  case "TaggedTemplateExpression":
                    p2 = p2.tag;
                    break;
                  case "TSNonNullExpression":
                    p2 = p2.expression;
                    break;
                  default:
                    return false;
                }
            }
            return false;
          case "BindExpression":
            return n2 === "callee" && (s2.type === "BindExpression" || s2.type === "NewExpression") || n2 === "object" && q2(s2);
          case "NGPipeExpression":
            return !(s2.type === "NGRoot" || s2.type === "NGMicrosyntaxExpression" || s2.type === "ObjectProperty" && !((C = r2.extra) != null && C.parenthesized) || U2(s2) || n2 === "arguments" && L3(s2) || n2 === "right" && s2.type === "NGPipeExpression" || n2 === "property" && s2.type === "MemberExpression" || s2.type === "AssignmentExpression");
          case "JSXFragment":
          case "JSXElement":
            return n2 === "callee" || n2 === "left" && s2.type === "BinaryExpression" && s2.operator === "<" || !U2(s2) && s2.type !== "ArrowFunctionExpression" && s2.type !== "AssignmentExpression" && s2.type !== "AssignmentPattern" && s2.type !== "BinaryExpression" && s2.type !== "NewExpression" && s2.type !== "ConditionalExpression" && s2.type !== "ExpressionStatement" && s2.type !== "JsExpressionRoot" && s2.type !== "JSXAttribute" && s2.type !== "JSXElement" && s2.type !== "JSXExpressionContainer" && s2.type !== "JSXFragment" && s2.type !== "LogicalExpression" && !L3(s2) && !Ae3(s2) && s2.type !== "ReturnStatement" && s2.type !== "ThrowStatement" && s2.type !== "TypeCastExpression" && s2.type !== "VariableDeclarator" && s2.type !== "YieldExpression";
          case "TSInstantiationExpression":
            return n2 === "object" && q2(s2);
        }
        return false;
      }
      var sc2 = v2(["BlockStatement", "BreakStatement", "ComponentDeclaration", "ClassBody", "ClassDeclaration", "ClassMethod", "ClassProperty", "PropertyDefinition", "ClassPrivateProperty", "ContinueStatement", "DebuggerStatement", "DeclareComponent", "DeclareClass", "DeclareExportAllDeclaration", "DeclareExportDeclaration", "DeclareFunction", "DeclareHook", "DeclareInterface", "DeclareModule", "DeclareModuleExports", "DeclareNamespace", "DeclareVariable", "DeclareEnum", "DoWhileStatement", "EnumDeclaration", "ExportAllDeclaration", "ExportDefaultDeclaration", "ExportNamedDeclaration", "ExpressionStatement", "ForInStatement", "ForOfStatement", "ForStatement", "FunctionDeclaration", "HookDeclaration", "IfStatement", "ImportDeclaration", "InterfaceDeclaration", "LabeledStatement", "MethodDefinition", "ReturnStatement", "SwitchStatement", "ThrowStatement", "TryStatement", "TSDeclareFunction", "TSEnumDeclaration", "TSImportEqualsDeclaration", "TSInterfaceDeclaration", "TSModuleDeclaration", "TSNamespaceExportDeclaration", "TypeAlias", "VariableDeclaration", "WhileStatement", "WithStatement"]);
      function uc2(e2) {
        let t2 = 0, { node: r2 } = e2;
        for (; r2; ) {
          let n2 = e2.getParentNode(t2++);
          if ((n2 == null ? void 0 : n2.type) === "ForStatement" && n2.init === r2)
            return true;
          r2 = n2;
        }
        return false;
      }
      function ic(e2) {
        return tr2(e2, (t2) => t2.type === "ObjectTypeAnnotation" && tr2(t2, (r2) => r2.type === "FunctionTypeAnnotation"));
      }
      function ac2(e2) {
        return se2(e2);
      }
      function or3(e2) {
        let { parent: t2, key: r2 } = e2;
        switch (t2.type) {
          case "NGPipeExpression":
            if (r2 === "arguments" && e2.isLast)
              return e2.callParent(or3);
            break;
          case "ObjectProperty":
            if (r2 === "value")
              return e2.callParent(() => e2.key === "properties" && e2.isLast);
            break;
          case "BinaryExpression":
          case "LogicalExpression":
            if (r2 === "right")
              return e2.callParent(or3);
            break;
          case "ConditionalExpression":
            if (r2 === "alternate")
              return e2.callParent(or3);
            break;
          case "UnaryExpression":
            if (t2.prefix)
              return e2.callParent(or3);
            break;
        }
        return false;
      }
      function li3(e2, t2) {
        let { node: r2, parent: n2 } = e2;
        return r2.type === "FunctionExpression" || r2.type === "ClassExpression" ? n2.type === "ExportDefaultDeclaration" || !is(e2, t2) : !jt2(r2) || n2.type !== "ExportDefaultDeclaration" && is(e2, t2) ? false : e2.call(() => li3(e2, t2), ...Pr2(r2));
      }
      function oc2(e2) {
        let { node: t2, parent: r2, grandparent: n2, key: s2 } = e2;
        return !!((t2.type === "OptionalMemberExpression" || t2.type === "OptionalCallExpression") && (s2 === "object" && r2.type === "MemberExpression" || s2 === "callee" && (r2.type === "CallExpression" || r2.type === "NewExpression") || r2.type === "TSNonNullExpression" && n2.type === "MemberExpression" && n2.object === r2) || e2.match(() => t2.type === "CallExpression" || t2.type === "MemberExpression", (u2, i2) => i2 === "expression" && u2.type === "ChainExpression") && (e2.match(void 0, void 0, (u2, i2) => i2 === "callee" && (u2.type === "CallExpression" && !u2.optional || u2.type === "NewExpression") || i2 === "object" && u2.type === "MemberExpression" && !u2.optional) || e2.match(void 0, void 0, (u2, i2) => i2 === "expression" && u2.type === "TSNonNullExpression", (u2, i2) => i2 === "object" && u2.type === "MemberExpression")) || e2.match(() => t2.type === "CallExpression" || t2.type === "MemberExpression", (u2, i2) => i2 === "expression" && u2.type === "TSNonNullExpression", (u2, i2) => i2 === "expression" && u2.type === "ChainExpression", (u2, i2) => i2 === "object" && u2.type === "MemberExpression"));
      }
      function as(e2) {
        return e2.type === "Identifier" ? true : q2(e2) ? !e2.computed && !e2.optional && e2.property.type === "Identifier" && as(e2.object) : false;
      }
      function pc2(e2) {
        return e2.type === "ChainExpression" && (e2 = e2.expression), as(e2) || L3(e2) && !e2.optional && as(e2.callee);
      }
      var Be3 = is;
      function cc2(e2, t2) {
        let r2 = t2 - 1;
        r2 = Ge3(e2, r2, { backwards: true }), r2 = Ue2(e2, r2, { backwards: true }), r2 = Ge3(e2, r2, { backwards: true });
        let n2 = Ue2(e2, r2, { backwards: true });
        return r2 !== n2;
      }
      var mi = cc2;
      var lc2 = () => true;
      function os(e2, t2) {
        let r2 = e2.node;
        return r2.printed = true, t2.printer.printComment(e2, t2);
      }
      function mc2(e2, t2) {
        var m;
        let r2 = e2.node, n2 = [os(e2, t2)], { printer: s2, originalText: u2, locStart: i2, locEnd: a2 } = t2;
        if ((m = s2.isBlockComment) == null ? void 0 : m.call(s2, r2)) {
          let D = te2(u2, a2(r2)) ? te2(u2, i2(r2), { backwards: true }) ? F : x2 : " ";
          n2.push(D);
        } else
          n2.push(F);
        let c2 = Ue2(u2, Ge3(u2, a2(r2)));
        return c2 !== false && te2(u2, c2) && n2.push(F), n2;
      }
      function yc2(e2, t2, r2) {
        var c2;
        let n2 = e2.node, s2 = os(e2, t2), { printer: u2, originalText: i2, locStart: a2 } = t2, o2 = (c2 = u2.isBlockComment) == null ? void 0 : c2.call(u2, n2);
        if (r2 != null && r2.hasLineSuffix && !(r2 != null && r2.isBlock) || te2(i2, a2(n2), { backwards: true })) {
          let m = mi(i2, a2(n2));
          return { doc: Gn3([F, m ? F : "", s2]), isBlock: o2, hasLineSuffix: true };
        }
        return !o2 || r2 != null && r2.hasLineSuffix ? { doc: [Gn3([" ", s2]), Ee2], isBlock: o2, hasLineSuffix: true } : { doc: [" ", s2], isBlock: o2, hasLineSuffix: false };
      }
      function M3(e2, t2, r2 = {}) {
        let { node: n2 } = e2;
        if (!w2(n2 == null ? void 0 : n2.comments))
          return "";
        let { indent: s2 = false, marker: u2, filter: i2 = lc2 } = r2, a2 = [];
        if (e2.each(({ node: c2 }) => {
          c2.leading || c2.trailing || c2.marker !== u2 || !i2(c2) || a2.push(os(e2, t2));
        }, "comments"), a2.length === 0)
          return "";
        let o2 = P2(F, a2);
        return s2 ? f2([F, o2]) : o2;
      }
      function ps(e2, t2) {
        let r2 = e2.node;
        if (!r2)
          return {};
        let n2 = t2[Symbol.for("printedComments")];
        if ((r2.comments || []).filter((o2) => !n2.has(o2)).length === 0)
          return { leading: "", trailing: "" };
        let u2 = [], i2 = [], a2;
        return e2.each(() => {
          let o2 = e2.node;
          if (n2 != null && n2.has(o2))
            return;
          let { leading: c2, trailing: m } = o2;
          c2 ? u2.push(mc2(e2, t2)) : m && (a2 = yc2(e2, t2, a2), i2.push(a2.doc));
        }, "comments"), { leading: u2, trailing: i2 };
      }
      function ye(e2, t2, r2) {
        let { leading: n2, trailing: s2 } = ps(e2, r2);
        return !n2 && !s2 ? t2 : ir3(t2, (u2) => [n2, u2, s2]);
      }
      var cs = class extends Error {
        constructor(t2, r2, n2 = "type") {
          super(`Unexpected ${r2} node ${n2}: ${JSON.stringify(t2[n2])}.`);
          __publicField(this, "name", "UnexpectedNodeError");
          this.node = t2;
        }
      }, Me3 = cs;
      function ls(e2) {
        if (typeof e2 != "string")
          throw new TypeError("Expected a string");
        return e2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
      }
      var Re3, ms = class {
        constructor(t2) {
          Ws2(this, Re3);
          Gs2(this, Re3, new Set(t2));
        }
        getLeadingWhitespaceCount(t2) {
          let r2 = pt3(this, Re3), n2 = 0;
          for (let s2 = 0; s2 < t2.length && r2.has(t2.charAt(s2)); s2++)
            n2++;
          return n2;
        }
        getTrailingWhitespaceCount(t2) {
          let r2 = pt3(this, Re3), n2 = 0;
          for (let s2 = t2.length - 1; s2 >= 0 && r2.has(t2.charAt(s2)); s2--)
            n2++;
          return n2;
        }
        getLeadingWhitespace(t2) {
          let r2 = this.getLeadingWhitespaceCount(t2);
          return t2.slice(0, r2);
        }
        getTrailingWhitespace(t2) {
          let r2 = this.getTrailingWhitespaceCount(t2);
          return t2.slice(t2.length - r2);
        }
        hasLeadingWhitespace(t2) {
          return pt3(this, Re3).has(t2.charAt(0));
        }
        hasTrailingWhitespace(t2) {
          return pt3(this, Re3).has(O2(false, t2, -1));
        }
        trimStart(t2) {
          let r2 = this.getLeadingWhitespaceCount(t2);
          return t2.slice(r2);
        }
        trimEnd(t2) {
          let r2 = this.getTrailingWhitespaceCount(t2);
          return t2.slice(0, t2.length - r2);
        }
        trim(t2) {
          return this.trimEnd(this.trimStart(t2));
        }
        split(t2, r2 = false) {
          let n2 = `[${ls([...pt3(this, Re3)].join(""))}]+`, s2 = new RegExp(r2 ? `(${n2})` : n2, "u");
          return t2.split(s2);
        }
        hasWhitespaceCharacter(t2) {
          let r2 = pt3(this, Re3);
          return Array.prototype.some.call(t2, (n2) => r2.has(n2));
        }
        hasNonWhitespaceCharacter(t2) {
          let r2 = pt3(this, Re3);
          return Array.prototype.some.call(t2, (n2) => !r2.has(n2));
        }
        isWhitespaceOnly(t2) {
          let r2 = pt3(this, Re3);
          return Array.prototype.every.call(t2, (n2) => r2.has(n2));
        }
      };
      Re3 = /* @__PURE__ */ new WeakMap();
      var yi = ms;
      var Nr3 = new yi(` 
\r	`), ys = (e2) => e2 === "" || e2 === x2 || e2 === F || e2 === E2;
      function Dc2(e2, t2, r2) {
        var _3, J3, j2;
        let { node: n2 } = e2;
        if (n2.type === "JSXElement" && Pc(n2))
          return [r2("openingElement"), r2("closingElement")];
        let s2 = n2.type === "JSXElement" ? r2("openingElement") : r2("openingFragment"), u2 = n2.type === "JSXElement" ? r2("closingElement") : r2("closingFragment");
        if (n2.children.length === 1 && n2.children[0].type === "JSXExpressionContainer" && (n2.children[0].expression.type === "TemplateLiteral" || n2.children[0].expression.type === "TaggedTemplateExpression"))
          return [s2, ...e2.map(r2, "children"), u2];
        n2.children = n2.children.map((h2) => kc2(h2) ? { type: "JSXText", value: " ", raw: " " } : h2);
        let i2 = n2.children.some(X3), a2 = n2.children.filter((h2) => h2.type === "JSXExpressionContainer").length > 1, o2 = n2.type === "JSXElement" && n2.openingElement.attributes.length > 1, c2 = ne3(s2) || i2 || o2 || a2, m = e2.parent.rootMarker === "mdx", D = t2.singleQuote ? "{' '}" : '{" "}', y3 = m ? " " : b3([D, E2], " "), C = ((J3 = (_3 = n2.openingElement) == null ? void 0 : _3.name) == null ? void 0 : J3.name) === "fbt", p2 = fc2(e2, t2, r2, y3, C), A = n2.children.some((h2) => pr3(h2));
        for (let h2 = p2.length - 2; h2 >= 0; h2--) {
          let W2 = p2[h2] === "" && p2[h2 + 1] === "", Fe3 = p2[h2] === F && p2[h2 + 1] === "" && p2[h2 + 2] === F, H3 = (p2[h2] === E2 || p2[h2] === F) && p2[h2 + 1] === "" && p2[h2 + 2] === y3, ue2 = p2[h2] === y3 && p2[h2 + 1] === "" && (p2[h2 + 2] === E2 || p2[h2 + 2] === F), Z3 = p2[h2] === y3 && p2[h2 + 1] === "" && p2[h2 + 2] === y3, It2 = p2[h2] === E2 && p2[h2 + 1] === "" && p2[h2 + 2] === F || p2[h2] === F && p2[h2 + 1] === "" && p2[h2 + 2] === E2;
          Fe3 && A || W2 || H3 || Z3 || It2 ? p2.splice(h2, 2) : ue2 && p2.splice(h2 + 1, 2);
        }
        for (; p2.length > 0 && ys(O2(false, p2, -1)); )
          p2.pop();
        for (; p2.length > 1 && ys(p2[0]) && ys(p2[1]); )
          p2.shift(), p2.shift();
        let T3 = [];
        for (let [h2, W2] of p2.entries()) {
          if (W2 === y3) {
            if (h2 === 1 && p2[h2 - 1] === "") {
              if (p2.length === 2) {
                T3.push(D);
                continue;
              }
              T3.push([D, F]);
              continue;
            } else if (h2 === p2.length - 1) {
              T3.push(D);
              continue;
            } else if (p2[h2 - 1] === "" && p2[h2 - 2] === F) {
              T3.push(D);
              continue;
            }
          }
          T3.push(W2), ne3(W2) && (c2 = true);
        }
        let S3 = A ? qt2(T3) : l2(T3, { shouldBreak: true });
        if (((j2 = t2.cursorNode) == null ? void 0 : j2.type) === "JSXText" && n2.children.includes(t2.cursorNode) && (S3 = [Nn2, S3, Nn2]), m)
          return S3;
        let B2 = l2([s2, f2([F, S3]), F, u2]);
        return c2 ? B2 : ze2([l2([s2, ...p2, u2]), B2]);
      }
      function fc2(e2, t2, r2, n2, s2) {
        let u2 = [];
        return e2.each(({ node: i2, next: a2 }) => {
          if (i2.type === "JSXText") {
            let o2 = fe2(i2);
            if (pr3(i2)) {
              let c2 = Nr3.split(o2, true);
              c2[0] === "" && (u2.push(""), c2.shift(), /\n/u.test(c2[0]) ? u2.push(fi2(s2, c2[1], i2, a2)) : u2.push(n2), c2.shift());
              let m;
              if (O2(false, c2, -1) === "" && (c2.pop(), m = c2.pop()), c2.length === 0)
                return;
              for (let [D, y3] of c2.entries())
                D % 2 === 1 ? u2.push(x2) : u2.push(y3);
              m !== void 0 ? /\n/u.test(m) ? u2.push(fi2(s2, O2(false, u2, -1), i2, a2)) : u2.push(n2) : u2.push(Di2(s2, O2(false, u2, -1), i2, a2));
            } else
              /\n/u.test(o2) ? o2.match(/\n/gu).length > 1 && u2.push("", F) : u2.push("", n2);
          } else {
            let o2 = r2();
            if (u2.push(o2), a2 && pr3(a2)) {
              let m = Nr3.trim(fe2(a2)), [D] = Nr3.split(m);
              u2.push(Di2(s2, D, i2, a2));
            } else
              u2.push(F);
          }
        }, "children"), u2;
      }
      function Di2(e2, t2, r2, n2) {
        return e2 ? "" : r2.type === "JSXElement" && !r2.closingElement || (n2 == null ? void 0 : n2.type) === "JSXElement" && !n2.closingElement ? t2.length === 1 ? E2 : F : E2;
      }
      function fi2(e2, t2, r2, n2) {
        return e2 ? F : t2.length === 1 ? r2.type === "JSXElement" && !r2.closingElement || (n2 == null ? void 0 : n2.type) === "JSXElement" && !n2.closingElement ? F : E2 : F;
      }
      var Ec = /* @__PURE__ */ new Set(["ArrayExpression", "TupleExpression", "JSXAttribute", "JSXElement", "JSXExpressionContainer", "JSXFragment", "ExpressionStatement", "CallExpression", "OptionalCallExpression", "ConditionalExpression", "JsExpressionRoot"]);
      function Fc(e2, t2, r2) {
        let { parent: n2 } = e2;
        if (Ec.has(n2.type))
          return t2;
        let s2 = e2.match(void 0, (i2) => i2.type === "ArrowFunctionExpression", L3, (i2) => i2.type === "JSXExpressionContainer"), u2 = Be3(e2, r2);
        return l2([u2 ? "" : b3("("), f2([E2, t2]), E2, u2 ? "" : b3(")")], { shouldBreak: s2 });
      }
      function Cc(e2, t2, r2) {
        let { node: n2 } = e2, s2 = [];
        if (s2.push(r2("name")), n2.value) {
          let u2;
          if (Q3(n2.value)) {
            let i2 = fe2(n2.value), a2 = N2(false, N2(false, i2.slice(1, -1), "&apos;", "'"), "&quot;", '"'), o2 = xr3(a2, t2.jsxSingleQuote);
            a2 = o2 === '"' ? N2(false, a2, '"', "&quot;") : N2(false, a2, "'", "&apos;"), u2 = e2.call(() => ye(e2, Ie3(o2 + a2 + o2), t2), "value");
          } else
            u2 = r2("value");
          s2.push("=", u2);
        }
        return s2;
      }
      function Ac(e2, t2, r2) {
        let { node: n2 } = e2, s2 = (u2, i2) => u2.type === "JSXEmptyExpression" || !d2(u2) && (U2(u2) || se2(u2) || u2.type === "ArrowFunctionExpression" || u2.type === "AwaitExpression" && (s2(u2.argument, u2) || u2.argument.type === "JSXElement") || L3(u2) || u2.type === "ChainExpression" && L3(u2.expression) || u2.type === "FunctionExpression" || u2.type === "TemplateLiteral" || u2.type === "TaggedTemplateExpression" || u2.type === "DoExpression" || X3(i2) && (u2.type === "ConditionalExpression" || De3(u2)));
        return s2(n2.expression, e2.parent) ? l2(["{", r2("expression"), ke3, "}"]) : l2(["{", f2([E2, r2("expression")]), E2, ke3, "}"]);
      }
      function Tc(e2, t2, r2) {
        var a2, o2;
        let { node: n2 } = e2, s2 = d2(n2.name) || d2(n2.typeParameters) || d2(n2.typeArguments);
        if (n2.selfClosing && n2.attributes.length === 0 && !s2)
          return ["<", r2("name"), n2.typeArguments ? r2("typeArguments") : r2("typeParameters"), " />"];
        if (((a2 = n2.attributes) == null ? void 0 : a2.length) === 1 && Q3(n2.attributes[0].value) && !n2.attributes[0].value.value.includes(`
`) && !s2 && !d2(n2.attributes[0]))
          return l2(["<", r2("name"), n2.typeArguments ? r2("typeArguments") : r2("typeParameters"), " ", ...e2.map(r2, "attributes"), n2.selfClosing ? " />" : ">"]);
        let u2 = (o2 = n2.attributes) == null ? void 0 : o2.some((c2) => Q3(c2.value) && c2.value.value.includes(`
`)), i2 = t2.singleAttributePerLine && n2.attributes.length > 1 ? F : x2;
        return l2(["<", r2("name"), n2.typeArguments ? r2("typeArguments") : r2("typeParameters"), f2(e2.map(() => [i2, r2()], "attributes")), ...dc2(n2, t2, s2)], { shouldBreak: u2 });
      }
      function dc2(e2, t2, r2) {
        return e2.selfClosing ? [x2, "/>"] : xc(e2, t2, r2) ? [">"] : [E2, ">"];
      }
      function xc(e2, t2, r2) {
        let n2 = e2.attributes.length > 0 && d2(O2(false, e2.attributes, -1), g2.Trailing);
        return e2.attributes.length === 0 && !r2 || (t2.bracketSameLine || t2.jsxBracketSameLine) && (!r2 || e2.attributes.length > 0) && !n2;
      }
      function hc2(e2, t2, r2) {
        let { node: n2 } = e2, s2 = [];
        s2.push("</");
        let u2 = r2("name");
        return d2(n2.name, g2.Leading | g2.Line) ? s2.push(f2([F, u2]), F) : d2(n2.name, g2.Leading | g2.Block) ? s2.push(" ", u2) : s2.push(u2), s2.push(">"), s2;
      }
      function gc2(e2, t2) {
        let { node: r2 } = e2, n2 = d2(r2), s2 = d2(r2, g2.Line), u2 = r2.type === "JSXOpeningFragment";
        return [u2 ? "<" : "</", f2([s2 ? F : n2 && !u2 ? " " : "", M3(e2, t2)]), s2 ? F : "", ">"];
      }
      function Sc2(e2, t2, r2) {
        let n2 = ye(e2, Dc2(e2, t2, r2), t2);
        return Fc(e2, n2, t2);
      }
      function Bc(e2, t2) {
        let { node: r2 } = e2, n2 = d2(r2, g2.Line);
        return [M3(e2, t2, { indent: n2 }), n2 ? F : ""];
      }
      function bc2(e2, t2, r2) {
        let { node: n2 } = e2;
        return ["{", e2.call(({ node: s2 }) => {
          let u2 = ["...", r2()];
          return !d2(s2) || !Qn3(e2) ? u2 : [f2([E2, ye(e2, u2, t2)]), E2];
        }, n2.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
      }
      function Ei(e2, t2, r2) {
        let { node: n2 } = e2;
        if (n2.type.startsWith("JSX"))
          switch (n2.type) {
            case "JSXAttribute":
              return Cc(e2, t2, r2);
            case "JSXIdentifier":
              return n2.name;
            case "JSXNamespacedName":
              return P2(":", [r2("namespace"), r2("name")]);
            case "JSXMemberExpression":
              return P2(".", [r2("object"), r2("property")]);
            case "JSXSpreadAttribute":
            case "JSXSpreadChild":
              return bc2(e2, t2, r2);
            case "JSXExpressionContainer":
              return Ac(e2, t2, r2);
            case "JSXFragment":
            case "JSXElement":
              return Sc2(e2, t2, r2);
            case "JSXOpeningElement":
              return Tc(e2, t2, r2);
            case "JSXClosingElement":
              return hc2(e2, t2, r2);
            case "JSXOpeningFragment":
            case "JSXClosingFragment":
              return gc2(e2, t2);
            case "JSXEmptyExpression":
              return Bc(e2, t2);
            case "JSXText":
              throw new Error("JSXText should be handled by JSXElement");
            default:
              throw new Me3(n2, "JSX");
          }
      }
      function Pc(e2) {
        if (e2.children.length === 0)
          return true;
        if (e2.children.length > 1)
          return false;
        let t2 = e2.children[0];
        return t2.type === "JSXText" && !pr3(t2);
      }
      function pr3(e2) {
        return e2.type === "JSXText" && (Nr3.hasNonWhitespaceCharacter(fe2(e2)) || !/\n/u.test(fe2(e2)));
      }
      function kc2(e2) {
        return e2.type === "JSXExpressionContainer" && Q3(e2.expression) && e2.expression.value === " " && !d2(e2.expression);
      }
      function Fi(e2) {
        let { node: t2, parent: r2 } = e2;
        if (!X3(t2) || !X3(r2))
          return false;
        let { index: n2, siblings: s2 } = e2, u2;
        for (let i2 = n2; i2 > 0; i2--) {
          let a2 = s2[i2 - 1];
          if (!(a2.type === "JSXText" && !pr3(a2))) {
            u2 = a2;
            break;
          }
        }
        return (u2 == null ? void 0 : u2.type) === "JSXExpressionContainer" && u2.expression.type === "JSXEmptyExpression" && Bt2(u2.expression);
      }
      function Ic(e2) {
        return Bt2(e2.node) || Fi(e2);
      }
      var Xr2 = Ic;
      var Lc = 0;
      function Yr3(e2, t2, r2) {
        var J3;
        let { node: n2, parent: s2, grandparent: u2, key: i2 } = e2, a2 = i2 !== "body" && (s2.type === "IfStatement" || s2.type === "WhileStatement" || s2.type === "SwitchStatement" || s2.type === "DoWhileStatement"), o2 = n2.operator === "|>" && ((J3 = e2.root.extra) == null ? void 0 : J3.__isUsingHackPipeline), c2 = Ds2(e2, r2, t2, false, a2);
        if (a2)
          return c2;
        if (o2)
          return l2(c2);
        if (L3(s2) && s2.callee === n2 || s2.type === "UnaryExpression" || q2(s2) && !s2.computed)
          return l2([f2([E2, ...c2]), E2]);
        let m = s2.type === "ReturnStatement" || s2.type === "ThrowStatement" || s2.type === "JSXExpressionContainer" && u2.type === "JSXAttribute" || n2.operator !== "|" && s2.type === "JsExpressionRoot" || n2.type !== "NGPipeExpression" && (s2.type === "NGRoot" && t2.parser === "__ng_binding" || s2.type === "NGMicrosyntaxExpression" && u2.type === "NGMicrosyntax" && u2.body.length === 1) || n2 === s2.body && s2.type === "ArrowFunctionExpression" || n2 !== s2.body && s2.type === "ForStatement" || s2.type === "ConditionalExpression" && u2.type !== "ReturnStatement" && u2.type !== "ThrowStatement" && !L3(u2) || s2.type === "TemplateLiteral", D = s2.type === "AssignmentExpression" || s2.type === "VariableDeclarator" || s2.type === "ClassProperty" || s2.type === "PropertyDefinition" || s2.type === "TSAbstractPropertyDefinition" || s2.type === "ClassPrivateProperty" || Ae3(s2), y3 = De3(n2.left) && nr2(n2.operator, n2.left.operator);
        if (m || Ut2(n2) && !y3 || !Ut2(n2) && D)
          return l2(c2);
        if (c2.length === 0)
          return "";
        let C = X3(n2.right), p2 = c2.findIndex((j2) => typeof j2 != "string" && !Array.isArray(j2) && j2.type === le2), A = c2.slice(0, p2 === -1 ? 1 : p2 + 1), T3 = c2.slice(A.length, C ? -1 : void 0), S3 = Symbol("logicalChain-" + ++Lc), B2 = l2([...A, f2(T3)], { id: S3 });
        if (!C)
          return B2;
        let _3 = O2(false, c2, -1);
        return l2([B2, At3(_3, { groupId: S3 })]);
      }
      function Ds2(e2, t2, r2, n2, s2) {
        var A;
        let { node: u2 } = e2;
        if (!De3(u2))
          return [l2(t2())];
        let i2 = [];
        nr2(u2.operator, u2.left.operator) ? i2 = e2.call((T3) => Ds2(T3, t2, r2, true, s2), "left") : i2.push(l2(t2("left")));
        let a2 = Ut2(u2), o2 = (u2.operator === "|>" || u2.type === "NGPipeExpression" || wc2(e2, r2)) && !Oe3(r2.originalText, u2.right), c2 = u2.type === "NGPipeExpression" ? "|" : u2.operator, m = u2.type === "NGPipeExpression" && u2.arguments.length > 0 ? l2(f2([E2, ": ", P2([x2, ": "], e2.map(() => he3(2, l2(t2())), "arguments"))])) : "", D;
        if (a2)
          D = [c2, " ", t2("right"), m];
        else {
          let S3 = c2 === "|>" && ((A = e2.root.extra) == null ? void 0 : A.__isUsingHackPipeline) ? e2.call((B2) => Ds2(B2, t2, r2, true, s2), "right") : t2("right");
          D = [o2 ? x2 : "", c2, o2 ? " " : x2, S3, m];
        }
        let { parent: y3 } = e2, C = d2(u2.left, g2.Trailing | g2.Line), p2 = C || !(s2 && u2.type === "LogicalExpression") && y3.type !== u2.type && u2.left.type !== u2.type && u2.right.type !== u2.type;
        if (i2.push(o2 ? "" : " ", p2 ? l2(D, { shouldBreak: C }) : D), n2 && d2(u2)) {
          let T3 = Wt2(ye(e2, i2, r2));
          return T3.type === Pe3 ? T3.parts : Array.isArray(T3) ? T3 : [T3];
        }
        return i2;
      }
      function Ut2(e2) {
        return e2.type !== "LogicalExpression" ? false : !!(se2(e2.right) && e2.right.properties.length > 0 || U2(e2.right) && e2.right.elements.length > 0 || X3(e2.right));
      }
      var Ci = (e2) => e2.type === "BinaryExpression" && e2.operator === "|";
      function wc2(e2, t2) {
        return (t2.parser === "__vue_expression" || t2.parser === "__vue_ts_expression") && Ci(e2.node) && !e2.hasAncestor((r2) => !Ci(r2) && r2.type !== "JsExpressionRoot");
      }
      function Ti2(e2, t2, r2) {
        let { node: n2 } = e2;
        if (n2.type.startsWith("NG"))
          switch (n2.type) {
            case "NGRoot":
              return [r2("node"), d2(n2.node) ? " //" + ct3(n2.node)[0].value.trimEnd() : ""];
            case "NGPipeExpression":
              return Yr3(e2, t2, r2);
            case "NGChainedExpression":
              return l2(P2([";", x2], e2.map(() => _c(e2) ? r2() : ["(", r2(), ")"], "expressions")));
            case "NGEmptyExpression":
              return "";
            case "NGMicrosyntax":
              return e2.map(() => [e2.isFirst ? "" : Ai2(e2) ? " " : [";", x2], r2()], "body");
            case "NGMicrosyntaxKey":
              return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/iu.test(n2.name) ? n2.name : JSON.stringify(n2.name);
            case "NGMicrosyntaxExpression":
              return [r2("expression"), n2.alias === null ? "" : [" as ", r2("alias")]];
            case "NGMicrosyntaxKeyedExpression": {
              let { index: s2, parent: u2 } = e2, i2 = Ai2(e2) || (s2 === 1 && (n2.key.name === "then" || n2.key.name === "else" || n2.key.name === "as") || (s2 === 2 || s2 === 3) && (n2.key.name === "else" && u2.body[s2 - 1].type === "NGMicrosyntaxKeyedExpression" && u2.body[s2 - 1].key.name === "then" || n2.key.name === "track")) && u2.body[0].type === "NGMicrosyntaxExpression";
              return [r2("key"), i2 ? " " : ": ", r2("expression")];
            }
            case "NGMicrosyntaxLet":
              return ["let ", r2("key"), n2.value === null ? "" : [" = ", r2("value")]];
            case "NGMicrosyntaxAs":
              return [r2("key"), " as ", r2("alias")];
            default:
              throw new Me3(n2, "Angular");
          }
      }
      function Ai2({ node: e2, index: t2 }) {
        return e2.type === "NGMicrosyntaxKeyedExpression" && e2.key.name === "of" && t2 === 1;
      }
      var Oc2 = v2(["CallExpression", "OptionalCallExpression", "AssignmentExpression"]);
      function _c({ node: e2 }) {
        return tr2(e2, Oc2);
      }
      function fs(e2, t2, r2) {
        let { node: n2 } = e2;
        return l2([P2(x2, e2.map(r2, "decorators")), hi3(n2, t2) ? F : x2]);
      }
      function di2(e2, t2, r2) {
        return gi(e2.node) ? [P2(F, e2.map(r2, "declaration", "decorators")), F] : "";
      }
      function xi(e2, t2, r2) {
        let { node: n2, parent: s2 } = e2, { decorators: u2 } = n2;
        if (!w2(u2) || gi(s2) || Xr2(e2))
          return "";
        let i2 = n2.type === "ClassExpression" || n2.type === "ClassDeclaration" || hi3(n2, t2);
        return [e2.key === "declaration" && iu2(s2) ? F : i2 ? Ee2 : "", P2(x2, e2.map(r2, "decorators")), x2];
      }
      function hi3(e2, t2) {
        return e2.decorators.some((r2) => te2(t2.originalText, k(r2)));
      }
      function gi(e2) {
        var r2;
        if (e2.type !== "ExportDefaultDeclaration" && e2.type !== "ExportNamedDeclaration" && e2.type !== "DeclareExportDeclaration")
          return false;
        let t2 = (r2 = e2.declaration) == null ? void 0 : r2.decorators;
        return w2(t2) && ht3(e2, t2[0]);
      }
      var Dt2 = class extends Error {
        constructor() {
          super(...arguments);
          __publicField(this, "name", "ArgExpansionBailout");
        }
      };
      function jc2(e2, t2, r2) {
        let { node: n2 } = e2, s2 = oe3(n2);
        if (s2.length === 0)
          return ["(", M3(e2, t2), ")"];
        let u2 = s2.length - 1;
        if (Rc(s2)) {
          let y3 = ["("];
          return Rt2(e2, (C, p2) => {
            y3.push(r2()), p2 !== u2 && y3.push(", ");
          }), y3.push(")"), y3;
        }
        let i2 = false, a2 = [];
        Rt2(e2, ({ node: y3 }, C) => {
          let p2 = r2();
          C === u2 || (pe2(y3, t2) ? (i2 = true, p2 = [p2, ",", F, F]) : p2 = [p2, ",", x2]), a2.push(p2);
        });
        let o2 = n2.type === "ImportExpression" || n2.callee.type === "Import", c2 = !t2.parser.startsWith("__ng_") && !o2 && ae2(t2, "all") ? "," : "";
        function m() {
          return l2(["(", f2([x2, ...a2]), c2, x2, ")"], { shouldBreak: true });
        }
        if (i2 || e2.parent.type !== "Decorator" && lu3(s2))
          return m();
        if (Mc(s2)) {
          let y3 = a2.slice(1);
          if (y3.some(ne3))
            return m();
          let C;
          try {
            C = r2(Jn2(n2, 0), { expandFirstArg: true });
          } catch (p2) {
            if (p2 instanceof Dt2)
              return m();
            throw p2;
          }
          return ne3(C) ? [Ee2, ze2([["(", l2(C, { shouldBreak: true }), ", ", ...y3, ")"], m()])] : ze2([["(", C, ", ", ...y3, ")"], ["(", l2(C, { shouldBreak: true }), ", ", ...y3, ")"], m()]);
        }
        if (vc2(s2, a2, t2)) {
          let y3 = a2.slice(0, -1);
          if (y3.some(ne3))
            return m();
          let C;
          try {
            C = r2(Jn2(n2, -1), { expandLastArg: true });
          } catch (p2) {
            if (p2 instanceof Dt2)
              return m();
            throw p2;
          }
          return ne3(C) ? [Ee2, ze2([["(", ...y3, l2(C, { shouldBreak: true }), ")"], m()])] : ze2([["(", ...y3, C, ")"], ["(", ...y3, l2(C, { shouldBreak: true }), ")"], m()]);
        }
        let D = ["(", f2([E2, ...a2]), b3(c2), E2, ")"];
        return Or2(e2) ? D : l2(D, { shouldBreak: a2.some(ne3) || i2 });
      }
      function cr3(e2, t2 = false) {
        return se2(e2) && (e2.properties.length > 0 || d2(e2)) || U2(e2) && (e2.elements.length > 0 || d2(e2)) || e2.type === "TSTypeAssertion" && cr3(e2.expression) || Te2(e2) && cr3(e2.expression) || e2.type === "FunctionExpression" || e2.type === "ArrowFunctionExpression" && (!e2.returnType || !e2.returnType.typeAnnotation || e2.returnType.typeAnnotation.type !== "TSTypeReference" || Jc(e2.body)) && (e2.body.type === "BlockStatement" || e2.body.type === "ArrowFunctionExpression" && cr3(e2.body, true) || se2(e2.body) || U2(e2.body) || !t2 && (L3(e2.body) || e2.body.type === "ConditionalExpression") || X3(e2.body)) || e2.type === "DoExpression" || e2.type === "ModuleExpression";
      }
      function vc2(e2, t2, r2) {
        var u2, i2;
        let n2 = O2(false, e2, -1);
        if (e2.length === 1) {
          let a2 = O2(false, t2, -1);
          if ((u2 = a2.label) != null && u2.embed && ((i2 = a2.label) == null ? void 0 : i2.hug) !== false)
            return true;
        }
        let s2 = O2(false, e2, -2);
        return !d2(n2, g2.Leading) && !d2(n2, g2.Trailing) && cr3(n2) && (!s2 || s2.type !== n2.type) && (e2.length !== 2 || s2.type !== "ArrowFunctionExpression" || !U2(n2)) && !(e2.length > 1 && Es2(n2, r2));
      }
      function Mc(e2) {
        if (e2.length !== 2)
          return false;
        let [t2, r2] = e2;
        return t2.type === "ModuleExpression" && qc(r2) ? true : !d2(t2) && (t2.type === "FunctionExpression" || t2.type === "ArrowFunctionExpression" && t2.body.type === "BlockStatement") && r2.type !== "FunctionExpression" && r2.type !== "ArrowFunctionExpression" && r2.type !== "ConditionalExpression" && Bi2(r2) && !cr3(r2);
      }
      function Bi2(e2) {
        if (e2.type === "ParenthesizedExpression")
          return Bi2(e2.expression);
        if (Te2(e2) || e2.type === "TypeCastExpression") {
          let { typeAnnotation: t2 } = e2;
          if (t2.type === "TypeAnnotation" && (t2 = t2.typeAnnotation), t2.type === "TSArrayType" && (t2 = t2.elementType, t2.type === "TSArrayType" && (t2 = t2.elementType)), t2.type === "GenericTypeAnnotation" || t2.type === "TSTypeReference") {
            let r2 = t2.typeArguments ?? t2.typeParameters;
            (r2 == null ? void 0 : r2.params.length) === 1 && (t2 = r2.params[0]);
          }
          return Mt2(t2) && be3(e2.expression, 1);
        }
        return lt3(e2) && oe3(e2).length > 1 ? false : De3(e2) ? be3(e2.left, 1) && be3(e2.right, 1) : Mn2(e2) || be3(e2);
      }
      function Rc(e2) {
        return e2.length === 2 ? Si2(e2, 0) : e2.length === 3 ? e2[0].type === "Identifier" && Si2(e2, 1) : false;
      }
      function Si2(e2, t2) {
        let r2 = e2[t2], n2 = e2[t2 + 1];
        return r2.type === "ArrowFunctionExpression" && K2(r2).length === 0 && r2.body.type === "BlockStatement" && n2.type === "ArrayExpression" && !e2.some((s2) => d2(s2));
      }
      function Jc(e2) {
        return e2.type === "BlockStatement" && (e2.body.some((t2) => t2.type !== "EmptyStatement") || d2(e2, g2.Dangling));
      }
      function qc(e2) {
        return e2.type === "ObjectExpression" && e2.properties.length === 1 && Ae3(e2.properties[0]) && e2.properties[0].key.type === "Identifier" && e2.properties[0].key.name === "type" && Q3(e2.properties[0].value) && e2.properties[0].value.value === "module";
      }
      var lr3 = jc2;
      var Wc2 = (e2) => ((e2.type === "ChainExpression" || e2.type === "TSNonNullExpression") && (e2 = e2.expression), L3(e2) && oe3(e2).length > 0);
      function bi(e2, t2, r2) {
        var c2;
        let n2 = r2("object"), s2 = Fs2(e2, t2, r2), { node: u2 } = e2, i2 = e2.findAncestor((m) => !(q2(m) || m.type === "TSNonNullExpression")), a2 = e2.findAncestor((m) => !(m.type === "ChainExpression" || m.type === "TSNonNullExpression")), o2 = i2 && (i2.type === "NewExpression" || i2.type === "BindExpression" || i2.type === "AssignmentExpression" && i2.left.type !== "Identifier") || u2.computed || u2.object.type === "Identifier" && u2.property.type === "Identifier" && !q2(a2) || (a2.type === "AssignmentExpression" || a2.type === "VariableDeclarator") && (Wc2(u2.object) || ((c2 = n2.label) == null ? void 0 : c2.memberChain));
        return it3(n2.label, [n2, o2 ? s2 : l2(f2([E2, s2]))]);
      }
      function Fs2(e2, t2, r2) {
        let n2 = r2("property"), { node: s2 } = e2, u2 = V2(e2);
        return s2.computed ? !s2.property || Ce3(s2.property) ? [u2, "[", n2, "]"] : l2([u2, "[", f2([E2, n2]), E2, "]"]) : [u2, ".", n2];
      }
      function Pi(e2, t2, r2) {
        if (e2.node.type === "ChainExpression")
          return e2.call(() => Pi(e2, t2, r2), "expression");
        let { parent: n2 } = e2, s2 = !n2 || n2.type === "ExpressionStatement", u2 = [];
        function i2(I2) {
          let { originalText: G3 } = t2, ee3 = yt2(G3, k(I2));
          return G3.charAt(ee3) === ")" ? ee3 !== false && Ot2(G3, ee3 + 1) : pe2(I2, t2);
        }
        function a2(I2) {
          let { node: G3 } = I2;
          if (G3.type === "ChainExpression")
            return I2.call(() => a2(I2), "expression");
          if (L3(G3) && (Ft3(G3.callee) || L3(G3.callee))) {
            let ee3 = i2(G3);
            u2.unshift({ node: G3, hasTrailingEmptyLine: ee3, printed: [ye(I2, [V2(I2), Qe3(I2, t2, r2), lr3(I2, t2, r2)], t2), ee3 ? F : ""] }), I2.call((qe2) => a2(qe2), "callee");
          } else
            Ft3(G3) ? (u2.unshift({ node: G3, needsParens: Be3(I2, t2), printed: ye(I2, q2(G3) ? Fs2(I2, t2, r2) : Hr3(I2, t2, r2), t2) }), I2.call((ee3) => a2(ee3), "object")) : G3.type === "TSNonNullExpression" ? (u2.unshift({ node: G3, printed: ye(I2, "!", t2) }), I2.call((ee3) => a2(ee3), "expression")) : u2.unshift({ node: G3, printed: r2() });
        }
        let { node: o2 } = e2;
        u2.unshift({ node: o2, printed: [V2(e2), Qe3(e2, t2, r2), lr3(e2, t2, r2)] }), o2.callee && e2.call((I2) => a2(I2), "callee");
        let c2 = [], m = [u2[0]], D = 1;
        for (; D < u2.length && (u2[D].node.type === "TSNonNullExpression" || L3(u2[D].node) || q2(u2[D].node) && u2[D].node.computed && Ce3(u2[D].node.property)); ++D)
          m.push(u2[D]);
        if (!L3(u2[0].node))
          for (; D + 1 < u2.length && (Ft3(u2[D].node) && Ft3(u2[D + 1].node)); ++D)
            m.push(u2[D]);
        c2.push(m), m = [];
        let y3 = false;
        for (; D < u2.length; ++D) {
          if (y3 && Ft3(u2[D].node)) {
            if (u2[D].node.computed && Ce3(u2[D].node.property)) {
              m.push(u2[D]);
              continue;
            }
            c2.push(m), m = [], y3 = false;
          }
          (L3(u2[D].node) || u2[D].node.type === "ImportExpression") && (y3 = true), m.push(u2[D]), d2(u2[D].node, g2.Trailing) && (c2.push(m), m = [], y3 = false);
        }
        m.length > 0 && c2.push(m);
        function C(I2) {
          return /^[A-Z]|^[$_]+$/u.test(I2);
        }
        function p2(I2) {
          return I2.length <= t2.tabWidth;
        }
        function A(I2) {
          var qe2;
          let G3 = (qe2 = I2[1][0]) == null ? void 0 : qe2.node.computed;
          if (I2[0].length === 1) {
            let xt3 = I2[0][0].node;
            return xt3.type === "ThisExpression" || xt3.type === "Identifier" && (C(xt3.name) || s2 && p2(xt3.name) || G3);
          }
          let ee3 = O2(false, I2[0], -1).node;
          return q2(ee3) && ee3.property.type === "Identifier" && (C(ee3.property.name) || G3);
        }
        let T3 = c2.length >= 2 && !d2(c2[1][0].node) && A(c2);
        function S3(I2) {
          let G3 = I2.map((ee3) => ee3.printed);
          return I2.length > 0 && O2(false, I2, -1).needsParens ? ["(", ...G3, ")"] : G3;
        }
        function B2(I2) {
          return I2.length === 0 ? "" : f2([F, P2(F, I2.map(S3))]);
        }
        let _3 = c2.map(S3), J3 = _3, j2 = T3 ? 3 : 2, h2 = c2.flat(), W2 = h2.slice(1, -1).some((I2) => d2(I2.node, g2.Leading)) || h2.slice(0, -1).some((I2) => d2(I2.node, g2.Trailing)) || c2[j2] && d2(c2[j2][0].node, g2.Leading);
        if (c2.length <= j2 && !W2 && !c2.some((I2) => O2(false, I2, -1).hasTrailingEmptyLine))
          return Or2(e2) ? J3 : l2(J3);
        let Fe3 = O2(false, c2[T3 ? 1 : 0], -1).node, H3 = !L3(Fe3) && i2(Fe3), ue2 = [S3(c2[0]), T3 ? c2.slice(1, 2).map(S3) : "", H3 ? F : "", B2(c2.slice(T3 ? 2 : 1))], Z3 = u2.map(({ node: I2 }) => I2).filter(L3);
        function It2() {
          let I2 = O2(false, O2(false, c2, -1), -1).node, G3 = O2(false, _3, -1);
          return L3(I2) && ne3(G3) && Z3.slice(0, -1).some((ee3) => ee3.arguments.some(_t2));
        }
        let $t2;
        return W2 || Z3.length > 2 && Z3.some((I2) => !I2.arguments.every((G3) => be3(G3))) || _3.slice(0, -1).some(ne3) || It2() ? $t2 = l2(ue2) : $t2 = [ne3(J3) || H3 ? Ee2 : "", ze2([J3, ue2])], it3({ memberChain: true }, $t2);
      }
      var ki = Pi;
      function Vr2(e2, t2, r2) {
        var m;
        let { node: n2 } = e2, s2 = n2.type === "NewExpression", u2 = n2.type === "ImportExpression", i2 = V2(e2), a2 = oe3(n2), o2 = a2.length === 1 && Lr3(a2[0], t2.originalText);
        if (o2 || Gc2(e2) || St3(n2, e2.parent)) {
          let D = [];
          if (Rt2(e2, () => {
            D.push(r2());
          }), !(o2 && ((m = D[0].label) != null && m.embed)))
            return [s2 ? "new " : "", Ii2(e2, r2), i2, Qe3(e2, t2, r2), "(", P2(", ", D), ")"];
        }
        if (!u2 && !s2 && Ft3(n2.callee) && !e2.call((D) => Be3(D, t2), "callee", ...n2.callee.type === "ChainExpression" ? ["expression"] : []))
          return ki(e2, t2, r2);
        let c2 = [s2 ? "new " : "", Ii2(e2, r2), i2, Qe3(e2, t2, r2), lr3(e2, t2, r2)];
        return u2 || L3(n2.callee) ? l2(c2) : c2;
      }
      function Ii2(e2, t2) {
        let { node: r2 } = e2;
        return r2.type === "ImportExpression" ? `import${r2.phase ? `.${r2.phase}` : ""}` : t2("callee");
      }
      function Gc2(e2) {
        let { node: t2 } = e2;
        if (t2.type !== "CallExpression" || t2.optional || t2.callee.type !== "Identifier")
          return false;
        let r2 = oe3(t2);
        return t2.callee.name === "require" ? r2.length === 1 && Q3(r2[0]) || r2.length > 1 : t2.callee.name === "define" && e2.parent.type === "ExpressionStatement" ? r2.length === 1 || r2.length === 2 && r2[0].type === "ArrayExpression" || r2.length === 3 && Q3(r2[0]) && r2[1].type === "ArrayExpression" : false;
      }
      function Tt2(e2, t2, r2, n2, s2, u2) {
        let i2 = Uc(e2, t2, r2, n2, u2), a2 = u2 ? r2(u2, { assignmentLayout: i2 }) : "";
        switch (i2) {
          case "break-after-operator":
            return l2([l2(n2), s2, l2(f2([x2, a2]))]);
          case "never-break-after-operator":
            return l2([l2(n2), s2, " ", a2]);
          case "fluid": {
            let o2 = Symbol("assignment");
            return l2([l2(n2), s2, l2(f2(x2), { id: o2 }), ke3, At3(a2, { groupId: o2 })]);
          }
          case "break-lhs":
            return l2([n2, s2, " ", l2(a2)]);
          case "chain":
            return [l2(n2), s2, x2, a2];
          case "chain-tail":
            return [l2(n2), s2, f2([x2, a2])];
          case "chain-tail-arrow-chain":
            return [l2(n2), s2, a2];
          case "only-left":
            return n2;
        }
      }
      function wi(e2, t2, r2) {
        let { node: n2 } = e2;
        return Tt2(e2, t2, r2, r2("left"), [" ", n2.operator], "right");
      }
      function Oi2(e2, t2, r2) {
        return Tt2(e2, t2, r2, r2("id"), " =", "init");
      }
      function Uc(e2, t2, r2, n2, s2) {
        let { node: u2 } = e2, i2 = u2[s2];
        if (!i2)
          return "only-left";
        let a2 = !$r3(i2);
        if (e2.match($r3, _i, (y3) => !a2 || y3.type !== "ExpressionStatement" && y3.type !== "VariableDeclaration"))
          return a2 ? i2.type === "ArrowFunctionExpression" && i2.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
        if (!a2 && $r3(i2.right) || Oe3(t2.originalText, i2))
          return "break-after-operator";
        if (u2.type === "ImportAttribute" || i2.type === "CallExpression" && i2.callee.name === "require" || t2.parser === "json5" || t2.parser === "jsonc" || t2.parser === "json")
          return "never-break-after-operator";
        let m = Bu3(n2);
        if (Xc(u2) || $c2(u2) || Cs2(u2) && m)
          return "break-lhs";
        let D = zc(u2, n2, t2);
        return e2.call(() => Nc(e2, t2, r2, D), s2) ? "break-after-operator" : Yc(u2) ? "break-lhs" : !m && (D || i2.type === "TemplateLiteral" || i2.type === "TaggedTemplateExpression" || i2.type === "BooleanLiteral" || Ce3(i2) || i2.type === "ClassExpression") ? "never-break-after-operator" : "fluid";
      }
      function Nc(e2, t2, r2, n2) {
        let s2 = e2.node;
        if (De3(s2) && !Ut2(s2))
          return true;
        switch (s2.type) {
          case "StringLiteralTypeAnnotation":
          case "SequenceExpression":
            return true;
          case "TSConditionalType":
          case "ConditionalTypeAnnotation":
            if (!t2.experimentalTernaries && !el2(s2))
              break;
            return true;
          case "ConditionalExpression": {
            if (!t2.experimentalTernaries) {
              let { test: c2 } = s2;
              return De3(c2) && !Ut2(c2);
            }
            let { consequent: a2, alternate: o2 } = s2;
            return a2.type === "ConditionalExpression" || o2.type === "ConditionalExpression";
          }
          case "ClassExpression":
            return w2(s2.decorators);
        }
        if (n2)
          return false;
        let u2 = s2, i2 = [];
        for (; ; )
          if (u2.type === "UnaryExpression" || u2.type === "AwaitExpression" || u2.type === "YieldExpression" && u2.argument !== null)
            u2 = u2.argument, i2.push("argument");
          else if (u2.type === "TSNonNullExpression")
            u2 = u2.expression, i2.push("expression");
          else
            break;
        return !!(Q3(u2) || e2.call(() => ji(e2, t2, r2), ...i2));
      }
      function Xc(e2) {
        if (_i(e2)) {
          let t2 = e2.left || e2.id;
          return t2.type === "ObjectPattern" && t2.properties.length > 2 && t2.properties.some((r2) => {
            var n2;
            return Ae3(r2) && (!r2.shorthand || ((n2 = r2.value) == null ? void 0 : n2.type) === "AssignmentPattern");
          });
        }
        return false;
      }
      function $r3(e2) {
        return e2.type === "AssignmentExpression";
      }
      function _i(e2) {
        return $r3(e2) || e2.type === "VariableDeclarator";
      }
      function Yc(e2) {
        let t2 = Vc(e2);
        if (w2(t2)) {
          let r2 = e2.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
          if (t2.length > 1 && t2.some((n2) => n2[r2] || n2.default))
            return true;
        }
        return false;
      }
      var Hc2 = v2(["TSTypeAliasDeclaration", "TypeAlias"]);
      function Vc(e2) {
        var t2;
        if (Hc2(e2))
          return (t2 = e2.typeParameters) == null ? void 0 : t2.params;
      }
      function $c2(e2) {
        if (e2.type !== "VariableDeclarator")
          return false;
        let { typeAnnotation: t2 } = e2.id;
        if (!t2 || !t2.typeAnnotation)
          return false;
        let r2 = Li2(t2.typeAnnotation);
        return w2(r2) && r2.length > 1 && r2.some((n2) => w2(Li2(n2)) || n2.type === "TSConditionalType");
      }
      function Cs2(e2) {
        var t2;
        return e2.type === "VariableDeclarator" && ((t2 = e2.init) == null ? void 0 : t2.type) === "ArrowFunctionExpression";
      }
      var Kc = v2(["TSTypeReference", "GenericTypeAnnotation"]);
      function Li2(e2) {
        var t2;
        if (Kc(e2))
          return (t2 = e2.typeArguments ?? e2.typeParameters) == null ? void 0 : t2.params;
      }
      function ji(e2, t2, r2, n2 = false) {
        var i2;
        let { node: s2 } = e2, u2 = () => ji(e2, t2, r2, true);
        if (s2.type === "ChainExpression" || s2.type === "TSNonNullExpression")
          return e2.call(u2, "expression");
        if (L3(s2)) {
          if ((i2 = Vr2(e2, t2, r2).label) != null && i2.memberChain)
            return false;
          let o2 = oe3(s2);
          return !(o2.length === 0 || o2.length === 1 && rr2(o2[0], t2)) || Qc(s2, r2) ? false : e2.call(u2, "callee");
        }
        return q2(s2) ? e2.call(u2, "object") : n2 && (s2.type === "Identifier" || s2.type === "ThisExpression");
      }
      function zc(e2, t2, r2) {
        return Ae3(e2) ? (t2 = Wt2(t2), typeof t2 == "string" && et2(t2) < r2.tabWidth + 3) : false;
      }
      function Qc(e2, t2) {
        let r2 = Zc(e2);
        if (w2(r2)) {
          if (r2.length > 1)
            return true;
          if (r2.length === 1) {
            let s2 = r2[0];
            if (Ne2(s2) || _r3(s2) || s2.type === "TSTypeLiteral" || s2.type === "ObjectTypeAnnotation")
              return true;
          }
          let n2 = e2.typeParameters ? "typeParameters" : "typeArguments";
          if (ne3(t2(n2)))
            return true;
        }
        return false;
      }
      function Zc(e2) {
        var t2;
        return (t2 = e2.typeParameters ?? e2.typeArguments) == null ? void 0 : t2.params;
      }
      function el2(e2) {
        function t2(r2) {
          switch (r2.type) {
            case "FunctionTypeAnnotation":
            case "GenericTypeAnnotation":
            case "TSFunctionType":
              return !!r2.typeParameters;
            case "TSTypeReference":
              return !!(r2.typeArguments ?? r2.typeParameters);
            default:
              return false;
          }
        }
        return t2(e2.checkType) || t2(e2.extendsType);
      }
      function Je2(e2, t2, r2, n2, s2) {
        let u2 = e2.node, i2 = K2(u2), a2 = s2 ? Qe3(e2, r2, t2) : "";
        if (i2.length === 0)
          return [a2, "(", M3(e2, r2, { filter: (p2) => ge2(r2.originalText, k(p2)) === ")" }), ")"];
        let { parent: o2 } = e2, c2 = St3(o2), m = As2(u2), D = [];
        if (fu2(e2, (p2, A) => {
          let T3 = A === i2.length - 1;
          T3 && u2.rest && D.push("..."), D.push(t2()), !T3 && (D.push(","), c2 || m ? D.push(" ") : pe2(i2[A], r2) ? D.push(F, F) : D.push(x2));
        }), n2 && !rl2(e2)) {
          if (ne3(a2) || ne3(D))
            throw new Dt2();
          return l2([ur3(a2), "(", ur3(D), ")"]);
        }
        let y3 = i2.every((p2) => !w2(p2.decorators));
        return m && y3 ? [a2, "(", ...D, ")"] : c2 ? [a2, "(", ...D, ")"] : (Ir2(o2) || ou3(o2) || o2.type === "TypeAlias" || o2.type === "UnionTypeAnnotation" || o2.type === "IntersectionTypeAnnotation" || o2.type === "FunctionTypeAnnotation" && o2.returnType === u2) && i2.length === 1 && i2[0].name === null && u2.this !== i2[0] && i2[0].typeAnnotation && u2.typeParameters === null && Mt2(i2[0].typeAnnotation) && !u2.rest ? r2.arrowParens === "always" || u2.type === "HookTypeAnnotation" ? ["(", ...D, ")"] : D : [a2, "(", f2([E2, ...D]), b3(!Du2(u2) && ae2(r2, "all") ? "," : ""), E2, ")"];
      }
      function As2(e2) {
        if (!e2)
          return false;
        let t2 = K2(e2);
        if (t2.length !== 1)
          return false;
        let [r2] = t2;
        return !d2(r2) && (r2.type === "ObjectPattern" || r2.type === "ArrayPattern" || r2.type === "Identifier" && r2.typeAnnotation && (r2.typeAnnotation.type === "TypeAnnotation" || r2.typeAnnotation.type === "TSTypeAnnotation") && we3(r2.typeAnnotation.typeAnnotation) || r2.type === "FunctionTypeParam" && we3(r2.typeAnnotation) && r2 !== e2.rest || r2.type === "AssignmentPattern" && (r2.left.type === "ObjectPattern" || r2.left.type === "ArrayPattern") && (r2.right.type === "Identifier" || se2(r2.right) && r2.right.properties.length === 0 || U2(r2.right) && r2.right.elements.length === 0));
      }
      function tl(e2) {
        let t2;
        return e2.returnType ? (t2 = e2.returnType, t2.typeAnnotation && (t2 = t2.typeAnnotation)) : e2.typeAnnotation && (t2 = e2.typeAnnotation), t2;
      }
      function ot3(e2, t2) {
        var s2;
        let r2 = tl(e2);
        if (!r2)
          return false;
        let n2 = (s2 = e2.typeParameters) == null ? void 0 : s2.params;
        if (n2) {
          if (n2.length > 1)
            return false;
          if (n2.length === 1) {
            let u2 = n2[0];
            if (u2.constraint || u2.default)
              return false;
          }
        }
        return K2(e2).length === 1 && (we3(r2) || ne3(t2));
      }
      function rl2(e2) {
        return e2.match((t2) => t2.type === "ArrowFunctionExpression" && t2.body.type === "BlockStatement", (t2, r2) => {
          if (t2.type === "CallExpression" && r2 === "arguments" && t2.arguments.length === 1 && t2.callee.type === "CallExpression") {
            let n2 = t2.callee.callee;
            return n2.type === "Identifier" || n2.type === "MemberExpression" && !n2.computed && n2.object.type === "Identifier" && n2.property.type === "Identifier";
          }
          return false;
        }, (t2, r2) => t2.type === "VariableDeclarator" && r2 === "init" || t2.type === "ExportDefaultDeclaration" && r2 === "declaration" || t2.type === "TSExportAssignment" && r2 === "expression" || t2.type === "AssignmentExpression" && r2 === "right" && t2.left.type === "MemberExpression" && t2.left.object.type === "Identifier" && t2.left.object.name === "module" && t2.left.property.type === "Identifier" && t2.left.property.name === "exports", (t2) => t2.type !== "VariableDeclaration" || t2.kind === "const" && t2.declarations.length === 1);
      }
      function vi2(e2) {
        let t2 = K2(e2);
        return t2.length > 1 && t2.some((r2) => r2.type === "TSParameterProperty");
      }
      var nl = v2(["VoidTypeAnnotation", "TSVoidKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword"]), sl = v2(["ObjectTypeAnnotation", "TSTypeLiteral", "GenericTypeAnnotation", "TSTypeReference"]);
      function ul(e2) {
        let { types: t2 } = e2;
        if (t2.some((n2) => d2(n2)))
          return false;
        let r2 = t2.find((n2) => sl(n2));
        return r2 ? t2.every((n2) => n2 === r2 || nl(n2)) : false;
      }
      function Ts2(e2) {
        return Mt2(e2) || we3(e2) ? true : Ne2(e2) ? ul(e2) : false;
      }
      function Mi2(e2, t2, r2) {
        let n2 = t2.semi ? ";" : "", { node: s2 } = e2, u2 = [$2(e2), "opaque type ", r2("id"), r2("typeParameters")];
        return s2.supertype && u2.push(": ", r2("supertype")), s2.impltype && u2.push(" = ", r2("impltype")), u2.push(n2), u2;
      }
      function Kr2(e2, t2, r2) {
        let n2 = t2.semi ? ";" : "", { node: s2 } = e2, u2 = [$2(e2)];
        u2.push("type ", r2("id"), r2("typeParameters"));
        let i2 = s2.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
        return [Tt2(e2, t2, r2, u2, " =", i2), n2];
      }
      function zr2(e2, t2, r2) {
        let n2 = false;
        return l2(e2.map(({ isFirst: s2, previous: u2, node: i2, index: a2 }) => {
          let o2 = r2();
          if (s2)
            return o2;
          let c2 = we3(i2), m = we3(u2);
          return m && c2 ? [" & ", n2 ? f2(o2) : o2] : !m && !c2 ? f2([" &", x2, o2]) : (a2 > 1 && (n2 = true), [" & ", a2 > 1 ? f2(o2) : o2]);
        }, "types"));
      }
      function Qr2(e2, t2, r2) {
        let { node: n2 } = e2, { parent: s2 } = e2, u2 = s2.type !== "TypeParameterInstantiation" && (s2.type !== "TSConditionalType" || !t2.experimentalTernaries) && (s2.type !== "ConditionalTypeAnnotation" || !t2.experimentalTernaries) && s2.type !== "TSTypeParameterInstantiation" && s2.type !== "GenericTypeAnnotation" && s2.type !== "TSTypeReference" && s2.type !== "TSTypeAssertion" && s2.type !== "TupleTypeAnnotation" && s2.type !== "TSTupleType" && !(s2.type === "FunctionTypeParam" && !s2.name && e2.grandparent.this !== s2) && !((s2.type === "TypeAlias" || s2.type === "VariableDeclarator" || s2.type === "TSTypeAliasDeclaration") && Oe3(t2.originalText, n2)), i2 = Ts2(n2), a2 = e2.map((m) => {
          let D = r2();
          return i2 || (D = he3(2, D)), ye(m, D, t2);
        }, "types");
        if (i2)
          return P2(" | ", a2);
        let o2 = u2 && !Oe3(t2.originalText, n2), c2 = [b3([o2 ? x2 : "", "| "]), P2([x2, "| "], a2)];
        return Be3(e2, t2) ? l2([f2(c2), E2]) : (s2.type === "TupleTypeAnnotation" || s2.type === "TSTupleType") && s2[s2.type === "TupleTypeAnnotation" && s2.types ? "types" : "elementTypes"].length > 1 ? l2([f2([b3(["(", E2]), c2]), E2, b3(")")]) : l2(u2 ? f2(c2) : c2);
      }
      function il(e2) {
        var n2;
        let { node: t2, parent: r2 } = e2;
        return t2.type === "FunctionTypeAnnotation" && (Ir2(r2) || !((r2.type === "ObjectTypeProperty" || r2.type === "ObjectTypeInternalSlot") && !r2.variance && !r2.optional && ht3(r2, t2) || r2.type === "ObjectTypeCallProperty" || ((n2 = e2.getParentNode(2)) == null ? void 0 : n2.type) === "DeclareFunction"));
      }
      function Zr2(e2, t2, r2) {
        let { node: n2 } = e2, s2 = [Nt2(e2)];
        (n2.type === "TSConstructorType" || n2.type === "TSConstructSignatureDeclaration") && s2.push("new ");
        let u2 = Je2(e2, r2, t2, false, true), i2 = [];
        return n2.type === "FunctionTypeAnnotation" ? i2.push(il(e2) ? " => " : ": ", r2("returnType")) : i2.push(Y2(e2, r2, n2.returnType ? "returnType" : "typeAnnotation")), ot3(n2, i2) && (u2 = l2(u2)), s2.push(u2, i2), l2(s2);
      }
      function en3(e2, t2, r2) {
        return [r2("objectType"), V2(e2), "[", r2("indexType"), "]"];
      }
      function tn3(e2, t2, r2) {
        return ["infer ", r2("typeParameter")];
      }
      function ds(e2, t2, r2) {
        let { node: n2 } = e2;
        return [n2.postfix ? "" : r2, Y2(e2, t2), n2.postfix ? r2 : ""];
      }
      function rn3(e2, t2, r2) {
        let { node: n2 } = e2;
        return ["...", ...n2.type === "TupleTypeSpreadElement" && n2.label ? [r2("label"), ": "] : [], r2("typeAnnotation")];
      }
      function nn3(e2, t2, r2) {
        let { node: n2 } = e2;
        return [n2.variance ? r2("variance") : "", r2("label"), n2.optional ? "?" : "", ": ", r2("elementType")];
      }
      var al = /* @__PURE__ */ new WeakSet();
      function Y2(e2, t2, r2 = "typeAnnotation") {
        let { node: { [r2]: n2 } } = e2;
        if (!n2)
          return "";
        let s2 = false;
        if (n2.type === "TSTypeAnnotation" || n2.type === "TypeAnnotation") {
          let u2 = e2.call(Ri, r2);
          (u2 === "=>" || u2 === ":" && d2(n2, g2.Leading)) && (s2 = true), al.add(n2);
        }
        return s2 ? [" ", t2(r2)] : t2(r2);
      }
      var Ri = (e2) => e2.match((t2) => t2.type === "TSTypeAnnotation", (t2, r2) => (r2 === "returnType" || r2 === "typeAnnotation") && (t2.type === "TSFunctionType" || t2.type === "TSConstructorType")) ? "=>" : e2.match((t2) => t2.type === "TSTypeAnnotation", (t2, r2) => r2 === "typeAnnotation" && (t2.type === "TSJSDocNullableType" || t2.type === "TSJSDocNonNullableType" || t2.type === "TSTypePredicate")) || e2.match((t2) => t2.type === "TypeAnnotation", (t2, r2) => r2 === "typeAnnotation" && t2.type === "Identifier", (t2, r2) => r2 === "id" && t2.type === "DeclareFunction") || e2.match((t2) => t2.type === "TypeAnnotation", (t2, r2) => r2 === "typeAnnotation" && t2.type === "Identifier", (t2, r2) => r2 === "id" && t2.type === "DeclareHook") || e2.match((t2) => t2.type === "TypeAnnotation", (t2, r2) => r2 === "bound" && t2.type === "TypeParameter" && t2.usesExtendsBound) ? "" : ":";
      function sn2(e2, t2, r2) {
        let n2 = Ri(e2);
        return n2 ? [n2, " ", r2("typeAnnotation")] : r2("typeAnnotation");
      }
      function un3(e2) {
        return [e2("elementType"), "[]"];
      }
      function an3({ node: e2 }, t2) {
        let r2 = e2.type === "TSTypeQuery" ? "exprName" : "argument", n2 = e2.type === "TypeofTypeAnnotation" || e2.typeArguments ? "typeArguments" : "typeParameters";
        return ["typeof ", t2(r2), t2(n2)];
      }
      function on2(e2, t2) {
        let { node: r2 } = e2;
        return [r2.type === "TSTypePredicate" && r2.asserts ? "asserts " : r2.type === "TypePredicate" && r2.kind ? `${r2.kind} ` : "", t2("parameterName"), r2.typeAnnotation ? [" is ", Y2(e2, t2)] : ""];
      }
      function V2(e2) {
        let { node: t2 } = e2;
        return !t2.optional || t2.type === "Identifier" && t2 === e2.parent.key ? "" : L3(t2) || q2(t2) && t2.computed || t2.type === "OptionalIndexedAccessType" ? "?." : "?";
      }
      function pn3(e2) {
        return e2.node.definite || e2.match(void 0, (t2, r2) => r2 === "id" && t2.type === "VariableDeclarator" && t2.definite) ? "!" : "";
      }
      var ol = /* @__PURE__ */ new Set(["DeclareClass", "DeclareComponent", "DeclareFunction", "DeclareHook", "DeclareVariable", "DeclareExportDeclaration", "DeclareExportAllDeclaration", "DeclareOpaqueType", "DeclareTypeAlias", "DeclareEnum", "DeclareInterface"]);
      function $2(e2) {
        let { node: t2 } = e2;
        return t2.declare || ol.has(t2.type) && e2.parent.type !== "DeclareExportDeclaration" ? "declare " : "";
      }
      var pl2 = /* @__PURE__ */ new Set(["TSAbstractMethodDefinition", "TSAbstractPropertyDefinition", "TSAbstractAccessorProperty"]);
      function Nt2({ node: e2 }) {
        return e2.abstract || pl2.has(e2.type) ? "abstract " : "";
      }
      function Qe3(e2, t2, r2) {
        let n2 = e2.node;
        return n2.typeArguments ? r2("typeArguments") : n2.typeParameters ? r2("typeParameters") : "";
      }
      function Hr3(e2, t2, r2) {
        return ["::", r2("callee")];
      }
      function ft2(e2, t2, r2) {
        return e2.type === "EmptyStatement" ? ";" : e2.type === "BlockStatement" || r2 ? [" ", t2] : f2([x2, t2]);
      }
      function cn3(e2, t2) {
        return ["...", t2("argument"), Y2(e2, t2)];
      }
      function Xt(e2) {
        return e2.accessibility ? e2.accessibility + " " : "";
      }
      function cl(e2, t2, r2, n2) {
        let { node: s2 } = e2, u2 = s2.inexact ? "..." : "";
        return d2(s2, g2.Dangling) ? l2([r2, u2, M3(e2, t2, { indent: true }), E2, n2]) : [r2, u2, n2];
      }
      function Yt2(e2, t2, r2) {
        let { node: n2 } = e2, s2 = [], u2 = n2.type === "TupleExpression" ? "#[" : "[", i2 = "]", a2 = n2.type === "TupleTypeAnnotation" && n2.types ? "types" : n2.type === "TSTupleType" || n2.type === "TupleTypeAnnotation" ? "elementTypes" : "elements", o2 = n2[a2];
        if (o2.length === 0)
          s2.push(cl(e2, t2, u2, i2));
        else {
          let c2 = O2(false, o2, -1), m = (c2 == null ? void 0 : c2.type) !== "RestElement" && !n2.inexact, D = c2 === null, y3 = Symbol("array"), C = !t2.__inJestEach && o2.length > 1 && o2.every((T3, S3, B2) => {
            let _3 = T3 == null ? void 0 : T3.type;
            if (!U2(T3) && !se2(T3))
              return false;
            let J3 = B2[S3 + 1];
            if (J3 && _3 !== J3.type)
              return false;
            let j2 = U2(T3) ? "elements" : "properties";
            return T3[j2] && T3[j2].length > 1;
          }), p2 = Es2(n2, t2), A = m ? D ? "," : ae2(t2) ? p2 ? b3(",", "", { groupId: y3 }) : b3(",") : "" : "";
          s2.push(l2([u2, f2([E2, p2 ? ml(e2, t2, r2, A) : [ll(e2, t2, a2, n2.inexact, r2), A], M3(e2, t2)]), E2, i2], { shouldBreak: C, id: y3 }));
        }
        return s2.push(V2(e2), Y2(e2, r2)), s2;
      }
      function Es2(e2, t2) {
        return U2(e2) && e2.elements.length > 1 && e2.elements.every((r2) => r2 && (Ce3(r2) || vn3(r2) && !d2(r2.argument)) && !d2(r2, g2.Trailing | g2.Line, (n2) => !te2(t2.originalText, R3(n2), { backwards: true })));
      }
      function Ji({ node: e2 }, { originalText: t2 }) {
        let r2 = (s2) => Lt2(t2, wt3(t2, s2)), n2 = (s2) => t2[s2] === "," ? s2 : n2(r2(s2 + 1));
        return Ot2(t2, n2(k(e2)));
      }
      function ll(e2, t2, r2, n2, s2) {
        let u2 = [];
        return e2.each(({ node: i2, isLast: a2 }) => {
          u2.push(i2 ? l2(s2()) : ""), (!a2 || n2) && u2.push([",", x2, i2 && Ji(e2, t2) ? E2 : ""]);
        }, r2), n2 && u2.push("..."), u2;
      }
      function ml(e2, t2, r2, n2) {
        let s2 = [];
        return e2.each(({ isLast: u2, next: i2 }) => {
          s2.push([r2(), u2 ? n2 : ","]), u2 || s2.push(Ji(e2, t2) ? [F, F] : d2(i2, g2.Leading | g2.Line) ? F : x2);
        }, "elements"), qt2(s2);
      }
      var qi2 = new Proxy(() => {
      }, { get: () => qi2 }), ln3 = qi2;
      var yl = /^[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC][\$0-9A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]*$/, Dl = (e2) => yl.test(e2), Wi = Dl;
      function fl(e2) {
        return e2.length === 1 ? e2 : e2.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(?=\d)/u, "$1$2").replace(/^([+-]?[\d.]+)e[+-]?0+$/u, "$1").replace(/^([+-])?\./u, "$10.").replace(/(\.\d+?)0+(?=e|$)/u, "$1").replace(/\.(?=e|$)/u, "");
      }
      var Ze2 = fl;
      var mn3 = /* @__PURE__ */ new WeakMap();
      function Ui(e2) {
        return /^(?:\d+|\d+\.\d+)$/u.test(e2);
      }
      function Gi(e2, t2) {
        return t2.parser === "json" || t2.parser === "jsonc" || !Q3(e2.key) || tt2(fe2(e2.key), t2).slice(1, -1) !== e2.key.value ? false : !!(Wi(e2.key.value) && !(t2.parser === "babel-ts" && e2.type === "ClassProperty" || t2.parser === "typescript" && e2.type === "PropertyDefinition") || Ui(e2.key.value) && String(Number(e2.key.value)) === e2.key.value && e2.type !== "ImportAttribute" && (t2.parser === "babel" || t2.parser === "acorn" || t2.parser === "espree" || t2.parser === "meriyah" || t2.parser === "__babel_estree"));
      }
      function El(e2, t2) {
        let { key: r2 } = e2.node;
        return (r2.type === "Identifier" || Ce3(r2) && Ui(Ze2(fe2(r2))) && String(r2.value) === Ze2(fe2(r2)) && !(t2.parser === "typescript" || t2.parser === "babel-ts")) && (t2.parser === "json" || t2.parser === "jsonc" || t2.quoteProps === "consistent" && mn3.get(e2.parent));
      }
      function Et3(e2, t2, r2) {
        let { node: n2 } = e2;
        if (n2.computed)
          return ["[", r2("key"), "]"];
        let { parent: s2 } = e2, { key: u2 } = n2;
        if (t2.quoteProps === "consistent" && !mn3.has(s2)) {
          let i2 = e2.siblings.some((a2) => !a2.computed && Q3(a2.key) && !Gi(a2, t2));
          mn3.set(s2, i2);
        }
        if (El(e2, t2)) {
          let i2 = tt2(JSON.stringify(u2.type === "Identifier" ? u2.name : u2.value.toString()), t2);
          return e2.call((a2) => ye(a2, i2, t2), "key");
        }
        return Gi(n2, t2) && (t2.quoteProps === "as-needed" || t2.quoteProps === "consistent" && !mn3.get(s2)) ? e2.call((i2) => ye(i2, /^\d/u.test(u2.value) ? Ze2(u2.value) : u2.value, t2), "key") : r2("key");
      }
      function yn3(e2, t2, r2) {
        let { node: n2 } = e2;
        return n2.shorthand ? r2("value") : Tt2(e2, t2, r2, Et3(e2, t2, r2), ":", "value");
      }
      var Fl = ({ node: e2, key: t2, parent: r2 }) => t2 === "value" && e2.type === "FunctionExpression" && (r2.type === "ObjectMethod" || r2.type === "ClassMethod" || r2.type === "ClassPrivateMethod" || r2.type === "MethodDefinition" || r2.type === "TSAbstractMethodDefinition" || r2.type === "TSDeclareMethod" || r2.type === "Property" && gt2(r2));
      function Dn2(e2, t2, r2, n2) {
        if (Fl(e2))
          return fn3(e2, r2, t2);
        let { node: s2 } = e2, u2 = false;
        if ((s2.type === "FunctionDeclaration" || s2.type === "FunctionExpression") && (n2 != null && n2.expandLastArg)) {
          let { parent: m } = e2;
          L3(m) && (oe3(m).length > 1 || K2(s2).every((D) => D.type === "Identifier" && !D.typeAnnotation)) && (u2 = true);
        }
        let i2 = [$2(e2), s2.async ? "async " : "", `function${s2.generator ? "*" : ""} `, s2.id ? t2("id") : ""], a2 = Je2(e2, t2, r2, u2), o2 = Ht2(e2, t2), c2 = ot3(s2, o2);
        return i2.push(Qe3(e2, r2, t2), l2([c2 ? l2(a2) : a2, o2]), s2.body ? " " : "", t2("body")), r2.semi && (s2.declare || !s2.body) && i2.push(";"), i2;
      }
      function mr2(e2, t2, r2) {
        let { node: n2 } = e2, { kind: s2 } = n2, u2 = n2.value || n2, i2 = [];
        return !s2 || s2 === "init" || s2 === "method" || s2 === "constructor" ? u2.async && i2.push("async ") : (ln3.ok(s2 === "get" || s2 === "set"), i2.push(s2, " ")), u2.generator && i2.push("*"), i2.push(Et3(e2, t2, r2), n2.optional || n2.key.optional ? "?" : "", n2 === u2 ? fn3(e2, t2, r2) : r2("value")), i2;
      }
      function fn3(e2, t2, r2) {
        let { node: n2 } = e2, s2 = Je2(e2, r2, t2), u2 = Ht2(e2, r2), i2 = vi2(n2), a2 = ot3(n2, u2), o2 = [Qe3(e2, t2, r2), l2([i2 ? l2(s2, { shouldBreak: true }) : a2 ? l2(s2) : s2, u2])];
        return n2.body ? o2.push(" ", r2("body")) : o2.push(t2.semi ? ";" : ""), o2;
      }
      function Cl(e2) {
        let t2 = K2(e2);
        return t2.length === 1 && !e2.typeParameters && !d2(e2, g2.Dangling) && t2[0].type === "Identifier" && !t2[0].typeAnnotation && !d2(t2[0]) && !t2[0].optional && !e2.predicate && !e2.returnType;
      }
      function En2(e2, t2) {
        if (t2.arrowParens === "always")
          return false;
        if (t2.arrowParens === "avoid") {
          let { node: r2 } = e2;
          return Cl(r2);
        }
        return false;
      }
      function Ht2(e2, t2) {
        let { node: r2 } = e2, s2 = [Y2(e2, t2, "returnType")];
        return r2.predicate && s2.push(t2("predicate")), s2;
      }
      function Ni(e2, t2, r2) {
        let { node: n2 } = e2, s2 = t2.semi ? ";" : "", u2 = [];
        if (n2.argument) {
          let o2 = r2("argument");
          Al(t2, n2.argument) ? o2 = ["(", f2([F, o2]), F, ")"] : (De3(n2.argument) || n2.argument.type === "SequenceExpression" || t2.experimentalTernaries && n2.argument.type === "ConditionalExpression" && (n2.argument.consequent.type === "ConditionalExpression" || n2.argument.alternate.type === "ConditionalExpression")) && (o2 = l2([b3("("), f2([E2, o2]), E2, b3(")")])), u2.push(" ", o2);
        }
        let i2 = d2(n2, g2.Dangling), a2 = s2 && i2 && d2(n2, g2.Last | g2.Line);
        return a2 && u2.push(s2), i2 && u2.push(" ", M3(e2, t2)), a2 || u2.push(s2), u2;
      }
      function Xi2(e2, t2, r2) {
        return ["return", Ni(e2, t2, r2)];
      }
      function Yi2(e2, t2, r2) {
        return ["throw", Ni(e2, t2, r2)];
      }
      function Al(e2, t2) {
        if (Oe3(e2.originalText, t2) || d2(t2, g2.Leading, (r2) => de2(e2.originalText, R3(r2), k(r2))) && !X3(t2))
          return true;
        if (jt2(t2)) {
          let r2 = t2, n2;
          for (; n2 = uu2(r2); )
            if (r2 = n2, Oe3(e2.originalText, r2))
              return true;
        }
        return false;
      }
      var xs = /* @__PURE__ */ new WeakMap();
      function Hi(e2) {
        return xs.has(e2) || xs.set(e2, e2.type === "ConditionalExpression" && !ie2(e2, (t2) => t2.type === "ObjectExpression")), xs.get(e2);
      }
      var Vi = (e2) => e2.type === "SequenceExpression";
      function $i(e2, t2, r2, n2 = {}) {
        let s2 = [], u2, i2 = [], a2 = false, o2 = !n2.expandLastArg && e2.node.body.type === "ArrowFunctionExpression", c2;
        (function T3() {
          let { node: S3 } = e2, B2 = Tl(e2, t2, r2, n2);
          if (s2.length === 0)
            s2.push(B2);
          else {
            let { leading: _3, trailing: J3 } = ps(e2, t2);
            s2.push([_3, B2]), i2.unshift(J3);
          }
          o2 && (a2 || (a2 = S3.returnType && K2(S3).length > 0 || S3.typeParameters || K2(S3).some((_3) => _3.type !== "Identifier"))), !o2 || S3.body.type !== "ArrowFunctionExpression" ? (u2 = r2("body", n2), c2 = S3.body) : e2.call(T3, "body");
        })();
        let m = !Oe3(t2.originalText, c2) && (Vi(c2) || dl(c2, u2, t2) || !a2 && Hi(c2)), D = e2.key === "callee" && lt3(e2.parent), y3 = Symbol("arrow-chain"), C = xl(e2, n2, { signatureDocs: s2, shouldBreak: a2 }), p2, A = false;
        return o2 && (D || n2.assignmentLayout) && (A = true, p2 = n2.assignmentLayout === "chain-tail-arrow-chain" || D && !m), u2 = hl2(e2, t2, n2, { bodyDoc: u2, bodyComments: i2, functionBody: c2, shouldPutBodyOnSameLine: m }), l2([l2(A ? f2([E2, C]) : C, { shouldBreak: p2, id: y3 }), " =>", o2 ? At3(u2, { groupId: y3 }) : l2(u2), o2 && D ? b3(E2, "", { groupId: y3 }) : ""]);
      }
      function Tl(e2, t2, r2, n2) {
        let { node: s2 } = e2, u2 = [];
        if (s2.async && u2.push("async "), En2(e2, t2))
          u2.push(r2(["params", 0]));
        else {
          let a2 = n2.expandLastArg || n2.expandFirstArg, o2 = Ht2(e2, r2);
          if (a2) {
            if (ne3(o2))
              throw new Dt2();
            o2 = l2(ur3(o2));
          }
          u2.push(l2([Je2(e2, r2, t2, a2, true), o2]));
        }
        let i2 = M3(e2, t2, { filter(a2) {
          let o2 = yt2(t2.originalText, k(a2));
          return o2 !== false && t2.originalText.slice(o2, o2 + 2) === "=>";
        } });
        return i2 && u2.push(" ", i2), u2;
      }
      function dl(e2, t2, r2) {
        var n2, s2;
        return U2(e2) || se2(e2) || e2.type === "ArrowFunctionExpression" || e2.type === "DoExpression" || e2.type === "BlockStatement" || X3(e2) || ((n2 = t2.label) == null ? void 0 : n2.hug) !== false && (((s2 = t2.label) == null ? void 0 : s2.embed) || Lr3(e2, r2.originalText));
      }
      function xl(e2, t2, { signatureDocs: r2, shouldBreak: n2 }) {
        if (r2.length === 1)
          return r2[0];
        let { parent: s2, key: u2 } = e2;
        return u2 !== "callee" && lt3(s2) || De3(s2) ? l2([r2[0], " =>", f2([x2, P2([" =>", x2], r2.slice(1))])], { shouldBreak: n2 }) : u2 === "callee" && lt3(s2) || t2.assignmentLayout ? l2(P2([" =>", x2], r2), { shouldBreak: n2 }) : l2(f2(P2([" =>", x2], r2)), { shouldBreak: n2 });
      }
      function hl2(e2, t2, r2, { bodyDoc: n2, bodyComments: s2, functionBody: u2, shouldPutBodyOnSameLine: i2 }) {
        let { node: a2, parent: o2 } = e2, c2 = r2.expandLastArg && ae2(t2, "all") ? b3(",") : "", m = (r2.expandLastArg || o2.type === "JSXExpressionContainer") && !d2(a2) ? E2 : "";
        return i2 && Hi(u2) ? [" ", l2([b3("", "("), f2([E2, n2]), b3("", ")"), c2, m]), s2] : (Vi(u2) && (n2 = l2(["(", f2([E2, n2]), E2, ")"])), i2 ? [" ", n2, s2] : [f2([x2, n2, s2]), c2, m]);
      }
      var gl2 = (e2, t2, r2) => {
        if (!(e2 && t2 == null)) {
          if (t2.findLast)
            return t2.findLast(r2);
          for (let n2 = t2.length - 1; n2 >= 0; n2--) {
            let s2 = t2[n2];
            if (r2(s2, n2, t2))
              return s2;
          }
        }
      }, Ki2 = gl2;
      function yr3(e2, t2, r2, n2) {
        let { node: s2 } = e2, u2 = [], i2 = Ki2(false, s2[n2], (a2) => a2.type !== "EmptyStatement");
        return e2.each(({ node: a2 }) => {
          a2.type !== "EmptyStatement" && (u2.push(r2()), a2 !== i2 && (u2.push(F), pe2(a2, t2) && u2.push(F)));
        }, n2), u2;
      }
      function Fn2(e2, t2, r2) {
        let n2 = Sl(e2, t2, r2), { node: s2, parent: u2 } = e2;
        if (s2.type === "Program" && (u2 == null ? void 0 : u2.type) !== "ModuleExpression")
          return n2 ? [n2, F] : "";
        let i2 = [];
        if (s2.type === "StaticBlock" && i2.push("static "), i2.push("{"), n2)
          i2.push(f2([F, n2]), F);
        else {
          let a2 = e2.grandparent;
          u2.type === "ArrowFunctionExpression" || u2.type === "FunctionExpression" || u2.type === "FunctionDeclaration" || u2.type === "ComponentDeclaration" || u2.type === "HookDeclaration" || u2.type === "ObjectMethod" || u2.type === "ClassMethod" || u2.type === "ClassPrivateMethod" || u2.type === "ForStatement" || u2.type === "WhileStatement" || u2.type === "DoWhileStatement" || u2.type === "DoExpression" || u2.type === "ModuleExpression" || u2.type === "CatchClause" && !a2.finalizer || u2.type === "TSModuleDeclaration" || s2.type === "StaticBlock" || i2.push(F);
        }
        return i2.push("}"), i2;
      }
      function Sl(e2, t2, r2) {
        let { node: n2 } = e2, s2 = w2(n2.directives), u2 = n2.body.some((o2) => o2.type !== "EmptyStatement"), i2 = d2(n2, g2.Dangling);
        if (!s2 && !u2 && !i2)
          return "";
        let a2 = [];
        return s2 && (a2.push(yr3(e2, t2, r2, "directives")), (u2 || i2) && (a2.push(F), pe2(O2(false, n2.directives, -1), t2) && a2.push(F))), u2 && a2.push(yr3(e2, t2, r2, "body")), i2 && a2.push(M3(e2, t2)), a2;
      }
      function Bl(e2) {
        let t2 = /* @__PURE__ */ new WeakMap();
        return function(r2) {
          return t2.has(r2) || t2.set(r2, Symbol(e2)), t2.get(r2);
        };
      }
      var Cn2 = Bl;
      function bl(e2) {
        switch (e2) {
          case null:
            return "";
          case "PlusOptional":
            return "+?";
          case "MinusOptional":
            return "-?";
          case "Optional":
            return "?";
        }
      }
      function zi(e2, t2, r2) {
        let { node: n2 } = e2;
        return l2([n2.variance ? r2("variance") : "", "[", f2([r2("keyTparam"), " in ", r2("sourceType")]), "]", bl(n2.optional), ": ", r2("propType")]);
      }
      function hs(e2, t2) {
        return e2 === "+" || e2 === "-" ? e2 + t2 : t2;
      }
      function Qi2(e2, t2, r2) {
        let { node: n2 } = e2, s2 = de2(t2.originalText, R3(n2), R3(n2.typeParameter));
        return l2(["{", f2([t2.bracketSpacing ? x2 : E2, l2([r2("typeParameter"), n2.optional ? hs(n2.optional, "?") : "", n2.typeAnnotation ? ": " : "", r2("typeAnnotation")]), t2.semi ? b3(";") : ""]), M3(e2, t2), t2.bracketSpacing ? x2 : E2, "}"], { shouldBreak: s2 });
      }
      var Dr2 = Cn2("typeParameters");
      function Pl(e2, t2, r2) {
        let { node: n2 } = e2;
        return K2(n2).length === 1 && n2.type.startsWith("TS") && !n2[r2][0].constraint && e2.parent.type === "ArrowFunctionExpression" && !(t2.filepath && /\.ts$/u.test(t2.filepath));
      }
      function Pt2(e2, t2, r2, n2) {
        let { node: s2 } = e2;
        if (!s2[n2])
          return "";
        if (!Array.isArray(s2[n2]))
          return r2(n2);
        let u2 = St3(e2.grandparent), i2 = e2.match((c2) => !(c2[n2].length === 1 && we3(c2[n2][0])), void 0, (c2, m) => m === "typeAnnotation", (c2) => c2.type === "Identifier", Cs2);
        if (s2[n2].length === 0 || !i2 && (u2 || s2[n2].length === 1 && (s2[n2][0].type === "NullableTypeAnnotation" || Ts2(s2[n2][0]))))
          return ["<", P2(", ", e2.map(r2, n2)), kl(e2, t2), ">"];
        let o2 = s2.type === "TSTypeParameterInstantiation" ? "" : Pl(e2, t2, n2) ? "," : ae2(t2) ? b3(",") : "";
        return l2(["<", f2([E2, P2([",", x2], e2.map(r2, n2))]), o2, E2, ">"], { id: Dr2(s2) });
      }
      function kl(e2, t2) {
        let { node: r2 } = e2;
        if (!d2(r2, g2.Dangling))
          return "";
        let n2 = !d2(r2, g2.Line), s2 = M3(e2, t2, { indent: !n2 });
        return n2 ? s2 : [s2, F];
      }
      function An2(e2, t2, r2) {
        let { node: n2, parent: s2 } = e2, u2 = [n2.type === "TSTypeParameter" && n2.const ? "const " : ""], i2 = n2.type === "TSTypeParameter" ? r2("name") : n2.name;
        if (s2.type === "TSMappedType")
          return s2.readonly && u2.push(hs(s2.readonly, "readonly"), " "), u2.push("[", i2), n2.constraint && u2.push(" in ", r2("constraint")), s2.nameType && u2.push(" as ", e2.callParent(() => r2("nameType"))), u2.push("]"), u2;
        if (n2.variance && u2.push(r2("variance")), n2.in && u2.push("in "), n2.out && u2.push("out "), u2.push(i2), n2.bound && (n2.usesExtendsBound && u2.push(" extends "), u2.push(Y2(e2, r2, "bound"))), n2.constraint) {
          let a2 = Symbol("constraint");
          u2.push(" extends", l2(f2(x2), { id: a2 }), ke3, At3(r2("constraint"), { groupId: a2 }));
        }
        return n2.default && u2.push(" = ", r2("default")), l2(u2);
      }
      var Zi = v2(["ClassProperty", "PropertyDefinition", "ClassPrivateProperty", "ClassAccessorProperty", "AccessorProperty", "TSAbstractPropertyDefinition", "TSAbstractAccessorProperty"]);
      function Tn3(e2, t2, r2) {
        let { node: n2 } = e2, s2 = [$2(e2), Nt2(e2), "class"], u2 = d2(n2.id, g2.Trailing) || d2(n2.typeParameters, g2.Trailing) || d2(n2.superClass) || w2(n2.extends) || w2(n2.mixins) || w2(n2.implements), i2 = [], a2 = [];
        if (n2.id && i2.push(" ", r2("id")), i2.push(r2("typeParameters")), n2.superClass) {
          let o2 = [Ll(e2, t2, r2), r2(n2.superTypeArguments ? "superTypeArguments" : "superTypeParameters")], c2 = e2.call((m) => ["extends ", ye(m, o2, t2)], "superClass");
          u2 ? a2.push(x2, l2(c2)) : a2.push(" ", c2);
        } else
          a2.push(gs(e2, t2, r2, "extends"));
        if (a2.push(gs(e2, t2, r2, "mixins"), gs(e2, t2, r2, "implements")), u2) {
          let o2;
          ta(n2) ? o2 = [...i2, f2(a2)] : o2 = f2([...i2, a2]), s2.push(l2(o2, { id: ea(n2) }));
        } else
          s2.push(...i2, ...a2);
        return s2.push(" ", r2("body")), s2;
      }
      var ea = Cn2("heritageGroup");
      function Ss2(e2) {
        return b3(F, "", { groupId: ea(e2) });
      }
      function Il(e2) {
        return ["extends", "mixins", "implements"].reduce((t2, r2) => t2 + (Array.isArray(e2[r2]) ? e2[r2].length : 0), e2.superClass ? 1 : 0) > 1;
      }
      function ta(e2) {
        return e2.typeParameters && !d2(e2.typeParameters, g2.Trailing | g2.Line) && !Il(e2);
      }
      function gs(e2, t2, r2, n2) {
        let { node: s2 } = e2;
        if (!w2(s2[n2]))
          return "";
        let u2 = M3(e2, t2, { marker: n2 });
        return [ta(s2) ? b3(" ", x2, { groupId: Dr2(s2.typeParameters) }) : x2, u2, u2 && F, n2, l2(f2([x2, P2([",", x2], e2.map(r2, n2))]))];
      }
      function Ll(e2, t2, r2) {
        let n2 = r2("superClass"), { parent: s2 } = e2;
        return s2.type === "AssignmentExpression" ? l2(b3(["(", f2([E2, n2]), E2, ")"], n2)) : n2;
      }
      function dn3(e2, t2, r2) {
        let { node: n2 } = e2, s2 = [];
        return w2(n2.decorators) && s2.push(fs(e2, t2, r2)), s2.push(Xt(n2)), n2.static && s2.push("static "), s2.push(Nt2(e2)), n2.override && s2.push("override "), s2.push(mr2(e2, t2, r2)), s2;
      }
      function xn3(e2, t2, r2) {
        let { node: n2 } = e2, s2 = [], u2 = t2.semi ? ";" : "";
        w2(n2.decorators) && s2.push(fs(e2, t2, r2)), s2.push(Xt(n2), $2(e2)), n2.static && s2.push("static "), s2.push(Nt2(e2)), n2.override && s2.push("override "), n2.readonly && s2.push("readonly "), n2.variance && s2.push(r2("variance")), (n2.type === "ClassAccessorProperty" || n2.type === "AccessorProperty" || n2.type === "TSAbstractAccessorProperty") && s2.push("accessor "), s2.push(Et3(e2, t2, r2), V2(e2), pn3(e2), Y2(e2, r2));
        let i2 = n2.type === "TSAbstractPropertyDefinition" || n2.type === "TSAbstractAccessorProperty";
        return [Tt2(e2, t2, r2, s2, " =", i2 ? void 0 : "value"), u2];
      }
      function ra(e2, t2, r2) {
        let { node: n2 } = e2, s2 = [];
        return e2.each(({ node: u2, next: i2, isLast: a2 }) => {
          s2.push(r2()), !t2.semi && Zi(u2) && wl(u2, i2) && s2.push(";"), a2 || (s2.push(F), pe2(u2, t2) && s2.push(F));
        }, "body"), d2(n2, g2.Dangling) && s2.push(M3(e2, t2)), [w2(n2.body) ? Ss2(e2.parent) : "", "{", s2.length > 0 ? [f2([F, s2]), F] : "", "}"];
      }
      function wl(e2, t2) {
        var s2;
        let { type: r2, name: n2 } = e2.key;
        if (!e2.computed && r2 === "Identifier" && (n2 === "static" || n2 === "get" || n2 === "set") && !e2.value && !e2.typeAnnotation)
          return true;
        if (!t2 || t2.static || t2.accessibility || t2.readonly)
          return false;
        if (!t2.computed) {
          let u2 = (s2 = t2.key) == null ? void 0 : s2.name;
          if (u2 === "in" || u2 === "instanceof")
            return true;
        }
        if (Zi(t2) && t2.variance && !t2.static && !t2.declare)
          return true;
        switch (t2.type) {
          case "ClassProperty":
          case "PropertyDefinition":
          case "TSAbstractPropertyDefinition":
            return t2.computed;
          case "MethodDefinition":
          case "TSAbstractMethodDefinition":
          case "ClassMethod":
          case "ClassPrivateMethod": {
            if ((t2.value ? t2.value.async : t2.async) || t2.kind === "get" || t2.kind === "set")
              return false;
            let i2 = t2.value ? t2.value.generator : t2.generator;
            return !!(t2.computed || i2);
          }
          case "TSIndexSignature":
            return true;
        }
        return false;
      }
      function na(e2, t2) {
        if (t2.semi || Bs2(e2, t2) || Ps2(e2, t2))
          return false;
        let { node: r2, key: n2, parent: s2 } = e2;
        return !!(r2.type === "ExpressionStatement" && (n2 === "body" && (s2.type === "Program" || s2.type === "BlockStatement" || s2.type === "StaticBlock" || s2.type === "TSModuleBlock") || n2 === "consequent" && s2.type === "SwitchCase") && e2.call(() => sa2(e2, t2), "expression"));
      }
      function sa2(e2, t2) {
        let { node: r2 } = e2;
        switch (r2.type) {
          case "ParenthesizedExpression":
          case "TypeCastExpression":
          case "ArrayExpression":
          case "ArrayPattern":
          case "TemplateLiteral":
          case "TemplateElement":
          case "RegExpLiteral":
            return true;
          case "ArrowFunctionExpression":
            if (!En2(e2, t2))
              return true;
            break;
          case "UnaryExpression": {
            let { prefix: n2, operator: s2 } = r2;
            if (n2 && (s2 === "+" || s2 === "-"))
              return true;
            break;
          }
          case "BindExpression":
            if (!r2.object)
              return true;
            break;
          case "Literal":
            if (r2.regex)
              return true;
            break;
          default:
            if (X3(r2))
              return true;
        }
        return Be3(e2, t2) ? true : jt2(r2) ? e2.call(() => sa2(e2, t2), ...Pr2(r2)) : false;
      }
      function Bs2({ node: e2, parent: t2 }, r2) {
        return (r2.parentParser === "markdown" || r2.parentParser === "mdx") && e2.type === "ExpressionStatement" && X3(e2.expression) && t2.type === "Program" && t2.body.length === 1;
      }
      function bs2(e2) {
        switch (e2.type) {
          case "MemberExpression":
            switch (e2.property.type) {
              case "Identifier":
              case "NumericLiteral":
              case "StringLiteral":
                return bs2(e2.object);
            }
            return false;
          case "Identifier":
            return true;
          default:
            return false;
        }
      }
      function Ps2({ node: e2, parent: t2 }, r2) {
        return (r2.parser === "__vue_event_binding" || r2.parser === "__vue_ts_event_binding") && e2.type === "ExpressionStatement" && t2.type === "Program" && t2.body.length === 1;
      }
      function ua2(e2, t2, r2) {
        let n2 = [r2("expression")];
        return Ps2(e2, t2) ? bs2(e2.node.expression) && n2.push(";") : Bs2(e2, t2) || t2.semi && n2.push(";"), n2;
      }
      function ia(e2, t2, r2) {
        if (t2.__isVueBindings || t2.__isVueForBindingLeft) {
          let n2 = e2.map(r2, "program", "body", 0, "params");
          if (n2.length === 1)
            return n2[0];
          let s2 = P2([",", x2], n2);
          return t2.__isVueForBindingLeft ? ["(", f2([E2, l2(s2)]), E2, ")"] : s2;
        }
        if (t2.__isEmbeddedTypescriptGenericParameters) {
          let n2 = e2.map(r2, "program", "body", 0, "typeParameters", "params");
          return P2([",", x2], n2);
        }
      }
      function pa2(e2, t2) {
        let { node: r2 } = e2;
        switch (r2.type) {
          case "RegExpLiteral":
            return aa2(r2);
          case "BigIntLiteral":
            return hn3(r2.extra.raw);
          case "NumericLiteral":
            return Ze2(r2.extra.raw);
          case "StringLiteral":
            return Ie3(tt2(r2.extra.raw, t2));
          case "NullLiteral":
            return "null";
          case "BooleanLiteral":
            return String(r2.value);
          case "DecimalLiteral":
            return Ze2(r2.value) + "m";
          case "DirectiveLiteral":
            return oa2(r2.extra.raw, t2);
          case "Literal": {
            if (r2.regex)
              return aa2(r2.regex);
            if (r2.bigint)
              return hn3(r2.raw);
            if (r2.decimal)
              return Ze2(r2.decimal) + "m";
            let { value: n2 } = r2;
            return typeof n2 == "number" ? Ze2(r2.raw) : typeof n2 == "string" ? Ol(e2) ? oa2(r2.raw, t2) : Ie3(tt2(r2.raw, t2)) : String(n2);
          }
        }
      }
      function Ol(e2) {
        if (e2.key !== "expression")
          return;
        let { parent: t2 } = e2;
        return t2.type === "ExpressionStatement" && t2.directive;
      }
      function hn3(e2) {
        return e2.toLowerCase();
      }
      function aa2({ pattern: e2, flags: t2 }) {
        return t2 = [...t2].sort().join(""), `/${e2}/${t2}`;
      }
      function oa2(e2, t2) {
        let r2 = e2.slice(1, -1);
        if (r2.includes('"') || r2.includes("'"))
          return e2;
        let n2 = t2.singleQuote ? "'" : '"';
        return n2 + r2 + n2;
      }
      function _l(e2, t2, r2) {
        let n2 = e2.originalText.slice(t2, r2);
        for (let s2 of e2[Symbol.for("comments")]) {
          let u2 = R3(s2);
          if (u2 > r2)
            break;
          let i2 = k(s2);
          if (i2 < t2)
            continue;
          let a2 = i2 - u2;
          n2 = n2.slice(0, u2 - t2) + " ".repeat(a2) + n2.slice(i2 - t2);
        }
        return n2;
      }
      var fr3 = _l;
      function ca2(e2, t2, r2) {
        let { node: n2 } = e2;
        return ["import", n2.module ? " module" : "", n2.phase ? ` ${n2.phase}` : "", Is2(n2), ya(e2, t2, r2), ma2(e2, t2, r2), fa2(e2, t2, r2), t2.semi ? ";" : ""];
      }
      var la2 = (e2) => e2.type === "ExportDefaultDeclaration" || e2.type === "DeclareExportDeclaration" && e2.default;
      function gn3(e2, t2, r2) {
        let { node: n2 } = e2, s2 = [di2(e2, t2, r2), $2(e2), "export", la2(n2) ? " default" : ""], { declaration: u2, exported: i2 } = n2;
        return d2(n2, g2.Dangling) && (s2.push(" ", M3(e2, t2)), wr2(n2) && s2.push(F)), u2 ? s2.push(" ", r2("declaration")) : (s2.push(Ml(n2)), n2.type === "ExportAllDeclaration" || n2.type === "DeclareExportAllDeclaration" ? (s2.push(" *"), i2 && s2.push(" as ", r2("exported"))) : s2.push(ya(e2, t2, r2)), s2.push(ma2(e2, t2, r2), fa2(e2, t2, r2))), s2.push(vl(n2, t2)), s2;
      }
      var jl = v2(["ClassDeclaration", "ComponentDeclaration", "FunctionDeclaration", "TSInterfaceDeclaration", "DeclareClass", "DeclareComponent", "DeclareFunction", "DeclareHook", "HookDeclaration", "TSDeclareFunction", "EnumDeclaration"]);
      function vl(e2, t2) {
        return t2.semi && (!e2.declaration || la2(e2) && !jl(e2.declaration)) ? ";" : "";
      }
      function ks2(e2, t2 = true) {
        return e2 && e2 !== "value" ? `${t2 ? " " : ""}${e2}${t2 ? "" : " "}` : "";
      }
      function Is2(e2, t2) {
        return ks2(e2.importKind, t2);
      }
      function Ml(e2) {
        return ks2(e2.exportKind);
      }
      function ma2(e2, t2, r2) {
        let { node: n2 } = e2;
        if (!n2.source)
          return "";
        let s2 = [];
        return Da2(n2, t2) && s2.push(" from"), s2.push(" ", r2("source")), s2;
      }
      function ya(e2, t2, r2) {
        let { node: n2 } = e2;
        if (!Da2(n2, t2))
          return "";
        let s2 = [" "];
        if (w2(n2.specifiers)) {
          let u2 = [], i2 = [];
          e2.each(() => {
            let a2 = e2.node.type;
            if (a2 === "ExportNamespaceSpecifier" || a2 === "ExportDefaultSpecifier" || a2 === "ImportNamespaceSpecifier" || a2 === "ImportDefaultSpecifier")
              u2.push(r2());
            else if (a2 === "ExportSpecifier" || a2 === "ImportSpecifier")
              i2.push(r2());
            else
              throw new Me3(n2, "specifier");
          }, "specifiers"), s2.push(P2(", ", u2)), i2.length > 0 && (u2.length > 0 && s2.push(", "), i2.length > 1 || u2.length > 0 || n2.specifiers.some((o2) => d2(o2)) ? s2.push(l2(["{", f2([t2.bracketSpacing ? x2 : E2, P2([",", x2], i2)]), b3(ae2(t2) ? "," : ""), t2.bracketSpacing ? x2 : E2, "}"])) : s2.push(["{", t2.bracketSpacing ? " " : "", ...i2, t2.bracketSpacing ? " " : "", "}"]));
        } else
          s2.push("{}");
        return s2;
      }
      function Da2(e2, t2) {
        return e2.type !== "ImportDeclaration" || w2(e2.specifiers) || e2.importKind === "type" ? true : fr3(t2, R3(e2), R3(e2.source)).trimEnd().endsWith("from");
      }
      function Rl(e2, t2) {
        var n2, s2;
        if ((n2 = e2.extra) != null && n2.deprecatedAssertSyntax)
          return "assert";
        let r2 = fr3(t2, k(e2.source), (s2 = e2.attributes) != null && s2[0] ? R3(e2.attributes[0]) : k(e2)).trimStart();
        return r2.startsWith("assert") ? "assert" : r2.startsWith("with") || w2(e2.attributes) ? "with" : void 0;
      }
      function fa2(e2, t2, r2) {
        let { node: n2 } = e2;
        if (!n2.source)
          return "";
        let s2 = Rl(n2, t2);
        if (!s2)
          return "";
        let u2 = [` ${s2} {`];
        return w2(n2.attributes) && (t2.bracketSpacing && u2.push(" "), u2.push(P2(", ", e2.map(r2, "attributes"))), t2.bracketSpacing && u2.push(" ")), u2.push("}"), u2;
      }
      function Ea2(e2, t2, r2) {
        let { node: n2 } = e2, { type: s2 } = n2, u2 = s2.startsWith("Import"), i2 = u2 ? "imported" : "local", a2 = u2 ? "local" : "exported", o2 = n2[i2], c2 = n2[a2], m = "", D = "";
        return s2 === "ExportNamespaceSpecifier" || s2 === "ImportNamespaceSpecifier" ? m = "*" : o2 && (m = r2(i2)), c2 && !Jl(n2) && (D = r2(a2)), [ks2(s2 === "ImportSpecifier" ? n2.importKind : n2.exportKind, false), m, m && D ? " as " : "", D];
      }
      function Jl(e2) {
        if (e2.type !== "ImportSpecifier" && e2.type !== "ExportSpecifier")
          return false;
        let { local: t2, [e2.type === "ImportSpecifier" ? "imported" : "exported"]: r2 } = e2;
        if (t2.type !== r2.type || !eu2(t2, r2))
          return false;
        if (Q3(t2))
          return t2.value === r2.value && fe2(t2) === fe2(r2);
        switch (t2.type) {
          case "Identifier":
            return t2.name === r2.name;
          default:
            return false;
        }
      }
      function dt3(e2, t2, r2) {
        var j2;
        let n2 = t2.semi ? ";" : "", { node: s2 } = e2, u2 = s2.type === "ObjectTypeAnnotation", i2 = s2.type === "TSEnumDeclaration" || s2.type === "EnumBooleanBody" || s2.type === "EnumNumberBody" || s2.type === "EnumBigIntBody" || s2.type === "EnumStringBody" || s2.type === "EnumSymbolBody", a2 = [s2.type === "TSTypeLiteral" || i2 ? "members" : s2.type === "TSInterfaceBody" ? "body" : "properties"];
        u2 && a2.push("indexers", "callProperties", "internalSlots");
        let o2 = a2.flatMap((h2) => e2.map(({ node: W2 }) => ({ node: W2, printed: r2(), loc: R3(W2) }), h2));
        a2.length > 1 && o2.sort((h2, W2) => h2.loc - W2.loc);
        let { parent: c2, key: m } = e2, D = u2 && m === "body" && (c2.type === "InterfaceDeclaration" || c2.type === "DeclareInterface" || c2.type === "DeclareClass"), y3 = s2.type === "TSInterfaceBody" || i2 || D || s2.type === "ObjectPattern" && c2.type !== "FunctionDeclaration" && c2.type !== "FunctionExpression" && c2.type !== "ArrowFunctionExpression" && c2.type !== "ObjectMethod" && c2.type !== "ClassMethod" && c2.type !== "ClassPrivateMethod" && c2.type !== "AssignmentPattern" && c2.type !== "CatchClause" && s2.properties.some((h2) => h2.value && (h2.value.type === "ObjectPattern" || h2.value.type === "ArrayPattern")) || s2.type !== "ObjectPattern" && o2.length > 0 && de2(t2.originalText, R3(s2), o2[0].loc), C = D ? ";" : s2.type === "TSInterfaceBody" || s2.type === "TSTypeLiteral" ? b3(n2, ";") : ",", p2 = s2.type === "RecordExpression" ? "#{" : s2.exact ? "{|" : "{", A = s2.exact ? "|}" : "}", T3 = [], S3 = o2.map((h2) => {
          let W2 = [...T3, l2(h2.printed)];
          return T3 = [C, x2], (h2.node.type === "TSPropertySignature" || h2.node.type === "TSMethodSignature" || h2.node.type === "TSConstructSignatureDeclaration" || h2.node.type === "TSCallSignatureDeclaration") && d2(h2.node, g2.PrettierIgnore) && T3.shift(), pe2(h2.node, t2) && T3.push(F), W2;
        });
        if (s2.inexact || s2.hasUnknownMembers) {
          let h2;
          if (d2(s2, g2.Dangling)) {
            let W2 = d2(s2, g2.Line);
            h2 = [M3(e2, t2), W2 || te2(t2.originalText, k(O2(false, ct3(s2), -1))) ? F : x2, "..."];
          } else
            h2 = ["..."];
          S3.push([...T3, ...h2]);
        }
        let B2 = (j2 = O2(false, o2, -1)) == null ? void 0 : j2.node, _3 = !(s2.inexact || s2.hasUnknownMembers || B2 && (B2.type === "RestElement" || (B2.type === "TSPropertySignature" || B2.type === "TSCallSignatureDeclaration" || B2.type === "TSMethodSignature" || B2.type === "TSConstructSignatureDeclaration") && d2(B2, g2.PrettierIgnore))), J3;
        if (S3.length === 0) {
          if (!d2(s2, g2.Dangling))
            return [p2, A, Y2(e2, r2)];
          J3 = l2([p2, M3(e2, t2, { indent: true }), E2, A, V2(e2), Y2(e2, r2)]);
        } else
          J3 = [D && w2(s2.properties) ? Ss2(c2) : "", p2, f2([t2.bracketSpacing ? x2 : E2, ...S3]), b3(_3 && (C !== "," || ae2(t2)) ? C : ""), t2.bracketSpacing ? x2 : E2, A, V2(e2), Y2(e2, r2)];
        return e2.match((h2) => h2.type === "ObjectPattern" && !w2(h2.decorators), Ls) || we3(s2) && (e2.match(void 0, (h2, W2) => W2 === "typeAnnotation", (h2, W2) => W2 === "typeAnnotation", Ls) || e2.match(void 0, (h2, W2) => h2.type === "FunctionTypeParam" && W2 === "typeAnnotation", Ls)) || !y3 && e2.match((h2) => h2.type === "ObjectPattern", (h2) => h2.type === "AssignmentExpression" || h2.type === "VariableDeclarator") ? J3 : l2(J3, { shouldBreak: y3 });
      }
      function Ls(e2, t2) {
        return (t2 === "params" || t2 === "parameters" || t2 === "this" || t2 === "rest") && As2(e2);
      }
      function ql(e2) {
        let t2 = [e2];
        for (let r2 = 0; r2 < t2.length; r2++) {
          let n2 = t2[r2];
          for (let s2 of ["test", "consequent", "alternate"]) {
            let u2 = n2[s2];
            if (X3(u2))
              return true;
            u2.type === "ConditionalExpression" && t2.push(u2);
          }
        }
        return false;
      }
      function Wl(e2, t2, r2) {
        let { node: n2 } = e2, s2 = n2.type === "ConditionalExpression", u2 = s2 ? "alternate" : "falseType", { parent: i2 } = e2, a2 = s2 ? r2("test") : [r2("checkType"), " ", "extends", " ", r2("extendsType")];
        return i2.type === n2.type && i2[u2] === n2 ? he3(2, a2) : a2;
      }
      var Gl = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"], ["AwaitExpression", "argument"]]);
      function Ul2(e2) {
        let { node: t2 } = e2;
        if (t2.type !== "ConditionalExpression")
          return false;
        let r2, n2 = t2;
        for (let s2 = 0; !r2; s2++) {
          let u2 = e2.getParentNode(s2);
          if (u2.type === "ChainExpression" && u2.expression === n2 || L3(u2) && u2.callee === n2 || q2(u2) && u2.object === n2 || u2.type === "TSNonNullExpression" && u2.expression === n2) {
            n2 = u2;
            continue;
          }
          u2.type === "NewExpression" && u2.callee === n2 || Te2(u2) && u2.expression === n2 ? (r2 = e2.getParentNode(s2 + 1), n2 = u2) : r2 = u2;
        }
        return n2 === t2 ? false : r2[Gl.get(r2.type)] === n2;
      }
      function Fa2(e2, t2, r2) {
        let { node: n2 } = e2, s2 = n2.type === "ConditionalExpression", u2 = s2 ? "consequent" : "trueType", i2 = s2 ? "alternate" : "falseType", a2 = s2 ? ["test"] : ["checkType", "extendsType"], o2 = n2[u2], c2 = n2[i2], m = [], D = false, { parent: y3 } = e2, C = y3.type === n2.type && a2.some((H3) => y3[H3] === n2), p2 = y3.type === n2.type && !C, A, T3, S3 = 0;
        do
          T3 = A || n2, A = e2.getParentNode(S3), S3++;
        while (A && A.type === n2.type && a2.every((H3) => A[H3] !== T3));
        let B2 = A || y3, _3 = T3;
        if (s2 && (X3(n2[a2[0]]) || X3(o2) || X3(c2) || ql(_3))) {
          D = true, p2 = true;
          let H3 = (Z3) => [b3("("), f2([E2, Z3]), E2, b3(")")], ue2 = (Z3) => Z3.type === "NullLiteral" || Z3.type === "Literal" && Z3.value === null || Z3.type === "Identifier" && Z3.name === "undefined";
          m.push(" ? ", ue2(o2) ? r2(u2) : H3(r2(u2)), " : ", c2.type === n2.type || ue2(c2) ? r2(i2) : H3(r2(i2)));
        } else {
          let H3 = (Z3) => t2.useTabs ? f2(r2(Z3)) : he3(2, r2(Z3)), ue2 = [x2, "? ", o2.type === n2.type ? b3("", "(") : "", H3(u2), o2.type === n2.type ? b3("", ")") : "", x2, ": ", H3(i2)];
          m.push(y3.type !== n2.type || y3[i2] === n2 || C ? ue2 : t2.useTabs ? Mr2(f2(ue2)) : he3(Math.max(0, t2.tabWidth - 2), ue2));
        }
        let J3 = [u2, i2, ...a2].some((H3) => d2(n2[H3], (ue2) => re3(ue2) && de2(t2.originalText, R3(ue2), k(ue2)))), j2 = (H3) => y3 === B2 ? l2(H3, { shouldBreak: J3 }) : J3 ? [H3, Ee2] : H3, h2 = !D && (q2(y3) || y3.type === "NGPipeExpression" && y3.left === n2) && !y3.computed, W2 = Ul2(e2), Fe3 = j2([Wl(e2, t2, r2), p2 ? m : f2(m), s2 && h2 && !W2 ? E2 : ""]);
        return C || W2 ? l2([f2([E2, Fe3]), E2]) : Fe3;
      }
      function Nl(e2, t2) {
        return (q2(t2) || t2.type === "NGPipeExpression" && t2.left === e2) && !t2.computed;
      }
      function Xl2(e2, t2, r2, n2) {
        return [...e2.map((u2) => ct3(u2)), ct3(t2), ct3(r2)].flat().some((u2) => re3(u2) && de2(n2.originalText, R3(u2), k(u2)));
      }
      var Yl2 = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"], ["AwaitExpression", "argument"]]);
      function Hl(e2) {
        let { node: t2 } = e2;
        if (t2.type !== "ConditionalExpression")
          return false;
        let r2, n2 = t2;
        for (let s2 = 0; !r2; s2++) {
          let u2 = e2.getParentNode(s2);
          if (u2.type === "ChainExpression" && u2.expression === n2 || L3(u2) && u2.callee === n2 || q2(u2) && u2.object === n2 || u2.type === "TSNonNullExpression" && u2.expression === n2) {
            n2 = u2;
            continue;
          }
          u2.type === "NewExpression" && u2.callee === n2 || Te2(u2) && u2.expression === n2 ? (r2 = e2.getParentNode(s2 + 1), n2 = u2) : r2 = u2;
        }
        return n2 === t2 ? false : r2[Yl2.get(r2.type)] === n2;
      }
      var ws = (e2) => [b3("("), f2([E2, e2]), E2, b3(")")];
      function Vt2(e2, t2, r2, n2) {
        if (!t2.experimentalTernaries)
          return Fa2(e2, t2, r2);
        let { node: s2 } = e2, u2 = s2.type === "ConditionalExpression", i2 = s2.type === "TSConditionalType" || s2.type === "ConditionalTypeAnnotation", a2 = u2 ? "consequent" : "trueType", o2 = u2 ? "alternate" : "falseType", c2 = u2 ? ["test"] : ["checkType", "extendsType"], m = s2[a2], D = s2[o2], y3 = c2.map((We2) => s2[We2]), { parent: C } = e2, p2 = C.type === s2.type, A = p2 && c2.some((We2) => C[We2] === s2), T3 = p2 && C[o2] === s2, S3 = m.type === s2.type, B2 = D.type === s2.type, _3 = B2 || T3, J3 = t2.tabWidth > 2 || t2.useTabs, j2, h2, W2 = 0;
        do
          h2 = j2 || s2, j2 = e2.getParentNode(W2), W2++;
        while (j2 && j2.type === s2.type && c2.every((We2) => j2[We2] !== h2));
        let Fe3 = j2 || C, H3 = n2 && n2.assignmentLayout && n2.assignmentLayout !== "break-after-operator" && (C.type === "AssignmentExpression" || C.type === "VariableDeclarator" || C.type === "ClassProperty" || C.type === "PropertyDefinition" || C.type === "ClassPrivateProperty" || C.type === "ObjectProperty" || C.type === "Property"), ue2 = (C.type === "ReturnStatement" || C.type === "ThrowStatement") && !(S3 || B2), Z3 = u2 && Fe3.type === "JSXExpressionContainer" && e2.grandparent.type !== "JSXAttribute", It2 = Hl(e2), $t2 = Nl(s2, C), I2 = i2 && Be3(e2, t2), G3 = J3 ? t2.useTabs ? "	" : " ".repeat(t2.tabWidth - 1) : "", ee3 = Xl2(y3, m, D, t2) || S3 || B2, qe2 = !_3 && !p2 && !i2 && (Z3 ? m.type === "NullLiteral" || m.type === "Literal" && m.value === null : rr2(m, t2) && Rn2(s2.test, 3)), xt3 = _3 || T3 || i2 && !p2 || p2 && u2 && Rn2(s2.test, 1) || qe2, js2 = [];
        !S3 && d2(m, g2.Dangling) && e2.call((We2) => {
          js2.push(M3(We2, t2), F);
        }, "consequent");
        let Kt2 = [];
        d2(s2.test, g2.Dangling) && e2.call((We2) => {
          Kt2.push(M3(We2, t2));
        }, "test"), !B2 && d2(D, g2.Dangling) && e2.call((We2) => {
          Kt2.push(M3(We2, t2));
        }, "alternate"), d2(s2, g2.Dangling) && Kt2.push(M3(e2, t2));
        let vs = Symbol("test"), Ma2 = Symbol("consequent"), Fr2 = Symbol("test-and-consequent"), Ra2 = u2 ? [ws(r2("test")), s2.test.type === "ConditionalExpression" ? Ee2 : ""] : [r2("checkType"), " ", "extends", " ", s2.extendsType.type === "TSConditionalType" || s2.extendsType.type === "ConditionalTypeAnnotation" || s2.extendsType.type === "TSMappedType" ? r2("extendsType") : l2(ws(r2("extendsType")))], Ms2 = l2([Ra2, " ?"], { id: vs }), Ja2 = r2(a2), Cr2 = f2([S3 || Z3 && (X3(m) || p2 || _3) ? F : x2, js2, Ja2]), qa = xt3 ? l2([Ms2, _3 ? Cr2 : b3(Cr2, l2(Cr2, { id: Ma2 }), { groupId: vs })], { id: Fr2 }) : [Ms2, Cr2], kn3 = r2(o2), Rs2 = qe2 ? b3(kn3, Mr2(ws(kn3)), { groupId: Fr2 }) : kn3, zt2 = [qa, Kt2.length > 0 ? [f2([F, Kt2]), F] : B2 ? F : qe2 ? b3(x2, " ", { groupId: Fr2 }) : x2, ":", B2 ? " " : J3 ? xt3 ? b3(G3, b3(_3 || qe2 ? " " : G3, " "), { groupId: Fr2 }) : b3(G3, " ") : " ", B2 ? Rs2 : l2([f2(Rs2), Z3 && !qe2 ? E2 : ""]), $t2 && !It2 ? E2 : "", ee3 ? Ee2 : ""];
        return H3 && !ee3 ? l2(f2([E2, l2(zt2)])) : H3 || ue2 ? l2(f2(zt2)) : It2 || i2 && A ? l2([f2([E2, zt2]), I2 ? E2 : ""]) : C === Fe3 ? l2(zt2) : zt2;
      }
      function Ca(e2, t2, r2, n2) {
        let { node: s2 } = e2;
        if (kr3(s2))
          return pa2(e2, t2);
        let u2 = t2.semi ? ";" : "", i2 = [];
        switch (s2.type) {
          case "JsExpressionRoot":
            return r2("node");
          case "JsonRoot":
            return [r2("node"), F];
          case "File":
            return ia(e2, t2, r2) ?? r2("program");
          case "EmptyStatement":
            return "";
          case "ExpressionStatement":
            return ua2(e2, t2, r2);
          case "ChainExpression":
            return r2("expression");
          case "ParenthesizedExpression":
            return !d2(s2.expression) && (se2(s2.expression) || U2(s2.expression)) ? ["(", r2("expression"), ")"] : l2(["(", f2([E2, r2("expression")]), E2, ")"]);
          case "AssignmentExpression":
            return wi(e2, t2, r2);
          case "VariableDeclarator":
            return Oi2(e2, t2, r2);
          case "BinaryExpression":
          case "LogicalExpression":
            return Yr3(e2, t2, r2);
          case "AssignmentPattern":
            return [r2("left"), " = ", r2("right")];
          case "OptionalMemberExpression":
          case "MemberExpression":
            return bi(e2, t2, r2);
          case "MetaProperty":
            return [r2("meta"), ".", r2("property")];
          case "BindExpression":
            return s2.object && i2.push(r2("object")), i2.push(l2(f2([E2, Hr3(e2, t2, r2)]))), i2;
          case "Identifier":
            return [s2.name, V2(e2), pn3(e2), Y2(e2, r2)];
          case "V8IntrinsicIdentifier":
            return ["%", s2.name];
          case "SpreadElement":
          case "SpreadElementPattern":
          case "SpreadPropertyPattern":
          case "RestElement":
            return cn3(e2, r2);
          case "FunctionDeclaration":
          case "FunctionExpression":
            return Dn2(e2, r2, t2, n2);
          case "ArrowFunctionExpression":
            return $i(e2, t2, r2, n2);
          case "YieldExpression":
            return i2.push("yield"), s2.delegate && i2.push("*"), s2.argument && i2.push(" ", r2("argument")), i2;
          case "AwaitExpression":
            if (i2.push("await"), s2.argument) {
              i2.push(" ", r2("argument"));
              let { parent: a2 } = e2;
              if (L3(a2) && a2.callee === s2 || q2(a2) && a2.object === s2) {
                i2 = [f2([E2, ...i2]), E2];
                let o2 = e2.findAncestor((c2) => c2.type === "AwaitExpression" || c2.type === "BlockStatement");
                if ((o2 == null ? void 0 : o2.type) !== "AwaitExpression" || !ie2(o2.argument, (c2) => c2 === s2))
                  return l2(i2);
              }
            }
            return i2;
          case "ExportDefaultDeclaration":
          case "ExportNamedDeclaration":
          case "ExportAllDeclaration":
            return gn3(e2, t2, r2);
          case "ImportDeclaration":
            return ca2(e2, t2, r2);
          case "ImportSpecifier":
          case "ExportSpecifier":
          case "ImportNamespaceSpecifier":
          case "ExportNamespaceSpecifier":
          case "ImportDefaultSpecifier":
          case "ExportDefaultSpecifier":
            return Ea2(e2, t2, r2);
          case "ImportAttribute":
            return yn3(e2, t2, r2);
          case "Import":
            return "import";
          case "Program":
          case "BlockStatement":
          case "StaticBlock":
            return Fn2(e2, t2, r2);
          case "ClassBody":
            return ra(e2, t2, r2);
          case "ThrowStatement":
            return Yi2(e2, t2, r2);
          case "ReturnStatement":
            return Xi2(e2, t2, r2);
          case "NewExpression":
          case "ImportExpression":
          case "OptionalCallExpression":
          case "CallExpression":
            return Vr2(e2, t2, r2);
          case "ObjectExpression":
          case "ObjectPattern":
          case "RecordExpression":
            return dt3(e2, t2, r2);
          case "Property":
            return gt2(s2) ? mr2(e2, t2, r2) : yn3(e2, t2, r2);
          case "ObjectProperty":
            return yn3(e2, t2, r2);
          case "ObjectMethod":
            return mr2(e2, t2, r2);
          case "Decorator":
            return ["@", r2("expression")];
          case "ArrayExpression":
          case "ArrayPattern":
          case "TupleExpression":
            return Yt2(e2, t2, r2);
          case "SequenceExpression": {
            let { parent: a2 } = e2;
            if (a2.type === "ExpressionStatement" || a2.type === "ForStatement") {
              let o2 = [];
              return e2.each(({ isFirst: c2 }) => {
                c2 ? o2.push(r2()) : o2.push(",", f2([x2, r2()]));
              }, "expressions"), l2(o2);
            }
            return l2(P2([",", x2], e2.map(r2, "expressions")));
          }
          case "ThisExpression":
            return "this";
          case "Super":
            return "super";
          case "Directive":
            return [r2("value"), u2];
          case "UnaryExpression":
            return i2.push(s2.operator), /[a-z]$/u.test(s2.operator) && i2.push(" "), d2(s2.argument) ? i2.push(l2(["(", f2([E2, r2("argument")]), E2, ")"])) : i2.push(r2("argument")), i2;
          case "UpdateExpression":
            return [s2.prefix ? s2.operator : "", r2("argument"), s2.prefix ? "" : s2.operator];
          case "ConditionalExpression":
            return Vt2(e2, t2, r2, n2);
          case "VariableDeclaration": {
            let a2 = e2.map(r2, "declarations"), o2 = e2.parent, c2 = o2.type === "ForStatement" || o2.type === "ForInStatement" || o2.type === "ForOfStatement", m = s2.declarations.some((y3) => y3.init), D;
            return a2.length === 1 && !d2(s2.declarations[0]) ? D = a2[0] : a2.length > 0 && (D = f2(a2[0])), i2 = [$2(e2), s2.kind, D ? [" ", D] : "", f2(a2.slice(1).map((y3) => [",", m && !c2 ? F : x2, y3]))], c2 && o2.body !== s2 || i2.push(u2), l2(i2);
          }
          case "WithStatement":
            return l2(["with (", r2("object"), ")", ft2(s2.body, r2("body"))]);
          case "IfStatement": {
            let a2 = ft2(s2.consequent, r2("consequent")), o2 = l2(["if (", l2([f2([E2, r2("test")]), E2]), ")", a2]);
            if (i2.push(o2), s2.alternate) {
              let c2 = d2(s2.consequent, g2.Trailing | g2.Line) || wr2(s2), m = s2.consequent.type === "BlockStatement" && !c2;
              i2.push(m ? " " : F), d2(s2, g2.Dangling) && i2.push(M3(e2, t2), c2 ? F : " "), i2.push("else", l2(ft2(s2.alternate, r2("alternate"), s2.alternate.type === "IfStatement")));
            }
            return i2;
          }
          case "ForStatement": {
            let a2 = ft2(s2.body, r2("body")), o2 = M3(e2, t2), c2 = o2 ? [o2, E2] : "";
            return !s2.init && !s2.test && !s2.update ? [c2, l2(["for (;;)", a2])] : [c2, l2(["for (", l2([f2([E2, r2("init"), ";", x2, r2("test"), ";", x2, r2("update")]), E2]), ")", a2])];
          }
          case "WhileStatement":
            return l2(["while (", l2([f2([E2, r2("test")]), E2]), ")", ft2(s2.body, r2("body"))]);
          case "ForInStatement":
            return l2(["for (", r2("left"), " in ", r2("right"), ")", ft2(s2.body, r2("body"))]);
          case "ForOfStatement":
            return l2(["for", s2.await ? " await" : "", " (", r2("left"), " of ", r2("right"), ")", ft2(s2.body, r2("body"))]);
          case "DoWhileStatement": {
            let a2 = ft2(s2.body, r2("body"));
            return i2 = [l2(["do", a2])], s2.body.type === "BlockStatement" ? i2.push(" ") : i2.push(F), i2.push("while (", l2([f2([E2, r2("test")]), E2]), ")", u2), i2;
          }
          case "DoExpression":
            return [s2.async ? "async " : "", "do ", r2("body")];
          case "BreakStatement":
          case "ContinueStatement":
            return i2.push(s2.type === "BreakStatement" ? "break" : "continue"), s2.label && i2.push(" ", r2("label")), i2.push(u2), i2;
          case "LabeledStatement":
            return s2.body.type === "EmptyStatement" ? [r2("label"), ":;"] : [r2("label"), ": ", r2("body")];
          case "TryStatement":
            return ["try ", r2("block"), s2.handler ? [" ", r2("handler")] : "", s2.finalizer ? [" finally ", r2("finalizer")] : ""];
          case "CatchClause":
            if (s2.param) {
              let a2 = d2(s2.param, (c2) => !re3(c2) || c2.leading && te2(t2.originalText, k(c2)) || c2.trailing && te2(t2.originalText, R3(c2), { backwards: true })), o2 = r2("param");
              return ["catch ", a2 ? ["(", f2([E2, o2]), E2, ") "] : ["(", o2, ") "], r2("body")];
            }
            return ["catch ", r2("body")];
          case "SwitchStatement":
            return [l2(["switch (", f2([E2, r2("discriminant")]), E2, ")"]), " {", s2.cases.length > 0 ? f2([F, P2(F, e2.map(({ node: a2, isLast: o2 }) => [r2(), !o2 && pe2(a2, t2) ? F : ""], "cases"))]) : "", F, "}"];
          case "SwitchCase": {
            s2.test ? i2.push("case ", r2("test"), ":") : i2.push("default:"), d2(s2, g2.Dangling) && i2.push(" ", M3(e2, t2));
            let a2 = s2.consequent.filter((o2) => o2.type !== "EmptyStatement");
            if (a2.length > 0) {
              let o2 = yr3(e2, t2, r2, "consequent");
              i2.push(a2.length === 1 && a2[0].type === "BlockStatement" ? [" ", o2] : f2([F, o2]));
            }
            return i2;
          }
          case "DebuggerStatement":
            return ["debugger", u2];
          case "ClassDeclaration":
          case "ClassExpression":
            return Tn3(e2, t2, r2);
          case "ClassMethod":
          case "ClassPrivateMethod":
          case "MethodDefinition":
            return dn3(e2, t2, r2);
          case "ClassProperty":
          case "PropertyDefinition":
          case "ClassPrivateProperty":
          case "ClassAccessorProperty":
          case "AccessorProperty":
            return xn3(e2, t2, r2);
          case "TemplateElement":
            return Ie3(s2.value.raw);
          case "TemplateLiteral":
            return qr2(e2, r2, t2);
          case "TaggedTemplateExpression":
            return Uu3(e2, r2);
          case "PrivateIdentifier":
            return ["#", s2.name];
          case "PrivateName":
            return ["#", r2("id")];
          case "TopicReference":
            return "%";
          case "ArgumentPlaceholder":
            return "?";
          case "ModuleExpression":
            return ["module ", r2("body")];
          case "InterpreterDirective":
          default:
            throw new Me3(s2, "ESTree");
        }
      }
      function Sn3(e2, t2, r2) {
        let { parent: n2, node: s2, key: u2 } = e2, i2 = [r2("expression")];
        switch (s2.type) {
          case "AsConstExpression":
            i2.push(" as const");
            break;
          case "AsExpression":
          case "TSAsExpression":
            i2.push(" as ", r2("typeAnnotation"));
            break;
          case "SatisfiesExpression":
          case "TSSatisfiesExpression":
            i2.push(" satisfies ", r2("typeAnnotation"));
            break;
        }
        return u2 === "callee" && L3(n2) || u2 === "object" && q2(n2) ? l2([f2([E2, ...i2]), E2]) : i2;
      }
      function Aa(e2, t2, r2) {
        let { node: n2 } = e2, s2 = [$2(e2), "component"];
        n2.id && s2.push(" ", r2("id")), s2.push(r2("typeParameters"));
        let u2 = Vl(e2, r2, t2);
        return n2.rendersType ? s2.push(l2([u2, " ", r2("rendersType")])) : s2.push(l2([u2])), n2.body && s2.push(" ", r2("body")), t2.semi && n2.type === "DeclareComponent" && s2.push(";"), s2;
      }
      function Vl(e2, t2, r2) {
        let { node: n2 } = e2, s2 = n2.params;
        if (n2.rest && (s2 = [...s2, n2.rest]), s2.length === 0)
          return ["(", M3(e2, r2, { filter: (i2) => ge2(r2.originalText, k(i2)) === ")" }), ")"];
        let u2 = [];
        return Kl(e2, (i2, a2) => {
          let o2 = a2 === s2.length - 1;
          o2 && n2.rest && u2.push("..."), u2.push(t2()), !o2 && (u2.push(","), pe2(s2[a2], r2) ? u2.push(F, F) : u2.push(x2));
        }), ["(", f2([E2, ...u2]), b3(ae2(r2, "all") && !$l(n2, s2) ? "," : ""), E2, ")"];
      }
      function $l(e2, t2) {
        var r2;
        return e2.rest || ((r2 = O2(false, t2, -1)) == null ? void 0 : r2.type) === "RestElement";
      }
      function Kl(e2, t2) {
        let { node: r2 } = e2, n2 = 0, s2 = (u2) => t2(u2, n2++);
        e2.each(s2, "params"), r2.rest && e2.call(s2, "rest");
      }
      function Ta(e2, t2, r2) {
        let { node: n2 } = e2;
        return n2.shorthand ? r2("local") : [r2("name"), " as ", r2("local")];
      }
      function da2(e2, t2, r2) {
        let { node: n2 } = e2, s2 = [];
        return n2.name && s2.push(r2("name"), n2.optional ? "?: " : ": "), s2.push(r2("typeAnnotation")), s2;
      }
      function xa2(e2, t2, r2) {
        return dt3(e2, r2, t2);
      }
      function Bn3(e2, t2) {
        let { node: r2 } = e2, n2 = t2("id");
        r2.computed && (n2 = ["[", n2, "]"]);
        let s2 = "";
        return r2.initializer && (s2 = t2("initializer")), r2.init && (s2 = t2("init")), s2 ? [n2, " = ", s2] : n2;
      }
      function ha2(e2, t2, r2) {
        let { node: n2 } = e2, s2;
        if (n2.type === "EnumSymbolBody" || n2.explicitType)
          switch (n2.type) {
            case "EnumBooleanBody":
              s2 = "boolean";
              break;
            case "EnumNumberBody":
              s2 = "number";
              break;
            case "EnumBigIntBody":
              s2 = "bigint";
              break;
            case "EnumStringBody":
              s2 = "string";
              break;
            case "EnumSymbolBody":
              s2 = "symbol";
              break;
          }
        return [s2 ? `of ${s2} ` : "", xa2(e2, t2, r2)];
      }
      function bn3(e2, t2, r2) {
        let { node: n2 } = e2;
        return [$2(e2), n2.const ? "const " : "", "enum ", t2("id"), " ", n2.type === "TSEnumDeclaration" ? xa2(e2, t2, r2) : t2("body")];
      }
      function Sa2(e2, t2, r2) {
        let { node: n2 } = e2, s2 = ["hook"];
        n2.id && s2.push(" ", r2("id"));
        let u2 = Je2(e2, r2, t2, false, true), i2 = Ht2(e2, r2), a2 = ot3(n2, i2);
        return s2.push(l2([a2 ? l2(u2) : u2, i2]), n2.body ? " " : "", r2("body")), s2;
      }
      function Ba(e2, t2, r2) {
        let { node: n2 } = e2, s2 = [$2(e2), "hook"];
        return n2.id && s2.push(" ", r2("id")), t2.semi && s2.push(";"), s2;
      }
      function ga2(e2) {
        var r2;
        let { node: t2 } = e2;
        return t2.type === "HookTypeAnnotation" && ((r2 = e2.getParentNode(2)) == null ? void 0 : r2.type) === "DeclareHook";
      }
      function ba2(e2, t2, r2) {
        let { node: n2 } = e2, s2 = [];
        s2.push(ga2(e2) ? "" : "hook ");
        let u2 = Je2(e2, r2, t2, false, true), i2 = [];
        return i2.push(ga2(e2) ? ": " : " => ", r2("returnType")), ot3(n2, i2) && (u2 = l2(u2)), s2.push(u2, i2), l2(s2);
      }
      function Pn3(e2, t2, r2) {
        let { node: n2 } = e2, s2 = [$2(e2), "interface"], u2 = [], i2 = [];
        n2.type !== "InterfaceTypeAnnotation" && u2.push(" ", r2("id"), r2("typeParameters"));
        let a2 = n2.typeParameters && !d2(n2.typeParameters, g2.Trailing | g2.Line);
        return w2(n2.extends) && i2.push(a2 ? b3(" ", x2, { groupId: Dr2(n2.typeParameters) }) : x2, "extends ", (n2.extends.length === 1 ? mu2 : f2)(P2([",", x2], e2.map(r2, "extends")))), d2(n2.id, g2.Trailing) || w2(n2.extends) ? a2 ? s2.push(l2([...u2, f2(i2)])) : s2.push(l2(f2([...u2, ...i2]))) : s2.push(...u2, ...i2), s2.push(" ", r2("body")), l2(s2);
      }
      function Pa(e2, t2, r2) {
        let { node: n2 } = e2;
        if (Sr2(n2))
          return n2.type.slice(0, -14).toLowerCase();
        let s2 = t2.semi ? ";" : "";
        switch (n2.type) {
          case "ComponentDeclaration":
          case "DeclareComponent":
          case "ComponentTypeAnnotation":
            return Aa(e2, t2, r2);
          case "ComponentParameter":
            return Ta(e2, t2, r2);
          case "ComponentTypeParameter":
            return da2(e2, t2, r2);
          case "HookDeclaration":
            return Sa2(e2, t2, r2);
          case "DeclareHook":
            return Ba(e2, t2, r2);
          case "HookTypeAnnotation":
            return ba2(e2, t2, r2);
          case "DeclareClass":
            return Tn3(e2, t2, r2);
          case "DeclareFunction":
            return [$2(e2), "function ", r2("id"), r2("predicate"), s2];
          case "DeclareModule":
            return ["declare module ", r2("id"), " ", r2("body")];
          case "DeclareModuleExports":
            return ["declare module.exports", Y2(e2, r2), s2];
          case "DeclareNamespace":
            return ["declare namespace ", r2("id"), " ", r2("body")];
          case "DeclareVariable":
            return [$2(e2), n2.kind ?? "var", " ", r2("id"), s2];
          case "DeclareExportDeclaration":
          case "DeclareExportAllDeclaration":
            return gn3(e2, t2, r2);
          case "DeclareOpaqueType":
          case "OpaqueType":
            return Mi2(e2, t2, r2);
          case "DeclareTypeAlias":
          case "TypeAlias":
            return Kr2(e2, t2, r2);
          case "IntersectionTypeAnnotation":
            return zr2(e2, t2, r2);
          case "UnionTypeAnnotation":
            return Qr2(e2, t2, r2);
          case "ConditionalTypeAnnotation":
            return Vt2(e2, t2, r2);
          case "InferTypeAnnotation":
            return tn3(e2, t2, r2);
          case "FunctionTypeAnnotation":
            return Zr2(e2, t2, r2);
          case "TupleTypeAnnotation":
            return Yt2(e2, t2, r2);
          case "TupleTypeLabeledElement":
            return nn3(e2, t2, r2);
          case "TupleTypeSpreadElement":
            return rn3(e2, t2, r2);
          case "GenericTypeAnnotation":
            return [r2("id"), Pt2(e2, t2, r2, "typeParameters")];
          case "IndexedAccessType":
          case "OptionalIndexedAccessType":
            return en3(e2, t2, r2);
          case "TypeAnnotation":
            return sn2(e2, t2, r2);
          case "TypeParameter":
            return An2(e2, t2, r2);
          case "TypeofTypeAnnotation":
            return an3(e2, r2);
          case "ExistsTypeAnnotation":
            return "*";
          case "ArrayTypeAnnotation":
            return un3(r2);
          case "DeclareEnum":
          case "EnumDeclaration":
            return bn3(e2, r2, t2);
          case "EnumBooleanBody":
          case "EnumNumberBody":
          case "EnumBigIntBody":
          case "EnumStringBody":
          case "EnumSymbolBody":
            return ha2(e2, r2, t2);
          case "EnumBooleanMember":
          case "EnumNumberMember":
          case "EnumBigIntMember":
          case "EnumStringMember":
          case "EnumDefaultedMember":
            return Bn3(e2, r2);
          case "FunctionTypeParam": {
            let u2 = n2.name ? r2("name") : e2.parent.this === n2 ? "this" : "";
            return [u2, V2(e2), u2 ? ": " : "", r2("typeAnnotation")];
          }
          case "DeclareInterface":
          case "InterfaceDeclaration":
          case "InterfaceTypeAnnotation":
            return Pn3(e2, t2, r2);
          case "ClassImplements":
          case "InterfaceExtends":
            return [r2("id"), r2("typeParameters")];
          case "NullableTypeAnnotation":
            return ["?", r2("typeAnnotation")];
          case "Variance": {
            let { kind: u2 } = n2;
            return ln3.ok(u2 === "plus" || u2 === "minus"), u2 === "plus" ? "+" : "-";
          }
          case "KeyofTypeAnnotation":
            return ["keyof ", r2("argument")];
          case "ObjectTypeCallProperty":
            return [n2.static ? "static " : "", r2("value")];
          case "ObjectTypeMappedTypeProperty":
            return zi(e2, t2, r2);
          case "ObjectTypeIndexer":
            return [n2.static ? "static " : "", n2.variance ? r2("variance") : "", "[", r2("id"), n2.id ? ": " : "", r2("key"), "]: ", r2("value")];
          case "ObjectTypeProperty": {
            let u2 = "";
            return n2.proto ? u2 = "proto " : n2.static && (u2 = "static "), [u2, n2.kind !== "init" ? n2.kind + " " : "", n2.variance ? r2("variance") : "", Et3(e2, t2, r2), V2(e2), gt2(n2) ? "" : ": ", r2("value")];
          }
          case "ObjectTypeAnnotation":
            return dt3(e2, t2, r2);
          case "ObjectTypeInternalSlot":
            return [n2.static ? "static " : "", "[[", r2("id"), "]]", V2(e2), n2.method ? "" : ": ", r2("value")];
          case "ObjectTypeSpreadProperty":
            return cn3(e2, r2);
          case "QualifiedTypeofIdentifier":
          case "QualifiedTypeIdentifier":
            return [r2("qualification"), ".", r2("id")];
          case "NullLiteralTypeAnnotation":
            return "null";
          case "BooleanLiteralTypeAnnotation":
            return String(n2.value);
          case "StringLiteralTypeAnnotation":
            return Ie3(tt2(fe2(n2), t2));
          case "NumberLiteralTypeAnnotation":
            return Ze2(n2.raw ?? n2.extra.raw);
          case "BigIntLiteralTypeAnnotation":
            return hn3(n2.raw ?? n2.extra.raw);
          case "TypeCastExpression":
            return ["(", r2("expression"), Y2(e2, r2), ")"];
          case "TypePredicate":
            return on2(e2, r2);
          case "TypeOperator":
            return [n2.operator, " ", r2("typeAnnotation")];
          case "TypeParameterDeclaration":
          case "TypeParameterInstantiation":
            return Pt2(e2, t2, r2, "params");
          case "InferredPredicate":
          case "DeclaredPredicate":
            return [e2.key === "predicate" && e2.parent.type !== "DeclareFunction" && !e2.parent.returnType ? ": " : " ", "%checks", ...n2.type === "DeclaredPredicate" ? ["(", r2("value"), ")"] : []];
          case "AsExpression":
          case "AsConstExpression":
          case "SatisfiesExpression":
            return Sn3(e2, t2, r2);
        }
      }
      function ka2(e2, t2, r2) {
        var i2;
        let { node: n2 } = e2;
        if (!n2.type.startsWith("TS"))
          return;
        if (Br2(n2))
          return n2.type.slice(2, -7).toLowerCase();
        let s2 = t2.semi ? ";" : "", u2 = [];
        switch (n2.type) {
          case "TSThisType":
            return "this";
          case "TSTypeAssertion": {
            let a2 = !(U2(n2.expression) || se2(n2.expression)), o2 = l2(["<", f2([E2, r2("typeAnnotation")]), E2, ">"]), c2 = [b3("("), f2([E2, r2("expression")]), E2, b3(")")];
            return a2 ? ze2([[o2, r2("expression")], [o2, l2(c2, { shouldBreak: true })], [o2, r2("expression")]]) : l2([o2, r2("expression")]);
          }
          case "TSDeclareFunction":
            return Dn2(e2, r2, t2);
          case "TSExportAssignment":
            return ["export = ", r2("expression"), s2];
          case "TSModuleBlock":
            return Fn2(e2, t2, r2);
          case "TSInterfaceBody":
          case "TSTypeLiteral":
            return dt3(e2, t2, r2);
          case "TSTypeAliasDeclaration":
            return Kr2(e2, t2, r2);
          case "TSQualifiedName":
            return [r2("left"), ".", r2("right")];
          case "TSAbstractMethodDefinition":
          case "TSDeclareMethod":
            return dn3(e2, t2, r2);
          case "TSAbstractAccessorProperty":
          case "TSAbstractPropertyDefinition":
            return xn3(e2, t2, r2);
          case "TSInterfaceHeritage":
          case "TSClassImplements":
          case "TSExpressionWithTypeArguments":
          case "TSInstantiationExpression":
            return [r2("expression"), r2(n2.typeArguments ? "typeArguments" : "typeParameters")];
          case "TSTemplateLiteralType":
            return qr2(e2, r2, t2);
          case "TSNamedTupleMember":
            return nn3(e2, t2, r2);
          case "TSRestType":
            return rn3(e2, t2, r2);
          case "TSOptionalType":
            return [r2("typeAnnotation"), "?"];
          case "TSInterfaceDeclaration":
            return Pn3(e2, t2, r2);
          case "TSTypeParameterDeclaration":
          case "TSTypeParameterInstantiation":
            return Pt2(e2, t2, r2, "params");
          case "TSTypeParameter":
            return An2(e2, t2, r2);
          case "TSAsExpression":
          case "TSSatisfiesExpression":
            return Sn3(e2, t2, r2);
          case "TSArrayType":
            return un3(r2);
          case "TSPropertySignature":
            return [n2.readonly ? "readonly " : "", Et3(e2, t2, r2), V2(e2), Y2(e2, r2)];
          case "TSParameterProperty":
            return [Xt(n2), n2.static ? "static " : "", n2.override ? "override " : "", n2.readonly ? "readonly " : "", r2("parameter")];
          case "TSTypeQuery":
            return an3(e2, r2);
          case "TSIndexSignature": {
            let a2 = n2.parameters.length > 1 ? b3(ae2(t2) ? "," : "") : "", o2 = l2([f2([E2, P2([", ", E2], e2.map(r2, "parameters"))]), a2, E2]), c2 = e2.parent.type === "ClassBody" && e2.key === "body";
            return [c2 && n2.static ? "static " : "", n2.readonly ? "readonly " : "", "[", n2.parameters ? o2 : "", "]", Y2(e2, r2), c2 ? s2 : ""];
          }
          case "TSTypePredicate":
            return on2(e2, r2);
          case "TSNonNullExpression":
            return [r2("expression"), "!"];
          case "TSImportType":
            return [n2.isTypeOf ? "typeof " : "", "import(", r2("argument"), ")", n2.qualifier ? [".", r2("qualifier")] : "", Pt2(e2, t2, r2, n2.typeArguments ? "typeArguments" : "typeParameters")];
          case "TSLiteralType":
            return r2("literal");
          case "TSIndexedAccessType":
            return en3(e2, t2, r2);
          case "TSTypeOperator":
            return [n2.operator, " ", r2("typeAnnotation")];
          case "TSMappedType":
            return Qi2(e2, t2, r2);
          case "TSMethodSignature": {
            let a2 = n2.kind && n2.kind !== "method" ? `${n2.kind} ` : "";
            u2.push(Xt(n2), a2, n2.computed ? "[" : "", r2("key"), n2.computed ? "]" : "", V2(e2));
            let o2 = Je2(e2, r2, t2, false, true), c2 = n2.returnType ? "returnType" : "typeAnnotation", m = n2[c2], D = m ? Y2(e2, r2, c2) : "", y3 = ot3(n2, D);
            return u2.push(y3 ? l2(o2) : o2), m && u2.push(l2(D)), l2(u2);
          }
          case "TSNamespaceExportDeclaration":
            return ["export as namespace ", r2("id"), t2.semi ? ";" : ""];
          case "TSEnumDeclaration":
            return bn3(e2, r2, t2);
          case "TSEnumMember":
            return Bn3(e2, r2);
          case "TSImportEqualsDeclaration":
            return [n2.isExport ? "export " : "", "import ", Is2(n2, false), r2("id"), " = ", r2("moduleReference"), t2.semi ? ";" : ""];
          case "TSExternalModuleReference":
            return ["require(", r2("expression"), ")"];
          case "TSModuleDeclaration": {
            let { parent: a2 } = e2, o2 = a2.type === "TSModuleDeclaration", c2 = ((i2 = n2.body) == null ? void 0 : i2.type) === "TSModuleDeclaration";
            if (o2)
              u2.push(".");
            else if (u2.push($2(e2)), !(n2.kind === "global" || n2.global)) {
              let D = n2.kind ?? (Q3(n2.id) || fr3(t2, R3(n2), R3(n2.id)).trim().endsWith("module") ? "module" : "namespace");
              u2.push(D, " ");
            }
            return u2.push(r2("id")), c2 ? u2.push(r2("body")) : n2.body ? u2.push(" ", l2(r2("body"))) : u2.push(s2), u2;
          }
          case "TSConditionalType":
            return Vt2(e2, t2, r2);
          case "TSInferType":
            return tn3(e2, t2, r2);
          case "TSIntersectionType":
            return zr2(e2, t2, r2);
          case "TSUnionType":
            return Qr2(e2, t2, r2);
          case "TSFunctionType":
          case "TSCallSignatureDeclaration":
          case "TSConstructorType":
          case "TSConstructSignatureDeclaration":
            return Zr2(e2, t2, r2);
          case "TSTupleType":
            return Yt2(e2, t2, r2);
          case "TSTypeReference":
            return [r2("typeName"), Pt2(e2, t2, r2, n2.typeArguments ? "typeArguments" : "typeParameters")];
          case "TSTypeAnnotation":
            return sn2(e2, t2, r2);
          case "TSEmptyBodyFunctionExpression":
            return fn3(e2, t2, r2);
          case "TSJSDocAllType":
            return "*";
          case "TSJSDocUnknownType":
            return "?";
          case "TSJSDocNullableType":
            return ds(e2, r2, "?");
          case "TSJSDocNonNullableType":
            return ds(e2, r2, "!");
          case "TSParenthesizedType":
          default:
            throw new Me3(n2, "TypeScript");
        }
      }
      function zl(e2, t2, r2, n2) {
        if (Xr2(e2))
          return ci3(e2, t2);
        for (let s2 of [Ti2, Ei, Pa, ka2, Ca]) {
          let u2 = s2(e2, t2, r2, n2);
          if (u2 !== void 0)
            return u2;
        }
      }
      var Ql = v2(["ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "ClassPrivateProperty", "MethodDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod"]);
      function Zl(e2, t2, r2, n2) {
        var D;
        e2.isRoot && ((D = t2.__onHtmlBindingRoot) == null || D.call(t2, e2.node, t2));
        let s2 = zl(e2, t2, r2, n2);
        if (!s2)
          return "";
        let { node: u2 } = e2;
        if (Ql(u2))
          return s2;
        let i2 = w2(u2.decorators), a2 = xi(e2, t2, r2), o2 = u2.type === "ClassExpression";
        if (i2 && !o2)
          return ir3(s2, (y3) => l2([a2, y3]));
        let c2 = Be3(e2, t2), m = na(e2, t2);
        return !a2 && !c2 && !m ? s2 : ir3(s2, (y3) => [m ? ";" : "", c2 ? "(" : "", c2 && o2 && i2 ? [f2([x2, a2, y3]), x2] : [a2, y3], c2 ? ")" : ""]);
      }
      var Ia2 = Zl;
      var em = { avoidAstMutation: true };
      var La = [{ linguistLanguageId: 174, name: "JSON.stringify", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".importmap"], filenames: ["package.json", "package-lock.json", "composer.json"], parsers: ["json-stringify"], vscodeLanguageIds: ["json"] }, { linguistLanguageId: 174, name: "JSON", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".all-contributorsrc", ".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "flake.lock", "mcmod.info", ".babelrc", ".jscsrc", ".jshintrc", ".jslintrc", ".swcrc"], parsers: ["json"], vscodeLanguageIds: ["json"] }, { linguistLanguageId: 423, name: "JSON with Comments", type: "data", color: "#292929", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".code-snippets", ".code-workspace", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [], parsers: ["jsonc"], vscodeLanguageIds: ["jsonc"] }, { linguistLanguageId: 175, name: "JSON5", type: "data", color: "#267CB9", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", parsers: ["json5"], vscodeLanguageIds: ["json5"] }];
      var _s2 = {};
      Ar3(_s2, { getVisitorKeys: () => Oa, massageAstNode: () => ja, print: () => nm });
      var tm = { JsonRoot: ["node"], ArrayExpression: ["elements"], ObjectExpression: ["properties"], ObjectProperty: ["key", "value"], UnaryExpression: ["argument"], NullLiteral: [], BooleanLiteral: [], StringLiteral: [], NumericLiteral: [], Identifier: [], TemplateLiteral: ["quasis"], TemplateElement: [] }, wa2 = tm;
      var rm = hr2(wa2), Oa = rm;
      function nm(e2, t2, r2) {
        let { node: n2 } = e2;
        switch (n2.type) {
          case "JsonRoot":
            return [r2("node"), F];
          case "ArrayExpression": {
            if (n2.elements.length === 0)
              return "[]";
            let s2 = e2.map(() => e2.node === null ? "null" : r2(), "elements");
            return ["[", f2([F, P2([",", F], s2)]), F, "]"];
          }
          case "ObjectExpression":
            return n2.properties.length === 0 ? "{}" : ["{", f2([F, P2([",", F], e2.map(r2, "properties"))]), F, "}"];
          case "ObjectProperty":
            return [r2("key"), ": ", r2("value")];
          case "UnaryExpression":
            return [n2.operator === "+" ? "" : n2.operator, r2("argument")];
          case "NullLiteral":
            return "null";
          case "BooleanLiteral":
            return n2.value ? "true" : "false";
          case "StringLiteral":
            return JSON.stringify(n2.value);
          case "NumericLiteral":
            return _a(e2) ? JSON.stringify(String(n2.value)) : JSON.stringify(n2.value);
          case "Identifier":
            return _a(e2) ? JSON.stringify(n2.name) : n2.name;
          case "TemplateLiteral":
            return r2(["quasis", 0]);
          case "TemplateElement":
            return JSON.stringify(n2.value.cooked);
          default:
            throw new Me3(n2, "JSON");
        }
      }
      function _a(e2) {
        return e2.key === "key" && e2.parent.type === "ObjectProperty";
      }
      var sm = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
      function ja(e2, t2) {
        let { type: r2 } = e2;
        if (r2 === "ObjectProperty") {
          let { key: n2 } = e2;
          n2.type === "Identifier" ? t2.key = { type: "StringLiteral", value: n2.name } : n2.type === "NumericLiteral" && (t2.key = { type: "StringLiteral", value: String(n2.value) });
          return;
        }
        if (r2 === "UnaryExpression" && e2.operator === "+")
          return t2.argument;
        if (r2 === "ArrayExpression") {
          for (let [n2, s2] of e2.elements.entries())
            s2 === null && t2.elements.splice(n2, 0, { type: "NullLiteral" });
          return;
        }
        if (r2 === "TemplateLiteral")
          return { type: "StringLiteral", value: e2.quasis[0].value.cooked };
      }
      ja.ignoredProperties = sm;
      var Er2 = { bracketSpacing: { category: "Common", type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { category: "Common", type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { category: "Common", type: "choice", default: "preserve", description: "How to wrap prose.", choices: [{ value: "always", description: "Wrap prose if it exceeds the print width." }, { value: "never", description: "Do not wrap prose." }, { value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { category: "Common", type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { category: "Common", type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
      var kt3 = "JavaScript", um = { arrowParens: { category: kt3, type: "choice", default: "always", description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: Er2.bracketSameLine, bracketSpacing: Er2.bracketSpacing, jsxBracketSameLine: { category: kt3, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { category: kt3, type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, experimentalTernaries: { category: kt3, type: "boolean", default: false, description: "Use curious ternaries, with the question mark after the condition.", oppositeDescription: "Default behavior of ternaries; keep question marks on the same line as the consequent." }, singleQuote: Er2.singleQuote, jsxSingleQuote: { category: kt3, type: "boolean", default: false, description: "Use single quotes in JSX." }, quoteProps: { category: kt3, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { category: kt3, type: "choice", default: "all", description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "all", description: "Trailing commas wherever possible (including function arguments)." }, { value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }] }, singleAttributePerLine: Er2.singleAttributePerLine }, va2 = um;
      var im = { estree: Os2, "estree-json": _s2 }, am = [...Us2, ...La];
      return Xa(om);
    });
  }
});

// node_modules/@react-three/uikit/dist/font.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);

// node_modules/@pmndrs/uikit/dist/properties/alias.js
var borderAliases = {
  borderWidth: ["borderBottomWidth", "borderTopWidth", "borderLeftWidth", "borderRightWidth"],
  borderXWidth: ["borderLeftWidth", "borderRightWidth"],
  borderYWidth: ["borderTopWidth", "borderBottomWidth"]
};
var flexAliases = {
  ...borderAliases,
  inset: ["positionTop", "positionLeft", "positionRight", "positionBottom"],
  padding: ["paddingBottom", "paddingTop", "paddingLeft", "paddingRight"],
  paddingX: ["paddingLeft", "paddingRight"],
  paddingY: ["paddingTop", "paddingBottom"],
  margin: ["marginBottom", "marginTop", "marginLeft", "marginRight"],
  marginX: ["marginLeft", "marginRight"],
  marginY: ["marginTop", "marginBottom"],
  gap: ["gapRow", "gapColumn"]
};
var panelAliases = {
  borderRadius: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"],
  borderTopRadius: ["borderTopLeftRadius", "borderTopRightRadius"],
  borderLeftRadius: ["borderTopLeftRadius", "borderBottomLeftRadius"],
  borderRightRadius: ["borderTopRightRadius", "borderBottomRightRadius"],
  borderBottomRadius: ["borderBottomLeftRadius", "borderBottomRightRadius"]
};
var scrollbarAliases = {
  scrollbarBorderRadius: [
    "scrollbarBorderTopLeftRadius",
    "scrollbarBorderTopRightRadius",
    "scrollbarBorderBottomLeftRadius",
    "scrollbarBorderBottomRightRadius"
  ],
  scrollbarBorderTopRadius: ["scrollbarBorderTopLeftRadius", "scrollbarBorderTopRightRadius"],
  scrollbarBorderLeftRadius: ["scrollbarBorderTopLeftRadius", "scrollbarBorderBottomLeftRadius"],
  scrollbarBorderRightRadius: ["scrollbarBorderTopRightRadius", "scrollbarBorderBottomRightRadius"],
  scrollbarBorderBottomRadius: ["scrollbarBorderBottomLeftRadius", "scrollbarBorderBottomRightRadius"],
  scrollbarBorderWidth: [
    "scrollbarBorderBottomWidth",
    "scrollbarBorderTopWidth",
    "scrollbarBorderLeftWidth",
    "scrollbarBorderRightWidth"
  ],
  scrollbarBorderXWidth: ["scrollbarBorderLeftWidth", "scrollbarBorderRightWidth"],
  scrollbarBorderYWidth: ["scrollbarBorderTopWidth", "scrollbarBorderBottomWidth"]
};
var caretAliases = {
  caretBorderRadius: [
    "caretBorderTopLeftRadius",
    "caretBorderTopRightRadius",
    "caretBorderBottomLeftRadius",
    "caretBorderBottomRightRadius"
  ],
  caretBorderTopRadius: ["caretBorderTopLeftRadius", "caretBorderTopRightRadius"],
  caretBorderLeftRadius: ["caretBorderTopLeftRadius", "caretBorderBottomLeftRadius"],
  caretBorderRightRadius: ["caretBorderTopRightRadius", "caretBorderBottomRightRadius"],
  caretBorderBottomRadius: ["caretBorderBottomLeftRadius", "caretBorderBottomRightRadius"],
  caretBorderWidth: ["caretBorderBottomWidth", "caretBorderTopWidth", "caretBorderLeftWidth", "caretBorderRightWidth"],
  caretBorderXWidth: ["caretBorderLeftWidth", "caretBorderRightWidth"],
  caretBorderYWidth: ["caretBorderTopWidth", "caretBorderBottomWidth"]
};
var selectionAliases = {
  selectionBorderRadius: [
    "selectionBorderTopLeftRadius",
    "selectionBorderTopRightRadius",
    "selectionBorderBottomLeftRadius",
    "selectionBorderBottomRightRadius"
  ],
  selectionBorderTopRadius: ["selectionBorderTopLeftRadius", "selectionBorderTopRightRadius"],
  selectionBorderLeftRadius: ["selectionBorderTopLeftRadius", "selectionBorderBottomLeftRadius"],
  selectionBorderRightRadius: ["selectionBorderTopRightRadius", "selectionBorderBottomRightRadius"],
  selectionBorderBottomRadius: ["selectionBorderBottomLeftRadius", "selectionBorderBottomRightRadius"],
  selectionBorderWidth: [
    "selectionBorderBottomWidth",
    "selectionBorderTopWidth",
    "selectionBorderLeftWidth",
    "selectionBorderRightWidth"
  ],
  selectionBorderXWidth: ["selectionBorderLeftWidth", "selectionBorderRightWidth"],
  selectionBorderYWidth: ["selectionBorderTopWidth", "selectionBorderBottomWidth"]
};
var transformAliases = {
  transformScale: ["transformScaleX", "transformScaleY", "transformScaleZ"]
};
var allAliases = Object.assign({}, flexAliases, panelAliases, scrollbarAliases, transformAliases, caretAliases, selectionAliases);

// node_modules/@preact/signals-core/dist/signals-core.module.js
var i = Symbol.for("preact-signals");
function t() {
  if (!(s > 1)) {
    var i2, t2 = false;
    while (void 0 !== h) {
      var r2 = h;
      h = void 0;
      f++;
      while (void 0 !== r2) {
        var o2 = r2.o;
        r2.o = void 0;
        r2.f &= -3;
        if (!(8 & r2.f) && c(r2))
          try {
            r2.c();
          } catch (r3) {
            if (!t2) {
              i2 = r3;
              t2 = true;
            }
          }
        r2 = o2;
      }
    }
    f = 0;
    s--;
    if (t2)
      throw i2;
  } else
    s--;
}
function r(i2) {
  if (s > 0)
    return i2();
  s++;
  try {
    return i2();
  } finally {
    t();
  }
}
var o = void 0;
function n(i2) {
  var t2 = o;
  o = void 0;
  try {
    return i2();
  } finally {
    o = t2;
  }
}
var h = void 0;
var s = 0;
var f = 0;
var v = 0;
function e(i2) {
  if (void 0 !== o) {
    var t2 = i2.n;
    if (void 0 === t2 || t2.t !== o) {
      t2 = { i: 0, S: i2, p: o.s, n: void 0, t: o, e: void 0, x: void 0, r: t2 };
      if (void 0 !== o.s)
        o.s.n = t2;
      o.s = t2;
      i2.n = t2;
      if (32 & o.f)
        i2.S(t2);
      return t2;
    } else if (-1 === t2.i) {
      t2.i = 0;
      if (void 0 !== t2.n) {
        t2.n.p = t2.p;
        if (void 0 !== t2.p)
          t2.p.n = t2.n;
        t2.p = o.s;
        t2.n = void 0;
        o.s.n = t2;
        o.s = t2;
      }
      return t2;
    }
  }
}
function u(i2) {
  this.v = i2;
  this.i = 0;
  this.n = void 0;
  this.t = void 0;
}
u.prototype.brand = i;
u.prototype.h = function() {
  return true;
};
u.prototype.S = function(i2) {
  if (this.t !== i2 && void 0 === i2.e) {
    i2.x = this.t;
    if (void 0 !== this.t)
      this.t.e = i2;
    this.t = i2;
  }
};
u.prototype.U = function(i2) {
  if (void 0 !== this.t) {
    var t2 = i2.e, r2 = i2.x;
    if (void 0 !== t2) {
      t2.x = r2;
      i2.e = void 0;
    }
    if (void 0 !== r2) {
      r2.e = t2;
      i2.x = void 0;
    }
    if (i2 === this.t)
      this.t = r2;
  }
};
u.prototype.subscribe = function(i2) {
  var t2 = this;
  return E(function() {
    var r2 = t2.value, n2 = o;
    o = void 0;
    try {
      i2(r2);
    } finally {
      o = n2;
    }
  });
};
u.prototype.valueOf = function() {
  return this.value;
};
u.prototype.toString = function() {
  return this.value + "";
};
u.prototype.toJSON = function() {
  return this.value;
};
u.prototype.peek = function() {
  var i2 = o;
  o = void 0;
  try {
    return this.value;
  } finally {
    o = i2;
  }
};
Object.defineProperty(u.prototype, "value", { get: function() {
  var i2 = e(this);
  if (void 0 !== i2)
    i2.i = this.i;
  return this.v;
}, set: function(i2) {
  if (i2 !== this.v) {
    if (f > 100)
      throw new Error("Cycle detected");
    this.v = i2;
    this.i++;
    v++;
    s++;
    try {
      for (var r2 = this.t; void 0 !== r2; r2 = r2.x)
        r2.t.N();
    } finally {
      t();
    }
  }
} });
function d(i2) {
  return new u(i2);
}
function c(i2) {
  for (var t2 = i2.s; void 0 !== t2; t2 = t2.n)
    if (t2.S.i !== t2.i || !t2.S.h() || t2.S.i !== t2.i)
      return true;
  return false;
}
function a(i2) {
  for (var t2 = i2.s; void 0 !== t2; t2 = t2.n) {
    var r2 = t2.S.n;
    if (void 0 !== r2)
      t2.r = r2;
    t2.S.n = t2;
    t2.i = -1;
    if (void 0 === t2.n) {
      i2.s = t2;
      break;
    }
  }
}
function l(i2) {
  var t2 = i2.s, r2 = void 0;
  while (void 0 !== t2) {
    var o2 = t2.p;
    if (-1 === t2.i) {
      t2.S.U(t2);
      if (void 0 !== o2)
        o2.n = t2.n;
      if (void 0 !== t2.n)
        t2.n.p = o2;
    } else
      r2 = t2;
    t2.S.n = t2.r;
    if (void 0 !== t2.r)
      t2.r = void 0;
    t2 = o2;
  }
  i2.s = r2;
}
function y(i2) {
  u.call(this, void 0);
  this.x = i2;
  this.s = void 0;
  this.g = v - 1;
  this.f = 4;
}
(y.prototype = new u()).h = function() {
  this.f &= -3;
  if (1 & this.f)
    return false;
  if (32 == (36 & this.f))
    return true;
  this.f &= -5;
  if (this.g === v)
    return true;
  this.g = v;
  this.f |= 1;
  if (this.i > 0 && !c(this)) {
    this.f &= -2;
    return true;
  }
  var i2 = o;
  try {
    a(this);
    o = this;
    var t2 = this.x();
    if (16 & this.f || this.v !== t2 || 0 === this.i) {
      this.v = t2;
      this.f &= -17;
      this.i++;
    }
  } catch (i3) {
    this.v = i3;
    this.f |= 16;
    this.i++;
  }
  o = i2;
  l(this);
  this.f &= -2;
  return true;
};
y.prototype.S = function(i2) {
  if (void 0 === this.t) {
    this.f |= 36;
    for (var t2 = this.s; void 0 !== t2; t2 = t2.n)
      t2.S.S(t2);
  }
  u.prototype.S.call(this, i2);
};
y.prototype.U = function(i2) {
  if (void 0 !== this.t) {
    u.prototype.U.call(this, i2);
    if (void 0 === this.t) {
      this.f &= -33;
      for (var t2 = this.s; void 0 !== t2; t2 = t2.n)
        t2.S.U(t2);
    }
  }
};
y.prototype.N = function() {
  if (!(2 & this.f)) {
    this.f |= 6;
    for (var i2 = this.t; void 0 !== i2; i2 = i2.x)
      i2.t.N();
  }
};
Object.defineProperty(y.prototype, "value", { get: function() {
  if (1 & this.f)
    throw new Error("Cycle detected");
  var i2 = e(this);
  this.h();
  if (void 0 !== i2)
    i2.i = this.i;
  if (16 & this.f)
    throw this.v;
  return this.v;
} });
function w(i2) {
  return new y(i2);
}
function _(i2) {
  var r2 = i2.u;
  i2.u = void 0;
  if ("function" == typeof r2) {
    s++;
    var n2 = o;
    o = void 0;
    try {
      r2();
    } catch (t2) {
      i2.f &= -2;
      i2.f |= 8;
      g(i2);
      throw t2;
    } finally {
      o = n2;
      t();
    }
  }
}
function g(i2) {
  for (var t2 = i2.s; void 0 !== t2; t2 = t2.n)
    t2.S.U(t2);
  i2.x = void 0;
  i2.s = void 0;
  _(i2);
}
function p(i2) {
  if (o !== this)
    throw new Error("Out-of-order effect");
  l(this);
  o = i2;
  this.f &= -2;
  if (8 & this.f)
    g(this);
  t();
}
function b(i2) {
  this.x = i2;
  this.u = void 0;
  this.s = void 0;
  this.o = void 0;
  this.f = 32;
}
b.prototype.c = function() {
  var i2 = this.S();
  try {
    if (8 & this.f)
      return;
    if (void 0 === this.x)
      return;
    var t2 = this.x();
    if ("function" == typeof t2)
      this.u = t2;
  } finally {
    i2();
  }
};
b.prototype.S = function() {
  if (1 & this.f)
    throw new Error("Cycle detected");
  this.f |= 1;
  this.f &= -9;
  _(this);
  a(this);
  s++;
  var i2 = o;
  o = this;
  return p.bind(this, i2);
};
b.prototype.N = function() {
  if (!(2 & this.f)) {
    this.f |= 2;
    this.o = h;
    h = this;
  }
};
b.prototype.d = function() {
  this.f |= 8;
  if (!(1 & this.f))
    g(this);
};
function E(i2) {
  var t2 = new b(i2);
  try {
    t2.c();
  } catch (i3) {
    t2.d();
    throw i3;
  }
  return t2.d.bind(t2);
}

// node_modules/@pmndrs/uikit/dist/utils.js
var percentageRegex = /(-?\d+(?:\.\d+)?)%/;
function unsubscribeSubscriptions(subscriptions) {
  const length = subscriptions.length;
  for (let i2 = 0; i2 < length; i2++) {
    subscriptions[i2]();
  }
  subscriptions.length = 0;
}
function initialize(inits, subscriptions) {
  const length = inits.length;
  for (let i2 = 0; i2 < length; i2++) {
    const unsubscribe = inits[i2](subscriptions);
    if (Array.isArray(unsubscribe)) {
      continue;
    }
    subscriptions.push(unsubscribe);
  }
}
var alignmentXMap = { left: 0.5, center: 0, middle: 0, right: -0.5 };
var alignmentYMap = { top: -0.5, center: 0, middle: 0, bottom: 0.5 };
var alignmentZMap = { back: -0.5, center: 0, middle: 0, front: 0.5 };
function fitNormalizedContentInside(offsetTarget, scaleTarget, size, paddingInset, borderInset, pixelSize, aspectRatio) {
  if (size.value == null || paddingInset.value == null || borderInset.value == null) {
    return;
  }
  const [width, height] = size.value;
  const [pTop, pRight, pBottom, pLeft] = paddingInset.value;
  const [bTop, bRight, bBottom, bLeft] = borderInset.value;
  const topInset = pTop + bTop;
  const rightInset = pRight + bRight;
  const bottomInset = pBottom + bBottom;
  const leftInset = pLeft + bLeft;
  offsetTarget.set((leftInset - rightInset) * 0.5 * pixelSize, (bottomInset - topInset) * 0.5 * pixelSize, 0);
  const innerWidth = width - leftInset - rightInset;
  const innerHeight = height - topInset - bottomInset;
  const flexRatio = innerWidth / innerHeight;
  if (flexRatio > aspectRatio) {
    scaleTarget.setScalar(innerHeight * pixelSize);
    return;
  }
  scaleTarget.setScalar(innerWidth * pixelSize / aspectRatio);
}
function readReactive(value) {
  return value instanceof u ? value.value : value;
}
function createConditionalPropertyTranslator(condition) {
  const signalMap2 = /* @__PURE__ */ new Map();
  return (properties, merged) => {
    if (typeof properties != "object") {
      throw new Error(`Invalid properties "${properties}"`);
    }
    for (const key in properties) {
      const value = properties[key];
      if (value === void 0) {
        return;
      }
      let result = signalMap2.get(value);
      if (result == null) {
        signalMap2.set(value, result = w(() => condition() ? readReactive(value) : void 0));
      }
      merged.add(key, result);
    }
  };
}
function computedBorderInset(propertiesSignal, keys) {
  const sizes = keys.map((key) => computedInheritableProperty(propertiesSignal, key, 0));
  return w(() => sizes.map((size) => size.value));
}

// node_modules/@pmndrs/uikit/dist/properties/utils.js
function computedInheritableProperty(propertiesSignal, key, defaultValue) {
  return w(() => propertiesSignal.value.read(key, defaultValue));
}
function computedNonInheritableProperty(style, properties, key, defaultValue) {
  return w(() => {
    var _a, _b;
    return readReactive((_a = style.value) == null ? void 0 : _a[key]) ?? readReactive((_b = properties.value) == null ? void 0 : _b[key]) ?? defaultValue;
  });
}

// node_modules/@pmndrs/uikit/dist/properties/default.js
function traverseProperties(style, properties, defaultProperties, fn3) {
  if (defaultProperties != null) {
    traverseClasses(defaultProperties.classes, fn3);
    fn3(defaultProperties);
  }
  if (properties != null) {
    traverseClasses(properties.classes, fn3);
    fn3(properties);
  }
  if (style != null) {
    traverseClasses(style.classes, fn3);
    fn3(style);
  }
}
function traverseClasses(classes, fn3) {
  if (classes == null) {
    return;
  }
  if (!Array.isArray(classes)) {
    fn3(classes);
    return;
  }
  const classesLength = classes.length;
  for (let i2 = 0; i2 < classesLength; i2++) {
    fn3(classes[i2]);
  }
  return;
}

// node_modules/@pmndrs/uikit/dist/properties/immediate.js
function setupImmediateProperties(propertiesSignal, activeSignal, hasProperty, setProperty, subscriptions) {
  let active = false;
  let currentProperties;
  let propertySubscriptions = {};
  subscriptions.push(E(() => {
    const newProperties = propertiesSignal.value;
    if (active) {
      applyProperties(hasProperty, newProperties, currentProperties, propertySubscriptions, setProperty);
    }
    currentProperties = newProperties;
  }), E(() => {
    active = activeSignal.value;
    if (!active) {
      return;
    }
    if (currentProperties == null) {
      return;
    }
    applyProperties(hasProperty, currentProperties, void 0, propertySubscriptions, setProperty);
    return () => {
      unsubscribeProperties(propertySubscriptions);
      propertySubscriptions = {};
    };
  }));
}
function applyProperties(hasProperty, currentProperties, oldProperties, subscriptions, setProperty) {
  const onNew = (key) => (
    //subscribe and write property
    subscriptions[key] = E(() => setProperty(key, currentProperties.read(key, void 0)))
  );
  const onDelete = (key) => {
    var _a;
    (_a = subscriptions[key]) == null ? void 0 : _a.call(subscriptions);
    delete subscriptions[key];
    if (oldProperties.read(key, void 0) === void 0) {
      return;
    }
    setProperty(key, void 0);
  };
  const onChange = (key) => {
    var _a;
    (_a = subscriptions[key]) == null ? void 0 : _a.call(subscriptions);
    onNew(key);
  };
  n(() => currentProperties.filterCompare(hasProperty, oldProperties, onNew, onChange, onDelete));
}
function unsubscribeProperties(subscriptions) {
  for (const key in subscriptions) {
    subscriptions[key]();
  }
}

// node_modules/@pmndrs/uikit/dist/properties/merged.js
var MergedProperties = class {
  constructor(preTransformers) {
    __publicField(this, "preTransformers");
    __publicField(this, "propertyMap", /* @__PURE__ */ new Map());
    this.preTransformers = preTransformers;
  }
  add(key, value) {
    var _a;
    if (value === void 0) {
      return;
    }
    const transform = (_a = this.preTransformers) == null ? void 0 : _a[key];
    if (transform != null) {
      transform(value, this);
      return;
    }
    const aliases = allAliases[key];
    if (aliases == null) {
      this.addToMap(key, value);
      return;
    }
    const length = aliases.length;
    for (let i2 = 0; i2 < length; i2++) {
      this.addToMap(aliases[i2], value);
    }
  }
  addToMap(key, value) {
    let entry = this.propertyMap.get(key);
    if (entry == null) {
      this.propertyMap.set(key, entry = []);
    }
    if (!(value instanceof u)) {
      entry.length = 0;
    }
    entry.push(value);
  }
  /**
   * @returns undefined if the property doesn't exist
   */
  read(key, defaultValue) {
    const entry = this.propertyMap.get(key);
    if (entry == null) {
      return defaultValue;
    }
    const length = entry.length;
    for (let i2 = length - 1; i2 >= 0; i2--) {
      const value = entry[i2];
      const result = value instanceof u ? value.value : value;
      if (result === void 0) {
        continue;
      }
      return result;
    }
    return defaultValue;
  }
  filterCompare(filter, old, onNew, onChange, onDelete) {
    for (const key of this.propertyMap.keys()) {
      if (!filter(key)) {
        continue;
      }
      if (old == null) {
        onNew(key);
        continue;
      }
      const oldEntry = old.propertyMap.get(key);
      if (oldEntry == null) {
        onNew(key);
        continue;
      }
      const thisEntry = this.propertyMap.get(key);
      if (shallodwEqual(oldEntry, thisEntry)) {
        continue;
      }
      onChange(key);
    }
    if (old == null) {
      return;
    }
    for (const key of old.propertyMap.keys()) {
      if (!filter(key)) {
        continue;
      }
      if (this.propertyMap.has(key)) {
        continue;
      }
      onDelete(key);
    }
  }
  isEqual(otherMap, key) {
    const entry1 = this.propertyMap.get(key);
    const entry2 = otherMap.propertyMap.get(key);
    if (entry1 == null || entry2 == null) {
      return entry1 === entry2;
    }
    return shallodwEqual(entry1, entry2);
  }
  addAll(style, properties, defaultProperties, postTransformers) {
    traverseProperties(style, properties, defaultProperties, (p2) => {
      for (const key in p2) {
        this.add(key, p2[key]);
      }
      for (const key in postTransformers) {
        const property = p2[key];
        if (property == null) {
          continue;
        }
        postTransformers[key](property, this);
      }
    });
  }
};
function shallodwEqual(a1, a2) {
  const length = a1.length;
  if (length != a2.length) {
    return false;
  }
  for (let i2 = 0; i2 < length; i2++) {
    if (a1[i2] != a2[i2]) {
      return false;
    }
  }
  return true;
}

// node_modules/@pmndrs/uikit/dist/order.js
var cameraDistanceKey = Symbol("camera-distance-key");
var orderInfoKey = Symbol("order-info-key");
function reversePainterSortStable(a2, b3) {
  if (a2.groupOrder !== b3.groupOrder) {
    return a2.groupOrder - b3.groupOrder;
  }
  if (a2.renderOrder !== b3.renderOrder) {
    return a2.renderOrder - b3.renderOrder;
  }
  const aDistanceRef = a2.object[cameraDistanceKey];
  const bDistanceRef = b3.object[cameraDistanceKey];
  if (aDistanceRef == null || bDistanceRef == null) {
    return a2.z !== b3.z ? b3.z - a2.z : a2.id - b3.id;
  }
  if (aDistanceRef === bDistanceRef) {
    return compareOrderInfo(a2.object[orderInfoKey].value, b3.object[orderInfoKey].value);
  }
  return bDistanceRef.cameraDistance - aDistanceRef.cameraDistance;
}
var ElementType = {
  Panel: 0,
  //render first
  Image: 1,
  Object: 2,
  Custom: 3,
  Svg: 4,
  Text: 5
  //render last
};
function compareOrderInfo(o1, o2) {
  if (o1 == null || o2 == null) {
    return 0;
  }
  let dif = o1.majorIndex - o2.majorIndex;
  if (dif != 0) {
    return dif;
  }
  dif = o1.elementType - o2.elementType;
  if (dif != 0) {
    return dif;
  }
  return o1.minorIndex - o2.minorIndex;
}
function computedOrderInfo(propertiesSignal, type, instancedGroupDependencies, parentOrderInfoSignal) {
  const zIndexOffset = propertiesSignal == null ? void 0 : computedInheritableProperty(propertiesSignal, "zIndexOffset", void 0);
  return w(() => {
    let parentOrderInfo;
    if (parentOrderInfoSignal == null) {
      parentOrderInfo = void 0;
    } else if (parentOrderInfoSignal.value == null) {
      return void 0;
    } else {
      parentOrderInfo = parentOrderInfoSignal.value;
    }
    const offset = zIndexOffset == null ? void 0 : zIndexOffset.value;
    const majorOffset = typeof offset === "number" ? offset : (offset == null ? void 0 : offset.major) ?? 0;
    const minorOffset = typeof offset === "number" ? 0 : (offset == null ? void 0 : offset.minor) ?? 0;
    let majorIndex;
    let minorIndex;
    if (parentOrderInfo == null) {
      majorIndex = 0;
      minorIndex = 0;
    } else if (type > parentOrderInfo.elementType) {
      majorIndex = parentOrderInfo.majorIndex;
      minorIndex = 0;
    } else if (type != parentOrderInfo.elementType || !shallowEqualRecord(readReactive(instancedGroupDependencies), readReactive(parentOrderInfo.instancedGroupDependencies))) {
      majorIndex = parentOrderInfo.majorIndex + 1;
      minorIndex = 0;
    } else {
      majorIndex = parentOrderInfo.majorIndex;
      minorIndex = parentOrderInfo.minorIndex + 1;
    }
    if (majorOffset > 0) {
      majorIndex += majorOffset;
      minorIndex = 0;
    }
    minorIndex += minorOffset;
    return {
      instancedGroupDependencies,
      elementType: type,
      majorIndex,
      minorIndex
    };
  });
}
function shallowEqualRecord(r1, r2) {
  if (r1 === r2) {
    return true;
  }
  if (r1 == null || r2 == null) {
    return false;
  }
  let i2 = 0;
  for (const key in r1) {
    if (r1[key] != r2[key]) {
      return false;
    }
    ++i2;
  }
  return i2 === Object.keys(r2).length;
}
function setupRenderOrder(result, rootCameraDistance, orderInfo) {
  ;
  result[cameraDistanceKey] = rootCameraDistance;
  result[orderInfoKey] = orderInfo;
  return result;
}

// node_modules/@pmndrs/uikit/dist/listeners.js
function setupLayoutListeners(l1, l2, size, initializers) {
  initializers.push(() => E(() => {
    var _a, _b, _c, _d;
    const s2 = size.value;
    if (s2 == null) {
      return;
    }
    (_b = (_a = l1.peek()) == null ? void 0 : _a.onSizeChange) == null ? void 0 : _b.call(_a, ...s2);
    (_d = (_c = l2.peek()) == null ? void 0 : _c.onSizeChange) == null ? void 0 : _d.call(_c, ...s2);
  }));
}
function setupClippedListeners(l1, l2, isClippedSignal, initializers) {
  let first = true;
  initializers.push(() => E(() => {
    var _a, _b, _c, _d;
    const isClipped = isClippedSignal.value;
    if (first) {
      first = false;
      return;
    }
    (_b = (_a = l1.peek()) == null ? void 0 : _a.onIsClippedChange) == null ? void 0 : _b.call(_a, isClipped);
    (_d = (_c = l2.peek()) == null ? void 0 : _c.onIsClippedChange) == null ? void 0 : _d.call(_c, isClipped);
  }));
}

// node_modules/@pmndrs/uikit/dist/transform.js
var tHelper = new Vector3();
var sHelper = new Vector3();
var originVector = new Vector3();
var matrixHelper = new Matrix4();
var eulerHelper = new Euler();
var quaternionHelper = new Quaternion();
var toRad = Math.PI / 180;
function toQuaternion([x2, y3, z3]) {
  return quaternionHelper.setFromEuler(eulerHelper.set(x2 * toRad, y3 * toRad, z3 * toRad));
}
var defaultTransformOriginX = "center";
var defaultTransformOriginY = "center";
function computedTransformMatrix(propertiesSignal, { relativeCenter, size }, pixelSizeSignal) {
  const tTX = computedInheritableProperty(propertiesSignal, "transformTranslateX", 0);
  const tTY = computedInheritableProperty(propertiesSignal, "transformTranslateY", 0);
  const tTZ = computedInheritableProperty(propertiesSignal, "transformTranslateZ", 0);
  const tRX = computedInheritableProperty(propertiesSignal, "transformRotateX", 0);
  const tRY = computedInheritableProperty(propertiesSignal, "transformRotateY", 0);
  const tRZ = computedInheritableProperty(propertiesSignal, "transformRotateZ", 0);
  const tSX = computedInheritableProperty(propertiesSignal, "transformScaleX", 1);
  const tSY = computedInheritableProperty(propertiesSignal, "transformScaleY", 1);
  const tSZ = computedInheritableProperty(propertiesSignal, "transformScaleZ", 1);
  const tOX = computedInheritableProperty(propertiesSignal, "transformOriginX", defaultTransformOriginX);
  const tOY = computedInheritableProperty(propertiesSignal, "transformOriginY", defaultTransformOriginY);
  return w(() => {
    if (relativeCenter.value == null) {
      return void 0;
    }
    const [x2, y3] = relativeCenter.value;
    const pixelSize = pixelSizeSignal.value;
    const result = new Matrix4().makeTranslation(x2 * pixelSize, y3 * pixelSize, 0);
    let originCenter = true;
    if (tOX.value != "center" || tOY.value != "center") {
      if (size.value == null) {
        return void 0;
      }
      const [width, height] = size.value;
      originCenter = false;
      originVector.set(-alignmentXMap[tOX.value] * width * pixelSize, -alignmentYMap[tOY.value] * height * pixelSize, 0);
      result.multiply(matrixHelper.makeTranslation(originVector));
      originVector.negate();
    }
    const r2 = [tRX.value, tRY.value, tRZ.value];
    const t2 = [translateToNumber(tTX.value, size, 0), -translateToNumber(tTY.value, size, 1), tTZ.value];
    const s2 = [scaleToNumber(tSX.value), scaleToNumber(tSY.value), scaleToNumber(tSZ.value)];
    if (t2.some((v2) => v2 != 0) || r2.some((v2) => v2 != 0) || s2.some((v2) => v2 != 1)) {
      result.multiply(matrixHelper.compose(tHelper.fromArray(t2).multiplyScalar(pixelSize), toQuaternion(r2), sHelper.fromArray(s2)));
    }
    if (!originCenter) {
      result.multiply(matrixHelper.makeTranslation(originVector));
    }
    return result;
  });
}
function scaleToNumber(scale) {
  if (typeof scale === "number") {
    return scale;
  }
  const result = percentageRegex.exec(scale);
  if (result == null) {
    throw new Error(`invalid value "${scale}", expected number of percentage`);
  }
  return parseFloat(result[1]) / 100;
}
function translateToNumber(translate, size, sizeIndex) {
  var _a;
  if (typeof translate === "number") {
    return translate;
  }
  const result = percentageRegex.exec(translate);
  if (result == null) {
    throw new Error(`invalid value "${translate}", expected number of percentage`);
  }
  const sizeOnAxis = ((_a = size.value) == null ? void 0 : _a[sizeIndex]) ?? 0;
  return sizeOnAxis * parseFloat(result[1]) / 100;
}
function applyTransform(root, object, transformMatrix, initializers) {
  initializers.push(() => E(() => {
    var _a, _b;
    if (transformMatrix.value == null) {
      (_a = object.current) == null ? void 0 : _a.matrix.elements.fill(0);
      return;
    }
    (_b = object.current) == null ? void 0 : _b.matrix.copy(transformMatrix.value);
    root.requestRender();
  }));
}

// node_modules/yoga-layout/dist/binaries/yoga-wasm-base64-esm.js
var loadYoga = (() => {
  var _scriptDir = import.meta.url;
  return function(loadYoga3) {
    loadYoga3 = loadYoga3 || {};
    var h2;
    h2 || (h2 = typeof loadYoga3 !== "undefined" ? loadYoga3 : {});
    var aa2, ca2;
    h2.ready = new Promise(function(a2, b3) {
      aa2 = a2;
      ca2 = b3;
    });
    var da2 = Object.assign({}, h2), q2 = "";
    "undefined" != typeof document && document.currentScript && (q2 = document.currentScript.src);
    _scriptDir && (q2 = _scriptDir);
    0 !== q2.indexOf("blob:") ? q2 = q2.substr(0, q2.replace(/[?#].*/, "").lastIndexOf("/") + 1) : q2 = "";
    var ea = h2.print || console.log.bind(console), v2 = h2.printErr || console.warn.bind(console);
    Object.assign(h2, da2);
    da2 = null;
    var w2;
    h2.wasmBinary && (w2 = h2.wasmBinary);
    var noExitRuntime = h2.noExitRuntime || true;
    "object" != typeof WebAssembly && x2("no native wasm support detected");
    var fa2, ha2 = false;
    function z3(a2, b3, c2) {
      c2 = b3 + c2;
      for (var d2 = ""; !(b3 >= c2); ) {
        var e2 = a2[b3++];
        if (!e2)
          break;
        if (e2 & 128) {
          var f2 = a2[b3++] & 63;
          if (192 == (e2 & 224))
            d2 += String.fromCharCode((e2 & 31) << 6 | f2);
          else {
            var g2 = a2[b3++] & 63;
            e2 = 224 == (e2 & 240) ? (e2 & 15) << 12 | f2 << 6 | g2 : (e2 & 7) << 18 | f2 << 12 | g2 << 6 | a2[b3++] & 63;
            65536 > e2 ? d2 += String.fromCharCode(e2) : (e2 -= 65536, d2 += String.fromCharCode(55296 | e2 >> 10, 56320 | e2 & 1023));
          }
        } else
          d2 += String.fromCharCode(e2);
      }
      return d2;
    }
    var ia, ja, A, C, ka2, D, E2, la2, ma2;
    function na() {
      var a2 = fa2.buffer;
      ia = a2;
      h2.HEAP8 = ja = new Int8Array(a2);
      h2.HEAP16 = C = new Int16Array(a2);
      h2.HEAP32 = D = new Int32Array(a2);
      h2.HEAPU8 = A = new Uint8Array(a2);
      h2.HEAPU16 = ka2 = new Uint16Array(a2);
      h2.HEAPU32 = E2 = new Uint32Array(a2);
      h2.HEAPF32 = la2 = new Float32Array(a2);
      h2.HEAPF64 = ma2 = new Float64Array(a2);
    }
    var oa2, pa2 = [], qa = [], ra = [];
    function sa2() {
      var a2 = h2.preRun.shift();
      pa2.unshift(a2);
    }
    var F = 0, ta = null, G3 = null;
    function x2(a2) {
      if (h2.onAbort)
        h2.onAbort(a2);
      a2 = "Aborted(" + a2 + ")";
      v2(a2);
      ha2 = true;
      a2 = new WebAssembly.RuntimeError(a2 + ". Build with -sASSERTIONS for more info.");
      ca2(a2);
      throw a2;
    }
    function ua2(a2) {
      return a2.startsWith("data:application/octet-stream;base64,");
    }
    var H3;
    H3 = "data:application/octet-stream;base64,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KgIIIgcgAioCACIGXARAIAcgB1sEQCACLQAEIQIMAgsgBiAGXCEECyACLQAEIQIgBEUNACADLQAMIAJB/wFxRg0BCyAFIAEgBiACEDQDQCAALQAAIgFBBHENASAAIAFBBHI6AAAgACgCECIBBEAgACABEQAACyAAQYCAgP4HNgKcASAAKALcAyIADQALCyADQRBqJAALHAAgACABQQggAqcgAkIgiKcgA6cgA0IgiKcQFQsFABBQAAvOAQIDfwJ9IwBBEGsiAyQAQQEhBCADQQhqIABB/ABqIgUgACABQQF0akHEAGoiAS8BABAfAkACQCADKgIIIgcgAioCACIGXARAIAcgB1sEQCACLQAEIQIMAgsgBiAGXCEECyACLQAEIQIgBEUNACADLQAMIAJB/wFxRg0BCyAFIAEgBiACEDQDQCAALQAAIgFBBHENASAAIAFBBHI6AAAgACgCECIBBEAgACABEQAACyAAQYCAgP4HNgKcASAAKALcAyIADQALCyADQRBqJAALOQAgAEUEQEEADwsCfyABQYB/cUGAvwNGIAFB/wBNckUEQEHIO0EZNgIAQX8MAQsgACABOgAAQQELC8QCAAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAFBCWsOEgAKCwwKCwIDBAUMCwwMCgsHCAkLIAIgAigCACIBQQRqNgIAIAAgASgCADYCAA8LAAsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsACyACIAIoAgBBB2pBeHEiAUEIajYCACAAIAErAwA5AwAPCyAAIAIgAxECAAsPCyACIAIoAgAiAUEEajYCACAAIAE0AgA3AwAPCyACIAIoAgAiAUEEajYCACAAIAE1AgA3AwAPCyACIAIoAgBBB2pBeHEiAUEIajYCACAAIAEpAwA3AwALXQEEfyAAKAIAIQIDQCACLAAAIgMQTwRAQX8hBCAAIAJBAWoiAjYCACABQcyZs+YATQR/QX8gA0EwayIDIAFBCmwiBGogAyAEQf////8Hc0obBSAECyEBDAELCyABC6oUAhJ/AX4jAEHQAGsiCCQAIAggATYCTCAIQTdq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AkAgBkL///////////8AgyIEQoCAgICAgMCAPH0gBEKAgICAgIDA/8MAfVQEQCAGQgSGIANCPIiEIQQgA0L//////////w+DIgNCgYCAgICAgIAIWgRAIARCgYCAgICAgIDAAHwhAgwCCyAEQoCAgICAgICAQH0hAiADQoCAgICAgICACFINASACIARCAYN8IQIMAQsgA1AgBEKAgICAgIDA//8AVCAEQoCAgICAgMD//wBRG0UEQCAGQgSGIANCPIiEQv////////8Dg0KAgICAgICA/P8AhCECDAELQoCAgICAgID4/wAhAiAEQv///////7//wwBWDQBCACECIARCMIinIgBBkfcASQ0AIAMhAiAGQv///////z+DQoCAgICAgMAAhCIFIQcCQCAAQYH3AGsiAUHAAHEEQCACIAFBQGqthiEHQgAhAgwBCyABRQ0AIAcgAa0iBIYgAkHAACABa62IhCEHIAIgBIYhAgsgCCACNwMQIAggBzcDGAJAQYH4ACAAayIAQcAAcQRAIAUgAEFAaq2IIQNCACEFDAELIABFDQAgBUHAACAAa62GIAMgAK0iAoiEIQMgBSACiCEFCyAIIAM3AwAgCCAFNwMIIAgpAwhCBIYgCCkDACIDQjyIhCECIAgpAxAgCCkDGIRCAFKtIANC//////////8Pg4QiA0KBgICAgICAgAhaBEAgAkIBfCECDAELIANCgICAgICAgIAIUg0AIAJCAYMgAnwhAgsgCEEgaiQAIAkgAiAGQoCAgICAgICAgH+DhL85AwALmRgDEn8BfAN+IwBBsARrIgwkACAMQQA2AiwCQCABvSIZQgBTBEBBASERQZkJIRMgAZoiAb0hGQwBCyAEQYAQcQRAQQEhEUGcCSETDAELQZ8JQZoJIARBAXEiERshEyARRSEVCwJAIBlCgICAgICAgPj/AINCgICAgICAgPj/AFEEQCAAQSAgAiARQQNqIgMgBEH//3txECsgACATIBEQKSAAQd0VQbIeIAVBIHEiBRtBtxpBth4gBRsgASABYhtBAxApIABBICACIAMgBEGAwABzECsgAyACIAIgA0gbIQoMAQsgDEEQaiESAkACfwJAIAEgDEEsahCDASIBIAGgIgFEAAAAAAAAAABiBEAgDCAMKAIsIgZBAWs2AiwgBUEgciIOQeEARw0BDAMLIAVB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NwMIIAALDABBMBAeQQBBMBAwCzcBAX8gASAAKAIEIgNBAXVqIQEgACgCACEAIAEgAiADQQFxBH8gASgCACAAaigCAAUgAAsRGwALBQBBijsLIQAgACABKAIAIAEgASwAC0EASBtBhzsgAigCABAQNgIACyoBAX9BDBAeIgFBADoABCABIAAoAgA2AgggAEEANgIAIAFBqCc2AgAgAQsFAEGHOwsFAEGEOwshACAAIAEoAgAgASABLAALQQBIG0HwOiACKAIAEBA2AgAL2AEBBH8jAEEgayIDJAAgASgCACIEQfD///8HSQRAAkACQCAEQQtPBEAgBEEPckEBaiIFEB4hBiADIAVBgICAgHhyNgIQIAMgBjYCCCADIAQ2AgwgBCAGaiEFDAELIAMgBDoAEyADQQhqIgYgBGohBSAERQ0BCyAGIAFBBGogBBAsGgsgBUEAOgAAIAMgAjYCACADQRhqIANBCGogAyAAEQMAIAMoAhgQHSADKAIYIgAQBiADKAIAEAYgAywAE0EASARAIAMoAggQKAsgA0EgaiQAIAAPCxACAAsqAQF/QQwQHiIBQQA6AAQgASAAKAIANgIIIABBADYCACABQbAmNgIAIAELBQBB8DoLaQECfyMAQRBrIgYkACABIAAoAgQiB0EBdWohASAAKAIAIQAgBiABIAIgAyAEIAUgB0EBcQR/IAEoAgAgAGooAgAFIAALERAAQRAQHiIAIAYpAwg3AwggACAGKQMANwMAIAZBEGokACAACwUAQew6Cx0AIAAoAgAiACAALQAAQfcBcUEIQQAgARtyOgAAC6oBAgJ/AX0jAEEQayICJAAgACgCACEAIAFB/wFxIgNBBkkEQAJ/AkACQAJAIANBBGsOAgABAgsgAEHQA2ogAC0AhANBA3FBAkYNAhogAEHIA2oMAgsgAEHIA2ogAC0AhANBA3FBAkYNARogAEHQA2oMAQsgACABQf8BcUECdGpByANqCyoCACEEIAJBEGokACAEuw8LIAJB7hA2AgAgAEEFQa4lIAIQLhAnAAuqAQICfwF9IwBBEGsiAiQAIAAoAgAhACABQf8BcSIDQQZJBEACfwJAAkACQCADQQRrDgIAAQILIABBwANqIAAtAIQDQQNxQQJGDQIaIABBuANqDAILIABBuANqIAAtAIQDQQNxQQJGDQEaIABBwANqDAEL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IAMQUwsgAEGYAWogAUGYAWpByAIQLBogACgC4AMiAwRAIAAgAzYC5AMgAxAoCyAAIAEoAuADNgLgAyAAIAEoAuQDNgLkAyAAIAEoAugDNgLoAyABQQA2AugDIAFCADcC4AMgACABKQL0AzcC9AMgACABKQLsAzcC7AMgACABKAL8AzYC/AMgASgClAEhACABQQA2ApQBIAAEQCAAEFMLIAJBoARqJAAPCyACQcYcNgIQIABBBUGuJSACQRBqEC4QJwALIAJB5hE2AgAgAEEFQa4lIAIQLhAnAAsLtyYiAEGACAvZHU9ubHkgbGVhZiBub2RlcyB3aXRoIGN1c3RvbSBtZWFzdXJlIGZ1bmN0aW9ucyBzaG91bGQgbWFudWFsbHkgbWFyayB0aGVtc2VsdmVzIGFzIGRpcnR5AGlzRGlydHkAbWFya0RpcnR5AGRlc3Ryb3kAc2V0RGlzcGxheQBnZXREaXNwbGF5AHNldEZsZXgALSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweABzZXRGbGV4R3JvdwBnZXRGbGV4R3JvdwBzZXRPdmVyZmxvdwBnZXRPdmVyZmxvdwBoYXNOZXdMYXlvdXQAY2FsY3VsYXRlTGF5b3V0AGdldENvbXB1dGVkTGF5b3V0AHVuc2lnbmVkIHNob3J0AGdldENoaWxkQ291bnQAdW5zaWduZWQgaW50AHNldEp1c3RpZnlDb250ZW50AGdldEp1c3RpZnlDb250ZW50AGF2YWlsYWJsZUhlaWdodCBpcyBpbmRlZmluaXRlIHNvIGhlaWdodFNpemluZ01vZGUgbXVzdCBiZSBTaXppbmdNb2RlOjpNYXhDb250ZW50AGF2YWlsYWJsZVdpZHRoIGlzIGluZGVmaW5pdGUgc28gd2lkdGhTaXppbmdNb2RlIG11c3QgYmUgU2l6aW5nTW9kZTo6TWF4Q29udGVudABzZXRBbGlnbkNvbnRlbnQAZ2V0QWxpZ25Db250ZW50AGdldFBhcmVudABpbXBsZW1lbnQAc2V0TWF4SGVpZ2h0UGVyY2VudABzZXRIZWlnaHRQZXJjZW50AHNldE1pbkhlaWdodFBlcmNlbnQAc2V0RmxleEJhc2lzUGVyY2VudABzZXRHYXBQZXJjZW50AHNldFBvc2l0aW9uUGVyY2VudABzZXRNYXJnaW5QZXJjZW50AHNldE1heFdpZHRoUGVyY2VudABzZXRXaWR0aFBlcmNlbnQAc2V0TWluV2lkdGhQZXJjZW50AHNldFBhZGRpbmdQZXJjZW50AGhhbmRsZS50eXBlKCkgPT0gU3R5bGVWYWx1ZUhhbmRsZTo6VHlwZTo6UG9pbnQgfHwgaGFuZGxlLnR5cGUoKSA9PSBTdHlsZVZhbHVlSGFuZGxlOjpUeXBlOjpQZXJjZW50AGNyZWF0ZURlZmF1bHQAdW5pdAByaWdodABoZWlnaHQAc2V0TWF4SGVpZ2h0AGdldE1heEhlaWdodABzZXRIZWlnaHQAZ2V0SGVpZ2h0AHNldE1pbkhlaWdodABnZXRNaW5IZWlnaHQAZ2V0Q29tcHV0ZWRIZWlnaHQAZ2V0Q29tcHV0ZWRSaWdodABsZWZ0AGdldENvbXB1dGVkTGVmdAByZXNldABfX2Rlc3RydWN0AGZsb2F0AHVpbnQ2NF90AHVzZVdlYkRlZmF1bHRzAHNldFVzZVdlYkRlZmF1bHRzAHNldEFsaWduSXRlbXMAZ2V0QWxpZ25JdGVtcwBzZXRGbGV4QmFzaXMAZ2V0RmxleEJhc2lzAENhbm5vdCBnZXQgbGF5b3V0IHByb3BlcnRpZXMgb2YgbXVsdGktZWRnZSBzaG9ydGhhbmRzAHNldFBvaW50U2NhbGVGYWN0b3IATWVhc3VyZUNhbGxiYWNrV3JhcHBlcgBEaXJ0aWVkQ2FsbGJhY2tXcmFwcGVyAENhbm5vdCByZXNldCBhIG5vZGUgc3RpbGwgYXR0YWNoZWQgdG8gYSBvd25lcgBzZXRCb3JkZXIAZ2V0Qm9yZGVyAGdldENvbXB1dGVkQm9yZGVyAGdldE51bWJlcgBoYW5kbGUudHlwZSgpID09IFN0eWxlVmFsdWVIYW5kbGU6OlR5cGU6Ok51bWJlcgB1bnNpZ25lZCBjaGFyAHRvcABnZXRDb21wdXRlZFRvcABzZXRGbGV4V3JhcABnZXRGbGV4V3JhcABzZXRHYXAAZ2V0R2FwACVwAHNldEhlaWdodEF1dG8Ac2V0RmxleEJhc2lzQXV0bwBzZXRNYXJnaW5BdXRvAHNldFdpZHRoQXV0bwBTY2FsZSBmYWN0b3Igc2hvdWxkIG5vdCBiZSBsZXNzIHRoYW4gemVybwBzZXRBc3BlY3RSYXRpbwBnZXRBc3BlY3RSYXRpbwBzZXRQb3NpdGlvbgBnZXRQb3NpdGlvbgBub3RpZnlPbkRlc3RydWN0aW9uAHNldEZsZXhEaXJlY3Rpb24AZ2V0RmxleERpcmVjdGlvbgBzZXREaXJlY3Rpb24AZ2V0RGlyZWN0aW9uAHNldE1hcmdpbgBnZXRNYXJnaW4AZ2V0Q29tcHV0ZWRNYXJnaW4AbWFya0xheW91dFNlZW4AbmFuAGJvdHRvbQBnZXRDb21wdXRlZEJvdHRvbQBib29sAGVtc2NyaXB0ZW46OnZhbABzZXRGbGV4U2hyaW5rAGdldEZsZXhTaHJpbmsAc2V0QWx3YXlzRm9ybXNDb250YWluaW5nQmxvY2sATWVhc3VyZUNhbGxiYWNrAERpcnRpZWRDYWxsYmFjawBnZXRMZW5ndGgAd2lkdGgAc2V0TWF4V2lkdGgAZ2V0TWF4V2lkdGgAc2V0V2lkdGgAZ2V0V2lkdGgAc2V0TWluV2lkdGgAZ2V0TWluV2lkdGgAZ2V0Q29tcHV0ZWRXaWR0aABwdXNoAC9ob21lL3J1bm5lci93b3JrL3lvZ2EveW9nYS9qYXZhc2NyaXB0Ly4uL3lvZ2Evc3R5bGUvU21hbGxWYWx1ZUJ1ZmZlci5oAC9ob21lL3J1bm5lci93b3JrL3lvZ2EveW9nYS9qYXZhc2NyaXB0Ly4uL3lvZ2Evc3R5bGUvU3R5bGVWYWx1ZVBvb2wuaAB1bnNpZ25lZCBsb25nAHN0ZDo6d3N0cmluZwBzdGQ6OnN0cmluZwBzdGQ6OnUxNnN0cmluZwBzdGQ6OnUzMnN0cmluZwBzZXRQYWRkaW5nAGdldFBhZGRpbmcAZ2V0Q29tcHV0ZWRQYWRkaW5nAFRyaWVkIHRvIGNvbnN0cnVjdCBZR05vZGUgd2l0aCBudWxsIGNvbmZpZwBBdHRlbXB0aW5nIHRvIGNvbnN0cnVjdCBOb2RlIHdpdGggbnVsbCBjb25maWcAY3JlYXRlV2l0aENvbmZpZwBpbmYAc2V0QWxpZ25TZWxmAGdldEFsaWduU2VsZgBTaXplAHZhbHVlAFZhbHVlAGNyZWF0ZQBtZWFzdXJlAHNldFBvc2l0aW9uVHlwZQBnZXRQb3NpdGlvblR5cGUAaXNSZWZlcmVuY2VCYXNlbGluZQBzZXRJc1JlZmVyZW5jZUJhc2VsaW5lAGNvcHlTdHlsZQBkb3VibGUATm9kZQBleHRlbmQAaW5zZXJ0Q2hpbGQAZ2V0Q2hpbGQAcmVtb3ZlQ2hpbGQAdm9pZABzZXRFeHBlcmltZW50YWxGZWF0dXJlRW5hYmxlZABpc0V4cGVyaW1lbnRhbEZlYXR1cmVFbmFibGVkAGRpcnRpZWQAQ2Fubm90IHJlc2V0IGEgbm9kZSB3aGljaCBzdGlsbCBoYXMgY2hpbGRyZW4gYXR0YWNoZWQAdW5zZXRNZWFzdXJlRnVuYwB1bnNldERpcnRpZWRGdW5jAHNldEVycmF0YQBnZXRFcnJhdGEATWVhc3VyZSBmdW5jdGlvbiByZXR1cm5lZCBhbiBpbnZhbGlkIGRpbWVuc2lvbiB0byBZb2dhOiBbd2lkdGg9JWYsIGhlaWdodD0lZl0ARXhwZWN0IGN1c3RvbSBiYXNlbGluZSBmdW5jdGlvbiB0byBub3QgcmV0dXJuIE5hTgBOQU4ASU5GAGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGZsb2F0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4Ac3RkOjpiYXNpY19zdHJpbmc8dW5zaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2ln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";
    if (!ua2(H3)) {
      var va2 = H3;
      H3 = h2.locateFile ? h2.locateFile(va2, q2) : q2 + va2;
    }
    function wa2() {
      var a2 = H3;
      try {
        if (a2 == H3 && w2)
          return new Uint8Array(w2);
        if (ua2(a2))
          try {
            var b3 = xa2(a2.slice(37)), c2 = new Uint8Array(b3.length);
            for (a2 = 0; a2 < b3.length; ++a2)
              c2[a2] = b3.charCodeAt(a2);
            var d2 = c2;
          } catch (f2) {
            throw Error("Converting base64 string to bytes failed.");
          }
        else
          d2 = void 0;
        var e2 = d2;
        if (e2)
          return e2;
        throw "both async and sync fetching of the wasm failed";
      } catch (f2) {
        x2(f2);
      }
    }
    function ya() {
      return w2 || "function" != typeof fetch ? Promise.resolve().then(function() {
        return wa2();
      }) : fetch(H3, { credentials: "same-origin" }).then(function(a2) {
        if (!a2.ok)
          throw "failed to load wasm binary file at '" + H3 + "'";
        return a2.arrayBuffer();
      }).catch(function() {
        return wa2();
      });
    }
    function za(a2) {
      for (; 0 < a2.length; )
        a2.shift()(h2);
    }
    function Aa(a2) {
      if (void 0 === a2)
        return "_unknown";
      a2 = a2.replace(/[^a-zA-Z0-9_]/g, "$");
      var b3 = a2.charCodeAt(0);
      return 48 <= b3 && 57 >= b3 ? "_" + a2 : a2;
    }
    function Ba(a2, b3) {
      a2 = Aa(a2);
      return function() {
        return b3.apply(this, arguments);
      };
    }
    var J3 = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }], Ca = [];
    function Da2(a2) {
      var b3 = Error, c2 = Ba(a2, function(d2) {
        this.name = a2;
        this.message = d2;
        d2 = Error(d2).stack;
        void 0 !== d2 && (this.stack = this.toString() + "\n" + d2.replace(/^Error(:[^\n]*)?\n/, ""));
      });
      c2.prototype = Object.create(b3.prototype);
      c2.prototype.constructor = c2;
      c2.prototype.toString = function() {
        return void 0 === this.message ? this.name : this.name + ": " + this.message;
      };
      return c2;
    }
    var K2 = void 0;
    function L3(a2) {
      throw new K2(a2);
    }
    var M3 = (a2) => {
      a2 || L3("Cannot use deleted val. handle = " + a2);
      return J3[a2].value;
    }, Ea2 = (a2) => {
      switch (a2) {
        case void 0:
          return 1;
        case null:
          return 2;
        case true:
          return 3;
        case false:
          return 4;
        default:
          var b3 = Ca.length ? Ca.pop() : J3.length;
          J3[b3] = { ga: 1, value: a2 };
          return b3;
      }
    }, Fa2 = void 0, Ga = void 0;
    function N2(a2) {
      for (var b3 = ""; A[a2]; )
        b3 += Ga[A[a2++]];
      return b3;
    }
    var O2 = [];
    function Ha() {
      for (; O2.length; ) {
        var a2 = O2.pop();
        a2.M.$ = false;
        a2["delete"]();
      }
    }
    var P2 = void 0, Q3 = {};
    function Ia2(a2, b3) {
      for (void 0 === b3 && L3("ptr should not be undefined"); a2.R; )
        b3 = a2.ba(b3), a2 = a2.R;
      return b3;
    }
    var R3 = {};
    function Ja2(a2) {
      a2 = Ka(a2);
      var b3 = N2(a2);
      S3(a2);
      return b3;
    }
    function La(a2, b3) {
      var c2 = R3[a2];
      void 0 === c2 && L3(b3 + " has unknown type " + Ja2(a2));
      return c2;
    }
    function Ma2() {
    }
    var Na2 = false;
    function Oa(a2) {
      --a2.count.value;
      0 === a2.count.value && (a2.T ? a2.U.W(a2.T) : a2.P.N.W(a2.O));
    }
    function Pa(a2, b3, c2) {
      if (b3 === c2)
        return a2;
      if (void 0 === c2.R)
        return null;
      a2 = Pa(a2, b3, c2.R);
      return null === a2 ? null : c2.na(a2);
    }
    var Qa = {};
    function Ra2(a2, b3) {
      b3 = Ia2(a2, b3);
      return Q3[b3];
    }
    var Sa2 = void 0;
    function Ta(a2) {
      throw new Sa2(a2);
    }
    function Ua2(a2, b3) {
      b3.P && b3.O || Ta("makeClassHandle requires ptr and ptrType");
      !!b3.U !== !!b3.T && Ta("Both smartPtrType and smartPtr must be specified");
      b3.count = { value: 1 };
      return T3(Object.create(a2, { M: { value: b3 } }));
    }
    function T3(a2) {
      if ("undefined" === typeof FinalizationRegistry)
        return T3 = (b3) => b3, a2;
      Na2 = new FinalizationRegistry((b3) => {
        Oa(b3.M);
      });
      T3 = (b3) => {
        var c2 = b3.M;
        c2.T && Na2.register(b3, { M: c2 }, b3);
        return b3;
      };
      Ma2 = (b3) => {
        Na2.unregister(b3);
      };
      return T3(a2);
    }
    var Va = {};
    function Wa(a2) {
      for (; a2.length; ) {
        var b3 = a2.pop();
        a2.pop()(b3);
      }
    }
    function Xa(a2) {
      return this.fromWireType(D[a2 >> 2]);
    }
    var U2 = {}, Ya = {};
    function V2(a2, b3, c2) {
      function d2(k) {
        k = c2(k);
        k.length !== a2.length && Ta("Mismatched type converter count");
        for (var m = 0; m < a2.length; ++m)
          W2(a2[m], k[m]);
      }
      a2.forEach(function(k) {
        Ya[k] = b3;
      });
      var e2 = Array(b3.length), f2 = [], g2 = 0;
      b3.forEach((k, m) => {
        R3.hasOwnProperty(k) ? e2[m] = R3[k] : (f2.push(k), U2.hasOwnProperty(k) || (U2[k] = []), U2[k].push(() => {
          e2[m] = R3[k];
          ++g2;
          g2 === f2.length && d2(e2);
        }));
      });
      0 === f2.length && d2(e2);
    }
    function Za(a2) {
      switch (a2) {
        case 1:
          return 0;
        case 2:
          return 1;
        case 4:
          return 2;
        case 8:
          return 3;
        default:
          throw new TypeError("Unknown type size: " + a2);
      }
    }
    function W2(a2, b3, c2 = {}) {
      if (!("argPackAdvance" in b3))
        throw new TypeError("registerType registeredInstance requires argPackAdvance");
      var d2 = b3.name;
      a2 || L3('type "' + d2 + '" must have a positive integer typeid pointer');
      if (R3.hasOwnProperty(a2)) {
        if (c2.ua)
          return;
        L3("Cannot register type '" + d2 + "' twice");
      }
      R3[a2] = b3;
      delete Ya[a2];
      U2.hasOwnProperty(a2) && (b3 = U2[a2], delete U2[a2], b3.forEach((e2) => e2()));
    }
    function $a2(a2) {
      L3(a2.M.P.N.name + " instance already deleted");
    }
    function X3() {
    }
    function ab2(a2, b3, c2) {
      if (void 0 === a2[b3].S) {
        var d2 = a2[b3];
        a2[b3] = function() {
          a2[b3].S.hasOwnProperty(arguments.length) || L3("Function '" + c2 + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + a2[b3].S + ")!");
          return a2[b3].S[arguments.length].apply(this, arguments);
        };
        a2[b3].S = [];
        a2[b3].S[d2.Z] = d2;
      }
    }
    function bb(a2, b3) {
      h2.hasOwnProperty(a2) ? (L3("Cannot register public name '" + a2 + "' twice"), ab2(h2, a2, a2), h2.hasOwnProperty(void 0) && L3("Cannot register multiple overloads of a function with the same number of arguments (undefined)!"), h2[a2].S[void 0] = b3) : h2[a2] = b3;
    }
    function cb(a2, b3, c2, d2, e2, f2, g2, k) {
      this.name = a2;
      this.constructor = b3;
      this.X = c2;
      this.W = d2;
      this.R = e2;
      this.pa = f2;
      this.ba = g2;
      this.na = k;
      this.ja = [];
    }
    function db(a2, b3, c2) {
      for (; b3 !== c2; )
        b3.ba || L3("Expected null or instance of " + c2.name + ", got an instance of " + b3.name), a2 = b3.ba(a2), b3 = b3.R;
      return a2;
    }
    function eb(a2, b3) {
      if (null === b3)
        return this.ea && L3("null is not a valid " + this.name), 0;
      b3.M || L3('Cannot pass "' + fb(b3) + '" as a ' + this.name);
      b3.M.O || L3("Cannot pass deleted object as a pointer of type " + this.name);
      return db(b3.M.O, b3.M.P.N, this.N);
    }
    function gb(a2, b3) {
      if (null === b3) {
        this.ea && L3("null is not a valid " + this.name);
        if (this.da) {
          var c2 = this.fa();
          null !== a2 && a2.push(this.W, c2);
          return c2;
        }
        return 0;
      }
      b3.M || L3('Cannot pass "' + fb(b3) + '" as a ' + this.name);
      b3.M.O || L3("Cannot pass deleted object as a pointer of type " + this.name);
      !this.ca && b3.M.P.ca && L3("Cannot convert argument of type " + (b3.M.U ? b3.M.U.name : b3.M.P.name) + " to parameter type " + this.name);
      c2 = db(b3.M.O, b3.M.P.N, this.N);
      if (this.da)
        switch (void 0 === b3.M.T && L3("Passing raw pointer to smart pointer is illegal"), this.Ba) {
          case 0:
            b3.M.U === this ? c2 = b3.M.T : L3("Cannot convert argument of type " + (b3.M.U ? b3.M.U.name : b3.M.P.name) + " to parameter type " + this.name);
            break;
          case 1:
            c2 = b3.M.T;
            break;
          case 2:
            if (b3.M.U === this)
              c2 = b3.M.T;
            else {
              var d2 = b3.clone();
              c2 = this.xa(c2, Ea2(function() {
                d2["delete"]();
              }));
              null !== a2 && a2.push(this.W, c2);
            }
            break;
          default:
            L3("Unsupporting sharing policy");
        }
      return c2;
    }
    function hb(a2, b3) {
      if (null === b3)
        return this.ea && L3("null is not a valid " + this.name), 0;
      b3.M || L3('Cannot pass "' + fb(b3) + '" as a ' + this.name);
      b3.M.O || L3("Cannot pass deleted object as a pointer of type " + this.name);
      b3.M.P.ca && L3("Cannot convert argument of type " + b3.M.P.name + " to parameter type " + this.name);
      return db(b3.M.O, b3.M.P.N, this.N);
    }
    function Y2(a2, b3, c2, d2) {
      this.name = a2;
      this.N = b3;
      this.ea = c2;
      this.ca = d2;
      this.da = false;
      this.W = this.xa = this.fa = this.ka = this.Ba = this.wa = void 0;
      void 0 !== b3.R ? this.toWireType = gb : (this.toWireType = d2 ? eb : hb, this.V = null);
    }
    function ib(a2, b3) {
      h2.hasOwnProperty(a2) || Ta("Replacing nonexistant public symbol");
      h2[a2] = b3;
      h2[a2].Z = void 0;
    }
    function jb(a2, b3) {
      var c2 = [];
      return function() {
        c2.length = 0;
        Object.assign(c2, arguments);
        if (a2.includes("j")) {
          var d2 = h2["dynCall_" + a2];
          d2 = c2 && c2.length ? d2.apply(null, [b3].concat(c2)) : d2.call(null, b3);
        } else
          d2 = oa2.get(b3).apply(null, c2);
        return d2;
      };
    }
    function Z3(a2, b3) {
      a2 = N2(a2);
      var c2 = a2.includes("j") ? jb(a2, b3) : oa2.get(b3);
      "function" != typeof c2 && L3("unknown function pointer with signature " + a2 + ": " + b3);
      return c2;
    }
    var mb = void 0;
    function nb(a2, b3) {
      function c2(f2) {
        e2[f2] || R3[f2] || (Ya[f2] ? Ya[f2].forEach(c2) : (d2.push(f2), e2[f2] = true));
      }
      var d2 = [], e2 = {};
      b3.forEach(c2);
      throw new mb(a2 + ": " + d2.map(Ja2).join([", "]));
    }
    function ob(a2, b3, c2, d2, e2) {
      var f2 = b3.length;
      2 > f2 && L3("argTypes array size mismatch! Must at least get return value and 'this' types!");
      var g2 = null !== b3[1] && null !== c2, k = false;
      for (c2 = 1; c2 < b3.length; ++c2)
        if (null !== b3[c2] && void 0 === b3[c2].V) {
          k = true;
          break;
        }
      var m = "void" !== b3[0].name, l2 = f2 - 2, n2 = Array(l2), p2 = [], r2 = [];
      return function() {
        arguments.length !== l2 && L3("function " + a2 + " called with " + arguments.length + " arguments, expected " + l2 + " args!");
        r2.length = 0;
        p2.length = g2 ? 2 : 1;
        p2[0] = e2;
        if (g2) {
          var u2 = b3[1].toWireType(r2, this);
          p2[1] = u2;
        }
        for (var t2 = 0; t2 < l2; ++t2)
          n2[t2] = b3[t2 + 2].toWireType(r2, arguments[t2]), p2.push(n2[t2]);
        t2 = d2.apply(null, p2);
        if (k)
          Wa(r2);
        else
          for (var y3 = g2 ? 1 : 2; y3 < b3.length; y3++) {
            var B2 = 1 === y3 ? u2 : n2[y3 - 2];
            null !== b3[y3].V && b3[y3].V(B2);
          }
        u2 = m ? b3[0].fromWireType(t2) : void 0;
        return u2;
      };
    }
    function pb(a2, b3) {
      for (var c2 = [], d2 = 0; d2 < a2; d2++)
        c2.push(E2[b3 + 4 * d2 >> 2]);
      return c2;
    }
    function qb(a2) {
      4 < a2 && 0 === --J3[a2].ga && (J3[a2] = void 0, Ca.push(a2));
    }
    function fb(a2) {
      if (null === a2)
        return "null";
      var b3 = typeof a2;
      return "object" === b3 || "array" === b3 || "function" === b3 ? a2.toString() : "" + a2;
    }
    function rb(a2, b3) {
      switch (b3) {
        case 2:
          return function(c2) {
            return this.fromWireType(la2[c2 >> 2]);
          };
        case 3:
          return function(c2) {
            return this.fromWireType(ma2[c2 >> 3]);
          };
        default:
          throw new TypeError("Unknown float type: " + a2);
      }
    }
    function sb2(a2, b3, c2) {
      switch (b3) {
        case 0:
          return c2 ? function(d2) {
            return ja[d2];
          } : function(d2) {
            return A[d2];
          };
        case 1:
          return c2 ? function(d2) {
            return C[d2 >> 1];
          } : function(d2) {
            return ka2[d2 >> 1];
          };
        case 2:
          return c2 ? function(d2) {
            return D[d2 >> 2];
          } : function(d2) {
            return E2[d2 >> 2];
          };
        default:
          throw new TypeError("Unknown integer type: " + a2);
      }
    }
    function tb(a2, b3) {
      for (var c2 = "", d2 = 0; !(d2 >= b3 / 2); ++d2) {
        var e2 = C[a2 + 2 * d2 >> 1];
        if (0 == e2)
          break;
        c2 += String.fromCharCode(e2);
      }
      return c2;
    }
    function ub(a2, b3, c2) {
      void 0 === c2 && (c2 = 2147483647);
      if (2 > c2)
        return 0;
      c2 -= 2;
      var d2 = b3;
      c2 = c2 < 2 * a2.length ? c2 / 2 : a2.length;
      for (var e2 = 0; e2 < c2; ++e2)
        C[b3 >> 1] = a2.charCodeAt(e2), b3 += 2;
      C[b3 >> 1] = 0;
      return b3 - d2;
    }
    function vb(a2) {
      return 2 * a2.length;
    }
    function wb(a2, b3) {
      for (var c2 = 0, d2 = ""; !(c2 >= b3 / 4); ) {
        var e2 = D[a2 + 4 * c2 >> 2];
        if (0 == e2)
          break;
        ++c2;
        65536 <= e2 ? (e2 -= 65536, d2 += String.fromCharCode(55296 | e2 >> 10, 56320 | e2 & 1023)) : d2 += String.fromCharCode(e2);
      }
      return d2;
    }
    function xb(a2, b3, c2) {
      void 0 === c2 && (c2 = 2147483647);
      if (4 > c2)
        return 0;
      var d2 = b3;
      c2 = d2 + c2 - 4;
      for (var e2 = 0; e2 < a2.length; ++e2) {
        var f2 = a2.charCodeAt(e2);
        if (55296 <= f2 && 57343 >= f2) {
          var g2 = a2.charCodeAt(++e2);
          f2 = 65536 + ((f2 & 1023) << 10) | g2 & 1023;
        }
        D[b3 >> 2] = f2;
        b3 += 4;
        if (b3 + 4 > c2)
          break;
      }
      D[b3 >> 2] = 0;
      return b3 - d2;
    }
    function yb(a2) {
      for (var b3 = 0, c2 = 0; c2 < a2.length; ++c2) {
        var d2 = a2.charCodeAt(c2);
        55296 <= d2 && 57343 >= d2 && ++c2;
        b3 += 4;
      }
      return b3;
    }
    var zb = {};
    function Ab(a2) {
      var b3 = zb[a2];
      return void 0 === b3 ? N2(a2) : b3;
    }
    var Bb = [];
    function Cb(a2) {
      var b3 = Bb.length;
      Bb.push(a2);
      return b3;
    }
    function Db(a2, b3) {
      for (var c2 = Array(a2), d2 = 0; d2 < a2; ++d2)
        c2[d2] = La(E2[b3 + 4 * d2 >> 2], "parameter " + d2);
      return c2;
    }
    var Eb = [], Fb = [null, [], []];
    K2 = h2.BindingError = Da2("BindingError");
    h2.count_emval_handles = function() {
      for (var a2 = 0, b3 = 5; b3 < J3.length; ++b3)
        void 0 !== J3[b3] && ++a2;
      return a2;
    };
    h2.get_first_emval = function() {
      for (var a2 = 5; a2 < J3.length; ++a2)
        if (void 0 !== J3[a2])
          return J3[a2];
      return null;
    };
    Fa2 = h2.PureVirtualError = Da2("PureVirtualError");
    for (var Gb = Array(256), Hb = 0; 256 > Hb; ++Hb)
      Gb[Hb] = String.fromCharCode(Hb);
    Ga = Gb;
    h2.getInheritedInstanceCount = function() {
      return Object.keys(Q3).length;
    };
    h2.getLiveInheritedInstances = function() {
      var a2 = [], b3;
      for (b3 in Q3)
        Q3.hasOwnProperty(b3) && a2.push(Q3[b3]);
      return a2;
    };
    h2.flushPendingDeletes = Ha;
    h2.setDelayFunction = function(a2) {
      P2 = a2;
      O2.length && P2 && P2(Ha);
    };
    Sa2 = h2.InternalError = Da2("InternalError");
    X3.prototype.isAliasOf = function(a2) {
      if (!(this instanceof X3 && a2 instanceof X3))
        return false;
      var b3 = this.M.P.N, c2 = this.M.O, d2 = a2.M.P.N;
      for (a2 = a2.M.O; b3.R; )
        c2 = b3.ba(c2), b3 = b3.R;
      for (; d2.R; )
        a2 = d2.ba(a2), d2 = d2.R;
      return b3 === d2 && c2 === a2;
    };
    X3.prototype.clone = function() {
      this.M.O || $a2(this);
      if (this.M.aa)
        return this.M.count.value += 1, this;
      var a2 = T3, b3 = Object, c2 = b3.create, d2 = Object.getPrototypeOf(this), e2 = this.M;
      a2 = a2(c2.call(b3, d2, { M: { value: { count: e2.count, $: e2.$, aa: e2.aa, O: e2.O, P: e2.P, T: e2.T, U: e2.U } } }));
      a2.M.count.value += 1;
      a2.M.$ = false;
      return a2;
    };
    X3.prototype["delete"] = function() {
      this.M.O || $a2(this);
      this.M.$ && !this.M.aa && L3("Object already scheduled for deletion");
      Ma2(this);
      Oa(this.M);
      this.M.aa || (this.M.T = void 0, this.M.O = void 0);
    };
    X3.prototype.isDeleted = function() {
      return !this.M.O;
    };
    X3.prototype.deleteLater = function() {
      this.M.O || $a2(this);
      this.M.$ && !this.M.aa && L3("Object already scheduled for deletion");
      O2.push(this);
      1 === O2.length && P2 && P2(Ha);
      this.M.$ = true;
      return this;
    };
    Y2.prototype.qa = function(a2) {
      this.ka && (a2 = this.ka(a2));
      return a2;
    };
    Y2.prototype.ha = function(a2) {
      this.W && this.W(a2);
    };
    Y2.prototype.argPackAdvance = 8;
    Y2.prototype.readValueFromPointer = Xa;
    Y2.prototype.deleteObject = function(a2) {
      if (null !== a2)
        a2["delete"]();
    };
    Y2.prototype.fromWireType = function(a2) {
      function b3() {
        return this.da ? Ua2(this.N.X, { P: this.wa, O: c2, U: this, T: a2 }) : Ua2(this.N.X, { P: this, O: a2 });
      }
      var c2 = this.qa(a2);
      if (!c2)
        return this.ha(a2), null;
      var d2 = Ra2(this.N, c2);
      if (void 0 !== d2) {
        if (0 === d2.M.count.value)
          return d2.M.O = c2, d2.M.T = a2, d2.clone();
        d2 = d2.clone();
        this.ha(a2);
        return d2;
      }
      d2 = this.N.pa(c2);
      d2 = Qa[d2];
      if (!d2)
        return b3.call(this);
      d2 = this.ca ? d2.la : d2.pointerType;
      var e2 = Pa(c2, this.N, d2.N);
      return null === e2 ? b3.call(this) : this.da ? Ua2(d2.N.X, { P: d2, O: e2, U: this, T: a2 }) : Ua2(d2.N.X, { P: d2, O: e2 });
    };
    mb = h2.UnboundTypeError = Da2("UnboundTypeError");
    var xa2 = "function" == typeof atob ? atob : function(a2) {
      var b3 = "", c2 = 0;
      a2 = a2.replace(/[^A-Za-z0-9\+\/=]/g, "");
      do {
        var d2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a2.charAt(c2++));
        var e2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a2.charAt(c2++));
        var f2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a2.charAt(c2++));
        var g2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a2.charAt(c2++));
        d2 = d2 << 2 | e2 >> 4;
        e2 = (e2 & 15) << 4 | f2 >> 2;
        var k = (f2 & 3) << 6 | g2;
        b3 += String.fromCharCode(d2);
        64 !== f2 && (b3 += String.fromCharCode(e2));
        64 !== g2 && (b3 += String.fromCharCode(k));
      } while (c2 < a2.length);
      return b3;
    }, Jb = {
      l: function(a2, b3, c2, d2) {
        x2("Assertion failed: " + (a2 ? z3(A, a2) : "") + ", at: " + [b3 ? b3 ? z3(A, b3) : "" : "unknown filename", c2, d2 ? d2 ? z3(A, d2) : "" : "unknown function"]);
      },
      q: function(a2, b3, c2) {
        a2 = N2(a2);
        b3 = La(b3, "wrapper");
        c2 = M3(c2);
        var d2 = [].slice, e2 = b3.N, f2 = e2.X, g2 = e2.R.X, k = e2.R.constructor;
        a2 = Ba(a2, function() {
          e2.R.ja.forEach((function(l2) {
            if (this[l2] === g2[l2])
              throw new Fa2("Pure virtual function " + l2 + " must be implemented in JavaScript");
          }).bind(this));
          Object.defineProperty(this, "__parent", { value: f2 });
          this.__construct.apply(this, d2.call(arguments));
        });
        f2.__construct = function() {
          this === f2 && L3("Pass correct 'this' to __construct");
          var l2 = k.implement.apply(void 0, [this].concat(d2.call(arguments)));
          Ma2(l2);
          var n2 = l2.M;
          l2.notifyOnDestruction();
          n2.aa = true;
          Object.defineProperties(this, { M: { value: n2 } });
          T3(this);
          l2 = n2.O;
          l2 = Ia2(e2, l2);
          Q3.hasOwnProperty(l2) ? L3("Tried to register registered instance: " + l2) : Q3[l2] = this;
        };
        f2.__destruct = function() {
          this === f2 && L3("Pass correct 'this' to __destruct");
          Ma2(this);
          var l2 = this.M.O;
          l2 = Ia2(e2, l2);
          Q3.hasOwnProperty(l2) ? delete Q3[l2] : L3("Tried to unregister unregistered instance: " + l2);
        };
        a2.prototype = Object.create(f2);
        for (var m in c2)
          a2.prototype[m] = c2[m];
        return Ea2(a2);
      },
      j: function(a2) {
        var b3 = Va[a2];
        delete Va[a2];
        var c2 = b3.fa, d2 = b3.W, e2 = b3.ia, f2 = e2.map((g2) => g2.ta).concat(e2.map((g2) => g2.za));
        V2([a2], f2, (g2) => {
          var k = {};
          e2.forEach((m, l2) => {
            var n2 = g2[l2], p2 = m.ra, r2 = m.sa, u2 = g2[l2 + e2.length], t2 = m.ya, y3 = m.Aa;
            k[m.oa] = { read: (B2) => n2.fromWireType(p2(r2, B2)), write: (B2, ba2) => {
              var I2 = [];
              t2(
                y3,
                B2,
                u2.toWireType(I2, ba2)
              );
              Wa(I2);
            } };
          });
          return [{ name: b3.name, fromWireType: function(m) {
            var l2 = {}, n2;
            for (n2 in k)
              l2[n2] = k[n2].read(m);
            d2(m);
            return l2;
          }, toWireType: function(m, l2) {
            for (var n2 in k)
              if (!(n2 in l2))
                throw new TypeError('Missing field:  "' + n2 + '"');
            var p2 = c2();
            for (n2 in k)
              k[n2].write(p2, l2[n2]);
            null !== m && m.push(d2, p2);
            return p2;
          }, argPackAdvance: 8, readValueFromPointer: Xa, V: d2 }];
        });
      },
      v: function() {
      },
      B: function(a2, b3, c2, d2, e2) {
        var f2 = Za(c2);
        b3 = N2(b3);
        W2(a2, {
          name: b3,
          fromWireType: function(g2) {
            return !!g2;
          },
          toWireType: function(g2, k) {
            return k ? d2 : e2;
          },
          argPackAdvance: 8,
          readValueFromPointer: function(g2) {
            if (1 === c2)
              var k = ja;
            else if (2 === c2)
              k = C;
            else if (4 === c2)
              k = D;
            else
              throw new TypeError("Unknown boolean type size: " + b3);
            return this.fromWireType(k[g2 >> f2]);
          },
          V: null
        });
      },
      f: function(a2, b3, c2, d2, e2, f2, g2, k, m, l2, n2, p2, r2) {
        n2 = N2(n2);
        f2 = Z3(e2, f2);
        k && (k = Z3(g2, k));
        l2 && (l2 = Z3(m, l2));
        r2 = Z3(p2, r2);
        var u2 = Aa(n2);
        bb(u2, function() {
          nb("Cannot construct " + n2 + " due to unbound types", [d2]);
        });
        V2([a2, b3, c2], d2 ? [d2] : [], function(t2) {
          t2 = t2[0];
          if (d2) {
            var y3 = t2.N;
            var B2 = y3.X;
          } else
            B2 = X3.prototype;
          t2 = Ba(u2, function() {
            if (Object.getPrototypeOf(this) !== ba2)
              throw new K2("Use 'new' to construct " + n2);
            if (void 0 === I2.Y)
              throw new K2(n2 + " has no accessible constructor");
            var kb = I2.Y[arguments.length];
            if (void 0 === kb)
              throw new K2("Tried to invoke ctor of " + n2 + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(I2.Y).toString() + ") parameters instead!");
            return kb.apply(this, arguments);
          });
          var ba2 = Object.create(B2, { constructor: { value: t2 } });
          t2.prototype = ba2;
          var I2 = new cb(n2, t2, ba2, r2, y3, f2, k, l2);
          y3 = new Y2(n2, I2, true, false);
          B2 = new Y2(n2 + "*", I2, false, false);
          var lb = new Y2(n2 + " const*", I2, false, true);
          Qa[a2] = {
            pointerType: B2,
            la: lb
          };
          ib(u2, t2);
          return [y3, B2, lb];
        });
      },
      d: function(a2, b3, c2, d2, e2, f2, g2) {
        var k = pb(c2, d2);
        b3 = N2(b3);
        f2 = Z3(e2, f2);
        V2([], [a2], function(m) {
          function l2() {
            nb("Cannot call " + n2 + " due to unbound types", k);
          }
          m = m[0];
          var n2 = m.name + "." + b3;
          b3.startsWith("@@") && (b3 = Symbol[b3.substring(2)]);
          var p2 = m.N.constructor;
          void 0 === p2[b3] ? (l2.Z = c2 - 1, p2[b3] = l2) : (ab2(p2, b3, n2), p2[b3].S[c2 - 1] = l2);
          V2([], k, function(r2) {
            r2 = ob(n2, [r2[0], null].concat(r2.slice(1)), null, f2, g2);
            void 0 === p2[b3].S ? (r2.Z = c2 - 1, p2[b3] = r2) : p2[b3].S[c2 - 1] = r2;
            return [];
          });
          return [];
        });
      },
      p: function(a2, b3, c2, d2, e2, f2) {
        0 < b3 || x2();
        var g2 = pb(
          b3,
          c2
        );
        e2 = Z3(d2, e2);
        V2([], [a2], function(k) {
          k = k[0];
          var m = "constructor " + k.name;
          void 0 === k.N.Y && (k.N.Y = []);
          if (void 0 !== k.N.Y[b3 - 1])
            throw new K2("Cannot register multiple constructors with identical number of parameters (" + (b3 - 1) + ") for class '" + k.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
          k.N.Y[b3 - 1] = () => {
            nb("Cannot construct " + k.name + " due to unbound types", g2);
          };
          V2([], g2, function(l2) {
            l2.splice(1, 0, null);
            k.N.Y[b3 - 1] = ob(m, l2, null, e2, f2);
            return [];
          });
          return [];
        });
      },
      a: function(a2, b3, c2, d2, e2, f2, g2, k) {
        var m = pb(c2, d2);
        b3 = N2(b3);
        f2 = Z3(e2, f2);
        V2([], [a2], function(l2) {
          function n2() {
            nb("Cannot call " + p2 + " due to unbound types", m);
          }
          l2 = l2[0];
          var p2 = l2.name + "." + b3;
          b3.startsWith("@@") && (b3 = Symbol[b3.substring(2)]);
          k && l2.N.ja.push(b3);
          var r2 = l2.N.X, u2 = r2[b3];
          void 0 === u2 || void 0 === u2.S && u2.className !== l2.name && u2.Z === c2 - 2 ? (n2.Z = c2 - 2, n2.className = l2.name, r2[b3] = n2) : (ab2(r2, b3, p2), r2[b3].S[c2 - 2] = n2);
          V2([], m, function(t2) {
            t2 = ob(p2, t2, l2, f2, g2);
            void 0 === r2[b3].S ? (t2.Z = c2 - 2, r2[b3] = t2) : r2[b3].S[c2 - 2] = t2;
            return [];
          });
          return [];
        });
      },
      A: function(a2, b3) {
        b3 = N2(b3);
        W2(
          a2,
          { name: b3, fromWireType: function(c2) {
            var d2 = M3(c2);
            qb(c2);
            return d2;
          }, toWireType: function(c2, d2) {
            return Ea2(d2);
          }, argPackAdvance: 8, readValueFromPointer: Xa, V: null }
        );
      },
      n: function(a2, b3, c2) {
        c2 = Za(c2);
        b3 = N2(b3);
        W2(a2, { name: b3, fromWireType: function(d2) {
          return d2;
        }, toWireType: function(d2, e2) {
          return e2;
        }, argPackAdvance: 8, readValueFromPointer: rb(b3, c2), V: null });
      },
      e: function(a2, b3, c2, d2, e2) {
        b3 = N2(b3);
        -1 === e2 && (e2 = 4294967295);
        e2 = Za(c2);
        var f2 = (k) => k;
        if (0 === d2) {
          var g2 = 32 - 8 * c2;
          f2 = (k) => k << g2 >>> g2;
        }
        c2 = b3.includes("unsigned") ? function(k, m) {
          return m >>> 0;
        } : function(k, m) {
          return m;
        };
        W2(a2, { name: b3, fromWireType: f2, toWireType: c2, argPackAdvance: 8, readValueFromPointer: sb2(b3, e2, 0 !== d2), V: null });
      },
      b: function(a2, b3, c2) {
        function d2(f2) {
          f2 >>= 2;
          var g2 = E2;
          return new e2(ia, g2[f2 + 1], g2[f2]);
        }
        var e2 = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array][b3];
        c2 = N2(c2);
        W2(a2, { name: c2, fromWireType: d2, argPackAdvance: 8, readValueFromPointer: d2 }, { ua: true });
      },
      o: function(a2, b3) {
        b3 = N2(b3);
        var c2 = "std::string" === b3;
        W2(a2, { name: b3, fromWireType: function(d2) {
          var e2 = E2[d2 >> 2], f2 = d2 + 4;
          if (c2)
            for (var g2 = f2, k = 0; k <= e2; ++k) {
              var m = f2 + k;
              if (k == e2 || 0 == A[m]) {
                g2 = g2 ? z3(A, g2, m - g2) : "";
                if (void 0 === l2)
                  var l2 = g2;
                else
                  l2 += String.fromCharCode(0), l2 += g2;
                g2 = m + 1;
              }
            }
          else {
            l2 = Array(e2);
            for (k = 0; k < e2; ++k)
              l2[k] = String.fromCharCode(A[f2 + k]);
            l2 = l2.join("");
          }
          S3(d2);
          return l2;
        }, toWireType: function(d2, e2) {
          e2 instanceof ArrayBuffer && (e2 = new Uint8Array(e2));
          var f2, g2 = "string" == typeof e2;
          g2 || e2 instanceof Uint8Array || e2 instanceof Uint8ClampedArray || e2 instanceof Int8Array || L3("Cannot pass non-string to std::string");
          if (c2 && g2) {
            var k = 0;
            for (f2 = 0; f2 < e2.length; ++f2) {
              var m = e2.charCodeAt(f2);
              127 >= m ? k++ : 2047 >= m ? k += 2 : 55296 <= m && 57343 >= m ? (k += 4, ++f2) : k += 3;
            }
            f2 = k;
          } else
            f2 = e2.length;
          k = Ib(4 + f2 + 1);
          m = k + 4;
          E2[k >> 2] = f2;
          if (c2 && g2) {
            if (g2 = m, m = f2 + 1, f2 = A, 0 < m) {
              m = g2 + m - 1;
              for (var l2 = 0; l2 < e2.length; ++l2) {
                var n2 = e2.charCodeAt(l2);
                if (55296 <= n2 && 57343 >= n2) {
                  var p2 = e2.charCodeAt(++l2);
                  n2 = 65536 + ((n2 & 1023) << 10) | p2 & 1023;
                }
                if (127 >= n2) {
                  if (g2 >= m)
                    break;
                  f2[g2++] = n2;
                } else {
                  if (2047 >= n2) {
                    if (g2 + 1 >= m)
                      break;
                    f2[g2++] = 192 | n2 >> 6;
                  } else {
                    if (65535 >= n2) {
                      if (g2 + 2 >= m)
                        break;
                      f2[g2++] = 224 | n2 >> 12;
                    } else {
                      if (g2 + 3 >= m)
                        break;
                      f2[g2++] = 240 | n2 >> 18;
                      f2[g2++] = 128 | n2 >> 12 & 63;
                    }
                    f2[g2++] = 128 | n2 >> 6 & 63;
                  }
                  f2[g2++] = 128 | n2 & 63;
                }
              }
              f2[g2] = 0;
            }
          } else if (g2)
            for (g2 = 0; g2 < f2; ++g2)
              l2 = e2.charCodeAt(g2), 255 < l2 && (S3(m), L3("String has UTF-16 code units that do not fit in 8 bits")), A[m + g2] = l2;
          else
            for (g2 = 0; g2 < f2; ++g2)
              A[m + g2] = e2[g2];
          null !== d2 && d2.push(S3, k);
          return k;
        }, argPackAdvance: 8, readValueFromPointer: Xa, V: function(d2) {
          S3(d2);
        } });
      },
      i: function(a2, b3, c2) {
        c2 = N2(c2);
        if (2 === b3) {
          var d2 = tb;
          var e2 = ub;
          var f2 = vb;
          var g2 = () => ka2;
          var k = 1;
        } else
          4 === b3 && (d2 = wb, e2 = xb, f2 = yb, g2 = () => E2, k = 2);
        W2(a2, { name: c2, fromWireType: function(m) {
          for (var l2 = E2[m >> 2], n2 = g2(), p2, r2 = m + 4, u2 = 0; u2 <= l2; ++u2) {
            var t2 = m + 4 + u2 * b3;
            if (u2 == l2 || 0 == n2[t2 >> k])
              r2 = d2(r2, t2 - r2), void 0 === p2 ? p2 = r2 : (p2 += String.fromCharCode(0), p2 += r2), r2 = t2 + b3;
          }
          S3(m);
          return p2;
        }, toWireType: function(m, l2) {
          "string" != typeof l2 && L3("Cannot pass non-string to C++ string type " + c2);
          var n2 = f2(l2), p2 = Ib(4 + n2 + b3);
          E2[p2 >> 2] = n2 >> k;
          e2(l2, p2 + 4, n2 + b3);
          null !== m && m.push(S3, p2);
          return p2;
        }, argPackAdvance: 8, readValueFromPointer: Xa, V: function(m) {
          S3(m);
        } });
      },
      k: function(a2, b3, c2, d2, e2, f2) {
        Va[a2] = { name: N2(b3), fa: Z3(c2, d2), W: Z3(e2, f2), ia: [] };
      },
      h: function(a2, b3, c2, d2, e2, f2, g2, k, m, l2) {
        Va[a2].ia.push({ oa: N2(b3), ta: c2, ra: Z3(d2, e2), sa: f2, za: g2, ya: Z3(k, m), Aa: l2 });
      },
      C: function(a2, b3) {
        b3 = N2(b3);
        W2(a2, {
          va: true,
          name: b3,
          argPackAdvance: 0,
          fromWireType: function() {
          },
          toWireType: function() {
          }
        });
      },
      s: function(a2, b3, c2, d2, e2) {
        a2 = Bb[a2];
        b3 = M3(b3);
        c2 = Ab(c2);
        var f2 = [];
        E2[d2 >> 2] = Ea2(f2);
        return a2(b3, c2, f2, e2);
      },
      t: function(a2, b3, c2, d2) {
        a2 = Bb[a2];
        b3 = M3(b3);
        c2 = Ab(c2);
        a2(b3, c2, null, d2);
      },
      g: qb,
      m: function(a2, b3) {
        var c2 = Db(a2, b3), d2 = c2[0];
        b3 = d2.name + "_$" + c2.slice(1).map(function(g2) {
          return g2.name;
        }).join("_") + "$";
        var e2 = Eb[b3];
        if (void 0 !== e2)
          return e2;
        var f2 = Array(a2 - 1);
        e2 = Cb((g2, k, m, l2) => {
          for (var n2 = 0, p2 = 0; p2 < a2 - 1; ++p2)
            f2[p2] = c2[p2 + 1].readValueFromPointer(l2 + n2), n2 += c2[p2 + 1].argPackAdvance;
          g2 = g2[k].apply(
            g2,
            f2
          );
          for (p2 = 0; p2 < a2 - 1; ++p2)
            c2[p2 + 1].ma && c2[p2 + 1].ma(f2[p2]);
          if (!d2.va)
            return d2.toWireType(m, g2);
        });
        return Eb[b3] = e2;
      },
      D: function(a2) {
        4 < a2 && (J3[a2].ga += 1);
      },
      r: function(a2) {
        var b3 = M3(a2);
        Wa(b3);
        qb(a2);
      },
      c: function() {
        x2("");
      },
      x: function(a2, b3, c2) {
        A.copyWithin(a2, b3, b3 + c2);
      },
      w: function(a2) {
        var b3 = A.length;
        a2 >>>= 0;
        if (2147483648 < a2)
          return false;
        for (var c2 = 1; 4 >= c2; c2 *= 2) {
          var d2 = b3 * (1 + 0.2 / c2);
          d2 = Math.min(d2, a2 + 100663296);
          var e2 = Math;
          d2 = Math.max(a2, d2);
          e2 = e2.min.call(e2, 2147483648, d2 + (65536 - d2 % 65536) % 65536);
          a: {
            try {
              fa2.grow(e2 - ia.byteLength + 65535 >>> 16);
              na();
              var f2 = 1;
              break a;
            } catch (g2) {
            }
            f2 = void 0;
          }
          if (f2)
            return true;
        }
        return false;
      },
      z: function() {
        return 52;
      },
      u: function() {
        return 70;
      },
      y: function(a2, b3, c2, d2) {
        for (var e2 = 0, f2 = 0; f2 < c2; f2++) {
          var g2 = E2[b3 >> 2], k = E2[b3 + 4 >> 2];
          b3 += 8;
          for (var m = 0; m < k; m++) {
            var l2 = A[g2 + m], n2 = Fb[a2];
            0 === l2 || 10 === l2 ? ((1 === a2 ? ea : v2)(z3(n2, 0)), n2.length = 0) : n2.push(l2);
          }
          e2 += k;
        }
        E2[d2 >> 2] = e2;
        return 0;
      }
    };
    (function() {
      function a2(e2) {
        h2.asm = e2.exports;
        fa2 = h2.asm.E;
        na();
        oa2 = h2.asm.J;
        qa.unshift(h2.asm.F);
        F--;
        h2.monitorRunDependencies && h2.monitorRunDependencies(F);
        0 == F && (null !== ta && (clearInterval(ta), ta = null), G3 && (e2 = G3, G3 = null, e2()));
      }
      function b3(e2) {
        a2(e2.instance);
      }
      function c2(e2) {
        return ya().then(function(f2) {
          return WebAssembly.instantiate(f2, d2);
        }).then(function(f2) {
          return f2;
        }).then(e2, function(f2) {
          v2("failed to asynchronously prepare wasm: " + f2);
          x2(f2);
        });
      }
      var d2 = { a: Jb };
      F++;
      h2.monitorRunDependencies && h2.monitorRunDependencies(F);
      if (h2.instantiateWasm)
        try {
          return h2.instantiateWasm(
            d2,
            a2
          );
        } catch (e2) {
          v2("Module.instantiateWasm callback failed with error: " + e2), ca2(e2);
        }
      (function() {
        return w2 || "function" != typeof WebAssembly.instantiateStreaming || ua2(H3) || "function" != typeof fetch ? c2(b3) : fetch(H3, { credentials: "same-origin" }).then(function(e2) {
          return WebAssembly.instantiateStreaming(e2, d2).then(b3, function(f2) {
            v2("wasm streaming compile failed: " + f2);
            v2("falling back to ArrayBuffer instantiation");
            return c2(b3);
          });
        });
      })().catch(ca2);
      return {};
    })();
    h2.___wasm_call_ctors = function() {
      return (h2.___wasm_call_ctors = h2.asm.F).apply(null, arguments);
    };
    var Ka = h2.___getTypeName = function() {
      return (Ka = h2.___getTypeName = h2.asm.G).apply(null, arguments);
    };
    h2.__embind_initialize_bindings = function() {
      return (h2.__embind_initialize_bindings = h2.asm.H).apply(null, arguments);
    };
    var Ib = h2._malloc = function() {
      return (Ib = h2._malloc = h2.asm.I).apply(null, arguments);
    }, S3 = h2._free = function() {
      return (S3 = h2._free = h2.asm.K).apply(null, arguments);
    };
    h2.dynCall_jiji = function() {
      return (h2.dynCall_jiji = h2.asm.L).apply(null, arguments);
    };
    var Kb2;
    G3 = function Lb() {
      Kb2 || Mb();
      Kb2 || (G3 = Lb);
    };
    function Mb() {
      function a2() {
        if (!Kb2 && (Kb2 = true, h2.calledRun = true, !ha2)) {
          za(qa);
          aa2(h2);
          if (h2.onRuntimeInitialized)
            h2.onRuntimeInitialized();
          if (h2.postRun)
            for ("function" == typeof h2.postRun && (h2.postRun = [h2.postRun]); h2.postRun.length; ) {
              var b3 = h2.postRun.shift();
              ra.unshift(b3);
            }
          za(ra);
        }
      }
      if (!(0 < F)) {
        if (h2.preRun)
          for ("function" == typeof h2.preRun && (h2.preRun = [h2.preRun]); h2.preRun.length; )
            sa2();
        za(pa2);
        0 < F || (h2.setStatus ? (h2.setStatus("Running..."), setTimeout(function() {
          setTimeout(function() {
            h2.setStatus("");
          }, 1);
          a2();
        }, 1)) : a2());
      }
    }
    if (h2.preInit)
      for ("function" == typeof h2.preInit && (h2.preInit = [h2.preInit]); 0 < h2.preInit.length; )
        h2.preInit.pop()();
    Mb();
    return loadYoga3.ready;
  };
})();
var yoga_wasm_base64_esm_default = loadYoga;

// node_modules/yoga-layout/dist/src/generated/YGEnums.js
var Align = function(Align2) {
  Align2[Align2["Auto"] = 0] = "Auto";
  Align2[Align2["FlexStart"] = 1] = "FlexStart";
  Align2[Align2["Center"] = 2] = "Center";
  Align2[Align2["FlexEnd"] = 3] = "FlexEnd";
  Align2[Align2["Stretch"] = 4] = "Stretch";
  Align2[Align2["Baseline"] = 5] = "Baseline";
  Align2[Align2["SpaceBetween"] = 6] = "SpaceBetween";
  Align2[Align2["SpaceAround"] = 7] = "SpaceAround";
  Align2[Align2["SpaceEvenly"] = 8] = "SpaceEvenly";
  return Align2;
}({});
var Dimension = function(Dimension2) {
  Dimension2[Dimension2["Width"] = 0] = "Width";
  Dimension2[Dimension2["Height"] = 1] = "Height";
  return Dimension2;
}({});
var Direction = function(Direction2) {
  Direction2[Direction2["Inherit"] = 0] = "Inherit";
  Direction2[Direction2["LTR"] = 1] = "LTR";
  Direction2[Direction2["RTL"] = 2] = "RTL";
  return Direction2;
}({});
var Display = function(Display2) {
  Display2[Display2["Flex"] = 0] = "Flex";
  Display2[Display2["None"] = 1] = "None";
  return Display2;
}({});
var Edge = function(Edge2) {
  Edge2[Edge2["Left"] = 0] = "Left";
  Edge2[Edge2["Top"] = 1] = "Top";
  Edge2[Edge2["Right"] = 2] = "Right";
  Edge2[Edge2["Bottom"] = 3] = "Bottom";
  Edge2[Edge2["Start"] = 4] = "Start";
  Edge2[Edge2["End"] = 5] = "End";
  Edge2[Edge2["Horizontal"] = 6] = "Horizontal";
  Edge2[Edge2["Vertical"] = 7] = "Vertical";
  Edge2[Edge2["All"] = 8] = "All";
  return Edge2;
}({});
var Errata = function(Errata2) {
  Errata2[Errata2["None"] = 0] = "None";
  Errata2[Errata2["StretchFlexBasis"] = 1] = "StretchFlexBasis";
  Errata2[Errata2["AbsolutePositioningIncorrect"] = 2] = "AbsolutePositioningIncorrect";
  Errata2[Errata2["AbsolutePercentAgainstInnerSize"] = 4] = "AbsolutePercentAgainstInnerSize";
  Errata2[Errata2["All"] = 2147483647] = "All";
  Errata2[Errata2["Classic"] = 2147483646] = "Classic";
  return Errata2;
}({});
var ExperimentalFeature = function(ExperimentalFeature2) {
  ExperimentalFeature2[ExperimentalFeature2["WebFlexBasis"] = 0] = "WebFlexBasis";
  return ExperimentalFeature2;
}({});
var FlexDirection = function(FlexDirection2) {
  FlexDirection2[FlexDirection2["Column"] = 0] = "Column";
  FlexDirection2[FlexDirection2["ColumnReverse"] = 1] = "ColumnReverse";
  FlexDirection2[FlexDirection2["Row"] = 2] = "Row";
  FlexDirection2[FlexDirection2["RowReverse"] = 3] = "RowReverse";
  return FlexDirection2;
}({});
var Gutter = function(Gutter2) {
  Gutter2[Gutter2["Column"] = 0] = "Column";
  Gutter2[Gutter2["Row"] = 1] = "Row";
  Gutter2[Gutter2["All"] = 2] = "All";
  return Gutter2;
}({});
var Justify = function(Justify2) {
  Justify2[Justify2["FlexStart"] = 0] = "FlexStart";
  Justify2[Justify2["Center"] = 1] = "Center";
  Justify2[Justify2["FlexEnd"] = 2] = "FlexEnd";
  Justify2[Justify2["SpaceBetween"] = 3] = "SpaceBetween";
  Justify2[Justify2["SpaceAround"] = 4] = "SpaceAround";
  Justify2[Justify2["SpaceEvenly"] = 5] = "SpaceEvenly";
  return Justify2;
}({});
var LogLevel = function(LogLevel2) {
  LogLevel2[LogLevel2["Error"] = 0] = "Error";
  LogLevel2[LogLevel2["Warn"] = 1] = "Warn";
  LogLevel2[LogLevel2["Info"] = 2] = "Info";
  LogLevel2[LogLevel2["Debug"] = 3] = "Debug";
  LogLevel2[LogLevel2["Verbose"] = 4] = "Verbose";
  LogLevel2[LogLevel2["Fatal"] = 5] = "Fatal";
  return LogLevel2;
}({});
var MeasureMode = function(MeasureMode2) {
  MeasureMode2[MeasureMode2["Undefined"] = 0] = "Undefined";
  MeasureMode2[MeasureMode2["Exactly"] = 1] = "Exactly";
  MeasureMode2[MeasureMode2["AtMost"] = 2] = "AtMost";
  return MeasureMode2;
}({});
var NodeType = function(NodeType2) {
  NodeType2[NodeType2["Default"] = 0] = "Default";
  NodeType2[NodeType2["Text"] = 1] = "Text";
  return NodeType2;
}({});
var Overflow = function(Overflow2) {
  Overflow2[Overflow2["Visible"] = 0] = "Visible";
  Overflow2[Overflow2["Hidden"] = 1] = "Hidden";
  Overflow2[Overflow2["Scroll"] = 2] = "Scroll";
  return Overflow2;
}({});
var PositionType = function(PositionType2) {
  PositionType2[PositionType2["Static"] = 0] = "Static";
  PositionType2[PositionType2["Relative"] = 1] = "Relative";
  PositionType2[PositionType2["Absolute"] = 2] = "Absolute";
  return PositionType2;
}({});
var Unit = function(Unit2) {
  Unit2[Unit2["Undefined"] = 0] = "Undefined";
  Unit2[Unit2["Point"] = 1] = "Point";
  Unit2[Unit2["Percent"] = 2] = "Percent";
  Unit2[Unit2["Auto"] = 3] = "Auto";
  return Unit2;
}({});
var Wrap = function(Wrap2) {
  Wrap2[Wrap2["NoWrap"] = 0] = "NoWrap";
  Wrap2[Wrap2["Wrap"] = 1] = "Wrap";
  Wrap2[Wrap2["WrapReverse"] = 2] = "WrapReverse";
  return Wrap2;
}({});
var constants = {
  ALIGN_AUTO: Align.Auto,
  ALIGN_FLEX_START: Align.FlexStart,
  ALIGN_CENTER: Align.Center,
  ALIGN_FLEX_END: Align.FlexEnd,
  ALIGN_STRETCH: Align.Stretch,
  ALIGN_BASELINE: Align.Baseline,
  ALIGN_SPACE_BETWEEN: Align.SpaceBetween,
  ALIGN_SPACE_AROUND: Align.SpaceAround,
  ALIGN_SPACE_EVENLY: Align.SpaceEvenly,
  DIMENSION_WIDTH: Dimension.Width,
  DIMENSION_HEIGHT: Dimension.Height,
  DIRECTION_INHERIT: Direction.Inherit,
  DIRECTION_LTR: Direction.LTR,
  DIRECTION_RTL: Direction.RTL,
  DISPLAY_FLEX: Display.Flex,
  DISPLAY_NONE: Display.None,
  EDGE_LEFT: Edge.Left,
  EDGE_TOP: Edge.Top,
  EDGE_RIGHT: Edge.Right,
  EDGE_BOTTOM: Edge.Bottom,
  EDGE_START: Edge.Start,
  EDGE_END: Edge.End,
  EDGE_HORIZONTAL: Edge.Horizontal,
  EDGE_VERTICAL: Edge.Vertical,
  EDGE_ALL: Edge.All,
  ERRATA_NONE: Errata.None,
  ERRATA_STRETCH_FLEX_BASIS: Errata.StretchFlexBasis,
  ERRATA_ABSOLUTE_POSITIONING_INCORRECT: Errata.AbsolutePositioningIncorrect,
  ERRATA_ABSOLUTE_PERCENT_AGAINST_INNER_SIZE: Errata.AbsolutePercentAgainstInnerSize,
  ERRATA_ALL: Errata.All,
  ERRATA_CLASSIC: Errata.Classic,
  EXPERIMENTAL_FEATURE_WEB_FLEX_BASIS: ExperimentalFeature.WebFlexBasis,
  FLEX_DIRECTION_COLUMN: FlexDirection.Column,
  FLEX_DIRECTION_COLUMN_REVERSE: FlexDirection.ColumnReverse,
  FLEX_DIRECTION_ROW: FlexDirection.Row,
  FLEX_DIRECTION_ROW_REVERSE: FlexDirection.RowReverse,
  GUTTER_COLUMN: Gutter.Column,
  GUTTER_ROW: Gutter.Row,
  GUTTER_ALL: Gutter.All,
  JUSTIFY_FLEX_START: Justify.FlexStart,
  JUSTIFY_CENTER: Justify.Center,
  JUSTIFY_FLEX_END: Justify.FlexEnd,
  JUSTIFY_SPACE_BETWEEN: Justify.SpaceBetween,
  JUSTIFY_SPACE_AROUND: Justify.SpaceAround,
  JUSTIFY_SPACE_EVENLY: Justify.SpaceEvenly,
  LOG_LEVEL_ERROR: LogLevel.Error,
  LOG_LEVEL_WARN: LogLevel.Warn,
  LOG_LEVEL_INFO: LogLevel.Info,
  LOG_LEVEL_DEBUG: LogLevel.Debug,
  LOG_LEVEL_VERBOSE: LogLevel.Verbose,
  LOG_LEVEL_FATAL: LogLevel.Fatal,
  MEASURE_MODE_UNDEFINED: MeasureMode.Undefined,
  MEASURE_MODE_EXACTLY: MeasureMode.Exactly,
  MEASURE_MODE_AT_MOST: MeasureMode.AtMost,
  NODE_TYPE_DEFAULT: NodeType.Default,
  NODE_TYPE_TEXT: NodeType.Text,
  OVERFLOW_VISIBLE: Overflow.Visible,
  OVERFLOW_HIDDEN: Overflow.Hidden,
  OVERFLOW_SCROLL: Overflow.Scroll,
  POSITION_TYPE_STATIC: PositionType.Static,
  POSITION_TYPE_RELATIVE: PositionType.Relative,
  POSITION_TYPE_ABSOLUTE: PositionType.Absolute,
  UNIT_UNDEFINED: Unit.Undefined,
  UNIT_POINT: Unit.Point,
  UNIT_PERCENT: Unit.Percent,
  UNIT_AUTO: Unit.Auto,
  WRAP_NO_WRAP: Wrap.NoWrap,
  WRAP_WRAP: Wrap.Wrap,
  WRAP_WRAP_REVERSE: Wrap.WrapReverse
};
var YGEnums_default = constants;

// node_modules/yoga-layout/dist/src/wrapAssembly.js
function wrapAssembly(lib) {
  function patch(prototype, name, fn3) {
    const original = prototype[name];
    prototype[name] = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return fn3.call(this, original, ...args);
    };
  }
  for (const fnName of ["setPosition", "setMargin", "setFlexBasis", "setWidth", "setHeight", "setMinWidth", "setMinHeight", "setMaxWidth", "setMaxHeight", "setPadding", "setGap"]) {
    const methods = {
      [Unit.Point]: lib.Node.prototype[fnName],
      [Unit.Percent]: lib.Node.prototype[`${fnName}Percent`],
      [Unit.Auto]: lib.Node.prototype[`${fnName}Auto`]
    };
    patch(lib.Node.prototype, fnName, function(original) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      const value = args.pop();
      let unit, asNumber;
      if (value === "auto") {
        unit = Unit.Auto;
        asNumber = void 0;
      } else if (typeof value === "object") {
        unit = value.unit;
        asNumber = value.valueOf();
      } else {
        unit = typeof value === "string" && value.endsWith("%") ? Unit.Percent : Unit.Point;
        asNumber = parseFloat(value);
        if (value !== void 0 && !Number.isNaN(value) && Number.isNaN(asNumber)) {
          throw new Error(`Invalid value ${value} for ${fnName}`);
        }
      }
      if (!methods[unit])
        throw new Error(`Failed to execute "${fnName}": Unsupported unit '${value}'`);
      if (asNumber !== void 0) {
        return methods[unit].call(this, ...args, asNumber);
      } else {
        return methods[unit].call(this, ...args);
      }
    });
  }
  function wrapMeasureFunction(measureFunction) {
    return lib.MeasureCallback.implement({
      measure: function() {
        const {
          width,
          height
        } = measureFunction(...arguments);
        return {
          width: width ?? NaN,
          height: height ?? NaN
        };
      }
    });
  }
  patch(lib.Node.prototype, "setMeasureFunc", function(original, measureFunc) {
    if (measureFunc) {
      return original.call(this, wrapMeasureFunction(measureFunc));
    } else {
      return this.unsetMeasureFunc();
    }
  });
  function wrapDirtiedFunc(dirtiedFunction) {
    return lib.DirtiedCallback.implement({
      dirtied: dirtiedFunction
    });
  }
  patch(lib.Node.prototype, "setDirtiedFunc", function(original, dirtiedFunc) {
    original.call(this, wrapDirtiedFunc(dirtiedFunc));
  });
  patch(lib.Config.prototype, "free", function() {
    lib.Config.destroy(this);
  });
  patch(lib.Node, "create", (_3, config) => {
    return config ? lib.Node.createWithConfig(config) : lib.Node.createDefault();
  });
  patch(lib.Node.prototype, "free", function() {
    lib.Node.destroy(this);
  });
  patch(lib.Node.prototype, "freeRecursive", function() {
    for (let t2 = 0, T3 = this.getChildCount(); t2 < T3; ++t2) {
      this.getChild(0).freeRecursive();
    }
    this.free();
  });
  patch(lib.Node.prototype, "calculateLayout", function(original) {
    let width = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : NaN;
    let height = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NaN;
    let direction = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Direction.LTR;
    return original.call(this, width, height, direction);
  });
  return {
    Config: lib.Config,
    Node: lib.Node,
    ...YGEnums_default
  };
}

// node_modules/yoga-layout/dist/src/load.js
async function loadYoga2() {
  return wrapAssembly(await yoga_wasm_base64_esm_default());
}

// node_modules/@pmndrs/uikit/dist/clipping.js
var dotLt45deg = Math.cos(45 / 180 * Math.PI);
var helperPlanes = [new Plane(), new Plane(), new Plane(), new Plane()];
var positionHelper = new Vector3();
var ClippingRect = class {
  constructor(globalMatrix, centerX, centerY, width, height) {
    __publicField(this, "planes");
    __publicField(this, "facePlane");
    __publicField(this, "originalCenter");
    this.originalCenter = new Vector3(centerX, centerY, 0).applyMatrix4(globalMatrix);
    this.facePlane = new Plane(new Vector3(0, 0, 1), 0).applyMatrix4(globalMatrix);
    const halfWidth = width / 2;
    const halfHeight = height / 2;
    const top = centerY + halfHeight;
    const right = centerX + halfWidth;
    const bottom = -centerY + halfHeight;
    const left = -centerX + halfWidth;
    this.planes = [
      new Plane(new Vector3(0, -1, 0), bottom).applyMatrix4(globalMatrix),
      new Plane(new Vector3(-1, 0, 0), left).applyMatrix4(globalMatrix),
      new Plane(new Vector3(0, 1, 0), top).applyMatrix4(globalMatrix),
      new Plane(new Vector3(1, 0, 0), right).applyMatrix4(globalMatrix)
    ];
  }
  min({ planes }) {
    for (let i2 = 0; i2 < 4; i2++) {
      const p1 = this.facePlane;
      const p2 = planes[i2];
      const n1n2DotProduct = p1.normal.dot(p2.normal);
      if (Math.abs(n1n2DotProduct) > 0.99) {
        return this;
      }
      const helperPlane = helperPlanes[i2];
      if (Math.abs(n1n2DotProduct) < 0.01) {
        helperPlane.copy(p2);
        continue;
      }
      helperPlane.normal.crossVectors(p1.normal, p2.normal).normalize().cross(p1.normal).negate();
      const divisor = 1 - n1n2DotProduct * n1n2DotProduct;
      const c1 = (p1.constant - p2.constant * n1n2DotProduct) / divisor;
      const c2 = (p2.constant - p1.constant * n1n2DotProduct) / divisor;
      positionHelper.copy(p1.normal).multiplyScalar(c1).addScaledVector(p2.normal, c2);
      helperPlane.constant = -positionHelper.dot(helperPlane.normal);
    }
    let indexOffset = 0;
    const firstPlaneNormal = this.planes[0].normal;
    while (helperPlanes[indexOffset].normal.dot(firstPlaneNormal) > dotLt45deg) {
      break;
    }
    for (let i2 = 0; i2 < 4; i2++) {
      const plane = this.planes[i2];
      const otherPlaneIndex = (i2 + indexOffset) % 4;
      if (helperPlanes[otherPlaneIndex].distanceToPoint(this.originalCenter) < plane.distanceToPoint(this.originalCenter)) {
        plane.copy(planes[otherPlaneIndex]);
      }
    }
    return this;
  }
  toArray(array, offset) {
    for (let i2 = 0; i2 < 4; i2++) {
      const { normal, constant } = this.planes[i2];
      normal.toArray(array, offset);
      array[offset + 3] = constant;
      offset += 4;
    }
  }
};
var helperPoints = [new Vector3(), new Vector3(), new Vector3(), new Vector3()];
var multiplier = [
  [-0.5, -0.5],
  [0.5, -0.5],
  [0.5, 0.5],
  [-0.5, 0.5]
];
function computedIsClipped(parentClippingRect, globalMatrix, size, pixelSizeSignal) {
  return w(() => {
    if (size.value == null) {
      return true;
    }
    const global2 = globalMatrix.value;
    const rect = parentClippingRect == null ? void 0 : parentClippingRect.value;
    if (rect == null || global2 == null) {
      return false;
    }
    const [width, height] = size.value;
    const pixelSize = pixelSizeSignal.value;
    for (let i2 = 0; i2 < 4; i2++) {
      const [mx2, my] = multiplier[i2];
      helperPoints[i2].set(mx2 * pixelSize * width, my * pixelSize * height, 0).applyMatrix4(global2);
    }
    const { planes } = rect;
    let allOutside;
    for (let planeIndex = 0; planeIndex < 4; planeIndex++) {
      const clippingPlane = planes[planeIndex];
      allOutside = true;
      for (let pointIndex = 0; pointIndex < 4; pointIndex++) {
        const point = helperPoints[pointIndex];
        if (clippingPlane.distanceToPoint(point) >= 0) {
          allOutside = false;
        }
      }
      if (allOutside) {
        return true;
      }
    }
    return false;
  });
}
function computedClippingRect(globalMatrix, { overflow, borderInset, size }, pixelSizeSignal, parentClippingRect) {
  return w(() => {
    const global2 = globalMatrix.value;
    if (global2 == null || overflow.value === Overflow.Visible) {
      return parentClippingRect == null ? void 0 : parentClippingRect.value;
    }
    if (size.value == null || borderInset.value == null) {
      return void 0;
    }
    const [width, height] = size.value;
    const [top, right, bottom, left] = borderInset.value;
    const pixelSize = pixelSizeSignal.value;
    const rect = new ClippingRect(global2, (right - left) * pixelSize / 2, (top - bottom) * pixelSize / 2, (width - left - right) * pixelSize, (height - top - bottom) * pixelSize);
    if ((parentClippingRect == null ? void 0 : parentClippingRect.value) != null) {
      rect.min(parentClippingRect.value);
    }
    return rect;
  });
}
var NoClippingPlane = new Plane(new Vector3(-1, 0, 0), Number.MAX_SAFE_INTEGER);
var defaultClippingData = new Float32Array(16);
for (let i2 = 0; i2 < 4; i2++) {
  NoClippingPlane.normal.toArray(defaultClippingData, i2 * 4);
  defaultClippingData[i2 * 4 + 3] = NoClippingPlane.constant;
}
function createGlobalClippingPlanes(root, clippingRect, initializers) {
  const planes = [new Plane(), new Plane(), new Plane(), new Plane()];
  const updateClippingPlanes = () => {
    var _a;
    if (root.object.current == null) {
      return;
    }
    const localPlanes = (_a = clippingRect == null ? void 0 : clippingRect.value) == null ? void 0 : _a.planes;
    if (localPlanes == null) {
      for (let i2 = 0; i2 < 4; i2++) {
        planes[i2].copy(NoClippingPlane);
      }
      return;
    }
    for (let i2 = 0; i2 < 4; i2++) {
      planes[i2].copy(localPlanes[i2]).applyMatrix4(root.object.current.matrixWorld);
    }
  };
  initializers.push(() => {
    root.onFrameSet.add(updateClippingPlanes);
    return () => root.onFrameSet.delete(updateClippingPlanes);
  });
  return planes;
}

// node_modules/@pmndrs/uikit/dist/allocation/sorted-buckets.js
function assureBucketExists(buckets, bucketIndex) {
  while (bucketIndex >= buckets.length) {
    let offset = 0;
    let missingSpace = 0;
    if (buckets.length > 0) {
      const prevBucket = buckets[buckets.length - 1];
      offset += prevBucket.offset + prevBucket.elements.length;
      missingSpace = Math.min(0, prevBucket.missingSpace);
      prevBucket.missingSpace -= missingSpace;
    }
    buckets.push({
      add: [],
      missingSpace,
      offset,
      elements: []
    });
  }
}
function resizeSortedBucketsSpace(buckets, oldSize, newSize) {
  assureBucketExists(buckets, 0);
  const lastBucket = buckets[buckets.length - 1];
  lastBucket.missingSpace += oldSize - newSize;
}
function addToSortedBuckets(buckets, bucketIndex, element, activateElement) {
  assureBucketExists(buckets, bucketIndex);
  const bucket = buckets[bucketIndex];
  bucket.missingSpace += 1;
  if (bucket.missingSpace <= 0) {
    activateElement(element, bucket, bucket.elements.length);
    bucket.elements.push(element);
    return false;
  }
  bucket.add.push(element);
  return true;
}
function removeFromSortedBuckets(buckets, bucketIndex, element, elementIndex, activateElement, clearBufferAt, setElementIndex, bufferCopyWithin) {
  if (bucketIndex >= buckets.length) {
    throw new Error(`no bucket at index ${bucketIndex}`);
  }
  const bucket = buckets[bucketIndex];
  bucket.missingSpace -= 1;
  const addIndex = bucket.add.indexOf(element);
  if (addIndex != -1) {
    bucket.add.splice(addIndex, 1);
    return false;
  }
  if (elementIndex == null || elementIndex >= bucket.elements.length) {
    throw new Error(`no element at index ${elementIndex}`);
  }
  if (bucket.add.length > 0) {
    const newElement = bucket.add.shift();
    bucket.elements[elementIndex] = newElement;
    activateElement(newElement, bucket, elementIndex);
    return false;
  }
  const offset = bucket.offset;
  const lastIndexInBucket = bucket.elements.length - 1;
  if (lastIndexInBucket != elementIndex) {
    const startIndex = offset + lastIndexInBucket;
    const targetIndex = offset + elementIndex;
    bufferCopyWithin(targetIndex, startIndex, startIndex + 1);
    const swapElement = bucket.elements[lastIndexInBucket];
    bucket.elements[elementIndex] = swapElement;
    setElementIndex(swapElement, elementIndex);
  }
  clearBufferAt(offset + lastIndexInBucket);
  bucket.elements.length -= 1;
  if (bucketIndex < buckets.length - 1) {
    return true;
  }
  let currentBucket = bucket;
  while (currentBucket.elements.length === 0 && currentBucket.add.length == 0 && bucketIndex > 0) {
    const prevBucket = buckets[bucketIndex - 1];
    prevBucket.missingSpace += currentBucket.missingSpace;
    currentBucket = buckets[--bucketIndex];
  }
  buckets.length = bucketIndex + 1;
  return false;
}
function updateSortedBucketsAllocation(buckets, activateElement, bufferCopyWithin) {
  let bucketsLength = buckets.length;
  let lastBucketWithElements = -1;
  for (let i2 = 0; i2 < bucketsLength; i2++) {
    const bucket = buckets[i2];
    if (bucket.elements.length + bucket.add.length > 0) {
      lastBucketWithElements = i2;
    }
    const lastBucket = i2 === bucketsLength - 1;
    if (!lastBucket && bucket.missingSpace === 0) {
      continue;
    }
    const hasSpace = bucket.missingSpace < 0;
    for (let ii2 = i2 - 1; ii2 >= 0; ii2--) {
      const otherBucket = buckets[ii2];
      if (otherBucket.missingSpace === 0) {
        continue;
      }
      const otherHasSpace = otherBucket.missingSpace < 0;
      if (otherHasSpace && (lastBucket || hasSpace)) {
        shiftLeft(buckets, bufferCopyWithin, ii2, i2, Math.abs(otherBucket.missingSpace));
        continue;
      }
      if (!hasSpace && !otherHasSpace) {
        continue;
      }
      const shiftBy = Math.min(Math.abs(otherBucket.missingSpace), Math.abs(bucket.missingSpace));
      if (hasSpace) {
        shiftRight(buckets, bufferCopyWithin, ii2, i2, shiftBy);
      } else {
        shiftLeft(buckets, bufferCopyWithin, ii2, i2, shiftBy);
      }
    }
  }
  const newLastBucket = buckets[lastBucketWithElements];
  for (let i2 = lastBucketWithElements + 1; i2 < bucketsLength; i2++) {
    newLastBucket.missingSpace += buckets[i2].missingSpace;
  }
  bucketsLength = buckets.length = lastBucketWithElements + 1;
  for (let i2 = 0; i2 < bucketsLength; i2++) {
    const bucket = buckets[i2];
    const { elements, add } = bucket;
    const addLength = add.length;
    for (let ii2 = 0; ii2 < addLength; ii2++) {
      const element = add[ii2];
      activateElement(element, bucket, elements.length);
      elements.push(element);
    }
    add.length = 0;
  }
}
function shiftLeft(buckets, bufferCopyWithin, startIndexIncl, endIndexIncl, shiftBy) {
  const endBucket = buckets[endIndexIncl];
  const startIndex = buckets[startIndexIncl + 1].offset;
  bufferCopyWithin(startIndex - shiftBy, startIndex, endBucket.offset + endBucket.elements.length);
  const startBucket = buckets[startIndexIncl];
  startBucket.missingSpace += shiftBy;
  endBucket.missingSpace -= shiftBy;
  for (let i2 = startIndexIncl + 1; i2 <= endIndexIncl; i2++) {
    buckets[i2].offset -= shiftBy;
  }
}
function shiftRight(buckets, bufferCopyWithin, startIndexIncl, endIndexIncl, shiftBy) {
  const endBucket = buckets[endIndexIncl];
  const startIndex = buckets[startIndexIncl + 1].offset;
  bufferCopyWithin(startIndex + shiftBy, startIndex, endBucket.offset + endBucket.elements.length);
  const startBucket = buckets[startIndexIncl];
  startBucket.missingSpace -= shiftBy;
  endBucket.missingSpace += shiftBy;
  for (let i2 = startIndexIncl + 1; i2 <= endIndexIncl; i2++) {
    buckets[i2].offset += shiftBy;
  }
}

// node_modules/@pmndrs/uikit/dist/flex/setter.js
function convertEnum(lut, input, defaultValue) {
  if (input == null) {
    return defaultValue;
  }
  const resolvedValue = lut[input];
  if (resolvedValue == null) {
    throw new Error(`unexpected value ${input}, expected ${Object.keys(lut).join(", ")}`);
  }
  return resolvedValue;
}
var POSITION_TYPE_LUT = {
  "static": 0,
  "relative": 1,
  "absolute": 2
};
var ALIGN_LUT = {
  "auto": 0,
  "flex-start": 1,
  "center": 2,
  "flex-end": 3,
  "stretch": 4,
  "baseline": 5,
  "space-between": 6,
  "space-around": 7,
  "space-evenly": 8
};
var FLEX_DIRECTION_LUT = {
  "column": 0,
  "column-reverse": 1,
  "row": 2,
  "row-reverse": 3
};
var WRAP_LUT = {
  "no-wrap": 0,
  "wrap": 1,
  "wrap-reverse": 2
};
var JUSTIFY_LUT = {
  "flex-start": 0,
  "center": 1,
  "flex-end": 2,
  "space-between": 3,
  "space-around": 4,
  "space-evenly": 5
};
var OVERFLOW_LUT = {
  "visible": 0,
  "hidden": 1,
  "scroll": 2
};
var DISPLAY_LUT = {
  "flex": 0,
  "none": 1
};
var setter = {
  positionType: (node, input) => node.setPositionType(convertEnum(POSITION_TYPE_LUT, input, 1)),
  positionTop: (node, input) => node.setPosition(1, input ?? NaN),
  positionLeft: (node, input) => node.setPosition(0, input ?? NaN),
  positionRight: (node, input) => node.setPosition(2, input ?? NaN),
  positionBottom: (node, input) => node.setPosition(3, input ?? NaN),
  alignContent: (node, input) => node.setAlignContent(convertEnum(ALIGN_LUT, input, 4)),
  alignItems: (node, input) => node.setAlignItems(convertEnum(ALIGN_LUT, input, 4)),
  alignSelf: (node, input) => node.setAlignSelf(convertEnum(ALIGN_LUT, input, 0)),
  flexDirection: (node, input) => node.setFlexDirection(convertEnum(FLEX_DIRECTION_LUT, input, 2)),
  flexWrap: (node, input) => node.setFlexWrap(convertEnum(WRAP_LUT, input, 0)),
  justifyContent: (node, input) => node.setJustifyContent(convertEnum(JUSTIFY_LUT, input, 0)),
  marginTop: (node, input) => node.setMargin(1, input ?? NaN),
  marginLeft: (node, input) => node.setMargin(0, input ?? NaN),
  marginRight: (node, input) => node.setMargin(2, input ?? NaN),
  marginBottom: (node, input) => node.setMargin(3, input ?? NaN),
  flexBasis: (node, input) => node.setFlexBasis(input ?? NaN),
  flexGrow: (node, input) => node.setFlexGrow(input ?? 0),
  flexShrink: (node, input) => node.setFlexShrink(input ?? 1),
  width: (node, input) => node.setWidth(input ?? NaN),
  height: (node, input) => node.setHeight(input ?? NaN),
  minWidth: (node, input) => node.setMinWidth(input ?? NaN),
  minHeight: (node, input) => node.setMinHeight(input ?? NaN),
  maxWidth: (node, input) => node.setMaxWidth(input ?? NaN),
  maxHeight: (node, input) => node.setMaxHeight(input ?? NaN),
  aspectRatio: (node, input) => node.setAspectRatio(input ?? NaN),
  borderTopWidth: (node, input) => node.setBorder(1, input ?? NaN),
  borderLeftWidth: (node, input) => node.setBorder(0, input ?? NaN),
  borderRightWidth: (node, input) => node.setBorder(2, input ?? NaN),
  borderBottomWidth: (node, input) => node.setBorder(3, input ?? NaN),
  overflow: (node, input) => node.setOverflow(convertEnum(OVERFLOW_LUT, input, 0)),
  display: (node, input) => node.setDisplay(convertEnum(DISPLAY_LUT, input, 0)),
  paddingTop: (node, input) => node.setPadding(1, input ?? NaN),
  paddingLeft: (node, input) => node.setPadding(0, input ?? NaN),
  paddingRight: (node, input) => node.setPadding(2, input ?? NaN),
  paddingBottom: (node, input) => node.setPadding(3, input ?? NaN),
  gapRow: (node, input) => node.setGap(1, input ?? NaN),
  gapColumn: (node, input) => node.setGap(0, input ?? NaN)
};

// node_modules/@pmndrs/uikit/dist/flex/yoga.js
var PointScaleFactor = 100;
function createDefaultConfig(Config) {
  const config = Config.create();
  config.setUseWebDefaults(true);
  config.setPointScaleFactor(PointScaleFactor);
  config.setExperimentalFeatureEnabled(ExperimentalFeature.WebFlexBasis, true);
  return config;
}
var create2 = d(void 0);
loadYoga2().then(({ Node: Node2, Config }) => {
  const config = createDefaultConfig(Config);
  create2.value = () => Node2.create(config);
}).catch(console.error);
var createYogaNode = () => {
  var _a;
  return (_a = create2.value) == null ? void 0 : _a.call(create2);
};

// node_modules/@pmndrs/uikit/dist/flex/node.js
function hasImmediateProperty(key) {
  if (key === "measureFunc") {
    return true;
  }
  return key in setter;
}
function createFlexNodeState() {
  const scrollable = d([false, false]);
  return {
    size: d(void 0),
    relativeCenter: d(void 0),
    borderInset: d(void 0),
    overflow: d(Overflow.Visible),
    displayed: d(false),
    scrollable,
    paddingInset: d(void 0),
    maxScrollPosition: d([void 0, void 0])
  };
}
var FlexNode = class {
  constructor(state, propertiesSignal, requestCalculateLayout, object, objectVisibileDefault, subscriptions) {
    __publicField(this, "state");
    __publicField(this, "propertiesSignal");
    __publicField(this, "requestCalculateLayout");
    __publicField(this, "object");
    __publicField(this, "objectVisibileDefault");
    __publicField(this, "children", []);
    __publicField(this, "yogaNode");
    __publicField(this, "layoutChangeListeners", /* @__PURE__ */ new Set());
    __publicField(this, "customLayouting");
    __publicField(this, "active", d(false));
    __publicField(this, "objectVisible", false);
    this.state = state;
    this.propertiesSignal = propertiesSignal;
    this.requestCalculateLayout = requestCalculateLayout;
    this.object = object;
    this.objectVisibileDefault = objectVisibileDefault;
    subscriptions.push(E(() => {
      const yogaNode = createYogaNode();
      if (yogaNode == null) {
        return;
      }
      this.yogaNode = yogaNode;
      this.active.value = true;
      this.updateMeasureFunction();
      return () => {
        var _a, _b, _c;
        (_b = (_a = this.yogaNode) == null ? void 0 : _a.getParent()) == null ? void 0 : _b.removeChild(this.yogaNode);
        (_c = this.yogaNode) == null ? void 0 : _c.free();
      };
    }));
    setupImmediateProperties(propertiesSignal, this.active, hasImmediateProperty, (key, value) => {
      setter[key](this.yogaNode, value);
      this.requestCalculateLayout();
    }, subscriptions);
  }
  setCustomLayouting(layouting) {
    this.customLayouting = layouting;
    this.updateMeasureFunction();
  }
  updateMeasureFunction() {
    if (this.customLayouting == null || !this.active.value) {
      return;
    }
    setMeasureFunc(this.yogaNode, this.customLayouting.measure);
    this.requestCalculateLayout();
  }
  /**
   * use requestCalculateLayout instead
   */
  calculateLayout() {
    if (this.yogaNode == null) {
      return;
    }
    this.commit(this.yogaNode.getFlexDirection());
    this.yogaNode.calculateLayout(void 0, void 0);
    r(() => this.updateMeasurements(true, void 0, void 0));
  }
  addChild(node) {
    this.children.push(node);
    this.requestCalculateLayout();
  }
  removeChild(node) {
    const i2 = this.children.indexOf(node);
    if (i2 === -1) {
      return;
    }
    this.children.splice(i2, 1);
    this.requestCalculateLayout();
  }
  commit(parentDirection) {
    var _a;
    if (this.yogaNode == null) {
      throw new Error(`commit cannot be called without a yoga node`);
    }
    const parentDirectionVertical = parentDirection === FlexDirection.Column || parentDirection === FlexDirection.ColumnReverse;
    const properties = this.propertiesSignal.peek();
    if (this.customLayouting != null && n(() => properties.read(parentDirectionVertical ? "minHeight" : "minWidth", void 0)) === void 0) {
      this.yogaNode[parentDirectionVertical ? "setMinHeight" : "setMinWidth"](parentDirectionVertical ? this.customLayouting.minHeight : this.customLayouting.minWidth);
    }
    if (n(() => properties.read("flexShrink", void 0)) == null) {
      const hasHeight = n(() => properties.read("height", void 0)) != null;
      this.yogaNode.setFlexShrink(hasHeight && parentDirectionVertical ? 0 : void 0);
    }
    let groupChildren;
    this.children.sort((child1, child2) => {
      var _a2, _b;
      groupChildren ?? (groupChildren = (_b = (_a2 = child1.object.current) == null ? void 0 : _a2.parent) == null ? void 0 : _b.children);
      if (groupChildren == null) {
        return 0;
      }
      const group1 = child1.object.current;
      const group2 = child2.object.current;
      if (group1 == null || group2 == null) {
        return 0;
      }
      const i1 = groupChildren.indexOf(group1);
      if (i1 === -1) {
        throw new Error(`parent mismatch`);
      }
      const i22 = groupChildren.indexOf(group2);
      if (i22 === -1) {
        throw new Error(`parent mismatch`);
      }
      return i1 - i22;
    });
    let i2 = 0;
    let oldChildNode = this.yogaNode.getChild(i2);
    let correctChild = this.children[i2];
    while (correctChild != null || oldChildNode != null) {
      if (correctChild != null && oldChildNode != null && yogaNodeEqual(oldChildNode, assertNodeNotNull(correctChild.yogaNode))) {
        correctChild = this.children[++i2];
        oldChildNode = this.yogaNode.getChild(i2);
        continue;
      }
      if (oldChildNode != null) {
        this.yogaNode.removeChild(oldChildNode);
      }
      if (correctChild != null) {
        const node = assertNodeNotNull(correctChild.yogaNode);
        (_a = node.getParent()) == null ? void 0 : _a.removeChild(node);
        this.yogaNode.insertChild(node, i2);
        correctChild = this.children[++i2];
      }
      oldChildNode = this.yogaNode.getChild(i2);
    }
    const childrenLength = this.children.length;
    for (let i3 = 0; i3 < childrenLength; i3++) {
      this.children[i3].commit(this.yogaNode.getFlexDirection());
    }
    this.objectVisible = this.objectVisibileDefault || this.children.some((child) => child.objectVisible);
    if (this.object.current != null) {
      this.object.current.visible = this.objectVisible;
    }
  }
  updateMeasurements(displayed, parentWidth, parentHeight) {
    if (this.yogaNode == null) {
      throw new Error(`update measurements cannot be called without a yoga node`);
    }
    this.state.overflow.value = this.yogaNode.getOverflow();
    displayed && (displayed = this.yogaNode.getDisplay() === Display.Flex);
    this.state.displayed.value = displayed;
    const width = this.yogaNode.getComputedWidth();
    const height = this.yogaNode.getComputedHeight();
    updateVector2Signal(this.state.size, width, height);
    parentWidth ?? (parentWidth = width);
    parentHeight ?? (parentHeight = height);
    const x2 = this.yogaNode.getComputedLeft();
    const y3 = this.yogaNode.getComputedTop();
    const relativeCenterX = x2 + width * 0.5 - parentWidth * 0.5;
    const relativeCenterY = -(y3 + height * 0.5 - parentHeight * 0.5);
    updateVector2Signal(this.state.relativeCenter, relativeCenterX, relativeCenterY);
    const paddingTop = this.yogaNode.getComputedPadding(Edge.Top);
    const paddingLeft = this.yogaNode.getComputedPadding(Edge.Left);
    const paddingRight = this.yogaNode.getComputedPadding(Edge.Right);
    const paddingBottom = this.yogaNode.getComputedPadding(Edge.Bottom);
    updateInsetSignal(this.state.paddingInset, paddingTop, paddingRight, paddingBottom, paddingLeft);
    const borderTop = this.yogaNode.getComputedBorder(Edge.Top);
    const borderRight = this.yogaNode.getComputedBorder(Edge.Right);
    const borderBottom = this.yogaNode.getComputedBorder(Edge.Bottom);
    const borderLeft = this.yogaNode.getComputedBorder(Edge.Left);
    updateInsetSignal(this.state.borderInset, borderTop, borderRight, borderBottom, borderLeft);
    for (const layoutChangeListener of this.layoutChangeListeners) {
      layoutChangeListener();
    }
    const childrenLength = this.children.length;
    let maxContentWidth = 0;
    let maxContentHeight = 0;
    for (let i2 = 0; i2 < childrenLength; i2++) {
      const [contentWidth, contentHeight] = this.children[i2].updateMeasurements(displayed, width, height);
      maxContentWidth = Math.max(maxContentWidth, contentWidth);
      maxContentHeight = Math.max(maxContentHeight, contentHeight);
    }
    maxContentWidth -= borderLeft;
    maxContentHeight -= borderTop;
    if (this.state.overflow.value === Overflow.Scroll) {
      maxContentWidth += paddingRight;
      maxContentHeight += paddingLeft;
      const widthWithoutBorder = width - borderLeft - borderRight;
      const heightWithoutBorder = height - borderTop - borderBottom;
      const maxScrollX = maxContentWidth - widthWithoutBorder;
      const maxScrollY = maxContentHeight - heightWithoutBorder;
      const xScrollable = maxScrollX > 0.5;
      const yScrollable = maxScrollY > 0.5;
      updateVector2Signal(this.state.maxScrollPosition, xScrollable ? maxScrollX : void 0, yScrollable ? maxScrollY : void 0);
      updateVector2Signal(this.state.scrollable, xScrollable, yScrollable);
    } else {
      updateVector2Signal(this.state.maxScrollPosition, void 0, void 0);
      updateVector2Signal(this.state.scrollable, false, false);
    }
    const overflowVisible = this.state.overflow.value === Overflow.Visible;
    return [
      x2 + Math.max(width, overflowVisible ? maxContentWidth : 0),
      y3 + Math.max(height, overflowVisible ? maxContentHeight : 0)
    ];
  }
  addLayoutChangeListener(listener) {
    this.layoutChangeListeners.add(listener);
    return () => void this.layoutChangeListeners.delete(listener);
  }
};
function setMeasureFunc(node, func) {
  if (func == null) {
    node.setMeasureFunc(null);
    return;
  }
  node.setMeasureFunc((width, wMode, height, hMode) => {
    const result = func(width, wMode, height, hMode);
    return {
      width: Math.ceil(result.width * PointScaleFactor + 1) / PointScaleFactor,
      height: Math.ceil(result.height * PointScaleFactor + 1) / PointScaleFactor
    };
  });
  node.markDirty();
}
function updateVector2Signal(signal, x2, y3) {
  if (signal.value != null) {
    const [oldX, oldY] = signal.value;
    if (oldX === x2 && oldY === y3) {
      return;
    }
  }
  signal.value = [x2, y3];
}
function updateInsetSignal(signal, top, right, bottom, left) {
  if (signal.value != null) {
    const [oldTop, oldRight, oldBottom, oldLeft] = signal.value;
    if (oldTop == top && oldRight == right && oldBottom == bottom && oldLeft == left) {
      return;
    }
  }
  signal.value = [top, right, bottom, left];
}
function assertNodeNotNull(val) {
  if (val == null) {
    throw new Error(`commit cannot be called with a children that miss a yoga node`);
  }
  return val;
}
function yogaNodeEqual(n1, n2) {
  return n1["M"]["O"] === n2["M"]["O"];
}

// node_modules/@pmndrs/uikit/dist/active.js
function addActiveHandlers(target, style, properties, defaultProperties, activeSignal) {
  let activePropertiesExist = false;
  traverseProperties(style, defaultProperties, properties, (p2) => {
    if ("active" in p2) {
      activePropertiesExist = true;
    }
  });
  if (!activePropertiesExist && (style == null ? void 0 : style.onActiveChange) == null && (properties == null ? void 0 : properties.onActiveChange) == null) {
    activeSignal.value.length = 0;
    return;
  }
  const onLeave = ({ pointerId }) => {
    var _a, _b;
    activeSignal.value = activeSignal.value.filter((id) => id != pointerId);
    if (activeSignal.value.length > 0) {
      return;
    }
    (_a = properties == null ? void 0 : properties.onActiveChange) == null ? void 0 : _a.call(properties, false);
    (_b = style == null ? void 0 : style.onActiveChange) == null ? void 0 : _b.call(style, false);
  };
  addHandler("onPointerDown", target, ({ pointerId }) => {
    var _a, _b;
    activeSignal.value = [pointerId, ...activeSignal.value];
    if (activeSignal.value.length != 1) {
      return;
    }
    (_a = properties == null ? void 0 : properties.onActiveChange) == null ? void 0 : _a.call(properties, true);
    (_b = style == null ? void 0 : style.onActiveChange) == null ? void 0 : _b.call(style, true);
  });
  addHandler("onPointerUp", target, onLeave);
  addHandler("onPointerLeave", target, onLeave);
}
function createActivePropertyTransfomers(activeSignal) {
  return {
    active: createConditionalPropertyTranslator(() => activeSignal.value.length > 0)
  };
}

// node_modules/@pmndrs/uikit/dist/components/utils.js
function disposeGroup(object) {
  object == null ? void 0 : object.traverse((mesh) => {
    if (!(mesh instanceof Mesh)) {
      return;
    }
    if (mesh.material instanceof Material) {
      mesh.material.dispose();
    }
    if (mesh.geometry instanceof BufferGeometry) {
      mesh.geometry.dispose();
    }
  });
}
function computedGlobalMatrix(parentMatrix, localMatrix) {
  return w(() => {
    const local = localMatrix.value;
    const parent = parentMatrix.value;
    if (local == null || parent == null) {
      return void 0;
    }
    return parent.clone().multiply(local);
  });
}
function computedIsVisible(flexState, isClipped, mergedProperties) {
  return w(() => flexState.displayed.value && (isClipped == null || !(isClipped == null ? void 0 : isClipped.value)) && mergedProperties.value.read("visibility", "visible") === "visible");
}
function loadResourceWithParams(target, fn3, cleanup, initializers, param, ...additionals) {
  initializers.push((subscriptions) => {
    if (!(param instanceof u)) {
      let canceled = false;
      fn3(param, ...additionals).then((value) => canceled ? void 0 : target.value = value);
      subscriptions.push(() => canceled = true);
      return subscriptions;
    }
    subscriptions.push(E(() => {
      let canceled = false;
      fn3(param.value, ...additionals).then((value) => canceled ? void 0 : target.value = value).catch(console.error);
      return () => canceled = true;
    }));
    if (cleanup != null) {
      subscriptions.push(() => {
        const { value } = target;
        if (value == null) {
          return;
        }
        cleanup(value);
      });
    }
    return subscriptions;
  });
}
function createNode(target, state, parentContext, mergedProperties, object, objectVisibleDefault, initializers) {
  initializers.push((subscriptions) => {
    const node = new FlexNode(state, mergedProperties, parentContext.root.requestCalculateLayout, object, objectVisibleDefault, subscriptions);
    if (target != null) {
      target.value = node;
    }
    subscriptions.push(E(() => {
      const parentNode = parentContext.node.value;
      if (parentNode == null) {
        return;
      }
      parentNode.addChild(node);
      return () => parentNode.removeChild(node);
    }));
    return subscriptions;
  });
}
var signalMap = /* @__PURE__ */ new Map();
var keepAspectRatioPropertyTransformer = {
  keepAspectRatio: (value, target) => {
    let signal = signalMap.get(value);
    if (signal == null) {
      signalMap.set(value, signal = w(() => readReactive(value) === false ? null : void 0));
    }
    target.add("aspectRatio", signal);
  }
};
function computedHandlers(style, properties, defaultProperties, hoveredSignal, activeSignal, dynamicHandlers, defaultCursor) {
  return w(() => {
    const handlers = {};
    addHandlers(handlers, dynamicHandlers == null ? void 0 : dynamicHandlers.value);
    addHoverHandlers(handlers, style.value, properties.value, defaultProperties.value, hoveredSignal, defaultCursor);
    addActiveHandlers(handlers, style.value, properties.value, defaultProperties.value, activeSignal);
    return handlers;
  });
}
function addHandlers(target, handlers) {
  for (const key in handlers) {
    addHandler(key, target, handlers[key]);
  }
}
function addHandler(key, target, handler) {
  if (handler == null) {
    return;
  }
  const existingHandler = target[key];
  if (existingHandler == null) {
    target[key] = handler;
    return;
  }
  target[key] = (e2) => {
    existingHandler(e2);
    if ("stopped" in e2 && e2.stopped) {
      return;
    }
    handler(e2);
  };
}
function computedMergedProperties(style, properties, defaultProperties, postTransformers, preTransformers, onInit) {
  return w(() => {
    const merged = new MergedProperties(preTransformers);
    onInit == null ? void 0 : onInit(merged);
    merged.addAll(style.value, properties.value, defaultProperties.value, postTransformers);
    return merged;
  });
}
var colorHelper = new Color();
function applyAppearancePropertiesToGroup(propertiesSignal, group, initializers, root) {
  const color = computedInheritableProperty(propertiesSignal, "color", void 0);
  const opacity = computedInheritableProperty(propertiesSignal, "opacity", 1);
  initializers.push(() => E(() => {
    var _a;
    let c2;
    if (Array.isArray(color.value)) {
      c2 = colorHelper.setRGB(...color.value);
    } else if (color.value != null) {
      c2 = colorHelper.set(color.value);
    }
    (_a = readReactive(group)) == null ? void 0 : _a.traverse((mesh) => {
      if (!(mesh instanceof Mesh)) {
        return;
      }
      mesh.renderOrder = root.renderOrder.value;
      const material = mesh.material;
      material.color.copy(c2 ?? mesh.userData.color);
      material.opacity = opacity.value;
      material.depthTest = root.depthTest.value;
    });
  }));
}

// node_modules/@pmndrs/uikit/dist/panel/instanced-panel.js
function createInstancedPanel(propertiesSignal, orderInfo, panelGroupDependencies, panelGroupManager, matrix, size, offset, borderInset, clippingRect, isVisible, materialConfig, subscriptions) {
  subscriptions.push(E(() => {
    if (orderInfo.value == null) {
      return;
    }
    const innerSubscriptions = [];
    const group = panelGroupManager.getGroup(orderInfo.value.majorIndex, panelGroupDependencies == null ? void 0 : panelGroupDependencies.value);
    new InstancedPanel(propertiesSignal, group, orderInfo.value.minorIndex, matrix, size, offset, borderInset, clippingRect, isVisible, materialConfig, innerSubscriptions);
    return () => unsubscribeSubscriptions(innerSubscriptions);
  }));
  return subscriptions;
}
var matrixHelper1 = new Matrix4();
var matrixHelper2 = new Matrix4();
var InstancedPanel = class {
  constructor(propertiesSignal, group, minorIndex, matrix, size, offset, borderInset, clippingRect, isVisible, materialConfig, subscriptions) {
    __publicField(this, "group");
    __publicField(this, "minorIndex");
    __publicField(this, "matrix");
    __publicField(this, "size");
    __publicField(this, "offset");
    __publicField(this, "borderInset");
    __publicField(this, "clippingRect");
    __publicField(this, "materialConfig");
    __publicField(this, "indexInBucket");
    __publicField(this, "bucket");
    __publicField(this, "unsubscribeList", []);
    __publicField(this, "insertedIntoGroup", false);
    __publicField(this, "active", d(false));
    this.group = group;
    this.minorIndex = minorIndex;
    this.matrix = matrix;
    this.size = size;
    this.offset = offset;
    this.borderInset = borderInset;
    this.clippingRect = clippingRect;
    this.materialConfig = materialConfig;
    const setters = materialConfig.setters;
    setupImmediateProperties(propertiesSignal, this.active, materialConfig.hasProperty, (key, value) => {
      const index = this.getIndexInBuffer();
      if (index == null) {
        return;
      }
      const { instanceData, instanceDataOnUpdate: instanceDataAddUpdateRange, root } = this.group;
      setters[key](instanceData.array, instanceData.itemSize * index, value, size, instanceDataAddUpdateRange);
      root.requestRender();
    }, subscriptions);
    const isPanelVisible = materialConfig.computedIsVisibile(propertiesSignal, borderInset, size, isVisible);
    subscriptions.push(E(() => {
      if (isPanelVisible.value) {
        this.requestShow();
        return;
      }
      this.hide();
    }), () => this.hide());
  }
  setIndexInBucket(index) {
    this.indexInBucket = index;
  }
  getIndexInBuffer() {
    if (this.bucket == null || this.indexInBucket == null) {
      return void 0;
    }
    return this.bucket.offset + this.indexInBucket;
  }
  activate(bucket, index) {
    this.bucket = bucket;
    this.indexInBucket = index;
    this.active.value = true;
    this.unsubscribeList.push(E(() => {
      if (this.matrix.value == null || this.size.value == null) {
        return;
      }
      const index2 = this.getIndexInBuffer();
      if (index2 == null) {
        return;
      }
      const arrayIndex = index2 * 16;
      const [width, height] = this.size.value;
      const pixelSize = this.group.pixelSize.value;
      matrixHelper1.makeScale(width * pixelSize, height * pixelSize, 1);
      if (this.offset != null) {
        const [x2, y3] = this.offset.value;
        matrixHelper1.premultiply(matrixHelper2.makeTranslation(x2 * pixelSize, y3 * pixelSize, 0));
      }
      matrixHelper1.premultiply(this.matrix.value);
      const { instanceMatrix, root } = this.group;
      matrixHelper1.toArray(instanceMatrix.array, arrayIndex);
      instanceMatrix.addUpdateRange(arrayIndex, 16);
      instanceMatrix.needsUpdate = true;
      root.requestRender();
    }), E(() => {
      const index2 = this.getIndexInBuffer();
      if (index2 == null || this.size.value == null) {
        return;
      }
      const [width, height] = this.size.value;
      const { instanceData, root } = this.group;
      const { array } = instanceData;
      const bufferIndex = index2 * 16 + 13;
      array[bufferIndex] = width;
      array[bufferIndex + 1] = height;
      instanceData.addUpdateRange(bufferIndex, 2);
      instanceData.needsUpdate = true;
      root.requestRender();
    }), E(() => {
      const index2 = this.getIndexInBuffer();
      if (index2 == null || this.borderInset.value == null) {
        return;
      }
      const { instanceData, root } = this.group;
      const offset = index2 * 16 + 0;
      instanceData.array.set(this.borderInset.value, offset);
      instanceData.addUpdateRange(offset, 4);
      instanceData.needsUpdate = true;
      root.requestRender();
    }), E(() => {
      var _a;
      const index2 = this.getIndexInBuffer();
      if (index2 == null) {
        return;
      }
      const { instanceClipping, root } = this.group;
      const offset = index2 * 16;
      const clipping = (_a = this.clippingRect) == null ? void 0 : _a.value;
      if (clipping != null) {
        clipping.toArray(instanceClipping.array, offset);
      } else {
        instanceClipping.array.set(defaultClippingData, offset);
      }
      instanceClipping.addUpdateRange(offset, 16);
      instanceClipping.needsUpdate = true;
      root.requestRender();
    }));
  }
  requestShow() {
    if (this.insertedIntoGroup) {
      return;
    }
    this.insertedIntoGroup = true;
    this.group.insert(this.minorIndex, this);
  }
  hide() {
    if (!this.insertedIntoGroup) {
      return;
    }
    this.active.value = false;
    this.group.delete(this.minorIndex, this.indexInBucket, this);
    this.insertedIntoGroup = false;
    this.bucket = void 0;
    this.indexInBucket = void 0;
    const unsubscribeListLength = this.unsubscribeList.length;
    for (let i2 = 0; i2 < unsubscribeListLength; i2++) {
      this.unsubscribeList[i2]();
    }
    this.unsubscribeList.length = 0;
  }
};

// node_modules/@pmndrs/uikit/dist/panel/utils.js
function createPanelGeometry() {
  const geometry = new PlaneGeometry();
  const position = geometry.getAttribute("position");
  const array = new Float32Array(4 * position.count);
  const tangent = [1, 0, 0, 1];
  for (let i2 = 0; i2 < array.length; i2++) {
    array[i2] = tangent[i2 % 4];
  }
  geometry.setAttribute("tangent", new BufferAttribute(array, 4));
  return geometry;
}
function setComponentInFloat(from, index, value) {
  const x2 = Math.pow(50, index);
  const currentValue = Math.floor(from / x2) % 50;
  return from + (value - currentValue) * x2;
}
var panelGeometry = createPanelGeometry();
function setBorderRadius(data, indexInData, indexInFloat, value, height) {
  data[indexInData] = setComponentInFloat(data[indexInData], indexInFloat, clamp(Math.ceil((value ?? 0) / height * 100), 0, 49));
}

// node_modules/@pmndrs/uikit/dist/panel/panel-material.js
var noColor = new Color(-1, -1, -1);
var defaultDefaults = {
  backgroundColor: noColor,
  backgroundOpacity: -1,
  borderColor: 16777215,
  borderBottomLeftRadius: 0,
  borderTopLeftRadius: 0,
  borderBottomRightRadius: 0,
  borderTopRightRadius: 0,
  borderBend: 0,
  borderOpacity: 1
};
var defaultPanelMaterialConfig;
function getDefaultPanelMaterialConfig() {
  if (defaultPanelMaterialConfig == null) {
    const defaultPanelMaterialKeys = {};
    for (const key in defaultDefaults) {
      defaultPanelMaterialKeys[key] = key;
    }
    defaultPanelMaterialConfig = createPanelMaterialConfig(defaultPanelMaterialKeys);
  }
  return defaultPanelMaterialConfig;
}
function createPanelMaterialConfig(keys, overrideDefaults) {
  const defaults = { ...defaultDefaults, ...overrideDefaults };
  const setters = {};
  for (const key in keys) {
    const fn3 = materialSetters[key];
    const defaultValue = defaults[key];
    setters[keys[key]] = (data, offset, value, size, onUpdate) => fn3(data, offset, value ?? defaultValue, size, onUpdate);
  }
  const defaultData = new Float32Array(16);
  writeColor(defaultData, 4, defaults.backgroundColor, void 0);
  writeColor(defaultData, 8, defaults.borderColor, void 0);
  defaultData[11] = defaults.borderBend;
  defaultData[12] = defaults.borderOpacity;
  defaultData[15] = defaults.backgroundOpacity;
  return {
    hasProperty: (key) => key in setters,
    defaultData,
    setters,
    computedIsVisibile: (propertiesSignal, borderInset, size, isVisible) => {
      return w(() => {
        if (borderInset.value == null || size.value == null) {
          return true;
        }
        const borderOpacity = keys.borderOpacity == null ? defaults.borderOpacity : propertiesSignal.value.read(keys.borderOpacity, defaults.borderOpacity);
        const backgroundOpacity = keys.backgroundOpacity == null ? defaults.backgroundOpacity : propertiesSignal.value.read(keys.backgroundOpacity, defaults.backgroundOpacity);
        const backgroundColor = keys.backgroundColor == null ? defaults.backgroundColor : propertiesSignal.value.read(keys.backgroundColor, defaults.backgroundColor);
        const borderVisible = borderInset.value.some((s2) => s2 > 0) && borderOpacity > 0;
        const [width, height] = size.value;
        const backgroundVisible = width > 0 && height > 0 && (backgroundOpacity === -1 || backgroundOpacity > 0) && backgroundColor != noColor;
        if (!backgroundVisible && !borderVisible) {
          return false;
        }
        return isVisible.value;
      });
    }
  };
}
var materialSetters = {
  //0-3 = borderSizes
  //4-6 = background color
  backgroundColor: (d2, o2, p2, _3, u2) => writeColor(d2, o2 + 4, p2, u2),
  //7 = border radiuses
  borderBottomLeftRadius: (d2, o2, p2, { value: s2 }, u2) => s2 != null && writeBorderRadius(d2, o2 + 7, 0, p2, s2[1], u2),
  borderBottomRightRadius: (d2, o2, p2, { value: s2 }, u2) => s2 != null && writeBorderRadius(d2, o2 + 7, 1, p2, s2[1], u2),
  borderTopRightRadius: (d2, o2, p2, { value: s2 }, u2) => s2 != null && writeBorderRadius(d2, o2 + 7, 2, p2, s2[1], u2),
  borderTopLeftRadius: (d2, o2, p2, { value: s2 }, u2) => s2 != null && writeBorderRadius(d2, o2 + 7, 3, p2, s2[1], u2),
  //8 - 10 = border color
  borderColor: (d2, o2, p2, _3, u2) => writeColor(d2, o2 + 8, p2, u2),
  //11
  borderBend: (d2, o2, p2, _3, u2) => writeComponent(d2, o2 + 11, p2, u2),
  //12
  borderOpacity: (d2, o2, p2, _3, u2) => writeComponent(d2, o2 + 12, p2, u2),
  //13 = width
  //14 = height
  //15
  backgroundOpacity: (d2, o2, p2, _3, u2) => writeComponent(d2, o2 + 15, p2, u2)
};
function writeBorderRadius(data, offset, indexInFloat, value, height, onUpdate) {
  setBorderRadius(data, offset, indexInFloat, value, height);
  onUpdate == null ? void 0 : onUpdate(offset, 1);
}
function writeComponent(data, offset, value, onUpdate) {
  data[offset] = value;
  onUpdate == null ? void 0 : onUpdate(offset, 1);
}
var colorHelper2 = new Color();
function writeColor(target, offset, color, onUpdate) {
  if (Array.isArray(color)) {
    target.set(color, offset);
  } else {
    colorHelper2.set(color).toArray(target, offset);
  }
  onUpdate == null ? void 0 : onUpdate(offset, 3);
}
function createPanelMaterial(MaterialClass, info) {
  const material = new MaterialClass();
  if (material.defines == null) {
    material.defines = {};
  }
  material.side = FrontSide;
  material.clipShadows = true;
  material.transparent = true;
  material.toneMapped = false;
  material.depthWrite = false;
  material.shadowSide = FrontSide;
  material.defines.USE_UV = "";
  material.defines.USE_TANGENT = "";
  const superOnBeforeCompile = material.onBeforeCompile;
  material.onBeforeCompile = (parameters, renderer) => {
    superOnBeforeCompile.call(material, parameters, renderer);
    if (info.type === "normal") {
      parameters.uniforms.data = { value: info.data };
    }
    compilePanelMaterial(parameters, info.type === "instanced");
  };
  return material;
}
var PanelDistanceMaterial = class extends MeshDistanceMaterial {
  constructor(info) {
    super();
    __publicField(this, "info");
    this.info = info;
    if (this.defines == null) {
      this.defines = {};
    }
    this.defines.USE_UV = "";
    this.clipShadows = true;
  }
  onBeforeCompile(parameters, renderer) {
    super.onBeforeCompile(parameters, renderer);
    if (this.info.type === "normal") {
      parameters.uniforms.data = { value: this.info.data };
    }
    compilePanelDepthMaterial(parameters, this.info.type === "instanced");
  }
};
var PanelDepthMaterial = class extends MeshDepthMaterial {
  constructor(info) {
    super({ depthPacking: RGBADepthPacking });
    __publicField(this, "info");
    this.info = info;
    if (this.defines == null) {
      this.defines = {};
    }
    this.defines.USE_UV = "";
    this.clipShadows = true;
  }
  onBeforeCompile(parameters, renderer) {
    super.onBeforeCompile(parameters, renderer);
    if (this.info.type === "normal") {
      parameters.uniforms.data = { value: this.info.data };
    }
    compilePanelDepthMaterial(parameters, this.info.type === "instanced");
  }
};
var instancedPanelDepthMaterial = new PanelDepthMaterial({ type: "instanced" });
var instancedPanelDistanceMaterial = new PanelDistanceMaterial({ type: "instanced" });
function compilePanelDepthMaterial(parameters, instanced) {
  compilePanelClippingMaterial(parameters, instanced);
  parameters.fragmentShader = parameters.fragmentShader.replace("#include <clipping_planes_fragment>", `#include <clipping_planes_fragment>
    ${getFargmentOpacityCode(instanced, void 0)}
    `);
}
function compilePanelClippingMaterial(parameters, instanced) {
  parameters.vertexShader = parameters.vertexShader.replace("#include <common>", ` #include <common>
      out vec4 borderRadius;
      ${instanced ? "" : "uniform highp mat4 data;"}`);
  parameters.vertexShader = parameters.vertexShader.replace("#include <uv_vertex>", ` #include <uv_vertex>
      highp int packedBorderRadius = int(data[1].w);
      borderRadius = vec4(
        packedBorderRadius / 125000 % 50,
        packedBorderRadius / 2500 % 50,
        packedBorderRadius / 50 % 50,
        packedBorderRadius % 50
      ) * vec4(0.5 / 50.0);`);
  if (instanced) {
    parameters.vertexShader = parameters.vertexShader.replace("#include <common>", ` #include <common>
        attribute highp mat4 aData;
        attribute mat4 aClipping;
        out mat4 data;
        out mat4 clipping;
        out vec3 localPosition;`);
    parameters.vertexShader = parameters.vertexShader.replace("#include <uv_vertex>", ` #include <uv_vertex>
        data = aData;
        clipping = aClipping;
        localPosition = (instanceMatrix * vec4(position, 1.0)).xyz;`);
  }
  parameters.fragmentShader = `${instanced ? "in" : "uniform"} highp mat4 data;
    in vec4 borderRadius;
    ${instanced ? `
    in vec3 localPosition;
    in mat4 clipping;
    ` : ""}

    float min4 (vec4 v) {
        return min(min(min(v.x,v.y),v.z),v.w);
    }
    float max4 (vec4 v) {
        return max(max(max(v.x,v.y),v.z),v.w);
    }
    vec2 radiusDistance(float radius, vec2 outside, vec2 border, vec2 borderSize) {
        vec2 outerRadiusXX = vec2(radius, radius);
        vec2 innerRadiusXX = outerRadiusXX - borderSize;
        vec2 radiusWeightUnnormalized = abs(innerRadiusXX - border);
        vec2 radiusWeight = radiusWeightUnnormalized / vec2(radiusWeightUnnormalized.x + radiusWeightUnnormalized.y);
        return vec2(
            radius - distance(outside, outerRadiusXX),
            dot(radiusWeight, innerRadiusXX) - distance(border, innerRadiusXX)
        );
    }
    ` + parameters.fragmentShader;
  parameters.fragmentShader = parameters.fragmentShader.replace("#include <clipping_planes_fragment>", ` ${instanced ? `
        vec4 plane;
        float distanceToPlane, distanceGradient;
        float clipOpacity = 1.0;

        for(int i = 0; i < 4; i++) {
          plane = clipping[ i ];
          distanceToPlane = - dot( -localPosition, plane.xyz ) + plane.w;
          distanceGradient = fwidth( distanceToPlane ) / 2.0;
          clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
    
          if ( clipOpacity < 0.01 ) discard;
        }
        ` : ""}
        vec4 absoluteBorderSize = data[0];
        vec3 backgroundColor = data[1].xyz;
        vec3 borderColor = data[2].xyz;
        float borderBend = data[2].w;
        float borderOpacity = data[3].x;
        float width = data[3].y;
        float height = data[3].z;
        float backgroundOpacity = data[3].w;
        float ratio = width / height;
        vec4 relative = vec4(height, height, height, height);
        vec4 borderSize = absoluteBorderSize / relative;
        vec4 v_outsideDistance = vec4(1.0 - vUv.y, (1.0 - vUv.x) * ratio, vUv.y, vUv.x * ratio);
        vec4 v_borderDistance = v_outsideDistance - borderSize;
  
        vec2 distance = vec2(min4(v_outsideDistance), min4(v_borderDistance));
        vec4 negateBorderDistance = vec4(1.0) - v_borderDistance;
        float maxWeight = max4(negateBorderDistance);
        vec4 borderWeight = step(maxWeight, negateBorderDistance);
  
        vec4 insideBorder;
  
        if(all(lessThan(v_outsideDistance.xw, borderRadius.xx))) {
            distance = radiusDistance(borderRadius.x, v_outsideDistance.xw, v_borderDistance.xw, borderSize.xw);
            
            float tmp = borderRadius.x - borderSize.w;
            vec2 xIntersection = vec2(tmp, tmp / ratio);
            tmp = borderRadius.x - borderSize.x;
            vec2 yIntersection = vec2(tmp * ratio, tmp);
            vec2 lineIntersection = min(xIntersection, yIntersection);
  
            insideBorder.yz = vec2(0.0);
            insideBorder.xw = max(vec2(0.0), lineIntersection - v_borderDistance.xw);
  
        } else if(all(lessThan(v_outsideDistance.xy, borderRadius.yy))) {
            distance = radiusDistance(borderRadius.y, v_outsideDistance.xy, v_borderDistance.xy, borderSize.xy);
  
            float tmp = borderRadius.y - borderSize.y;
            vec2 xIntersection = vec2(tmp, tmp / ratio);
            tmp = borderRadius.y - borderSize.x;
            vec2 yIntersection = vec2(tmp * ratio, tmp);
            vec2 lineIntersection = min(xIntersection, yIntersection);
  
            insideBorder.zw = vec2(0.0);
            insideBorder.xy = max(vec2(0.0), lineIntersection - v_borderDistance.xy);
  
        } else if(all(lessThan(v_outsideDistance.zy, borderRadius.zz))) {
            distance = radiusDistance(borderRadius.z, v_outsideDistance.zy, v_borderDistance.zy, borderSize.zy);
  
            float tmp = borderRadius.z - borderSize.y;
            vec2 xIntersection = vec2(tmp, tmp / ratio);
            tmp = borderRadius.z - borderSize.z;
            vec2 yIntersection = vec2(tmp * ratio, tmp);
            vec2 lineIntersection = min(xIntersection, yIntersection);
  
            insideBorder.xw = vec2(0.0);
            insideBorder.zy =max(vec2(0.0), lineIntersection - v_borderDistance.zy);
  
        } else if(all(lessThan(v_outsideDistance.zw, borderRadius.ww))) {
            distance = radiusDistance(borderRadius.w, v_outsideDistance.zw, v_borderDistance.zw, borderSize.zw);
  
            float tmp = borderRadius.w - borderSize.w;
            vec2 xIntersection = vec2(tmp, tmp / ratio);
            tmp = borderRadius.w - borderSize.z;
            vec2 yIntersection = vec2(tmp * ratio, tmp);
            vec2 lineIntersection = min(xIntersection, yIntersection);
  
            insideBorder.xy = vec2(0.0);
            insideBorder.zw = max(vec2(0.0), lineIntersection - v_borderDistance.zw);
  
        }
  
        if(insideBorder.x + insideBorder.y + insideBorder.z + insideBorder.w > 0.0) {
          borderWeight = normalize(insideBorder);
        }
  
        #include <clipping_planes_fragment>`);
}
function getFargmentOpacityCode(instanced, existingOpacity) {
  return `float ddx = fwidth(distance.x);
  float outer = smoothstep(-ddx, ddx, distance.x);

  float ddy = fwidth(distance.y);
  float inner = smoothstep(-ddy, ddy, distance.y);

  float transition = 1.0 - step(0.1, outer - inner) * (1.0 - inner);

  if(backgroundColor.r < 0.0 && backgroundOpacity >= 0.0) {
    backgroundColor = vec3(1.0);
  }
  if(backgroundOpacity < 0.0) {
    backgroundOpacity = backgroundColor.r >= 0.0 ? 1.0 : 0.0;
  }

  if(backgroundOpacity < 0.0) {
    backgroundOpacity = 0.0;
  }

  borderOpacity = min(backgroundOpacity + data[3].x, 1.0);
  borderColor = mix(backgroundColor, data[2].xyz, data[3].x / borderOpacity);
        

  float outOpacity = ${instanced ? "clipOpacity * " : ""} outer * mix(borderOpacity, ${existingOpacity == null ? "" : `${existingOpacity} *`} backgroundOpacity, transition);

  if(outOpacity < 0.01) {
    discard;
  }`;
}
function compilePanelMaterial(parameters, instanced) {
  compilePanelClippingMaterial(parameters, instanced);
  parameters.fragmentShader = parameters.fragmentShader.replace("#include <color_fragment>", ` #include <color_fragment>
      ${getFargmentOpacityCode(instanced, "diffuseColor.a")}
      diffuseColor.rgb = mix(borderColor, diffuseColor.rgb * backgroundColor, transition);
      diffuseColor.a = outOpacity;
      `);
  parameters.fragmentShader = parameters.fragmentShader.replace("#include <normal_fragment_maps>", ` #include <normal_fragment_maps>
      vec3 b = normalize(vBitangent);
      vec3 t = normalize(vTangent);
      mat4 directions = mat4(vec4(b, 1.0), vec4(t, 1.0), vec4(-b, 1.0), vec4(-t, 1.0));
      float currentBorderSize = distance.x - distance.y;
      float outsideNormalWeight = currentBorderSize < 0.00001 ? 0.0 : max(0.0, -distance.y / currentBorderSize) * borderBend;
      vec3 outsideNormal = (borderWeight * transpose(directions)).xyz;
      normal = normalize(outsideNormalWeight * outsideNormal + (1.0 - outsideNormalWeight) * normal);
    `);
}

// node_modules/@pmndrs/uikit/dist/panel/interaction-panel-mesh.js
var planeHelper = new Plane();
var vectorHelper = new Vector3();
var sides = [
  //left
  new Plane().setFromNormalAndCoplanarPoint(new Vector3(1, 0, 0), new Vector3(-0.5, 0, 0)),
  //right
  new Plane().setFromNormalAndCoplanarPoint(new Vector3(-1, 0, 0), new Vector3(0.5, 0, 0)),
  //bottom
  new Plane().setFromNormalAndCoplanarPoint(new Vector3(0, 1, 0), new Vector3(0, -0.5, 0)),
  //top
  new Plane().setFromNormalAndCoplanarPoint(new Vector3(0, -1, 0), new Vector3(0, 0.5, 0))
];
var distancesHelper = [0, 0, 0, 0];
var scaleHelper = new Vector3();
function isSingularMatrix(matrix) {
  scaleHelper.setFromMatrixScale(matrix);
  return scaleHelper.x === 0 || scaleHelper.y === 0 || scaleHelper.z === 0;
}
function makePanelSpherecast(mesh) {
  return (sphere, intersects) => {
    const matrixWorld = mesh.matrixWorld;
    if (isSingularMatrix(matrixWorld)) {
      return;
    }
    planeHelper.constant = 0;
    planeHelper.normal.set(0, 0, 1);
    planeHelper.applyMatrix4(matrixWorld);
    planeHelper.projectPoint(sphere.center, vectorHelper);
    if (vectorHelper.distanceToSquared(sphere.center) > sphere.radius * sphere.radius) {
      return;
    }
    for (let i2 = 0; i2 < 4; i2++) {
      const side = sides[i2];
      planeHelper.copy(side).applyMatrix4(matrixWorld);
      let distance2 = planeHelper.distanceToPoint(vectorHelper);
      if (distance2 < 0) {
        if (Math.abs(distance2) > sphere.radius) {
          return;
        }
        planeHelper.projectPoint(vectorHelper, vectorHelper);
        distance2 = 0;
      }
      distancesHelper[i2] = distance2;
    }
    const distance = sphere.center.distanceTo(vectorHelper);
    if (distance > sphere.radius) {
      return;
    }
    intersects.push({
      distance,
      object: mesh,
      point: vectorHelper.clone(),
      uv: new Vector2(distancesHelper[0] / (distancesHelper[0] + distancesHelper[1]), distancesHelper[3] / (distancesHelper[2] + distancesHelper[3])),
      normal: new Vector3(0, 0, 1)
    });
  };
}
function makePanelRaycast(mesh) {
  return (raycaster, intersects) => {
    const matrixWorld = mesh.matrixWorld;
    if (isSingularMatrix(matrixWorld)) {
      return;
    }
    planeHelper.constant = 0;
    planeHelper.normal.set(0, 0, 1);
    planeHelper.applyMatrix4(matrixWorld);
    if (planeHelper.distanceToPoint(raycaster.ray.origin) <= 0 || raycaster.ray.intersectPlane(planeHelper, vectorHelper) == null) {
      return;
    }
    for (let i2 = 0; i2 < 4; i2++) {
      const side = sides[i2];
      planeHelper.copy(side).applyMatrix4(matrixWorld);
      if ((distancesHelper[i2] = planeHelper.distanceToPoint(vectorHelper)) < 0) {
        return;
      }
    }
    intersects.push({
      distance: vectorHelper.distanceTo(raycaster.ray.origin),
      object: mesh,
      point: vectorHelper.clone(),
      uv: new Vector2(distancesHelper[0] / (distancesHelper[0] + distancesHelper[1]), distancesHelper[3] / (distancesHelper[2] + distancesHelper[3])),
      normal: new Vector3(0, 0, 1)
    });
  };
}
function makeClippedCast(mesh, fn3, rootObject, clippingRect, orderInfo) {
  return (raycaster, intersects) => {
    var _a;
    const obj = rootObject instanceof Object3D ? rootObject : rootObject.current;
    if (obj == null || orderInfo.value == null) {
      return;
    }
    const { majorIndex, minorIndex, elementType } = orderInfo.value;
    const oldLength = intersects.length;
    fn3.call(mesh, raycaster, intersects);
    const clippingPlanes = (_a = clippingRect == null ? void 0 : clippingRect.value) == null ? void 0 : _a.planes;
    const outerMatrixWorld = obj.matrixWorld;
    outer:
      for (let i2 = intersects.length - 1; i2 >= oldLength; i2--) {
        const intersection = intersects[i2];
        intersection.distance -= majorIndex * 0.01 + elementType * 1e-3 + //1-10
        minorIndex * 1e-5;
        if (clippingPlanes == null) {
          continue;
        }
        for (let ii2 = 0; ii2 < 4; ii2++) {
          planeHelper.copy(clippingPlanes[ii2]).applyMatrix4(outerMatrixWorld);
          if (planeHelper.distanceToPoint(intersection.point) < 0) {
            intersects.splice(i2, 1);
            continue outer;
          }
        }
      }
  };
}

// node_modules/@pmndrs/uikit/dist/panel/instanced-panel-mesh.js
function createInteractionPanel(orderInfo, rootContext, parentClippingRect, size, initializers) {
  const panel = new Mesh(panelGeometry);
  panel.matrixAutoUpdate = false;
  panel.raycast = makeClippedCast(panel, makePanelRaycast(panel), rootContext.object, parentClippingRect, orderInfo);
  panel.spherecast = makeClippedCast(panel, makePanelSpherecast(panel), rootContext.object, parentClippingRect, orderInfo);
  panel.visible = false;
  initializers.push(() => E(() => {
    if (size.value == null) {
      return;
    }
    const [width, height] = size.value;
    const pixelSize = rootContext.pixelSize.value;
    panel.scale.set(width * pixelSize, height * pixelSize, 1);
    panel.updateMatrix();
  }));
  return panel;
}
var InstancedPanelMesh = class extends Mesh {
  constructor(instanceMatrix, instanceData, instanceClipping) {
    const panelGeometry2 = createPanelGeometry();
    super(panelGeometry2);
    __publicField(this, "instanceMatrix");
    __publicField(this, "count", 0);
    __publicField(this, "isInstancedMesh", true);
    __publicField(this, "instanceColor", null);
    __publicField(this, "morphTexture", null);
    __publicField(this, "boundingBox", new Box3());
    __publicField(this, "boundingSphere", new Sphere());
    this.instanceMatrix = instanceMatrix;
    this.frustumCulled = false;
    panelGeometry2.attributes.aData = instanceData;
    panelGeometry2.attributes.aClipping = instanceClipping;
    this.customDepthMaterial = instancedPanelDepthMaterial;
    this.customDistanceMaterial = instancedPanelDistanceMaterial;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  copy() {
    throw new Error("copy not implemented");
  }
  //functions not needed because intersection (and morphing) is intenionally disabled
  computeBoundingBox() {
  }
  computeBoundingSphere() {
  }
  updateMorphTargets() {
  }
  raycast() {
  }
  spherecast() {
  }
};

// node_modules/@pmndrs/uikit/dist/panel/instanced-panel-group.js
function computedPanelGroupDependencies(propertiesSignal) {
  const panelMaterialClass = computedInheritableProperty(propertiesSignal, "panelMaterialClass", MeshBasicMaterial);
  const castShadow = computedInheritableProperty(propertiesSignal, "castShadow", false);
  const receiveShadow = computedInheritableProperty(propertiesSignal, "receiveShadow", false);
  return w(() => ({
    panelMaterialClass: panelMaterialClass.value,
    castShadow: castShadow.value,
    receiveShadow: receiveShadow.value
  }));
}
var defaultPanelDependencies = {
  panelMaterialClass: MeshBasicMaterial,
  castShadow: false,
  receiveShadow: false
};
var PanelGroupManager = class {
  constructor(renderOrder, depthTest, pixelSize, root, object, initializers) {
    __publicField(this, "renderOrder");
    __publicField(this, "depthTest");
    __publicField(this, "pixelSize");
    __publicField(this, "root");
    __publicField(this, "object");
    __publicField(this, "map", /* @__PURE__ */ new Map());
    this.renderOrder = renderOrder;
    this.depthTest = depthTest;
    this.pixelSize = pixelSize;
    this.root = root;
    this.object = object;
    initializers.push(() => {
      const onFrame = () => this.traverse((group) => group.onFrame());
      root.onFrameSet.add(onFrame);
      return () => root.onFrameSet.delete(onFrame);
    }, () => () => this.traverse((group) => group.destroy()), () => E(() => {
      const ro2 = renderOrder.value;
      this.traverse((group) => group.setRenderOrder(ro2));
      this.root.requestRender();
    }), () => E(() => {
      const dt3 = depthTest.value;
      this.traverse((group) => group.setDepthTest(dt3));
      this.root.requestRender();
    }));
  }
  traverse(fn3) {
    for (const groups of this.map.values()) {
      for (const group of groups.values()) {
        fn3(group);
      }
    }
  }
  getGroup(majorIndex, { panelMaterialClass, receiveShadow, castShadow } = defaultPanelDependencies) {
    let groups = this.map.get(panelMaterialClass);
    if (groups == null) {
      this.map.set(panelMaterialClass, groups = /* @__PURE__ */ new Map());
    }
    const key = (majorIndex << 2) + ((receiveShadow ? 1 : 0) << 1) + (castShadow ? 1 : 0);
    let panelGroup = groups.get(key);
    if (panelGroup == null) {
      groups.set(key, panelGroup = new InstancedPanelGroup(this.renderOrder.peek(), this.depthTest.peek(), this.object, panelMaterialClass, this.pixelSize, this.root, {
        elementType: ElementType.Panel,
        majorIndex,
        minorIndex: 0
      }, receiveShadow, castShadow));
    }
    return panelGroup;
  }
};
var nextFrame = Symbol("nextFrame");
var InstancedPanelGroup = class {
  constructor(renderOrder, depthTest, object, materialClass, pixelSize, root, orderInfo, meshReceiveShadow, meshCastShadow) {
    __publicField(this, "renderOrder");
    __publicField(this, "object");
    __publicField(this, "pixelSize");
    __publicField(this, "root");
    __publicField(this, "orderInfo");
    __publicField(this, "meshReceiveShadow");
    __publicField(this, "meshCastShadow");
    __publicField(this, "mesh");
    __publicField(this, "instanceMatrix");
    __publicField(this, "instanceData");
    __publicField(this, "instanceClipping");
    __publicField(this, "instanceMaterial");
    __publicField(this, "buckets", []);
    __publicField(this, "elementCount", 0);
    __publicField(this, "bufferElementSize", 0);
    __publicField(this, "instanceDataOnUpdate");
    __publicField(this, "nextUpdateTime");
    __publicField(this, "nextUpdateTimeoutRef");
    __publicField(this, "activateElement", (element, bucket, indexInBucket) => {
      const index = bucket.offset + indexInBucket;
      this.instanceData.set(element.materialConfig.defaultData, 16 * index);
      this.instanceData.addUpdateRange(16 * index, 16);
      this.instanceData.needsUpdate = true;
      element.activate(bucket, indexInBucket);
    });
    __publicField(this, "setElementIndex", (element, index) => {
      element.setIndexInBucket(index);
    });
    __publicField(this, "bufferCopyWithin", (targetIndex, startIndex, endIndex) => {
      copyWithinAttribute(this.instanceMatrix, targetIndex, startIndex, endIndex);
      copyWithinAttribute(this.instanceData, targetIndex, startIndex, endIndex);
      copyWithinAttribute(this.instanceClipping, targetIndex, startIndex, endIndex);
    });
    __publicField(this, "clearBufferAt", (index) => {
      const bufferOffset = index * 16;
      this.instanceMatrix.array.fill(0, bufferOffset, bufferOffset + 16);
      this.instanceMatrix.addUpdateRange(bufferOffset, 16);
      this.instanceMatrix.needsUpdate = true;
    });
    this.renderOrder = renderOrder;
    this.object = object;
    this.pixelSize = pixelSize;
    this.root = root;
    this.orderInfo = orderInfo;
    this.meshReceiveShadow = meshReceiveShadow;
    this.meshCastShadow = meshCastShadow;
    this.instanceMaterial = createPanelMaterial(materialClass, { type: "instanced" });
    this.instanceMaterial.depthTest = depthTest;
  }
  updateCount() {
    const lastBucket = this.buckets[this.buckets.length - 1];
    const count = lastBucket.offset + lastBucket.elements.length;
    if (this.mesh == null) {
      return;
    }
    this.mesh.count = count;
    this.mesh.visible = count > 0;
    this.root.requestRender();
  }
  requestUpdate(time) {
    if (this.nextUpdateTime == nextFrame) {
      return;
    }
    const forTime = performance.now() + time;
    if (this.nextUpdateTime != null && this.nextUpdateTime < forTime) {
      return;
    }
    this.nextUpdateTime = forTime;
    clearTimeout(this.nextUpdateTimeoutRef);
    this.nextUpdateTimeoutRef = setTimeout(this.requestUpdateNextFrame.bind(this), time);
  }
  requestUpdateNextFrame() {
    this.nextUpdateTime = nextFrame;
    clearTimeout(this.nextUpdateTimeoutRef);
    this.nextUpdateTimeoutRef = void 0;
    this.root.requestRender();
  }
  setDepthTest(depthTest) {
    this.instanceMaterial.depthTest = depthTest;
  }
  setRenderOrder(renderOrder) {
    this.renderOrder = renderOrder;
    if (this.mesh == null) {
      return;
    }
    this.mesh.renderOrder = renderOrder;
  }
  insert(bucketIndex, panel) {
    this.elementCount += 1;
    if (!addToSortedBuckets(this.buckets, bucketIndex, panel, this.activateElement)) {
      this.updateCount();
      return;
    }
    this.requestUpdateNextFrame();
  }
  delete(bucketIndex, elementIndex, panel) {
    this.elementCount -= 1;
    if (!removeFromSortedBuckets(this.buckets, bucketIndex, panel, elementIndex, this.activateElement, this.clearBufferAt, this.setElementIndex, this.bufferCopyWithin)) {
      this.updateCount();
      return;
    }
    this.requestUpdate(1e3);
  }
  onFrame() {
    if (this.nextUpdateTime != nextFrame) {
      return;
    }
    this.nextUpdateTime = void 0;
    this.update();
  }
  update() {
    if (this.elementCount === 0) {
      if (this.mesh != null) {
        this.mesh.visible = false;
      }
      return;
    }
    if (this.elementCount > this.bufferElementSize) {
      this.resize();
    } else if (this.elementCount <= this.bufferElementSize / 3) {
      this.resize();
    }
    updateSortedBucketsAllocation(this.buckets, this.activateElement, this.bufferCopyWithin);
    this.mesh.count = this.elementCount;
    this.mesh.visible = true;
  }
  resize() {
    var _a, _b;
    const oldBufferSize = this.bufferElementSize;
    this.bufferElementSize = Math.ceil(this.elementCount * 1.5);
    if (this.mesh != null) {
      this.mesh.dispose();
      (_a = this.object.current) == null ? void 0 : _a.remove(this.mesh);
    }
    resizeSortedBucketsSpace(this.buckets, oldBufferSize, this.bufferElementSize);
    const matrixArray = new Float32Array(this.bufferElementSize * 16);
    if (this.instanceMatrix != null) {
      matrixArray.set(this.instanceMatrix.array.subarray(0, matrixArray.length));
    }
    this.instanceMatrix = new InstancedBufferAttribute(matrixArray, 16, false);
    this.instanceMatrix.setUsage(DynamicDrawUsage);
    const dataArray = new Float32Array(this.bufferElementSize * 16);
    if (this.instanceData != null) {
      dataArray.set(this.instanceData.array.subarray(0, dataArray.length));
    }
    this.instanceData = new InstancedBufferAttribute(dataArray, 16, false);
    this.instanceDataOnUpdate = (start, count) => {
      this.instanceData.addUpdateRange(start, count);
      this.instanceData.needsUpdate = true;
    };
    this.instanceData.setUsage(DynamicDrawUsage);
    const clippingArray = new Float32Array(this.bufferElementSize * 16);
    if (this.instanceClipping != null) {
      clippingArray.set(this.instanceClipping.array.subarray(0, clippingArray.length));
    }
    this.instanceClipping = new InstancedBufferAttribute(clippingArray, 16, false);
    this.instanceClipping.setUsage(DynamicDrawUsage);
    this.mesh = new InstancedPanelMesh(this.instanceMatrix, this.instanceData, this.instanceClipping);
    this.mesh.renderOrder = this.renderOrder;
    setupRenderOrder(this.mesh, this.root, { value: this.orderInfo });
    this.mesh.material = this.instanceMaterial;
    this.mesh.receiveShadow = this.meshReceiveShadow;
    this.mesh.castShadow = this.meshCastShadow;
    (_b = this.object.current) == null ? void 0 : _b.add(this.mesh);
  }
  destroy() {
    clearTimeout(this.nextUpdateTimeoutRef);
  }
};
function copyWithinAttribute(attribute, targetIndex, startIndex, endIndex) {
  const itemSize = attribute.itemSize;
  const start = startIndex * itemSize;
  const end = endIndex * itemSize;
  const target = targetIndex * itemSize;
  attribute.array.copyWithin(target, start, end);
  const count = end - start;
  attribute.addUpdateRange(start, count);
  attribute.addUpdateRange(target, count);
  attribute.needsUpdate = true;
}

// node_modules/@pmndrs/uikit/dist/scroll.js
var distanceHelper = new Vector3();
var localPointHelper = new Vector3();
function createScrollPosition() {
  return d([0, 0]);
}
function computedGlobalScrollMatrix(scrollPosition, globalMatrix, pixelSizeSignal) {
  return w(() => {
    const global2 = globalMatrix.value;
    if (global2 == null) {
      return void 0;
    }
    const [scrollX, scrollY] = scrollPosition.value;
    const pixelSize = pixelSizeSignal.value;
    return new Matrix4().makeTranslation(-scrollX * pixelSize, scrollY * pixelSize, 0).premultiply(global2);
  });
}
function applyScrollPosition(object, scrollPosition, pixelSizeSignal, initializers) {
  return initializers.push(() => E(() => {
    var _a, _b;
    const [scrollX, scrollY] = scrollPosition.value;
    const pixelSize = pixelSizeSignal.value;
    (_a = object.current) == null ? void 0 : _a.position.set(-scrollX * pixelSize, scrollY * pixelSize, 0);
    (_b = object.current) == null ? void 0 : _b.updateMatrix();
  }));
}
function computedAnyAncestorScrollable(scrollable, anyAncestorScrollable) {
  return w(() => {
    const [ancestorX, ancestorY] = (anyAncestorScrollable == null ? void 0 : anyAncestorScrollable.value) ?? [false, false];
    const [x2, y3] = scrollable.value;
    return [ancestorX || x2, ancestorY || y3];
  });
}
function computedScrollHandlers(scrollPosition, anyAncestorScrollable, { scrollable, maxScrollPosition }, object, interactionPanel, listeners, root, initializers) {
  const isScrollable = w(() => {
    var _a;
    return ((_a = scrollable.value) == null ? void 0 : _a.some((scrollable2) => scrollable2)) ?? false;
  });
  const downPointerMap = /* @__PURE__ */ new Map();
  const scrollVelocity = new Vector2();
  const scroll = (event, deltaX, deltaY, deltaTime, enableRubberBand) => {
    var _a, _b;
    if (scrollPosition.value == null) {
      return;
    }
    const [wasScrolledX, wasScrolledY] = event == null ? [false, false] : getWasScrolled(event.nativeEvent);
    if (wasScrolledX) {
      deltaX = 0;
    }
    if (wasScrolledY) {
      deltaY = 0;
    }
    const [x2, y3] = scrollPosition.value;
    const [maxX, maxY] = maxScrollPosition.value;
    let [newX, newY] = scrollPosition.value;
    const [ancestorScrollableX, ancestorScrollableY] = (anyAncestorScrollable == null ? void 0 : anyAncestorScrollable.value) ?? [false, false];
    newX = computeScroll(x2, maxX, deltaX, enableRubberBand && !ancestorScrollableX);
    newY = computeScroll(y3, maxY, deltaY, enableRubberBand && !ancestorScrollableY);
    if (deltaTime != null && deltaTime > 0) {
      scrollVelocity.set(deltaX, deltaY).divideScalar(deltaTime);
    }
    if (event != null) {
      setWasScrolled(event.nativeEvent, wasScrolledX || Math.min(x2, (maxX ?? 0) - x2) > 5, wasScrolledY || Math.min(y3, (maxY ?? 0) - y3) > 5);
    }
    const preventScroll = (_b = (_a = listeners.peek()) == null ? void 0 : _a.onScroll) == null ? void 0 : _b.call(_a, newX, newY, scrollPosition, event);
    if (preventScroll === false || x2 === newX && y3 === newY) {
      return;
    }
    scrollPosition.value = [newX, newY];
  };
  const onFrame = (delta) => {
    if (downPointerMap.size > 0 || scrollPosition.value == null) {
      return;
    }
    let deltaX = 0;
    let deltaY = 0;
    const [x2, y3] = scrollPosition.value;
    const [maxX, maxY] = maxScrollPosition.value;
    const outsideDistanceX = outsideDistance(x2, 0, maxX ?? 0);
    const outsideDistanceY = outsideDistance(y3, 0, maxY ?? 0);
    if (Math.abs(outsideDistanceX) > 1 || Math.abs(outsideDistanceY) > 1) {
      root.requestFrame();
    }
    deltaX += outsideDistanceX * -0.3;
    deltaY += outsideDistanceY * -0.3;
    deltaX += scrollVelocity.x * delta;
    deltaY += scrollVelocity.y * delta;
    scrollVelocity.multiplyScalar(0.9);
    if (Math.abs(scrollVelocity.x) < 10) {
      scrollVelocity.x = 0;
    } else {
      root.requestFrame();
    }
    if (Math.abs(scrollVelocity.y) < 10) {
      scrollVelocity.y = 0;
    } else {
      root.requestFrame();
    }
    if (deltaX === 0 && deltaY === 0) {
      return;
    }
    scroll(void 0, deltaX, deltaY, void 0, true);
  };
  initializers.push(() => E(() => {
    if (!isScrollable.value) {
      return;
    }
    root.onFrameSet.add(onFrame);
    return () => root.onFrameSet.delete(onFrame);
  }));
  return w(() => {
    if (!isScrollable.value) {
      return void 0;
    }
    const onPointerFinish = ({ pointerId }) => {
      if (!downPointerMap.delete(pointerId) || downPointerMap.size > 0 || scrollPosition.value == null) {
        return;
      }
      root.requestRender();
    };
    return {
      onPointerDown: ({ pointerId, point }) => {
        let interaction = downPointerMap.get(pointerId);
        if (interaction == null) {
          downPointerMap.set(pointerId, interaction = { timestamp: 0, point: new Vector3() });
        }
        interaction.timestamp = performance.now() / 1e3;
        object.current.worldToLocal(interaction.point.copy(point));
      },
      onPointerUp: onPointerFinish,
      onPointerLeave: onPointerFinish,
      onPointerCancel: onPointerFinish,
      onPointerMove: (event) => {
        const prevInteraction = downPointerMap.get(event.pointerId);
        if (prevInteraction == null) {
          return;
        }
        object.current.worldToLocal(localPointHelper.copy(event.point));
        distanceHelper.copy(localPointHelper).sub(prevInteraction.point).divideScalar(root.pixelSize.peek());
        const timestamp = performance.now() / 1e3;
        const deltaTime = timestamp - prevInteraction.timestamp;
        prevInteraction.point.copy(localPointHelper);
        prevInteraction.timestamp = timestamp;
        if (event.defaultPrevented) {
          return;
        }
        scroll(event, -distanceHelper.x, distanceHelper.y, deltaTime, true);
      },
      onWheel: (event) => {
        if (event.defaultPrevented) {
          return;
        }
        const { nativeEvent } = event;
        scroll(event, nativeEvent.deltaX, nativeEvent.deltaY, void 0, false);
      }
    };
  });
}
var wasScrolledSymbol = Symbol("was-scrolled");
function getWasScrolled(event) {
  return event[wasScrolledSymbol] ?? [false, false];
}
function setWasScrolled(event, x2, y3) {
  event[wasScrolledSymbol] = [x2, y3];
}
function computeScroll(position, maxPosition, delta, enableRubberBand) {
  if (delta === 0) {
    return position;
  }
  const outside = outsideDistance(position, 0, maxPosition ?? 0);
  if (sign(delta) === sign(outside)) {
    delta *= Math.max(0, 1 - Math.abs(outside) / 100);
  }
  let newPosition = position + delta;
  if (enableRubberBand && maxPosition != null) {
    return newPosition;
  }
  return clamp(newPosition, 0, maxPosition ?? 0);
}
function sign(value) {
  return value >= 0;
}
function outsideDistance(value, min, max) {
  if (value < min) {
    return value - min;
  }
  if (value > max) {
    return value - max;
  }
  return 0;
}
var scrollbarBorderPropertyKeys = [
  "scrollbarBorderLeftWidth",
  "scrollbarBorderRightWidth",
  "scrollbarBorderTopWidth",
  "scrollbarBorderBottomWidth"
];
function createScrollbars(propertiesSignal, scrollPosition, flexState, globalMatrix, isVisible, parentClippingRect, orderInfo, panelGroupManager, initializers) {
  const scrollbarOrderInfo = computedOrderInfo(void 0, ElementType.Panel, defaultPanelDependencies, orderInfo);
  const scrollbarWidth = computedInheritableProperty(propertiesSignal, "scrollbarWidth", 10);
  const borderInset = computedBorderInset(propertiesSignal, scrollbarBorderPropertyKeys);
  createScrollbar(propertiesSignal, 0, scrollPosition, flexState, globalMatrix, isVisible, parentClippingRect, scrollbarOrderInfo, panelGroupManager, scrollbarWidth, borderInset, initializers);
  createScrollbar(propertiesSignal, 1, scrollPosition, flexState, globalMatrix, isVisible, parentClippingRect, scrollbarOrderInfo, panelGroupManager, scrollbarWidth, borderInset, initializers);
}
var scrollbarMaterialConfig;
function getScrollbarMaterialConfig() {
  scrollbarMaterialConfig ?? (scrollbarMaterialConfig = createPanelMaterialConfig({
    backgroundColor: "scrollbarColor",
    borderBottomLeftRadius: "scrollbarBorderBottomLeftRadius",
    borderBottomRightRadius: "scrollbarBorderBottomRightRadius",
    borderTopRightRadius: "scrollbarBorderTopRightRadius",
    borderTopLeftRadius: "scrollbarBorderTopLeftRadius",
    borderColor: "scrollbarBorderColor",
    borderBend: "scrollbarBorderBend",
    borderOpacity: "scrollbarBorderOpacity",
    backgroundOpacity: "scrollbarOpacity"
  }, {
    backgroundColor: 16777215,
    backgroundOpacity: 1
  }));
  return scrollbarMaterialConfig;
}
function createScrollbar(propertiesSignal, mainIndex, scrollPosition, flexState, globalMatrix, isVisible, parentClippingRect, orderInfo, panelGroupManager, scrollbarWidth, borderSize, initializers) {
  const scrollbarTransformation = w(() => computeScrollbarTransformation(mainIndex, scrollbarWidth.value, flexState.size.value, flexState.maxScrollPosition.value, flexState.borderInset.value, scrollPosition.value));
  const scrollbarPosition = w(() => {
    var _a;
    return ((_a = scrollbarTransformation.value) == null ? void 0 : _a.slice(0, 2)) ?? [0, 0];
  });
  const scrollbarSize = w(() => {
    var _a;
    return ((_a = scrollbarTransformation.value) == null ? void 0 : _a.slice(2, 4)) ?? [0, 0];
  });
  initializers.push((subscriptions) => createInstancedPanel(propertiesSignal, orderInfo, void 0, panelGroupManager, globalMatrix, scrollbarSize, scrollbarPosition, borderSize, parentClippingRect, isVisible, getScrollbarMaterialConfig(), subscriptions));
}
function computeScrollbarTransformation(mainIndex, otherScrollbarSize, size, maxScrollbarPosition, borderInset, scrollPosition) {
  if (size == null || borderInset == null || scrollPosition == null) {
    return void 0;
  }
  const maxMainScrollbarPosition = maxScrollbarPosition[mainIndex];
  if (maxMainScrollbarPosition == null) {
    return void 0;
  }
  const result = [0, 0, 0, 0];
  const invertedIndex = 1 - mainIndex;
  const mainSizeWithoutBorder = size[mainIndex] - borderInset[invertedIndex] - borderInset[invertedIndex + 2];
  const mainScrollbarSize = Math.max(otherScrollbarSize, mainSizeWithoutBorder * mainSizeWithoutBorder / (maxMainScrollbarPosition + mainSizeWithoutBorder));
  const maxScrollbarDistancance = mainSizeWithoutBorder - mainScrollbarSize;
  const mainScrollPosition = scrollPosition[mainIndex];
  result[mainIndex] = size[mainIndex] * 0.5 - mainScrollbarSize * 0.5 - borderInset[(mainIndex + 3) % 4] - maxScrollbarDistancance * clamp(mainScrollPosition / maxMainScrollbarPosition, 0, 1);
  result[invertedIndex] = size[invertedIndex] * 0.5 - otherScrollbarSize * 0.5 - borderInset[invertedIndex + 1];
  if (mainIndex === 0) {
    result[0] *= -1;
    result[1] *= -1;
  }
  result[mainIndex + 2] = mainScrollbarSize;
  result[invertedIndex + 2] = otherScrollbarSize;
  return result;
}

// node_modules/@pmndrs/uikit/dist/text/render/instanced-glyph-mesh.js
var InstancedGlyphMesh = class extends Mesh {
  constructor(instanceMatrix, instanceRGBA, instanceUV, instanceClipping, material) {
    const planeGeometry = new PlaneGeometry();
    planeGeometry.translate(0.5, -0.5, 0);
    super(planeGeometry, material);
    __publicField(this, "instanceMatrix");
    __publicField(this, "instanceRGBA");
    __publicField(this, "instanceUV");
    __publicField(this, "instanceClipping");
    __publicField(this, "count", 0);
    __publicField(this, "isInstancedMesh", true);
    __publicField(this, "instanceColor", null);
    __publicField(this, "morphTexture", null);
    __publicField(this, "boundingBox", new Box3());
    __publicField(this, "boundingSphere", new Sphere());
    this.instanceMatrix = instanceMatrix;
    this.instanceRGBA = instanceRGBA;
    this.instanceUV = instanceUV;
    this.instanceClipping = instanceClipping;
    planeGeometry.attributes.instanceUVOffset = instanceUV;
    planeGeometry.attributes.instanceRGBA = instanceRGBA;
    planeGeometry.attributes.instanceClipping = instanceClipping;
    this.frustumCulled = false;
  }
  copy() {
    throw new Error("copy not implemented");
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  //functions not needed because intersection (and morphing) is intenionally disabled
  computeBoundingBox() {
  }
  computeBoundingSphere() {
  }
  updateMorphTargets() {
  }
  raycast() {
  }
  spherecast() {
  }
};

// node_modules/@pmndrs/uikit/dist/text/render/instanced-gylph-material.js
var InstancedGlyphMaterial = class extends MeshBasicMaterial {
  constructor(font) {
    super({
      transparent: true,
      depthWrite: false,
      toneMapped: false
    });
    this.onBeforeCompile = (parameters) => {
      parameters.uniforms.fontPage = { value: font.page };
      parameters.uniforms.pageSize = { value: [font.pageWidth, font.pageHeight] };
      parameters.uniforms.distanceRange = { value: font.distanceRange };
      parameters.uniforms.v_weight = { value: 0.3 };
      parameters.vertexShader = `attribute vec4 instanceUVOffset;
        varying vec2 fontUv;
        attribute vec4 instanceRGBA;
        varying vec4 rgba;
        attribute mat4 instanceClipping;
        varying mat4 clipping;
        varying vec3 localPosition;
        ` + parameters.vertexShader;
      parameters.vertexShader = parameters.vertexShader.replace("#include <uv_vertex>", `#include <uv_vertex>
            fontUv = instanceUVOffset.xy + uv * instanceUVOffset.zw;
            rgba = instanceRGBA;
            clipping = instanceClipping;
            localPosition = (instanceMatrix * vec4(position, 1.0)).xyz;`);
      parameters.fragmentShader = `uniform sampler2D fontPage;
            uniform vec2 pageSize;
            uniform int distanceRange;
            uniform float v_weight;
        varying vec2 fontUv;
        varying vec4 rgba;
        varying mat4 clipping; 
        varying vec3 localPosition;
        float median(float r, float g, float b) {
            return max(min(r, g), min(max(r, g), b));
        }
        float getDistance() {
            vec3 msdf = texture(fontPage, fontUv).rgb;
            return median(msdf.r, msdf.g, msdf.b);
        }
        ` + parameters.fragmentShader;
      parameters.fragmentShader = parameters.fragmentShader.replace("#include <map_fragment>", ` #include <map_fragment>
          vec4 plane;
          float distanceToPlane, distanceGradient;
          float clipOpacity = 1.0;
          for(int i = 0; i < 4; i++) {
            plane = clipping[ i ];
            distanceToPlane = - dot( -localPosition, plane.xyz ) + plane.w;
            distanceGradient = fwidth( distanceToPlane ) / 2.0;
            clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
      
            if ( clipOpacity == 0.0 ) discard;
          }
          vec2 dxdy = fwidth(fontUv) * pageSize;
          float dist = getDistance() + min(float(v_weight), 0.5 - 1.0 / float(distanceRange)) - 0.5;
          float multiplier = clamp(dist * float(distanceRange) / length(dxdy) + 0.5, 0.0, 1.0);
          if(multiplier <= 0.5) {
              discard;
          }
          diffuseColor.a *= clipOpacity * min((multiplier - 0.5) / 0.5, 1.0);
          diffuseColor *= rgba;
            `);
    };
  }
};

// node_modules/@pmndrs/uikit/dist/text/render/instanced-glyph-group.js
var GlyphGroupManager = class {
  constructor(renderOrder, depthTest, pixelSize, root, object, initializers) {
    __publicField(this, "renderOrder");
    __publicField(this, "depthTest");
    __publicField(this, "pixelSize");
    __publicField(this, "root");
    __publicField(this, "object");
    __publicField(this, "map", /* @__PURE__ */ new Map());
    this.renderOrder = renderOrder;
    this.depthTest = depthTest;
    this.pixelSize = pixelSize;
    this.root = root;
    this.object = object;
    initializers.push(() => {
      const onFrame = (delta) => this.traverse((group) => group.onFrame(delta));
      root.onFrameSet.add(onFrame);
      return () => root.onFrameSet.delete(onFrame);
    }, () => E(() => {
      const ro2 = renderOrder.value;
      this.traverse((group) => group.setRenderOrder(ro2));
    }), () => E(() => {
      const dt3 = depthTest.value;
      this.traverse((group) => group.setDepthTest(dt3));
    }));
  }
  traverse(fn3) {
    for (const groups of this.map.values()) {
      for (const group of groups.values()) {
        fn3(group);
      }
    }
  }
  getGroup(majorIndex, font) {
    let groups = this.map.get(font);
    if (groups == null) {
      this.map.set(font, groups = /* @__PURE__ */ new Map());
    }
    let glyphGroup = groups == null ? void 0 : groups.get(majorIndex);
    if (glyphGroup == null) {
      groups.set(majorIndex, glyphGroup = new InstancedGlyphGroup(this.renderOrder.peek(), this.depthTest.peek(), this.object, font, this.pixelSize, this.root, {
        majorIndex,
        elementType: ElementType.Text,
        minorIndex: 0
      }));
    }
    return glyphGroup;
  }
};
var InstancedGlyphGroup = class {
  constructor(renderOrder, depthTest, object, font, pixelSize, root, orderInfo) {
    __publicField(this, "renderOrder");
    __publicField(this, "object");
    __publicField(this, "pixelSize");
    __publicField(this, "root");
    __publicField(this, "orderInfo");
    __publicField(this, "instanceMatrix");
    __publicField(this, "instanceUV");
    __publicField(this, "instanceRGBA");
    __publicField(this, "instanceClipping");
    __publicField(this, "glyphs", []);
    __publicField(this, "requestedGlyphs", []);
    __publicField(this, "holeIndicies", []);
    __publicField(this, "mesh");
    __publicField(this, "instanceMaterial");
    __publicField(this, "timeTillDecimate");
    this.renderOrder = renderOrder;
    this.object = object;
    this.pixelSize = pixelSize;
    this.root = root;
    this.orderInfo = orderInfo;
    this.instanceMaterial = new InstancedGlyphMaterial(font);
    this.instanceMaterial.depthTest = depthTest;
  }
  setDepthTest(depthTest) {
    this.instanceMaterial.depthTest = depthTest;
    this.root.requestRender();
  }
  setRenderOrder(renderOrder) {
    this.renderOrder = renderOrder;
    if (this.mesh == null) {
      return;
    }
    this.mesh.renderOrder = renderOrder;
    this.root.requestRender();
  }
  requestActivate(glyph) {
    const holeIndex = this.holeIndicies.shift();
    this.root.requestRender();
    if (holeIndex != null) {
      this.glyphs[holeIndex] = glyph;
      glyph.activate(holeIndex);
      return;
    }
    if (this.mesh == null || this.mesh.count >= this.instanceMatrix.count) {
      this.requestedGlyphs.push(glyph);
      return;
    }
    const index = this.mesh.count;
    this.glyphs[index] = glyph;
    glyph.activate(index);
    this.mesh.count += 1;
    return;
  }
  delete(glyph) {
    if (glyph.index == null) {
      const indexInRequested = this.requestedGlyphs.indexOf(glyph);
      if (indexInRequested === -1) {
        return;
      }
      this.requestedGlyphs.splice(indexInRequested, 1);
      return;
    }
    this.root.requestRender();
    const replacement = this.requestedGlyphs.shift();
    if (replacement != null) {
      replacement.activate(glyph.index);
      this.glyphs[glyph.index] = replacement;
      glyph.index = void 0;
      return;
    }
    if (glyph.index === this.glyphs.length - 1) {
      this.glyphs.length -= 1;
      this.mesh.count -= 1;
      glyph.index = void 0;
      return;
    }
    const bufferOffset = glyph.index * 16;
    this.instanceMatrix.array.fill(0, bufferOffset, bufferOffset + 16);
    this.instanceMatrix.addUpdateRange(bufferOffset, 16);
    this.instanceMatrix.needsUpdate = true;
    this.holeIndicies.push(glyph.index);
    this.glyphs[glyph.index] = void 0;
    glyph.index = void 0;
  }
  onFrame(delta) {
    var _a;
    const requiredSize = this.glyphs.length - this.holeIndicies.length + this.requestedGlyphs.length;
    if (this.mesh != null) {
      this.mesh.visible = requiredSize > 0;
    }
    if (requiredSize === 0) {
      return;
    }
    const availableSize = ((_a = this.instanceMatrix) == null ? void 0 : _a.count) ?? 0;
    if (requiredSize < availableSize / 3) {
      this.timeTillDecimate ?? (this.timeTillDecimate = 1);
    } else {
      this.timeTillDecimate = void 0;
    }
    if (this.timeTillDecimate != null) {
      this.timeTillDecimate -= delta;
    }
    if ((this.timeTillDecimate == null || this.timeTillDecimate > 0) && requiredSize <= availableSize) {
      return;
    }
    this.timeTillDecimate = void 0;
    this.resize(requiredSize);
    const indexOffset = this.mesh.count;
    const requestedGlyphsLength = this.requestedGlyphs.length;
    for (let i2 = 0; i2 < requestedGlyphsLength; i2++) {
      const glyph = this.requestedGlyphs[i2];
      glyph.activate(indexOffset + i2);
      this.glyphs[indexOffset + i2] = glyph;
    }
    this.mesh.count += requestedGlyphsLength;
    this.mesh.visible = true;
    this.requestedGlyphs.length = 0;
  }
  resize(neededSize) {
    var _a, _b;
    const newSize = Math.ceil(neededSize * 1.5);
    const matrixArray = new Float32Array(newSize * 16);
    const uvArray = new Float32Array(newSize * 4);
    const rgbaArray = new Float32Array(newSize * 4);
    const clippingArray = new Float32Array(newSize * 16);
    this.instanceMatrix = new InstancedBufferAttribute(matrixArray, 16, false);
    this.instanceMatrix.setUsage(DynamicDrawUsage);
    this.instanceUV = new InstancedBufferAttribute(uvArray, 4, false);
    this.instanceUV.setUsage(DynamicDrawUsage);
    this.instanceRGBA = new InstancedBufferAttribute(rgbaArray, 4, false);
    this.instanceRGBA.setUsage(DynamicDrawUsage);
    this.instanceClipping = new InstancedBufferAttribute(clippingArray, 16, false);
    this.instanceClipping.setUsage(DynamicDrawUsage);
    const oldMesh = this.mesh;
    this.mesh = new InstancedGlyphMesh(this.instanceMatrix, this.instanceRGBA, this.instanceUV, this.instanceClipping, this.instanceMaterial);
    this.mesh.renderOrder = this.renderOrder;
    if (oldMesh != null) {
      this.holeIndicies.sort((i1, i22) => i1 - i22);
      const holesLength = this.holeIndicies.length;
      let afterPrevHoleIndex = 0;
      let i2 = 0;
      while (i2 < holesLength) {
        const holeIndex = this.holeIndicies[i2];
        copyBuffer(afterPrevHoleIndex - i2, afterPrevHoleIndex, holeIndex, oldMesh, this.mesh);
        afterPrevHoleIndex = holeIndex + 1;
        this.glyphs.splice(holeIndex - i2, 1);
        i2++;
      }
      copyBuffer(afterPrevHoleIndex - i2, afterPrevHoleIndex, oldMesh.count, oldMesh, this.mesh);
      if (this.holeIndicies.length > 0) {
        for (let i3 = this.holeIndicies[0]; i3 < this.glyphs.length; i3++) {
          this.glyphs[i3].setIndex(i3);
        }
      }
      this.holeIndicies.length = 0;
      (_a = this.object.current) == null ? void 0 : _a.remove(oldMesh);
      oldMesh.dispose();
    }
    setupRenderOrder(this.mesh, this.root, { value: this.orderInfo });
    this.mesh.count = this.glyphs.length;
    (_b = this.object.current) == null ? void 0 : _b.add(this.mesh);
  }
};
function copyBuffer(target, start, end, oldMesh, newMesh) {
  copy(target, start, end, oldMesh.instanceMatrix.array, newMesh.instanceMatrix.array, 16);
  copy(target, start, end, oldMesh.instanceUV.array, newMesh.instanceUV.array, 4);
  copy(target, start, end, oldMesh.instanceRGBA.array, newMesh.instanceRGBA.array, 4);
  copy(target, start, end, oldMesh.instanceClipping.array, newMesh.instanceClipping.array, 16);
}
function copy(target, start, end, from, to2, itemSize) {
  if (start === end) {
    return;
  }
  const targetIndex = target * itemSize;
  const startIndex = start * itemSize;
  const endIndex = end * itemSize;
  to2.set(from.subarray(startIndex, endIndex), targetIndex);
}

// node_modules/@pmndrs/uikit/dist/responsive.js
var breakPoints = {
  sm: 640,
  md: 768,
  lg: 1024,
  xl: 1280,
  "2xl": 1536
};
var breakPointKeys = Object.keys(breakPoints);
var breakPointKeysLength = breakPointKeys.length;
function createResponsivePropertyTransformers(rootSize) {
  const transformers = {};
  for (let i2 = 0; i2 < breakPointKeysLength; i2++) {
    const key = breakPointKeys[i2];
    transformers[key] = createConditionalPropertyTranslator(() => {
      var _a;
      return (((_a = rootSize.value) == null ? void 0 : _a[0]) ?? 0) > breakPoints[key];
    });
  }
  return transformers;
}

// node_modules/@pmndrs/uikit/dist/dark.js
var queryList = typeof matchMedia === "undefined" ? void 0 : matchMedia == null ? void 0 : matchMedia("(prefers-color-scheme: dark)");
var symstemIsDarkMode = d((queryList == null ? void 0 : queryList.matches) ?? false);
queryList == null ? void 0 : queryList.addEventListener("change", (event) => symstemIsDarkMode.value = event.matches);
var preferredColorScheme = d("system");
var isDarkMode = w(() => {
  switch (preferredColorScheme.value) {
    case "system":
      return symstemIsDarkMode.value;
    case "dark":
      return true;
    case "light":
      return false;
  }
});
function setPreferredColorScheme(scheme) {
  preferredColorScheme.value = scheme;
}
function getPreferredColorScheme() {
  return preferredColorScheme.peek();
}
var darkPropertyTransformers = {
  dark: createConditionalPropertyTranslator(() => isDarkMode.value)
};
function basedOnPreferredColorScheme({ dark, light }) {
  const result = {};
  for (const key in dark) {
    result[key] = w(() => isDarkMode.value ? dark[key] : light[key]);
  }
  return result;
}

// node_modules/@pmndrs/uikit/dist/components/root.js
var DEFAULT_PIXEL_SIZE = 0.01;
var vectorHelper2 = new Vector3();
var planeHelper2 = new Plane();
var identityMatrix = d(new Matrix4());
function createRoot(pixelSize, style, properties, defaultProperties, object, childrenContainer, getCamera, renderer, onFrameSet, requestRender = () => {
}, requestFrame = () => {
}) {
  const rootSize = d([0, 0]);
  const hoveredSignal = d([]);
  const activeSignal = d([]);
  const initializers = [];
  setupCursorCleanup(hoveredSignal, initializers);
  const mergedProperties = computedMergedProperties(style, properties, defaultProperties, {
    ...darkPropertyTransformers,
    ...createResponsivePropertyTransformers(rootSize),
    ...createHoverPropertyTransformers(hoveredSignal),
    ...createActivePropertyTransfomers(activeSignal)
  }, {
    ...createSizeTranslator(pixelSize, "sizeX", "width"),
    ...createSizeTranslator(pixelSize, "sizeY", "height")
  });
  const renderOrder = computedInheritableProperty(mergedProperties, "renderOrder", 0);
  const depthTest = computedInheritableProperty(mergedProperties, "depthTest", true);
  const ctx = {
    cameraDistance: 0,
    onFrameSet,
    requestRender,
    requestFrame,
    pixelSize
  };
  const node = d(void 0);
  const requestCalculateLayout = createDeferredRequestLayoutCalculation(ctx, node, initializers);
  const flexState = createFlexNodeState();
  initializers.push((subscriptions) => {
    const newNode = new FlexNode(flexState, mergedProperties, requestCalculateLayout, object, true, subscriptions);
    node.value = newNode;
    return subscriptions;
  });
  const transformMatrix = computedTransformMatrix(mergedProperties, flexState, pixelSize);
  const rootMatrix = computedRootMatrix(mergedProperties, transformMatrix, flexState.size, pixelSize);
  applyTransform(ctx, object, rootMatrix, initializers);
  const groupDeps = computedPanelGroupDependencies(mergedProperties);
  const orderInfo = computedOrderInfo(void 0, ElementType.Panel, groupDeps, void 0);
  const panelGroupManager = new PanelGroupManager(renderOrder, depthTest, pixelSize, ctx, object, initializers);
  const onCameraDistanceFrame = () => {
    if (object.current == null) {
      ctx.cameraDistance = 0;
      return;
    }
    planeHelper2.normal.set(0, 0, 1);
    planeHelper2.constant = 0;
    planeHelper2.applyMatrix4(object.current.matrixWorld);
    vectorHelper2.setFromMatrixPosition(getCamera().matrixWorld);
    ctx.cameraDistance = planeHelper2.distanceToPoint(vectorHelper2);
  };
  initializers.push(() => {
    onFrameSet.add(onCameraDistanceFrame);
    return () => onFrameSet.delete(onCameraDistanceFrame);
  });
  const isVisible = computedIsVisible(flexState, void 0, mergedProperties);
  initializers.push((subscriptions) => createInstancedPanel(mergedProperties, orderInfo, groupDeps, panelGroupManager, identityMatrix, flexState.size, void 0, flexState.borderInset, void 0, isVisible, getDefaultPanelMaterialConfig(), subscriptions));
  const scrollPosition = createScrollPosition();
  applyScrollPosition(childrenContainer, scrollPosition, pixelSize, initializers);
  const childrenMatrix = computedGlobalScrollMatrix(scrollPosition, identityMatrix, pixelSize);
  createScrollbars(mergedProperties, scrollPosition, flexState, identityMatrix, isVisible, void 0, orderInfo, panelGroupManager, initializers);
  setupLayoutListeners(style, properties, flexState.size, initializers);
  const gylphGroupManager = new GlyphGroupManager(renderOrder, depthTest, pixelSize, ctx, object, initializers);
  const rootCtx = Object.assign(ctx, {
    requestFrame,
    scrollPosition,
    requestCalculateLayout,
    cameraDistance: 0,
    gylphGroupManager,
    object,
    panelGroupManager,
    pixelSize,
    renderOrder,
    depthTest,
    renderer,
    size: flexState.size
  });
  const interactionPanel = createInteractionPanel(orderInfo, rootCtx, void 0, flexState.size, initializers);
  const scrollHandlers = computedScrollHandlers(scrollPosition, void 0, flexState, object, interactionPanel, properties, ctx, initializers);
  return Object.assign(flexState, {
    scrollPosition,
    mergedProperties,
    anyAncestorScrollable: flexState.scrollable,
    clippingRect: computedClippingRect(identityMatrix, flexState, pixelSize, void 0),
    childrenMatrix,
    node,
    orderInfo,
    initializers,
    interactionPanel,
    handlers: computedHandlers(style, properties, defaultProperties, hoveredSignal, activeSignal, scrollHandlers),
    root: rootCtx
  });
}
function createDeferredRequestLayoutCalculation(root, nodeSignal, initializers) {
  let requested = false;
  const onFrame = () => {
    const node = nodeSignal.peek();
    if (!requested || node == null) {
      return;
    }
    requested = false;
    node.calculateLayout();
  };
  initializers.push(() => {
    root.onFrameSet.add(onFrame);
    return () => root.onFrameSet.delete(onFrame);
  });
  return () => {
    requested = true;
    root.requestRender();
  };
}
function createSizeTranslator(pixelSize, key, to2) {
  const map = /* @__PURE__ */ new Map();
  return {
    [key]: (value, target) => {
      let entry = map.get(value);
      if (entry == null) {
        map.set(value, entry = w(() => {
          const s2 = readReactive(value);
          if (s2 == null) {
            return void 0;
          }
          return s2 / pixelSize.value;
        }));
      }
      target.add(to2, entry);
    }
  };
}
var matrixHelper3 = new Matrix4();
var defaultAnchorX = "center";
var defaultAnchorY = "center";
function computedRootMatrix(propertiesSignal, matrix, size, pixelSize) {
  const anchorX = computedInheritableProperty(propertiesSignal, "anchorX", defaultAnchorX);
  const anchorY = computedInheritableProperty(propertiesSignal, "anchorY", defaultAnchorY);
  return w(() => {
    var _a;
    if (size.value == null) {
      return void 0;
    }
    const [width, height] = size.value;
    return (_a = matrix.value) == null ? void 0 : _a.clone().premultiply(matrixHelper3.makeTranslation(alignmentXMap[anchorX.value] * width * pixelSize.value, alignmentYMap[anchorY.value] * height * pixelSize.value, 0));
  });
}

// node_modules/@pmndrs/uikit/dist/components/container.js
function createContainer(parentContext, style, properties, defaultProperties, object, childrenContainer) {
  const node = d(void 0);
  const flexState = createFlexNodeState();
  const hoveredSignal = d([]);
  const activeSignal = d([]);
  const initializers = [];
  setupCursorCleanup(hoveredSignal, initializers);
  const mergedProperties = computedMergedProperties(style, properties, defaultProperties, {
    ...darkPropertyTransformers,
    ...createResponsivePropertyTransformers(parentContext.root.size),
    ...createHoverPropertyTransformers(hoveredSignal),
    ...createActivePropertyTransfomers(activeSignal)
  });
  createNode(node, flexState, parentContext, mergedProperties, object, false, initializers);
  const transformMatrix = computedTransformMatrix(mergedProperties, flexState, parentContext.root.pixelSize);
  applyTransform(parentContext.root, object, transformMatrix, initializers);
  const globalMatrix = computedGlobalMatrix(parentContext.childrenMatrix, transformMatrix);
  const isClipped = computedIsClipped(parentContext.clippingRect, globalMatrix, flexState.size, parentContext.root.pixelSize);
  const isVisible = computedIsVisible(flexState, isClipped, mergedProperties);
  const groupDeps = computedPanelGroupDependencies(mergedProperties);
  const orderInfo = computedOrderInfo(mergedProperties, ElementType.Panel, groupDeps, parentContext.orderInfo);
  initializers.push((subscriptions) => createInstancedPanel(mergedProperties, orderInfo, groupDeps, parentContext.root.panelGroupManager, globalMatrix, flexState.size, void 0, flexState.borderInset, parentContext.clippingRect, isVisible, getDefaultPanelMaterialConfig(), subscriptions));
  const scrollPosition = createScrollPosition();
  applyScrollPosition(childrenContainer, scrollPosition, parentContext.root.pixelSize, initializers);
  const childrenMatrix = computedGlobalScrollMatrix(scrollPosition, globalMatrix, parentContext.root.pixelSize);
  createScrollbars(mergedProperties, scrollPosition, flexState, globalMatrix, isVisible, parentContext.clippingRect, orderInfo, parentContext.root.panelGroupManager, initializers);
  const interactionPanel = createInteractionPanel(orderInfo, parentContext.root, parentContext.clippingRect, flexState.size, initializers);
  const scrollHandlers = computedScrollHandlers(scrollPosition, parentContext.anyAncestorScrollable, flexState, object, interactionPanel, properties, parentContext.root, initializers);
  setupLayoutListeners(style, properties, flexState.size, initializers);
  setupClippedListeners(style, properties, isClipped, initializers);
  return Object.assign(flexState, {
    isClipped,
    mergedProperties,
    anyAncestorScrollable: computedAnyAncestorScrollable(flexState.scrollable, parentContext.anyAncestorScrollable),
    clippingRect: computedClippingRect(globalMatrix, flexState, parentContext.root.pixelSize, parentContext.clippingRect),
    childrenMatrix,
    node,
    orderInfo,
    root: parentContext.root,
    scrollPosition,
    interactionPanel,
    handlers: computedHandlers(style, properties, defaultProperties, hoveredSignal, activeSignal, scrollHandlers),
    initializers
  });
}

// node_modules/@pmndrs/uikit/dist/components/image.js
var defaultImageFit = "fill";
function createImage(parentContext, style, properties, defaultProperties, object, childrenContainer) {
  const initializers = [];
  const texture = d(void 0);
  const hoveredSignal = d([]);
  const activeSignal = d([]);
  setupCursorCleanup(hoveredSignal, initializers);
  const src = w(() => {
    var _a, _b;
    return readReactive((_a = style.value) == null ? void 0 : _a.src) ?? readReactive((_b = properties.value) == null ? void 0 : _b.src);
  });
  loadResourceWithParams(texture, loadTextureImpl, cleanupTexture, initializers, src);
  const textureAspectRatio = w(() => {
    const tex = texture.value;
    if (tex == null) {
      return void 0;
    }
    const image = tex.source.data;
    return image.width / image.height;
  });
  const mergedProperties = computedMergedProperties(style, properties, defaultProperties, {
    ...darkPropertyTransformers,
    ...createResponsivePropertyTransformers(parentContext.root.size),
    ...createHoverPropertyTransformers(hoveredSignal),
    ...createActivePropertyTransfomers(activeSignal)
  }, keepAspectRatioPropertyTransformer, (m) => m.add("aspectRatio", textureAspectRatio));
  const node = d(void 0);
  const flexState = createFlexNodeState();
  createNode(node, flexState, parentContext, mergedProperties, object, true, initializers);
  const transformMatrix = computedTransformMatrix(mergedProperties, flexState, parentContext.root.pixelSize);
  applyTransform(parentContext.root, object, transformMatrix, initializers);
  const globalMatrix = computedGlobalMatrix(parentContext.childrenMatrix, transformMatrix);
  const isClipped = computedIsClipped(parentContext.clippingRect, globalMatrix, flexState.size, parentContext.root.pixelSize);
  const isHidden = w(() => isClipped.value || texture.value == null);
  const isVisible = computedIsVisible(flexState, isHidden, mergedProperties);
  const orderInfo = computedOrderInfo(mergedProperties, ElementType.Image, void 0, parentContext.orderInfo);
  const scrollPosition = createScrollPosition();
  applyScrollPosition(childrenContainer, scrollPosition, parentContext.root.pixelSize, initializers);
  const childrenMatrix = computedGlobalScrollMatrix(scrollPosition, globalMatrix, parentContext.root.pixelSize);
  createScrollbars(mergedProperties, scrollPosition, flexState, globalMatrix, isVisible, parentContext.clippingRect, orderInfo, parentContext.root.panelGroupManager, initializers);
  const interactionPanel = createImageMesh(mergedProperties, texture, parentContext, flexState, orderInfo, parentContext.root, isVisible, initializers);
  const scrollHandlers = computedScrollHandlers(scrollPosition, parentContext.anyAncestorScrollable, flexState, object, interactionPanel, properties, parentContext.root, initializers);
  setupLayoutListeners(style, properties, flexState.size, initializers);
  setupClippedListeners(style, properties, isClipped, initializers);
  return Object.assign(flexState, {
    scrollPosition,
    isClipped,
    mergedProperties,
    anyAncestorScrollable: computedAnyAncestorScrollable(flexState.scrollable, parentContext.anyAncestorScrollable),
    initializers,
    handlers: computedHandlers(style, properties, defaultProperties, hoveredSignal, activeSignal, scrollHandlers),
    interactionPanel,
    clippingRect: computedClippingRect(globalMatrix, flexState, parentContext.root.pixelSize, parentContext.clippingRect),
    childrenMatrix,
    node,
    orderInfo,
    root: parentContext.root
  });
}
var imageMaterialConfig;
function getImageMaterialConfig() {
  imageMaterialConfig ?? (imageMaterialConfig = createPanelMaterialConfig({
    borderBend: "borderBend",
    borderBottomLeftRadius: "borderBottomLeftRadius",
    borderBottomRightRadius: "borderBottomRightRadius",
    borderColor: "borderColor",
    borderOpacity: "borderOpacity",
    borderTopLeftRadius: "borderTopLeftRadius",
    borderTopRightRadius: "borderTopRightRadius",
    backgroundOpacity: "opacity"
  }, {
    backgroundColor: 16777215
  }));
  return imageMaterialConfig;
}
function createImageMesh(propertiesSignal, textureSignal, parentContext, flexState, orderInfo, root, isVisible, initializers) {
  const mesh = new Mesh(panelGeometry);
  mesh.matrixAutoUpdate = false;
  const clippingPlanes = createGlobalClippingPlanes(root, parentContext.clippingRect, initializers);
  const isMeshVisible = getImageMaterialConfig().computedIsVisibile(propertiesSignal, flexState.borderInset, flexState.size, isVisible);
  setupImageMaterials(propertiesSignal, mesh, flexState.size, flexState.borderInset, isMeshVisible, clippingPlanes, root, initializers);
  mesh.raycast = makeClippedCast(mesh, makePanelRaycast(mesh), root.object, parentContext.clippingRect, orderInfo);
  mesh.spherecast = makeClippedCast(mesh, makePanelSpherecast(mesh), root.object, parentContext.clippingRect, orderInfo);
  setupRenderOrder(mesh, root, orderInfo);
  const objectFit = computedInheritableProperty(propertiesSignal, "objectFit", defaultImageFit);
  initializers.push(() => E(() => {
    const texture = textureSignal.value;
    if (texture == null || flexState.size.value == null || flexState.borderInset.value == null) {
      return;
    }
    texture.matrix.identity();
    root.requestRender();
    if (objectFit.value === "fill" || texture == null) {
      transformInsideBorder(flexState.borderInset, flexState.size, texture);
      return;
    }
    const { width: textureWidth, height: textureHeight } = texture.source.data;
    const textureRatio = textureWidth / textureHeight;
    const [width, height] = flexState.size.value;
    const [top, right, bottom, left] = flexState.borderInset.value;
    const boundsRatioValue = (width - left - right) / (height - top - bottom);
    if (textureRatio > boundsRatioValue) {
      texture.matrix.translate(-(0.5 * (boundsRatioValue - textureRatio)) / boundsRatioValue, 0).scale(boundsRatioValue / textureRatio, 1);
    } else {
      texture.matrix.translate(0, -(0.5 * (textureRatio - boundsRatioValue)) / textureRatio).scale(1, textureRatio / boundsRatioValue);
    }
    transformInsideBorder(flexState.borderInset, flexState.size, texture);
  }));
  initializers.push(() => E(() => {
    mesh.visible = isMeshVisible.value;
    parentContext.root.requestRender();
  }));
  initializers.push(() => E(() => {
    const map = textureSignal.value ?? null;
    if (mesh.material.map === map) {
      return;
    }
    mesh.material.map = map;
    mesh.material.needsUpdate = true;
    parentContext.root.requestRender();
  }), () => E(() => {
    if (flexState.size.value == null) {
      return;
    }
    const [width, height] = flexState.size.value;
    const pixelSize = parentContext.root.pixelSize.value;
    mesh.scale.set(width * pixelSize, height * pixelSize, 1);
    mesh.updateMatrix();
    parentContext.root.requestRender();
  }));
  return mesh;
}
function transformInsideBorder(borderInset, size, texture) {
  if (size.value == null || borderInset.value == null) {
    return;
  }
  const [outerWidth, outerHeight] = size.value;
  const [top, right, bottom, left] = borderInset.value;
  const width = outerWidth - left - right;
  const height = outerHeight - top - bottom;
  texture.matrix.translate(-1 + (left + width) / outerWidth, -1 + (top + height) / outerHeight).scale(outerWidth / width, outerHeight / height);
}
var textureLoader = new TextureLoader();
function cleanupTexture(texture) {
  if ((texture == null ? void 0 : texture.disposable) === true) {
    texture.dispose();
  }
}
async function loadTextureImpl(src) {
  if (src == null) {
    return Promise.resolve(void 0);
  }
  if (src instanceof Texture) {
    return Promise.resolve(src);
  }
  try {
    const texture = await textureLoader.loadAsync(src);
    texture.colorSpace = SRGBColorSpace;
    texture.matrixAutoUpdate = false;
    return Object.assign(texture, { disposable: true });
  } catch (error) {
    console.error(error);
    return void 0;
  }
}
function setupImageMaterials(propertiesSignal, target, size, borderInset, isVisible, clippingPlanes, root, initializers) {
  const data = new Float32Array(16);
  const info = { data, type: "normal" };
  target.customDepthMaterial = new PanelDepthMaterial(info);
  target.customDistanceMaterial = new PanelDistanceMaterial(info);
  target.customDepthMaterial.clippingPlanes = clippingPlanes;
  target.customDistanceMaterial.clippingPlanes = clippingPlanes;
  const panelMaterialClass = computedInheritableProperty(propertiesSignal, "panelMaterialClass", MeshBasicMaterial);
  initializers.push((subscriptions) => {
    subscriptions.push(E(() => {
      const material = createPanelMaterial(panelMaterialClass.value, info);
      material.clippingPlanes = clippingPlanes;
      target.material = material;
      return E(() => {
        material.depthTest = root.depthTest.value;
        root.requestRender();
      });
    }), E(() => {
      target.renderOrder = root.renderOrder.value;
      root.requestRender();
    }), E(() => {
      target.castShadow = propertiesSignal.value.read("castShadow", false);
      root.requestRender();
    }), E(() => {
      target.receiveShadow = propertiesSignal.value.read("receiveShadow", false);
      root.requestRender();
    }));
    return subscriptions;
  });
  const imageMaterialConfig2 = getImageMaterialConfig();
  const internalSubscriptions = [];
  initializers.push(() => E(() => {
    if (!isVisible.value) {
      return;
    }
    data.set(imageMaterialConfig2.defaultData);
    internalSubscriptions.push(E(() => size.value != null && data.set(size.value, 13)), E(() => borderInset.value != null && data.set(borderInset.value, 0)));
    root.requestRender();
    return () => unsubscribeSubscriptions(internalSubscriptions);
  }));
  const setters = imageMaterialConfig2.setters;
  initializers.push((subscriptions) => {
    setupImmediateProperties(propertiesSignal, isVisible, imageMaterialConfig2.hasProperty, (key, value) => {
      setters[key](data, 0, value, size, void 0);
      root.requestRender();
    }, subscriptions);
    return subscriptions;
  });
}

// node_modules/@pmndrs/uikit/dist/text/utils.js
function getGlyphOffsetX(font, fontSize, glyphInfo, prevGlyphId) {
  const kerning = prevGlyphId == null ? 0 : font.getKerning(prevGlyphId, glyphInfo.id);
  return (kerning + glyphInfo.xoffset) * fontSize;
}
function lineHeightToAbsolute(lineHeight, fontSize) {
  if (typeof lineHeight === "number") {
    return lineHeight;
  }
  const result = percentageRegex.exec(lineHeight);
  if (result == null) {
    throw new Error(`invalid line height "${lineHeight}"`);
  }
  return fontSize * parseFloat(result[1]) / 100;
}
function getGlyphOffsetY(fontSize, lineHeight, glyphInfo) {
  return ((glyphInfo == null ? void 0 : glyphInfo.yoffset) ?? 0) * fontSize + (lineHeightToAbsolute(lineHeight, fontSize) - fontSize) / 2;
}
function getOffsetToNextGlyph(fontSize, glyphInfo, letterSpacing) {
  return glyphInfo.xadvance * fontSize + letterSpacing;
}
function getOffsetToNextLine(lineHeight, fontSize) {
  return lineHeightToAbsolute(lineHeight, fontSize);
}
function getGlyphLayoutHeight(linesAmount, { lineHeight, fontSize }) {
  return Math.max(linesAmount, 1) * lineHeightToAbsolute(lineHeight, fontSize);
}

// node_modules/@pmndrs/uikit/dist/text/wrapper/breakall-wrapper.js
var BreakallWrapper = ({ text, fontSize, font, letterSpacing }, availableWidth, charIndex, target) => {
  charIndex = skipWhitespace(text, charIndex);
  const firstIndex = charIndex;
  target.charIndexOffset = firstIndex;
  target.nonWhitespaceCharLength = 0;
  target.charLength = 0;
  target.nonWhitespaceWidth = 0;
  target.whitespacesBetween = 0;
  let position = 0;
  let whitespaces = 0;
  for (; charIndex < text.length; charIndex++) {
    const char = text[charIndex];
    if (char === "\n") {
      target.charLength = charIndex - firstIndex + 1;
      return;
    }
    position += getOffsetToNextGlyph(fontSize, font.getGlyphInfo(char), letterSpacing);
    if (char === " ") {
      whitespaces += 1;
      continue;
    }
    if (target.nonWhitespaceWidth > 0 && availableWidth != null && position > availableWidth) {
      break;
    }
    target.nonWhitespaceCharLength = charIndex - firstIndex + 1;
    target.nonWhitespaceWidth = position;
    target.whitespacesBetween = whitespaces;
  }
  target.charLength = charIndex - firstIndex;
};

// node_modules/@pmndrs/uikit/dist/text/wrapper/nowrap-wrapper.js
var NowrapWrapper = ({ text, fontSize, font, letterSpacing }, _3, charIndex, target) => {
  charIndex = skipWhitespace(text, charIndex);
  const firstIndex = charIndex;
  target.charIndexOffset = firstIndex;
  target.nonWhitespaceCharLength = 0;
  target.charLength = 0;
  target.nonWhitespaceWidth = 0;
  target.whitespacesBetween = 0;
  let position = 0;
  let whitespaces = 0;
  for (; charIndex < text.length; charIndex++) {
    const char = text[charIndex];
    if (char === "\n") {
      target.charLength = charIndex - firstIndex + 1;
      return;
    }
    position += getOffsetToNextGlyph(fontSize, font.getGlyphInfo(char), letterSpacing);
    if (char === " ") {
      whitespaces += 1;
      continue;
    }
    target.nonWhitespaceWidth = position;
    target.whitespacesBetween = whitespaces;
    target.nonWhitespaceCharLength = charIndex - firstIndex + 1;
  }
  target.charLength = charIndex - firstIndex;
};

// node_modules/@pmndrs/uikit/dist/text/wrapper/word-wrapper.js
var WordWrapper = ({ text, fontSize, font, letterSpacing }, availableWidth, charIndex, target) => {
  charIndex = skipWhitespace(text, charIndex);
  const firstIndex = charIndex;
  target.charIndexOffset = firstIndex;
  target.nonWhitespaceCharLength = 0;
  target.charLength = 0;
  target.nonWhitespaceWidth = 0;
  target.whitespacesBetween = 0;
  let position = 0;
  let whitespaces = 0;
  for (; charIndex < text.length; charIndex++) {
    const char = text[charIndex];
    if (char === "\n") {
      target.charLength = charIndex - firstIndex + 1;
      break;
    }
    position += getOffsetToNextGlyph(fontSize, font.getGlyphInfo(char), letterSpacing);
    if (char === " ") {
      whitespaces += 1;
      target.charLength = charIndex - firstIndex + 1;
      continue;
    }
    if (target.nonWhitespaceWidth > 0 && availableWidth != null && position > availableWidth) {
      break;
    }
    const nextChar = text[charIndex + 1];
    if (nextChar === " " || nextChar === "\n" || nextChar == null) {
      target.charLength = charIndex - firstIndex + 1;
      target.nonWhitespaceCharLength = target.charLength;
      target.nonWhitespaceWidth = position;
      target.whitespacesBetween = whitespaces;
    }
  }
};

// node_modules/@pmndrs/uikit/dist/text/wrapper/index.js
function skipWhitespace(text, index) {
  const textLength = text.length;
  while (text[index] === " " && index < textLength) {
    index++;
  }
  return index;
}

// node_modules/@pmndrs/uikit/dist/text/cache.js
var fontCache = /* @__PURE__ */ new Map();
var textureLoader2 = new TextureLoader();
function loadCachedFont(url, renderer, onLoad) {
  let entry = fontCache.get(url);
  if (entry instanceof Set) {
    entry.add(onLoad);
    return;
  }
  if (entry != null) {
    onLoad(entry);
    return;
  }
  const set = /* @__PURE__ */ new Set();
  set.add(onLoad);
  fontCache.set(url, set);
  loadFont(url, renderer).then((font) => {
    for (const fn3 of set) {
      fn3(font);
    }
    fontCache.set(url, font);
  }).catch(console.error);
}
async function loadFont(url, renderer) {
  const info = await (await fetch(url)).json();
  if (info.pages.length !== 1) {
    throw new Error("only supporting exactly 1 page");
  }
  const page = await textureLoader2.loadAsync(new URL(info.pages[0], new URL(url, window.location.href)).href);
  page.anisotropy = renderer.capabilities.getMaxAnisotropy();
  page.flipY = false;
  return new Font(info, page);
}

// node_modules/@pmndrs/uikit/dist/text/font.js
var fontWeightNames = {
  thin: 100,
  "extra-light": 200,
  light: 300,
  normal: 400,
  medium: 500,
  "semi-bold": 600,
  bold: 700,
  "extra-bold": 800,
  black: 900,
  "extra-black": 950
};
var defaultFontFamilyUrls = {
  inter: {
    light: "https://pmndrs.github.io/uikit/fonts/inter-light.json",
    normal: "https://pmndrs.github.io/uikit/fonts/inter-normal.json",
    medium: "https://pmndrs.github.io/uikit/fonts/inter-medium.json",
    "semi-bold": "https://pmndrs.github.io/uikit/fonts/inter-semi-bold.json",
    bold: "https://pmndrs.github.io/uikit/fonts/inter-bold.json"
  }
};
function computedFont(properties, fontFamiliesSignal, renderer, initializers) {
  const result = d(void 0);
  const fontFamily = computedInheritableProperty(properties, "fontFamily", void 0);
  const fontWeight = computedInheritableProperty(properties, "fontWeight", "normal");
  initializers.push(() => E(() => {
    const fontFamilies = (fontFamiliesSignal == null ? void 0 : fontFamiliesSignal.value) ?? defaultFontFamilyUrls;
    let resolvedFontFamily = fontFamily.value;
    if (resolvedFontFamily == null) {
      resolvedFontFamily = Object.keys(fontFamilies)[0];
    }
    const url = getMatchingFontUrl(fontFamilies[resolvedFontFamily], typeof fontWeight.value === "string" ? fontWeightNames[fontWeight.value] : fontWeight.value);
    let canceled = false;
    loadCachedFont(url, renderer, (font) => canceled ? void 0 : result.value = font);
    return () => canceled = true;
  }));
  return result;
}
function getMatchingFontUrl(fontFamily, weight) {
  let distance = Infinity;
  let result;
  for (const fontWeight in fontFamily) {
    const d2 = Math.abs(weight - getWeightNumber(fontWeight));
    if (d2 === 0) {
      return fontFamily[fontWeight];
    }
    if (d2 < distance) {
      distance = d2;
      result = fontFamily[fontWeight];
    }
  }
  if (result == null) {
    throw new Error(`font family has no entries ${fontFamily}`);
  }
  return result;
}
function getWeightNumber(value) {
  if (value in fontWeightNames) {
    return fontWeightNames[value];
  }
  const number = parseFloat(value);
  if (isNaN(number)) {
    throw new Error(`invalid font weight "${value}"`);
  }
  return number;
}
var Font = class {
  constructor(info, page) {
    __publicField(this, "page");
    __publicField(this, "glyphInfoMap", /* @__PURE__ */ new Map());
    __publicField(this, "kerningMap", /* @__PURE__ */ new Map());
    __publicField(this, "questionmarkGlyphInfo");
    //needed in the shader:
    __publicField(this, "pageWidth");
    __publicField(this, "pageHeight");
    __publicField(this, "distanceRange");
    this.page = page;
    const { scaleW, scaleH, lineHeight } = info.common;
    this.pageWidth = scaleW;
    this.pageHeight = scaleH;
    this.distanceRange = info.distanceField.distanceRange;
    const { size } = info.info;
    for (const glyph of info.chars) {
      glyph.uvX = glyph.x / scaleW;
      glyph.uvY = glyph.y / scaleH;
      glyph.uvWidth = glyph.width / scaleW;
      glyph.uvHeight = glyph.height / scaleH;
      glyph.width /= size;
      glyph.height /= size;
      glyph.xadvance /= size;
      glyph.xoffset /= size;
      glyph.yoffset -= lineHeight - size;
      glyph.yoffset /= size;
      this.glyphInfoMap.set(glyph.char, glyph);
    }
    for (const { first, second, amount } of info.kernings) {
      this.kerningMap.set(`${first}/${second}`, amount / size);
    }
    const questionmarkGlyphInfo = this.glyphInfoMap.get("?");
    if (questionmarkGlyphInfo == null) {
      throw new Error("missing '?' glyph in font");
    }
    this.questionmarkGlyphInfo = questionmarkGlyphInfo;
  }
  getGlyphInfo(char) {
    return this.glyphInfoMap.get(char) ?? (char == "\n" ? this.glyphInfoMap.get(" ") : this.questionmarkGlyphInfo) ?? this.questionmarkGlyphInfo;
  }
  getKerning(firstId, secondId) {
    return this.kerningMap.get(`${firstId}/${secondId}`) ?? 0;
  }
};
function glyphIntoToUV(info, target, offset) {
  target[offset + 0] = info.uvX;
  target[offset + 1] = info.uvY + info.uvHeight;
  target[offset + 2] = info.uvWidth;
  target[offset + 3] = -info.uvHeight;
}

// node_modules/@pmndrs/uikit/dist/text/layout.js
function computedCustomLayouting(properties, fontSignal, textSignal, propertiesRef, defaultWordBreak) {
  const fontSize = computedInheritableProperty(properties, "fontSize", 16);
  const letterSpacing = computedInheritableProperty(properties, "letterSpacing", 0);
  const lineHeight = computedInheritableProperty(properties, "lineHeight", "120%");
  const wordBreak = computedInheritableProperty(properties, "wordBreak", defaultWordBreak);
  return w(() => {
    const font = fontSignal.value;
    if (font == null) {
      return void 0;
    }
    const text = textSignal.value;
    const layoutProperties = {
      font,
      fontSize: fontSize.value,
      letterSpacing: letterSpacing.value,
      lineHeight: lineHeight.value,
      text: Array.isArray(text) ? text.map((t2) => readReactive(t2)).join("") : readReactive(text),
      wordBreak: wordBreak.value
    };
    propertiesRef.current = layoutProperties;
    const { width: minWidth } = measureGlyphLayout(layoutProperties, 0);
    const { height: minHeight } = measureGlyphLayout(layoutProperties, void 0);
    return {
      minHeight,
      minWidth,
      measure: (width, widthMode) => measureGlyphLayout(layoutProperties, widthMode === MeasureMode.Undefined ? void 0 : width)
    };
  });
}
var wrappers = {
  "keep-all": NowrapWrapper,
  "break-all": BreakallWrapper,
  "break-word": WordWrapper
};
var lineHelper = {};
function measureGlyphLayout(properties, availableWidth) {
  const wrapper = wrappers[properties.wordBreak];
  const text = properties.text;
  let width = 0;
  let lines = 0;
  let charIndex = 0;
  while (charIndex < text.length) {
    wrapper(properties, availableWidth, charIndex, lineHelper);
    width = Math.max(width, lineHelper.nonWhitespaceWidth);
    lines += 1;
    charIndex = lineHelper.charLength + lineHelper.charIndexOffset;
  }
  if (text[text.length - 1] === "\n") {
    lines += 1;
  }
  return { width, height: getGlyphLayoutHeight(lines, properties) };
}
function buildGlyphLayout(properties, availableWidth, availableHeight) {
  const lines = [];
  const wrapper = wrappers[properties.wordBreak];
  const text = properties.text;
  let charIndex = 0;
  while (charIndex < text.length) {
    const line = {};
    wrapper(properties, availableWidth, charIndex, line);
    lines.push(line);
    charIndex = line.charLength + line.charIndexOffset;
  }
  if (lines.length === 0 || text[text.length - 1] === "\n") {
    lines.push({
      charLength: 0,
      nonWhitespaceWidth: 0,
      whitespacesBetween: 0,
      charIndexOffset: text.length,
      nonWhitespaceCharLength: 0
    });
  }
  return {
    lines,
    availableHeight,
    availableWidth,
    ...properties
  };
}

// node_modules/@pmndrs/uikit/dist/text/render/instanced-glyph.js
var helperMatrix1 = new Matrix4();
var helperMatrix2 = new Matrix4();
function computedGylphGroupDependencies(fontSignal) {
  return w(() => ({ font: fontSignal.value }));
}
var InstancedGlyph = class {
  constructor(group, baseMatrix, color, opacity, clippingRect) {
    __publicField(this, "group");
    __publicField(this, "baseMatrix");
    __publicField(this, "color");
    __publicField(this, "opacity");
    __publicField(this, "clippingRect");
    __publicField(this, "index");
    __publicField(this, "hidden", true);
    __publicField(this, "glyphInfo");
    __publicField(this, "x", 0);
    __publicField(this, "y", 0);
    __publicField(this, "fontSize", 0);
    __publicField(this, "pixelSize", 0);
    this.group = group;
    this.baseMatrix = baseMatrix;
    this.color = color;
    this.opacity = opacity;
    this.clippingRect = clippingRect;
  }
  getX(widthMultiplier) {
    if (this.glyphInfo == null) {
      return this.x;
    }
    return this.x + widthMultiplier * this.glyphInfo.width * this.fontSize;
  }
  show() {
    if (!this.hidden) {
      return;
    }
    this.hidden = false;
    this.group.requestActivate(this);
  }
  hide() {
    if (this.hidden) {
      return;
    }
    this.hidden = true;
    this.group.delete(this);
  }
  activate(index) {
    this.index = index;
    this.writeUpdatedMatrix();
    this.writeUV();
    this.updateColor(this.color);
    this.updateOpacity(this.opacity);
    this.updateClippingRect(this.clippingRect);
  }
  setIndex(index) {
    this.index = index;
  }
  updateClippingRect(clippingRect) {
    this.clippingRect = clippingRect;
    if (this.index == null) {
      return;
    }
    const offset = this.index * 16;
    const { instanceClipping, root } = this.group;
    if (this.clippingRect == null) {
      instanceClipping.set(defaultClippingData, offset);
    } else {
      this.clippingRect.toArray(instanceClipping.array, offset);
    }
    instanceClipping.addUpdateRange(offset, 16);
    instanceClipping.needsUpdate = true;
    root.requestRender();
  }
  updateColor(color) {
    this.color = color;
    if (this.index == null) {
      return;
    }
    const { instanceRGBA, root } = this.group;
    const offset = instanceRGBA.itemSize * this.index;
    writeColor(instanceRGBA.array, offset, color, void 0);
    instanceRGBA.addUpdateRange(offset, 3);
    instanceRGBA.needsUpdate = true;
    root.requestRender();
  }
  updateOpacity(opacity) {
    this.opacity = opacity;
    if (this.index == null) {
      return;
    }
    const { instanceRGBA, root } = this.group;
    const bufferIndex = this.index * 4 + 3;
    instanceRGBA.array[bufferIndex] = opacity;
    instanceRGBA.addUpdateRange(bufferIndex, 1);
    instanceRGBA.needsUpdate = true;
    root.requestRender();
  }
  updateGlyphAndTransformation(glyphInfo, x2, y3, fontSize, pixelSize) {
    if (this.glyphInfo === glyphInfo && this.x === x2 && this.y === y3 && this.fontSize === fontSize && this.pixelSize === pixelSize) {
      return;
    }
    if (this.glyphInfo != glyphInfo) {
      this.glyphInfo = glyphInfo;
      this.writeUV();
    }
    this.x = x2;
    this.y = y3;
    this.fontSize = fontSize;
    this.pixelSize = pixelSize;
    this.writeUpdatedMatrix();
  }
  updateBaseMatrix(baseMatrix) {
    if (this.baseMatrix === baseMatrix) {
      return;
    }
    this.baseMatrix = baseMatrix;
    this.writeUpdatedMatrix();
  }
  writeUV() {
    if (this.index == null || this.glyphInfo == null) {
      return;
    }
    const offset = this.index * 4;
    const { instanceUV, root } = this.group;
    glyphIntoToUV(this.glyphInfo, instanceUV.array, offset);
    instanceUV.addUpdateRange(offset, 4);
    instanceUV.needsUpdate = true;
    root.requestRender();
  }
  writeUpdatedMatrix() {
    if (this.index == null || this.glyphInfo == null || this.baseMatrix == null) {
      return;
    }
    const offset = this.index * 16;
    const { instanceMatrix, root } = this.group;
    instanceMatrix.addUpdateRange(offset, 16);
    helperMatrix1.makeTranslation(this.x * this.pixelSize, this.y * this.pixelSize, 0).multiply(helperMatrix2.makeScale(this.fontSize * this.glyphInfo.width * this.pixelSize, this.fontSize * this.glyphInfo.height * this.pixelSize, 1)).premultiply(this.baseMatrix);
    helperMatrix1.toArray(instanceMatrix.array, offset);
    instanceMatrix.needsUpdate = true;
    root.requestRender();
  }
};

// node_modules/@pmndrs/uikit/dist/text/render/instanced-text.js
var defaultVerticalAlign = "middle";
var defaulttextAlign = "left";
function createInstancedText(properties, textSignal, matrix, nodeSignal, flexState, isVisible, parentClippingRect, orderInfo, fontSignal, glyphGroupManager, selectionRange, selectionBoxes, caretPosition, instancedTextRef, initializers, defaultWordBreak) {
  let layoutPropertiesRef = { current: void 0 };
  const customLayouting = computedCustomLayouting(properties, fontSignal, textSignal, layoutPropertiesRef, defaultWordBreak);
  const verticalAlign = computedInheritableProperty(properties, "verticalAlign", defaultVerticalAlign);
  const textAlign = computedInheritableProperty(properties, "textAlign", defaulttextAlign);
  const color = computedInheritableProperty(properties, "color", 0);
  const opacity = computedInheritableProperty(properties, "opacity", 1);
  const layoutSignal = d(void 0);
  initializers.push(() => E(() => {
    var _a;
    return (_a = nodeSignal.value) == null ? void 0 : _a.addLayoutChangeListener(() => {
      const layoutProperties = layoutPropertiesRef.current;
      const { size: { value: size }, paddingInset: { value: paddingInset }, borderInset: { value: borderInset } } = flexState;
      if (layoutProperties == null || size == null || paddingInset == null || borderInset == null) {
        return;
      }
      const [width, height] = size;
      const [pTop, pRight, pBottom, pLeft] = paddingInset;
      const [bTop, bRight, bBottom, bLeft] = borderInset;
      const actualWidth = width - pRight - pLeft - bRight - bLeft;
      const actualheight = height - pTop - pBottom - bTop - bBottom;
      layoutSignal.value = buildGlyphLayout(layoutProperties, actualWidth, actualheight);
    });
  }), () => E(() => {
    const font = fontSignal.value;
    if (font == null || orderInfo.value == null) {
      return;
    }
    const instancedText = new InstancedText(glyphGroupManager.getGroup(orderInfo.value.majorIndex, font), textAlign, verticalAlign, color, opacity, layoutSignal, matrix, isVisible, parentClippingRect, selectionRange, selectionBoxes, caretPosition);
    if (instancedTextRef != null) {
      instancedTextRef.current = instancedText;
    }
    return () => instancedText.destroy();
  }));
  return customLayouting;
}
var noSelectionBoxes = [];
var InstancedText = class {
  constructor(group, textAlign, verticalAlign, color, opacity, layoutSignal, matrix, isVisible, parentClippingRect, selectionRange, selectionBoxes, caretPosition) {
    __publicField(this, "group");
    __publicField(this, "textAlign");
    __publicField(this, "verticalAlign");
    __publicField(this, "color");
    __publicField(this, "opacity");
    __publicField(this, "layoutSignal");
    __publicField(this, "matrix");
    __publicField(this, "parentClippingRect");
    __publicField(this, "selectionRange");
    __publicField(this, "selectionBoxes");
    __publicField(this, "caretPosition");
    __publicField(this, "glyphLines", []);
    __publicField(this, "lastLayout");
    __publicField(this, "unsubscribeInitialList", []);
    __publicField(this, "unsubscribeShowList", []);
    this.group = group;
    this.textAlign = textAlign;
    this.verticalAlign = verticalAlign;
    this.color = color;
    this.opacity = opacity;
    this.layoutSignal = layoutSignal;
    this.matrix = matrix;
    this.parentClippingRect = parentClippingRect;
    this.selectionRange = selectionRange;
    this.selectionBoxes = selectionBoxes;
    this.caretPosition = caretPosition;
    this.unsubscribeInitialList = [
      E(() => {
        if (!isVisible.value || opacity.value < 0.01) {
          this.hide();
          return;
        }
        this.show();
      }),
      E(() => this.updateSelectionBoxes(this.lastLayout, selectionRange == null ? void 0 : selectionRange.value, verticalAlign.peek(), textAlign.peek()))
    ];
  }
  getCharIndex(x2, y3) {
    const layout = this.lastLayout;
    if (layout == null) {
      return 0;
    }
    y3 -= -getYOffset(layout, this.verticalAlign.peek());
    const lineIndex = Math.floor(y3 / -getOffsetToNextLine(layout.lineHeight, layout.fontSize));
    const lines = layout.lines;
    if (lineIndex < 0 || lines.length === 0) {
      return 0;
    }
    if (lineIndex >= lines.length) {
      const lastLine = lines[lines.length - 1];
      return lastLine.charIndexOffset + lastLine.charLength + 1;
    }
    const line = lines[lineIndex];
    const whitespaceWidth = layout.font.getGlyphInfo(" ").xadvance * layout.fontSize;
    const glyphs = this.glyphLines[lineIndex];
    let glyphsLength = glyphs.length;
    for (let i2 = 0; i2 < glyphsLength; i2++) {
      const entry = glyphs[i2];
      if (x2 < this.getGlyphX(entry, 0.5, whitespaceWidth) + layout.availableWidth / 2) {
        return i2 + line.charIndexOffset;
      }
    }
    return line.charIndexOffset + line.charLength + 1;
  }
  updateSelectionBoxes(layout, range, verticalAlign, textAlign) {
    if (this.caretPosition == null || this.selectionBoxes == null) {
      return;
    }
    if (range == null || layout == null || layout.lines.length === 0) {
      this.caretPosition.value = void 0;
      this.selectionBoxes.value = noSelectionBoxes;
      return;
    }
    const whitespaceWidth = layout.font.getGlyphInfo(" ").xadvance * layout.fontSize;
    const [startCharIndexIncl, endCharIndexExcl] = range;
    if (endCharIndexExcl <= startCharIndexIncl) {
      const { lineIndex, x: x2 } = this.getGlyphLineAndX(layout, endCharIndexExcl, true, whitespaceWidth, textAlign);
      const y3 = -(getYOffset(layout, verticalAlign) - layout.availableHeight / 2 + lineIndex * getOffsetToNextLine(layout.lineHeight, layout.fontSize) + getGlyphOffsetY(layout.fontSize, layout.lineHeight));
      this.caretPosition.value = [x2, y3 - layout.fontSize / 2, layout.fontSize];
      this.selectionBoxes.value = [];
      return;
    }
    this.caretPosition.value = void 0;
    const start = this.getGlyphLineAndX(layout, startCharIndexIncl, true, whitespaceWidth, textAlign);
    const end = this.getGlyphLineAndX(layout, endCharIndexExcl - 1, false, whitespaceWidth, textAlign);
    if (start.lineIndex === end.lineIndex) {
      this.selectionBoxes.value = [
        this.computeSelectionBox(start.lineIndex, start.x, end.x, layout, verticalAlign, whitespaceWidth)
      ];
      return;
    }
    const newSelectionBoxes = [
      this.computeSelectionBox(start.lineIndex, start.x, void 0, layout, verticalAlign, whitespaceWidth)
    ];
    for (let i2 = start.lineIndex + 1; i2 < end.lineIndex; i2++) {
      newSelectionBoxes.push(this.computeSelectionBox(i2, void 0, void 0, layout, verticalAlign, whitespaceWidth));
    }
    newSelectionBoxes.push(this.computeSelectionBox(end.lineIndex, void 0, end.x, layout, verticalAlign, whitespaceWidth));
    this.selectionBoxes.value = newSelectionBoxes;
  }
  computeSelectionBox(lineIndex, startX, endX, layout, verticalAlign, whitespaceWidth) {
    const lineGlyphs = this.glyphLines[lineIndex];
    if (startX == null) {
      startX = this.getGlyphX(lineGlyphs[0], 0, whitespaceWidth);
    }
    if (endX == null) {
      endX = this.getGlyphX(lineGlyphs[lineGlyphs.length - 1], 1, whitespaceWidth);
    }
    const height = getOffsetToNextLine(layout.lineHeight, layout.fontSize);
    const y3 = -(getYOffset(layout, verticalAlign) - layout.availableHeight / 2 + lineIndex * height);
    const width = endX - startX;
    return { position: [startX + width / 2, y3 - height / 2], size: [width, height] };
  }
  getGlyphLineAndX({ lines, availableWidth }, charIndex, start, whitespaceWidth, textAlign) {
    const linesLength = lines.length;
    for (let lineIndex = 0; lineIndex < linesLength; lineIndex++) {
      const line = lines[lineIndex];
      if (charIndex >= line.charIndexOffset + line.charLength) {
        continue;
      }
      const glyphEntry = this.glyphLines[lineIndex][Math.max(charIndex - line.charIndexOffset, 0)];
      return { lineIndex, x: this.getGlyphX(glyphEntry, start ? 0 : 1, whitespaceWidth) };
    }
    const lastLine = lines[linesLength - 1];
    if (lastLine.charLength === 0) {
      return {
        lineIndex: linesLength - 1,
        x: getXOffset(availableWidth, lastLine.nonWhitespaceWidth, textAlign) - availableWidth / 2
      };
    }
    const lastGlyphEntry = this.glyphLines[linesLength - 1][lastLine.charLength - 1];
    return { lineIndex: linesLength - 1, x: this.getGlyphX(lastGlyphEntry, 1, whitespaceWidth) };
  }
  getGlyphX(entry, widthMultiplier, whitespaceWidth) {
    if (typeof entry === "number") {
      return entry + widthMultiplier * whitespaceWidth;
    }
    return entry.getX(widthMultiplier);
  }
  show() {
    if (this.unsubscribeShowList.length > 0) {
      return;
    }
    traverseGlyphs(this.glyphLines, (glyph) => glyph.show());
    this.unsubscribeShowList.push(E(() => {
      const matrix = this.matrix.value;
      if (matrix == null) {
        return;
      }
      traverseGlyphs(this.glyphLines, (glyph) => glyph.updateBaseMatrix(matrix));
    }), E(() => {
      var _a;
      const clippingRect = (_a = this.parentClippingRect) == null ? void 0 : _a.value;
      traverseGlyphs(this.glyphLines, (glyph) => glyph.updateClippingRect(clippingRect));
    }), E(() => {
      const color = this.color.value;
      traverseGlyphs(this.glyphLines, (glyph) => glyph.updateColor(color));
    }), E(() => {
      const opacity = this.opacity.value;
      traverseGlyphs(this.glyphLines, (glyph) => glyph.updateOpacity(opacity));
    }), E(() => {
      var _a, _b;
      const layout = this.layoutSignal.value;
      if (layout == null) {
        return;
      }
      const { text, font, lines, letterSpacing = 0, fontSize = 16, lineHeight = 1.2, availableWidth } = layout;
      let y3 = getYOffset(layout, this.verticalAlign.value) - layout.availableHeight / 2;
      const linesLength = lines.length;
      const pixelSize = this.group.pixelSize.value;
      for (let lineIndex = 0; lineIndex < linesLength; lineIndex++) {
        if (lineIndex === this.glyphLines.length) {
          this.glyphLines.push([]);
        }
        const { whitespacesBetween, nonWhitespaceWidth, charIndexOffset: firstNonWhitespaceCharIndex, nonWhitespaceCharLength, charLength } = lines[lineIndex];
        let offsetPerWhitespace = this.textAlign.value === "block" ? (availableWidth - nonWhitespaceWidth) / whitespacesBetween : 0;
        let x2 = getXOffset(availableWidth, nonWhitespaceWidth, this.textAlign.value) - availableWidth / 2;
        let prevGlyphId;
        const glyphs = this.glyphLines[lineIndex];
        for (let charIndex = firstNonWhitespaceCharIndex; charIndex < firstNonWhitespaceCharIndex + charLength; charIndex++) {
          const glyphIndex = charIndex - firstNonWhitespaceCharIndex;
          const char = text[charIndex];
          const glyphInfo = font.getGlyphInfo(char);
          if (char === " " || charIndex > nonWhitespaceCharLength + firstNonWhitespaceCharIndex) {
            prevGlyphId = glyphInfo.id;
            const xPosition = x2 + getGlyphOffsetX(font, fontSize, glyphInfo, prevGlyphId);
            if (typeof glyphs[glyphIndex] === "number") {
              glyphs[glyphIndex] = x2;
            } else {
              glyphs.splice(glyphIndex, 0, xPosition);
            }
            x2 += offsetPerWhitespace + getOffsetToNextGlyph(fontSize, glyphInfo, letterSpacing);
            continue;
          }
          let glyphOrNumber = glyphs[glyphIndex];
          while (glyphIndex < glyphs.length && typeof glyphOrNumber == "number") {
            glyphs.splice(glyphIndex, 1);
            glyphOrNumber = glyphs[glyphIndex];
          }
          let glyph = glyphOrNumber;
          if (glyph == null) {
            glyphs[glyphIndex] = glyph = new InstancedGlyph(this.group, this.matrix.peek(), this.color.peek(), this.opacity.peek(), (_a = this.parentClippingRect) == null ? void 0 : _a.peek());
          }
          glyph.updateGlyphAndTransformation(glyphInfo, x2 + getGlyphOffsetX(font, fontSize, glyphInfo, prevGlyphId), -(y3 + getGlyphOffsetY(fontSize, lineHeight, glyphInfo)), fontSize, pixelSize);
          glyph.show();
          prevGlyphId = glyphInfo.id;
          x2 += getOffsetToNextGlyph(fontSize, glyphInfo, letterSpacing);
        }
        y3 += getOffsetToNextLine(lineHeight, fontSize);
        const glyphsLength = glyphs.length;
        const newGlyphsLength = charLength;
        for (let ii2 = newGlyphsLength; ii2 < glyphsLength; ii2++) {
          const glyph = glyphs[ii2];
          if (typeof glyph === "number") {
            continue;
          }
          glyph.hide();
        }
        glyphs.length = newGlyphsLength;
      }
      traverseGlyphs(this.glyphLines, (glyph) => glyph.hide(), linesLength);
      this.glyphLines.length = linesLength;
      this.lastLayout = layout;
      this.updateSelectionBoxes(layout, (_b = this.selectionRange) == null ? void 0 : _b.peek(), this.verticalAlign.value, this.textAlign.value);
    }));
  }
  hide() {
    const unsubscribeListLength = this.unsubscribeShowList.length;
    if (unsubscribeListLength === 0) {
      return;
    }
    for (let i2 = 0; i2 < unsubscribeListLength; i2++) {
      this.unsubscribeShowList[i2]();
    }
    this.unsubscribeShowList.length = 0;
    traverseGlyphs(this.glyphLines, (glyph) => glyph.hide());
  }
  destroy() {
    this.hide();
    this.glyphLines.length = 0;
    const length = this.unsubscribeInitialList.length;
    for (let i2 = 0; i2 < length; i2++) {
      this.unsubscribeInitialList[i2]();
    }
  }
};
function getXOffset(availableWidth, nonWhitespaceWidth, textAlign) {
  switch (textAlign) {
    case "right":
      return availableWidth - nonWhitespaceWidth;
    case "center":
      return (availableWidth - nonWhitespaceWidth) / 2;
    default:
      return 0;
  }
}
function getYOffset(layout, verticalAlign) {
  switch (verticalAlign) {
    case "center":
    case "middle":
      return (layout.availableHeight - getGlyphLayoutHeight(layout.lines.length, layout)) / 2;
    case "bottom":
      return layout.availableHeight - getGlyphLayoutHeight(layout.lines.length, layout);
    default:
      return 0;
  }
}
function traverseGlyphs(glyphLines, fn3, offset = 0) {
  const glyphLinesLength = glyphLines.length;
  for (let i2 = offset; i2 < glyphLinesLength; i2++) {
    const glyphs = glyphLines[i2];
    const glyphsLength = glyphs.length;
    for (let ii2 = 0; ii2 < glyphsLength; ii2++) {
      const glyph = glyphs[ii2];
      if (typeof glyph == "number") {
        continue;
      }
      fn3(glyph);
    }
  }
}

// node_modules/@pmndrs/uikit/dist/components/text.js
function createText(parentContext, textSignal, fontFamilies, style, properties, defaultProperties, object) {
  const hoveredSignal = d([]);
  const activeSignal = d([]);
  const initializers = [];
  setupCursorCleanup(hoveredSignal, initializers);
  const mergedProperties = computedMergedProperties(style, properties, defaultProperties, {
    ...darkPropertyTransformers,
    ...createResponsivePropertyTransformers(parentContext.root.size),
    ...createHoverPropertyTransformers(hoveredSignal),
    ...createActivePropertyTransfomers(activeSignal)
  });
  const nodeSignal = d(void 0);
  const flexState = createFlexNodeState();
  createNode(nodeSignal, flexState, parentContext, mergedProperties, object, false, initializers);
  const transformMatrix = computedTransformMatrix(mergedProperties, flexState, parentContext.root.pixelSize);
  applyTransform(parentContext.root, object, transformMatrix, initializers);
  const globalMatrix = computedGlobalMatrix(parentContext.childrenMatrix, transformMatrix);
  const isClipped = computedIsClipped(parentContext.clippingRect, globalMatrix, flexState.size, parentContext.root.pixelSize);
  const isVisible = computedIsVisible(flexState, isClipped, mergedProperties);
  const groupDeps = computedPanelGroupDependencies(mergedProperties);
  const backgroundOrderInfo = computedOrderInfo(mergedProperties, ElementType.Panel, groupDeps, parentContext.orderInfo);
  initializers.push((subscriptions) => createInstancedPanel(mergedProperties, backgroundOrderInfo, groupDeps, parentContext.root.panelGroupManager, globalMatrix, flexState.size, void 0, flexState.borderInset, parentContext.clippingRect, isVisible, getDefaultPanelMaterialConfig(), subscriptions));
  const fontSignal = computedFont(mergedProperties, fontFamilies, parentContext.root.renderer, initializers);
  const orderInfo = computedOrderInfo(void 0, ElementType.Text, computedGylphGroupDependencies(fontSignal), backgroundOrderInfo);
  const customLayouting = createInstancedText(mergedProperties, textSignal, globalMatrix, nodeSignal, flexState, isVisible, parentContext.clippingRect, orderInfo, fontSignal, parentContext.root.gylphGroupManager, void 0, void 0, void 0, void 0, initializers, "break-word");
  initializers.push(() => E(() => {
    var _a;
    return (_a = nodeSignal.value) == null ? void 0 : _a.setCustomLayouting(customLayouting.value);
  }));
  setupLayoutListeners(style, properties, flexState.size, initializers);
  setupClippedListeners(style, properties, isClipped, initializers);
  return Object.assign(flexState, {
    isClipped,
    mergedProperties,
    interactionPanel: createInteractionPanel(backgroundOrderInfo, parentContext.root, parentContext.clippingRect, flexState.size, initializers),
    handlers: computedHandlers(style, properties, defaultProperties, hoveredSignal, activeSignal),
    initializers
  });
}

// node_modules/three/examples/jsm/loaders/SVGLoader.js
var COLOR_SPACE_SVG = SRGBColorSpace;
var SVGLoader = class _SVGLoader extends Loader {
  constructor(manager) {
    super(manager);
    this.defaultDPI = 90;
    this.defaultUnit = "px";
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader3 = new FileLoader(scope.manager);
    loader3.setPath(scope.path);
    loader3.setRequestHeader(scope.requestHeader);
    loader3.setWithCredentials(scope.withCredentials);
    loader3.load(url, function(text) {
      try {
        onLoad(scope.parse(text));
      } catch (e2) {
        if (onError) {
          onError(e2);
        } else {
          console.error(e2);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(text) {
    const scope = this;
    function parseNode(node, style) {
      if (node.nodeType !== 1)
        return;
      const transform = getNodeTransform(node);
      let isDefsNode = false;
      let path = null;
      switch (node.nodeName) {
        case "svg":
          style = parseStyle(node, style);
          break;
        case "style":
          parseCSSStylesheet(node);
          break;
        case "g":
          style = parseStyle(node, style);
          break;
        case "path":
          style = parseStyle(node, style);
          if (node.hasAttribute("d"))
            path = parsePathNode(node);
          break;
        case "rect":
          style = parseStyle(node, style);
          path = parseRectNode(node);
          break;
        case "polygon":
          style = parseStyle(node, style);
          path = parsePolygonNode(node);
          break;
        case "polyline":
          style = parseStyle(node, style);
          path = parsePolylineNode(node);
          break;
        case "circle":
          style = parseStyle(node, style);
          path = parseCircleNode(node);
          break;
        case "ellipse":
          style = parseStyle(node, style);
          path = parseEllipseNode(node);
          break;
        case "line":
          style = parseStyle(node, style);
          path = parseLineNode(node);
          break;
        case "defs":
          isDefsNode = true;
          break;
        case "use":
          style = parseStyle(node, style);
          const href = node.getAttributeNS("http://www.w3.org/1999/xlink", "href") || "";
          const usedNodeId = href.substring(1);
          const usedNode = node.viewportElement.getElementById(usedNodeId);
          if (usedNode) {
            parseNode(usedNode, style);
          } else {
            console.warn("SVGLoader: 'use node' references non-existent node id: " + usedNodeId);
          }
          break;
        default:
      }
      if (path) {
        if (style.fill !== void 0 && style.fill !== "none") {
          path.color.setStyle(style.fill, COLOR_SPACE_SVG);
        }
        transformPath(path, currentTransform);
        paths.push(path);
        path.userData = { node, style };
      }
      const childNodes = node.childNodes;
      for (let i2 = 0; i2 < childNodes.length; i2++) {
        const node2 = childNodes[i2];
        if (isDefsNode && node2.nodeName !== "style" && node2.nodeName !== "defs") {
          continue;
        }
        parseNode(node2, style);
      }
      if (transform) {
        transformStack.pop();
        if (transformStack.length > 0) {
          currentTransform.copy(transformStack[transformStack.length - 1]);
        } else {
          currentTransform.identity();
        }
      }
    }
    function parsePathNode(node) {
      const path = new ShapePath();
      const point = new Vector2();
      const control = new Vector2();
      const firstPoint = new Vector2();
      let isFirstPoint = true;
      let doSetFirstPoint = false;
      const d2 = node.getAttribute("d");
      if (d2 === "" || d2 === "none")
        return null;
      const commands = d2.match(/[a-df-z][^a-df-z]*/ig);
      for (let i2 = 0, l2 = commands.length; i2 < l2; i2++) {
        const command = commands[i2];
        const type = command.charAt(0);
        const data2 = command.slice(1).trim();
        if (isFirstPoint === true) {
          doSetFirstPoint = true;
          isFirstPoint = false;
        }
        let numbers;
        switch (type) {
          case "M":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2 += 2) {
              point.x = numbers[j2 + 0];
              point.y = numbers[j2 + 1];
              control.x = point.x;
              control.y = point.y;
              if (j2 === 0) {
                path.moveTo(point.x, point.y);
              } else {
                path.lineTo(point.x, point.y);
              }
              if (j2 === 0)
                firstPoint.copy(point);
            }
            break;
          case "H":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2++) {
              point.x = numbers[j2];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "V":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2++) {
              point.y = numbers[j2];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "L":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2 += 2) {
              point.x = numbers[j2 + 0];
              point.y = numbers[j2 + 1];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "C":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2 += 6) {
              path.bezierCurveTo(
                numbers[j2 + 0],
                numbers[j2 + 1],
                numbers[j2 + 2],
                numbers[j2 + 3],
                numbers[j2 + 4],
                numbers[j2 + 5]
              );
              control.x = numbers[j2 + 2];
              control.y = numbers[j2 + 3];
              point.x = numbers[j2 + 4];
              point.y = numbers[j2 + 5];
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "S":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2 += 4) {
              path.bezierCurveTo(
                getReflection(point.x, control.x),
                getReflection(point.y, control.y),
                numbers[j2 + 0],
                numbers[j2 + 1],
                numbers[j2 + 2],
                numbers[j2 + 3]
              );
              control.x = numbers[j2 + 0];
              control.y = numbers[j2 + 1];
              point.x = numbers[j2 + 2];
              point.y = numbers[j2 + 3];
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "Q":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2 += 4) {
              path.quadraticCurveTo(
                numbers[j2 + 0],
                numbers[j2 + 1],
                numbers[j2 + 2],
                numbers[j2 + 3]
              );
              control.x = numbers[j2 + 0];
              control.y = numbers[j2 + 1];
              point.x = numbers[j2 + 2];
              point.y = numbers[j2 + 3];
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "T":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2 += 2) {
              const rx2 = getReflection(point.x, control.x);
              const ry = getReflection(point.y, control.y);
              path.quadraticCurveTo(
                rx2,
                ry,
                numbers[j2 + 0],
                numbers[j2 + 1]
              );
              control.x = rx2;
              control.y = ry;
              point.x = numbers[j2 + 0];
              point.y = numbers[j2 + 1];
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "A":
            numbers = parseFloats(data2, [3, 4], 7);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2 += 7) {
              if (numbers[j2 + 5] == point.x && numbers[j2 + 6] == point.y)
                continue;
              const start = point.clone();
              point.x = numbers[j2 + 5];
              point.y = numbers[j2 + 6];
              control.x = point.x;
              control.y = point.y;
              parseArcCommand(
                path,
                numbers[j2],
                numbers[j2 + 1],
                numbers[j2 + 2],
                numbers[j2 + 3],
                numbers[j2 + 4],
                start,
                point
              );
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "m":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2 += 2) {
              point.x += numbers[j2 + 0];
              point.y += numbers[j2 + 1];
              control.x = point.x;
              control.y = point.y;
              if (j2 === 0) {
                path.moveTo(point.x, point.y);
              } else {
                path.lineTo(point.x, point.y);
              }
              if (j2 === 0)
                firstPoint.copy(point);
            }
            break;
          case "h":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2++) {
              point.x += numbers[j2];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "v":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2++) {
              point.y += numbers[j2];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "l":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2 += 2) {
              point.x += numbers[j2 + 0];
              point.y += numbers[j2 + 1];
              control.x = point.x;
              control.y = point.y;
              path.lineTo(point.x, point.y);
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "c":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2 += 6) {
              path.bezierCurveTo(
                point.x + numbers[j2 + 0],
                point.y + numbers[j2 + 1],
                point.x + numbers[j2 + 2],
                point.y + numbers[j2 + 3],
                point.x + numbers[j2 + 4],
                point.y + numbers[j2 + 5]
              );
              control.x = point.x + numbers[j2 + 2];
              control.y = point.y + numbers[j2 + 3];
              point.x += numbers[j2 + 4];
              point.y += numbers[j2 + 5];
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "s":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2 += 4) {
              path.bezierCurveTo(
                getReflection(point.x, control.x),
                getReflection(point.y, control.y),
                point.x + numbers[j2 + 0],
                point.y + numbers[j2 + 1],
                point.x + numbers[j2 + 2],
                point.y + numbers[j2 + 3]
              );
              control.x = point.x + numbers[j2 + 0];
              control.y = point.y + numbers[j2 + 1];
              point.x += numbers[j2 + 2];
              point.y += numbers[j2 + 3];
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "q":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2 += 4) {
              path.quadraticCurveTo(
                point.x + numbers[j2 + 0],
                point.y + numbers[j2 + 1],
                point.x + numbers[j2 + 2],
                point.y + numbers[j2 + 3]
              );
              control.x = point.x + numbers[j2 + 0];
              control.y = point.y + numbers[j2 + 1];
              point.x += numbers[j2 + 2];
              point.y += numbers[j2 + 3];
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "t":
            numbers = parseFloats(data2);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2 += 2) {
              const rx2 = getReflection(point.x, control.x);
              const ry = getReflection(point.y, control.y);
              path.quadraticCurveTo(
                rx2,
                ry,
                point.x + numbers[j2 + 0],
                point.y + numbers[j2 + 1]
              );
              control.x = rx2;
              control.y = ry;
              point.x = point.x + numbers[j2 + 0];
              point.y = point.y + numbers[j2 + 1];
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "a":
            numbers = parseFloats(data2, [3, 4], 7);
            for (let j2 = 0, jl = numbers.length; j2 < jl; j2 += 7) {
              if (numbers[j2 + 5] == 0 && numbers[j2 + 6] == 0)
                continue;
              const start = point.clone();
              point.x += numbers[j2 + 5];
              point.y += numbers[j2 + 6];
              control.x = point.x;
              control.y = point.y;
              parseArcCommand(
                path,
                numbers[j2],
                numbers[j2 + 1],
                numbers[j2 + 2],
                numbers[j2 + 3],
                numbers[j2 + 4],
                start,
                point
              );
              if (j2 === 0 && doSetFirstPoint === true)
                firstPoint.copy(point);
            }
            break;
          case "Z":
          case "z":
            path.currentPath.autoClose = true;
            if (path.currentPath.curves.length > 0) {
              point.copy(firstPoint);
              path.currentPath.currentPoint.copy(point);
              isFirstPoint = true;
            }
            break;
          default:
            console.warn(command);
        }
        doSetFirstPoint = false;
      }
      return path;
    }
    function parseCSSStylesheet(node) {
      if (!node.sheet || !node.sheet.cssRules || !node.sheet.cssRules.length)
        return;
      for (let i2 = 0; i2 < node.sheet.cssRules.length; i2++) {
        const stylesheet = node.sheet.cssRules[i2];
        if (stylesheet.type !== 1)
          continue;
        const selectorList = stylesheet.selectorText.split(/,/gm).filter(Boolean).map((i3) => i3.trim());
        for (let j2 = 0; j2 < selectorList.length; j2++) {
          const definitions = Object.fromEntries(
            Object.entries(stylesheet.style).filter(([, v2]) => v2 !== "")
          );
          stylesheets[selectorList[j2]] = Object.assign(
            stylesheets[selectorList[j2]] || {},
            definitions
          );
        }
      }
    }
    function parseArcCommand(path, rx2, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {
      if (rx2 == 0 || ry == 0) {
        path.lineTo(end.x, end.y);
        return;
      }
      x_axis_rotation = x_axis_rotation * Math.PI / 180;
      rx2 = Math.abs(rx2);
      ry = Math.abs(ry);
      const dx2 = (start.x - end.x) / 2;
      const dy2 = (start.y - end.y) / 2;
      const x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;
      const y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2;
      let rxs = rx2 * rx2;
      let rys = ry * ry;
      const x1ps = x1p * x1p;
      const y1ps = y1p * y1p;
      const cr3 = x1ps / rxs + y1ps / rys;
      if (cr3 > 1) {
        const s2 = Math.sqrt(cr3);
        rx2 = s2 * rx2;
        ry = s2 * ry;
        rxs = rx2 * rx2;
        rys = ry * ry;
      }
      const dq = rxs * y1ps + rys * x1ps;
      const pq = (rxs * rys - dq) / dq;
      let q2 = Math.sqrt(Math.max(0, pq));
      if (large_arc_flag === sweep_flag)
        q2 = -q2;
      const cxp = q2 * rx2 * y1p / ry;
      const cyp = -q2 * ry * x1p / rx2;
      const cx2 = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;
      const cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2;
      const theta = svgAngle(1, 0, (x1p - cxp) / rx2, (y1p - cyp) / ry);
      const delta = svgAngle((x1p - cxp) / rx2, (y1p - cyp) / ry, (-x1p - cxp) / rx2, (-y1p - cyp) / ry) % (Math.PI * 2);
      path.currentPath.absellipse(cx2, cy, rx2, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);
    }
    function svgAngle(ux2, uy, vx2, vy) {
      const dot = ux2 * vx2 + uy * vy;
      const len = Math.sqrt(ux2 * ux2 + uy * uy) * Math.sqrt(vx2 * vx2 + vy * vy);
      let ang = Math.acos(Math.max(-1, Math.min(1, dot / len)));
      if (ux2 * vy - uy * vx2 < 0)
        ang = -ang;
      return ang;
    }
    function parseRectNode(node) {
      const x2 = parseFloatWithUnits(node.getAttribute("x") || 0);
      const y3 = parseFloatWithUnits(node.getAttribute("y") || 0);
      const rx2 = parseFloatWithUnits(node.getAttribute("rx") || node.getAttribute("ry") || 0);
      const ry = parseFloatWithUnits(node.getAttribute("ry") || node.getAttribute("rx") || 0);
      const w2 = parseFloatWithUnits(node.getAttribute("width"));
      const h2 = parseFloatWithUnits(node.getAttribute("height"));
      const bci = 1 - 0.551915024494;
      const path = new ShapePath();
      path.moveTo(x2 + rx2, y3);
      path.lineTo(x2 + w2 - rx2, y3);
      if (rx2 !== 0 || ry !== 0) {
        path.bezierCurveTo(
          x2 + w2 - rx2 * bci,
          y3,
          x2 + w2,
          y3 + ry * bci,
          x2 + w2,
          y3 + ry
        );
      }
      path.lineTo(x2 + w2, y3 + h2 - ry);
      if (rx2 !== 0 || ry !== 0) {
        path.bezierCurveTo(
          x2 + w2,
          y3 + h2 - ry * bci,
          x2 + w2 - rx2 * bci,
          y3 + h2,
          x2 + w2 - rx2,
          y3 + h2
        );
      }
      path.lineTo(x2 + rx2, y3 + h2);
      if (rx2 !== 0 || ry !== 0) {
        path.bezierCurveTo(
          x2 + rx2 * bci,
          y3 + h2,
          x2,
          y3 + h2 - ry * bci,
          x2,
          y3 + h2 - ry
        );
      }
      path.lineTo(x2, y3 + ry);
      if (rx2 !== 0 || ry !== 0) {
        path.bezierCurveTo(x2, y3 + ry * bci, x2 + rx2 * bci, y3, x2 + rx2, y3);
      }
      return path;
    }
    function parsePolygonNode(node) {
      function iterator(match, a2, b3) {
        const x2 = parseFloatWithUnits(a2);
        const y3 = parseFloatWithUnits(b3);
        if (index === 0) {
          path.moveTo(x2, y3);
        } else {
          path.lineTo(x2, y3);
        }
        index++;
      }
      const regex = /([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g;
      const path = new ShapePath();
      let index = 0;
      node.getAttribute("points").replace(regex, iterator);
      path.currentPath.autoClose = true;
      return path;
    }
    function parsePolylineNode(node) {
      function iterator(match, a2, b3) {
        const x2 = parseFloatWithUnits(a2);
        const y3 = parseFloatWithUnits(b3);
        if (index === 0) {
          path.moveTo(x2, y3);
        } else {
          path.lineTo(x2, y3);
        }
        index++;
      }
      const regex = /([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g;
      const path = new ShapePath();
      let index = 0;
      node.getAttribute("points").replace(regex, iterator);
      path.currentPath.autoClose = false;
      return path;
    }
    function parseCircleNode(node) {
      const x2 = parseFloatWithUnits(node.getAttribute("cx") || 0);
      const y3 = parseFloatWithUnits(node.getAttribute("cy") || 0);
      const r2 = parseFloatWithUnits(node.getAttribute("r") || 0);
      const subpath = new Path();
      subpath.absarc(x2, y3, r2, 0, Math.PI * 2);
      const path = new ShapePath();
      path.subPaths.push(subpath);
      return path;
    }
    function parseEllipseNode(node) {
      const x2 = parseFloatWithUnits(node.getAttribute("cx") || 0);
      const y3 = parseFloatWithUnits(node.getAttribute("cy") || 0);
      const rx2 = parseFloatWithUnits(node.getAttribute("rx") || 0);
      const ry = parseFloatWithUnits(node.getAttribute("ry") || 0);
      const subpath = new Path();
      subpath.absellipse(x2, y3, rx2, ry, 0, Math.PI * 2);
      const path = new ShapePath();
      path.subPaths.push(subpath);
      return path;
    }
    function parseLineNode(node) {
      const x1 = parseFloatWithUnits(node.getAttribute("x1") || 0);
      const y1 = parseFloatWithUnits(node.getAttribute("y1") || 0);
      const x2 = parseFloatWithUnits(node.getAttribute("x2") || 0);
      const y22 = parseFloatWithUnits(node.getAttribute("y2") || 0);
      const path = new ShapePath();
      path.moveTo(x1, y1);
      path.lineTo(x2, y22);
      path.currentPath.autoClose = false;
      return path;
    }
    function parseStyle(node, style) {
      style = Object.assign({}, style);
      let stylesheetStyles = {};
      if (node.hasAttribute("class")) {
        const classSelectors = node.getAttribute("class").split(/\s/).filter(Boolean).map((i2) => i2.trim());
        for (let i2 = 0; i2 < classSelectors.length; i2++) {
          stylesheetStyles = Object.assign(stylesheetStyles, stylesheets["." + classSelectors[i2]]);
        }
      }
      if (node.hasAttribute("id")) {
        stylesheetStyles = Object.assign(stylesheetStyles, stylesheets["#" + node.getAttribute("id")]);
      }
      function addStyle(svgName, jsName, adjustFunction) {
        if (adjustFunction === void 0)
          adjustFunction = function copy2(v2) {
            if (v2.startsWith("url"))
              console.warn("SVGLoader: url access in attributes is not implemented.");
            return v2;
          };
        if (node.hasAttribute(svgName))
          style[jsName] = adjustFunction(node.getAttribute(svgName));
        if (stylesheetStyles[svgName])
          style[jsName] = adjustFunction(stylesheetStyles[svgName]);
        if (node.style && node.style[svgName] !== "")
          style[jsName] = adjustFunction(node.style[svgName]);
      }
      function clamp2(v2) {
        return Math.max(0, Math.min(1, parseFloatWithUnits(v2)));
      }
      function positive(v2) {
        return Math.max(0, parseFloatWithUnits(v2));
      }
      addStyle("fill", "fill");
      addStyle("fill-opacity", "fillOpacity", clamp2);
      addStyle("fill-rule", "fillRule");
      addStyle("opacity", "opacity", clamp2);
      addStyle("stroke", "stroke");
      addStyle("stroke-opacity", "strokeOpacity", clamp2);
      addStyle("stroke-width", "strokeWidth", positive);
      addStyle("stroke-linejoin", "strokeLineJoin");
      addStyle("stroke-linecap", "strokeLineCap");
      addStyle("stroke-miterlimit", "strokeMiterLimit", positive);
      addStyle("visibility", "visibility");
      return style;
    }
    function getReflection(a2, b3) {
      return a2 - (b3 - a2);
    }
    function parseFloats(input, flags, stride) {
      if (typeof input !== "string") {
        throw new TypeError("Invalid input: " + typeof input);
      }
      const RE = {
        SEPARATOR: /[ \t\r\n\,.\-+]/,
        WHITESPACE: /[ \t\r\n]/,
        DIGIT: /[\d]/,
        SIGN: /[-+]/,
        POINT: /\./,
        COMMA: /,/,
        EXP: /e/i,
        FLAGS: /[01]/
      };
      const SEP = 0;
      const INT = 1;
      const FLOAT = 2;
      const EXP = 3;
      let state = SEP;
      let seenComma = true;
      let number = "", exponent = "";
      const result = [];
      function throwSyntaxError(current2, i2, partial) {
        const error = new SyntaxError('Unexpected character "' + current2 + '" at index ' + i2 + ".");
        error.partial = partial;
        throw error;
      }
      function newNumber() {
        if (number !== "") {
          if (exponent === "")
            result.push(Number(number));
          else
            result.push(Number(number) * Math.pow(10, Number(exponent)));
        }
        number = "";
        exponent = "";
      }
      let current;
      const length = input.length;
      for (let i2 = 0; i2 < length; i2++) {
        current = input[i2];
        if (Array.isArray(flags) && flags.includes(result.length % stride) && RE.FLAGS.test(current)) {
          state = INT;
          number = current;
          newNumber();
          continue;
        }
        if (state === SEP) {
          if (RE.WHITESPACE.test(current)) {
            continue;
          }
          if (RE.DIGIT.test(current) || RE.SIGN.test(current)) {
            state = INT;
            number = current;
            continue;
          }
          if (RE.POINT.test(current)) {
            state = FLOAT;
            number = current;
            continue;
          }
          if (RE.COMMA.test(current)) {
            if (seenComma) {
              throwSyntaxError(current, i2, result);
            }
            seenComma = true;
          }
        }
        if (state === INT) {
          if (RE.DIGIT.test(current)) {
            number += current;
            continue;
          }
          if (RE.POINT.test(current)) {
            number += current;
            state = FLOAT;
            continue;
          }
          if (RE.EXP.test(current)) {
            state = EXP;
            continue;
          }
          if (RE.SIGN.test(current) && number.length === 1 && RE.SIGN.test(number[0])) {
            throwSyntaxError(current, i2, result);
          }
        }
        if (state === FLOAT) {
          if (RE.DIGIT.test(current)) {
            number += current;
            continue;
          }
          if (RE.EXP.test(current)) {
            state = EXP;
            continue;
          }
          if (RE.POINT.test(current) && number[number.length - 1] === ".") {
            throwSyntaxError(current, i2, result);
          }
        }
        if (state === EXP) {
          if (RE.DIGIT.test(current)) {
            exponent += current;
            continue;
          }
          if (RE.SIGN.test(current)) {
            if (exponent === "") {
              exponent += current;
              continue;
            }
            if (exponent.length === 1 && RE.SIGN.test(exponent)) {
              throwSyntaxError(current, i2, result);
            }
          }
        }
        if (RE.WHITESPACE.test(current)) {
          newNumber();
          state = SEP;
          seenComma = false;
        } else if (RE.COMMA.test(current)) {
          newNumber();
          state = SEP;
          seenComma = true;
        } else if (RE.SIGN.test(current)) {
          newNumber();
          state = INT;
          number = current;
        } else if (RE.POINT.test(current)) {
          newNumber();
          state = FLOAT;
          number = current;
        } else {
          throwSyntaxError(current, i2, result);
        }
      }
      newNumber();
      return result;
    }
    const units = ["mm", "cm", "in", "pt", "pc", "px"];
    const unitConversion = {
      "mm": {
        "mm": 1,
        "cm": 0.1,
        "in": 1 / 25.4,
        "pt": 72 / 25.4,
        "pc": 6 / 25.4,
        "px": -1
      },
      "cm": {
        "mm": 10,
        "cm": 1,
        "in": 1 / 2.54,
        "pt": 72 / 2.54,
        "pc": 6 / 2.54,
        "px": -1
      },
      "in": {
        "mm": 25.4,
        "cm": 2.54,
        "in": 1,
        "pt": 72,
        "pc": 6,
        "px": -1
      },
      "pt": {
        "mm": 25.4 / 72,
        "cm": 2.54 / 72,
        "in": 1 / 72,
        "pt": 1,
        "pc": 6 / 72,
        "px": -1
      },
      "pc": {
        "mm": 25.4 / 6,
        "cm": 2.54 / 6,
        "in": 1 / 6,
        "pt": 72 / 6,
        "pc": 1,
        "px": -1
      },
      "px": {
        "px": 1
      }
    };
    function parseFloatWithUnits(string) {
      let theUnit = "px";
      if (typeof string === "string" || string instanceof String) {
        for (let i2 = 0, n2 = units.length; i2 < n2; i2++) {
          const u2 = units[i2];
          if (string.endsWith(u2)) {
            theUnit = u2;
            string = string.substring(0, string.length - u2.length);
            break;
          }
        }
      }
      let scale = void 0;
      if (theUnit === "px" && scope.defaultUnit !== "px") {
        scale = unitConversion["in"][scope.defaultUnit] / scope.defaultDPI;
      } else {
        scale = unitConversion[theUnit][scope.defaultUnit];
        if (scale < 0) {
          scale = unitConversion[theUnit]["in"] * scope.defaultDPI;
        }
      }
      return scale * parseFloat(string);
    }
    function getNodeTransform(node) {
      if (!(node.hasAttribute("transform") || node.nodeName === "use" && (node.hasAttribute("x") || node.hasAttribute("y")))) {
        return null;
      }
      const transform = parseNodeTransform(node);
      if (transformStack.length > 0) {
        transform.premultiply(transformStack[transformStack.length - 1]);
      }
      currentTransform.copy(transform);
      transformStack.push(transform);
      return transform;
    }
    function parseNodeTransform(node) {
      const transform = new Matrix3();
      const currentTransform2 = tempTransform0;
      if (node.nodeName === "use" && (node.hasAttribute("x") || node.hasAttribute("y"))) {
        const tx2 = parseFloatWithUnits(node.getAttribute("x"));
        const ty = parseFloatWithUnits(node.getAttribute("y"));
        transform.translate(tx2, ty);
      }
      if (node.hasAttribute("transform")) {
        const transformsTexts = node.getAttribute("transform").split(")");
        for (let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex--) {
          const transformText = transformsTexts[tIndex].trim();
          if (transformText === "")
            continue;
          const openParPos = transformText.indexOf("(");
          const closeParPos = transformText.length;
          if (openParPos > 0 && openParPos < closeParPos) {
            const transformType = transformText.slice(0, openParPos);
            const array = parseFloats(transformText.slice(openParPos + 1));
            currentTransform2.identity();
            switch (transformType) {
              case "translate":
                if (array.length >= 1) {
                  const tx2 = array[0];
                  let ty = 0;
                  if (array.length >= 2) {
                    ty = array[1];
                  }
                  currentTransform2.translate(tx2, ty);
                }
                break;
              case "rotate":
                if (array.length >= 1) {
                  let angle = 0;
                  let cx2 = 0;
                  let cy = 0;
                  angle = array[0] * Math.PI / 180;
                  if (array.length >= 3) {
                    cx2 = array[1];
                    cy = array[2];
                  }
                  tempTransform1.makeTranslation(-cx2, -cy);
                  tempTransform2.makeRotation(angle);
                  tempTransform3.multiplyMatrices(tempTransform2, tempTransform1);
                  tempTransform1.makeTranslation(cx2, cy);
                  currentTransform2.multiplyMatrices(tempTransform1, tempTransform3);
                }
                break;
              case "scale":
                if (array.length >= 1) {
                  const scaleX = array[0];
                  let scaleY = scaleX;
                  if (array.length >= 2) {
                    scaleY = array[1];
                  }
                  currentTransform2.scale(scaleX, scaleY);
                }
                break;
              case "skewX":
                if (array.length === 1) {
                  currentTransform2.set(
                    1,
                    Math.tan(array[0] * Math.PI / 180),
                    0,
                    0,
                    1,
                    0,
                    0,
                    0,
                    1
                  );
                }
                break;
              case "skewY":
                if (array.length === 1) {
                  currentTransform2.set(
                    1,
                    0,
                    0,
                    Math.tan(array[0] * Math.PI / 180),
                    1,
                    0,
                    0,
                    0,
                    1
                  );
                }
                break;
              case "matrix":
                if (array.length === 6) {
                  currentTransform2.set(
                    array[0],
                    array[2],
                    array[4],
                    array[1],
                    array[3],
                    array[5],
                    0,
                    0,
                    1
                  );
                }
                break;
            }
          }
          transform.premultiply(currentTransform2);
        }
      }
      return transform;
    }
    function transformPath(path, m) {
      function transfVec2(v2) {
        tempV3.set(v2.x, v2.y, 1).applyMatrix3(m);
        v2.set(tempV3.x, tempV3.y);
      }
      function transfEllipseGeneric(curve) {
        const a2 = curve.xRadius;
        const b3 = curve.yRadius;
        const cosTheta = Math.cos(curve.aRotation);
        const sinTheta = Math.sin(curve.aRotation);
        const v1 = new Vector3(a2 * cosTheta, a2 * sinTheta, 0);
        const v2 = new Vector3(-b3 * sinTheta, b3 * cosTheta, 0);
        const f1 = v1.applyMatrix3(m);
        const f2 = v2.applyMatrix3(m);
        const mF = tempTransform0.set(
          f1.x,
          f2.x,
          0,
          f1.y,
          f2.y,
          0,
          0,
          0,
          1
        );
        const mFInv = tempTransform1.copy(mF).invert();
        const mFInvT = tempTransform2.copy(mFInv).transpose();
        const mQ = mFInvT.multiply(mFInv);
        const mQe = mQ.elements;
        const ed = eigenDecomposition(mQe[0], mQe[1], mQe[4]);
        const rt1sqrt = Math.sqrt(ed.rt1);
        const rt2sqrt = Math.sqrt(ed.rt2);
        curve.xRadius = 1 / rt1sqrt;
        curve.yRadius = 1 / rt2sqrt;
        curve.aRotation = Math.atan2(ed.sn, ed.cs);
        const isFullEllipse = (curve.aEndAngle - curve.aStartAngle) % (2 * Math.PI) < Number.EPSILON;
        if (!isFullEllipse) {
          const mDsqrt = tempTransform1.set(
            rt1sqrt,
            0,
            0,
            0,
            rt2sqrt,
            0,
            0,
            0,
            1
          );
          const mRT = tempTransform2.set(
            ed.cs,
            ed.sn,
            0,
            -ed.sn,
            ed.cs,
            0,
            0,
            0,
            1
          );
          const mDRF = mDsqrt.multiply(mRT).multiply(mF);
          const transformAngle = (phi) => {
            const { x: cosR, y: sinR } = new Vector3(Math.cos(phi), Math.sin(phi), 0).applyMatrix3(mDRF);
            return Math.atan2(sinR, cosR);
          };
          curve.aStartAngle = transformAngle(curve.aStartAngle);
          curve.aEndAngle = transformAngle(curve.aEndAngle);
          if (isTransformFlipped(m)) {
            curve.aClockwise = !curve.aClockwise;
          }
        }
      }
      function transfEllipseNoSkew(curve) {
        const sx2 = getTransformScaleX(m);
        const sy = getTransformScaleY(m);
        curve.xRadius *= sx2;
        curve.yRadius *= sy;
        const theta = sx2 > Number.EPSILON ? Math.atan2(m.elements[1], m.elements[0]) : Math.atan2(-m.elements[3], m.elements[4]);
        curve.aRotation += theta;
        if (isTransformFlipped(m)) {
          curve.aStartAngle *= -1;
          curve.aEndAngle *= -1;
          curve.aClockwise = !curve.aClockwise;
        }
      }
      const subPaths = path.subPaths;
      for (let i2 = 0, n2 = subPaths.length; i2 < n2; i2++) {
        const subPath = subPaths[i2];
        const curves = subPath.curves;
        for (let j2 = 0; j2 < curves.length; j2++) {
          const curve = curves[j2];
          if (curve.isLineCurve) {
            transfVec2(curve.v1);
            transfVec2(curve.v2);
          } else if (curve.isCubicBezierCurve) {
            transfVec2(curve.v0);
            transfVec2(curve.v1);
            transfVec2(curve.v2);
            transfVec2(curve.v3);
          } else if (curve.isQuadraticBezierCurve) {
            transfVec2(curve.v0);
            transfVec2(curve.v1);
            transfVec2(curve.v2);
          } else if (curve.isEllipseCurve) {
            tempV2.set(curve.aX, curve.aY);
            transfVec2(tempV2);
            curve.aX = tempV2.x;
            curve.aY = tempV2.y;
            if (isTransformSkewed(m)) {
              transfEllipseGeneric(curve);
            } else {
              transfEllipseNoSkew(curve);
            }
          }
        }
      }
    }
    function isTransformFlipped(m) {
      const te2 = m.elements;
      return te2[0] * te2[4] - te2[1] * te2[3] < 0;
    }
    function isTransformSkewed(m) {
      const te2 = m.elements;
      const basisDot = te2[0] * te2[3] + te2[1] * te2[4];
      if (basisDot === 0)
        return false;
      const sx2 = getTransformScaleX(m);
      const sy = getTransformScaleY(m);
      return Math.abs(basisDot / (sx2 * sy)) > Number.EPSILON;
    }
    function getTransformScaleX(m) {
      const te2 = m.elements;
      return Math.sqrt(te2[0] * te2[0] + te2[1] * te2[1]);
    }
    function getTransformScaleY(m) {
      const te2 = m.elements;
      return Math.sqrt(te2[3] * te2[3] + te2[4] * te2[4]);
    }
    function eigenDecomposition(A, B2, C) {
      let rt1, rt22, cs, sn2, t2;
      const sm = A + C;
      const df2 = A - C;
      const rt3 = Math.sqrt(df2 * df2 + 4 * B2 * B2);
      if (sm > 0) {
        rt1 = 0.5 * (sm + rt3);
        t2 = 1 / rt1;
        rt22 = A * t2 * C - B2 * t2 * B2;
      } else if (sm < 0) {
        rt22 = 0.5 * (sm - rt3);
      } else {
        rt1 = 0.5 * rt3;
        rt22 = -0.5 * rt3;
      }
      if (df2 > 0) {
        cs = df2 + rt3;
      } else {
        cs = df2 - rt3;
      }
      if (Math.abs(cs) > 2 * Math.abs(B2)) {
        t2 = -2 * B2 / cs;
        sn2 = 1 / Math.sqrt(1 + t2 * t2);
        cs = t2 * sn2;
      } else if (Math.abs(B2) === 0) {
        cs = 1;
        sn2 = 0;
      } else {
        t2 = -0.5 * cs / B2;
        cs = 1 / Math.sqrt(1 + t2 * t2);
        sn2 = t2 * cs;
      }
      if (df2 > 0) {
        t2 = cs;
        cs = -sn2;
        sn2 = t2;
      }
      return { rt1, rt2: rt22, cs, sn: sn2 };
    }
    const paths = [];
    const stylesheets = {};
    const transformStack = [];
    const tempTransform0 = new Matrix3();
    const tempTransform1 = new Matrix3();
    const tempTransform2 = new Matrix3();
    const tempTransform3 = new Matrix3();
    const tempV2 = new Vector2();
    const tempV3 = new Vector3();
    const currentTransform = new Matrix3();
    const xml = new DOMParser().parseFromString(text, "image/svg+xml");
    parseNode(xml.documentElement, {
      fill: "#000",
      fillOpacity: 1,
      strokeOpacity: 1,
      strokeWidth: 1,
      strokeLineJoin: "miter",
      strokeLineCap: "butt",
      strokeMiterLimit: 4
    });
    const data = { paths, xml: xml.documentElement };
    return data;
  }
  static createShapes(shapePath) {
    const BIGNUMBER = 999999999;
    const IntersectionLocationType = {
      ORIGIN: 0,
      DESTINATION: 1,
      BETWEEN: 2,
      LEFT: 3,
      RIGHT: 4,
      BEHIND: 5,
      BEYOND: 6
    };
    const classifyResult = {
      loc: IntersectionLocationType.ORIGIN,
      t: 0
    };
    function findEdgeIntersection(a0, a1, b0, b1) {
      const x1 = a0.x;
      const x2 = a1.x;
      const x3 = b0.x;
      const x4 = b1.x;
      const y1 = a0.y;
      const y22 = a1.y;
      const y3 = b0.y;
      const y4 = b1.y;
      const nom1 = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
      const nom2 = (x2 - x1) * (y1 - y3) - (y22 - y1) * (x1 - x3);
      const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y22 - y1);
      const t1 = nom1 / denom;
      const t2 = nom2 / denom;
      if (denom === 0 && nom1 !== 0 || t1 <= 0 || t1 >= 1 || t2 < 0 || t2 > 1) {
        return null;
      } else if (nom1 === 0 && denom === 0) {
        for (let i2 = 0; i2 < 2; i2++) {
          classifyPoint(i2 === 0 ? b0 : b1, a0, a1);
          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {
            const point = i2 === 0 ? b0 : b1;
            return { x: point.x, y: point.y, t: classifyResult.t };
          } else if (classifyResult.loc == IntersectionLocationType.BETWEEN) {
            const x5 = +(x1 + classifyResult.t * (x2 - x1)).toPrecision(10);
            const y5 = +(y1 + classifyResult.t * (y22 - y1)).toPrecision(10);
            return { x: x5, y: y5, t: classifyResult.t };
          }
        }
        return null;
      } else {
        for (let i2 = 0; i2 < 2; i2++) {
          classifyPoint(i2 === 0 ? b0 : b1, a0, a1);
          if (classifyResult.loc == IntersectionLocationType.ORIGIN) {
            const point = i2 === 0 ? b0 : b1;
            return { x: point.x, y: point.y, t: classifyResult.t };
          }
        }
        const x5 = +(x1 + t1 * (x2 - x1)).toPrecision(10);
        const y5 = +(y1 + t1 * (y22 - y1)).toPrecision(10);
        return { x: x5, y: y5, t: t1 };
      }
    }
    function classifyPoint(p2, edgeStart, edgeEnd) {
      const ax2 = edgeEnd.x - edgeStart.x;
      const ay = edgeEnd.y - edgeStart.y;
      const bx2 = p2.x - edgeStart.x;
      const by = p2.y - edgeStart.y;
      const sa2 = ax2 * by - bx2 * ay;
      if (p2.x === edgeStart.x && p2.y === edgeStart.y) {
        classifyResult.loc = IntersectionLocationType.ORIGIN;
        classifyResult.t = 0;
        return;
      }
      if (p2.x === edgeEnd.x && p2.y === edgeEnd.y) {
        classifyResult.loc = IntersectionLocationType.DESTINATION;
        classifyResult.t = 1;
        return;
      }
      if (sa2 < -Number.EPSILON) {
        classifyResult.loc = IntersectionLocationType.LEFT;
        return;
      }
      if (sa2 > Number.EPSILON) {
        classifyResult.loc = IntersectionLocationType.RIGHT;
        return;
      }
      if (ax2 * bx2 < 0 || ay * by < 0) {
        classifyResult.loc = IntersectionLocationType.BEHIND;
        return;
      }
      if (Math.sqrt(ax2 * ax2 + ay * ay) < Math.sqrt(bx2 * bx2 + by * by)) {
        classifyResult.loc = IntersectionLocationType.BEYOND;
        return;
      }
      let t2;
      if (ax2 !== 0) {
        t2 = bx2 / ax2;
      } else {
        t2 = by / ay;
      }
      classifyResult.loc = IntersectionLocationType.BETWEEN;
      classifyResult.t = t2;
    }
    function getIntersections(path1, path2) {
      const intersectionsRaw = [];
      const intersections = [];
      for (let index = 1; index < path1.length; index++) {
        const path1EdgeStart = path1[index - 1];
        const path1EdgeEnd = path1[index];
        for (let index2 = 1; index2 < path2.length; index2++) {
          const path2EdgeStart = path2[index2 - 1];
          const path2EdgeEnd = path2[index2];
          const intersection = findEdgeIntersection(path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd);
          if (intersection !== null && intersectionsRaw.find((i2) => i2.t <= intersection.t + Number.EPSILON && i2.t >= intersection.t - Number.EPSILON) === void 0) {
            intersectionsRaw.push(intersection);
            intersections.push(new Vector2(intersection.x, intersection.y));
          }
        }
      }
      return intersections;
    }
    function getScanlineIntersections(scanline, boundingBox, paths) {
      const center = new Vector2();
      boundingBox.getCenter(center);
      const allIntersections = [];
      paths.forEach((path) => {
        if (path.boundingBox.containsPoint(center)) {
          const intersections = getIntersections(scanline, path.points);
          intersections.forEach((p2) => {
            allIntersections.push({ identifier: path.identifier, isCW: path.isCW, point: p2 });
          });
        }
      });
      allIntersections.sort((i1, i2) => {
        return i1.point.x - i2.point.x;
      });
      return allIntersections;
    }
    function isHoleTo(simplePath, allPaths, scanlineMinX2, scanlineMaxX2, _fillRule) {
      if (_fillRule === null || _fillRule === void 0 || _fillRule === "") {
        _fillRule = "nonzero";
      }
      const centerBoundingBox = new Vector2();
      simplePath.boundingBox.getCenter(centerBoundingBox);
      const scanline = [new Vector2(scanlineMinX2, centerBoundingBox.y), new Vector2(scanlineMaxX2, centerBoundingBox.y)];
      const scanlineIntersections = getScanlineIntersections(scanline, simplePath.boundingBox, allPaths);
      scanlineIntersections.sort((i1, i22) => {
        return i1.point.x - i22.point.x;
      });
      const baseIntersections = [];
      const otherIntersections = [];
      scanlineIntersections.forEach((i3) => {
        if (i3.identifier === simplePath.identifier) {
          baseIntersections.push(i3);
        } else {
          otherIntersections.push(i3);
        }
      });
      const firstXOfPath = baseIntersections[0].point.x;
      const stack = [];
      let i2 = 0;
      while (i2 < otherIntersections.length && otherIntersections[i2].point.x < firstXOfPath) {
        if (stack.length > 0 && stack[stack.length - 1] === otherIntersections[i2].identifier) {
          stack.pop();
        } else {
          stack.push(otherIntersections[i2].identifier);
        }
        i2++;
      }
      stack.push(simplePath.identifier);
      if (_fillRule === "evenodd") {
        const isHole = stack.length % 2 === 0 ? true : false;
        const isHoleFor = stack[stack.length - 2];
        return { identifier: simplePath.identifier, isHole, for: isHoleFor };
      } else if (_fillRule === "nonzero") {
        let isHole = true;
        let isHoleFor = null;
        let lastCWValue = null;
        for (let i3 = 0; i3 < stack.length; i3++) {
          const identifier = stack[i3];
          if (isHole) {
            lastCWValue = allPaths[identifier].isCW;
            isHole = false;
            isHoleFor = identifier;
          } else if (lastCWValue !== allPaths[identifier].isCW) {
            lastCWValue = allPaths[identifier].isCW;
            isHole = true;
          }
        }
        return { identifier: simplePath.identifier, isHole, for: isHoleFor };
      } else {
        console.warn('fill-rule: "' + _fillRule + '" is currently not implemented.');
      }
    }
    let scanlineMinX = BIGNUMBER;
    let scanlineMaxX = -BIGNUMBER;
    let simplePaths = shapePath.subPaths.map((p2) => {
      const points = p2.getPoints();
      let maxY = -BIGNUMBER;
      let minY = BIGNUMBER;
      let maxX = -BIGNUMBER;
      let minX = BIGNUMBER;
      for (let i2 = 0; i2 < points.length; i2++) {
        const p3 = points[i2];
        if (p3.y > maxY) {
          maxY = p3.y;
        }
        if (p3.y < minY) {
          minY = p3.y;
        }
        if (p3.x > maxX) {
          maxX = p3.x;
        }
        if (p3.x < minX) {
          minX = p3.x;
        }
      }
      if (scanlineMaxX <= maxX) {
        scanlineMaxX = maxX + 1;
      }
      if (scanlineMinX >= minX) {
        scanlineMinX = minX - 1;
      }
      return { curves: p2.curves, points, isCW: ShapeUtils.isClockWise(points), identifier: -1, boundingBox: new Box2(new Vector2(minX, minY), new Vector2(maxX, maxY)) };
    });
    simplePaths = simplePaths.filter((sp) => sp.points.length > 1);
    for (let identifier = 0; identifier < simplePaths.length; identifier++) {
      simplePaths[identifier].identifier = identifier;
    }
    const isAHole = simplePaths.map((p2) => isHoleTo(p2, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData ? shapePath.userData.style.fillRule : void 0));
    const shapesToReturn = [];
    simplePaths.forEach((p2) => {
      const amIAHole = isAHole[p2.identifier];
      if (!amIAHole.isHole) {
        const shape = new Shape();
        shape.curves = p2.curves;
        const holes = isAHole.filter((h2) => h2.isHole && h2.for === p2.identifier);
        holes.forEach((h2) => {
          const hole = simplePaths[h2.identifier];
          const path = new Path();
          path.curves = hole.curves;
          shape.holes.push(path);
        });
        shapesToReturn.push(shape);
      }
    });
    return shapesToReturn;
  }
  static getStrokeStyle(width, color, lineJoin, lineCap, miterLimit) {
    width = width !== void 0 ? width : 1;
    color = color !== void 0 ? color : "#000";
    lineJoin = lineJoin !== void 0 ? lineJoin : "miter";
    lineCap = lineCap !== void 0 ? lineCap : "butt";
    miterLimit = miterLimit !== void 0 ? miterLimit : 4;
    return {
      strokeColor: color,
      strokeWidth: width,
      strokeLineJoin: lineJoin,
      strokeLineCap: lineCap,
      strokeMiterLimit: miterLimit
    };
  }
  static pointsToStroke(points, style, arcDivisions, minDistance) {
    const vertices = [];
    const normals = [];
    const uvs = [];
    if (_SVGLoader.pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs) === 0) {
      return null;
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    geometry.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    return geometry;
  }
  static pointsToStrokeWithBuffers(points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset) {
    const tempV2_1 = new Vector2();
    const tempV2_2 = new Vector2();
    const tempV2_3 = new Vector2();
    const tempV2_4 = new Vector2();
    const tempV2_5 = new Vector2();
    const tempV2_6 = new Vector2();
    const tempV2_7 = new Vector2();
    const lastPointL = new Vector2();
    const lastPointR = new Vector2();
    const point0L = new Vector2();
    const point0R = new Vector2();
    const currentPointL = new Vector2();
    const currentPointR = new Vector2();
    const nextPointL = new Vector2();
    const nextPointR = new Vector2();
    const innerPoint = new Vector2();
    const outerPoint = new Vector2();
    arcDivisions = arcDivisions !== void 0 ? arcDivisions : 12;
    minDistance = minDistance !== void 0 ? minDistance : 1e-3;
    vertexOffset = vertexOffset !== void 0 ? vertexOffset : 0;
    points = removeDuplicatedPoints(points);
    const numPoints = points.length;
    if (numPoints < 2)
      return 0;
    const isClosed = points[0].equals(points[numPoints - 1]);
    let currentPoint;
    let previousPoint = points[0];
    let nextPoint;
    const strokeWidth2 = style.strokeWidth / 2;
    const deltaU = 1 / (numPoints - 1);
    let u0 = 0, u1;
    let innerSideModified;
    let joinIsOnLeftSide;
    let isMiter;
    let initialJoinIsOnLeftSide = false;
    let numVertices = 0;
    let currentCoordinate = vertexOffset * 3;
    let currentCoordinateUV = vertexOffset * 2;
    getNormal(points[0], points[1], tempV2_1).multiplyScalar(strokeWidth2);
    lastPointL.copy(points[0]).sub(tempV2_1);
    lastPointR.copy(points[0]).add(tempV2_1);
    point0L.copy(lastPointL);
    point0R.copy(lastPointR);
    for (let iPoint = 1; iPoint < numPoints; iPoint++) {
      currentPoint = points[iPoint];
      if (iPoint === numPoints - 1) {
        if (isClosed) {
          nextPoint = points[1];
        } else
          nextPoint = void 0;
      } else {
        nextPoint = points[iPoint + 1];
      }
      const normal1 = tempV2_1;
      getNormal(previousPoint, currentPoint, normal1);
      tempV2_3.copy(normal1).multiplyScalar(strokeWidth2);
      currentPointL.copy(currentPoint).sub(tempV2_3);
      currentPointR.copy(currentPoint).add(tempV2_3);
      u1 = u0 + deltaU;
      innerSideModified = false;
      if (nextPoint !== void 0) {
        getNormal(currentPoint, nextPoint, tempV2_2);
        tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2);
        nextPointL.copy(currentPoint).sub(tempV2_3);
        nextPointR.copy(currentPoint).add(tempV2_3);
        joinIsOnLeftSide = true;
        tempV2_3.subVectors(nextPoint, previousPoint);
        if (normal1.dot(tempV2_3) < 0) {
          joinIsOnLeftSide = false;
        }
        if (iPoint === 1)
          initialJoinIsOnLeftSide = joinIsOnLeftSide;
        tempV2_3.subVectors(nextPoint, currentPoint);
        tempV2_3.normalize();
        const dot = Math.abs(normal1.dot(tempV2_3));
        if (dot > Number.EPSILON) {
          const miterSide = strokeWidth2 / dot;
          tempV2_3.multiplyScalar(-miterSide);
          tempV2_4.subVectors(currentPoint, previousPoint);
          tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3);
          innerPoint.copy(tempV2_5).negate();
          const miterLength2 = tempV2_5.length();
          const segmentLengthPrev = tempV2_4.length();
          tempV2_4.divideScalar(segmentLengthPrev);
          tempV2_6.subVectors(nextPoint, currentPoint);
          const segmentLengthNext = tempV2_6.length();
          tempV2_6.divideScalar(segmentLengthNext);
          if (tempV2_4.dot(innerPoint) < segmentLengthPrev && tempV2_6.dot(innerPoint) < segmentLengthNext) {
            innerSideModified = true;
          }
          outerPoint.copy(tempV2_5).add(currentPoint);
          innerPoint.add(currentPoint);
          isMiter = false;
          if (innerSideModified) {
            if (joinIsOnLeftSide) {
              nextPointR.copy(innerPoint);
              currentPointR.copy(innerPoint);
            } else {
              nextPointL.copy(innerPoint);
              currentPointL.copy(innerPoint);
            }
          } else {
            makeSegmentTriangles();
          }
          switch (style.strokeLineJoin) {
            case "bevel":
              makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);
              break;
            case "round":
              createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);
              if (joinIsOnLeftSide) {
                makeCircularSector(currentPoint, currentPointL, nextPointL, u1, 0);
              } else {
                makeCircularSector(currentPoint, nextPointR, currentPointR, u1, 1);
              }
              break;
            case "miter":
            case "miter-clip":
            default:
              const miterFraction = strokeWidth2 * style.strokeMiterLimit / miterLength2;
              if (miterFraction < 1) {
                if (style.strokeLineJoin !== "miter-clip") {
                  makeSegmentWithBevelJoin(joinIsOnLeftSide, innerSideModified, u1);
                  break;
                } else {
                  createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide, innerSideModified);
                  if (joinIsOnLeftSide) {
                    tempV2_6.subVectors(outerPoint, currentPointL).multiplyScalar(miterFraction).add(currentPointL);
                    tempV2_7.subVectors(outerPoint, nextPointL).multiplyScalar(miterFraction).add(nextPointL);
                    addVertex(currentPointL, u1, 0);
                    addVertex(tempV2_6, u1, 0);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(tempV2_6, u1, 0);
                    addVertex(tempV2_7, u1, 0);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(tempV2_7, u1, 0);
                    addVertex(nextPointL, u1, 0);
                  } else {
                    tempV2_6.subVectors(outerPoint, currentPointR).multiplyScalar(miterFraction).add(currentPointR);
                    tempV2_7.subVectors(outerPoint, nextPointR).multiplyScalar(miterFraction).add(nextPointR);
                    addVertex(currentPointR, u1, 1);
                    addVertex(tempV2_6, u1, 1);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(tempV2_6, u1, 1);
                    addVertex(tempV2_7, u1, 1);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(tempV2_7, u1, 1);
                    addVertex(nextPointR, u1, 1);
                  }
                }
              } else {
                if (innerSideModified) {
                  if (joinIsOnLeftSide) {
                    addVertex(lastPointR, u0, 1);
                    addVertex(lastPointL, u0, 0);
                    addVertex(outerPoint, u1, 0);
                    addVertex(lastPointR, u0, 1);
                    addVertex(outerPoint, u1, 0);
                    addVertex(innerPoint, u1, 1);
                  } else {
                    addVertex(lastPointR, u0, 1);
                    addVertex(lastPointL, u0, 0);
                    addVertex(outerPoint, u1, 1);
                    addVertex(lastPointL, u0, 0);
                    addVertex(innerPoint, u1, 0);
                    addVertex(outerPoint, u1, 1);
                  }
                  if (joinIsOnLeftSide) {
                    nextPointL.copy(outerPoint);
                  } else {
                    nextPointR.copy(outerPoint);
                  }
                } else {
                  if (joinIsOnLeftSide) {
                    addVertex(currentPointL, u1, 0);
                    addVertex(outerPoint, u1, 0);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(outerPoint, u1, 0);
                    addVertex(nextPointL, u1, 0);
                  } else {
                    addVertex(currentPointR, u1, 1);
                    addVertex(outerPoint, u1, 1);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(currentPoint, u1, 0.5);
                    addVertex(outerPoint, u1, 1);
                    addVertex(nextPointR, u1, 1);
                  }
                }
                isMiter = true;
              }
              break;
          }
        } else {
          makeSegmentTriangles();
        }
      } else {
        makeSegmentTriangles();
      }
      if (!isClosed && iPoint === numPoints - 1) {
        addCapGeometry(points[0], point0L, point0R, joinIsOnLeftSide, true, u0);
      }
      u0 = u1;
      previousPoint = currentPoint;
      lastPointL.copy(nextPointL);
      lastPointR.copy(nextPointR);
    }
    if (!isClosed) {
      addCapGeometry(currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1);
    } else if (innerSideModified && vertices) {
      let lastOuter = outerPoint;
      let lastInner = innerPoint;
      if (initialJoinIsOnLeftSide !== joinIsOnLeftSide) {
        lastOuter = innerPoint;
        lastInner = outerPoint;
      }
      if (joinIsOnLeftSide) {
        if (isMiter || initialJoinIsOnLeftSide) {
          lastInner.toArray(vertices, 0 * 3);
          lastInner.toArray(vertices, 3 * 3);
          if (isMiter) {
            lastOuter.toArray(vertices, 1 * 3);
          }
        }
      } else {
        if (isMiter || !initialJoinIsOnLeftSide) {
          lastInner.toArray(vertices, 1 * 3);
          lastInner.toArray(vertices, 3 * 3);
          if (isMiter) {
            lastOuter.toArray(vertices, 0 * 3);
          }
        }
      }
    }
    return numVertices;
    function getNormal(p1, p2, result) {
      result.subVectors(p2, p1);
      return result.set(-result.y, result.x).normalize();
    }
    function addVertex(position, u2, v2) {
      if (vertices) {
        vertices[currentCoordinate] = position.x;
        vertices[currentCoordinate + 1] = position.y;
        vertices[currentCoordinate + 2] = 0;
        if (normals) {
          normals[currentCoordinate] = 0;
          normals[currentCoordinate + 1] = 0;
          normals[currentCoordinate + 2] = 1;
        }
        currentCoordinate += 3;
        if (uvs) {
          uvs[currentCoordinateUV] = u2;
          uvs[currentCoordinateUV + 1] = v2;
          currentCoordinateUV += 2;
        }
      }
      numVertices += 3;
    }
    function makeCircularSector(center, p1, p2, u2, v2) {
      tempV2_1.copy(p1).sub(center).normalize();
      tempV2_2.copy(p2).sub(center).normalize();
      let angle = Math.PI;
      const dot = tempV2_1.dot(tempV2_2);
      if (Math.abs(dot) < 1)
        angle = Math.abs(Math.acos(dot));
      angle /= arcDivisions;
      tempV2_3.copy(p1);
      for (let i2 = 0, il = arcDivisions - 1; i2 < il; i2++) {
        tempV2_4.copy(tempV2_3).rotateAround(center, angle);
        addVertex(tempV2_3, u2, v2);
        addVertex(tempV2_4, u2, v2);
        addVertex(center, u2, 0.5);
        tempV2_3.copy(tempV2_4);
      }
      addVertex(tempV2_4, u2, v2);
      addVertex(p2, u2, v2);
      addVertex(center, u2, 0.5);
    }
    function makeSegmentTriangles() {
      addVertex(lastPointR, u0, 1);
      addVertex(lastPointL, u0, 0);
      addVertex(currentPointL, u1, 0);
      addVertex(lastPointR, u0, 1);
      addVertex(currentPointL, u1, 0);
      addVertex(currentPointR, u1, 1);
    }
    function makeSegmentWithBevelJoin(joinIsOnLeftSide2, innerSideModified2, u2) {
      if (innerSideModified2) {
        if (joinIsOnLeftSide2) {
          addVertex(lastPointR, u0, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(currentPointL, u1, 0);
          addVertex(lastPointR, u0, 1);
          addVertex(currentPointL, u1, 0);
          addVertex(innerPoint, u1, 1);
          addVertex(currentPointL, u2, 0);
          addVertex(nextPointL, u2, 0);
          addVertex(innerPoint, u2, 0.5);
        } else {
          addVertex(lastPointR, u0, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(currentPointR, u1, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(innerPoint, u1, 0);
          addVertex(currentPointR, u1, 1);
          addVertex(currentPointR, u2, 1);
          addVertex(innerPoint, u2, 0);
          addVertex(nextPointR, u2, 1);
        }
      } else {
        if (joinIsOnLeftSide2) {
          addVertex(currentPointL, u2, 0);
          addVertex(nextPointL, u2, 0);
          addVertex(currentPoint, u2, 0.5);
        } else {
          addVertex(currentPointR, u2, 1);
          addVertex(nextPointR, u2, 0);
          addVertex(currentPoint, u2, 0.5);
        }
      }
    }
    function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide2, innerSideModified2) {
      if (innerSideModified2) {
        if (joinIsOnLeftSide2) {
          addVertex(lastPointR, u0, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(currentPointL, u1, 0);
          addVertex(lastPointR, u0, 1);
          addVertex(currentPointL, u1, 0);
          addVertex(innerPoint, u1, 1);
          addVertex(currentPointL, u0, 0);
          addVertex(currentPoint, u1, 0.5);
          addVertex(innerPoint, u1, 1);
          addVertex(currentPoint, u1, 0.5);
          addVertex(nextPointL, u0, 0);
          addVertex(innerPoint, u1, 1);
        } else {
          addVertex(lastPointR, u0, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(currentPointR, u1, 1);
          addVertex(lastPointL, u0, 0);
          addVertex(innerPoint, u1, 0);
          addVertex(currentPointR, u1, 1);
          addVertex(currentPointR, u0, 1);
          addVertex(innerPoint, u1, 0);
          addVertex(currentPoint, u1, 0.5);
          addVertex(currentPoint, u1, 0.5);
          addVertex(innerPoint, u1, 0);
          addVertex(nextPointR, u0, 1);
        }
      }
    }
    function addCapGeometry(center, p1, p2, joinIsOnLeftSide2, start, u2) {
      switch (style.strokeLineCap) {
        case "round":
          if (start) {
            makeCircularSector(center, p2, p1, u2, 0.5);
          } else {
            makeCircularSector(center, p1, p2, u2, 0.5);
          }
          break;
        case "square":
          if (start) {
            tempV2_1.subVectors(p1, center);
            tempV2_2.set(tempV2_1.y, -tempV2_1.x);
            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);
            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);
            if (joinIsOnLeftSide2) {
              tempV2_3.toArray(vertices, 1 * 3);
              tempV2_4.toArray(vertices, 0 * 3);
              tempV2_4.toArray(vertices, 3 * 3);
            } else {
              tempV2_3.toArray(vertices, 1 * 3);
              uvs[3 * 2 + 1] === 1 ? tempV2_4.toArray(vertices, 3 * 3) : tempV2_3.toArray(vertices, 3 * 3);
              tempV2_4.toArray(vertices, 0 * 3);
            }
          } else {
            tempV2_1.subVectors(p2, center);
            tempV2_2.set(tempV2_1.y, -tempV2_1.x);
            tempV2_3.addVectors(tempV2_1, tempV2_2).add(center);
            tempV2_4.subVectors(tempV2_2, tempV2_1).add(center);
            const vl = vertices.length;
            if (joinIsOnLeftSide2) {
              tempV2_3.toArray(vertices, vl - 1 * 3);
              tempV2_4.toArray(vertices, vl - 2 * 3);
              tempV2_4.toArray(vertices, vl - 4 * 3);
            } else {
              tempV2_4.toArray(vertices, vl - 2 * 3);
              tempV2_3.toArray(vertices, vl - 1 * 3);
              tempV2_4.toArray(vertices, vl - 4 * 3);
            }
          }
          break;
        case "butt":
        default:
          break;
      }
    }
    function removeDuplicatedPoints(points2) {
      let dupPoints = false;
      for (let i2 = 1, n2 = points2.length - 1; i2 < n2; i2++) {
        if (points2[i2].distanceTo(points2[i2 + 1]) < minDistance) {
          dupPoints = true;
          break;
        }
      }
      if (!dupPoints)
        return points2;
      const newPoints = [];
      newPoints.push(points2[0]);
      for (let i2 = 1, n2 = points2.length - 1; i2 < n2; i2++) {
        if (points2[i2].distanceTo(points2[i2 + 1]) >= minDistance) {
          newPoints.push(points2[i2]);
        }
      }
      newPoints.push(points2[points2.length - 1]);
      return newPoints;
    }
  }
};

// node_modules/@pmndrs/uikit/dist/components/svg.js
function createSvg(parentContext, style, properties, defaultProperties, object, childrenContainer) {
  const initializers = [];
  const hoveredSignal = d([]);
  const activeSignal = d([]);
  setupCursorCleanup(hoveredSignal, initializers);
  const aspectRatio = d(void 0);
  const mergedProperties = computedMergedProperties(style, properties, defaultProperties, {
    ...darkPropertyTransformers,
    ...createResponsivePropertyTransformers(parentContext.root.size),
    ...createHoverPropertyTransformers(hoveredSignal),
    ...createActivePropertyTransfomers(activeSignal)
  }, keepAspectRatioPropertyTransformer, (m) => m.add("aspectRatio", aspectRatio));
  const node = d(void 0);
  const flexState = createFlexNodeState();
  createNode(node, flexState, parentContext, mergedProperties, object, true, initializers);
  const transformMatrix = computedTransformMatrix(mergedProperties, flexState, parentContext.root.pixelSize);
  applyTransform(parentContext.root, object, transformMatrix, initializers);
  const globalMatrix = computedGlobalMatrix(parentContext.childrenMatrix, transformMatrix);
  const isClipped = computedIsClipped(parentContext.clippingRect, globalMatrix, flexState.size, parentContext.root.pixelSize);
  const isVisible = computedIsVisible(flexState, isClipped, mergedProperties);
  const groupDeps = computedPanelGroupDependencies(mergedProperties);
  const backgroundOrderInfo = computedOrderInfo(mergedProperties, ElementType.Panel, groupDeps, parentContext.orderInfo);
  initializers.push((subscriptions) => createInstancedPanel(mergedProperties, backgroundOrderInfo, groupDeps, parentContext.root.panelGroupManager, globalMatrix, flexState.size, void 0, flexState.borderInset, parentContext.clippingRect, isVisible, getDefaultPanelMaterialConfig(), subscriptions));
  const orderInfo = computedOrderInfo(void 0, ElementType.Svg, void 0, backgroundOrderInfo);
  const src = w(() => {
    var _a, _b;
    return readReactive((_a = style.value) == null ? void 0 : _a.src) ?? readReactive((_b = properties.value) == null ? void 0 : _b.src);
  });
  const svgObject = d(void 0);
  const clippingPlanes = createGlobalClippingPlanes(parentContext.root, parentContext.clippingRect, initializers);
  loadResourceWithParams(svgObject, loadSvg, disposeGroup, initializers, src, parentContext.root, clippingPlanes, parentContext.clippingRect, orderInfo, aspectRatio);
  applyAppearancePropertiesToGroup(mergedProperties, svgObject, initializers, parentContext.root);
  const centerGroup = createCenterGroup(parentContext.root, flexState, svgObject, aspectRatio, isVisible, initializers);
  const scrollPosition = createScrollPosition();
  applyScrollPosition(childrenContainer, scrollPosition, parentContext.root.pixelSize, initializers);
  const childrenMatrix = computedGlobalScrollMatrix(scrollPosition, globalMatrix, parentContext.root.pixelSize);
  createScrollbars(mergedProperties, scrollPosition, flexState, globalMatrix, isVisible, parentContext.clippingRect, orderInfo, parentContext.root.panelGroupManager, initializers);
  const interactionPanel = createInteractionPanel(orderInfo, parentContext.root, parentContext.clippingRect, flexState.size, initializers);
  const scrollHandlers = computedScrollHandlers(scrollPosition, parentContext.anyAncestorScrollable, flexState, object, interactionPanel, properties, parentContext.root, initializers);
  setupLayoutListeners(style, properties, flexState.size, initializers);
  setupClippedListeners(style, properties, isClipped, initializers);
  return Object.assign(flexState, {
    scrollPosition,
    isClipped,
    mergedProperties,
    anyAncestorScrollable: computedAnyAncestorScrollable(flexState.scrollable, parentContext.anyAncestorScrollable),
    clippingRect: computedClippingRect(globalMatrix, flexState, parentContext.root.pixelSize, parentContext.clippingRect),
    childrenMatrix,
    node,
    orderInfo,
    root: parentContext.root,
    initializers,
    centerGroup,
    handlers: computedHandlers(style, properties, defaultProperties, hoveredSignal, activeSignal, scrollHandlers),
    interactionPanel
  });
}
function createCenterGroup(root, flexState, svgObject, aspectRatio, isVisible, initializers) {
  const centerGroup = new Group();
  centerGroup.matrixAutoUpdate = false;
  initializers.push(() => E(() => {
    fitNormalizedContentInside(centerGroup.position, centerGroup.scale, flexState.size, flexState.paddingInset, flexState.borderInset, root.pixelSize.value, aspectRatio.value ?? 1);
    centerGroup.updateMatrix();
    root.requestRender();
  }), () => E(() => {
    const object = svgObject.value;
    if (object == null) {
      return;
    }
    centerGroup.add(object);
    root.requestRender();
    return () => {
      centerGroup.remove(object);
      root.requestRender();
    };
  }), () => E(() => {
    void (centerGroup.visible = svgObject.value != null && isVisible.value);
    root.requestRender();
  }));
  return centerGroup;
}
var loader = new SVGLoader();
var box3Helper = new Box3();
var vectorHelper3 = new Vector3();
var svgCache = /* @__PURE__ */ new Map();
async function loadSvg(url, root, clippingPlanes, clippedRect, orderInfo, aspectRatio) {
  if (url == null) {
    return void 0;
  }
  const object = new Group();
  object.matrixAutoUpdate = false;
  let result = svgCache.get(url);
  if (result == null) {
    svgCache.set(url, result = await loader.loadAsync(url));
  }
  box3Helper.makeEmpty();
  for (const path of result.paths) {
    const shapes = SVGLoader.createShapes(path);
    const material = new MeshBasicMaterial();
    material.transparent = true;
    material.depthWrite = false;
    material.toneMapped = false;
    material.clippingPlanes = clippingPlanes;
    for (const shape of shapes) {
      const geometry = new ShapeGeometry(shape);
      geometry.computeBoundingBox();
      box3Helper.union(geometry.boundingBox);
      const mesh = new Mesh(geometry, material);
      mesh.matrixAutoUpdate = false;
      mesh.raycast = makeClippedCast(mesh, mesh.raycast, root.object, clippedRect, orderInfo);
      setupRenderOrder(mesh, root, orderInfo);
      mesh.userData.color = path.color;
      mesh.scale.y = -1;
      mesh.updateMatrix();
      object.add(mesh);
    }
  }
  box3Helper.getSize(vectorHelper3);
  aspectRatio.value = vectorHelper3.x / vectorHelper3.y;
  const scale = 1 / vectorHelper3.y;
  object.scale.set(1, 1, 1).multiplyScalar(scale);
  box3Helper.getCenter(vectorHelper3);
  vectorHelper3.y *= -1;
  object.position.copy(vectorHelper3).negate().multiplyScalar(scale);
  object.updateMatrix();
  return object;
}

// node_modules/@pmndrs/uikit/dist/components/icon.js
function createIcon(parentContext, text, svgWidth, svgHeight, style, properties, defaultProperties, object) {
  const initializers = [];
  const hoveredSignal = d([]);
  const activeSignal = d([]);
  setupCursorCleanup(hoveredSignal, initializers);
  const mergedProperties = computedMergedProperties(style, properties, defaultProperties, {
    ...darkPropertyTransformers,
    ...createResponsivePropertyTransformers(parentContext.root.size),
    ...createHoverPropertyTransformers(hoveredSignal),
    ...createActivePropertyTransfomers(activeSignal)
  }, keepAspectRatioPropertyTransformer, (m) => {
    m.add("aspectRatio", svgWidth / svgHeight);
    m.add("width", svgWidth);
    m.add("height", svgHeight);
  });
  const flexState = createFlexNodeState();
  createNode(void 0, flexState, parentContext, mergedProperties, object, true, initializers);
  const transformMatrix = computedTransformMatrix(mergedProperties, flexState, parentContext.root.pixelSize);
  applyTransform(parentContext.root, object, transformMatrix, initializers);
  const globalMatrix = computedGlobalMatrix(parentContext.childrenMatrix, transformMatrix);
  const isClipped = computedIsClipped(parentContext.clippingRect, globalMatrix, flexState.size, parentContext.root.pixelSize);
  const isVisible = computedIsVisible(flexState, isClipped, mergedProperties);
  const groupDeps = computedPanelGroupDependencies(mergedProperties);
  const backgroundOrderInfo = computedOrderInfo(mergedProperties, ElementType.Panel, groupDeps, parentContext.orderInfo);
  initializers.push((subscriptions) => createInstancedPanel(mergedProperties, backgroundOrderInfo, groupDeps, parentContext.root.panelGroupManager, globalMatrix, flexState.size, void 0, flexState.borderInset, parentContext.clippingRect, isVisible, getDefaultPanelMaterialConfig(), subscriptions));
  const orderInfo = computedOrderInfo(void 0, ElementType.Svg, void 0, backgroundOrderInfo);
  const clippingPlanes = createGlobalClippingPlanes(parentContext.root, parentContext.clippingRect, initializers);
  const iconGroup = createIconGroup(mergedProperties, text, svgWidth, svgHeight, parentContext, orderInfo, flexState, isVisible, clippingPlanes, initializers);
  setupLayoutListeners(style, properties, flexState.size, initializers);
  setupClippedListeners(style, properties, isClipped, initializers);
  return Object.assign(flexState, {
    isClipped,
    mergedProperties,
    initializers,
    iconGroup,
    handlers: computedHandlers(style, properties, defaultProperties, hoveredSignal, activeSignal),
    interactionPanel: createInteractionPanel(orderInfo, parentContext.root, parentContext.clippingRect, flexState.size, initializers)
  });
}
var loader2 = new SVGLoader();
function createIconGroup(propertiesSignal, text, svgWidth, svgHeight, parentContext, orderInfo, flexState, isVisible, clippingPlanes, initializers) {
  const group = new Group();
  group.matrixAutoUpdate = false;
  const result = loader2.parse(text);
  for (const path of result.paths) {
    const shapes = SVGLoader.createShapes(path);
    const material = new MeshBasicMaterial();
    material.transparent = true;
    material.depthWrite = false;
    material.toneMapped = false;
    material.clippingPlanes = clippingPlanes;
    for (const shape of shapes) {
      const geometry = new ShapeGeometry(shape);
      geometry.computeBoundingBox();
      const mesh = new Mesh(geometry, material);
      mesh.matrixAutoUpdate = false;
      mesh.raycast = makeClippedCast(mesh, mesh.raycast, parentContext.root.object, parentContext.clippingRect, orderInfo);
      setupRenderOrder(mesh, parentContext.root, orderInfo);
      mesh.userData.color = path.color;
      mesh.scale.y = -1;
      mesh.updateMatrix();
      group.add(mesh);
    }
  }
  const aspectRatio = svgWidth / svgHeight;
  initializers.push(() => E(() => {
    fitNormalizedContentInside(group.position, group.scale, flexState.size, flexState.paddingInset, flexState.borderInset, parentContext.root.pixelSize.value, aspectRatio);
    group.position.x -= group.scale.x * aspectRatio / 2;
    group.position.y += group.scale.x / 2;
    group.scale.divideScalar(svgHeight);
    group.updateMatrix();
    parentContext.root.requestRender();
  }), () => E(() => {
    group.visible = isVisible.value;
    parentContext.root.requestRender();
  }));
  applyAppearancePropertiesToGroup(propertiesSignal, group, initializers, parentContext.root);
  return group;
}

// node_modules/@pmndrs/uikit/dist/caret.js
var caretBorderKeys = [
  "caretBorderRightWidth",
  "caretBorderTopWidth",
  "caretBorderLeftWidth",
  "caretBorderBottomWidth"
];
var caretMaterialConfig;
function getCaretMaterialConfig() {
  caretMaterialConfig ?? (caretMaterialConfig = createPanelMaterialConfig({
    backgroundColor: "caretColor",
    backgroundOpacity: "caretOpacity",
    borderBend: "caretBorderBend",
    borderBottomLeftRadius: "caretBorderBottomLeftRadius",
    borderBottomRightRadius: "caretBorderBottomRightRadius",
    borderColor: "caretBorderColor",
    borderOpacity: "caretBorderOpacity",
    borderTopLeftRadius: "caretBorderTopLeftRadius",
    borderTopRightRadius: "caretBorderTopRightRadius"
  }, {
    backgroundColor: 0,
    backgroundOpacity: 1
  }));
  return caretMaterialConfig;
}
function createCaret(propertiesSignal, matrix, caretPosition, isVisible, parentOrderInfo, parentClippingRect, panelGroupManager, initializers) {
  const orderInfo = computedOrderInfo(void 0, ElementType.Panel, defaultPanelDependencies, parentOrderInfo);
  const blinkingCaretPosition = d(void 0);
  initializers.push(() => E(() => {
    const pos = caretPosition.value;
    if (pos == null) {
      blinkingCaretPosition.value = void 0;
    }
    blinkingCaretPosition.value = pos;
    const ref = setInterval(() => blinkingCaretPosition.value = blinkingCaretPosition.peek() == null ? pos : void 0, 500);
    return () => clearInterval(ref);
  }));
  const borderInset = computedBorderInset(propertiesSignal, caretBorderKeys);
  const caretWidth = computedInheritableProperty(propertiesSignal, "caretWidth", 1.5);
  initializers.push((subscriptions) => createInstancedPanel(propertiesSignal, orderInfo, void 0, panelGroupManager, matrix, w(() => {
    const size = blinkingCaretPosition.value;
    if (size == null) {
      return [0, 0];
    }
    return [caretWidth.value, size[2]];
  }), w(() => {
    const position = blinkingCaretPosition.value;
    if (position == null) {
      return [0, 0];
    }
    return [position[0] - caretWidth.value / 2, position[1]];
  }), borderInset, parentClippingRect, isVisible, getCaretMaterialConfig(), subscriptions));
}

// node_modules/@pmndrs/uikit/dist/selection.js
var selectionBorderKeys = [
  "selectionBorderRightWidth",
  "selectionBorderTopWidth",
  "selectionBorderLeftWidth",
  "selectionBorderBottomWidth"
];
var selectionMaterialConfig;
function getSelectionMaterialConfig() {
  selectionMaterialConfig ?? (selectionMaterialConfig = createPanelMaterialConfig({
    backgroundColor: "selectionColor",
    backgroundOpacity: "selectionOpacity",
    borderBend: "selectionBorderBend",
    borderBottomLeftRadius: "selectionBorderBottomLeftRadius",
    borderBottomRightRadius: "selectionBorderBottomRightRadius",
    borderColor: "selectionBorderColor",
    borderOpacity: "selectionBorderOpacity",
    borderTopLeftRadius: "selectionBorderTopLeftRadius",
    borderTopRightRadius: "selectionBorderTopRightRadius"
  }, {
    backgroundColor: 11851775,
    backgroundOpacity: 1
  }));
  return selectionMaterialConfig;
}
function createSelection(propertiesSignal, matrix, selectionBoxes, isVisible, prevOrderInfo, parentClippingRect, panelGroupManager, initializers) {
  const panels = [];
  const orderInfo = computedOrderInfo(void 0, ElementType.Panel, defaultPanelDependencies, prevOrderInfo);
  const borderInset = computedBorderInset(propertiesSignal, selectionBorderKeys);
  initializers.push(() => E(() => {
    const selections = selectionBoxes.value;
    const selectionsLength = selections.length;
    for (let i2 = 0; i2 < selectionsLength; i2++) {
      let panelData = panels[i2];
      if (panelData == null) {
        const size = d([0, 0]);
        const offset = d([0, 0]);
        const panelSubscriptions = [];
        createInstancedPanel(propertiesSignal, orderInfo, void 0, panelGroupManager, matrix, size, offset, borderInset, parentClippingRect, isVisible, getSelectionMaterialConfig(), panelSubscriptions);
        panels[i2] = panelData = {
          panelSubscriptions,
          offset,
          size
        };
      }
      const selection = selections[i2];
      panelData.size.value = selection.size;
      panelData.offset.value = selection.position;
    }
    const panelsLength = panels.length;
    for (let i2 = selectionsLength; i2 < panelsLength; i2++) {
      unsubscribeSubscriptions(panels[i2].panelSubscriptions);
    }
    panels.length = selectionsLength;
  }), () => () => {
    const panelsLength = panels.length;
    for (let i2 = 0; i2 < panelsLength; i2++) {
      unsubscribeSubscriptions(panels[i2].panelSubscriptions);
    }
  });
  return orderInfo;
}

// node_modules/@pmndrs/uikit/dist/focus.js
function createFocusPropertyTransformers(hasFocusSignal) {
  return {
    focus: createConditionalPropertyTranslator(() => hasFocusSignal.value)
  };
}

// node_modules/@pmndrs/uikit/dist/components/input.js
var cancelSet = /* @__PURE__ */ new Set();
function cancelBlur(event) {
  cancelSet.add(event);
}
var canvasInputProps = {
  onPointerDown: (e2) => {
    if (!(document.activeElement instanceof HTMLElement)) {
      return;
    }
    if (!cancelSet.has(e2.nativeEvent)) {
      return;
    }
    cancelSet.delete(e2.nativeEvent);
    e2.preventDefault();
  }
};
function createInput(parentContext, fontFamilies, style, properties, defaultProperties, object) {
  var _a, _b, _c, _d, _e3, _f2;
  const hoveredSignal = d([]);
  const activeSignal = d([]);
  const hasFocusSignal = d(false);
  const initializers = [];
  setupCursorCleanup(hoveredSignal, initializers);
  const mergedProperties = computedMergedProperties(style, properties, defaultProperties, {
    ...darkPropertyTransformers,
    ...createResponsivePropertyTransformers(parentContext.root.size),
    ...createHoverPropertyTransformers(hoveredSignal),
    ...createActivePropertyTransfomers(activeSignal),
    ...createFocusPropertyTransformers(hasFocusSignal)
  }, void 0, (m) => {
    traverseProperties(style.value, properties.value, defaultProperties.value, (p2) => {
      m.add("caretOpacity", p2.opacity);
      m.add("caretColor", p2.color);
    });
  });
  const flexState = createFlexNodeState();
  const nodeSignal = d(void 0);
  createNode(nodeSignal, flexState, parentContext, mergedProperties, object, false, initializers);
  const transformMatrix = computedTransformMatrix(mergedProperties, flexState, parentContext.root.pixelSize);
  applyTransform(parentContext.root, object, transformMatrix, initializers);
  const globalMatrix = computedGlobalMatrix(parentContext.childrenMatrix, transformMatrix);
  const isClipped = computedIsClipped(parentContext.clippingRect, globalMatrix, flexState.size, parentContext.root.pixelSize);
  const isVisible = computedIsVisible(flexState, isClipped, mergedProperties);
  const groupDeps = computedPanelGroupDependencies(mergedProperties);
  const backgroundOrderInfo = computedOrderInfo(mergedProperties, ElementType.Panel, groupDeps, parentContext.orderInfo);
  initializers.push((subscriptions) => createInstancedPanel(mergedProperties, backgroundOrderInfo, groupDeps, parentContext.root.panelGroupManager, globalMatrix, flexState.size, void 0, flexState.borderInset, parentContext.clippingRect, isVisible, getDefaultPanelMaterialConfig(), subscriptions));
  const instancedTextRef = {};
  const selectionBoxes = d([]);
  const caretPosition = d(void 0);
  const selectionRange = d(void 0);
  createCaret(mergedProperties, globalMatrix, caretPosition, isVisible, backgroundOrderInfo, parentContext.clippingRect, parentContext.root.panelGroupManager, initializers);
  const selectionOrderInfo = createSelection(mergedProperties, globalMatrix, selectionBoxes, isVisible, backgroundOrderInfo, parentContext.clippingRect, parentContext.root.panelGroupManager, initializers);
  const fontSignal = computedFont(mergedProperties, fontFamilies, parentContext.root.renderer, initializers);
  const orderInfo = computedOrderInfo(void 0, ElementType.Text, computedGylphGroupDependencies(fontSignal), selectionOrderInfo);
  const defaultValue = ((_a = style.peek()) == null ? void 0 : _a.defaultValue) ?? ((_b = properties.peek()) == null ? void 0 : _b.defaultValue);
  const writeValue = ((_c = style.peek()) == null ? void 0 : _c.value) == null && ((_d = properties.peek()) == null ? void 0 : _d.value) == null ? d(defaultValue ?? "") : void 0;
  const valueSignal = w(() => {
    var _a2, _b2;
    return (writeValue == null ? void 0 : writeValue.value) ?? readReactive((_a2 = style.value) == null ? void 0 : _a2.value) ?? readReactive((_b2 = properties.value) == null ? void 0 : _b2.value) ?? "";
  });
  const type = computedNonInheritableProperty(style, properties, "type", "text");
  const displayValueSignal = w(() => type.value === "text" ? valueSignal.value : "*".repeat(valueSignal.value.length ?? 0));
  const multiline = ((_e3 = style.peek()) == null ? void 0 : _e3.multiline) ?? ((_f2 = properties.peek()) == null ? void 0 : _f2.multiline) ?? false;
  const customLayouting = createInstancedText(mergedProperties, displayValueSignal, globalMatrix, nodeSignal, flexState, isVisible, parentContext.clippingRect, orderInfo, fontSignal, parentContext.root.gylphGroupManager, selectionRange, selectionBoxes, caretPosition, instancedTextRef, initializers, multiline ? "break-word" : "keep-all");
  initializers.push(() => E(() => {
    var _a2;
    return (_a2 = nodeSignal.value) == null ? void 0 : _a2.setCustomLayouting(customLayouting.value);
  }));
  setupLayoutListeners(style, properties, flexState.size, initializers);
  setupClippedListeners(style, properties, isClipped, initializers);
  const disabled = computedNonInheritableProperty(style, properties, "disabled", false);
  const element = createHtmlInputElement(valueSignal, selectionRange, (newValue) => {
    var _a2, _b2, _c2, _d2;
    if (writeValue != null) {
      writeValue.value = newValue;
    }
    (_b2 = (_a2 = style.peek()) == null ? void 0 : _a2.onValueChange) == null ? void 0 : _b2.call(_a2, newValue);
    (_d2 = (_c2 = properties.peek()) == null ? void 0 : _c2.onValueChange) == null ? void 0 : _d2.call(_c2, newValue);
  }, multiline, type, disabled, computedNonInheritableProperty(style, properties, "tabIndex", 0), initializers);
  const focus = (start, end, direction) => {
    const inputElement = element.peek();
    if (inputElement == null) {
      return;
    }
    if (!hasFocusSignal.peek()) {
      inputElement.focus();
    }
    if (start != null && end != null) {
      inputElement.setSelectionRange(start, end, direction);
    }
    selectionRange.value = [inputElement.selectionStart ?? 0, inputElement.selectionEnd ?? 0];
  };
  setupUpdateHasFocus(element, hasFocusSignal, initializers, (hasFocus) => {
    var _a2, _b2, _c2, _d2;
    (_b2 = (_a2 = properties.peek()) == null ? void 0 : _a2.onFocusChange) == null ? void 0 : _b2.call(_a2, hasFocus);
    (_d2 = (_c2 = style.peek()) == null ? void 0 : _c2.onFocusChange) == null ? void 0 : _d2.call(_c2, hasFocus);
  });
  const selectionHandlers = computedSelectionHandlers(flexState, instancedTextRef, focus, disabled);
  return Object.assign(flexState, {
    isClipped,
    mergedProperties,
    valueSignal,
    focus: () => focus(),
    root: parentContext.root,
    element,
    node: nodeSignal,
    interactionPanel: createInteractionPanel(backgroundOrderInfo, parentContext.root, parentContext.clippingRect, flexState.size, initializers),
    handlers: computedHandlers(style, properties, defaultProperties, hoveredSignal, activeSignal, selectionHandlers, "text"),
    initializers
  });
}
function computedSelectionHandlers(flexState, instancedTextRef, focus, disabled) {
  return w(() => {
    if (disabled.value) {
      return void 0;
    }
    let startCharIndex;
    return {
      onPointerDown: (e2) => {
        var _a;
        if (e2.defaultPrevented || e2.uv == null || instancedTextRef.current == null) {
          return;
        }
        cancelBlur(e2.nativeEvent);
        (_a = e2.stopPropagation) == null ? void 0 : _a.call(e2);
        const charIndex = uvToCharIndex(flexState, e2.uv, instancedTextRef.current);
        startCharIndex = charIndex;
        setTimeout(() => focus(charIndex, charIndex));
      },
      onPointerUp: (e2) => {
        startCharIndex = void 0;
      },
      onPointerLeave: (e2) => {
        startCharIndex = void 0;
      },
      onPointerMove: (e2) => {
        var _a;
        if (startCharIndex == null || e2.uv == null || instancedTextRef.current == null) {
          return;
        }
        (_a = e2.stopPropagation) == null ? void 0 : _a.call(e2);
        const charIndex = uvToCharIndex(flexState, e2.uv, instancedTextRef.current);
        const start = Math.min(startCharIndex, charIndex);
        const end = Math.max(startCharIndex, charIndex);
        const direction = startCharIndex < charIndex ? "forward" : "backward";
        setTimeout(() => focus(start, end, direction));
      }
    };
  });
}
function createHtmlInputElement(value, selectionRange, onChange, multiline, type, disabled, tabIndex, initializers) {
  const elementSignal = d(void 0);
  initializers.push((subscriptions) => {
    const element = document.createElement(multiline ? "textarea" : "input");
    const style = element.style;
    style.setProperty("position", "absolute");
    style.setProperty("left", "-1000vw");
    style.setProperty("top", "0");
    style.setProperty("pointerEvents", "none");
    style.setProperty("opacity", "0");
    element.addEventListener("input", () => {
      onChange == null ? void 0 : onChange(element.value);
      updateSelection();
    });
    const updateSelection = () => {
      const { selectionStart, selectionEnd } = element;
      if (selectionStart == null || selectionEnd == null) {
        selectionRange.value = void 0;
        return;
      }
      const current = selectionRange.peek();
      if (current != null && current[0] === selectionStart && current[1] === selectionEnd) {
        return;
      }
      selectionRange.value = [selectionStart, selectionEnd];
    };
    element.addEventListener("keydown", updateSelection);
    element.addEventListener("keyup", updateSelection);
    element.addEventListener("blur", () => selectionRange.value = void 0);
    document.body.appendChild(element);
    elementSignal.value = element;
    subscriptions.push(() => {
      elementSignal.value = void 0;
      element.remove();
    }, E(() => element.value = value.value), E(() => element.disabled = disabled.value), E(() => element.tabIndex = tabIndex.value), E(() => element.setAttribute("type", type.value)));
    return subscriptions;
  });
  return elementSignal;
}
function setupUpdateHasFocus(elementSignal, hasFocusSignal, initializers, onFocusChange) {
  initializers.push(() => E(() => {
    const element = elementSignal.value;
    if (element == null) {
      return;
    }
    hasFocusSignal.value = document.activeElement === element;
    const listener = () => {
      const hasFocus = document.activeElement === element;
      if (hasFocus == hasFocusSignal.value) {
        return;
      }
      hasFocusSignal.value = hasFocus;
      onFocusChange(hasFocus);
    };
    element.addEventListener("focus", listener);
    element.addEventListener("blur", listener);
    return () => {
      element.removeEventListener("focus", listener);
      element.removeEventListener("blur", listener);
    };
  }));
}
function uvToCharIndex({ size: s2, borderInset: b3, paddingInset: p2 }, uv2, instancedText) {
  const size = s2.peek();
  const borderInset = b3.peek();
  const paddingInset = p2.peek();
  if (size == null || borderInset == null || paddingInset == null) {
    return 0;
  }
  const [width, height] = size;
  const [bTop, , , bLeft] = borderInset;
  const [pTop, , , pLeft] = paddingInset;
  const x2 = uv2.x * width - bLeft - pLeft;
  const y3 = -uv2.y * height + bTop + pTop;
  return instancedText.getCharIndex(x2, y3);
}

// node_modules/@pmndrs/uikit/dist/components/custom.js
function createCustomContainer(parentContext, style, properties, defaultProperties, object, meshRef) {
  const hoveredSignal = d([]);
  const activeSignal = d([]);
  const initializers = [];
  setupCursorCleanup(hoveredSignal, initializers);
  const mergedProperties = computedMergedProperties(style, properties, defaultProperties, {
    ...darkPropertyTransformers,
    ...createResponsivePropertyTransformers(parentContext.root.size),
    ...createHoverPropertyTransformers(hoveredSignal),
    ...createActivePropertyTransfomers(activeSignal)
  });
  const flexState = createFlexNodeState();
  createNode(void 0, flexState, parentContext, mergedProperties, object, true, initializers);
  const transformMatrix = computedTransformMatrix(mergedProperties, flexState, parentContext.root.pixelSize);
  applyTransform(parentContext.root, object, transformMatrix, initializers);
  const globalMatrix = computedGlobalMatrix(parentContext.childrenMatrix, transformMatrix);
  const isClipped = computedIsClipped(parentContext.clippingRect, globalMatrix, flexState.size, parentContext.root.pixelSize);
  const isVisible = computedIsVisible(flexState, isClipped, mergedProperties);
  const orderInfo = computedOrderInfo(mergedProperties, ElementType.Custom, void 0, parentContext.orderInfo);
  const clippingPlanes = createGlobalClippingPlanes(parentContext.root, parentContext.clippingRect, initializers);
  initializers.push((subscriptions) => {
    const mesh = meshRef.current;
    if (mesh == null) {
      return subscriptions;
    }
    mesh.matrixAutoUpdate = false;
    if (mesh.material instanceof Material) {
      const material = mesh.material;
      material.clippingPlanes = clippingPlanes;
      material.needsUpdate = true;
      material.shadowSide = FrontSide;
      subscriptions.push(() => E(() => {
        material.depthTest = parentContext.root.depthTest.value;
        parentContext.root.requestRender();
      }));
    }
    mesh.raycast = makeClippedCast(mesh, mesh.raycast, parentContext.root.object, parentContext.clippingRect, orderInfo);
    setupRenderOrder(mesh, parentContext.root, orderInfo);
    subscriptions.push(E(() => {
      mesh.renderOrder = parentContext.root.renderOrder.value;
      parentContext.root.requestRender();
    }), E(() => {
      mesh.receiveShadow = mergedProperties.value.read("receiveShadow", false);
      parentContext.root.requestRender();
    }), E(() => {
      mesh.castShadow = mergedProperties.value.read("castShadow", false);
      parentContext.root.requestRender();
    }), E(() => {
      if (flexState.size.value == null) {
        return;
      }
      const [width, height] = flexState.size.value;
      const pixelSize = parentContext.root.pixelSize.value;
      mesh.scale.set(width * pixelSize, height * pixelSize, 1);
      mesh.updateMatrix();
      parentContext.root.requestRender();
    }), E(() => {
      void (mesh.visible = isVisible.value);
      parentContext.root.requestRender();
    }));
    return subscriptions;
  });
  setupLayoutListeners(style, properties, flexState.size, initializers);
  setupClippedListeners(style, properties, isClipped, initializers);
  return Object.assign(flexState, {
    isClipped,
    mergedProperties,
    root: parentContext.root,
    handlers: computedHandlers(style, properties, defaultProperties, hoveredSignal, activeSignal),
    initializers
  });
}

// node_modules/@pmndrs/uikit/dist/components/content.js
function createContent(parentContext, style, properties, defaultProperties, object, contentContainerRef) {
  const hoveredSignal = d([]);
  const activeSignal = d([]);
  const initializers = [];
  const flexState = createFlexNodeState();
  setupCursorCleanup(hoveredSignal, initializers);
  const sizeSignal = d(new Vector3(1, 1, 1));
  const aspectRatio = w(() => sizeSignal.value.x / sizeSignal.value.y);
  const mergedProperties = computedMergedProperties(style, properties, defaultProperties, {
    ...darkPropertyTransformers,
    ...createResponsivePropertyTransformers(parentContext.root.size),
    ...createHoverPropertyTransformers(hoveredSignal),
    ...createActivePropertyTransfomers(activeSignal)
  }, keepAspectRatioPropertyTransformer, (m) => m.add("aspectRatio", aspectRatio));
  createNode(void 0, flexState, parentContext, mergedProperties, object, true, initializers);
  const transformMatrix = computedTransformMatrix(mergedProperties, flexState, parentContext.root.pixelSize);
  applyTransform(parentContext.root, object, transformMatrix, initializers);
  const globalMatrix = computedGlobalMatrix(parentContext.childrenMatrix, transformMatrix);
  const isClipped = computedIsClipped(parentContext.clippingRect, globalMatrix, flexState.size, parentContext.root.pixelSize);
  const isVisible = computedIsVisible(flexState, isClipped, mergedProperties);
  const groupDeps = computedPanelGroupDependencies(mergedProperties);
  const backgroundorderInfo = computedOrderInfo(mergedProperties, ElementType.Panel, groupDeps, parentContext.orderInfo);
  initializers.push((subscriptions) => createInstancedPanel(mergedProperties, backgroundorderInfo, groupDeps, parentContext.root.panelGroupManager, globalMatrix, flexState.size, void 0, flexState.borderInset, parentContext.clippingRect, isVisible, getDefaultPanelMaterialConfig(), subscriptions));
  const orderInfo = computedOrderInfo(void 0, ElementType.Object, void 0, backgroundorderInfo);
  setupLayoutListeners(style, properties, flexState.size, initializers);
  setupClippedListeners(style, properties, isClipped, initializers);
  return Object.assign(flexState, {
    isClipped,
    mergedProperties,
    remeasureContent: createMeasureContent(mergedProperties, parentContext.root, flexState, parentContext.clippingRect, isVisible, orderInfo, sizeSignal, contentContainerRef, initializers),
    interactionPanel: createInteractionPanel(backgroundorderInfo, parentContext.root, parentContext.clippingRect, flexState.size, initializers),
    handlers: computedHandlers(style, properties, defaultProperties, hoveredSignal, activeSignal),
    initializers
  });
}
var box3Helper2 = new Box3();
var smallValue = new Vector3().setScalar(1e-3);
var vectorHelper4 = new Vector3();
var defaultDepthAlign = "back";
function createMeasureContent(propertiesSignal, root, flexState, parentClippingRect, isVisible, orderInfo, sizeSignal, contentContainerRef, initializers) {
  const clippingPlanes = createGlobalClippingPlanes(root, parentClippingRect, initializers);
  const depthAlign = computedInheritableProperty(propertiesSignal, "depthAlign", defaultDepthAlign);
  const keepAspectRatio = computedInheritableProperty(propertiesSignal, "keepAspectRatio", true);
  const measuredSize = new Vector3();
  const measuredCenter = new Vector3();
  const updateRenderProperties = (content, visible, renderOrder, depthTest) => {
    if (content == null) {
      return;
    }
    content.visible = visible;
    content.traverse((object) => {
      if (!(object instanceof Mesh)) {
        return;
      }
      object.renderOrder = renderOrder;
      if (!(object.material instanceof Material)) {
        return;
      }
      object.material.depthTest = depthTest;
    });
    root.requestRender();
  };
  const measureContent = () => {
    const content = contentContainerRef.current;
    if (content == null) {
      measuredSize.copy(smallValue);
      measuredCenter.set(0, 0, 0);
      return;
    }
    content.traverse((object) => {
      if (object instanceof Mesh) {
        setupRenderOrder(object, root, orderInfo);
        object.material.clippingPlanes = clippingPlanes;
        object.material.needsUpdate = true;
        object.raycast = makeClippedCast(object, object.raycast, root.object, parentClippingRect, orderInfo);
      }
    });
    const parent = content.parent;
    content.parent = null;
    box3Helper2.setFromObject(content);
    box3Helper2.getSize(measuredSize).max(smallValue);
    sizeSignal.value = measuredSize;
    if (parent != null) {
      content.parent = parent;
    }
    box3Helper2.getCenter(measuredCenter);
    root.requestRender();
  };
  initializers.push(() => E(() => {
    updateRenderProperties(contentContainerRef.current, isVisible.value, root.renderOrder.value, root.depthTest.value);
    root.requestRender();
  }), (subscriptions) => {
    const content = contentContainerRef.current;
    if (content == null) {
      return subscriptions;
    }
    measureContent();
    subscriptions.push(E(() => {
      const { size: { value: size }, paddingInset: { value: paddingInset }, borderInset: { value: borderInset } } = flexState;
      if (size == null || paddingInset == null || borderInset == null) {
        return;
      }
      const [width, height] = size;
      const [pTop, pRight, pBottom, pLeft] = paddingInset;
      const [bTop, bRight, bBottom, bLeft] = borderInset;
      const topInset = pTop + bTop;
      const rightInset = pRight + bRight;
      const bottomInset = pBottom + bBottom;
      const leftInset = pLeft + bLeft;
      const innerWidth = width - leftInset - rightInset;
      const innerHeight = height - topInset - bottomInset;
      const pixelSize = root.pixelSize.value;
      content.scale.set(innerWidth * pixelSize, innerHeight * pixelSize, keepAspectRatio.value ? innerHeight * pixelSize * measuredSize.z / measuredSize.y : measuredSize.z).divide(measuredSize);
      content.position.copy(measuredCenter).negate();
      content.position.z -= alignmentZMap[depthAlign.value] * measuredSize.z;
      content.position.multiply(content.scale);
      content.position.add(vectorHelper4.set((leftInset - rightInset) * 0.5 * pixelSize, (bottomInset - topInset) * 0.5 * pixelSize, 0));
      content.updateMatrix();
      root.requestRender();
    }));
    return subscriptions;
  });
  return () => {
    updateRenderProperties(contentContainerRef.current, isVisible.peek(), root.renderOrder.peek(), root.depthTest.peek());
    measureContent();
  };
}

// node_modules/@pmndrs/uikit/dist/components/fullscreen.js
function updateSizeFullscreen(sizeX, sizeY, pixelSize, distanceToCamera, camera, screenHeight) {
  if (camera instanceof PerspectiveCamera) {
    const cameraHeight = 2 * Math.tan(Math.PI * camera.fov / 360) * distanceToCamera;
    pixelSize.value = cameraHeight / screenHeight;
    sizeY.value = cameraHeight;
    sizeX.value = cameraHeight * camera.aspect;
  }
  if (camera instanceof OrthographicCamera) {
    const cameraHeight = camera.top - camera.bottom;
    const cameraWidth = camera.right - camera.left;
    pixelSize.value = cameraHeight / screenHeight;
    sizeY.value = cameraHeight;
    sizeX.value = cameraWidth;
  }
}

// node_modules/@pmndrs/uikit/dist/components/video.js
function updateVideoElement(element, { src, autoplay, loop, muted, playbackRate, preservesPitch, volume }) {
  if (src instanceof HTMLElement) {
    return;
  }
  if (autoplay) {
    element.remove();
    document.body.append(element);
    element.style.position = "absolute";
    element.style.width = "1px";
    element.style.zIndex = "-1000";
    element.style.top = "0px";
    element.style.left = "0px";
  }
  element.playsInline = true;
  element.volume = volume ?? 1;
  element.preservesPitch = preservesPitch ?? true;
  element.playbackRate = playbackRate ?? 1;
  element.muted = muted ?? false;
  element.loop = loop ?? false;
  element.autoplay = autoplay ?? false;
  if (src == null) {
    element.removeAttribute("src");
    element.removeAttribute("srcObject");
    return;
  }
  if (typeof src === "string") {
    element.src = src;
  } else {
    element.srcObject = src;
  }
}
function setupVideoElementInvalidation(element, invalidate) {
  let requestId;
  const callback = () => {
    invalidate();
    requestId = element.requestVideoFrameCallback(callback);
  };
  requestId = element.requestVideoFrameCallback(callback);
  return () => element.cancelVideoFrameCallback(requestId);
}

// node_modules/@pmndrs/uikit/dist/hover.js
function setupCursorCleanup(hoveredSignal, initializers) {
  initializers.push(() => () => unsetCursorType(hoveredSignal));
}
function addHoverHandlers(target, style, properties, defaultProperties, hoveredSignal, defaultCursor) {
  let hoverPropertiesExist = false;
  traverseProperties(style, properties, defaultProperties, (p2) => {
    if ("hover" in p2) {
      hoverPropertiesExist = true;
    }
  });
  const cursor = (style == null ? void 0 : style.cursor) ?? (properties == null ? void 0 : properties.cursor) ?? defaultCursor;
  if (!hoverPropertiesExist && (style == null ? void 0 : style.onHoverChange) == null && (properties == null ? void 0 : properties.onHoverChange) == null && cursor == null) {
    hoveredSignal.value.length = 0;
    return;
  }
  addHandler("onPointerOver", target, ({ pointerId }) => {
    var _a, _b;
    hoveredSignal.value = [pointerId, ...hoveredSignal.value];
    if (hoveredSignal.value.length === 1) {
      (_a = properties == null ? void 0 : properties.onHoverChange) == null ? void 0 : _a.call(properties, true);
      (_b = style == null ? void 0 : style.onHoverChange) == null ? void 0 : _b.call(style, true);
    }
    if (cursor != null) {
      setCursorType(hoveredSignal, cursor);
    }
  });
  addHandler("onPointerOut", target, ({ pointerId }) => {
    var _a, _b;
    hoveredSignal.value = hoveredSignal.value.filter((id) => id != pointerId);
    if (hoveredSignal.value.length === 0) {
      (_a = properties == null ? void 0 : properties.onHoverChange) == null ? void 0 : _a.call(properties, false);
      (_b = style == null ? void 0 : style.onHoverChange) == null ? void 0 : _b.call(style, false);
    }
    unsetCursorType(hoveredSignal);
  });
}
function createHoverPropertyTransformers(hoveredSignal) {
  return {
    hover: createConditionalPropertyTranslator(() => hoveredSignal.value.length > 0)
  };
}
var cursorRefStack = [];
var cursorTypeStack = [];
function setCursorType(ref, type) {
  cursorRefStack.push(ref);
  cursorTypeStack.push(type);
  document.body.style.cursor = type;
}
function unsetCursorType(ref) {
  const index = cursorRefStack.indexOf(ref);
  if (index == -1) {
    return;
  }
  cursorRefStack.splice(index, 1);
  cursorTypeStack.splice(index, 1);
  document.body.style.cursor = cursorTypeStack[cursorTypeStack.length - 1] ?? "default";
}

// node_modules/@pmndrs/uikit/dist/convert/html/internals.js
var import_node_html_parser = __toESM(require_dist(), 1);

// node_modules/@pmndrs/uikit/dist/convert/html/defaults.js
var htmlDefaults = {
  h1: {
    defaultProperties: {
      //tailwind disables this marginY: 10.67,
      fontSize: 32,
      fontWeight: "bold"
    }
  },
  h2: {
    defaultProperties: {
      //tailwind disables this marginY: 13.28,
      fontSize: 24,
      fontWeight: "bold"
    }
  },
  h3: {
    defaultProperties: {
      //tailwind disables this marginY: 16,
      fontSize: 18.72,
      fontWeight: "bold"
    }
  },
  h4: {
    defaultProperties: {
      //tailwind disables this marginY: 21.28,
      fontSize: 16,
      fontWeight: "bold"
    }
  },
  h5: {
    defaultProperties: {
      //tailwind disables this marginY: 26.72,
      fontSize: 13.28,
      fontWeight: "bold"
    }
  },
  h6: {
    defaultProperties: {
      //tailwind disables this marginY: 37.28,
      fontSize: 10.67,
      fontWeight: "bold"
    }
  },
  ol: {
    defaultProperties: { flexDirection: "column" }
  },
  ul: {
    defaultProperties: { flexDirection: "column" }
  },
  p: {
    defaultProperties: {
      //tailwind disables this marginY: 16
    }
  },
  a: {
    //TODO: custom property converter href => onClick ...
    defaultProperties: {
      //color: 'blue',
      cursor: "pointer"
    }
  },
  img: {
    renderAs: "Image"
  },
  button: { defaultProperties: { verticalAlign: "middle", textAlign: "center", cursor: "pointer" } },
  input: {
    renderAs: "Input",
    children: "none"
  },
  textarea: {
    renderAs: "Input",
    children: "none",
    defaultProperties: { multiline: true }
  },
  video: {
    renderAs: "Video"
  }
};

// node_modules/@pmndrs/uikit/dist/convert/html/internals.js
var import_inline_style_parser = __toESM(require_inline_style_parser(), 1);

// node_modules/tw-to-css/dist/index.mjs
var Ap = Object.create;
var gr = Object.defineProperty;
var _p = Object.getOwnPropertyDescriptor;
var Tp = Object.getOwnPropertyNames;
var Pp = Object.getPrototypeOf;
var Ip = Object.prototype.hasOwnProperty;
var dt = (t2, e2) => () => (t2 && (e2 = t2(t2 = 0)), e2);
var S = (t2, e2) => () => (e2 || t2((e2 = { exports: {} }).exports, e2), e2.exports);
var yr = (t2, e2) => {
  for (var r2 in e2)
    gr(t2, r2, { get: e2[r2], enumerable: true });
};
var Ia = (t2, e2, r2, n2) => {
  if (e2 && typeof e2 == "object" || typeof e2 == "function")
    for (let i2 of Tp(e2))
      !Ip.call(t2, i2) && i2 !== r2 && gr(t2, i2, { get: () => e2[i2], enumerable: !(n2 = _p(e2, i2)) || n2.enumerable });
  return t2;
};
var H = (t2, e2, r2) => (r2 = t2 != null ? Ap(Pp(t2)) : {}, Ia(e2 || !t2 || !t2.__esModule ? gr(r2, "default", { value: t2, enumerable: true }) : r2, t2));
var $e = (t2) => Ia(gr({}, "__esModule", { value: true }), t2);
var Ma;
var Da = dt(() => {
  Ma = `*,:before,:after{box-sizing:border-box;border-width:0;border-style:solid;border-color:theme("borderColor.DEFAULT",currentColor)}:before,:after{--tw-content: ""}html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:theme("fontFamily.sans",ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:theme("fontFamily.sans[1].fontFeatureSettings",normal);font-variation-settings:theme("fontFamily.sans[1].fontVariationSettings",normal)}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:theme("fontFamily.mono",ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;font-weight:inherit;line-height:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,[type=button],[type=reset],[type=submit]{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}ol,ul,menu{list-style:none;margin:0;padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:theme("colors.gray.400",#9ca3af)}button,[role=button]{cursor:pointer}:disabled{cursor:default}img,svg,video,canvas,audio,iframe,embed,object{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]{display:none}
`;
});
var Fa = {};
yr(Fa, { default: () => ht });
var ht;
var vr = dt(() => {
  Da();
  ht = { readFileSync: () => Ma };
});
var Na = S((mb, La) => {
  "use strict";
  var jn = class {
    constructor(e2 = {}) {
      if (!(e2.maxSize && e2.maxSize > 0))
        throw new TypeError("`maxSize` must be a number greater than 0");
      if (typeof e2.maxAge == "number" && e2.maxAge === 0)
        throw new TypeError("`maxAge` must be a number greater than 0");
      this.maxSize = e2.maxSize, this.maxAge = e2.maxAge || 1 / 0, this.onEviction = e2.onEviction, this.cache = /* @__PURE__ */ new Map(), this.oldCache = /* @__PURE__ */ new Map(), this._size = 0;
    }
    _emitEvictions(e2) {
      if (typeof this.onEviction == "function")
        for (let [r2, n2] of e2)
          this.onEviction(r2, n2.value);
    }
    _deleteIfExpired(e2, r2) {
      return typeof r2.expiry == "number" && r2.expiry <= Date.now() ? (typeof this.onEviction == "function" && this.onEviction(e2, r2.value), this.delete(e2)) : false;
    }
    _getOrDeleteIfExpired(e2, r2) {
      if (this._deleteIfExpired(e2, r2) === false)
        return r2.value;
    }
    _getItemValue(e2, r2) {
      return r2.expiry ? this._getOrDeleteIfExpired(e2, r2) : r2.value;
    }
    _peek(e2, r2) {
      let n2 = r2.get(e2);
      return this._getItemValue(e2, n2);
    }
    _set(e2, r2) {
      this.cache.set(e2, r2), this._size++, this._size >= this.maxSize && (this._size = 0, this._emitEvictions(this.oldCache), this.oldCache = this.cache, this.cache = /* @__PURE__ */ new Map());
    }
    _moveToRecent(e2, r2) {
      this.oldCache.delete(e2), this._set(e2, r2);
    }
    *_entriesAscending() {
      for (let e2 of this.oldCache) {
        let [r2, n2] = e2;
        this.cache.has(r2) || this._deleteIfExpired(r2, n2) === false && (yield e2);
      }
      for (let e2 of this.cache) {
        let [r2, n2] = e2;
        this._deleteIfExpired(r2, n2) === false && (yield e2);
      }
    }
    get(e2) {
      if (this.cache.has(e2)) {
        let r2 = this.cache.get(e2);
        return this._getItemValue(e2, r2);
      }
      if (this.oldCache.has(e2)) {
        let r2 = this.oldCache.get(e2);
        if (this._deleteIfExpired(e2, r2) === false)
          return this._moveToRecent(e2, r2), r2.value;
      }
    }
    set(e2, r2, { maxAge: n2 = this.maxAge === 1 / 0 ? void 0 : Date.now() + this.maxAge } = {}) {
      this.cache.has(e2) ? this.cache.set(e2, { value: r2, maxAge: n2 }) : this._set(e2, { value: r2, expiry: n2 });
    }
    has(e2) {
      return this.cache.has(e2) ? !this._deleteIfExpired(e2, this.cache.get(e2)) : this.oldCache.has(e2) ? !this._deleteIfExpired(e2, this.oldCache.get(e2)) : false;
    }
    peek(e2) {
      if (this.cache.has(e2))
        return this._peek(e2, this.cache);
      if (this.oldCache.has(e2))
        return this._peek(e2, this.oldCache);
    }
    delete(e2) {
      let r2 = this.cache.delete(e2);
      return r2 && this._size--, this.oldCache.delete(e2) || r2;
    }
    clear() {
      this.cache.clear(), this.oldCache.clear(), this._size = 0;
    }
    resize(e2) {
      if (!(e2 && e2 > 0))
        throw new TypeError("`maxSize` must be a number greater than 0");
      let r2 = [...this._entriesAscending()], n2 = r2.length - e2;
      n2 < 0 ? (this.cache = new Map(r2), this.oldCache = /* @__PURE__ */ new Map(), this._size = r2.length) : (n2 > 0 && this._emitEvictions(r2.slice(0, n2)), this.oldCache = new Map(r2.slice(n2)), this.cache = /* @__PURE__ */ new Map(), this._size = 0), this.maxSize = e2;
    }
    *keys() {
      for (let [e2] of this)
        yield e2;
    }
    *values() {
      for (let [, e2] of this)
        yield e2;
    }
    *[Symbol.iterator]() {
      for (let e2 of this.cache) {
        let [r2, n2] = e2;
        this._deleteIfExpired(r2, n2) === false && (yield [r2, n2.value]);
      }
      for (let e2 of this.oldCache) {
        let [r2, n2] = e2;
        this.cache.has(r2) || this._deleteIfExpired(r2, n2) === false && (yield [r2, n2.value]);
      }
    }
    *entriesDescending() {
      let e2 = [...this.cache];
      for (let r2 = e2.length - 1; r2 >= 0; --r2) {
        let n2 = e2[r2], [i2, a2] = n2;
        this._deleteIfExpired(i2, a2) === false && (yield [i2, a2.value]);
      }
      e2 = [...this.oldCache];
      for (let r2 = e2.length - 1; r2 >= 0; --r2) {
        let n2 = e2[r2], [i2, a2] = n2;
        this.cache.has(i2) || this._deleteIfExpired(i2, a2) === false && (yield [i2, a2.value]);
      }
    }
    *entriesAscending() {
      for (let [e2, r2] of this._entriesAscending())
        yield [e2, r2.value];
    }
    get size() {
      if (!this._size)
        return this.oldCache.size;
      let e2 = 0;
      for (let r2 of this.oldCache.keys())
        this.cache.has(r2) || e2++;
      return Math.min(this._size + e2, this.maxSize);
    }
  };
  La.exports = jn;
});
var Ua = {};
yr(Ua, { default: () => Bn });
var Bn;
var Gn = dt(() => {
  Bn = { yellow: (t2) => t2 };
});
var Yn = S(() => {
});
var br = S((bb, Va) => {
  "use strict";
  var ja = (Gn(), $e(Ua)), za = Yn(), Ue2 = class extends Error {
    constructor(e2, r2, n2, i2, a2, s2) {
      super(e2), this.name = "CssSyntaxError", this.reason = e2, a2 && (this.file = a2), i2 && (this.source = i2), s2 && (this.plugin = s2), typeof r2 < "u" && typeof n2 < "u" && (typeof r2 == "number" ? (this.line = r2, this.column = n2) : (this.line = r2.line, this.column = r2.column, this.endLine = n2.line, this.endColumn = n2.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, Ue2);
    }
    setMessage() {
      this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
    }
    showSourceCode(e2) {
      if (!this.source)
        return "";
      let r2 = this.source;
      e2 == null && (e2 = ja.isColorSupported), za && e2 && (r2 = za(r2));
      let n2 = r2.split(/\r?\n/), i2 = Math.max(this.line - 3, 0), a2 = Math.min(this.line + 2, n2.length), s2 = String(a2).length, o2, l2;
      if (e2) {
        let { bold: u2, gray: f2, red: p2 } = ja.createColors(true);
        o2 = (c2) => u2(p2(c2)), l2 = (c2) => f2(c2);
      } else
        o2 = l2 = (u2) => u2;
      return n2.slice(i2, a2).map((u2, f2) => {
        let p2 = i2 + 1 + f2, c2 = " " + (" " + p2).slice(-s2) + " | ";
        if (p2 === this.line) {
          let d2 = l2(c2.replace(/\d/g, " ")) + u2.slice(0, this.column - 1).replace(/[^\t]/g, " ");
          return o2(">") + l2(c2) + u2 + `
 ` + d2 + o2("^");
        }
        return " " + l2(c2) + u2;
      }).join(`
`);
    }
    toString() {
      let e2 = this.showSourceCode();
      return e2 && (e2 = `

` + e2 + `
`), this.name + ": " + this.message + e2;
    }
  };
  Va.exports = Ue2;
  Ue2.default = Ue2;
});
var xr = S((xb, Hn) => {
  "use strict";
  Hn.exports.isClean = Symbol("isClean");
  Hn.exports.my = Symbol("my");
});
var Qn = S((Sb, Ba) => {
  "use strict";
  var Wa = { after: `
`, beforeClose: `
`, beforeComment: `
`, beforeDecl: `
`, beforeOpen: " ", beforeRule: `
`, colon: ": ", commentLeft: " ", commentRight: " ", emptyBody: "", indent: "    ", semicolon: false };
  function Mp(t2) {
    return t2[0].toUpperCase() + t2.slice(1);
  }
  var gt2 = class {
    constructor(e2) {
      this.builder = e2;
    }
    atrule(e2, r2) {
      let n2 = "@" + e2.name, i2 = e2.params ? this.rawValue(e2, "params") : "";
      if (typeof e2.raws.afterName < "u" ? n2 += e2.raws.afterName : i2 && (n2 += " "), e2.nodes)
        this.block(e2, n2 + i2);
      else {
        let a2 = (e2.raws.between || "") + (r2 ? ";" : "");
        this.builder(n2 + i2 + a2, e2);
      }
    }
    beforeAfter(e2, r2) {
      let n2;
      e2.type === "decl" ? n2 = this.raw(e2, null, "beforeDecl") : e2.type === "comment" ? n2 = this.raw(e2, null, "beforeComment") : r2 === "before" ? n2 = this.raw(e2, null, "beforeRule") : n2 = this.raw(e2, null, "beforeClose");
      let i2 = e2.parent, a2 = 0;
      for (; i2 && i2.type !== "root"; )
        a2 += 1, i2 = i2.parent;
      if (n2.includes(`
`)) {
        let s2 = this.raw(e2, null, "indent");
        if (s2.length)
          for (let o2 = 0; o2 < a2; o2++)
            n2 += s2;
      }
      return n2;
    }
    block(e2, r2) {
      let n2 = this.raw(e2, "between", "beforeOpen");
      this.builder(r2 + n2 + "{", e2, "start");
      let i2;
      e2.nodes && e2.nodes.length ? (this.body(e2), i2 = this.raw(e2, "after")) : i2 = this.raw(e2, "after", "emptyBody"), i2 && this.builder(i2), this.builder("}", e2, "end");
    }
    body(e2) {
      let r2 = e2.nodes.length - 1;
      for (; r2 > 0 && e2.nodes[r2].type === "comment"; )
        r2 -= 1;
      let n2 = this.raw(e2, "semicolon");
      for (let i2 = 0; i2 < e2.nodes.length; i2++) {
        let a2 = e2.nodes[i2], s2 = this.raw(a2, "before");
        s2 && this.builder(s2), this.stringify(a2, r2 !== i2 || n2);
      }
    }
    comment(e2) {
      let r2 = this.raw(e2, "left", "commentLeft"), n2 = this.raw(e2, "right", "commentRight");
      this.builder("/*" + r2 + e2.text + n2 + "*/", e2);
    }
    decl(e2, r2) {
      let n2 = this.raw(e2, "between", "colon"), i2 = e2.prop + n2 + this.rawValue(e2, "value");
      e2.important && (i2 += e2.raws.important || " !important"), r2 && (i2 += ";"), this.builder(i2, e2);
    }
    document(e2) {
      this.body(e2);
    }
    raw(e2, r2, n2) {
      let i2;
      if (n2 || (n2 = r2), r2 && (i2 = e2.raws[r2], typeof i2 < "u"))
        return i2;
      let a2 = e2.parent;
      if (n2 === "before" && (!a2 || a2.type === "root" && a2.first === e2 || a2 && a2.type === "document"))
        return "";
      if (!a2)
        return Wa[n2];
      let s2 = e2.root();
      if (s2.rawCache || (s2.rawCache = {}), typeof s2.rawCache[n2] < "u")
        return s2.rawCache[n2];
      if (n2 === "before" || n2 === "after")
        return this.beforeAfter(e2, n2);
      {
        let o2 = "raw" + Mp(n2);
        this[o2] ? i2 = this[o2](s2, e2) : s2.walk((l2) => {
          if (i2 = l2.raws[r2], typeof i2 < "u")
            return false;
        });
      }
      return typeof i2 > "u" && (i2 = Wa[n2]), s2.rawCache[n2] = i2, i2;
    }
    rawBeforeClose(e2) {
      let r2;
      return e2.walk((n2) => {
        if (n2.nodes && n2.nodes.length > 0 && typeof n2.raws.after < "u")
          return r2 = n2.raws.after, r2.includes(`
`) && (r2 = r2.replace(/[^\n]+$/, "")), false;
      }), r2 && (r2 = r2.replace(/\S/g, "")), r2;
    }
    rawBeforeComment(e2, r2) {
      let n2;
      return e2.walkComments((i2) => {
        if (typeof i2.raws.before < "u")
          return n2 = i2.raws.before, n2.includes(`
`) && (n2 = n2.replace(/[^\n]+$/, "")), false;
      }), typeof n2 > "u" ? n2 = this.raw(r2, null, "beforeDecl") : n2 && (n2 = n2.replace(/\S/g, "")), n2;
    }
    rawBeforeDecl(e2, r2) {
      let n2;
      return e2.walkDecls((i2) => {
        if (typeof i2.raws.before < "u")
          return n2 = i2.raws.before, n2.includes(`
`) && (n2 = n2.replace(/[^\n]+$/, "")), false;
      }), typeof n2 > "u" ? n2 = this.raw(r2, null, "beforeRule") : n2 && (n2 = n2.replace(/\S/g, "")), n2;
    }
    rawBeforeOpen(e2) {
      let r2;
      return e2.walk((n2) => {
        if (n2.type !== "decl" && (r2 = n2.raws.between, typeof r2 < "u"))
          return false;
      }), r2;
    }
    rawBeforeRule(e2) {
      let r2;
      return e2.walk((n2) => {
        if (n2.nodes && (n2.parent !== e2 || e2.first !== n2) && typeof n2.raws.before < "u")
          return r2 = n2.raws.before, r2.includes(`
`) && (r2 = r2.replace(/[^\n]+$/, "")), false;
      }), r2 && (r2 = r2.replace(/\S/g, "")), r2;
    }
    rawColon(e2) {
      let r2;
      return e2.walkDecls((n2) => {
        if (typeof n2.raws.between < "u")
          return r2 = n2.raws.between.replace(/[^\s:]/g, ""), false;
      }), r2;
    }
    rawEmptyBody(e2) {
      let r2;
      return e2.walk((n2) => {
        if (n2.nodes && n2.nodes.length === 0 && (r2 = n2.raws.after, typeof r2 < "u"))
          return false;
      }), r2;
    }
    rawIndent(e2) {
      if (e2.raws.indent)
        return e2.raws.indent;
      let r2;
      return e2.walk((n2) => {
        let i2 = n2.parent;
        if (i2 && i2 !== e2 && i2.parent && i2.parent === e2 && typeof n2.raws.before < "u") {
          let a2 = n2.raws.before.split(`
`);
          return r2 = a2[a2.length - 1], r2 = r2.replace(/\S/g, ""), false;
        }
      }), r2;
    }
    rawSemicolon(e2) {
      let r2;
      return e2.walk((n2) => {
        if (n2.nodes && n2.nodes.length && n2.last.type === "decl" && (r2 = n2.raws.semicolon, typeof r2 < "u"))
          return false;
      }), r2;
    }
    rawValue(e2, r2) {
      let n2 = e2[r2], i2 = e2.raws[r2];
      return i2 && i2.value === n2 ? i2.raw : n2;
    }
    root(e2) {
      this.body(e2), e2.raws.after && this.builder(e2.raws.after);
    }
    rule(e2) {
      this.block(e2, this.rawValue(e2, "selector")), e2.raws.ownSemicolon && this.builder(e2.raws.ownSemicolon, e2, "end");
    }
    stringify(e2, r2) {
      if (!this[e2.type])
        throw new Error("Unknown AST node type " + e2.type + ". Maybe you need to change PostCSS stringifier.");
      this[e2.type](e2, r2);
    }
  };
  Ba.exports = gt2;
  gt2.default = gt2;
});
var yt = S((kb, Ga) => {
  "use strict";
  var Fp = Qn();
  function Jn2(t2, e2) {
    new Fp(e2).stringify(t2);
  }
  Ga.exports = Jn2;
  Jn2.default = Jn2;
});
var wt = S((Ob, Ya) => {
  "use strict";
  var { isClean: Sr2, my: Lp } = xr(), Np = br(), qp = Qn(), $p = yt();
  function Xn2(t2, e2) {
    let r2 = new t2.constructor();
    for (let n2 in t2) {
      if (!Object.prototype.hasOwnProperty.call(t2, n2) || n2 === "proxyCache")
        continue;
      let i2 = t2[n2], a2 = typeof i2;
      n2 === "parent" && a2 === "object" ? e2 && (r2[n2] = e2) : n2 === "source" ? r2[n2] = i2 : Array.isArray(i2) ? r2[n2] = i2.map((s2) => Xn2(s2, r2)) : (a2 === "object" && i2 !== null && (i2 = Xn2(i2)), r2[n2] = i2);
    }
    return r2;
  }
  var vt2 = class {
    constructor(e2 = {}) {
      this.raws = {}, this[Sr2] = false, this[Lp] = true;
      for (let r2 in e2)
        if (r2 === "nodes") {
          this.nodes = [];
          for (let n2 of e2[r2])
            typeof n2.clone == "function" ? this.append(n2.clone()) : this.append(n2);
        } else
          this[r2] = e2[r2];
    }
    addToError(e2) {
      if (e2.postcssNode = this, e2.stack && this.source && /\n\s{4}at /.test(e2.stack)) {
        let r2 = this.source;
        e2.stack = e2.stack.replace(/\n\s{4}at /, `$&${r2.input.from}:${r2.start.line}:${r2.start.column}$&`);
      }
      return e2;
    }
    after(e2) {
      return this.parent.insertAfter(this, e2), this;
    }
    assign(e2 = {}) {
      for (let r2 in e2)
        this[r2] = e2[r2];
      return this;
    }
    before(e2) {
      return this.parent.insertBefore(this, e2), this;
    }
    cleanRaws(e2) {
      delete this.raws.before, delete this.raws.after, e2 || delete this.raws.between;
    }
    clone(e2 = {}) {
      let r2 = Xn2(this);
      for (let n2 in e2)
        r2[n2] = e2[n2];
      return r2;
    }
    cloneAfter(e2 = {}) {
      let r2 = this.clone(e2);
      return this.parent.insertAfter(this, r2), r2;
    }
    cloneBefore(e2 = {}) {
      let r2 = this.clone(e2);
      return this.parent.insertBefore(this, r2), r2;
    }
    error(e2, r2 = {}) {
      if (this.source) {
        let { end: n2, start: i2 } = this.rangeBy(r2);
        return this.source.input.error(e2, { column: i2.column, line: i2.line }, { column: n2.column, line: n2.line }, r2);
      }
      return new Np(e2);
    }
    getProxyProcessor() {
      return { get(e2, r2) {
        return r2 === "proxyOf" ? e2 : r2 === "root" ? () => e2.root().toProxy() : e2[r2];
      }, set(e2, r2, n2) {
        return e2[r2] === n2 || (e2[r2] = n2, (r2 === "prop" || r2 === "value" || r2 === "name" || r2 === "params" || r2 === "important" || r2 === "text") && e2.markDirty()), true;
      } };
    }
    markDirty() {
      if (this[Sr2]) {
        this[Sr2] = false;
        let e2 = this;
        for (; e2 = e2.parent; )
          e2[Sr2] = false;
      }
    }
    next() {
      if (!this.parent)
        return;
      let e2 = this.parent.index(this);
      return this.parent.nodes[e2 + 1];
    }
    positionBy(e2, r2) {
      let n2 = this.source.start;
      if (e2.index)
        n2 = this.positionInside(e2.index, r2);
      else if (e2.word) {
        r2 = this.toString();
        let i2 = r2.indexOf(e2.word);
        i2 !== -1 && (n2 = this.positionInside(i2, r2));
      }
      return n2;
    }
    positionInside(e2, r2) {
      let n2 = r2 || this.toString(), i2 = this.source.start.column, a2 = this.source.start.line;
      for (let s2 = 0; s2 < e2; s2++)
        n2[s2] === `
` ? (i2 = 1, a2 += 1) : i2 += 1;
      return { column: i2, line: a2 };
    }
    prev() {
      if (!this.parent)
        return;
      let e2 = this.parent.index(this);
      return this.parent.nodes[e2 - 1];
    }
    rangeBy(e2) {
      let r2 = { column: this.source.start.column, line: this.source.start.line }, n2 = this.source.end ? { column: this.source.end.column + 1, line: this.source.end.line } : { column: r2.column + 1, line: r2.line };
      if (e2.word) {
        let i2 = this.toString(), a2 = i2.indexOf(e2.word);
        a2 !== -1 && (r2 = this.positionInside(a2, i2), n2 = this.positionInside(a2 + e2.word.length, i2));
      } else
        e2.start ? r2 = { column: e2.start.column, line: e2.start.line } : e2.index && (r2 = this.positionInside(e2.index)), e2.end ? n2 = { column: e2.end.column, line: e2.end.line } : e2.endIndex ? n2 = this.positionInside(e2.endIndex) : e2.index && (n2 = this.positionInside(e2.index + 1));
      return (n2.line < r2.line || n2.line === r2.line && n2.column <= r2.column) && (n2 = { column: r2.column + 1, line: r2.line }), { end: n2, start: r2 };
    }
    raw(e2, r2) {
      return new qp().raw(this, e2, r2);
    }
    remove() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }
    replaceWith(...e2) {
      if (this.parent) {
        let r2 = this, n2 = false;
        for (let i2 of e2)
          i2 === this ? n2 = true : n2 ? (this.parent.insertAfter(r2, i2), r2 = i2) : this.parent.insertBefore(r2, i2);
        n2 || this.remove();
      }
      return this;
    }
    root() {
      let e2 = this;
      for (; e2.parent && e2.parent.type !== "document"; )
        e2 = e2.parent;
      return e2;
    }
    toJSON(e2, r2) {
      let n2 = {}, i2 = r2 == null;
      r2 = r2 || /* @__PURE__ */ new Map();
      let a2 = 0;
      for (let s2 in this) {
        if (!Object.prototype.hasOwnProperty.call(this, s2) || s2 === "parent" || s2 === "proxyCache")
          continue;
        let o2 = this[s2];
        if (Array.isArray(o2))
          n2[s2] = o2.map((l2) => typeof l2 == "object" && l2.toJSON ? l2.toJSON(null, r2) : l2);
        else if (typeof o2 == "object" && o2.toJSON)
          n2[s2] = o2.toJSON(null, r2);
        else if (s2 === "source") {
          let l2 = r2.get(o2.input);
          l2 == null && (l2 = a2, r2.set(o2.input, a2), a2++), n2[s2] = { end: o2.end, inputId: l2, start: o2.start };
        } else
          n2[s2] = o2;
      }
      return i2 && (n2.inputs = [...r2.keys()].map((s2) => s2.toJSON())), n2;
    }
    toProxy() {
      return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
    }
    toString(e2 = $p) {
      e2.stringify && (e2 = e2.stringify);
      let r2 = "";
      return e2(this, (n2) => {
        r2 += n2;
      }), r2;
    }
    warn(e2, r2, n2) {
      let i2 = { node: this };
      for (let a2 in n2)
        i2[a2] = n2[a2];
      return e2.warn(r2, i2);
    }
    get proxyOf() {
      return this;
    }
  };
  Ya.exports = vt2;
  vt2.default = vt2;
});
var xt = S((Eb, Ha) => {
  "use strict";
  var Up = wt(), bt2 = class extends Up {
    constructor(e2) {
      e2 && typeof e2.value < "u" && typeof e2.value != "string" && (e2 = { ...e2, value: String(e2.value) }), super(e2), this.type = "decl";
    }
    get variable() {
      return this.prop.startsWith("--") || this.prop[0] === "$";
    }
  };
  Ha.exports = bt2;
  bt2.default = bt2;
});
var kr = S(() => {
});
var St = {};
yr(St, { join: () => Kn });
var Kn;
var kt = dt(() => {
  Kn = () => "";
});
var Zn = {};
yr(Zn, { default: () => jp });
var jp;
var ei = dt(() => {
  jp = null;
});
var Ja = S((_b, Qa) => {
  var zp = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", Vp = (t2, e2 = 21) => (r2 = e2) => {
    let n2 = "", i2 = r2;
    for (; i2--; )
      n2 += t2[Math.random() * t2.length | 0];
    return n2;
  }, Wp = (t2 = 21) => {
    let e2 = "", r2 = t2;
    for (; r2--; )
      e2 += zp[Math.random() * 64 | 0];
    return e2;
  };
  Qa.exports = { nanoid: Wp, customAlphabet: Vp };
});
var ri = S((Tb, Za) => {
  "use strict";
  var { SourceMapConsumer: Xa, SourceMapGenerator: Ka } = kr(), { existsSync: Bp, readFileSync: Gp } = (vr(), $e(Fa)), { dirname: ti2, join: Yp } = (kt(), $e(St));
  function Hp(t2) {
    return Buffer ? Buffer.from(t2, "base64").toString() : window.atob(t2);
  }
  var Ot2 = class {
    constructor(e2, r2) {
      if (r2.map === false)
        return;
      this.loadAnnotation(e2), this.inline = this.startWith(this.annotation, "data:");
      let n2 = r2.map ? r2.map.prev : void 0, i2 = this.loadMap(r2.from, n2);
      !this.mapFile && r2.from && (this.mapFile = r2.from), this.mapFile && (this.root = ti2(this.mapFile)), i2 && (this.text = i2);
    }
    consumer() {
      return this.consumerCache || (this.consumerCache = new Xa(this.text)), this.consumerCache;
    }
    decodeInline(e2) {
      let r2 = /^data:application\/json;charset=utf-?8;base64,/, n2 = /^data:application\/json;base64,/, i2 = /^data:application\/json;charset=utf-?8,/, a2 = /^data:application\/json,/;
      if (i2.test(e2) || a2.test(e2))
        return decodeURIComponent(e2.substr(RegExp.lastMatch.length));
      if (r2.test(e2) || n2.test(e2))
        return Hp(e2.substr(RegExp.lastMatch.length));
      let s2 = e2.match(/data:application\/json;([^,]+),/)[1];
      throw new Error("Unsupported source map encoding " + s2);
    }
    getAnnotationURL(e2) {
      return e2.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
    }
    isMap(e2) {
      return typeof e2 != "object" ? false : typeof e2.mappings == "string" || typeof e2._mappings == "string" || Array.isArray(e2.sections);
    }
    loadAnnotation(e2) {
      let r2 = e2.match(/\/\*\s*# sourceMappingURL=/gm);
      if (!r2)
        return;
      let n2 = e2.lastIndexOf(r2.pop()), i2 = e2.indexOf("*/", n2);
      n2 > -1 && i2 > -1 && (this.annotation = this.getAnnotationURL(e2.substring(n2, i2)));
    }
    loadFile(e2) {
      if (this.root = ti2(e2), Bp(e2))
        return this.mapFile = e2, Gp(e2, "utf-8").toString().trim();
    }
    loadMap(e2, r2) {
      if (r2 === false)
        return false;
      if (r2) {
        if (typeof r2 == "string")
          return r2;
        if (typeof r2 == "function") {
          let n2 = r2(e2);
          if (n2) {
            let i2 = this.loadFile(n2);
            if (!i2)
              throw new Error("Unable to load previous source map: " + n2.toString());
            return i2;
          }
        } else {
          if (r2 instanceof Xa)
            return Ka.fromSourceMap(r2).toString();
          if (r2 instanceof Ka)
            return r2.toString();
          if (this.isMap(r2))
            return JSON.stringify(r2);
          throw new Error("Unsupported previous source map format: " + r2.toString());
        }
      } else {
        if (this.inline)
          return this.decodeInline(this.annotation);
        if (this.annotation) {
          let n2 = this.annotation;
          return e2 && (n2 = Yp(ti2(e2), n2)), this.loadFile(n2);
        }
      }
    }
    startWith(e2, r2) {
      return e2 ? e2.substr(0, r2.length) === r2 : false;
    }
    withContent() {
      return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
    }
  };
  Za.exports = Ot2;
  Ot2.default = Ot2;
});
var Et = S((Pb, no2) => {
  "use strict";
  var { SourceMapConsumer: Qp, SourceMapGenerator: Jp } = kr(), { fileURLToPath: eo2, pathToFileURL: Or2 } = (ei(), $e(Zn)), { isAbsolute: si2, resolve: ai2 } = (kt(), $e(St)), { nanoid: Xp } = Ja(), ni2 = Yn(), to2 = br(), Kp = ri(), ii2 = Symbol("fromOffsetCache"), Zp = Boolean(Qp && Jp), ro2 = Boolean(ai2 && si2), Ye2 = class {
    constructor(e2, r2 = {}) {
      if (e2 === null || typeof e2 > "u" || typeof e2 == "object" && !e2.toString)
        throw new Error(`PostCSS received ${e2} instead of CSS string`);
      if (this.css = e2.toString(), this.css[0] === "\uFEFF" || this.css[0] === "￾" ? (this.hasBOM = true, this.css = this.css.slice(1)) : this.hasBOM = false, r2.from && (!ro2 || /^\w+:\/\//.test(r2.from) || si2(r2.from) ? this.file = r2.from : this.file = ai2(r2.from)), ro2 && Zp) {
        let n2 = new Kp(this.css, r2);
        if (n2.text) {
          this.map = n2;
          let i2 = n2.consumer().file;
          !this.file && i2 && (this.file = this.mapResolve(i2));
        }
      }
      this.file || (this.id = "<input css " + Xp(6) + ">"), this.map && (this.map.file = this.from);
    }
    error(e2, r2, n2, i2 = {}) {
      let a2, s2, o2;
      if (r2 && typeof r2 == "object") {
        let u2 = r2, f2 = n2;
        if (typeof u2.offset == "number") {
          let p2 = this.fromOffset(u2.offset);
          r2 = p2.line, n2 = p2.col;
        } else
          r2 = u2.line, n2 = u2.column;
        if (typeof f2.offset == "number") {
          let p2 = this.fromOffset(f2.offset);
          s2 = p2.line, o2 = p2.col;
        } else
          s2 = f2.line, o2 = f2.column;
      } else if (!n2) {
        let u2 = this.fromOffset(r2);
        r2 = u2.line, n2 = u2.col;
      }
      let l2 = this.origin(r2, n2, s2, o2);
      return l2 ? a2 = new to2(e2, l2.endLine === void 0 ? l2.line : { column: l2.column, line: l2.line }, l2.endLine === void 0 ? l2.column : { column: l2.endColumn, line: l2.endLine }, l2.source, l2.file, i2.plugin) : a2 = new to2(e2, s2 === void 0 ? r2 : { column: n2, line: r2 }, s2 === void 0 ? n2 : { column: o2, line: s2 }, this.css, this.file, i2.plugin), a2.input = { column: n2, endColumn: o2, endLine: s2, line: r2, source: this.css }, this.file && (Or2 && (a2.input.url = Or2(this.file).toString()), a2.input.file = this.file), a2;
    }
    fromOffset(e2) {
      let r2, n2;
      if (this[ii2])
        n2 = this[ii2];
      else {
        let a2 = this.css.split(`
`);
        n2 = new Array(a2.length);
        let s2 = 0;
        for (let o2 = 0, l2 = a2.length; o2 < l2; o2++)
          n2[o2] = s2, s2 += a2[o2].length + 1;
        this[ii2] = n2;
      }
      r2 = n2[n2.length - 1];
      let i2 = 0;
      if (e2 >= r2)
        i2 = n2.length - 1;
      else {
        let a2 = n2.length - 2, s2;
        for (; i2 < a2; )
          if (s2 = i2 + (a2 - i2 >> 1), e2 < n2[s2])
            a2 = s2 - 1;
          else if (e2 >= n2[s2 + 1])
            i2 = s2 + 1;
          else {
            i2 = s2;
            break;
          }
      }
      return { col: e2 - n2[i2] + 1, line: i2 + 1 };
    }
    mapResolve(e2) {
      return /^\w+:\/\//.test(e2) ? e2 : ai2(this.map.consumer().sourceRoot || this.map.root || ".", e2);
    }
    origin(e2, r2, n2, i2) {
      if (!this.map)
        return false;
      let a2 = this.map.consumer(), s2 = a2.originalPositionFor({ column: r2, line: e2 });
      if (!s2.source)
        return false;
      let o2;
      typeof n2 == "number" && (o2 = a2.originalPositionFor({ column: i2, line: n2 }));
      let l2;
      si2(s2.source) ? l2 = Or2(s2.source) : l2 = new URL(s2.source, this.map.consumer().sourceRoot || Or2(this.map.mapFile));
      let u2 = { column: s2.column, endColumn: o2 && o2.column, endLine: o2 && o2.line, line: s2.line, url: l2.toString() };
      if (l2.protocol === "file:")
        if (eo2)
          u2.file = eo2(l2);
        else
          throw new Error("file: protocol is not available in this PostCSS build");
      let f2 = a2.sourceContentFor(s2.source);
      return f2 && (u2.source = f2), u2;
    }
    toJSON() {
      let e2 = {};
      for (let r2 of ["hasBOM", "css", "file", "id"])
        this[r2] != null && (e2[r2] = this[r2]);
      return this.map && (e2.map = { ...this.map }, e2.map.consumerCache && (e2.map.consumerCache = void 0)), e2;
    }
    get from() {
      return this.file || this.id;
    }
  };
  no2.exports = Ye2;
  Ye2.default = Ye2;
  ni2 && ni2.registerInput && ni2.registerInput(Ye2);
});
var li = S((Ib, uo2) => {
  "use strict";
  var { SourceMapConsumer: so2, SourceMapGenerator: Er2 } = kr(), { dirname: Cr2, relative: ao2, resolve: oo2, sep: lo2 } = (kt(), $e(St)), { pathToFileURL: io2 } = (ei(), $e(Zn)), ed = Et(), td = Boolean(so2 && Er2), rd = Boolean(Cr2 && oo2 && ao2 && lo2), oi2 = class {
    constructor(e2, r2, n2, i2) {
      this.stringify = e2, this.mapOpts = n2.map || {}, this.root = r2, this.opts = n2, this.css = i2, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute, this.memoizedFileURLs = /* @__PURE__ */ new Map(), this.memoizedPaths = /* @__PURE__ */ new Map(), this.memoizedURLs = /* @__PURE__ */ new Map();
    }
    addAnnotation() {
      let e2;
      this.isInline() ? e2 = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? e2 = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? e2 = this.mapOpts.annotation(this.opts.to, this.root) : e2 = this.outputFile() + ".map";
      let r2 = `
`;
      this.css.includes(`\r
`) && (r2 = `\r
`), this.css += r2 + "/*# sourceMappingURL=" + e2 + " */";
    }
    applyPrevMaps() {
      for (let e2 of this.previous()) {
        let r2 = this.toUrl(this.path(e2.file)), n2 = e2.root || Cr2(e2.file), i2;
        this.mapOpts.sourcesContent === false ? (i2 = new so2(e2.text), i2.sourcesContent && (i2.sourcesContent = i2.sourcesContent.map(() => null))) : i2 = e2.consumer(), this.map.applySourceMap(i2, r2, this.toUrl(this.path(n2)));
      }
    }
    clearAnnotation() {
      if (this.mapOpts.annotation !== false)
        if (this.root) {
          let e2;
          for (let r2 = this.root.nodes.length - 1; r2 >= 0; r2--)
            e2 = this.root.nodes[r2], e2.type === "comment" && e2.text.indexOf("# sourceMappingURL=") === 0 && this.root.removeChild(r2);
        } else
          this.css && (this.css = this.css.replace(/(\n)?\/\*#[\S\s]*?\*\/$/gm, ""));
    }
    generate() {
      if (this.clearAnnotation(), rd && td && this.isMap())
        return this.generateMap();
      {
        let e2 = "";
        return this.stringify(this.root, (r2) => {
          e2 += r2;
        }), [e2];
      }
    }
    generateMap() {
      if (this.root)
        this.generateString();
      else if (this.previous().length === 1) {
        let e2 = this.previous()[0].consumer();
        e2.file = this.outputFile(), this.map = Er2.fromSourceMap(e2);
      } else
        this.map = new Er2({ file: this.outputFile() }), this.map.addMapping({ generated: { column: 0, line: 1 }, original: { column: 0, line: 1 }, source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>" });
      return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
    }
    generateString() {
      this.css = "", this.map = new Er2({ file: this.outputFile() });
      let e2 = 1, r2 = 1, n2 = "<no source>", i2 = { generated: { column: 0, line: 0 }, original: { column: 0, line: 0 }, source: "" }, a2, s2;
      this.stringify(this.root, (o2, l2, u2) => {
        if (this.css += o2, l2 && u2 !== "end" && (i2.generated.line = e2, i2.generated.column = r2 - 1, l2.source && l2.source.start ? (i2.source = this.sourcePath(l2), i2.original.line = l2.source.start.line, i2.original.column = l2.source.start.column - 1, this.map.addMapping(i2)) : (i2.source = n2, i2.original.line = 1, i2.original.column = 0, this.map.addMapping(i2))), a2 = o2.match(/\n/g), a2 ? (e2 += a2.length, s2 = o2.lastIndexOf(`
`), r2 = o2.length - s2) : r2 += o2.length, l2 && u2 !== "start") {
          let f2 = l2.parent || { raws: {} };
          (!(l2.type === "decl" || l2.type === "atrule" && !l2.nodes) || l2 !== f2.last || f2.raws.semicolon) && (l2.source && l2.source.end ? (i2.source = this.sourcePath(l2), i2.original.line = l2.source.end.line, i2.original.column = l2.source.end.column - 1, i2.generated.line = e2, i2.generated.column = r2 - 2, this.map.addMapping(i2)) : (i2.source = n2, i2.original.line = 1, i2.original.column = 0, i2.generated.line = e2, i2.generated.column = r2 - 1, this.map.addMapping(i2)));
        }
      });
    }
    isAnnotation() {
      return this.isInline() ? true : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((e2) => e2.annotation) : true;
    }
    isInline() {
      if (typeof this.mapOpts.inline < "u")
        return this.mapOpts.inline;
      let e2 = this.mapOpts.annotation;
      return typeof e2 < "u" && e2 !== true ? false : this.previous().length ? this.previous().some((r2) => r2.inline) : true;
    }
    isMap() {
      return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0;
    }
    isSourcesContent() {
      return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((e2) => e2.withContent()) : true;
    }
    outputFile() {
      return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
    }
    path(e2) {
      if (this.mapOpts.absolute || e2.charCodeAt(0) === 60 || /^\w+:\/\//.test(e2))
        return e2;
      let r2 = this.memoizedPaths.get(e2);
      if (r2)
        return r2;
      let n2 = this.opts.to ? Cr2(this.opts.to) : ".";
      typeof this.mapOpts.annotation == "string" && (n2 = Cr2(oo2(n2, this.mapOpts.annotation)));
      let i2 = ao2(n2, e2);
      return this.memoizedPaths.set(e2, i2), i2;
    }
    previous() {
      if (!this.previousMaps)
        if (this.previousMaps = [], this.root)
          this.root.walk((e2) => {
            if (e2.source && e2.source.input.map) {
              let r2 = e2.source.input.map;
              this.previousMaps.includes(r2) || this.previousMaps.push(r2);
            }
          });
        else {
          let e2 = new ed(this.css, this.opts);
          e2.map && this.previousMaps.push(e2.map);
        }
      return this.previousMaps;
    }
    setSourcesContent() {
      let e2 = {};
      if (this.root)
        this.root.walk((r2) => {
          if (r2.source) {
            let n2 = r2.source.input.from;
            if (n2 && !e2[n2]) {
              e2[n2] = true;
              let i2 = this.usesFileUrls ? this.toFileUrl(n2) : this.toUrl(this.path(n2));
              this.map.setSourceContent(i2, r2.source.input.css);
            }
          }
        });
      else if (this.css) {
        let r2 = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
        this.map.setSourceContent(r2, this.css);
      }
    }
    sourcePath(e2) {
      return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(e2.source.input.from) : this.toUrl(this.path(e2.source.input.from));
    }
    toBase64(e2) {
      return Buffer ? Buffer.from(e2).toString("base64") : window.btoa(unescape(encodeURIComponent(e2)));
    }
    toFileUrl(e2) {
      let r2 = this.memoizedFileURLs.get(e2);
      if (r2)
        return r2;
      if (io2) {
        let n2 = io2(e2).toString();
        return this.memoizedFileURLs.set(e2, n2), n2;
      } else
        throw new Error("`map.absolute` option is not available in this PostCSS build");
    }
    toUrl(e2) {
      let r2 = this.memoizedURLs.get(e2);
      if (r2)
        return r2;
      lo2 === "\\" && (e2 = e2.replace(/\\/g, "/"));
      let n2 = encodeURI(e2).replace(/[#?]/g, encodeURIComponent);
      return this.memoizedURLs.set(e2, n2), n2;
    }
  };
  uo2.exports = oi2;
});
var At = S((Rb, fo2) => {
  "use strict";
  var nd = wt(), Ct = class extends nd {
    constructor(e2) {
      super(e2), this.type = "comment";
    }
  };
  fo2.exports = Ct;
  Ct.default = Ct;
});
var _e = S((Db, bo) => {
  "use strict";
  var { isClean: co2, my: po2 } = xr(), ho2 = xt(), mo2 = At(), id = wt(), go2, ui2, fi2, yo2;
  function vo(t2) {
    return t2.map((e2) => (e2.nodes && (e2.nodes = vo(e2.nodes)), delete e2.source, e2));
  }
  function wo2(t2) {
    if (t2[co2] = false, t2.proxyOf.nodes)
      for (let e2 of t2.proxyOf.nodes)
        wo2(e2);
  }
  var ae2 = class extends id {
    append(...e2) {
      for (let r2 of e2) {
        let n2 = this.normalize(r2, this.last);
        for (let i2 of n2)
          this.proxyOf.nodes.push(i2);
      }
      return this.markDirty(), this;
    }
    cleanRaws(e2) {
      if (super.cleanRaws(e2), this.nodes)
        for (let r2 of this.nodes)
          r2.cleanRaws(e2);
    }
    each(e2) {
      if (!this.proxyOf.nodes)
        return;
      let r2 = this.getIterator(), n2, i2;
      for (; this.indexes[r2] < this.proxyOf.nodes.length && (n2 = this.indexes[r2], i2 = e2(this.proxyOf.nodes[n2], n2), i2 !== false); )
        this.indexes[r2] += 1;
      return delete this.indexes[r2], i2;
    }
    every(e2) {
      return this.nodes.every(e2);
    }
    getIterator() {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
      let e2 = this.lastEach;
      return this.indexes[e2] = 0, e2;
    }
    getProxyProcessor() {
      return { get(e2, r2) {
        return r2 === "proxyOf" ? e2 : e2[r2] ? r2 === "each" || typeof r2 == "string" && r2.startsWith("walk") ? (...n2) => e2[r2](...n2.map((i2) => typeof i2 == "function" ? (a2, s2) => i2(a2.toProxy(), s2) : i2)) : r2 === "every" || r2 === "some" ? (n2) => e2[r2]((i2, ...a2) => n2(i2.toProxy(), ...a2)) : r2 === "root" ? () => e2.root().toProxy() : r2 === "nodes" ? e2.nodes.map((n2) => n2.toProxy()) : r2 === "first" || r2 === "last" ? e2[r2].toProxy() : e2[r2] : e2[r2];
      }, set(e2, r2, n2) {
        return e2[r2] === n2 || (e2[r2] = n2, (r2 === "name" || r2 === "params" || r2 === "selector") && e2.markDirty()), true;
      } };
    }
    index(e2) {
      return typeof e2 == "number" ? e2 : (e2.proxyOf && (e2 = e2.proxyOf), this.proxyOf.nodes.indexOf(e2));
    }
    insertAfter(e2, r2) {
      let n2 = this.index(e2), i2 = this.normalize(r2, this.proxyOf.nodes[n2]).reverse();
      n2 = this.index(e2);
      for (let s2 of i2)
        this.proxyOf.nodes.splice(n2 + 1, 0, s2);
      let a2;
      for (let s2 in this.indexes)
        a2 = this.indexes[s2], n2 < a2 && (this.indexes[s2] = a2 + i2.length);
      return this.markDirty(), this;
    }
    insertBefore(e2, r2) {
      let n2 = this.index(e2), i2 = n2 === 0 ? "prepend" : false, a2 = this.normalize(r2, this.proxyOf.nodes[n2], i2).reverse();
      n2 = this.index(e2);
      for (let o2 of a2)
        this.proxyOf.nodes.splice(n2, 0, o2);
      let s2;
      for (let o2 in this.indexes)
        s2 = this.indexes[o2], n2 <= s2 && (this.indexes[o2] = s2 + a2.length);
      return this.markDirty(), this;
    }
    normalize(e2, r2) {
      if (typeof e2 == "string")
        e2 = vo(go2(e2).nodes);
      else if (Array.isArray(e2)) {
        e2 = e2.slice(0);
        for (let i2 of e2)
          i2.parent && i2.parent.removeChild(i2, "ignore");
      } else if (e2.type === "root" && this.type !== "document") {
        e2 = e2.nodes.slice(0);
        for (let i2 of e2)
          i2.parent && i2.parent.removeChild(i2, "ignore");
      } else if (e2.type)
        e2 = [e2];
      else if (e2.prop) {
        if (typeof e2.value > "u")
          throw new Error("Value field is missed in node creation");
        typeof e2.value != "string" && (e2.value = String(e2.value)), e2 = [new ho2(e2)];
      } else if (e2.selector)
        e2 = [new ui2(e2)];
      else if (e2.name)
        e2 = [new fi2(e2)];
      else if (e2.text)
        e2 = [new mo2(e2)];
      else
        throw new Error("Unknown node type in node creation");
      return e2.map((i2) => (i2[po2] || ae2.rebuild(i2), i2 = i2.proxyOf, i2.parent && i2.parent.removeChild(i2), i2[co2] && wo2(i2), typeof i2.raws.before > "u" && r2 && typeof r2.raws.before < "u" && (i2.raws.before = r2.raws.before.replace(/\S/g, "")), i2.parent = this.proxyOf, i2));
    }
    prepend(...e2) {
      e2 = e2.reverse();
      for (let r2 of e2) {
        let n2 = this.normalize(r2, this.first, "prepend").reverse();
        for (let i2 of n2)
          this.proxyOf.nodes.unshift(i2);
        for (let i2 in this.indexes)
          this.indexes[i2] = this.indexes[i2] + n2.length;
      }
      return this.markDirty(), this;
    }
    push(e2) {
      return e2.parent = this, this.proxyOf.nodes.push(e2), this;
    }
    removeAll() {
      for (let e2 of this.proxyOf.nodes)
        e2.parent = void 0;
      return this.proxyOf.nodes = [], this.markDirty(), this;
    }
    removeChild(e2) {
      e2 = this.index(e2), this.proxyOf.nodes[e2].parent = void 0, this.proxyOf.nodes.splice(e2, 1);
      let r2;
      for (let n2 in this.indexes)
        r2 = this.indexes[n2], r2 >= e2 && (this.indexes[n2] = r2 - 1);
      return this.markDirty(), this;
    }
    replaceValues(e2, r2, n2) {
      return n2 || (n2 = r2, r2 = {}), this.walkDecls((i2) => {
        r2.props && !r2.props.includes(i2.prop) || r2.fast && !i2.value.includes(r2.fast) || (i2.value = i2.value.replace(e2, n2));
      }), this.markDirty(), this;
    }
    some(e2) {
      return this.nodes.some(e2);
    }
    walk(e2) {
      return this.each((r2, n2) => {
        let i2;
        try {
          i2 = e2(r2, n2);
        } catch (a2) {
          throw r2.addToError(a2);
        }
        return i2 !== false && r2.walk && (i2 = r2.walk(e2)), i2;
      });
    }
    walkAtRules(e2, r2) {
      return r2 ? e2 instanceof RegExp ? this.walk((n2, i2) => {
        if (n2.type === "atrule" && e2.test(n2.name))
          return r2(n2, i2);
      }) : this.walk((n2, i2) => {
        if (n2.type === "atrule" && n2.name === e2)
          return r2(n2, i2);
      }) : (r2 = e2, this.walk((n2, i2) => {
        if (n2.type === "atrule")
          return r2(n2, i2);
      }));
    }
    walkComments(e2) {
      return this.walk((r2, n2) => {
        if (r2.type === "comment")
          return e2(r2, n2);
      });
    }
    walkDecls(e2, r2) {
      return r2 ? e2 instanceof RegExp ? this.walk((n2, i2) => {
        if (n2.type === "decl" && e2.test(n2.prop))
          return r2(n2, i2);
      }) : this.walk((n2, i2) => {
        if (n2.type === "decl" && n2.prop === e2)
          return r2(n2, i2);
      }) : (r2 = e2, this.walk((n2, i2) => {
        if (n2.type === "decl")
          return r2(n2, i2);
      }));
    }
    walkRules(e2, r2) {
      return r2 ? e2 instanceof RegExp ? this.walk((n2, i2) => {
        if (n2.type === "rule" && e2.test(n2.selector))
          return r2(n2, i2);
      }) : this.walk((n2, i2) => {
        if (n2.type === "rule" && n2.selector === e2)
          return r2(n2, i2);
      }) : (r2 = e2, this.walk((n2, i2) => {
        if (n2.type === "rule")
          return r2(n2, i2);
      }));
    }
    get first() {
      if (!!this.proxyOf.nodes)
        return this.proxyOf.nodes[0];
    }
    get last() {
      if (!!this.proxyOf.nodes)
        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
    }
  };
  ae2.registerParse = (t2) => {
    go2 = t2;
  };
  ae2.registerRule = (t2) => {
    ui2 = t2;
  };
  ae2.registerAtRule = (t2) => {
    fi2 = t2;
  };
  ae2.registerRoot = (t2) => {
    yo2 = t2;
  };
  bo.exports = ae2;
  ae2.default = ae2;
  ae2.rebuild = (t2) => {
    t2.type === "atrule" ? Object.setPrototypeOf(t2, fi2.prototype) : t2.type === "rule" ? Object.setPrototypeOf(t2, ui2.prototype) : t2.type === "decl" ? Object.setPrototypeOf(t2, ho2.prototype) : t2.type === "comment" ? Object.setPrototypeOf(t2, mo2.prototype) : t2.type === "root" && Object.setPrototypeOf(t2, yo2.prototype), t2[po2] = true, t2.nodes && t2.nodes.forEach((e2) => {
      ae2.rebuild(e2);
    });
  };
});
var Ar = S((Mb, ko2) => {
  "use strict";
  var sd = _e(), xo2, So, je2 = class extends sd {
    constructor(e2) {
      super({ type: "document", ...e2 }), this.nodes || (this.nodes = []);
    }
    toResult(e2 = {}) {
      return new xo2(new So(), this, e2).stringify();
    }
  };
  je2.registerLazyResult = (t2) => {
    xo2 = t2;
  };
  je2.registerProcessor = (t2) => {
    So = t2;
  };
  ko2.exports = je2;
  je2.default = je2;
});
var ci = S((Fb, Eo2) => {
  "use strict";
  var Oo = {};
  Eo2.exports = function(e2) {
    Oo[e2] || (Oo[e2] = true, typeof console < "u" && console.warn && console.warn(e2));
  };
});
var pi = S((Lb, Co) => {
  "use strict";
  var _t2 = class {
    constructor(e2, r2 = {}) {
      if (this.type = "warning", this.text = e2, r2.node && r2.node.source) {
        let n2 = r2.node.rangeBy(r2);
        this.line = n2.start.line, this.column = n2.start.column, this.endLine = n2.end.line, this.endColumn = n2.end.column;
      }
      for (let n2 in r2)
        this[n2] = r2[n2];
    }
    toString() {
      return this.node ? this.node.error(this.text, { index: this.index, plugin: this.plugin, word: this.word }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
    }
  };
  Co.exports = _t2;
  _t2.default = _t2;
});
var _r = S((Nb, Ao2) => {
  "use strict";
  var ad = pi(), Tt2 = class {
    constructor(e2, r2, n2) {
      this.processor = e2, this.messages = [], this.root = r2, this.opts = n2, this.css = void 0, this.map = void 0;
    }
    toString() {
      return this.css;
    }
    warn(e2, r2 = {}) {
      r2.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (r2.plugin = this.lastPlugin.postcssPlugin);
      let n2 = new ad(e2, r2);
      return this.messages.push(n2), n2;
    }
    warnings() {
      return this.messages.filter((e2) => e2.type === "warning");
    }
    get content() {
      return this.css;
    }
  };
  Ao2.exports = Tt2;
  Tt2.default = Tt2;
});
var Ro = S((qb, Io2) => {
  "use strict";
  var di2 = "'".charCodeAt(0), _o2 = '"'.charCodeAt(0), Tr2 = "\\".charCodeAt(0), To = "/".charCodeAt(0), Pr2 = `
`.charCodeAt(0), Pt2 = " ".charCodeAt(0), Ir2 = "\f".charCodeAt(0), Rr2 = "	".charCodeAt(0), Dr2 = "\r".charCodeAt(0), od = "[".charCodeAt(0), ld = "]".charCodeAt(0), ud = "(".charCodeAt(0), fd = ")".charCodeAt(0), cd = "{".charCodeAt(0), pd = "}".charCodeAt(0), dd = ";".charCodeAt(0), hd = "*".charCodeAt(0), md = ":".charCodeAt(0), gd = "@".charCodeAt(0), Mr2 = /[\t\n\f\r "#'()/;[\\\]{}]/g, Fr2 = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, yd = /.[\r\n"'(/\\]/, Po2 = /[\da-f]/i;
  Io2.exports = function(e2, r2 = {}) {
    let n2 = e2.css.valueOf(), i2 = r2.ignoreErrors, a2, s2, o2, l2, u2, f2, p2, c2, d2, h2, y3 = n2.length, m = 0, g2 = [], w2 = [];
    function b3() {
      return m;
    }
    function v2(E2) {
      throw e2.error("Unclosed " + E2, m);
    }
    function O2() {
      return w2.length === 0 && m >= y3;
    }
    function x2(E2) {
      if (w2.length)
        return w2.pop();
      if (m >= y3)
        return;
      let I2 = E2 ? E2.ignoreUnclosed : false;
      switch (a2 = n2.charCodeAt(m), a2) {
        case Pr2:
        case Pt2:
        case Rr2:
        case Dr2:
        case Ir2: {
          s2 = m;
          do
            s2 += 1, a2 = n2.charCodeAt(s2);
          while (a2 === Pt2 || a2 === Pr2 || a2 === Rr2 || a2 === Dr2 || a2 === Ir2);
          h2 = ["space", n2.slice(m, s2)], m = s2 - 1;
          break;
        }
        case od:
        case ld:
        case cd:
        case pd:
        case md:
        case dd:
        case fd: {
          let F = String.fromCharCode(a2);
          h2 = [F, F, m];
          break;
        }
        case ud: {
          if (c2 = g2.length ? g2.pop()[1] : "", d2 = n2.charCodeAt(m + 1), c2 === "url" && d2 !== di2 && d2 !== _o2 && d2 !== Pt2 && d2 !== Pr2 && d2 !== Rr2 && d2 !== Ir2 && d2 !== Dr2) {
            s2 = m;
            do {
              if (f2 = false, s2 = n2.indexOf(")", s2 + 1), s2 === -1)
                if (i2 || I2) {
                  s2 = m;
                  break;
                } else
                  v2("bracket");
              for (p2 = s2; n2.charCodeAt(p2 - 1) === Tr2; )
                p2 -= 1, f2 = !f2;
            } while (f2);
            h2 = ["brackets", n2.slice(m, s2 + 1), m, s2], m = s2;
          } else
            s2 = n2.indexOf(")", m + 1), l2 = n2.slice(m, s2 + 1), s2 === -1 || yd.test(l2) ? h2 = ["(", "(", m] : (h2 = ["brackets", l2, m, s2], m = s2);
          break;
        }
        case di2:
        case _o2: {
          o2 = a2 === di2 ? "'" : '"', s2 = m;
          do {
            if (f2 = false, s2 = n2.indexOf(o2, s2 + 1), s2 === -1)
              if (i2 || I2) {
                s2 = m + 1;
                break;
              } else
                v2("string");
            for (p2 = s2; n2.charCodeAt(p2 - 1) === Tr2; )
              p2 -= 1, f2 = !f2;
          } while (f2);
          h2 = ["string", n2.slice(m, s2 + 1), m, s2], m = s2;
          break;
        }
        case gd: {
          Mr2.lastIndex = m + 1, Mr2.test(n2), Mr2.lastIndex === 0 ? s2 = n2.length - 1 : s2 = Mr2.lastIndex - 2, h2 = ["at-word", n2.slice(m, s2 + 1), m, s2], m = s2;
          break;
        }
        case Tr2: {
          for (s2 = m, u2 = true; n2.charCodeAt(s2 + 1) === Tr2; )
            s2 += 1, u2 = !u2;
          if (a2 = n2.charCodeAt(s2 + 1), u2 && a2 !== To && a2 !== Pt2 && a2 !== Pr2 && a2 !== Rr2 && a2 !== Dr2 && a2 !== Ir2 && (s2 += 1, Po2.test(n2.charAt(s2)))) {
            for (; Po2.test(n2.charAt(s2 + 1)); )
              s2 += 1;
            n2.charCodeAt(s2 + 1) === Pt2 && (s2 += 1);
          }
          h2 = ["word", n2.slice(m, s2 + 1), m, s2], m = s2;
          break;
        }
        default: {
          a2 === To && n2.charCodeAt(m + 1) === hd ? (s2 = n2.indexOf("*/", m + 2) + 1, s2 === 0 && (i2 || I2 ? s2 = n2.length : v2("comment")), h2 = ["comment", n2.slice(m, s2 + 1), m, s2], m = s2) : (Fr2.lastIndex = m + 1, Fr2.test(n2), Fr2.lastIndex === 0 ? s2 = n2.length - 1 : s2 = Fr2.lastIndex - 2, h2 = ["word", n2.slice(m, s2 + 1), m, s2], g2.push(h2), m = s2);
          break;
        }
      }
      return m++, h2;
    }
    function A(E2) {
      w2.push(E2);
    }
    return { back: A, endOfFile: O2, nextToken: x2, position: b3 };
  };
});
var Lr = S(($b, Mo2) => {
  "use strict";
  var Do2 = _e(), He2 = class extends Do2 {
    constructor(e2) {
      super(e2), this.type = "atrule";
    }
    append(...e2) {
      return this.proxyOf.nodes || (this.nodes = []), super.append(...e2);
    }
    prepend(...e2) {
      return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e2);
    }
  };
  Mo2.exports = He2;
  He2.default = He2;
  Do2.registerAtRule(He2);
});
var Qe = S((Ub, qo2) => {
  "use strict";
  var Fo2 = _e(), Lo2, No, Te2 = class extends Fo2 {
    constructor(e2) {
      super(e2), this.type = "root", this.nodes || (this.nodes = []);
    }
    normalize(e2, r2, n2) {
      let i2 = super.normalize(e2);
      if (r2) {
        if (n2 === "prepend")
          this.nodes.length > 1 ? r2.raws.before = this.nodes[1].raws.before : delete r2.raws.before;
        else if (this.first !== r2)
          for (let a2 of i2)
            a2.raws.before = r2.raws.before;
      }
      return i2;
    }
    removeChild(e2, r2) {
      let n2 = this.index(e2);
      return !r2 && n2 === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[n2].raws.before), super.removeChild(e2);
    }
    toResult(e2 = {}) {
      return new Lo2(new No(), this, e2).stringify();
    }
  };
  Te2.registerLazyResult = (t2) => {
    Lo2 = t2;
  };
  Te2.registerProcessor = (t2) => {
    No = t2;
  };
  qo2.exports = Te2;
  Te2.default = Te2;
  Fo2.registerRoot(Te2);
});
var hi = S((jb, $o2) => {
  "use strict";
  var It2 = { comma(t2) {
    return It2.split(t2, [","], true);
  }, space(t2) {
    let e2 = [" ", `
`, "	"];
    return It2.split(t2, e2);
  }, split(t2, e2, r2) {
    let n2 = [], i2 = "", a2 = false, s2 = 0, o2 = false, l2 = "", u2 = false;
    for (let f2 of t2)
      u2 ? u2 = false : f2 === "\\" ? u2 = true : o2 ? f2 === l2 && (o2 = false) : f2 === '"' || f2 === "'" ? (o2 = true, l2 = f2) : f2 === "(" ? s2 += 1 : f2 === ")" ? s2 > 0 && (s2 -= 1) : s2 === 0 && e2.includes(f2) && (a2 = true), a2 ? (i2 !== "" && n2.push(i2.trim()), i2 = "", a2 = false) : i2 += f2;
    return (r2 || i2 !== "") && n2.push(i2.trim()), n2;
  } };
  $o2.exports = It2;
  It2.default = It2;
});
var Nr = S((zb, jo2) => {
  "use strict";
  var Uo2 = _e(), vd = hi(), Je2 = class extends Uo2 {
    constructor(e2) {
      super(e2), this.type = "rule", this.nodes || (this.nodes = []);
    }
    get selectors() {
      return vd.comma(this.selector);
    }
    set selectors(e2) {
      let r2 = this.selector ? this.selector.match(/,\s*/) : null, n2 = r2 ? r2[0] : "," + this.raw("between", "beforeOpen");
      this.selector = e2.join(n2);
    }
  };
  jo2.exports = Je2;
  Je2.default = Je2;
  Uo2.registerRule(Je2);
});
var Bo = S((Vb, Wo2) => {
  "use strict";
  var wd = xt(), bd = Ro(), xd = At(), Sd = Lr(), kd = Qe(), zo = Nr(), Vo2 = { empty: true, space: true };
  function Od(t2) {
    for (let e2 = t2.length - 1; e2 >= 0; e2--) {
      let r2 = t2[e2], n2 = r2[3] || r2[2];
      if (n2)
        return n2;
    }
  }
  var mi = class {
    constructor(e2) {
      this.input = e2, this.root = new kd(), this.current = this.root, this.spaces = "", this.semicolon = false, this.customProperty = false, this.createTokenizer(), this.root.source = { input: e2, start: { column: 1, line: 1, offset: 0 } };
    }
    atrule(e2) {
      let r2 = new Sd();
      r2.name = e2[1].slice(1), r2.name === "" && this.unnamedAtrule(r2, e2), this.init(r2, e2[2]);
      let n2, i2, a2, s2 = false, o2 = false, l2 = [], u2 = [];
      for (; !this.tokenizer.endOfFile(); ) {
        if (e2 = this.tokenizer.nextToken(), n2 = e2[0], n2 === "(" || n2 === "[" ? u2.push(n2 === "(" ? ")" : "]") : n2 === "{" && u2.length > 0 ? u2.push("}") : n2 === u2[u2.length - 1] && u2.pop(), u2.length === 0)
          if (n2 === ";") {
            r2.source.end = this.getPosition(e2[2]), r2.source.end.offset++, this.semicolon = true;
            break;
          } else if (n2 === "{") {
            o2 = true;
            break;
          } else if (n2 === "}") {
            if (l2.length > 0) {
              for (a2 = l2.length - 1, i2 = l2[a2]; i2 && i2[0] === "space"; )
                i2 = l2[--a2];
              i2 && (r2.source.end = this.getPosition(i2[3] || i2[2]), r2.source.end.offset++);
            }
            this.end(e2);
            break;
          } else
            l2.push(e2);
        else
          l2.push(e2);
        if (this.tokenizer.endOfFile()) {
          s2 = true;
          break;
        }
      }
      r2.raws.between = this.spacesAndCommentsFromEnd(l2), l2.length ? (r2.raws.afterName = this.spacesAndCommentsFromStart(l2), this.raw(r2, "params", l2), s2 && (e2 = l2[l2.length - 1], r2.source.end = this.getPosition(e2[3] || e2[2]), r2.source.end.offset++, this.spaces = r2.raws.between, r2.raws.between = "")) : (r2.raws.afterName = "", r2.params = ""), o2 && (r2.nodes = [], this.current = r2);
    }
    checkMissedSemicolon(e2) {
      let r2 = this.colon(e2);
      if (r2 === false)
        return;
      let n2 = 0, i2;
      for (let a2 = r2 - 1; a2 >= 0 && (i2 = e2[a2], !(i2[0] !== "space" && (n2 += 1, n2 === 2))); a2--)
        ;
      throw this.input.error("Missed semicolon", i2[0] === "word" ? i2[3] + 1 : i2[2]);
    }
    colon(e2) {
      let r2 = 0, n2, i2, a2;
      for (let [s2, o2] of e2.entries()) {
        if (n2 = o2, i2 = n2[0], i2 === "(" && (r2 += 1), i2 === ")" && (r2 -= 1), r2 === 0 && i2 === ":")
          if (!a2)
            this.doubleColon(n2);
          else {
            if (a2[0] === "word" && a2[1] === "progid")
              continue;
            return s2;
          }
        a2 = n2;
      }
      return false;
    }
    comment(e2) {
      let r2 = new xd();
      this.init(r2, e2[2]), r2.source.end = this.getPosition(e2[3] || e2[2]), r2.source.end.offset++;
      let n2 = e2[1].slice(2, -2);
      if (/^\s*$/.test(n2))
        r2.text = "", r2.raws.left = n2, r2.raws.right = "";
      else {
        let i2 = n2.match(/^(\s*)([^]*\S)(\s*)$/);
        r2.text = i2[2], r2.raws.left = i2[1], r2.raws.right = i2[3];
      }
    }
    createTokenizer() {
      this.tokenizer = bd(this.input);
    }
    decl(e2, r2) {
      let n2 = new wd();
      this.init(n2, e2[0][2]);
      let i2 = e2[e2.length - 1];
      for (i2[0] === ";" && (this.semicolon = true, e2.pop()), n2.source.end = this.getPosition(i2[3] || i2[2] || Od(e2)), n2.source.end.offset++; e2[0][0] !== "word"; )
        e2.length === 1 && this.unknownWord(e2), n2.raws.before += e2.shift()[1];
      for (n2.source.start = this.getPosition(e2[0][2]), n2.prop = ""; e2.length; ) {
        let u2 = e2[0][0];
        if (u2 === ":" || u2 === "space" || u2 === "comment")
          break;
        n2.prop += e2.shift()[1];
      }
      n2.raws.between = "";
      let a2;
      for (; e2.length; )
        if (a2 = e2.shift(), a2[0] === ":") {
          n2.raws.between += a2[1];
          break;
        } else
          a2[0] === "word" && /\w/.test(a2[1]) && this.unknownWord([a2]), n2.raws.between += a2[1];
      (n2.prop[0] === "_" || n2.prop[0] === "*") && (n2.raws.before += n2.prop[0], n2.prop = n2.prop.slice(1));
      let s2 = [], o2;
      for (; e2.length && (o2 = e2[0][0], !(o2 !== "space" && o2 !== "comment")); )
        s2.push(e2.shift());
      this.precheckMissedSemicolon(e2);
      for (let u2 = e2.length - 1; u2 >= 0; u2--) {
        if (a2 = e2[u2], a2[1].toLowerCase() === "!important") {
          n2.important = true;
          let f2 = this.stringFrom(e2, u2);
          f2 = this.spacesFromEnd(e2) + f2, f2 !== " !important" && (n2.raws.important = f2);
          break;
        } else if (a2[1].toLowerCase() === "important") {
          let f2 = e2.slice(0), p2 = "";
          for (let c2 = u2; c2 > 0; c2--) {
            let d2 = f2[c2][0];
            if (p2.trim().indexOf("!") === 0 && d2 !== "space")
              break;
            p2 = f2.pop()[1] + p2;
          }
          p2.trim().indexOf("!") === 0 && (n2.important = true, n2.raws.important = p2, e2 = f2);
        }
        if (a2[0] !== "space" && a2[0] !== "comment")
          break;
      }
      e2.some((u2) => u2[0] !== "space" && u2[0] !== "comment") && (n2.raws.between += s2.map((u2) => u2[1]).join(""), s2 = []), this.raw(n2, "value", s2.concat(e2), r2), n2.value.includes(":") && !r2 && this.checkMissedSemicolon(e2);
    }
    doubleColon(e2) {
      throw this.input.error("Double colon", { offset: e2[2] }, { offset: e2[2] + e2[1].length });
    }
    emptyRule(e2) {
      let r2 = new zo();
      this.init(r2, e2[2]), r2.selector = "", r2.raws.between = "", this.current = r2;
    }
    end(e2) {
      this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = false, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e2[2]), this.current.source.end.offset++, this.current = this.current.parent) : this.unexpectedClose(e2);
    }
    endFile() {
      this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.root.source.end = this.getPosition(this.tokenizer.position());
    }
    freeSemicolon(e2) {
      if (this.spaces += e2[1], this.current.nodes) {
        let r2 = this.current.nodes[this.current.nodes.length - 1];
        r2 && r2.type === "rule" && !r2.raws.ownSemicolon && (r2.raws.ownSemicolon = this.spaces, this.spaces = "");
      }
    }
    getPosition(e2) {
      let r2 = this.input.fromOffset(e2);
      return { column: r2.col, line: r2.line, offset: e2 };
    }
    init(e2, r2) {
      this.current.push(e2), e2.source = { input: this.input, start: this.getPosition(r2) }, e2.raws.before = this.spaces, this.spaces = "", e2.type !== "comment" && (this.semicolon = false);
    }
    other(e2) {
      let r2 = false, n2 = null, i2 = false, a2 = null, s2 = [], o2 = e2[1].startsWith("--"), l2 = [], u2 = e2;
      for (; u2; ) {
        if (n2 = u2[0], l2.push(u2), n2 === "(" || n2 === "[")
          a2 || (a2 = u2), s2.push(n2 === "(" ? ")" : "]");
        else if (o2 && i2 && n2 === "{")
          a2 || (a2 = u2), s2.push("}");
        else if (s2.length === 0)
          if (n2 === ";")
            if (i2) {
              this.decl(l2, o2);
              return;
            } else
              break;
          else if (n2 === "{") {
            this.rule(l2);
            return;
          } else if (n2 === "}") {
            this.tokenizer.back(l2.pop()), r2 = true;
            break;
          } else
            n2 === ":" && (i2 = true);
        else
          n2 === s2[s2.length - 1] && (s2.pop(), s2.length === 0 && (a2 = null));
        u2 = this.tokenizer.nextToken();
      }
      if (this.tokenizer.endOfFile() && (r2 = true), s2.length > 0 && this.unclosedBracket(a2), r2 && i2) {
        if (!o2)
          for (; l2.length && (u2 = l2[l2.length - 1][0], !(u2 !== "space" && u2 !== "comment")); )
            this.tokenizer.back(l2.pop());
        this.decl(l2, o2);
      } else
        this.unknownWord(l2);
    }
    parse() {
      let e2;
      for (; !this.tokenizer.endOfFile(); )
        switch (e2 = this.tokenizer.nextToken(), e2[0]) {
          case "space":
            this.spaces += e2[1];
            break;
          case ";":
            this.freeSemicolon(e2);
            break;
          case "}":
            this.end(e2);
            break;
          case "comment":
            this.comment(e2);
            break;
          case "at-word":
            this.atrule(e2);
            break;
          case "{":
            this.emptyRule(e2);
            break;
          default:
            this.other(e2);
            break;
        }
      this.endFile();
    }
    precheckMissedSemicolon() {
    }
    raw(e2, r2, n2, i2) {
      let a2, s2, o2 = n2.length, l2 = "", u2 = true, f2, p2;
      for (let c2 = 0; c2 < o2; c2 += 1)
        a2 = n2[c2], s2 = a2[0], s2 === "space" && c2 === o2 - 1 && !i2 ? u2 = false : s2 === "comment" ? (p2 = n2[c2 - 1] ? n2[c2 - 1][0] : "empty", f2 = n2[c2 + 1] ? n2[c2 + 1][0] : "empty", !Vo2[p2] && !Vo2[f2] ? l2.slice(-1) === "," ? u2 = false : l2 += a2[1] : u2 = false) : l2 += a2[1];
      if (!u2) {
        let c2 = n2.reduce((d2, h2) => d2 + h2[1], "");
        e2.raws[r2] = { raw: c2, value: l2 };
      }
      e2[r2] = l2;
    }
    rule(e2) {
      e2.pop();
      let r2 = new zo();
      this.init(r2, e2[0][2]), r2.raws.between = this.spacesAndCommentsFromEnd(e2), this.raw(r2, "selector", e2), this.current = r2;
    }
    spacesAndCommentsFromEnd(e2) {
      let r2, n2 = "";
      for (; e2.length && (r2 = e2[e2.length - 1][0], !(r2 !== "space" && r2 !== "comment")); )
        n2 = e2.pop()[1] + n2;
      return n2;
    }
    spacesAndCommentsFromStart(e2) {
      let r2, n2 = "";
      for (; e2.length && (r2 = e2[0][0], !(r2 !== "space" && r2 !== "comment")); )
        n2 += e2.shift()[1];
      return n2;
    }
    spacesFromEnd(e2) {
      let r2, n2 = "";
      for (; e2.length && (r2 = e2[e2.length - 1][0], r2 === "space"); )
        n2 = e2.pop()[1] + n2;
      return n2;
    }
    stringFrom(e2, r2) {
      let n2 = "";
      for (let i2 = r2; i2 < e2.length; i2++)
        n2 += e2[i2][1];
      return e2.splice(r2, e2.length - r2), n2;
    }
    unclosedBlock() {
      let e2 = this.current.source.start;
      throw this.input.error("Unclosed block", e2.line, e2.column);
    }
    unclosedBracket(e2) {
      throw this.input.error("Unclosed bracket", { offset: e2[2] }, { offset: e2[2] + 1 });
    }
    unexpectedClose(e2) {
      throw this.input.error("Unexpected }", { offset: e2[2] }, { offset: e2[2] + 1 });
    }
    unknownWord(e2) {
      throw this.input.error("Unknown word", { offset: e2[0][2] }, { offset: e2[0][2] + e2[0][1].length });
    }
    unnamedAtrule(e2, r2) {
      throw this.input.error("At-rule without name", { offset: r2[2] }, { offset: r2[2] + r2[1].length });
    }
  };
  Wo2.exports = mi;
});
var $r = S((Wb, Go2) => {
  "use strict";
  var Ed = _e(), Cd = Bo(), Ad = Et();
  function qr2(t2, e2) {
    let r2 = new Ad(t2, e2), n2 = new Cd(r2);
    try {
      n2.parse();
    } catch (i2) {
      throw i2;
    }
    return n2.root;
  }
  Go2.exports = qr2;
  qr2.default = qr2;
  Ed.registerParse(qr2);
});
var vi = S((Gb, Jo2) => {
  "use strict";
  var { isClean: me2, my: _d } = xr(), Td = li(), Pd = yt(), Id = _e(), Rd = Ar(), Bb = ci(), Yo2 = _r(), Dd = $r(), Md = Qe(), Fd = { atrule: "AtRule", comment: "Comment", decl: "Declaration", document: "Document", root: "Root", rule: "Rule" }, Ld = { AtRule: true, AtRuleExit: true, Comment: true, CommentExit: true, Declaration: true, DeclarationExit: true, Document: true, DocumentExit: true, Once: true, OnceExit: true, postcssPlugin: true, prepare: true, Root: true, RootExit: true, Rule: true, RuleExit: true }, Nd = { Once: true, postcssPlugin: true, prepare: true }, Xe2 = 0;
  function Rt2(t2) {
    return typeof t2 == "object" && typeof t2.then == "function";
  }
  function Qo2(t2) {
    let e2 = false, r2 = Fd[t2.type];
    return t2.type === "decl" ? e2 = t2.prop.toLowerCase() : t2.type === "atrule" && (e2 = t2.name.toLowerCase()), e2 && t2.append ? [r2, r2 + "-" + e2, Xe2, r2 + "Exit", r2 + "Exit-" + e2] : e2 ? [r2, r2 + "-" + e2, r2 + "Exit", r2 + "Exit-" + e2] : t2.append ? [r2, Xe2, r2 + "Exit"] : [r2, r2 + "Exit"];
  }
  function Ho2(t2) {
    let e2;
    return t2.type === "document" ? e2 = ["Document", Xe2, "DocumentExit"] : t2.type === "root" ? e2 = ["Root", Xe2, "RootExit"] : e2 = Qo2(t2), { eventIndex: 0, events: e2, iterator: 0, node: t2, visitorIndex: 0, visitors: [] };
  }
  function gi(t2) {
    return t2[me2] = false, t2.nodes && t2.nodes.forEach((e2) => gi(e2)), t2;
  }
  var yi = {}, ge2 = class {
    constructor(e2, r2, n2) {
      this.stringified = false, this.processed = false;
      let i2;
      if (typeof r2 == "object" && r2 !== null && (r2.type === "root" || r2.type === "document"))
        i2 = gi(r2);
      else if (r2 instanceof ge2 || r2 instanceof Yo2)
        i2 = gi(r2.root), r2.map && (typeof n2.map > "u" && (n2.map = {}), n2.map.inline || (n2.map.inline = false), n2.map.prev = r2.map);
      else {
        let a2 = Dd;
        n2.syntax && (a2 = n2.syntax.parse), n2.parser && (a2 = n2.parser), a2.parse && (a2 = a2.parse);
        try {
          i2 = a2(r2, n2);
        } catch (s2) {
          this.processed = true, this.error = s2;
        }
        i2 && !i2[_d] && Id.rebuild(i2);
      }
      this.result = new Yo2(e2, i2, n2), this.helpers = { ...yi, postcss: yi, result: this.result }, this.plugins = this.processor.plugins.map((a2) => typeof a2 == "object" && a2.prepare ? { ...a2, ...a2.prepare(this.result) } : a2);
    }
    async() {
      return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
    }
    catch(e2) {
      return this.async().catch(e2);
    }
    finally(e2) {
      return this.async().then(e2, e2);
    }
    getAsyncError() {
      throw new Error("Use process(css).then(cb) to work with async plugins");
    }
    handleError(e2, r2) {
      let n2 = this.result.lastPlugin;
      try {
        r2 && r2.addToError(e2), this.error = e2, e2.name === "CssSyntaxError" && !e2.plugin ? (e2.plugin = n2.postcssPlugin, e2.setMessage()) : n2.postcssVersion;
      } catch (i2) {
        console && console.error && console.error(i2);
      }
      return e2;
    }
    prepareVisitors() {
      this.listeners = {};
      let e2 = (r2, n2, i2) => {
        this.listeners[n2] || (this.listeners[n2] = []), this.listeners[n2].push([r2, i2]);
      };
      for (let r2 of this.plugins)
        if (typeof r2 == "object")
          for (let n2 in r2) {
            if (!Ld[n2] && /^[A-Z]/.test(n2))
              throw new Error(`Unknown event ${n2} in ${r2.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
            if (!Nd[n2])
              if (typeof r2[n2] == "object")
                for (let i2 in r2[n2])
                  i2 === "*" ? e2(r2, n2, r2[n2][i2]) : e2(r2, n2 + "-" + i2.toLowerCase(), r2[n2][i2]);
              else
                typeof r2[n2] == "function" && e2(r2, n2, r2[n2]);
          }
      this.hasListener = Object.keys(this.listeners).length > 0;
    }
    async runAsync() {
      this.plugin = 0;
      for (let e2 = 0; e2 < this.plugins.length; e2++) {
        let r2 = this.plugins[e2], n2 = this.runOnRoot(r2);
        if (Rt2(n2))
          try {
            await n2;
          } catch (i2) {
            throw this.handleError(i2);
          }
      }
      if (this.prepareVisitors(), this.hasListener) {
        let e2 = this.result.root;
        for (; !e2[me2]; ) {
          e2[me2] = true;
          let r2 = [Ho2(e2)];
          for (; r2.length > 0; ) {
            let n2 = this.visitTick(r2);
            if (Rt2(n2))
              try {
                await n2;
              } catch (i2) {
                let a2 = r2[r2.length - 1].node;
                throw this.handleError(i2, a2);
              }
          }
        }
        if (this.listeners.OnceExit)
          for (let [r2, n2] of this.listeners.OnceExit) {
            this.result.lastPlugin = r2;
            try {
              if (e2.type === "document") {
                let i2 = e2.nodes.map((a2) => n2(a2, this.helpers));
                await Promise.all(i2);
              } else
                await n2(e2, this.helpers);
            } catch (i2) {
              throw this.handleError(i2);
            }
          }
      }
      return this.processed = true, this.stringify();
    }
    runOnRoot(e2) {
      this.result.lastPlugin = e2;
      try {
        if (typeof e2 == "object" && e2.Once) {
          if (this.result.root.type === "document") {
            let r2 = this.result.root.nodes.map((n2) => e2.Once(n2, this.helpers));
            return Rt2(r2[0]) ? Promise.all(r2) : r2;
          }
          return e2.Once(this.result.root, this.helpers);
        } else if (typeof e2 == "function")
          return e2(this.result.root, this.result);
      } catch (r2) {
        throw this.handleError(r2);
      }
    }
    stringify() {
      if (this.error)
        throw this.error;
      if (this.stringified)
        return this.result;
      this.stringified = true, this.sync();
      let e2 = this.result.opts, r2 = Pd;
      e2.syntax && (r2 = e2.syntax.stringify), e2.stringifier && (r2 = e2.stringifier), r2.stringify && (r2 = r2.stringify);
      let i2 = new Td(r2, this.result.root, this.result.opts).generate();
      return this.result.css = i2[0], this.result.map = i2[1], this.result;
    }
    sync() {
      if (this.error)
        throw this.error;
      if (this.processed)
        return this.result;
      if (this.processed = true, this.processing)
        throw this.getAsyncError();
      for (let e2 of this.plugins) {
        let r2 = this.runOnRoot(e2);
        if (Rt2(r2))
          throw this.getAsyncError();
      }
      if (this.prepareVisitors(), this.hasListener) {
        let e2 = this.result.root;
        for (; !e2[me2]; )
          e2[me2] = true, this.walkSync(e2);
        if (this.listeners.OnceExit)
          if (e2.type === "document")
            for (let r2 of e2.nodes)
              this.visitSync(this.listeners.OnceExit, r2);
          else
            this.visitSync(this.listeners.OnceExit, e2);
      }
      return this.result;
    }
    then(e2, r2) {
      return this.async().then(e2, r2);
    }
    toString() {
      return this.css;
    }
    visitSync(e2, r2) {
      for (let [n2, i2] of e2) {
        this.result.lastPlugin = n2;
        let a2;
        try {
          a2 = i2(r2, this.helpers);
        } catch (s2) {
          throw this.handleError(s2, r2.proxyOf);
        }
        if (r2.type !== "root" && r2.type !== "document" && !r2.parent)
          return true;
        if (Rt2(a2))
          throw this.getAsyncError();
      }
    }
    visitTick(e2) {
      let r2 = e2[e2.length - 1], { node: n2, visitors: i2 } = r2;
      if (n2.type !== "root" && n2.type !== "document" && !n2.parent) {
        e2.pop();
        return;
      }
      if (i2.length > 0 && r2.visitorIndex < i2.length) {
        let [s2, o2] = i2[r2.visitorIndex];
        r2.visitorIndex += 1, r2.visitorIndex === i2.length && (r2.visitors = [], r2.visitorIndex = 0), this.result.lastPlugin = s2;
        try {
          return o2(n2.toProxy(), this.helpers);
        } catch (l2) {
          throw this.handleError(l2, n2);
        }
      }
      if (r2.iterator !== 0) {
        let s2 = r2.iterator, o2;
        for (; o2 = n2.nodes[n2.indexes[s2]]; )
          if (n2.indexes[s2] += 1, !o2[me2]) {
            o2[me2] = true, e2.push(Ho2(o2));
            return;
          }
        r2.iterator = 0, delete n2.indexes[s2];
      }
      let a2 = r2.events;
      for (; r2.eventIndex < a2.length; ) {
        let s2 = a2[r2.eventIndex];
        if (r2.eventIndex += 1, s2 === Xe2) {
          n2.nodes && n2.nodes.length && (n2[me2] = true, r2.iterator = n2.getIterator());
          return;
        } else if (this.listeners[s2]) {
          r2.visitors = this.listeners[s2];
          return;
        }
      }
      e2.pop();
    }
    walkSync(e2) {
      e2[me2] = true;
      let r2 = Qo2(e2);
      for (let n2 of r2)
        if (n2 === Xe2)
          e2.nodes && e2.each((i2) => {
            i2[me2] || this.walkSync(i2);
          });
        else {
          let i2 = this.listeners[n2];
          if (i2 && this.visitSync(i2, e2.toProxy()))
            return;
        }
    }
    warnings() {
      return this.sync().warnings();
    }
    get content() {
      return this.stringify().content;
    }
    get css() {
      return this.stringify().css;
    }
    get map() {
      return this.stringify().map;
    }
    get messages() {
      return this.sync().messages;
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      return this.sync().root;
    }
    get [Symbol.toStringTag]() {
      return "LazyResult";
    }
  };
  ge2.registerPostcss = (t2) => {
    yi = t2;
  };
  Jo2.exports = ge2;
  ge2.default = ge2;
  Md.registerLazyResult(ge2);
  Rd.registerLazyResult(ge2);
});
var Ko = S((Hb, Xo2) => {
  "use strict";
  var qd = li(), $d = yt(), Yb = ci(), Ud = $r(), jd = _r(), Dt2 = class {
    constructor(e2, r2, n2) {
      r2 = r2.toString(), this.stringified = false, this._processor = e2, this._css = r2, this._opts = n2, this._map = void 0;
      let i2, a2 = $d;
      this.result = new jd(this._processor, i2, this._opts), this.result.css = r2;
      let s2 = this;
      Object.defineProperty(this.result, "root", { get() {
        return s2.root;
      } });
      let o2 = new qd(a2, i2, this._opts, r2);
      if (o2.isMap()) {
        let [l2, u2] = o2.generate();
        l2 && (this.result.css = l2), u2 && (this.result.map = u2);
      }
    }
    async() {
      return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
    }
    catch(e2) {
      return this.async().catch(e2);
    }
    finally(e2) {
      return this.async().then(e2, e2);
    }
    sync() {
      if (this.error)
        throw this.error;
      return this.result;
    }
    then(e2, r2) {
      return this.async().then(e2, r2);
    }
    toString() {
      return this._css;
    }
    warnings() {
      return [];
    }
    get content() {
      return this.result.css;
    }
    get css() {
      return this.result.css;
    }
    get map() {
      return this.result.map;
    }
    get messages() {
      return [];
    }
    get opts() {
      return this.result.opts;
    }
    get processor() {
      return this.result.processor;
    }
    get root() {
      if (this._root)
        return this._root;
      let e2, r2 = Ud;
      try {
        e2 = r2(this._css, this._opts);
      } catch (n2) {
        this.error = n2;
      }
      if (this.error)
        throw this.error;
      return this._root = e2, e2;
    }
    get [Symbol.toStringTag]() {
      return "NoWorkResult";
    }
  };
  Xo2.exports = Dt2;
  Dt2.default = Dt2;
});
var el = S((Qb, Zo2) => {
  "use strict";
  var zd = Ko(), Vd = vi(), Wd = Ar(), Bd = Qe(), ze2 = class {
    constructor(e2 = []) {
      this.version = "8.4.31", this.plugins = this.normalize(e2);
    }
    normalize(e2) {
      let r2 = [];
      for (let n2 of e2)
        if (n2.postcss === true ? n2 = n2() : n2.postcss && (n2 = n2.postcss), typeof n2 == "object" && Array.isArray(n2.plugins))
          r2 = r2.concat(n2.plugins);
        else if (typeof n2 == "object" && n2.postcssPlugin)
          r2.push(n2);
        else if (typeof n2 == "function")
          r2.push(n2);
        else if (!(typeof n2 == "object" && (n2.parse || n2.stringify)))
          throw new Error(n2 + " is not a PostCSS plugin");
      return r2;
    }
    process(e2, r2 = {}) {
      return this.plugins.length === 0 && typeof r2.parser > "u" && typeof r2.stringifier > "u" && typeof r2.syntax > "u" ? new zd(this, e2, r2) : new Vd(this, e2, r2);
    }
    use(e2) {
      return this.plugins = this.plugins.concat(this.normalize([e2])), this;
    }
  };
  Zo2.exports = ze2;
  ze2.default = ze2;
  Bd.registerProcessor(ze2);
  Wd.registerProcessor(ze2);
});
var rl = S((Jb, tl) => {
  "use strict";
  var Gd = xt(), Yd = ri(), Hd = At(), Qd = Lr(), Jd = Et(), Xd = Qe(), Kd = Nr();
  function Mt2(t2, e2) {
    if (Array.isArray(t2))
      return t2.map((i2) => Mt2(i2));
    let { inputs: r2, ...n2 } = t2;
    if (r2) {
      e2 = [];
      for (let i2 of r2) {
        let a2 = { ...i2, __proto__: Jd.prototype };
        a2.map && (a2.map = { ...a2.map, __proto__: Yd.prototype }), e2.push(a2);
      }
    }
    if (n2.nodes && (n2.nodes = t2.nodes.map((i2) => Mt2(i2, e2))), n2.source) {
      let { inputId: i2, ...a2 } = n2.source;
      n2.source = a2, i2 != null && (n2.source.input = e2[i2]);
    }
    if (n2.type === "root")
      return new Xd(n2);
    if (n2.type === "decl")
      return new Gd(n2);
    if (n2.type === "rule")
      return new Kd(n2);
    if (n2.type === "comment")
      return new Hd(n2);
    if (n2.type === "atrule")
      return new Qd(n2);
    throw new Error("Unknown node type: " + t2.type);
  }
  tl.exports = Mt2;
  Mt2.default = Mt2;
});
var Ke = S((Xb, ul) => {
  "use strict";
  var Zd = br(), nl = xt(), eh = vi(), th = _e(), wi = el(), rh = yt(), nh = rl(), il = Ar(), ih = pi(), sl = At(), al = Lr(), sh = _r(), ah = Et(), oh = $r(), lh = hi(), ol = Nr(), ll = Qe(), uh = wt();
  function N2(...t2) {
    return t2.length === 1 && Array.isArray(t2[0]) && (t2 = t2[0]), new wi(t2);
  }
  N2.plugin = function(e2, r2) {
    let n2 = false;
    function i2(...s2) {
      console && console.warn && !n2 && (n2 = true, console.warn(e2 + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`), process.env.LANG && process.env.LANG.startsWith("cn") && console.warn(e2 + `: 里面 postcss.plugin 被弃用. 迁移指南:
https://www.w3ctech.com/topic/2226`));
      let o2 = r2(...s2);
      return o2.postcssPlugin = e2, o2.postcssVersion = new wi().version, o2;
    }
    let a2;
    return Object.defineProperty(i2, "postcss", { get() {
      return a2 || (a2 = i2()), a2;
    } }), i2.process = function(s2, o2, l2) {
      return N2([i2(l2)]).process(s2, o2);
    }, i2;
  };
  N2.stringify = rh;
  N2.parse = oh;
  N2.fromJSON = nh;
  N2.list = lh;
  N2.comment = (t2) => new sl(t2);
  N2.atRule = (t2) => new al(t2);
  N2.decl = (t2) => new nl(t2);
  N2.rule = (t2) => new ol(t2);
  N2.root = (t2) => new ll(t2);
  N2.document = (t2) => new il(t2);
  N2.CssSyntaxError = Zd;
  N2.Declaration = nl;
  N2.Container = th;
  N2.Processor = wi;
  N2.Document = il;
  N2.Comment = sl;
  N2.Warning = ih;
  N2.AtRule = al;
  N2.Result = sh;
  N2.Input = ah;
  N2.Rule = ol;
  N2.Root = ll;
  N2.Node = uh;
  eh.registerPostcss(N2);
  ul.exports = N2;
  N2.default = N2;
});
var jr = S((Ur2, fl) => {
  "use strict";
  Ur2.__esModule = true;
  Ur2.default = ph;
  function fh(t2) {
    for (var e2 = t2.toLowerCase(), r2 = "", n2 = false, i2 = 0; i2 < 6 && e2[i2] !== void 0; i2++) {
      var a2 = e2.charCodeAt(i2), s2 = a2 >= 97 && a2 <= 102 || a2 >= 48 && a2 <= 57;
      if (n2 = a2 === 32, !s2)
        break;
      r2 += e2[i2];
    }
    if (r2.length !== 0) {
      var o2 = parseInt(r2, 16), l2 = o2 >= 55296 && o2 <= 57343;
      return l2 || o2 === 0 || o2 > 1114111 ? ["�", r2.length + (n2 ? 1 : 0)] : [String.fromCodePoint(o2), r2.length + (n2 ? 1 : 0)];
    }
  }
  var ch = /\\/;
  function ph(t2) {
    var e2 = ch.test(t2);
    if (!e2)
      return t2;
    for (var r2 = "", n2 = 0; n2 < t2.length; n2++) {
      if (t2[n2] === "\\") {
        var i2 = fh(t2.slice(n2 + 1, n2 + 7));
        if (i2 !== void 0) {
          r2 += i2[0], n2 += i2[1];
          continue;
        }
        if (t2[n2 + 1] === "\\") {
          r2 += "\\", n2++;
          continue;
        }
        t2.length === n2 + 1 && (r2 += t2[n2]);
        continue;
      }
      r2 += t2[n2];
    }
    return r2;
  }
  fl.exports = Ur2.default;
});
var pl = S((zr2, cl) => {
  "use strict";
  zr2.__esModule = true;
  zr2.default = dh;
  function dh(t2) {
    for (var e2 = arguments.length, r2 = new Array(e2 > 1 ? e2 - 1 : 0), n2 = 1; n2 < e2; n2++)
      r2[n2 - 1] = arguments[n2];
    for (; r2.length > 0; ) {
      var i2 = r2.shift();
      if (!t2[i2])
        return;
      t2 = t2[i2];
    }
    return t2;
  }
  cl.exports = zr2.default;
});
var hl = S((Vr2, dl) => {
  "use strict";
  Vr2.__esModule = true;
  Vr2.default = hh;
  function hh(t2) {
    for (var e2 = arguments.length, r2 = new Array(e2 > 1 ? e2 - 1 : 0), n2 = 1; n2 < e2; n2++)
      r2[n2 - 1] = arguments[n2];
    for (; r2.length > 0; ) {
      var i2 = r2.shift();
      t2[i2] || (t2[i2] = {}), t2 = t2[i2];
    }
  }
  dl.exports = Vr2.default;
});
var gl = S((Wr2, ml) => {
  "use strict";
  Wr2.__esModule = true;
  Wr2.default = mh;
  function mh(t2) {
    for (var e2 = "", r2 = t2.indexOf("/*"), n2 = 0; r2 >= 0; ) {
      e2 = e2 + t2.slice(n2, r2);
      var i2 = t2.indexOf("*/", r2 + 2);
      if (i2 < 0)
        return e2;
      n2 = i2 + 2, r2 = t2.indexOf("/*", n2);
    }
    return e2 = e2 + t2.slice(n2), e2;
  }
  ml.exports = Wr2.default;
});
var Ft = S((ye) => {
  "use strict";
  ye.__esModule = true;
  ye.unesc = ye.stripComments = ye.getProp = ye.ensureObject = void 0;
  var gh = Br2(jr());
  ye.unesc = gh.default;
  var yh = Br2(pl());
  ye.getProp = yh.default;
  var vh = Br2(hl());
  ye.ensureObject = vh.default;
  var wh = Br2(gl());
  ye.stripComments = wh.default;
  function Br2(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
});
var Oe = S((Lt2, wl) => {
  "use strict";
  Lt2.__esModule = true;
  Lt2.default = void 0;
  var yl = Ft();
  function vl(t2, e2) {
    for (var r2 = 0; r2 < e2.length; r2++) {
      var n2 = e2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
    }
  }
  function bh(t2, e2, r2) {
    return e2 && vl(t2.prototype, e2), r2 && vl(t2, r2), Object.defineProperty(t2, "prototype", { writable: false }), t2;
  }
  var xh = function t2(e2, r2) {
    if (typeof e2 != "object" || e2 === null)
      return e2;
    var n2 = new e2.constructor();
    for (var i2 in e2)
      if (!!e2.hasOwnProperty(i2)) {
        var a2 = e2[i2], s2 = typeof a2;
        i2 === "parent" && s2 === "object" ? r2 && (n2[i2] = r2) : a2 instanceof Array ? n2[i2] = a2.map(function(o2) {
          return t2(o2, n2);
        }) : n2[i2] = t2(a2, n2);
      }
    return n2;
  }, Sh = function() {
    function t2(r2) {
      r2 === void 0 && (r2 = {}), Object.assign(this, r2), this.spaces = this.spaces || {}, this.spaces.before = this.spaces.before || "", this.spaces.after = this.spaces.after || "";
    }
    var e2 = t2.prototype;
    return e2.remove = function() {
      return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
    }, e2.replaceWith = function() {
      if (this.parent) {
        for (var n2 in arguments)
          this.parent.insertBefore(this, arguments[n2]);
        this.remove();
      }
      return this;
    }, e2.next = function() {
      return this.parent.at(this.parent.index(this) + 1);
    }, e2.prev = function() {
      return this.parent.at(this.parent.index(this) - 1);
    }, e2.clone = function(n2) {
      n2 === void 0 && (n2 = {});
      var i2 = xh(this);
      for (var a2 in n2)
        i2[a2] = n2[a2];
      return i2;
    }, e2.appendToPropertyAndEscape = function(n2, i2, a2) {
      this.raws || (this.raws = {});
      var s2 = this[n2], o2 = this.raws[n2];
      this[n2] = s2 + i2, o2 || a2 !== i2 ? this.raws[n2] = (o2 || s2) + a2 : delete this.raws[n2];
    }, e2.setPropertyAndEscape = function(n2, i2, a2) {
      this.raws || (this.raws = {}), this[n2] = i2, this.raws[n2] = a2;
    }, e2.setPropertyWithoutEscape = function(n2, i2) {
      this[n2] = i2, this.raws && delete this.raws[n2];
    }, e2.isAtPosition = function(n2, i2) {
      if (this.source && this.source.start && this.source.end)
        return !(this.source.start.line > n2 || this.source.end.line < n2 || this.source.start.line === n2 && this.source.start.column > i2 || this.source.end.line === n2 && this.source.end.column < i2);
    }, e2.stringifyProperty = function(n2) {
      return this.raws && this.raws[n2] || this[n2];
    }, e2.valueToString = function() {
      return String(this.stringifyProperty("value"));
    }, e2.toString = function() {
      return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
    }, bh(t2, [{ key: "rawSpaceBefore", get: function() {
      var n2 = this.raws && this.raws.spaces && this.raws.spaces.before;
      return n2 === void 0 && (n2 = this.spaces && this.spaces.before), n2 || "";
    }, set: function(n2) {
      (0, yl.ensureObject)(this, "raws", "spaces"), this.raws.spaces.before = n2;
    } }, { key: "rawSpaceAfter", get: function() {
      var n2 = this.raws && this.raws.spaces && this.raws.spaces.after;
      return n2 === void 0 && (n2 = this.spaces.after), n2 || "";
    }, set: function(n2) {
      (0, yl.ensureObject)(this, "raws", "spaces"), this.raws.spaces.after = n2;
    } }]), t2;
  }();
  Lt2.default = Sh;
  wl.exports = Lt2.default;
});
var J = S((U2) => {
  "use strict";
  U2.__esModule = true;
  U2.UNIVERSAL = U2.TAG = U2.STRING = U2.SELECTOR = U2.ROOT = U2.PSEUDO = U2.NESTING = U2.ID = U2.COMMENT = U2.COMBINATOR = U2.CLASS = U2.ATTRIBUTE = void 0;
  var kh = "tag";
  U2.TAG = kh;
  var Oh = "string";
  U2.STRING = Oh;
  var Eh = "selector";
  U2.SELECTOR = Eh;
  var Ch = "root";
  U2.ROOT = Ch;
  var Ah = "pseudo";
  U2.PSEUDO = Ah;
  var _h = "nesting";
  U2.NESTING = _h;
  var Th = "id";
  U2.ID = Th;
  var Ph = "comment";
  U2.COMMENT = Ph;
  var Ih = "combinator";
  U2.COMBINATOR = Ih;
  var Rh = "class";
  U2.CLASS = Rh;
  var Dh = "attribute";
  U2.ATTRIBUTE = Dh;
  var Mh = "universal";
  U2.UNIVERSAL = Mh;
});
var Gr = S((Nt2, kl) => {
  "use strict";
  Nt2.__esModule = true;
  Nt2.default = void 0;
  var Fh = Nh(Oe()), Ee2 = Lh(J());
  function Sl(t2) {
    if (typeof WeakMap != "function")
      return null;
    var e2 = /* @__PURE__ */ new WeakMap(), r2 = /* @__PURE__ */ new WeakMap();
    return (Sl = function(i2) {
      return i2 ? r2 : e2;
    })(t2);
  }
  function Lh(t2, e2) {
    if (!e2 && t2 && t2.__esModule)
      return t2;
    if (t2 === null || typeof t2 != "object" && typeof t2 != "function")
      return { default: t2 };
    var r2 = Sl(e2);
    if (r2 && r2.has(t2))
      return r2.get(t2);
    var n2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a2 in t2)
      if (a2 !== "default" && Object.prototype.hasOwnProperty.call(t2, a2)) {
        var s2 = i2 ? Object.getOwnPropertyDescriptor(t2, a2) : null;
        s2 && (s2.get || s2.set) ? Object.defineProperty(n2, a2, s2) : n2[a2] = t2[a2];
      }
    return n2.default = t2, r2 && r2.set(t2, n2), n2;
  }
  function Nh(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  function qh(t2, e2) {
    var r2 = typeof Symbol < "u" && t2[Symbol.iterator] || t2["@@iterator"];
    if (r2)
      return (r2 = r2.call(t2)).next.bind(r2);
    if (Array.isArray(t2) || (r2 = $h(t2)) || e2 && t2 && typeof t2.length == "number") {
      r2 && (t2 = r2);
      var n2 = 0;
      return function() {
        return n2 >= t2.length ? { done: true } : { done: false, value: t2[n2++] };
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function $h(t2, e2) {
    if (!!t2) {
      if (typeof t2 == "string")
        return bl(t2, e2);
      var r2 = Object.prototype.toString.call(t2).slice(8, -1);
      if (r2 === "Object" && t2.constructor && (r2 = t2.constructor.name), r2 === "Map" || r2 === "Set")
        return Array.from(t2);
      if (r2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
        return bl(t2, e2);
    }
  }
  function bl(t2, e2) {
    (e2 == null || e2 > t2.length) && (e2 = t2.length);
    for (var r2 = 0, n2 = new Array(e2); r2 < e2; r2++)
      n2[r2] = t2[r2];
    return n2;
  }
  function xl(t2, e2) {
    for (var r2 = 0; r2 < e2.length; r2++) {
      var n2 = e2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
    }
  }
  function Uh(t2, e2, r2) {
    return e2 && xl(t2.prototype, e2), r2 && xl(t2, r2), Object.defineProperty(t2, "prototype", { writable: false }), t2;
  }
  function jh(t2, e2) {
    t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, bi(t2, e2);
  }
  function bi(t2, e2) {
    return bi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i2) {
      return n2.__proto__ = i2, n2;
    }, bi(t2, e2);
  }
  var zh = function(t2) {
    jh(e2, t2);
    function e2(n2) {
      var i2;
      return i2 = t2.call(this, n2) || this, i2.nodes || (i2.nodes = []), i2;
    }
    var r2 = e2.prototype;
    return r2.append = function(i2) {
      return i2.parent = this, this.nodes.push(i2), this;
    }, r2.prepend = function(i2) {
      return i2.parent = this, this.nodes.unshift(i2), this;
    }, r2.at = function(i2) {
      return this.nodes[i2];
    }, r2.index = function(i2) {
      return typeof i2 == "number" ? i2 : this.nodes.indexOf(i2);
    }, r2.removeChild = function(i2) {
      i2 = this.index(i2), this.at(i2).parent = void 0, this.nodes.splice(i2, 1);
      var a2;
      for (var s2 in this.indexes)
        a2 = this.indexes[s2], a2 >= i2 && (this.indexes[s2] = a2 - 1);
      return this;
    }, r2.removeAll = function() {
      for (var i2 = qh(this.nodes), a2; !(a2 = i2()).done; ) {
        var s2 = a2.value;
        s2.parent = void 0;
      }
      return this.nodes = [], this;
    }, r2.empty = function() {
      return this.removeAll();
    }, r2.insertAfter = function(i2, a2) {
      a2.parent = this;
      var s2 = this.index(i2);
      this.nodes.splice(s2 + 1, 0, a2), a2.parent = this;
      var o2;
      for (var l2 in this.indexes)
        o2 = this.indexes[l2], s2 <= o2 && (this.indexes[l2] = o2 + 1);
      return this;
    }, r2.insertBefore = function(i2, a2) {
      a2.parent = this;
      var s2 = this.index(i2);
      this.nodes.splice(s2, 0, a2), a2.parent = this;
      var o2;
      for (var l2 in this.indexes)
        o2 = this.indexes[l2], o2 <= s2 && (this.indexes[l2] = o2 + 1);
      return this;
    }, r2._findChildAtPosition = function(i2, a2) {
      var s2 = void 0;
      return this.each(function(o2) {
        if (o2.atPosition) {
          var l2 = o2.atPosition(i2, a2);
          if (l2)
            return s2 = l2, false;
        } else if (o2.isAtPosition(i2, a2))
          return s2 = o2, false;
      }), s2;
    }, r2.atPosition = function(i2, a2) {
      if (this.isAtPosition(i2, a2))
        return this._findChildAtPosition(i2, a2) || this;
    }, r2._inferEndPosition = function() {
      this.last && this.last.source && this.last.source.end && (this.source = this.source || {}, this.source.end = this.source.end || {}, Object.assign(this.source.end, this.last.source.end));
    }, r2.each = function(i2) {
      this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
      var a2 = this.lastEach;
      if (this.indexes[a2] = 0, !!this.length) {
        for (var s2, o2; this.indexes[a2] < this.length && (s2 = this.indexes[a2], o2 = i2(this.at(s2), s2), o2 !== false); )
          this.indexes[a2] += 1;
        if (delete this.indexes[a2], o2 === false)
          return false;
      }
    }, r2.walk = function(i2) {
      return this.each(function(a2, s2) {
        var o2 = i2(a2, s2);
        if (o2 !== false && a2.length && (o2 = a2.walk(i2)), o2 === false)
          return false;
      });
    }, r2.walkAttributes = function(i2) {
      var a2 = this;
      return this.walk(function(s2) {
        if (s2.type === Ee2.ATTRIBUTE)
          return i2.call(a2, s2);
      });
    }, r2.walkClasses = function(i2) {
      var a2 = this;
      return this.walk(function(s2) {
        if (s2.type === Ee2.CLASS)
          return i2.call(a2, s2);
      });
    }, r2.walkCombinators = function(i2) {
      var a2 = this;
      return this.walk(function(s2) {
        if (s2.type === Ee2.COMBINATOR)
          return i2.call(a2, s2);
      });
    }, r2.walkComments = function(i2) {
      var a2 = this;
      return this.walk(function(s2) {
        if (s2.type === Ee2.COMMENT)
          return i2.call(a2, s2);
      });
    }, r2.walkIds = function(i2) {
      var a2 = this;
      return this.walk(function(s2) {
        if (s2.type === Ee2.ID)
          return i2.call(a2, s2);
      });
    }, r2.walkNesting = function(i2) {
      var a2 = this;
      return this.walk(function(s2) {
        if (s2.type === Ee2.NESTING)
          return i2.call(a2, s2);
      });
    }, r2.walkPseudos = function(i2) {
      var a2 = this;
      return this.walk(function(s2) {
        if (s2.type === Ee2.PSEUDO)
          return i2.call(a2, s2);
      });
    }, r2.walkTags = function(i2) {
      var a2 = this;
      return this.walk(function(s2) {
        if (s2.type === Ee2.TAG)
          return i2.call(a2, s2);
      });
    }, r2.walkUniversals = function(i2) {
      var a2 = this;
      return this.walk(function(s2) {
        if (s2.type === Ee2.UNIVERSAL)
          return i2.call(a2, s2);
      });
    }, r2.split = function(i2) {
      var a2 = this, s2 = [];
      return this.reduce(function(o2, l2, u2) {
        var f2 = i2.call(a2, l2);
        return s2.push(l2), f2 ? (o2.push(s2), s2 = []) : u2 === a2.length - 1 && o2.push(s2), o2;
      }, []);
    }, r2.map = function(i2) {
      return this.nodes.map(i2);
    }, r2.reduce = function(i2, a2) {
      return this.nodes.reduce(i2, a2);
    }, r2.every = function(i2) {
      return this.nodes.every(i2);
    }, r2.some = function(i2) {
      return this.nodes.some(i2);
    }, r2.filter = function(i2) {
      return this.nodes.filter(i2);
    }, r2.sort = function(i2) {
      return this.nodes.sort(i2);
    }, r2.toString = function() {
      return this.map(String).join("");
    }, Uh(e2, [{ key: "first", get: function() {
      return this.at(0);
    } }, { key: "last", get: function() {
      return this.at(this.length - 1);
    } }, { key: "length", get: function() {
      return this.nodes.length;
    } }]), e2;
  }(Fh.default);
  Nt2.default = zh;
  kl.exports = Nt2.default;
});
var Si = S((qt2, El) => {
  "use strict";
  qt2.__esModule = true;
  qt2.default = void 0;
  var Vh = Bh(Gr()), Wh = J();
  function Bh(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  function Ol(t2, e2) {
    for (var r2 = 0; r2 < e2.length; r2++) {
      var n2 = e2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
    }
  }
  function Gh(t2, e2, r2) {
    return e2 && Ol(t2.prototype, e2), r2 && Ol(t2, r2), Object.defineProperty(t2, "prototype", { writable: false }), t2;
  }
  function Yh(t2, e2) {
    t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, xi(t2, e2);
  }
  function xi(t2, e2) {
    return xi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i2) {
      return n2.__proto__ = i2, n2;
    }, xi(t2, e2);
  }
  var Hh = function(t2) {
    Yh(e2, t2);
    function e2(n2) {
      var i2;
      return i2 = t2.call(this, n2) || this, i2.type = Wh.ROOT, i2;
    }
    var r2 = e2.prototype;
    return r2.toString = function() {
      var i2 = this.reduce(function(a2, s2) {
        return a2.push(String(s2)), a2;
      }, []).join(",");
      return this.trailingComma ? i2 + "," : i2;
    }, r2.error = function(i2, a2) {
      return this._error ? this._error(i2, a2) : new Error(i2);
    }, Gh(e2, [{ key: "errorGenerator", set: function(i2) {
      this._error = i2;
    } }]), e2;
  }(Vh.default);
  qt2.default = Hh;
  El.exports = qt2.default;
});
var Oi = S(($t2, Cl) => {
  "use strict";
  $t2.__esModule = true;
  $t2.default = void 0;
  var Qh = Xh(Gr()), Jh = J();
  function Xh(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  function Kh(t2, e2) {
    t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, ki(t2, e2);
  }
  function ki(t2, e2) {
    return ki = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i2) {
      return n2.__proto__ = i2, n2;
    }, ki(t2, e2);
  }
  var Zh = function(t2) {
    Kh(e2, t2);
    function e2(r2) {
      var n2;
      return n2 = t2.call(this, r2) || this, n2.type = Jh.SELECTOR, n2;
    }
    return e2;
  }(Qh.default);
  $t2.default = Zh;
  Cl.exports = $t2.default;
});
var Yr = S((Ex, Al) => {
  "use strict";
  var em = {}, tm = em.hasOwnProperty, rm = function(e2, r2) {
    if (!e2)
      return r2;
    var n2 = {};
    for (var i2 in r2)
      n2[i2] = tm.call(e2, i2) ? e2[i2] : r2[i2];
    return n2;
  }, nm = /[ -,\.\/:-@\[-\^`\{-~]/, im = /[ -,\.\/:-@\[\]\^`\{-~]/, sm = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g, Ei = function t2(e2, r2) {
    r2 = rm(r2, t2.options), r2.quotes != "single" && r2.quotes != "double" && (r2.quotes = "single");
    for (var n2 = r2.quotes == "double" ? '"' : "'", i2 = r2.isIdentifier, a2 = e2.charAt(0), s2 = "", o2 = 0, l2 = e2.length; o2 < l2; ) {
      var u2 = e2.charAt(o2++), f2 = u2.charCodeAt(), p2 = void 0;
      if (f2 < 32 || f2 > 126) {
        if (f2 >= 55296 && f2 <= 56319 && o2 < l2) {
          var c2 = e2.charCodeAt(o2++);
          (c2 & 64512) == 56320 ? f2 = ((f2 & 1023) << 10) + (c2 & 1023) + 65536 : o2--;
        }
        p2 = "\\" + f2.toString(16).toUpperCase() + " ";
      } else
        r2.escapeEverything ? nm.test(u2) ? p2 = "\\" + u2 : p2 = "\\" + f2.toString(16).toUpperCase() + " " : /[\t\n\f\r\x0B]/.test(u2) ? p2 = "\\" + f2.toString(16).toUpperCase() + " " : u2 == "\\" || !i2 && (u2 == '"' && n2 == u2 || u2 == "'" && n2 == u2) || i2 && im.test(u2) ? p2 = "\\" + u2 : p2 = u2;
      s2 += p2;
    }
    return i2 && (/^-[-\d]/.test(s2) ? s2 = "\\-" + s2.slice(1) : /\d/.test(a2) && (s2 = "\\3" + a2 + " " + s2.slice(1))), s2 = s2.replace(sm, function(d2, h2, y3) {
      return h2 && h2.length % 2 ? d2 : (h2 || "") + y3;
    }), !i2 && r2.wrap ? n2 + s2 + n2 : s2;
  };
  Ei.options = { escapeEverything: false, isIdentifier: false, quotes: "single", wrap: false };
  Ei.version = "3.0.0";
  Al.exports = Ei;
});
var Ai = S((Ut2, Pl) => {
  "use strict";
  Ut2.__esModule = true;
  Ut2.default = void 0;
  var am = Tl(Yr()), om = Ft(), lm = Tl(Oe()), um = J();
  function Tl(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  function _l(t2, e2) {
    for (var r2 = 0; r2 < e2.length; r2++) {
      var n2 = e2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
    }
  }
  function fm(t2, e2, r2) {
    return e2 && _l(t2.prototype, e2), r2 && _l(t2, r2), Object.defineProperty(t2, "prototype", { writable: false }), t2;
  }
  function cm(t2, e2) {
    t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, Ci(t2, e2);
  }
  function Ci(t2, e2) {
    return Ci = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i2) {
      return n2.__proto__ = i2, n2;
    }, Ci(t2, e2);
  }
  var pm = function(t2) {
    cm(e2, t2);
    function e2(n2) {
      var i2;
      return i2 = t2.call(this, n2) || this, i2.type = um.CLASS, i2._constructed = true, i2;
    }
    var r2 = e2.prototype;
    return r2.valueToString = function() {
      return "." + t2.prototype.valueToString.call(this);
    }, fm(e2, [{ key: "value", get: function() {
      return this._value;
    }, set: function(i2) {
      if (this._constructed) {
        var a2 = (0, am.default)(i2, { isIdentifier: true });
        a2 !== i2 ? ((0, om.ensureObject)(this, "raws"), this.raws.value = a2) : this.raws && delete this.raws.value;
      }
      this._value = i2;
    } }]), e2;
  }(lm.default);
  Ut2.default = pm;
  Pl.exports = Ut2.default;
});
var Ti = S((jt2, Il) => {
  "use strict";
  jt2.__esModule = true;
  jt2.default = void 0;
  var dm = mm(Oe()), hm = J();
  function mm(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  function gm(t2, e2) {
    t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, _i(t2, e2);
  }
  function _i(t2, e2) {
    return _i = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i2) {
      return n2.__proto__ = i2, n2;
    }, _i(t2, e2);
  }
  var ym = function(t2) {
    gm(e2, t2);
    function e2(r2) {
      var n2;
      return n2 = t2.call(this, r2) || this, n2.type = hm.COMMENT, n2;
    }
    return e2;
  }(dm.default);
  jt2.default = ym;
  Il.exports = jt2.default;
});
var Ii = S((zt2, Rl) => {
  "use strict";
  zt2.__esModule = true;
  zt2.default = void 0;
  var vm = bm(Oe()), wm = J();
  function bm(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  function xm(t2, e2) {
    t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, Pi(t2, e2);
  }
  function Pi(t2, e2) {
    return Pi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i2) {
      return n2.__proto__ = i2, n2;
    }, Pi(t2, e2);
  }
  var Sm = function(t2) {
    xm(e2, t2);
    function e2(n2) {
      var i2;
      return i2 = t2.call(this, n2) || this, i2.type = wm.ID, i2;
    }
    var r2 = e2.prototype;
    return r2.valueToString = function() {
      return "#" + t2.prototype.valueToString.call(this);
    }, e2;
  }(vm.default);
  zt2.default = Sm;
  Rl.exports = zt2.default;
});
var Hr = S((Vt2, Fl) => {
  "use strict";
  Vt2.__esModule = true;
  Vt2.default = void 0;
  var km = Ml(Yr()), Om = Ft(), Em = Ml(Oe());
  function Ml(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  function Dl(t2, e2) {
    for (var r2 = 0; r2 < e2.length; r2++) {
      var n2 = e2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
    }
  }
  function Cm(t2, e2, r2) {
    return e2 && Dl(t2.prototype, e2), r2 && Dl(t2, r2), Object.defineProperty(t2, "prototype", { writable: false }), t2;
  }
  function Am(t2, e2) {
    t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, Ri(t2, e2);
  }
  function Ri(t2, e2) {
    return Ri = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i2) {
      return n2.__proto__ = i2, n2;
    }, Ri(t2, e2);
  }
  var _m = function(t2) {
    Am(e2, t2);
    function e2() {
      return t2.apply(this, arguments) || this;
    }
    var r2 = e2.prototype;
    return r2.qualifiedName = function(i2) {
      return this.namespace ? this.namespaceString + "|" + i2 : i2;
    }, r2.valueToString = function() {
      return this.qualifiedName(t2.prototype.valueToString.call(this));
    }, Cm(e2, [{ key: "namespace", get: function() {
      return this._namespace;
    }, set: function(i2) {
      if (i2 === true || i2 === "*" || i2 === "&") {
        this._namespace = i2, this.raws && delete this.raws.namespace;
        return;
      }
      var a2 = (0, km.default)(i2, { isIdentifier: true });
      this._namespace = i2, a2 !== i2 ? ((0, Om.ensureObject)(this, "raws"), this.raws.namespace = a2) : this.raws && delete this.raws.namespace;
    } }, { key: "ns", get: function() {
      return this._namespace;
    }, set: function(i2) {
      this.namespace = i2;
    } }, { key: "namespaceString", get: function() {
      if (this.namespace) {
        var i2 = this.stringifyProperty("namespace");
        return i2 === true ? "" : i2;
      } else
        return "";
    } }]), e2;
  }(Em.default);
  Vt2.default = _m;
  Fl.exports = Vt2.default;
});
var Mi = S((Wt2, Ll) => {
  "use strict";
  Wt2.__esModule = true;
  Wt2.default = void 0;
  var Tm = Im(Hr()), Pm = J();
  function Im(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  function Rm(t2, e2) {
    t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, Di2(t2, e2);
  }
  function Di2(t2, e2) {
    return Di2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i2) {
      return n2.__proto__ = i2, n2;
    }, Di2(t2, e2);
  }
  var Dm = function(t2) {
    Rm(e2, t2);
    function e2(r2) {
      var n2;
      return n2 = t2.call(this, r2) || this, n2.type = Pm.TAG, n2;
    }
    return e2;
  }(Tm.default);
  Wt2.default = Dm;
  Ll.exports = Wt2.default;
});
var Li = S((Bt2, Nl) => {
  "use strict";
  Bt2.__esModule = true;
  Bt2.default = void 0;
  var Mm = Lm(Oe()), Fm = J();
  function Lm(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  function Nm(t2, e2) {
    t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, Fi(t2, e2);
  }
  function Fi(t2, e2) {
    return Fi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i2) {
      return n2.__proto__ = i2, n2;
    }, Fi(t2, e2);
  }
  var qm = function(t2) {
    Nm(e2, t2);
    function e2(r2) {
      var n2;
      return n2 = t2.call(this, r2) || this, n2.type = Fm.STRING, n2;
    }
    return e2;
  }(Mm.default);
  Bt2.default = qm;
  Nl.exports = Bt2.default;
});
var qi = S((Gt2, ql) => {
  "use strict";
  Gt2.__esModule = true;
  Gt2.default = void 0;
  var $m = jm(Gr()), Um = J();
  function jm(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  function zm(t2, e2) {
    t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, Ni(t2, e2);
  }
  function Ni(t2, e2) {
    return Ni = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i2) {
      return n2.__proto__ = i2, n2;
    }, Ni(t2, e2);
  }
  var Vm = function(t2) {
    zm(e2, t2);
    function e2(n2) {
      var i2;
      return i2 = t2.call(this, n2) || this, i2.type = Um.PSEUDO, i2;
    }
    var r2 = e2.prototype;
    return r2.toString = function() {
      var i2 = this.length ? "(" + this.map(String).join(",") + ")" : "";
      return [this.rawSpaceBefore, this.stringifyProperty("value"), i2, this.rawSpaceAfter].join("");
    }, e2;
  }($m.default);
  Gt2.default = Vm;
  ql.exports = Gt2.default;
});
var Ul = S((Cx, $l) => {
  $l.exports = Wm;
  function Wm(t2, e2) {
    if ($i("noDeprecation"))
      return t2;
    var r2 = false;
    function n2() {
      if (!r2) {
        if ($i("throwDeprecation"))
          throw new Error(e2);
        $i("traceDeprecation") ? console.trace(e2) : console.warn(e2), r2 = true;
      }
      return t2.apply(this, arguments);
    }
    return n2;
  }
  function $i(t2) {
    try {
      if (!global.localStorage)
        return false;
    } catch {
      return false;
    }
    var e2 = global.localStorage[t2];
    return e2 == null ? false : String(e2).toLowerCase() === "true";
  }
});
var Bi = S((Qt2) => {
  "use strict";
  Qt2.__esModule = true;
  Qt2.default = void 0;
  Qt2.unescapeValue = Wi;
  var Yt2 = Vi(Yr()), Bm = Vi(jr()), Gm = Vi(Hr()), Ym = J(), Ui;
  function Vi(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  function jl(t2, e2) {
    for (var r2 = 0; r2 < e2.length; r2++) {
      var n2 = e2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
    }
  }
  function Hm(t2, e2, r2) {
    return e2 && jl(t2.prototype, e2), r2 && jl(t2, r2), Object.defineProperty(t2, "prototype", { writable: false }), t2;
  }
  function Qm(t2, e2) {
    t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, zi(t2, e2);
  }
  function zi(t2, e2) {
    return zi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i2) {
      return n2.__proto__ = i2, n2;
    }, zi(t2, e2);
  }
  var Ht2 = Ul(), Jm = /^('|")([^]*)\1$/, Xm = Ht2(function() {
  }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead."), Km = Ht2(function() {
  }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead."), Zm = Ht2(function() {
  }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
  function Wi(t2) {
    var e2 = false, r2 = null, n2 = t2, i2 = n2.match(Jm);
    return i2 && (r2 = i2[1], n2 = i2[2]), n2 = (0, Bm.default)(n2), n2 !== t2 && (e2 = true), { deprecatedUsage: e2, unescaped: n2, quoteMark: r2 };
  }
  function eg(t2) {
    if (t2.quoteMark !== void 0 || t2.value === void 0)
      return t2;
    Zm();
    var e2 = Wi(t2.value), r2 = e2.quoteMark, n2 = e2.unescaped;
    return t2.raws || (t2.raws = {}), t2.raws.value === void 0 && (t2.raws.value = t2.value), t2.value = n2, t2.quoteMark = r2, t2;
  }
  var Qr2 = function(t2) {
    Qm(e2, t2);
    function e2(n2) {
      var i2;
      return n2 === void 0 && (n2 = {}), i2 = t2.call(this, eg(n2)) || this, i2.type = Ym.ATTRIBUTE, i2.raws = i2.raws || {}, Object.defineProperty(i2.raws, "unquoted", { get: Ht2(function() {
        return i2.value;
      }, "attr.raws.unquoted is deprecated. Call attr.value instead."), set: Ht2(function() {
        return i2.value;
      }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.") }), i2._constructed = true, i2;
    }
    var r2 = e2.prototype;
    return r2.getQuotedValue = function(i2) {
      i2 === void 0 && (i2 = {});
      var a2 = this._determineQuoteMark(i2), s2 = ji[a2], o2 = (0, Yt2.default)(this._value, s2);
      return o2;
    }, r2._determineQuoteMark = function(i2) {
      return i2.smart ? this.smartQuoteMark(i2) : this.preferredQuoteMark(i2);
    }, r2.setValue = function(i2, a2) {
      a2 === void 0 && (a2 = {}), this._value = i2, this._quoteMark = this._determineQuoteMark(a2), this._syncRawValue();
    }, r2.smartQuoteMark = function(i2) {
      var a2 = this.value, s2 = a2.replace(/[^']/g, "").length, o2 = a2.replace(/[^"]/g, "").length;
      if (s2 + o2 === 0) {
        var l2 = (0, Yt2.default)(a2, { isIdentifier: true });
        if (l2 === a2)
          return e2.NO_QUOTE;
        var u2 = this.preferredQuoteMark(i2);
        if (u2 === e2.NO_QUOTE) {
          var f2 = this.quoteMark || i2.quoteMark || e2.DOUBLE_QUOTE, p2 = ji[f2], c2 = (0, Yt2.default)(a2, p2);
          if (c2.length < l2.length)
            return f2;
        }
        return u2;
      } else
        return o2 === s2 ? this.preferredQuoteMark(i2) : o2 < s2 ? e2.DOUBLE_QUOTE : e2.SINGLE_QUOTE;
    }, r2.preferredQuoteMark = function(i2) {
      var a2 = i2.preferCurrentQuoteMark ? this.quoteMark : i2.quoteMark;
      return a2 === void 0 && (a2 = i2.preferCurrentQuoteMark ? i2.quoteMark : this.quoteMark), a2 === void 0 && (a2 = e2.DOUBLE_QUOTE), a2;
    }, r2._syncRawValue = function() {
      var i2 = (0, Yt2.default)(this._value, ji[this.quoteMark]);
      i2 === this._value ? this.raws && delete this.raws.value : this.raws.value = i2;
    }, r2._handleEscapes = function(i2, a2) {
      if (this._constructed) {
        var s2 = (0, Yt2.default)(a2, { isIdentifier: true });
        s2 !== a2 ? this.raws[i2] = s2 : delete this.raws[i2];
      }
    }, r2._spacesFor = function(i2) {
      var a2 = { before: "", after: "" }, s2 = this.spaces[i2] || {}, o2 = this.raws.spaces && this.raws.spaces[i2] || {};
      return Object.assign(a2, s2, o2);
    }, r2._stringFor = function(i2, a2, s2) {
      a2 === void 0 && (a2 = i2), s2 === void 0 && (s2 = zl);
      var o2 = this._spacesFor(a2);
      return s2(this.stringifyProperty(i2), o2);
    }, r2.offsetOf = function(i2) {
      var a2 = 1, s2 = this._spacesFor("attribute");
      if (a2 += s2.before.length, i2 === "namespace" || i2 === "ns")
        return this.namespace ? a2 : -1;
      if (i2 === "attributeNS" || (a2 += this.namespaceString.length, this.namespace && (a2 += 1), i2 === "attribute"))
        return a2;
      a2 += this.stringifyProperty("attribute").length, a2 += s2.after.length;
      var o2 = this._spacesFor("operator");
      a2 += o2.before.length;
      var l2 = this.stringifyProperty("operator");
      if (i2 === "operator")
        return l2 ? a2 : -1;
      a2 += l2.length, a2 += o2.after.length;
      var u2 = this._spacesFor("value");
      a2 += u2.before.length;
      var f2 = this.stringifyProperty("value");
      if (i2 === "value")
        return f2 ? a2 : -1;
      a2 += f2.length, a2 += u2.after.length;
      var p2 = this._spacesFor("insensitive");
      return a2 += p2.before.length, i2 === "insensitive" && this.insensitive ? a2 : -1;
    }, r2.toString = function() {
      var i2 = this, a2 = [this.rawSpaceBefore, "["];
      return a2.push(this._stringFor("qualifiedAttribute", "attribute")), this.operator && (this.value || this.value === "") && (a2.push(this._stringFor("operator")), a2.push(this._stringFor("value")), a2.push(this._stringFor("insensitiveFlag", "insensitive", function(s2, o2) {
        return s2.length > 0 && !i2.quoted && o2.before.length === 0 && !(i2.spaces.value && i2.spaces.value.after) && (o2.before = " "), zl(s2, o2);
      }))), a2.push("]"), a2.push(this.rawSpaceAfter), a2.join("");
    }, Hm(e2, [{ key: "quoted", get: function() {
      var i2 = this.quoteMark;
      return i2 === "'" || i2 === '"';
    }, set: function(i2) {
      Km();
    } }, { key: "quoteMark", get: function() {
      return this._quoteMark;
    }, set: function(i2) {
      if (!this._constructed) {
        this._quoteMark = i2;
        return;
      }
      this._quoteMark !== i2 && (this._quoteMark = i2, this._syncRawValue());
    } }, { key: "qualifiedAttribute", get: function() {
      return this.qualifiedName(this.raws.attribute || this.attribute);
    } }, { key: "insensitiveFlag", get: function() {
      return this.insensitive ? "i" : "";
    } }, { key: "value", get: function() {
      return this._value;
    }, set: function(i2) {
      if (this._constructed) {
        var a2 = Wi(i2), s2 = a2.deprecatedUsage, o2 = a2.unescaped, l2 = a2.quoteMark;
        if (s2 && Xm(), o2 === this._value && l2 === this._quoteMark)
          return;
        this._value = o2, this._quoteMark = l2, this._syncRawValue();
      } else
        this._value = i2;
    } }, { key: "insensitive", get: function() {
      return this._insensitive;
    }, set: function(i2) {
      i2 || (this._insensitive = false, this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i") && (this.raws.insensitiveFlag = void 0)), this._insensitive = i2;
    } }, { key: "attribute", get: function() {
      return this._attribute;
    }, set: function(i2) {
      this._handleEscapes("attribute", i2), this._attribute = i2;
    } }]), e2;
  }(Gm.default);
  Qt2.default = Qr2;
  Qr2.NO_QUOTE = null;
  Qr2.SINGLE_QUOTE = "'";
  Qr2.DOUBLE_QUOTE = '"';
  var ji = (Ui = { "'": { quotes: "single", wrap: true }, '"': { quotes: "double", wrap: true } }, Ui[null] = { isIdentifier: true }, Ui);
  function zl(t2, e2) {
    return "" + e2.before + t2 + e2.after;
  }
});
var Yi = S((Jt2, Vl) => {
  "use strict";
  Jt2.__esModule = true;
  Jt2.default = void 0;
  var tg = ng(Hr()), rg = J();
  function ng(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  function ig(t2, e2) {
    t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, Gi(t2, e2);
  }
  function Gi(t2, e2) {
    return Gi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i2) {
      return n2.__proto__ = i2, n2;
    }, Gi(t2, e2);
  }
  var sg = function(t2) {
    ig(e2, t2);
    function e2(r2) {
      var n2;
      return n2 = t2.call(this, r2) || this, n2.type = rg.UNIVERSAL, n2.value = "*", n2;
    }
    return e2;
  }(tg.default);
  Jt2.default = sg;
  Vl.exports = Jt2.default;
});
var Qi = S((Xt, Wl) => {
  "use strict";
  Xt.__esModule = true;
  Xt.default = void 0;
  var ag = lg(Oe()), og = J();
  function lg(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  function ug(t2, e2) {
    t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, Hi(t2, e2);
  }
  function Hi(t2, e2) {
    return Hi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i2) {
      return n2.__proto__ = i2, n2;
    }, Hi(t2, e2);
  }
  var fg = function(t2) {
    ug(e2, t2);
    function e2(r2) {
      var n2;
      return n2 = t2.call(this, r2) || this, n2.type = og.COMBINATOR, n2;
    }
    return e2;
  }(ag.default);
  Xt.default = fg;
  Wl.exports = Xt.default;
});
var Xi = S((Kt2, Bl) => {
  "use strict";
  Kt2.__esModule = true;
  Kt2.default = void 0;
  var cg = dg(Oe()), pg = J();
  function dg(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  function hg(t2, e2) {
    t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, Ji(t2, e2);
  }
  function Ji(t2, e2) {
    return Ji = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n2, i2) {
      return n2.__proto__ = i2, n2;
    }, Ji(t2, e2);
  }
  var mg = function(t2) {
    hg(e2, t2);
    function e2(r2) {
      var n2;
      return n2 = t2.call(this, r2) || this, n2.type = pg.NESTING, n2.value = "&", n2;
    }
    return e2;
  }(cg.default);
  Kt2.default = mg;
  Bl.exports = Kt2.default;
});
var Yl = S((Jr2, Gl) => {
  "use strict";
  Jr2.__esModule = true;
  Jr2.default = gg;
  function gg(t2) {
    return t2.sort(function(e2, r2) {
      return e2 - r2;
    });
  }
  Gl.exports = Jr2.default;
});
var Ki = S((P2) => {
  "use strict";
  P2.__esModule = true;
  P2.word = P2.tilde = P2.tab = P2.str = P2.space = P2.slash = P2.singleQuote = P2.semicolon = P2.plus = P2.pipe = P2.openSquare = P2.openParenthesis = P2.newline = P2.greaterThan = P2.feed = P2.equals = P2.doubleQuote = P2.dollar = P2.cr = P2.comment = P2.comma = P2.combinator = P2.colon = P2.closeSquare = P2.closeParenthesis = P2.caret = P2.bang = P2.backslash = P2.at = P2.asterisk = P2.ampersand = void 0;
  var yg = 38;
  P2.ampersand = yg;
  var vg = 42;
  P2.asterisk = vg;
  var wg = 64;
  P2.at = wg;
  var bg = 44;
  P2.comma = bg;
  var xg = 58;
  P2.colon = xg;
  var Sg = 59;
  P2.semicolon = Sg;
  var kg = 40;
  P2.openParenthesis = kg;
  var Og = 41;
  P2.closeParenthesis = Og;
  var Eg = 91;
  P2.openSquare = Eg;
  var Cg = 93;
  P2.closeSquare = Cg;
  var Ag = 36;
  P2.dollar = Ag;
  var _g = 126;
  P2.tilde = _g;
  var Tg = 94;
  P2.caret = Tg;
  var Pg = 43;
  P2.plus = Pg;
  var Ig = 61;
  P2.equals = Ig;
  var Rg = 124;
  P2.pipe = Rg;
  var Dg = 62;
  P2.greaterThan = Dg;
  var Mg = 32;
  P2.space = Mg;
  var Hl = 39;
  P2.singleQuote = Hl;
  var Fg = 34;
  P2.doubleQuote = Fg;
  var Lg = 47;
  P2.slash = Lg;
  var Ng = 33;
  P2.bang = Ng;
  var qg = 92;
  P2.backslash = qg;
  var $g = 13;
  P2.cr = $g;
  var Ug = 12;
  P2.feed = Ug;
  var jg = 10;
  P2.newline = jg;
  var zg = 9;
  P2.tab = zg;
  var Vg = Hl;
  P2.str = Vg;
  var Wg = -1;
  P2.comment = Wg;
  var Bg = -2;
  P2.word = Bg;
  var Gg = -3;
  P2.combinator = Gg;
});
var Xl = S((Zt) => {
  "use strict";
  Zt.__esModule = true;
  Zt.FIELDS = void 0;
  Zt.default = Zg;
  var C = Yg(Ki()), Ze2, q2;
  function Jl(t2) {
    if (typeof WeakMap != "function")
      return null;
    var e2 = /* @__PURE__ */ new WeakMap(), r2 = /* @__PURE__ */ new WeakMap();
    return (Jl = function(i2) {
      return i2 ? r2 : e2;
    })(t2);
  }
  function Yg(t2, e2) {
    if (!e2 && t2 && t2.__esModule)
      return t2;
    if (t2 === null || typeof t2 != "object" && typeof t2 != "function")
      return { default: t2 };
    var r2 = Jl(e2);
    if (r2 && r2.has(t2))
      return r2.get(t2);
    var n2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a2 in t2)
      if (a2 !== "default" && Object.prototype.hasOwnProperty.call(t2, a2)) {
        var s2 = i2 ? Object.getOwnPropertyDescriptor(t2, a2) : null;
        s2 && (s2.get || s2.set) ? Object.defineProperty(n2, a2, s2) : n2[a2] = t2[a2];
      }
    return n2.default = t2, r2 && r2.set(t2, n2), n2;
  }
  var Hg = (Ze2 = {}, Ze2[C.tab] = true, Ze2[C.newline] = true, Ze2[C.cr] = true, Ze2[C.feed] = true, Ze2), Qg = (q2 = {}, q2[C.space] = true, q2[C.tab] = true, q2[C.newline] = true, q2[C.cr] = true, q2[C.feed] = true, q2[C.ampersand] = true, q2[C.asterisk] = true, q2[C.bang] = true, q2[C.comma] = true, q2[C.colon] = true, q2[C.semicolon] = true, q2[C.openParenthesis] = true, q2[C.closeParenthesis] = true, q2[C.openSquare] = true, q2[C.closeSquare] = true, q2[C.singleQuote] = true, q2[C.doubleQuote] = true, q2[C.plus] = true, q2[C.pipe] = true, q2[C.tilde] = true, q2[C.greaterThan] = true, q2[C.equals] = true, q2[C.dollar] = true, q2[C.caret] = true, q2[C.slash] = true, q2), Zi = {}, Ql = "0123456789abcdefABCDEF";
  for (Xr2 = 0; Xr2 < Ql.length; Xr2++)
    Zi[Ql.charCodeAt(Xr2)] = true;
  var Xr2;
  function Jg(t2, e2) {
    var r2 = e2, n2;
    do {
      if (n2 = t2.charCodeAt(r2), Qg[n2])
        return r2 - 1;
      n2 === C.backslash ? r2 = Xg(t2, r2) + 1 : r2++;
    } while (r2 < t2.length);
    return r2 - 1;
  }
  function Xg(t2, e2) {
    var r2 = e2, n2 = t2.charCodeAt(r2 + 1);
    if (!Hg[n2])
      if (Zi[n2]) {
        var i2 = 0;
        do
          r2++, i2++, n2 = t2.charCodeAt(r2 + 1);
        while (Zi[n2] && i2 < 6);
        i2 < 6 && n2 === C.space && r2++;
      } else
        r2++;
    return r2;
  }
  var Kg = { TYPE: 0, START_LINE: 1, START_COL: 2, END_LINE: 3, END_COL: 4, START_POS: 5, END_POS: 6 };
  Zt.FIELDS = Kg;
  function Zg(t2) {
    var e2 = [], r2 = t2.css.valueOf(), n2 = r2, i2 = n2.length, a2 = -1, s2 = 1, o2 = 0, l2 = 0, u2, f2, p2, c2, d2, h2, y3, m, g2, w2, b3, v2, O2;
    function x2(A, E2) {
      if (t2.safe)
        r2 += E2, g2 = r2.length - 1;
      else
        throw t2.error("Unclosed " + A, s2, o2 - a2, o2);
    }
    for (; o2 < i2; ) {
      switch (u2 = r2.charCodeAt(o2), u2 === C.newline && (a2 = o2, s2 += 1), u2) {
        case C.space:
        case C.tab:
        case C.newline:
        case C.cr:
        case C.feed:
          g2 = o2;
          do
            g2 += 1, u2 = r2.charCodeAt(g2), u2 === C.newline && (a2 = g2, s2 += 1);
          while (u2 === C.space || u2 === C.newline || u2 === C.tab || u2 === C.cr || u2 === C.feed);
          O2 = C.space, c2 = s2, p2 = g2 - a2 - 1, l2 = g2;
          break;
        case C.plus:
        case C.greaterThan:
        case C.tilde:
        case C.pipe:
          g2 = o2;
          do
            g2 += 1, u2 = r2.charCodeAt(g2);
          while (u2 === C.plus || u2 === C.greaterThan || u2 === C.tilde || u2 === C.pipe);
          O2 = C.combinator, c2 = s2, p2 = o2 - a2, l2 = g2;
          break;
        case C.asterisk:
        case C.ampersand:
        case C.bang:
        case C.comma:
        case C.equals:
        case C.dollar:
        case C.caret:
        case C.openSquare:
        case C.closeSquare:
        case C.colon:
        case C.semicolon:
        case C.openParenthesis:
        case C.closeParenthesis:
          g2 = o2, O2 = u2, c2 = s2, p2 = o2 - a2, l2 = g2 + 1;
          break;
        case C.singleQuote:
        case C.doubleQuote:
          v2 = u2 === C.singleQuote ? "'" : '"', g2 = o2;
          do
            for (d2 = false, g2 = r2.indexOf(v2, g2 + 1), g2 === -1 && x2("quote", v2), h2 = g2; r2.charCodeAt(h2 - 1) === C.backslash; )
              h2 -= 1, d2 = !d2;
          while (d2);
          O2 = C.str, c2 = s2, p2 = o2 - a2, l2 = g2 + 1;
          break;
        default:
          u2 === C.slash && r2.charCodeAt(o2 + 1) === C.asterisk ? (g2 = r2.indexOf("*/", o2 + 2) + 1, g2 === 0 && x2("comment", "*/"), f2 = r2.slice(o2, g2 + 1), m = f2.split(`
`), y3 = m.length - 1, y3 > 0 ? (w2 = s2 + y3, b3 = g2 - m[y3].length) : (w2 = s2, b3 = a2), O2 = C.comment, s2 = w2, c2 = w2, p2 = g2 - b3) : u2 === C.slash ? (g2 = o2, O2 = u2, c2 = s2, p2 = o2 - a2, l2 = g2 + 1) : (g2 = Jg(r2, o2), O2 = C.word, c2 = s2, p2 = g2 - a2), l2 = g2 + 1;
          break;
      }
      e2.push([O2, s2, o2 - a2, c2, p2, o2, l2]), b3 && (a2 = b3, b3 = null), o2 = l2;
    }
    return e2;
  }
});
var su = S((er2, iu2) => {
  "use strict";
  er2.__esModule = true;
  er2.default = void 0;
  var ey = le2(Si()), es = le2(Oi()), ty = le2(Ai()), Kl = le2(Ti()), ry = le2(Ii()), ny = le2(Mi()), ts = le2(Li()), iy = le2(qi()), Zl = Kr2(Bi()), sy = le2(Yi()), rs = le2(Qi()), ay = le2(Xi()), oy = le2(Yl()), k = Kr2(Xl()), _3 = Kr2(Ki()), ly = Kr2(J()), V2 = Ft(), Ve2, ns;
  function nu2(t2) {
    if (typeof WeakMap != "function")
      return null;
    var e2 = /* @__PURE__ */ new WeakMap(), r2 = /* @__PURE__ */ new WeakMap();
    return (nu2 = function(i2) {
      return i2 ? r2 : e2;
    })(t2);
  }
  function Kr2(t2, e2) {
    if (!e2 && t2 && t2.__esModule)
      return t2;
    if (t2 === null || typeof t2 != "object" && typeof t2 != "function")
      return { default: t2 };
    var r2 = nu2(e2);
    if (r2 && r2.has(t2))
      return r2.get(t2);
    var n2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a2 in t2)
      if (a2 !== "default" && Object.prototype.hasOwnProperty.call(t2, a2)) {
        var s2 = i2 ? Object.getOwnPropertyDescriptor(t2, a2) : null;
        s2 && (s2.get || s2.set) ? Object.defineProperty(n2, a2, s2) : n2[a2] = t2[a2];
      }
    return n2.default = t2, r2 && r2.set(t2, n2), n2;
  }
  function le2(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  function eu2(t2, e2) {
    for (var r2 = 0; r2 < e2.length; r2++) {
      var n2 = e2[r2];
      n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t2, n2.key, n2);
    }
  }
  function uy(t2, e2, r2) {
    return e2 && eu2(t2.prototype, e2), r2 && eu2(t2, r2), Object.defineProperty(t2, "prototype", { writable: false }), t2;
  }
  var as = (Ve2 = {}, Ve2[_3.space] = true, Ve2[_3.cr] = true, Ve2[_3.feed] = true, Ve2[_3.newline] = true, Ve2[_3.tab] = true, Ve2), fy = Object.assign({}, as, (ns = {}, ns[_3.comment] = true, ns));
  function tu2(t2) {
    return { line: t2[k.FIELDS.START_LINE], column: t2[k.FIELDS.START_COL] };
  }
  function ru2(t2) {
    return { line: t2[k.FIELDS.END_LINE], column: t2[k.FIELDS.END_COL] };
  }
  function We2(t2, e2, r2, n2) {
    return { start: { line: t2, column: e2 }, end: { line: r2, column: n2 } };
  }
  function et2(t2) {
    return We2(t2[k.FIELDS.START_LINE], t2[k.FIELDS.START_COL], t2[k.FIELDS.END_LINE], t2[k.FIELDS.END_COL]);
  }
  function is(t2, e2) {
    if (!!t2)
      return We2(t2[k.FIELDS.START_LINE], t2[k.FIELDS.START_COL], e2[k.FIELDS.END_LINE], e2[k.FIELDS.END_COL]);
  }
  function tt2(t2, e2) {
    var r2 = t2[e2];
    if (typeof r2 == "string")
      return r2.indexOf("\\") !== -1 && ((0, V2.ensureObject)(t2, "raws"), t2[e2] = (0, V2.unesc)(r2), t2.raws[e2] === void 0 && (t2.raws[e2] = r2)), t2;
  }
  function ss(t2, e2) {
    for (var r2 = -1, n2 = []; (r2 = t2.indexOf(e2, r2 + 1)) !== -1; )
      n2.push(r2);
    return n2;
  }
  function cy() {
    var t2 = Array.prototype.concat.apply([], arguments);
    return t2.filter(function(e2, r2) {
      return r2 === t2.indexOf(e2);
    });
  }
  var py = function() {
    function t2(r2, n2) {
      n2 === void 0 && (n2 = {}), this.rule = r2, this.options = Object.assign({ lossy: false, safe: false }, n2), this.position = 0, this.css = typeof this.rule == "string" ? this.rule : this.rule.selector, this.tokens = (0, k.default)({ css: this.css, error: this._errorGenerator(), safe: this.options.safe });
      var i2 = is(this.tokens[0], this.tokens[this.tokens.length - 1]);
      this.root = new ey.default({ source: i2 }), this.root.errorGenerator = this._errorGenerator();
      var a2 = new es.default({ source: { start: { line: 1, column: 1 } } });
      this.root.append(a2), this.current = a2, this.loop();
    }
    var e2 = t2.prototype;
    return e2._errorGenerator = function() {
      var n2 = this;
      return function(i2, a2) {
        return typeof n2.rule == "string" ? new Error(i2) : n2.rule.error(i2, a2);
      };
    }, e2.attribute = function() {
      var n2 = [], i2 = this.currToken;
      for (this.position++; this.position < this.tokens.length && this.currToken[k.FIELDS.TYPE] !== _3.closeSquare; )
        n2.push(this.currToken), this.position++;
      if (this.currToken[k.FIELDS.TYPE] !== _3.closeSquare)
        return this.expected("closing square bracket", this.currToken[k.FIELDS.START_POS]);
      var a2 = n2.length, s2 = { source: We2(i2[1], i2[2], this.currToken[3], this.currToken[4]), sourceIndex: i2[k.FIELDS.START_POS] };
      if (a2 === 1 && !~[_3.word].indexOf(n2[0][k.FIELDS.TYPE]))
        return this.expected("attribute", n2[0][k.FIELDS.START_POS]);
      for (var o2 = 0, l2 = "", u2 = "", f2 = null, p2 = false; o2 < a2; ) {
        var c2 = n2[o2], d2 = this.content(c2), h2 = n2[o2 + 1];
        switch (c2[k.FIELDS.TYPE]) {
          case _3.space:
            if (p2 = true, this.options.lossy)
              break;
            if (f2) {
              (0, V2.ensureObject)(s2, "spaces", f2);
              var y3 = s2.spaces[f2].after || "";
              s2.spaces[f2].after = y3 + d2;
              var m = (0, V2.getProp)(s2, "raws", "spaces", f2, "after") || null;
              m && (s2.raws.spaces[f2].after = m + d2);
            } else
              l2 = l2 + d2, u2 = u2 + d2;
            break;
          case _3.asterisk:
            if (h2[k.FIELDS.TYPE] === _3.equals)
              s2.operator = d2, f2 = "operator";
            else if ((!s2.namespace || f2 === "namespace" && !p2) && h2) {
              l2 && ((0, V2.ensureObject)(s2, "spaces", "attribute"), s2.spaces.attribute.before = l2, l2 = ""), u2 && ((0, V2.ensureObject)(s2, "raws", "spaces", "attribute"), s2.raws.spaces.attribute.before = l2, u2 = ""), s2.namespace = (s2.namespace || "") + d2;
              var g2 = (0, V2.getProp)(s2, "raws", "namespace") || null;
              g2 && (s2.raws.namespace += d2), f2 = "namespace";
            }
            p2 = false;
            break;
          case _3.dollar:
            if (f2 === "value") {
              var w2 = (0, V2.getProp)(s2, "raws", "value");
              s2.value += "$", w2 && (s2.raws.value = w2 + "$");
              break;
            }
          case _3.caret:
            h2[k.FIELDS.TYPE] === _3.equals && (s2.operator = d2, f2 = "operator"), p2 = false;
            break;
          case _3.combinator:
            if (d2 === "~" && h2[k.FIELDS.TYPE] === _3.equals && (s2.operator = d2, f2 = "operator"), d2 !== "|") {
              p2 = false;
              break;
            }
            h2[k.FIELDS.TYPE] === _3.equals ? (s2.operator = d2, f2 = "operator") : !s2.namespace && !s2.attribute && (s2.namespace = true), p2 = false;
            break;
          case _3.word:
            if (h2 && this.content(h2) === "|" && n2[o2 + 2] && n2[o2 + 2][k.FIELDS.TYPE] !== _3.equals && !s2.operator && !s2.namespace)
              s2.namespace = d2, f2 = "namespace";
            else if (!s2.attribute || f2 === "attribute" && !p2) {
              l2 && ((0, V2.ensureObject)(s2, "spaces", "attribute"), s2.spaces.attribute.before = l2, l2 = ""), u2 && ((0, V2.ensureObject)(s2, "raws", "spaces", "attribute"), s2.raws.spaces.attribute.before = u2, u2 = ""), s2.attribute = (s2.attribute || "") + d2;
              var b3 = (0, V2.getProp)(s2, "raws", "attribute") || null;
              b3 && (s2.raws.attribute += d2), f2 = "attribute";
            } else if (!s2.value && s2.value !== "" || f2 === "value" && !(p2 || s2.quoteMark)) {
              var v2 = (0, V2.unesc)(d2), O2 = (0, V2.getProp)(s2, "raws", "value") || "", x2 = s2.value || "";
              s2.value = x2 + v2, s2.quoteMark = null, (v2 !== d2 || O2) && ((0, V2.ensureObject)(s2, "raws"), s2.raws.value = (O2 || x2) + d2), f2 = "value";
            } else {
              var A = d2 === "i" || d2 === "I";
              (s2.value || s2.value === "") && (s2.quoteMark || p2) ? (s2.insensitive = A, (!A || d2 === "I") && ((0, V2.ensureObject)(s2, "raws"), s2.raws.insensitiveFlag = d2), f2 = "insensitive", l2 && ((0, V2.ensureObject)(s2, "spaces", "insensitive"), s2.spaces.insensitive.before = l2, l2 = ""), u2 && ((0, V2.ensureObject)(s2, "raws", "spaces", "insensitive"), s2.raws.spaces.insensitive.before = u2, u2 = "")) : (s2.value || s2.value === "") && (f2 = "value", s2.value += d2, s2.raws.value && (s2.raws.value += d2));
            }
            p2 = false;
            break;
          case _3.str:
            if (!s2.attribute || !s2.operator)
              return this.error("Expected an attribute followed by an operator preceding the string.", { index: c2[k.FIELDS.START_POS] });
            var E2 = (0, Zl.unescapeValue)(d2), I2 = E2.unescaped, F = E2.quoteMark;
            s2.value = I2, s2.quoteMark = F, f2 = "value", (0, V2.ensureObject)(s2, "raws"), s2.raws.value = d2, p2 = false;
            break;
          case _3.equals:
            if (!s2.attribute)
              return this.expected("attribute", c2[k.FIELDS.START_POS], d2);
            if (s2.value)
              return this.error('Unexpected "=" found; an operator was already defined.', { index: c2[k.FIELDS.START_POS] });
            s2.operator = s2.operator ? s2.operator + d2 : d2, f2 = "operator", p2 = false;
            break;
          case _3.comment:
            if (f2)
              if (p2 || h2 && h2[k.FIELDS.TYPE] === _3.space || f2 === "insensitive") {
                var Y2 = (0, V2.getProp)(s2, "spaces", f2, "after") || "", K2 = (0, V2.getProp)(s2, "raws", "spaces", f2, "after") || Y2;
                (0, V2.ensureObject)(s2, "raws", "spaces", f2), s2.raws.spaces[f2].after = K2 + d2;
              } else {
                var B2 = s2[f2] || "", qe2 = (0, V2.getProp)(s2, "raws", f2) || B2;
                (0, V2.ensureObject)(s2, "raws"), s2.raws[f2] = qe2 + d2;
              }
            else
              u2 = u2 + d2;
            break;
          default:
            return this.error('Unexpected "' + d2 + '" found.', { index: c2[k.FIELDS.START_POS] });
        }
        o2++;
      }
      tt2(s2, "attribute"), tt2(s2, "namespace"), this.newNode(new Zl.default(s2)), this.position++;
    }, e2.parseWhitespaceEquivalentTokens = function(n2) {
      n2 < 0 && (n2 = this.tokens.length);
      var i2 = this.position, a2 = [], s2 = "", o2 = void 0;
      do
        if (as[this.currToken[k.FIELDS.TYPE]])
          this.options.lossy || (s2 += this.content());
        else if (this.currToken[k.FIELDS.TYPE] === _3.comment) {
          var l2 = {};
          s2 && (l2.before = s2, s2 = ""), o2 = new Kl.default({ value: this.content(), source: et2(this.currToken), sourceIndex: this.currToken[k.FIELDS.START_POS], spaces: l2 }), a2.push(o2);
        }
      while (++this.position < n2);
      if (s2) {
        if (o2)
          o2.spaces.after = s2;
        else if (!this.options.lossy) {
          var u2 = this.tokens[i2], f2 = this.tokens[this.position - 1];
          a2.push(new ts.default({ value: "", source: We2(u2[k.FIELDS.START_LINE], u2[k.FIELDS.START_COL], f2[k.FIELDS.END_LINE], f2[k.FIELDS.END_COL]), sourceIndex: u2[k.FIELDS.START_POS], spaces: { before: s2, after: "" } }));
        }
      }
      return a2;
    }, e2.convertWhitespaceNodesToSpace = function(n2, i2) {
      var a2 = this;
      i2 === void 0 && (i2 = false);
      var s2 = "", o2 = "";
      n2.forEach(function(u2) {
        var f2 = a2.lossySpace(u2.spaces.before, i2), p2 = a2.lossySpace(u2.rawSpaceBefore, i2);
        s2 += f2 + a2.lossySpace(u2.spaces.after, i2 && f2.length === 0), o2 += f2 + u2.value + a2.lossySpace(u2.rawSpaceAfter, i2 && p2.length === 0);
      }), o2 === s2 && (o2 = void 0);
      var l2 = { space: s2, rawSpace: o2 };
      return l2;
    }, e2.isNamedCombinator = function(n2) {
      return n2 === void 0 && (n2 = this.position), this.tokens[n2 + 0] && this.tokens[n2 + 0][k.FIELDS.TYPE] === _3.slash && this.tokens[n2 + 1] && this.tokens[n2 + 1][k.FIELDS.TYPE] === _3.word && this.tokens[n2 + 2] && this.tokens[n2 + 2][k.FIELDS.TYPE] === _3.slash;
    }, e2.namedCombinator = function() {
      if (this.isNamedCombinator()) {
        var n2 = this.content(this.tokens[this.position + 1]), i2 = (0, V2.unesc)(n2).toLowerCase(), a2 = {};
        i2 !== n2 && (a2.value = "/" + n2 + "/");
        var s2 = new rs.default({ value: "/" + i2 + "/", source: We2(this.currToken[k.FIELDS.START_LINE], this.currToken[k.FIELDS.START_COL], this.tokens[this.position + 2][k.FIELDS.END_LINE], this.tokens[this.position + 2][k.FIELDS.END_COL]), sourceIndex: this.currToken[k.FIELDS.START_POS], raws: a2 });
        return this.position = this.position + 3, s2;
      } else
        this.unexpected();
    }, e2.combinator = function() {
      var n2 = this;
      if (this.content() === "|")
        return this.namespace();
      var i2 = this.locateNextMeaningfulToken(this.position);
      if (i2 < 0 || this.tokens[i2][k.FIELDS.TYPE] === _3.comma) {
        var a2 = this.parseWhitespaceEquivalentTokens(i2);
        if (a2.length > 0) {
          var s2 = this.current.last;
          if (s2) {
            var o2 = this.convertWhitespaceNodesToSpace(a2), l2 = o2.space, u2 = o2.rawSpace;
            u2 !== void 0 && (s2.rawSpaceAfter += u2), s2.spaces.after += l2;
          } else
            a2.forEach(function(O2) {
              return n2.newNode(O2);
            });
        }
        return;
      }
      var f2 = this.currToken, p2 = void 0;
      i2 > this.position && (p2 = this.parseWhitespaceEquivalentTokens(i2));
      var c2;
      if (this.isNamedCombinator() ? c2 = this.namedCombinator() : this.currToken[k.FIELDS.TYPE] === _3.combinator ? (c2 = new rs.default({ value: this.content(), source: et2(this.currToken), sourceIndex: this.currToken[k.FIELDS.START_POS] }), this.position++) : as[this.currToken[k.FIELDS.TYPE]] || p2 || this.unexpected(), c2) {
        if (p2) {
          var d2 = this.convertWhitespaceNodesToSpace(p2), h2 = d2.space, y3 = d2.rawSpace;
          c2.spaces.before = h2, c2.rawSpaceBefore = y3;
        }
      } else {
        var m = this.convertWhitespaceNodesToSpace(p2, true), g2 = m.space, w2 = m.rawSpace;
        w2 || (w2 = g2);
        var b3 = {}, v2 = { spaces: {} };
        g2.endsWith(" ") && w2.endsWith(" ") ? (b3.before = g2.slice(0, g2.length - 1), v2.spaces.before = w2.slice(0, w2.length - 1)) : g2.startsWith(" ") && w2.startsWith(" ") ? (b3.after = g2.slice(1), v2.spaces.after = w2.slice(1)) : v2.value = w2, c2 = new rs.default({ value: " ", source: is(f2, this.tokens[this.position - 1]), sourceIndex: f2[k.FIELDS.START_POS], spaces: b3, raws: v2 });
      }
      return this.currToken && this.currToken[k.FIELDS.TYPE] === _3.space && (c2.spaces.after = this.optionalSpace(this.content()), this.position++), this.newNode(c2);
    }, e2.comma = function() {
      if (this.position === this.tokens.length - 1) {
        this.root.trailingComma = true, this.position++;
        return;
      }
      this.current._inferEndPosition();
      var n2 = new es.default({ source: { start: tu2(this.tokens[this.position + 1]) } });
      this.current.parent.append(n2), this.current = n2, this.position++;
    }, e2.comment = function() {
      var n2 = this.currToken;
      this.newNode(new Kl.default({ value: this.content(), source: et2(n2), sourceIndex: n2[k.FIELDS.START_POS] })), this.position++;
    }, e2.error = function(n2, i2) {
      throw this.root.error(n2, i2);
    }, e2.missingBackslash = function() {
      return this.error("Expected a backslash preceding the semicolon.", { index: this.currToken[k.FIELDS.START_POS] });
    }, e2.missingParenthesis = function() {
      return this.expected("opening parenthesis", this.currToken[k.FIELDS.START_POS]);
    }, e2.missingSquareBracket = function() {
      return this.expected("opening square bracket", this.currToken[k.FIELDS.START_POS]);
    }, e2.unexpected = function() {
      return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[k.FIELDS.START_POS]);
    }, e2.unexpectedPipe = function() {
      return this.error("Unexpected '|'.", this.currToken[k.FIELDS.START_POS]);
    }, e2.namespace = function() {
      var n2 = this.prevToken && this.content(this.prevToken) || true;
      if (this.nextToken[k.FIELDS.TYPE] === _3.word)
        return this.position++, this.word(n2);
      if (this.nextToken[k.FIELDS.TYPE] === _3.asterisk)
        return this.position++, this.universal(n2);
      this.unexpectedPipe();
    }, e2.nesting = function() {
      if (this.nextToken) {
        var n2 = this.content(this.nextToken);
        if (n2 === "|") {
          this.position++;
          return;
        }
      }
      var i2 = this.currToken;
      this.newNode(new ay.default({ value: this.content(), source: et2(i2), sourceIndex: i2[k.FIELDS.START_POS] })), this.position++;
    }, e2.parentheses = function() {
      var n2 = this.current.last, i2 = 1;
      if (this.position++, n2 && n2.type === ly.PSEUDO) {
        var a2 = new es.default({ source: { start: tu2(this.tokens[this.position - 1]) } }), s2 = this.current;
        for (n2.append(a2), this.current = a2; this.position < this.tokens.length && i2; )
          this.currToken[k.FIELDS.TYPE] === _3.openParenthesis && i2++, this.currToken[k.FIELDS.TYPE] === _3.closeParenthesis && i2--, i2 ? this.parse() : (this.current.source.end = ru2(this.currToken), this.current.parent.source.end = ru2(this.currToken), this.position++);
        this.current = s2;
      } else {
        for (var o2 = this.currToken, l2 = "(", u2; this.position < this.tokens.length && i2; )
          this.currToken[k.FIELDS.TYPE] === _3.openParenthesis && i2++, this.currToken[k.FIELDS.TYPE] === _3.closeParenthesis && i2--, u2 = this.currToken, l2 += this.parseParenthesisToken(this.currToken), this.position++;
        n2 ? n2.appendToPropertyAndEscape("value", l2, l2) : this.newNode(new ts.default({ value: l2, source: We2(o2[k.FIELDS.START_LINE], o2[k.FIELDS.START_COL], u2[k.FIELDS.END_LINE], u2[k.FIELDS.END_COL]), sourceIndex: o2[k.FIELDS.START_POS] }));
      }
      if (i2)
        return this.expected("closing parenthesis", this.currToken[k.FIELDS.START_POS]);
    }, e2.pseudo = function() {
      for (var n2 = this, i2 = "", a2 = this.currToken; this.currToken && this.currToken[k.FIELDS.TYPE] === _3.colon; )
        i2 += this.content(), this.position++;
      if (!this.currToken)
        return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
      if (this.currToken[k.FIELDS.TYPE] === _3.word)
        this.splitWord(false, function(s2, o2) {
          i2 += s2, n2.newNode(new iy.default({ value: i2, source: is(a2, n2.currToken), sourceIndex: a2[k.FIELDS.START_POS] })), o2 > 1 && n2.nextToken && n2.nextToken[k.FIELDS.TYPE] === _3.openParenthesis && n2.error("Misplaced parenthesis.", { index: n2.nextToken[k.FIELDS.START_POS] });
        });
      else
        return this.expected(["pseudo-class", "pseudo-element"], this.currToken[k.FIELDS.START_POS]);
    }, e2.space = function() {
      var n2 = this.content();
      this.position === 0 || this.prevToken[k.FIELDS.TYPE] === _3.comma || this.prevToken[k.FIELDS.TYPE] === _3.openParenthesis || this.current.nodes.every(function(i2) {
        return i2.type === "comment";
      }) ? (this.spaces = this.optionalSpace(n2), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[k.FIELDS.TYPE] === _3.comma || this.nextToken[k.FIELDS.TYPE] === _3.closeParenthesis ? (this.current.last.spaces.after = this.optionalSpace(n2), this.position++) : this.combinator();
    }, e2.string = function() {
      var n2 = this.currToken;
      this.newNode(new ts.default({ value: this.content(), source: et2(n2), sourceIndex: n2[k.FIELDS.START_POS] })), this.position++;
    }, e2.universal = function(n2) {
      var i2 = this.nextToken;
      if (i2 && this.content(i2) === "|")
        return this.position++, this.namespace();
      var a2 = this.currToken;
      this.newNode(new sy.default({ value: this.content(), source: et2(a2), sourceIndex: a2[k.FIELDS.START_POS] }), n2), this.position++;
    }, e2.splitWord = function(n2, i2) {
      for (var a2 = this, s2 = this.nextToken, o2 = this.content(); s2 && ~[_3.dollar, _3.caret, _3.equals, _3.word].indexOf(s2[k.FIELDS.TYPE]); ) {
        this.position++;
        var l2 = this.content();
        if (o2 += l2, l2.lastIndexOf("\\") === l2.length - 1) {
          var u2 = this.nextToken;
          u2 && u2[k.FIELDS.TYPE] === _3.space && (o2 += this.requiredSpace(this.content(u2)), this.position++);
        }
        s2 = this.nextToken;
      }
      var f2 = ss(o2, ".").filter(function(h2) {
        var y3 = o2[h2 - 1] === "\\", m = /^\d+\.\d+%$/.test(o2);
        return !y3 && !m;
      }), p2 = ss(o2, "#").filter(function(h2) {
        return o2[h2 - 1] !== "\\";
      }), c2 = ss(o2, "#{");
      c2.length && (p2 = p2.filter(function(h2) {
        return !~c2.indexOf(h2);
      }));
      var d2 = (0, oy.default)(cy([0].concat(f2, p2)));
      d2.forEach(function(h2, y3) {
        var m = d2[y3 + 1] || o2.length, g2 = o2.slice(h2, m);
        if (y3 === 0 && i2)
          return i2.call(a2, g2, d2.length);
        var w2, b3 = a2.currToken, v2 = b3[k.FIELDS.START_POS] + d2[y3], O2 = We2(b3[1], b3[2] + h2, b3[3], b3[2] + (m - 1));
        if (~f2.indexOf(h2)) {
          var x2 = { value: g2.slice(1), source: O2, sourceIndex: v2 };
          w2 = new ty.default(tt2(x2, "value"));
        } else if (~p2.indexOf(h2)) {
          var A = { value: g2.slice(1), source: O2, sourceIndex: v2 };
          w2 = new ry.default(tt2(A, "value"));
        } else {
          var E2 = { value: g2, source: O2, sourceIndex: v2 };
          tt2(E2, "value"), w2 = new ny.default(E2);
        }
        a2.newNode(w2, n2), n2 = null;
      }), this.position++;
    }, e2.word = function(n2) {
      var i2 = this.nextToken;
      return i2 && this.content(i2) === "|" ? (this.position++, this.namespace()) : this.splitWord(n2);
    }, e2.loop = function() {
      for (; this.position < this.tokens.length; )
        this.parse(true);
      return this.current._inferEndPosition(), this.root;
    }, e2.parse = function(n2) {
      switch (this.currToken[k.FIELDS.TYPE]) {
        case _3.space:
          this.space();
          break;
        case _3.comment:
          this.comment();
          break;
        case _3.openParenthesis:
          this.parentheses();
          break;
        case _3.closeParenthesis:
          n2 && this.missingParenthesis();
          break;
        case _3.openSquare:
          this.attribute();
          break;
        case _3.dollar:
        case _3.caret:
        case _3.equals:
        case _3.word:
          this.word();
          break;
        case _3.colon:
          this.pseudo();
          break;
        case _3.comma:
          this.comma();
          break;
        case _3.asterisk:
          this.universal();
          break;
        case _3.ampersand:
          this.nesting();
          break;
        case _3.slash:
        case _3.combinator:
          this.combinator();
          break;
        case _3.str:
          this.string();
          break;
        case _3.closeSquare:
          this.missingSquareBracket();
        case _3.semicolon:
          this.missingBackslash();
        default:
          this.unexpected();
      }
    }, e2.expected = function(n2, i2, a2) {
      if (Array.isArray(n2)) {
        var s2 = n2.pop();
        n2 = n2.join(", ") + " or " + s2;
      }
      var o2 = /^[aeiou]/.test(n2[0]) ? "an" : "a";
      return a2 ? this.error("Expected " + o2 + " " + n2 + ', found "' + a2 + '" instead.', { index: i2 }) : this.error("Expected " + o2 + " " + n2 + ".", { index: i2 });
    }, e2.requiredSpace = function(n2) {
      return this.options.lossy ? " " : n2;
    }, e2.optionalSpace = function(n2) {
      return this.options.lossy ? "" : n2;
    }, e2.lossySpace = function(n2, i2) {
      return this.options.lossy ? i2 ? " " : "" : n2;
    }, e2.parseParenthesisToken = function(n2) {
      var i2 = this.content(n2);
      return n2[k.FIELDS.TYPE] === _3.space ? this.requiredSpace(i2) : i2;
    }, e2.newNode = function(n2, i2) {
      return i2 && (/^ +$/.test(i2) && (this.options.lossy || (this.spaces = (this.spaces || "") + i2), i2 = true), n2.namespace = i2, tt2(n2, "namespace")), this.spaces && (n2.spaces.before = this.spaces, this.spaces = ""), this.current.append(n2);
    }, e2.content = function(n2) {
      return n2 === void 0 && (n2 = this.currToken), this.css.slice(n2[k.FIELDS.START_POS], n2[k.FIELDS.END_POS]);
    }, e2.locateNextMeaningfulToken = function(n2) {
      n2 === void 0 && (n2 = this.position + 1);
      for (var i2 = n2; i2 < this.tokens.length; )
        if (fy[this.tokens[i2][k.FIELDS.TYPE]]) {
          i2++;
          continue;
        } else
          return i2;
      return -1;
    }, uy(t2, [{ key: "currToken", get: function() {
      return this.tokens[this.position];
    } }, { key: "nextToken", get: function() {
      return this.tokens[this.position + 1];
    } }, { key: "prevToken", get: function() {
      return this.tokens[this.position - 1];
    } }]), t2;
  }();
  er2.default = py;
  iu2.exports = er2.default;
});
var ou = S((tr2, au2) => {
  "use strict";
  tr2.__esModule = true;
  tr2.default = void 0;
  var dy = hy(su());
  function hy(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  var my = function() {
    function t2(r2, n2) {
      this.func = r2 || function() {
      }, this.funcRes = null, this.options = n2;
    }
    var e2 = t2.prototype;
    return e2._shouldUpdateSelector = function(n2, i2) {
      i2 === void 0 && (i2 = {});
      var a2 = Object.assign({}, this.options, i2);
      return a2.updateSelector === false ? false : typeof n2 != "string";
    }, e2._isLossy = function(n2) {
      n2 === void 0 && (n2 = {});
      var i2 = Object.assign({}, this.options, n2);
      return i2.lossless === false;
    }, e2._root = function(n2, i2) {
      i2 === void 0 && (i2 = {});
      var a2 = new dy.default(n2, this._parseOptions(i2));
      return a2.root;
    }, e2._parseOptions = function(n2) {
      return { lossy: this._isLossy(n2) };
    }, e2._run = function(n2, i2) {
      var a2 = this;
      return i2 === void 0 && (i2 = {}), new Promise(function(s2, o2) {
        try {
          var l2 = a2._root(n2, i2);
          Promise.resolve(a2.func(l2)).then(function(u2) {
            var f2 = void 0;
            return a2._shouldUpdateSelector(n2, i2) && (f2 = l2.toString(), n2.selector = f2), { transform: u2, root: l2, string: f2 };
          }).then(s2, o2);
        } catch (u2) {
          o2(u2);
          return;
        }
      });
    }, e2._runSync = function(n2, i2) {
      i2 === void 0 && (i2 = {});
      var a2 = this._root(n2, i2), s2 = this.func(a2);
      if (s2 && typeof s2.then == "function")
        throw new Error("Selector processor returned a promise to a synchronous call.");
      var o2 = void 0;
      return i2.updateSelector && typeof n2 != "string" && (o2 = a2.toString(), n2.selector = o2), { transform: s2, root: a2, string: o2 };
    }, e2.ast = function(n2, i2) {
      return this._run(n2, i2).then(function(a2) {
        return a2.root;
      });
    }, e2.astSync = function(n2, i2) {
      return this._runSync(n2, i2).root;
    }, e2.transform = function(n2, i2) {
      return this._run(n2, i2).then(function(a2) {
        return a2.transform;
      });
    }, e2.transformSync = function(n2, i2) {
      return this._runSync(n2, i2).transform;
    }, e2.process = function(n2, i2) {
      return this._run(n2, i2).then(function(a2) {
        return a2.string || a2.root.toString();
      });
    }, e2.processSync = function(n2, i2) {
      var a2 = this._runSync(n2, i2);
      return a2.string || a2.root.toString();
    }, t2;
  }();
  tr2.default = my;
  au2.exports = tr2.default;
});
var lu = S((j2) => {
  "use strict";
  j2.__esModule = true;
  j2.universal = j2.tag = j2.string = j2.selector = j2.root = j2.pseudo = j2.nesting = j2.id = j2.comment = j2.combinator = j2.className = j2.attribute = void 0;
  var gy = ue2(Bi()), yy = ue2(Ai()), vy = ue2(Qi()), wy = ue2(Ti()), by = ue2(Ii()), xy = ue2(Xi()), Sy = ue2(qi()), ky = ue2(Si()), Oy = ue2(Oi()), Ey = ue2(Li()), Cy = ue2(Mi()), Ay = ue2(Yi());
  function ue2(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  var _y = function(e2) {
    return new gy.default(e2);
  };
  j2.attribute = _y;
  var Ty = function(e2) {
    return new yy.default(e2);
  };
  j2.className = Ty;
  var Py = function(e2) {
    return new vy.default(e2);
  };
  j2.combinator = Py;
  var Iy = function(e2) {
    return new wy.default(e2);
  };
  j2.comment = Iy;
  var Ry = function(e2) {
    return new by.default(e2);
  };
  j2.id = Ry;
  var Dy = function(e2) {
    return new xy.default(e2);
  };
  j2.nesting = Dy;
  var My = function(e2) {
    return new Sy.default(e2);
  };
  j2.pseudo = My;
  var Fy = function(e2) {
    return new ky.default(e2);
  };
  j2.root = Fy;
  var Ly = function(e2) {
    return new Oy.default(e2);
  };
  j2.selector = Ly;
  var Ny = function(e2) {
    return new Ey.default(e2);
  };
  j2.string = Ny;
  var qy = function(e2) {
    return new Cy.default(e2);
  };
  j2.tag = qy;
  var $y = function(e2) {
    return new Ay.default(e2);
  };
  j2.universal = $y;
});
var pu = S((D) => {
  "use strict";
  D.__esModule = true;
  D.isComment = D.isCombinator = D.isClassName = D.isAttribute = void 0;
  D.isContainer = Xy;
  D.isIdentifier = void 0;
  D.isNamespace = Ky;
  D.isNesting = void 0;
  D.isNode = os;
  D.isPseudo = void 0;
  D.isPseudoClass = Jy;
  D.isPseudoElement = cu2;
  D.isUniversal = D.isTag = D.isString = D.isSelector = D.isRoot = void 0;
  var W2 = J(), te2, Uy = (te2 = {}, te2[W2.ATTRIBUTE] = true, te2[W2.CLASS] = true, te2[W2.COMBINATOR] = true, te2[W2.COMMENT] = true, te2[W2.ID] = true, te2[W2.NESTING] = true, te2[W2.PSEUDO] = true, te2[W2.ROOT] = true, te2[W2.SELECTOR] = true, te2[W2.STRING] = true, te2[W2.TAG] = true, te2[W2.UNIVERSAL] = true, te2);
  function os(t2) {
    return typeof t2 == "object" && Uy[t2.type];
  }
  function fe2(t2, e2) {
    return os(e2) && e2.type === t2;
  }
  var uu2 = fe2.bind(null, W2.ATTRIBUTE);
  D.isAttribute = uu2;
  var jy = fe2.bind(null, W2.CLASS);
  D.isClassName = jy;
  var zy = fe2.bind(null, W2.COMBINATOR);
  D.isCombinator = zy;
  var Vy = fe2.bind(null, W2.COMMENT);
  D.isComment = Vy;
  var Wy = fe2.bind(null, W2.ID);
  D.isIdentifier = Wy;
  var By = fe2.bind(null, W2.NESTING);
  D.isNesting = By;
  var ls = fe2.bind(null, W2.PSEUDO);
  D.isPseudo = ls;
  var Gy = fe2.bind(null, W2.ROOT);
  D.isRoot = Gy;
  var Yy = fe2.bind(null, W2.SELECTOR);
  D.isSelector = Yy;
  var Hy = fe2.bind(null, W2.STRING);
  D.isString = Hy;
  var fu2 = fe2.bind(null, W2.TAG);
  D.isTag = fu2;
  var Qy = fe2.bind(null, W2.UNIVERSAL);
  D.isUniversal = Qy;
  function cu2(t2) {
    return ls(t2) && t2.value && (t2.value.startsWith("::") || t2.value.toLowerCase() === ":before" || t2.value.toLowerCase() === ":after" || t2.value.toLowerCase() === ":first-letter" || t2.value.toLowerCase() === ":first-line");
  }
  function Jy(t2) {
    return ls(t2) && !cu2(t2);
  }
  function Xy(t2) {
    return !!(os(t2) && t2.walk);
  }
  function Ky(t2) {
    return uu2(t2) || fu2(t2);
  }
});
var du = S((de2) => {
  "use strict";
  de2.__esModule = true;
  var us = J();
  Object.keys(us).forEach(function(t2) {
    t2 === "default" || t2 === "__esModule" || t2 in de2 && de2[t2] === us[t2] || (de2[t2] = us[t2]);
  });
  var fs = lu();
  Object.keys(fs).forEach(function(t2) {
    t2 === "default" || t2 === "__esModule" || t2 in de2 && de2[t2] === fs[t2] || (de2[t2] = fs[t2]);
  });
  var cs = pu();
  Object.keys(cs).forEach(function(t2) {
    t2 === "default" || t2 === "__esModule" || t2 in de2 && de2[t2] === cs[t2] || (de2[t2] = cs[t2]);
  });
});
var ve = S((rr2, mu2) => {
  "use strict";
  rr2.__esModule = true;
  rr2.default = void 0;
  var Zy = r0(ou()), e0 = t0(du());
  function hu2(t2) {
    if (typeof WeakMap != "function")
      return null;
    var e2 = /* @__PURE__ */ new WeakMap(), r2 = /* @__PURE__ */ new WeakMap();
    return (hu2 = function(i2) {
      return i2 ? r2 : e2;
    })(t2);
  }
  function t0(t2, e2) {
    if (!e2 && t2 && t2.__esModule)
      return t2;
    if (t2 === null || typeof t2 != "object" && typeof t2 != "function")
      return { default: t2 };
    var r2 = hu2(e2);
    if (r2 && r2.has(t2))
      return r2.get(t2);
    var n2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var a2 in t2)
      if (a2 !== "default" && Object.prototype.hasOwnProperty.call(t2, a2)) {
        var s2 = i2 ? Object.getOwnPropertyDescriptor(t2, a2) : null;
        s2 && (s2.get || s2.set) ? Object.defineProperty(n2, a2, s2) : n2[a2] = t2[a2];
      }
    return n2.default = t2, r2 && r2.set(t2, n2), n2;
  }
  function r0(t2) {
    return t2 && t2.__esModule ? t2 : { default: t2 };
  }
  var ps = function(e2) {
    return new Zy.default(e2);
  };
  Object.assign(ps, e0);
  delete ps.__esModule;
  var n0 = ps;
  rr2.default = n0;
  mu2.exports = rr2.default;
});
var Su = S((Dx, ys) => {
  var { Rule: yu2, AtRule: i0 } = Ke(), vu2 = ve();
  function ms(t2, e2) {
    let r2;
    try {
      vu2((n2) => {
        r2 = n2;
      }).processSync(t2);
    } catch (n2) {
      throw t2.includes(":") ? e2 ? e2.error("Missed semicolon") : n2 : e2 ? e2.error(n2.message) : n2;
    }
    return r2.at(0);
  }
  function wu2(t2, e2) {
    let r2 = false;
    return t2.each((n2) => {
      if (n2.type === "nesting") {
        let i2 = e2.clone({});
        n2.value !== "&" ? n2.replaceWith(ms(n2.value.replace("&", i2.toString()))) : n2.replaceWith(i2), r2 = true;
      } else
        "nodes" in n2 && n2.nodes && wu2(n2, e2) && (r2 = true);
    }), r2;
  }
  function bu2(t2, e2) {
    let r2 = [];
    return t2.selectors.forEach((n2) => {
      let i2 = ms(n2, t2);
      e2.selectors.forEach((a2) => {
        if (!a2)
          return;
        let s2 = ms(a2, e2);
        wu2(s2, i2) || (s2.prepend(vu2.combinator({ value: " " })), s2.prepend(i2.clone({}))), r2.push(s2.toString());
      });
    }), r2;
  }
  function Zr2(t2, e2) {
    let r2 = t2.prev();
    for (e2.after(t2); r2 && r2.type === "comment"; ) {
      let n2 = r2.prev();
      e2.after(r2), r2 = n2;
    }
    return t2;
  }
  function s0(t2) {
    return function e2(r2, n2, i2, a2 = i2) {
      let s2 = [];
      if (n2.each((o2) => {
        o2.type === "rule" && i2 ? a2 && (o2.selectors = bu2(r2, o2)) : o2.type === "atrule" && o2.nodes ? t2[o2.name] ? e2(r2, o2, a2) : n2[gs] !== false && s2.push(o2) : s2.push(o2);
      }), i2 && s2.length) {
        let o2 = r2.clone({ nodes: [] });
        for (let l2 of s2)
          o2.append(l2);
        n2.prepend(o2);
      }
    };
  }
  function ds(t2, e2, r2) {
    let n2 = new yu2({ selector: t2, nodes: [] });
    return n2.append(e2), r2.after(n2), n2;
  }
  function gu2(t2, e2) {
    let r2 = {};
    for (let n2 of t2)
      r2[n2] = true;
    if (e2)
      for (let n2 of e2)
        r2[n2.replace(/^@/, "")] = true;
    return r2;
  }
  function a0(t2) {
    t2 = t2.trim();
    let e2 = t2.match(/^\((.*)\)$/);
    if (!e2)
      return { type: "basic", selector: t2 };
    let r2 = e2[1].match(/^(with(?:out)?):(.+)$/);
    if (r2) {
      let n2 = r2[1] === "with", i2 = Object.fromEntries(r2[2].trim().split(/\s+/).map((s2) => [s2, true]));
      if (n2 && i2.all)
        return { type: "noop" };
      let a2 = (s2) => !!i2[s2];
      return i2.all ? a2 = () => true : n2 && (a2 = (s2) => s2 === "all" ? false : !i2[s2]), { type: "withrules", escapes: a2 };
    }
    return { type: "unknown" };
  }
  function o0(t2) {
    let e2 = [], r2 = t2.parent;
    for (; r2 && r2 instanceof i0; )
      e2.push(r2), r2 = r2.parent;
    return e2;
  }
  function l0(t2) {
    let e2 = t2[xu2];
    if (!e2)
      t2.after(t2.nodes);
    else {
      let r2 = t2.nodes, n2, i2 = -1, a2, s2, o2, l2 = o0(t2);
      if (l2.forEach((u2, f2) => {
        if (e2(u2.name))
          n2 = u2, i2 = f2, s2 = o2;
        else {
          let p2 = o2;
          o2 = u2.clone({ nodes: [] }), p2 && o2.append(p2), a2 = a2 || o2;
        }
      }), n2 ? s2 ? (a2.append(r2), n2.after(s2)) : n2.after(r2) : t2.after(r2), t2.next() && n2) {
        let u2;
        l2.slice(0, i2 + 1).forEach((f2, p2, c2) => {
          let d2 = u2;
          u2 = f2.clone({ nodes: [] }), d2 && u2.append(d2);
          let h2 = [], m = (c2[p2 - 1] || t2).next();
          for (; m; )
            h2.push(m), m = m.next();
          u2.append(h2);
        }), u2 && (s2 || r2[r2.length - 1]).after(u2);
      }
    }
    t2.remove();
  }
  var gs = Symbol("rootRuleMergeSel"), xu2 = Symbol("rootRuleEscapes");
  function u0(t2) {
    let { params: e2 } = t2, { type: r2, selector: n2, escapes: i2 } = a0(e2);
    if (r2 === "unknown")
      throw t2.error(`Unknown @${t2.name} parameter ${JSON.stringify(e2)}`);
    if (r2 === "basic" && n2) {
      let a2 = new yu2({ selector: n2, nodes: t2.nodes });
      t2.removeAll(), t2.append(a2);
    }
    t2[xu2] = i2, t2[gs] = i2 ? !i2("all") : r2 === "noop";
  }
  var hs = Symbol("hasRootRule");
  ys.exports = (t2 = {}) => {
    let e2 = gu2(["media", "supports", "layer", "container"], t2.bubble), r2 = s0(e2), n2 = gu2(["document", "font-face", "keyframes", "-webkit-keyframes", "-moz-keyframes"], t2.unwrap), i2 = (t2.rootRuleName || "at-root").replace(/^@/, ""), a2 = t2.preserveEmpty;
    return { postcssPlugin: "postcss-nested", Once(s2) {
      s2.walkAtRules(i2, (o2) => {
        u0(o2), s2[hs] = true;
      });
    }, Rule(s2) {
      let o2 = false, l2 = s2, u2 = false, f2 = [];
      s2.each((p2) => {
        p2.type === "rule" ? (f2.length && (l2 = ds(s2.selector, f2, l2), f2 = []), u2 = true, o2 = true, p2.selectors = bu2(s2, p2), l2 = Zr2(p2, l2)) : p2.type === "atrule" ? (f2.length && (l2 = ds(s2.selector, f2, l2), f2 = []), p2.name === i2 ? (o2 = true, r2(s2, p2, true, p2[gs]), l2 = Zr2(p2, l2)) : e2[p2.name] ? (u2 = true, o2 = true, r2(s2, p2, true), l2 = Zr2(p2, l2)) : n2[p2.name] ? (u2 = true, o2 = true, r2(s2, p2, false), l2 = Zr2(p2, l2)) : u2 && f2.push(p2)) : p2.type === "decl" && u2 && f2.push(p2);
      }), f2.length && (l2 = ds(s2.selector, f2, l2)), o2 && a2 !== true && (s2.raws.semicolon = true, s2.nodes.length === 0 && s2.remove());
    }, RootExit(s2) {
      s2[hs] && (s2.walkAtRules(i2, l0), s2[hs] = false);
    } };
  };
  ys.exports.postcss = true;
});
var Cu = S((Mx, Eu2) => {
  "use strict";
  var ku2 = /-(\w|$)/g, Ou2 = function(e2, r2) {
    return r2.toUpperCase();
  }, f0 = function(e2) {
    return e2 = e2.toLowerCase(), e2 === "float" ? "cssFloat" : e2.charCodeAt(0) === 45 && e2.charCodeAt(1) === 109 && e2.charCodeAt(2) === 115 && e2.charCodeAt(3) === 45 ? e2.substr(1).replace(ku2, Ou2) : e2.replace(ku2, Ou2);
  };
  Eu2.exports = f0;
});
var bs = S((Fx, Au2) => {
  var c0 = Cu(), p0 = { boxFlex: true, boxFlexGroup: true, columnCount: true, flex: true, flexGrow: true, flexPositive: true, flexShrink: true, flexNegative: true, fontWeight: true, lineClamp: true, lineHeight: true, opacity: true, order: true, orphans: true, tabSize: true, widows: true, zIndex: true, zoom: true, fillOpacity: true, strokeDashoffset: true, strokeOpacity: true, strokeWidth: true };
  function vs(t2) {
    return typeof t2.nodes > "u" ? true : ws(t2);
  }
  function ws(t2) {
    let e2, r2 = {};
    return t2.each((n2) => {
      if (n2.type === "atrule")
        e2 = "@" + n2.name, n2.params && (e2 += " " + n2.params), typeof r2[e2] > "u" ? r2[e2] = vs(n2) : Array.isArray(r2[e2]) ? r2[e2].push(vs(n2)) : r2[e2] = [r2[e2], vs(n2)];
      else if (n2.type === "rule") {
        let i2 = ws(n2);
        if (r2[n2.selector])
          for (let a2 in i2)
            r2[n2.selector][a2] = i2[a2];
        else
          r2[n2.selector] = i2;
      } else if (n2.type === "decl") {
        n2.prop[0] === "-" && n2.prop[1] === "-" || n2.parent && n2.parent.selector === ":export" ? e2 = n2.prop : e2 = c0(n2.prop);
        let i2 = n2.value;
        !isNaN(n2.value) && p0[e2] && (i2 = parseFloat(n2.value)), n2.important && (i2 += " !important"), typeof r2[e2] > "u" ? r2[e2] = i2 : Array.isArray(r2[e2]) ? r2[e2].push(i2) : r2[e2] = [r2[e2], i2];
      }
    }), r2;
  }
  Au2.exports = ws;
});
var en = S((Lx, Iu2) => {
  var nr2 = Ke(), _u2 = /\s*!important\s*$/i, d0 = { "box-flex": true, "box-flex-group": true, "column-count": true, flex: true, "flex-grow": true, "flex-positive": true, "flex-shrink": true, "flex-negative": true, "font-weight": true, "line-clamp": true, "line-height": true, opacity: true, order: true, orphans: true, "tab-size": true, widows: true, "z-index": true, zoom: true, "fill-opacity": true, "stroke-dashoffset": true, "stroke-opacity": true, "stroke-width": true };
  function h0(t2) {
    return t2.replace(/([A-Z])/g, "-$1").replace(/^ms-/, "-ms-").toLowerCase();
  }
  function Tu2(t2, e2, r2) {
    r2 === false || r2 === null || (e2.startsWith("--") || (e2 = h0(e2)), typeof r2 == "number" && (r2 === 0 || d0[e2] ? r2 = r2.toString() : r2 += "px"), e2 === "css-float" && (e2 = "float"), _u2.test(r2) ? (r2 = r2.replace(_u2, ""), t2.push(nr2.decl({ prop: e2, value: r2, important: true }))) : t2.push(nr2.decl({ prop: e2, value: r2 })));
  }
  function Pu2(t2, e2, r2) {
    let n2 = nr2.atRule({ name: e2[1], params: e2[3] || "" });
    typeof r2 == "object" && (n2.nodes = [], xs(r2, n2)), t2.push(n2);
  }
  function xs(t2, e2) {
    let r2, n2, i2;
    for (r2 in t2)
      if (n2 = t2[r2], !(n2 === null || typeof n2 > "u"))
        if (r2[0] === "@") {
          let a2 = r2.match(/@(\S+)(\s+([\W\w]*)\s*)?/);
          if (Array.isArray(n2))
            for (let s2 of n2)
              Pu2(e2, a2, s2);
          else
            Pu2(e2, a2, n2);
        } else if (Array.isArray(n2))
          for (let a2 of n2)
            Tu2(e2, r2, a2);
        else
          typeof n2 == "object" ? (i2 = nr2.rule({ selector: r2 }), xs(n2, i2), e2.push(i2)) : Tu2(e2, r2, n2);
  }
  Iu2.exports = function(t2) {
    let e2 = nr2.root();
    return xs(t2, e2), e2;
  };
});
var Ss = S((Nx, Ru2) => {
  var m0 = bs();
  Ru2.exports = function(e2) {
    return console && console.warn && e2.warnings().forEach((r2) => {
      let n2 = r2.plugin || "PostCSS";
      console.warn(n2 + ": " + r2.text);
    }), m0(e2.root);
  };
});
var Mu = S((qx, Du2) => {
  var g0 = Ke(), y0 = Ss(), v0 = en();
  Du2.exports = function(e2) {
    let r2 = g0(e2);
    return async (n2) => {
      let i2 = await r2.process(n2, { parser: v0, from: void 0 });
      return y0(i2);
    };
  };
});
var Lu = S(($x, Fu2) => {
  var w0 = Ke(), b0 = Ss(), x0 = en();
  Fu2.exports = function(t2) {
    let e2 = w0(t2);
    return (r2) => {
      let n2 = e2.process(r2, { parser: x0, from: void 0 });
      return b0(n2);
    };
  };
});
var qu = S((Ux, Nu2) => {
  var S0 = bs(), k0 = en(), O0 = Mu(), E0 = Lu();
  Nu2.exports = { objectify: S0, parse: k0, async: O0, sync: E0 };
});
var qs = S((Ls, Ns) => {
  (function(t2, e2) {
    typeof Ls == "object" && typeof Ns < "u" ? Ns.exports = function(r2, n2, i2, a2, s2) {
      for (n2 = n2.split ? n2.split(".") : n2, a2 = 0; a2 < n2.length; a2++)
        r2 = r2 ? r2[n2[a2]] : s2;
      return r2 === s2 ? i2 : r2;
    } : typeof define == "function" && define.amd ? define(function() {
      return function(r2, n2, i2, a2, s2) {
        for (n2 = n2.split ? n2.split(".") : n2, a2 = 0; a2 < n2.length; a2++)
          r2 = r2 ? r2[n2[a2]] : s2;
        return r2 === s2 ? i2 : r2;
      };
    }) : t2.dlv = function(r2, n2, i2, a2, s2) {
      for (n2 = n2.split ? n2.split(".") : n2, a2 = 0; a2 < n2.length; a2++)
        r2 = r2 ? r2[n2[a2]] : s2;
      return r2 === s2 ? i2 : r2;
    };
  })(Ls);
});
var Bf = S((bk, On2) => {
  (function() {
    "use strict";
    function t2(n2, i2, a2) {
      if (!n2)
        return null;
      t2.caseSensitive || (n2 = n2.toLowerCase());
      var s2 = t2.threshold === null ? null : t2.threshold * n2.length, o2 = t2.thresholdAbsolute, l2;
      s2 !== null && o2 !== null ? l2 = Math.min(s2, o2) : s2 !== null ? l2 = s2 : o2 !== null ? l2 = o2 : l2 = null;
      var u2, f2, p2, c2, d2, h2 = i2.length;
      for (d2 = 0; d2 < h2; d2++)
        if (f2 = i2[d2], a2 && (f2 = f2[a2]), !!f2 && (t2.caseSensitive ? p2 = f2 : p2 = f2.toLowerCase(), c2 = r2(n2, p2, l2), (l2 === null || c2 < l2) && (l2 = c2, a2 && t2.returnWinningObject ? u2 = i2[d2] : u2 = f2, t2.returnFirstMatch)))
          return u2;
      return u2 || t2.nullResultValue;
    }
    t2.threshold = 0.4, t2.thresholdAbsolute = 20, t2.caseSensitive = false, t2.nullResultValue = null, t2.returnWinningObject = null, t2.returnFirstMatch = false, typeof On2 < "u" && On2.exports ? On2.exports = t2 : window.didYouMean = t2;
    var e2 = Math.pow(2, 32) - 1;
    function r2(n2, i2, a2) {
      a2 = a2 || a2 === 0 ? a2 : e2;
      var s2 = n2.length, o2 = i2.length;
      if (s2 === 0)
        return Math.min(a2 + 1, o2);
      if (o2 === 0)
        return Math.min(a2 + 1, s2);
      if (Math.abs(s2 - o2) > a2)
        return a2 + 1;
      var l2 = [], u2, f2, p2, c2, d2;
      for (u2 = 0; u2 <= o2; u2++)
        l2[u2] = [u2];
      for (f2 = 0; f2 <= s2; f2++)
        l2[0][f2] = f2;
      for (u2 = 1; u2 <= o2; u2++) {
        for (p2 = e2, c2 = 1, u2 > a2 && (c2 = u2 - a2), d2 = o2 + 1, d2 > a2 + u2 && (d2 = a2 + u2), f2 = 1; f2 <= s2; f2++)
          f2 < c2 || f2 > d2 ? l2[u2][f2] = a2 + 1 : i2.charAt(u2 - 1) === n2.charAt(f2 - 1) ? l2[u2][f2] = l2[u2 - 1][f2 - 1] : l2[u2][f2] = Math.min(l2[u2 - 1][f2 - 1] + 1, Math.min(l2[u2][f2 - 1] + 1, l2[u2 - 1][f2] + 1)), l2[u2][f2] < p2 && (p2 = l2[u2][f2]);
        if (p2 > a2)
          return a2 + 1;
      }
      return l2[o2][s2];
    }
  })();
});
var Yf = S((xk, Gf) => {
  var Ks = "(".charCodeAt(0), Zs = ")".charCodeAt(0), En2 = "'".charCodeAt(0), ea = '"'.charCodeAt(0), ta = "\\".charCodeAt(0), ft2 = "/".charCodeAt(0), ra = ",".charCodeAt(0), na = ":".charCodeAt(0), Cn2 = "*".charCodeAt(0), Yv = "u".charCodeAt(0), Hv = "U".charCodeAt(0), Qv = "+".charCodeAt(0), Jv = /^[a-f0-9?-]+$/i;
  Gf.exports = function(t2) {
    for (var e2 = [], r2 = t2, n2, i2, a2, s2, o2, l2, u2, f2, p2 = 0, c2 = r2.charCodeAt(p2), d2 = r2.length, h2 = [{ nodes: e2 }], y3 = 0, m, g2 = "", w2 = "", b3 = ""; p2 < d2; )
      if (c2 <= 32) {
        n2 = p2;
        do
          n2 += 1, c2 = r2.charCodeAt(n2);
        while (c2 <= 32);
        s2 = r2.slice(p2, n2), a2 = e2[e2.length - 1], c2 === Zs && y3 ? b3 = s2 : a2 && a2.type === "div" ? (a2.after = s2, a2.sourceEndIndex += s2.length) : c2 === ra || c2 === na || c2 === ft2 && r2.charCodeAt(n2 + 1) !== Cn2 && (!m || m && m.type === "function" && m.value !== "calc") ? w2 = s2 : e2.push({ type: "space", sourceIndex: p2, sourceEndIndex: n2, value: s2 }), p2 = n2;
      } else if (c2 === En2 || c2 === ea) {
        n2 = p2, i2 = c2 === En2 ? "'" : '"', s2 = { type: "string", sourceIndex: p2, quote: i2 };
        do
          if (o2 = false, n2 = r2.indexOf(i2, n2 + 1), ~n2)
            for (l2 = n2; r2.charCodeAt(l2 - 1) === ta; )
              l2 -= 1, o2 = !o2;
          else
            r2 += i2, n2 = r2.length - 1, s2.unclosed = true;
        while (o2);
        s2.value = r2.slice(p2 + 1, n2), s2.sourceEndIndex = s2.unclosed ? n2 : n2 + 1, e2.push(s2), p2 = n2 + 1, c2 = r2.charCodeAt(p2);
      } else if (c2 === ft2 && r2.charCodeAt(p2 + 1) === Cn2)
        n2 = r2.indexOf("*/", p2), s2 = { type: "comment", sourceIndex: p2, sourceEndIndex: n2 + 2 }, n2 === -1 && (s2.unclosed = true, n2 = r2.length, s2.sourceEndIndex = n2), s2.value = r2.slice(p2 + 2, n2), e2.push(s2), p2 = n2 + 2, c2 = r2.charCodeAt(p2);
      else if ((c2 === ft2 || c2 === Cn2) && m && m.type === "function" && m.value === "calc")
        s2 = r2[p2], e2.push({ type: "word", sourceIndex: p2 - w2.length, sourceEndIndex: p2 + s2.length, value: s2 }), p2 += 1, c2 = r2.charCodeAt(p2);
      else if (c2 === ft2 || c2 === ra || c2 === na)
        s2 = r2[p2], e2.push({ type: "div", sourceIndex: p2 - w2.length, sourceEndIndex: p2 + s2.length, value: s2, before: w2, after: "" }), w2 = "", p2 += 1, c2 = r2.charCodeAt(p2);
      else if (Ks === c2) {
        n2 = p2;
        do
          n2 += 1, c2 = r2.charCodeAt(n2);
        while (c2 <= 32);
        if (f2 = p2, s2 = { type: "function", sourceIndex: p2 - g2.length, value: g2, before: r2.slice(f2 + 1, n2) }, p2 = n2, g2 === "url" && c2 !== En2 && c2 !== ea) {
          n2 -= 1;
          do
            if (o2 = false, n2 = r2.indexOf(")", n2 + 1), ~n2)
              for (l2 = n2; r2.charCodeAt(l2 - 1) === ta; )
                l2 -= 1, o2 = !o2;
            else
              r2 += ")", n2 = r2.length - 1, s2.unclosed = true;
          while (o2);
          u2 = n2;
          do
            u2 -= 1, c2 = r2.charCodeAt(u2);
          while (c2 <= 32);
          f2 < u2 ? (p2 !== u2 + 1 ? s2.nodes = [{ type: "word", sourceIndex: p2, sourceEndIndex: u2 + 1, value: r2.slice(p2, u2 + 1) }] : s2.nodes = [], s2.unclosed && u2 + 1 !== n2 ? (s2.after = "", s2.nodes.push({ type: "space", sourceIndex: u2 + 1, sourceEndIndex: n2, value: r2.slice(u2 + 1, n2) })) : (s2.after = r2.slice(u2 + 1, n2), s2.sourceEndIndex = n2)) : (s2.after = "", s2.nodes = []), p2 = n2 + 1, s2.sourceEndIndex = s2.unclosed ? n2 : p2, c2 = r2.charCodeAt(p2), e2.push(s2);
        } else
          y3 += 1, s2.after = "", s2.sourceEndIndex = p2 + 1, e2.push(s2), h2.push(s2), e2 = s2.nodes = [], m = s2;
        g2 = "";
      } else if (Zs === c2 && y3)
        p2 += 1, c2 = r2.charCodeAt(p2), m.after = b3, m.sourceEndIndex += b3.length, b3 = "", y3 -= 1, h2[h2.length - 1].sourceEndIndex = p2, h2.pop(), m = h2[y3], e2 = m.nodes;
      else {
        n2 = p2;
        do
          c2 === ta && (n2 += 1), n2 += 1, c2 = r2.charCodeAt(n2);
        while (n2 < d2 && !(c2 <= 32 || c2 === En2 || c2 === ea || c2 === ra || c2 === na || c2 === ft2 || c2 === Ks || c2 === Cn2 && m && m.type === "function" && m.value === "calc" || c2 === ft2 && m.type === "function" && m.value === "calc" || c2 === Zs && y3));
        s2 = r2.slice(p2, n2), Ks === c2 ? g2 = s2 : (Yv === s2.charCodeAt(0) || Hv === s2.charCodeAt(0)) && Qv === s2.charCodeAt(1) && Jv.test(s2.slice(2)) ? e2.push({ type: "unicode-range", sourceIndex: p2, sourceEndIndex: n2, value: s2 }) : e2.push({ type: "word", sourceIndex: p2, sourceEndIndex: n2, value: s2 }), p2 = n2;
      }
    for (p2 = h2.length - 1; p2; p2 -= 1)
      h2[p2].unclosed = true, h2[p2].sourceEndIndex = r2.length;
    return h2[0].nodes;
  };
});
var Qf = S((Sk, Hf) => {
  Hf.exports = function t2(e2, r2, n2) {
    var i2, a2, s2, o2;
    for (i2 = 0, a2 = e2.length; i2 < a2; i2 += 1)
      s2 = e2[i2], n2 || (o2 = r2(s2, i2, e2)), o2 !== false && s2.type === "function" && Array.isArray(s2.nodes) && t2(s2.nodes, r2, n2), n2 && r2(s2, i2, e2);
  };
});
var Zf = S((kk, Kf) => {
  function Jf(t2, e2) {
    var r2 = t2.type, n2 = t2.value, i2, a2;
    return e2 && (a2 = e2(t2)) !== void 0 ? a2 : r2 === "word" || r2 === "space" ? n2 : r2 === "string" ? (i2 = t2.quote || "", i2 + n2 + (t2.unclosed ? "" : i2)) : r2 === "comment" ? "/*" + n2 + (t2.unclosed ? "" : "*/") : r2 === "div" ? (t2.before || "") + n2 + (t2.after || "") : Array.isArray(t2.nodes) ? (i2 = Xf(t2.nodes, e2), r2 !== "function" ? i2 : n2 + "(" + (t2.before || "") + i2 + (t2.after || "") + (t2.unclosed ? "" : ")")) : n2;
  }
  function Xf(t2, e2) {
    var r2, n2;
    if (Array.isArray(t2)) {
      for (r2 = "", n2 = t2.length - 1; ~n2; n2 -= 1)
        r2 = Jf(t2[n2], e2) + r2;
      return r2;
    }
    return Jf(t2, e2);
  }
  Kf.exports = Xf;
});
var tc = S((Ok, ec) => {
  var An2 = "-".charCodeAt(0), _n2 = "+".charCodeAt(0), ia = ".".charCodeAt(0), Xv = "e".charCodeAt(0), Kv = "E".charCodeAt(0);
  function Zv(t2) {
    var e2 = t2.charCodeAt(0), r2;
    if (e2 === _n2 || e2 === An2) {
      if (r2 = t2.charCodeAt(1), r2 >= 48 && r2 <= 57)
        return true;
      var n2 = t2.charCodeAt(2);
      return r2 === ia && n2 >= 48 && n2 <= 57;
    }
    return e2 === ia ? (r2 = t2.charCodeAt(1), r2 >= 48 && r2 <= 57) : e2 >= 48 && e2 <= 57;
  }
  ec.exports = function(t2) {
    var e2 = 0, r2 = t2.length, n2, i2, a2;
    if (r2 === 0 || !Zv(t2))
      return false;
    for (n2 = t2.charCodeAt(e2), (n2 === _n2 || n2 === An2) && e2++; e2 < r2 && (n2 = t2.charCodeAt(e2), !(n2 < 48 || n2 > 57)); )
      e2 += 1;
    if (n2 = t2.charCodeAt(e2), i2 = t2.charCodeAt(e2 + 1), n2 === ia && i2 >= 48 && i2 <= 57)
      for (e2 += 2; e2 < r2 && (n2 = t2.charCodeAt(e2), !(n2 < 48 || n2 > 57)); )
        e2 += 1;
    if (n2 = t2.charCodeAt(e2), i2 = t2.charCodeAt(e2 + 1), a2 = t2.charCodeAt(e2 + 2), (n2 === Xv || n2 === Kv) && (i2 >= 48 && i2 <= 57 || (i2 === _n2 || i2 === An2) && a2 >= 48 && a2 <= 57))
      for (e2 += i2 === _n2 || i2 === An2 ? 3 : 2; e2 < r2 && (n2 = t2.charCodeAt(e2), !(n2 < 48 || n2 > 57)); )
        e2 += 1;
    return { number: t2.slice(0, e2), unit: t2.slice(e2) };
  };
});
var sc = S((Ek, ic) => {
  var ew = Yf(), rc = Qf(), nc = Zf();
  function Ne2(t2) {
    return this instanceof Ne2 ? (this.nodes = ew(t2), this) : new Ne2(t2);
  }
  Ne2.prototype.toString = function() {
    return Array.isArray(this.nodes) ? nc(this.nodes) : "";
  };
  Ne2.prototype.walk = function(t2, e2) {
    return rc(this.nodes, t2, e2), this;
  };
  Ne2.unit = tc();
  Ne2.walk = rc;
  Ne2.stringify = nc;
  ic.exports = Ne2;
});
var Sc = S((CO, xc) => {
  xc.exports = { content: [], presets: [], darkMode: "media", theme: { accentColor: ({ theme: t2 }) => ({ ...t2("colors"), auto: "auto" }), animation: { none: "none", spin: "spin 1s linear infinite", ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite", pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite", bounce: "bounce 1s infinite" }, aria: { checked: 'checked="true"', disabled: 'disabled="true"', expanded: 'expanded="true"', hidden: 'hidden="true"', pressed: 'pressed="true"', readonly: 'readonly="true"', required: 'required="true"', selected: 'selected="true"' }, aspectRatio: { auto: "auto", square: "1 / 1", video: "16 / 9" }, backdropBlur: ({ theme: t2 }) => t2("blur"), backdropBrightness: ({ theme: t2 }) => t2("brightness"), backdropContrast: ({ theme: t2 }) => t2("contrast"), backdropGrayscale: ({ theme: t2 }) => t2("grayscale"), backdropHueRotate: ({ theme: t2 }) => t2("hueRotate"), backdropInvert: ({ theme: t2 }) => t2("invert"), backdropOpacity: ({ theme: t2 }) => t2("opacity"), backdropSaturate: ({ theme: t2 }) => t2("saturate"), backdropSepia: ({ theme: t2 }) => t2("sepia"), backgroundColor: ({ theme: t2 }) => t2("colors"), backgroundImage: { none: "none", "gradient-to-t": "linear-gradient(to top, var(--tw-gradient-stops))", "gradient-to-tr": "linear-gradient(to top right, var(--tw-gradient-stops))", "gradient-to-r": "linear-gradient(to right, var(--tw-gradient-stops))", "gradient-to-br": "linear-gradient(to bottom right, var(--tw-gradient-stops))", "gradient-to-b": "linear-gradient(to bottom, var(--tw-gradient-stops))", "gradient-to-bl": "linear-gradient(to bottom left, var(--tw-gradient-stops))", "gradient-to-l": "linear-gradient(to left, var(--tw-gradient-stops))", "gradient-to-tl": "linear-gradient(to top left, var(--tw-gradient-stops))" }, backgroundOpacity: ({ theme: t2 }) => t2("opacity"), backgroundPosition: { bottom: "bottom", center: "center", left: "left", "left-bottom": "left bottom", "left-top": "left top", right: "right", "right-bottom": "right bottom", "right-top": "right top", top: "top" }, backgroundSize: { auto: "auto", cover: "cover", contain: "contain" }, blur: { 0: "0", none: "0", sm: "4px", DEFAULT: "8px", md: "12px", lg: "16px", xl: "24px", "2xl": "40px", "3xl": "64px" }, borderColor: ({ theme: t2 }) => ({ ...t2("colors"), DEFAULT: t2("colors.gray.200", "currentColor") }), borderOpacity: ({ theme: t2 }) => t2("opacity"), borderRadius: { none: "0px", sm: "0.125rem", DEFAULT: "0.25rem", md: "0.375rem", lg: "0.5rem", xl: "0.75rem", "2xl": "1rem", "3xl": "1.5rem", full: "9999px" }, borderSpacing: ({ theme: t2 }) => ({ ...t2("spacing") }), borderWidth: { DEFAULT: "1px", 0: "0px", 2: "2px", 4: "4px", 8: "8px" }, boxShadow: { sm: "0 1px 2px 0 rgb(0 0 0 / 0.05)", DEFAULT: "0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)", md: "0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)", lg: "0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)", xl: "0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)", "2xl": "0 25px 50px -12px rgb(0 0 0 / 0.25)", inner: "inset 0 2px 4px 0 rgb(0 0 0 / 0.05)", none: "none" }, boxShadowColor: ({ theme: t2 }) => t2("colors"), brightness: { 0: "0", 50: ".5", 75: ".75", 90: ".9", 95: ".95", 100: "1", 105: "1.05", 110: "1.1", 125: "1.25", 150: "1.5", 200: "2" }, caretColor: ({ theme: t2 }) => t2("colors"), colors: ({ colors: t2 }) => ({ inherit: t2.inherit, current: t2.current, transparent: t2.transparent, black: t2.black, white: t2.white, slate: t2.slate, gray: t2.gray, zinc: t2.zinc, neutral: t2.neutral, stone: t2.stone, red: t2.red, orange: t2.orange, amber: t2.amber, yellow: t2.yellow, lime: t2.lime, green: t2.green, emerald: t2.emerald, teal: t2.teal, cyan: t2.cyan, sky: t2.sky, blue: t2.blue, indigo: t2.indigo, violet: t2.violet, purple: t2.purple, fuchsia: t2.fuchsia, pink: t2.pink, rose: t2.rose }), columns: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", "3xs": "16rem", "2xs": "18rem", xs: "20rem", sm: "24rem", md: "28rem", lg: "32rem", xl: "36rem", "2xl": "42rem", "3xl": "48rem", "4xl": "56rem", "5xl": "64rem", "6xl": "72rem", "7xl": "80rem" }, container: {}, content: { none: "none" }, contrast: { 0: "0", 50: ".5", 75: ".75", 100: "1", 125: "1.25", 150: "1.5", 200: "2" }, cursor: { auto: "auto", default: "default", pointer: "pointer", wait: "wait", text: "text", move: "move", help: "help", "not-allowed": "not-allowed", none: "none", "context-menu": "context-menu", progress: "progress", cell: "cell", crosshair: "crosshair", "vertical-text": "vertical-text", alias: "alias", copy: "copy", "no-drop": "no-drop", grab: "grab", grabbing: "grabbing", "all-scroll": "all-scroll", "col-resize": "col-resize", "row-resize": "row-resize", "n-resize": "n-resize", "e-resize": "e-resize", "s-resize": "s-resize", "w-resize": "w-resize", "ne-resize": "ne-resize", "nw-resize": "nw-resize", "se-resize": "se-resize", "sw-resize": "sw-resize", "ew-resize": "ew-resize", "ns-resize": "ns-resize", "nesw-resize": "nesw-resize", "nwse-resize": "nwse-resize", "zoom-in": "zoom-in", "zoom-out": "zoom-out" }, divideColor: ({ theme: t2 }) => t2("borderColor"), divideOpacity: ({ theme: t2 }) => t2("borderOpacity"), divideWidth: ({ theme: t2 }) => t2("borderWidth"), dropShadow: { sm: "0 1px 1px rgb(0 0 0 / 0.05)", DEFAULT: ["0 1px 2px rgb(0 0 0 / 0.1)", "0 1px 1px rgb(0 0 0 / 0.06)"], md: ["0 4px 3px rgb(0 0 0 / 0.07)", "0 2px 2px rgb(0 0 0 / 0.06)"], lg: ["0 10px 8px rgb(0 0 0 / 0.04)", "0 4px 3px rgb(0 0 0 / 0.1)"], xl: ["0 20px 13px rgb(0 0 0 / 0.03)", "0 8px 5px rgb(0 0 0 / 0.08)"], "2xl": "0 25px 25px rgb(0 0 0 / 0.15)", none: "0 0 #0000" }, fill: ({ theme: t2 }) => ({ none: "none", ...t2("colors") }), flex: { 1: "1 1 0%", auto: "1 1 auto", initial: "0 1 auto", none: "none" }, flexBasis: ({ theme: t2 }) => ({ auto: "auto", ...t2("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", "1/12": "8.333333%", "2/12": "16.666667%", "3/12": "25%", "4/12": "33.333333%", "5/12": "41.666667%", "6/12": "50%", "7/12": "58.333333%", "8/12": "66.666667%", "9/12": "75%", "10/12": "83.333333%", "11/12": "91.666667%", full: "100%" }), flexGrow: { 0: "0", DEFAULT: "1" }, flexShrink: { 0: "0", DEFAULT: "1" }, fontFamily: { sans: ["ui-sans-serif", "system-ui", "-apple-system", "BlinkMacSystemFont", '"Segoe UI"', "Roboto", '"Helvetica Neue"', "Arial", '"Noto Sans"', "sans-serif", '"Apple Color Emoji"', '"Segoe UI Emoji"', '"Segoe UI Symbol"', '"Noto Color Emoji"'], serif: ["ui-serif", "Georgia", "Cambria", '"Times New Roman"', "Times", "serif"], mono: ["ui-monospace", "SFMono-Regular", "Menlo", "Monaco", "Consolas", '"Liberation Mono"', '"Courier New"', "monospace"] }, fontSize: { xs: ["0.75rem", { lineHeight: "1rem" }], sm: ["0.875rem", { lineHeight: "1.25rem" }], base: ["1rem", { lineHeight: "1.5rem" }], lg: ["1.125rem", { lineHeight: "1.75rem" }], xl: ["1.25rem", { lineHeight: "1.75rem" }], "2xl": ["1.5rem", { lineHeight: "2rem" }], "3xl": ["1.875rem", { lineHeight: "2.25rem" }], "4xl": ["2.25rem", { lineHeight: "2.5rem" }], "5xl": ["3rem", { lineHeight: "1" }], "6xl": ["3.75rem", { lineHeight: "1" }], "7xl": ["4.5rem", { lineHeight: "1" }], "8xl": ["6rem", { lineHeight: "1" }], "9xl": ["8rem", { lineHeight: "1" }] }, fontWeight: { thin: "100", extralight: "200", light: "300", normal: "400", medium: "500", semibold: "600", bold: "700", extrabold: "800", black: "900" }, gap: ({ theme: t2 }) => t2("spacing"), gradientColorStops: ({ theme: t2 }) => t2("colors"), gradientColorStopPositions: { "0%": "0%", "5%": "5%", "10%": "10%", "15%": "15%", "20%": "20%", "25%": "25%", "30%": "30%", "35%": "35%", "40%": "40%", "45%": "45%", "50%": "50%", "55%": "55%", "60%": "60%", "65%": "65%", "70%": "70%", "75%": "75%", "80%": "80%", "85%": "85%", "90%": "90%", "95%": "95%", "100%": "100%" }, grayscale: { 0: "0", DEFAULT: "100%" }, gridAutoColumns: { auto: "auto", min: "min-content", max: "max-content", fr: "minmax(0, 1fr)" }, gridAutoRows: { auto: "auto", min: "min-content", max: "max-content", fr: "minmax(0, 1fr)" }, gridColumn: { auto: "auto", "span-1": "span 1 / span 1", "span-2": "span 2 / span 2", "span-3": "span 3 / span 3", "span-4": "span 4 / span 4", "span-5": "span 5 / span 5", "span-6": "span 6 / span 6", "span-7": "span 7 / span 7", "span-8": "span 8 / span 8", "span-9": "span 9 / span 9", "span-10": "span 10 / span 10", "span-11": "span 11 / span 11", "span-12": "span 12 / span 12", "span-full": "1 / -1" }, gridColumnEnd: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", 13: "13" }, gridColumnStart: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12", 13: "13" }, gridRow: { auto: "auto", "span-1": "span 1 / span 1", "span-2": "span 2 / span 2", "span-3": "span 3 / span 3", "span-4": "span 4 / span 4", "span-5": "span 5 / span 5", "span-6": "span 6 / span 6", "span-full": "1 / -1" }, gridRowEnd: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7" }, gridRowStart: { auto: "auto", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7" }, gridTemplateColumns: { none: "none", 1: "repeat(1, minmax(0, 1fr))", 2: "repeat(2, minmax(0, 1fr))", 3: "repeat(3, minmax(0, 1fr))", 4: "repeat(4, minmax(0, 1fr))", 5: "repeat(5, minmax(0, 1fr))", 6: "repeat(6, minmax(0, 1fr))", 7: "repeat(7, minmax(0, 1fr))", 8: "repeat(8, minmax(0, 1fr))", 9: "repeat(9, minmax(0, 1fr))", 10: "repeat(10, minmax(0, 1fr))", 11: "repeat(11, minmax(0, 1fr))", 12: "repeat(12, minmax(0, 1fr))" }, gridTemplateRows: { none: "none", 1: "repeat(1, minmax(0, 1fr))", 2: "repeat(2, minmax(0, 1fr))", 3: "repeat(3, minmax(0, 1fr))", 4: "repeat(4, minmax(0, 1fr))", 5: "repeat(5, minmax(0, 1fr))", 6: "repeat(6, minmax(0, 1fr))" }, height: ({ theme: t2 }) => ({ auto: "auto", ...t2("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", full: "100%", screen: "100vh", min: "min-content", max: "max-content", fit: "fit-content" }), hueRotate: { 0: "0deg", 15: "15deg", 30: "30deg", 60: "60deg", 90: "90deg", 180: "180deg" }, inset: ({ theme: t2 }) => ({ auto: "auto", ...t2("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", full: "100%" }), invert: { 0: "0", DEFAULT: "100%" }, keyframes: { spin: { to: { transform: "rotate(360deg)" } }, ping: { "75%, 100%": { transform: "scale(2)", opacity: "0" } }, pulse: { "50%": { opacity: ".5" } }, bounce: { "0%, 100%": { transform: "translateY(-25%)", animationTimingFunction: "cubic-bezier(0.8,0,1,1)" }, "50%": { transform: "none", animationTimingFunction: "cubic-bezier(0,0,0.2,1)" } } }, letterSpacing: { tighter: "-0.05em", tight: "-0.025em", normal: "0em", wide: "0.025em", wider: "0.05em", widest: "0.1em" }, lineHeight: { none: "1", tight: "1.25", snug: "1.375", normal: "1.5", relaxed: "1.625", loose: "2", 3: ".75rem", 4: "1rem", 5: "1.25rem", 6: "1.5rem", 7: "1.75rem", 8: "2rem", 9: "2.25rem", 10: "2.5rem" }, listStyleType: { none: "none", disc: "disc", decimal: "decimal" }, listStyleImage: { none: "none" }, margin: ({ theme: t2 }) => ({ auto: "auto", ...t2("spacing") }), lineClamp: { 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6" }, maxHeight: ({ theme: t2 }) => ({ ...t2("spacing"), none: "none", full: "100%", screen: "100vh", min: "min-content", max: "max-content", fit: "fit-content" }), maxWidth: ({ theme: t2, breakpoints: e2 }) => ({ none: "none", 0: "0rem", xs: "20rem", sm: "24rem", md: "28rem", lg: "32rem", xl: "36rem", "2xl": "42rem", "3xl": "48rem", "4xl": "56rem", "5xl": "64rem", "6xl": "72rem", "7xl": "80rem", full: "100%", min: "min-content", max: "max-content", fit: "fit-content", prose: "65ch", ...e2(t2("screens")) }), minHeight: { 0: "0px", full: "100%", screen: "100vh", min: "min-content", max: "max-content", fit: "fit-content" }, minWidth: { 0: "0px", full: "100%", min: "min-content", max: "max-content", fit: "fit-content" }, objectPosition: { bottom: "bottom", center: "center", left: "left", "left-bottom": "left bottom", "left-top": "left top", right: "right", "right-bottom": "right bottom", "right-top": "right top", top: "top" }, opacity: { 0: "0", 5: "0.05", 10: "0.1", 20: "0.2", 25: "0.25", 30: "0.3", 40: "0.4", 50: "0.5", 60: "0.6", 70: "0.7", 75: "0.75", 80: "0.8", 90: "0.9", 95: "0.95", 100: "1" }, order: { first: "-9999", last: "9999", none: "0", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 10: "10", 11: "11", 12: "12" }, outlineColor: ({ theme: t2 }) => t2("colors"), outlineOffset: { 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, outlineWidth: { 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, padding: ({ theme: t2 }) => t2("spacing"), placeholderColor: ({ theme: t2 }) => t2("colors"), placeholderOpacity: ({ theme: t2 }) => t2("opacity"), ringColor: ({ theme: t2 }) => ({ DEFAULT: t2("colors.blue.500", "#3b82f6"), ...t2("colors") }), ringOffsetColor: ({ theme: t2 }) => t2("colors"), ringOffsetWidth: { 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, ringOpacity: ({ theme: t2 }) => ({ DEFAULT: "0.5", ...t2("opacity") }), ringWidth: { DEFAULT: "3px", 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, rotate: { 0: "0deg", 1: "1deg", 2: "2deg", 3: "3deg", 6: "6deg", 12: "12deg", 45: "45deg", 90: "90deg", 180: "180deg" }, saturate: { 0: "0", 50: ".5", 100: "1", 150: "1.5", 200: "2" }, scale: { 0: "0", 50: ".5", 75: ".75", 90: ".9", 95: ".95", 100: "1", 105: "1.05", 110: "1.1", 125: "1.25", 150: "1.5" }, screens: { sm: "640px", md: "768px", lg: "1024px", xl: "1280px", "2xl": "1536px" }, scrollMargin: ({ theme: t2 }) => ({ ...t2("spacing") }), scrollPadding: ({ theme: t2 }) => t2("spacing"), sepia: { 0: "0", DEFAULT: "100%" }, skew: { 0: "0deg", 1: "1deg", 2: "2deg", 3: "3deg", 6: "6deg", 12: "12deg" }, space: ({ theme: t2 }) => ({ ...t2("spacing") }), spacing: { px: "1px", 0: "0px", 0.5: "0.125rem", 1: "0.25rem", 1.5: "0.375rem", 2: "0.5rem", 2.5: "0.625rem", 3: "0.75rem", 3.5: "0.875rem", 4: "1rem", 5: "1.25rem", 6: "1.5rem", 7: "1.75rem", 8: "2rem", 9: "2.25rem", 10: "2.5rem", 11: "2.75rem", 12: "3rem", 14: "3.5rem", 16: "4rem", 20: "5rem", 24: "6rem", 28: "7rem", 32: "8rem", 36: "9rem", 40: "10rem", 44: "11rem", 48: "12rem", 52: "13rem", 56: "14rem", 60: "15rem", 64: "16rem", 72: "18rem", 80: "20rem", 96: "24rem" }, stroke: ({ theme: t2 }) => ({ none: "none", ...t2("colors") }), strokeWidth: { 0: "0", 1: "1", 2: "2" }, supports: {}, data: {}, textColor: ({ theme: t2 }) => t2("colors"), textDecorationColor: ({ theme: t2 }) => t2("colors"), textDecorationThickness: { auto: "auto", "from-font": "from-font", 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, textIndent: ({ theme: t2 }) => ({ ...t2("spacing") }), textOpacity: ({ theme: t2 }) => t2("opacity"), textUnderlineOffset: { auto: "auto", 0: "0px", 1: "1px", 2: "2px", 4: "4px", 8: "8px" }, transformOrigin: { center: "center", top: "top", "top-right": "top right", right: "right", "bottom-right": "bottom right", bottom: "bottom", "bottom-left": "bottom left", left: "left", "top-left": "top left" }, transitionDelay: { 0: "0s", 75: "75ms", 100: "100ms", 150: "150ms", 200: "200ms", 300: "300ms", 500: "500ms", 700: "700ms", 1e3: "1000ms" }, transitionDuration: { DEFAULT: "150ms", 0: "0s", 75: "75ms", 100: "100ms", 150: "150ms", 200: "200ms", 300: "300ms", 500: "500ms", 700: "700ms", 1e3: "1000ms" }, transitionProperty: { none: "none", all: "all", DEFAULT: "color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter", colors: "color, background-color, border-color, text-decoration-color, fill, stroke", opacity: "opacity", shadow: "box-shadow", transform: "transform" }, transitionTimingFunction: { DEFAULT: "cubic-bezier(0.4, 0, 0.2, 1)", linear: "linear", in: "cubic-bezier(0.4, 0, 1, 1)", out: "cubic-bezier(0, 0, 0.2, 1)", "in-out": "cubic-bezier(0.4, 0, 0.2, 1)" }, translate: ({ theme: t2 }) => ({ ...t2("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", full: "100%" }), width: ({ theme: t2 }) => ({ auto: "auto", ...t2("spacing"), "1/2": "50%", "1/3": "33.333333%", "2/3": "66.666667%", "1/4": "25%", "2/4": "50%", "3/4": "75%", "1/5": "20%", "2/5": "40%", "3/5": "60%", "4/5": "80%", "1/6": "16.666667%", "2/6": "33.333333%", "3/6": "50%", "4/6": "66.666667%", "5/6": "83.333333%", "1/12": "8.333333%", "2/12": "16.666667%", "3/12": "25%", "4/12": "33.333333%", "5/12": "41.666667%", "6/12": "50%", "7/12": "58.333333%", "8/12": "66.666667%", "9/12": "75%", "10/12": "83.333333%", "11/12": "91.666667%", full: "100%", screen: "100vw", min: "min-content", max: "max-content", fit: "fit-content" }), willChange: { auto: "auto", scroll: "scroll-position", contents: "contents", transform: "transform" }, zIndex: { auto: "auto", 0: "0", 10: "10", 20: "20", 30: "30", 40: "40", 50: "50" } }, plugins: [] };
});
var Dc = S((FO, Rc) => {
  "use strict";
  var Dn2 = Object.prototype.hasOwnProperty, Ic = Object.prototype.toString, Ec = Object.defineProperty, Cc = Object.getOwnPropertyDescriptor, Ac = function(e2) {
    return typeof Array.isArray == "function" ? Array.isArray(e2) : Ic.call(e2) === "[object Array]";
  }, _c = function(e2) {
    if (!e2 || Ic.call(e2) !== "[object Object]")
      return false;
    var r2 = Dn2.call(e2, "constructor"), n2 = e2.constructor && e2.constructor.prototype && Dn2.call(e2.constructor.prototype, "isPrototypeOf");
    if (e2.constructor && !r2 && !n2)
      return false;
    var i2;
    for (i2 in e2)
      ;
    return typeof i2 > "u" || Dn2.call(e2, i2);
  }, Tc = function(e2, r2) {
    Ec && r2.name === "__proto__" ? Ec(e2, r2.name, { enumerable: true, configurable: true, value: r2.newValue, writable: true }) : e2[r2.name] = r2.newValue;
  }, Pc = function(e2, r2) {
    if (r2 === "__proto__")
      if (Dn2.call(e2, r2)) {
        if (Cc)
          return Cc(e2, r2).value;
      } else
        return;
    return e2[r2];
  };
  Rc.exports = function t2() {
    var e2, r2, n2, i2, a2, s2, o2 = arguments[0], l2 = 1, u2 = arguments.length, f2 = false;
    for (typeof o2 == "boolean" && (f2 = o2, o2 = arguments[1] || {}, l2 = 2), (o2 == null || typeof o2 != "object" && typeof o2 != "function") && (o2 = {}); l2 < u2; ++l2)
      if (e2 = arguments[l2], e2 != null)
        for (r2 in e2)
          n2 = Pc(o2, r2), i2 = Pc(e2, r2), o2 !== i2 && (f2 && i2 && (_c(i2) || (a2 = Ac(i2))) ? (a2 ? (a2 = false, s2 = n2 && Ac(n2) ? n2 : []) : s2 = n2 && _c(n2) ? n2 : {}, Tc(o2, { name: r2, newValue: t2(f2, s2, i2) })) : typeof i2 < "u" && Tc(o2, { name: r2, newValue: i2 }));
    return o2;
  };
});
var Mn = S((LO, Mc) => {
  var ya = function(t2, e2) {
    var r2 = new t2.constructor();
    return Object.keys(t2).forEach(function(n2) {
      if (!!t2.hasOwnProperty(n2)) {
        var i2 = t2[n2], a2 = typeof i2;
        n2 === "parent" && a2 === "object" ? e2 && (r2[n2] = e2) : n2 === "source" ? r2[n2] = i2 : i2 instanceof Array ? n2 === "nodes" ? r2[n2] = [] : r2[n2] = i2.map(function(s2) {
          ya(s2, r2);
        }) : n2 !== "before" && n2 !== "after" && n2 !== "between" && n2 !== "semicolon" && (a2 === "object" && (i2 = ya(i2)), r2[n2] = i2);
      }
    }), r2;
  };
  Mc.exports = ya;
});
var $c = S((NO, qc) => {
  "use strict";
  qc.exports = Lc;
  function Lc(t2, e2, r2) {
    t2 instanceof RegExp && (t2 = Fc(t2, r2)), e2 instanceof RegExp && (e2 = Fc(e2, r2));
    var n2 = Nc(t2, e2, r2);
    return n2 && { start: n2[0], end: n2[1], pre: r2.slice(0, n2[0]), body: r2.slice(n2[0] + t2.length, n2[1]), post: r2.slice(n2[1] + e2.length) };
  }
  function Fc(t2, e2) {
    var r2 = e2.match(t2);
    return r2 ? r2[0] : null;
  }
  Lc.range = Nc;
  function Nc(t2, e2, r2) {
    var n2, i2, a2, s2, o2, l2 = r2.indexOf(t2), u2 = r2.indexOf(e2, l2 + 1), f2 = l2;
    if (l2 >= 0 && u2 > 0) {
      if (t2 === e2)
        return [l2, u2];
      for (n2 = [], a2 = r2.length; f2 >= 0 && !o2; )
        f2 == l2 ? (n2.push(f2), l2 = r2.indexOf(t2, f2 + 1)) : n2.length == 1 ? o2 = [n2.pop(), u2] : (i2 = n2.pop(), i2 < a2 && (a2 = i2, s2 = u2), u2 = r2.indexOf(e2, f2 + 1)), f2 = l2 < u2 && l2 >= 0 ? l2 : u2;
      n2.length && (o2 = [a2, s2]);
    }
    return o2;
  }
});
var jc = S((qO, Uc) => {
  var Ow = /(.*?(?:(?:\([^\)]+\)|\[[^\]]+\]|(?![><+~\s]).)+)(?:(?:(?:\s(?!>>))|(?:\t(?!>>))|(?:\s?>>\s?))(?!\s+))(?![><+~][\s]+?))/, Ew = function(t2) {
    return t2.split(Ow).filter(function(e2) {
      return e2.length > 0;
    }).map(function(e2) {
      return e2.trim().replace(/\s*?>>\s*?/g, "");
    });
  };
  Uc.exports = Ew;
});
var dr = S(($O, zc) => {
  var Cw = jc(), Aw = function(t2, e2) {
    e2 = e2 || false;
    for (var r2 = [[]], n2 = e2 ? t2 : t2.parent; n2; ) {
      var i2 = (n2.selectors || []).map(function(s2) {
        return { value: s2, type: "selector" };
      });
      n2.type === "atrule" && (i2 = [].concat(n2.params).map(function(s2) {
        return { value: "@" + n2.name + " " + s2, type: "atrule" };
      }));
      var a2 = (i2.length > 0 ? i2 : [1]).map(function() {
        return r2.map(function(s2) {
          return s2.slice(0);
        });
      });
      i2.forEach(function(s2, o2) {
        a2[o2] = a2[o2].map(function(l2) {
          var u2 = [s2.value];
          return s2.type === "selector" && (u2 = Cw(s2.value)), l2.unshift.apply(l2, u2), l2;
        });
      }), r2 = [], a2.forEach(function(s2) {
        r2 = r2.concat(s2);
      }), n2 = n2.parent;
    }
    return r2;
  };
  zc.exports = Aw;
});
var Wc = S((UO, Vc) => {
  "use strict";
  var _w = /[|\\{}()[\]^$+*?.]/g;
  Vc.exports = function(t2) {
    if (typeof t2 != "string")
      throw new TypeError("Expected a string");
    return t2.replace(_w, "\\$&");
  };
});
var Gc = S((jO, Bc) => {
  var Tw = { "*": true, ":root": true, html: true }, Pw = function(t2) {
    return !!Tw[t2];
  };
  Bc.exports = Pw;
});
var Hc = S((zO, Yc) => {
  var Iw = /(.*?(?:(?:\([^\)]+\)|\[[^\]]+\]|(?!>>|<|\+|~|\s).)+)(?:(?:(?:>(?!>))|(?:\s?>(?!>)\s?))(?!\s+))(?!(?:>>|<|\+|~)[\s]+?))/, Rw = function(t2) {
    return t2.split(Iw).filter(function(e2) {
      return e2.length > 0;
    }).map(function(e2) {
      return e2.trim().replace(/\s*?>\s*?/g, "");
    });
  };
  Yc.exports = Rw;
});
var va = S((VO, tp) => {
  var Dw = Wc(), Qc = Gc(), Jc = Hc(), Mw = /^@.*/, Kc = /([^\s:]+)((?::|::)[^\s]*?)(\s+|$)/;
  function Zc(t2, e2) {
    var r2, n2, i2 = e2.some(function(a2) {
      return t2.some(function(s2) {
        r2 = null;
        var o2 = true;
        for (n2 = 0; n2 < a2.length; n2++) {
          for (var l2 = a2[n2], u2 = r2 || 0, f2 = -1, p2 = s2.slice(u2), c2 = 0; c2 < p2.length; c2++) {
            var d2 = p2[c2], h2 = u2 + c2;
            if (new RegExp(Dw(l2) + "$").test(d2)) {
              f2 = h2;
              break;
            }
            if (Qc(l2) || Qc(d2)) {
              f2 = h2;
              break;
            }
            var y3 = Jc(d2);
            if (y3.length > 1) {
              var m = [].concat([y3]), g2 = [].concat([a2.slice(n2).reduce(function(v2, O2) {
                return v2.concat(Jc(O2));
              }, [])]), w2 = Zc(m, g2);
              (w2.doesMatchScope || n2 + 1 < a2.length) && (f2 = h2, n2 += w2.scopePieceIndex - 1);
              break;
            }
          }
          var b3 = f2 >= u2;
          if (r2 = f2 + 1, o2 = o2 && b3, !o2)
            break;
        }
        return o2;
      });
    });
    return { doesMatchScope: i2, nodeScopePieceIndex: r2 - 1, scopePieceIndex: n2 };
  }
  var Xc = function(t2) {
    return t2.map(function(e2) {
      return e2.map(function(r2) {
        return Mw.test(r2) ? r2 : r2.replace(new RegExp(Kc.source, "g"), function(n2, i2, a2, s2) {
          return i2 + s2;
        });
      });
    });
  }, ep = function(t2, e2, r2) {
    return t2 = Xc(t2), r2 && (e2 = Xc(e2)), Zc(t2, e2).doesMatchScope;
  };
  ep.RE_PSEUDO_SELECTOR = Kc;
  tp.exports = ep;
});
var wa = S((WO, np) => {
  var Fw = va(), rp = dr(), Lw = function(t2, e2, r2) {
    var n2 = rp(t2, true), i2 = rp(e2, true);
    return Fw(n2, i2, r2);
  };
  np.exports = Lw;
});
var ba = S((BO, sp) => {
  var ip = function(t2, e2, r2) {
    r2 = r2 || [];
    var n2 = false;
    return t2 && (r2 = t2.reduce(function(i2, a2) {
      var s2 = !!e2[a2], o2 = s2 ? i2.some(function(l2) {
        return e2[a2].some(function(u2) {
          return l2 === u2;
        });
      }) : false;
      return n2 = n2 || o2, s2 && !n2 && (i2 = i2.concat(e2[a2]), (e2[a2] || []).forEach(function(l2) {
        var u2 = ip(l2.variablesUsed, e2, i2);
        i2 = u2.deps, n2 = n2 || u2.hasCircularOrSelfReference;
      })), i2;
    }, r2)), { deps: r2, hasCircularOrSelfReference: n2 };
  };
  sp.exports = ip;
});
var xa = S((GO, ap) => {
  var Nw = dr(), qw = function(t2, e2) {
    for (var r2, n2 = e2; n2.parent && !r2; ) {
      var i2 = Nw(n2.clone(), true);
      i2.some(function(a2) {
        return a2.some(function(s2) {
          return s2 === t2 ? (r2 = n2, true) : false;
        });
      }), n2 = n2.parent;
    }
    return r2;
  };
  ap.exports = qw;
});
var Sa = S((YO, lp) => {
  var op = Mn(), $w = function(t2, e2, r2) {
    r2 = r2 || function() {
      return true;
    };
    for (var n2 = [], i2 = t2, a2 = false; i2 && !a2; )
      i2.type === "decl" ? n2.push(i2.clone()) : n2.push(op(i2)), a2 = r2(i2), i2 = i2.parent;
    for (var s2 = [], o2 = e2; o2; )
      s2.push(op(o2)), o2 = o2.parent;
    return s2.forEach(function(l2, u2, f2) {
      u2 + 1 < f2.length && (l2.parent = f2[u2 + 1]);
    }), n2.forEach(function(l2, u2, f2) {
      u2 + 1 < f2.length ? l2.parent = f2[u2 + 1] : (s2.slice(-1)[0].parent = i2, l2.parent = s2[0]);
    }), n2[0];
  };
  lp.exports = $w;
});
var ka = S((HO, fp) => {
  var Uw = $c(), jw = dr(), up = wa(), zw = ba(), Vw = xa(), Ww = Sa(), Bw = /var\(\s*(--[^,\s)]+)/;
  function Gw(t2) {
    return String(t2);
  }
  function Fn2(t2) {
    var e2 = Uw("(", ")", t2);
    if (e2) {
      if (/(?:^|[^\w-])var$/.test(e2.pre))
        return { pre: e2.pre.slice(0, -3), body: e2.body, post: e2.post };
      var r2 = Fn2(e2.body);
      if (r2)
        return { pre: e2.pre + "(" + r2.pre, body: r2.body, post: r2.post + ")" + e2.post };
      var n2 = Fn2(e2.post);
      if (n2)
        return { pre: e2.pre + "(" + e2.body + ")" + n2.pre, body: n2.body, post: n2.post };
    }
  }
  var Ln = function(t2, e2, r2, n2) {
    for (var i2 = n2 ? "	" : "", a2 = void 0, s2 = Gw(t2.value), o2 = [], l2 = {}, u2 = s2; a2 = Fn2(u2); ) {
      var f2 = a2.body.split(","), p2 = f2[0].trim();
      l2[p2] = true, u2 = (a2.pre || "") + a2.body.replace(p2, "") + (a2.post || "");
    }
    u2 = void 0;
    for (var c2 = Object.keys(l2), d2 = false; a2 = Fn2(s2); ) {
      var h2 = void 0, f2 = a2.body.split(","), p2 = f2[0].trim(), y3 = f2.length > 1 ? f2.slice(1).join(",").trim() : void 0;
      (e2[p2] || []).forEach(function(A) {
        var E2 = A.parent.type === "root" || A.parent.selectors[0] === ":root", I2 = up(t2.parent, A.parent), F = up(t2.parent, A.parent, r2);
        F && (!(h2 || {}).isImportant || A.isImportant) && (h2 = A);
      });
      var m = (h2 || {}).calculatedInPlaceValue || function() {
        var A = y3;
        if (y3) {
          var E2 = t2.clone({ parent: t2.parent, value: y3 });
          A = Ln(E2, e2, false, true).value;
        }
        return A;
      }();
      if (h2 !== void 0 && !zw(c2, e2).hasCircularOrSelfReference) {
        var g2 = jw(t2.parent.parent, true), w2 = g2[0].slice(-1)[0], b3 = Vw(w2, h2.decl.parent), v2 = Ww(h2.decl, t2.parent.parent, function(A) {
          return A === b3;
        });
        m = Ln(v2, e2, false, true).value;
      }
      d2 = m === void 0, d2 && o2.push(["variable " + p2 + " is undefined and used without a fallback", { node: t2 }]), s2 = (a2.pre || "") + m + (a2.post || "");
    }
    return { value: d2 ? void 0 : s2, variablesUsed: c2, warnings: o2 };
  };
  Ln.RE_VAR_FUNC = Bw;
  fp.exports = Ln;
});
var hp = S((QO, dp) => {
  var cp = ka(), Yw = dr(), Hw = ba(), pp = va(), Qw = wa(), Nn2 = Mn(), Jw = xa(), Xw = Sa();
  function Kw(t2, e2, r2, n2) {
    t2.forEach(function(i2) {
      Hw(t2, e2).deps.forEach(function(a2) {
        var s2;
        if (a2.isUnderAtRule) {
          var o2 = Yw(a2.parent, true), l2 = o2[0].slice(-1)[0], u2 = Jw(l2, r2.parent), f2 = a2.parent.parent;
          s2 = Xw(r2, f2, function(h2) {
            return h2 === u2;
          });
        } else if (pp.RE_PSEUDO_SELECTOR.test(a2.parent.selector)) {
          var p2 = Nn2(r2.parent);
          p2.parent = r2.parent.parent, s2 = r2.clone(), p2.append(s2);
          var c2 = a2.parent.selector.match(new RegExp(pp.RE_PSEUDO_SELECTOR.source + "$")), d2 = c2 ? c2[2] : "";
          p2.selector += d2;
        }
        s2 && Qw(s2, a2.parent, true) && n2(s2, a2);
      });
    });
  }
  function Zw(t2, e2, r2, n2, i2) {
    r2 = (typeof r2 == "function" ? r2(t2) : r2) || false, n2 = n2 || false;
    var a2 = function(l2) {
      return i2 && i2(l2), l2;
    }, s2 = a2(cp(t2, e2)), o2;
    Kw(s2.variablesUsed, e2, t2, function(l2, u2) {
      var f2 = Nn2(t2.parent), p2 = t2.clone();
      f2.append(p2);
      let c2;
      if (typeof r2 == "function" ? c2 = r2(t2) : c2 = r2, c2 === true && p2.cloneAfter(), p2.value = a2(cp(l2, e2, true)).value, u2.isUnderAtRule) {
        var d2 = Nn2(u2.parent.parent);
        d2.append(f2);
        for (var h2 = d2, y3 = u2.parent.parent; y3.parent.type === "atrule"; ) {
          var m = Nn2(y3.parent);
          m.append(h2), h2 = m, y3 = y3.parent;
        }
        t2.parent.parent.insertAfter(n2 && o2 || t2.parent, h2), o2 = h2;
      } else
        f2.selector = l2.parent.selector, t2.parent.parent.insertAfter(n2 && o2 || t2.parent, f2);
    }), r2 === true && t2.value !== s2.value && t2.cloneAfter(), s2.value === void 0 && (s2.value = "undefined"), t2.value = s2.value;
  }
  dp.exports = Zw;
});
var vp = S((JO, Oa) => {
  var mp = Dc(), eb = Mn(), gp = ka(), tb = hp(), yp = /(--(.+))/;
  function rb(t2, e2) {
    t2.walkDecls(function(r2) {
      yp.test(r2.prop) && e2(r2);
    });
  }
  function nb(t2) {
    for (var e2 = t2; e2 && e2.nodes.length <= 0; ) {
      var r2 = e2.type !== "root" ? e2 : null;
      r2 ? (e2 = r2.parent, r2.remove()) : e2 = null;
    }
  }
  var ib = { preserve: false, variables: {}, preserveInjectedVariables: true, preserveAtRulesOrder: false };
  Oa.exports = (t2 = {}) => {
    var e2 = mp({}, ib, t2);
    return { postcssPlugin: "postcss-css-variables", Once(r2, { decl: n2, result: i2, rule: a2 }) {
      var s2 = [], o2 = [], l2 = {};
      l2 = mp(l2, Object.keys(e2.variables).reduce(function(p2, c2) {
        var d2 = e2.variables[c2];
        c2 = c2.slice(0, 2) === "--" ? c2 : "--" + c2;
        var h2 = (d2 || {}).value || d2, y3 = (d2 || {}).isImportant || false, m = a2({ selector: ":root" });
        r2.root().prepend(m);
        var g2 = n2({ prop: c2, value: h2, important: y3 });
        return m.append(g2), e2.preserveInjectedVariables || o2.push(g2), p2[c2] = (p2[c2] || []).concat({ decl: g2, prop: c2, calculatedInPlaceValue: h2, isImportant: y3, variablesUsed: [], parent: m, isUnderAtRule: false }), p2;
      }, {}));
      var u2 = function(p2) {
        var c2 = [].concat(p2.warnings);
        return c2.forEach(function(d2) {
          d2 = [].concat(d2), i2.warn.apply(i2, d2);
        }), p2;
      };
      rb(r2, function(p2) {
        var c2 = p2.parent, d2 = u2(gp(p2, l2));
        p2.parent.selectors.forEach(function(y3) {
          var m = eb(p2.parent);
          m.selector = y3, m.parent = p2.parent.parent;
          var g2 = p2.clone();
          m.append(g2);
          var w2 = p2.prop;
          l2[w2] = (l2[w2] || []).concat({ decl: g2, prop: w2, calculatedInPlaceValue: d2.value, isImportant: p2.important || false, variablesUsed: d2.variablesUsed, parent: m, isUnderAtRule: m.parent.type === "atrule" });
        });
        let h2;
        typeof e2.preserve == "function" ? h2 = e2.preserve(p2) : h2 = e2.preserve, h2 ? h2 === "computed" && (p2.value = d2.value) : p2.remove(), c2.nodes.length <= 0 && s2.push(c2);
      });
      var f2 = [];
      r2.walk(function(p2) {
        if (p2.nodes !== void 0) {
          var c2 = p2.nodes.some(function(d2) {
            if (d2.type === "decl") {
              var h2 = d2;
              if (gp.RE_VAR_FUNC.test(h2.value) && !yp.test(h2.prop))
                return true;
            }
            return false;
          });
          c2 && f2.push(p2);
        }
      }), f2.forEach(function(p2) {
        var c2 = [].concat(p2);
        p2.type === "rule" && p2.selectors.length > 1 && (c2 = p2.selectors.reverse().map(function(d2) {
          var h2 = p2.cloneAfter();
          return h2.selector = d2, h2;
        }), p2.remove()), c2.forEach(function(d2) {
          d2.nodes.slice(0).forEach(function(h2) {
            if (h2.type === "decl") {
              var y3 = h2;
              tb(y3, l2, e2.preserve, e2.preserveAtRulesOrder, u2);
            }
          });
        });
      }), s2.forEach(nb), o2.forEach(function(p2) {
        p2.remove();
      });
    } };
  };
  Oa.exports.postcss = true;
});
var Ra = (t2) => ({ extractCSS(e2, r2 = false) {
  let n2 = /(?:[\s\r\n]*)?(?<prop>[\w-]+)\s*:\s*(?<value>[^;\r\n]+)/gm, i2, a2 = {};
  for (; (i2 = n2.exec(e2)) !== null; ) {
    let { prop: s2, value: o2 } = i2.groups;
    a2[s2] = o2;
  }
  return Object.entries(a2).reduce((s2, [o2, l2]) => s2 + `${r2 ? "	" : ""}${o2}: ${l2}; 
\r`, "");
}, merge() {
  let e2 = new RegExp("(?<=\\.)[^{]+\\s*\\{(?<content>[^{}]*(?:(?<=;)\\s*\\n\\r?[^{}]*)*)\\s*\\}", "gm"), r2, n2 = "";
  for (; (r2 = e2.exec(t2)) !== null; ) {
    let { content: o2 } = r2.groups;
    n2 += o2;
  }
  let i2 = this.extractCSS(n2), a2 = /(?<media>@media\s*\([^\)]*\))\s*\{(?<content>[^\}]*)\}/gm, s2;
  for (; (s2 = a2.exec(t2)) !== null; ) {
    let { media: o2, content: l2 } = s2.groups;
    i2 += `
\r${o2} {
\r${this.extractCSS(l2, true)}}
\r`;
  }
  return t2 = i2, this;
}, removeUndefined() {
  let e2 = /^[^{}]*(?:[.#][a-zA-Z0-9_-]+)[^{]*{[^}]*\b(?:[a-z-]+):\s*undefined\s*;?[^}]*}/gm;
  return t2 = t2.replace(e2, ""), this;
}, combineMediaQueries() {
  let e2 = new RegExp("@media\\s*(?<conditions>\\([^)]+\\))\\s*{(?<content>(?:[^{}]+|{(?:[^{}]+|{[^{}]*})*})+)}", "gs"), r2 = /* @__PURE__ */ new Map(), n2 = (a2) => a2.replace(e2, (s2, o2, l2) => {
    var f2;
    let u2 = (f2 = r2.get(o2)) != null ? f2 : "";
    return r2.set(o2, u2 + n2(l2.trim())), n2(l2), "";
  }), i2 = [];
  return i2.push(n2(t2)), i2.push(...Array.from(r2, ([a2, s2]) => `@media${a2}{${s2}}`)), t2 = i2.join(""), this;
}, minify() {
  return t2 = t2.replace(/\/\*[\s\S]*?\*\//gm, "").replace(/;\s+/gm, ";").replace(/:\s+/gm, ":").replace(/\)\s*{/gm, "){").replace(/\s+\(/gm, "(").replace(/{\s+/gm, "{").replace(/}\s+/gm, "}").replace(/\s*{/gm, "{").replace(/;?\s*}/gm, "}"), this;
}, fixRGB() {
  let e2 = /rgb\(\s*(?<red>\d+)\s*(?<green>\d+)\s*(?<blue>\d+)(?:\s*\/\s*(?<alpha>[\d%.]+))?\s*\)/gm, r2;
  for (; (r2 = e2.exec(t2)) !== null; ) {
    let [n2] = r2, { red: i2, green: a2, blue: s2, alpha: o2 = 1 } = r2.groups;
    t2 = t2.replace(n2, `rgb(${i2},${a2},${s2}${o2 === "1" ? "" : `,${o2}`})`);
  }
  return this;
}, removeMediaQueries() {
  return t2 = t2.replace(/@media[^\{]+\{[^@]+\}/g, ""), this;
}, get() {
  return t2;
} });
function $n() {
}
var L = { info: $n, warn: $n, risk: $n };
function Un(t2) {
  let e2 = /* @__PURE__ */ new Set(), r2 = /* @__PURE__ */ new Set(), n2 = /* @__PURE__ */ new Set();
  if (t2.walkAtRules((i2) => {
    i2.name === "apply" && n2.add(i2), i2.name === "import" && (i2.params === '"tailwindcss/base"' || i2.params === "'tailwindcss/base'" ? (i2.name = "tailwind", i2.params = "base") : i2.params === '"tailwindcss/components"' || i2.params === "'tailwindcss/components'" ? (i2.name = "tailwind", i2.params = "components") : i2.params === '"tailwindcss/utilities"' || i2.params === "'tailwindcss/utilities'" ? (i2.name = "tailwind", i2.params = "utilities") : (i2.params === '"tailwindcss/screens"' || i2.params === "'tailwindcss/screens'" || i2.params === '"tailwindcss/variants"' || i2.params === "'tailwindcss/variants'") && (i2.name = "tailwind", i2.params = "variants")), i2.name === "tailwind" && (i2.params === "screens" && (i2.params = "variants"), e2.add(i2.params)), ["layer", "responsive", "variants"].includes(i2.name) && (["responsive", "variants"].includes(i2.name) && L.warn(`${i2.name}-at-rule-deprecated`, [`The \`@${i2.name}\` directive has been deprecated in Tailwind CSS v3.0.`, "Use `@layer utilities` or `@layer components` instead.", "https://tailwindcss.com/docs/upgrade-guide#replace-variants-with-layer"]), r2.add(i2));
  }), !e2.has("base") || !e2.has("components") || !e2.has("utilities")) {
    for (let i2 of r2)
      if (i2.name === "layer" && ["base", "components", "utilities"].includes(i2.params)) {
        if (!e2.has(i2.params))
          throw i2.error(`\`@layer ${i2.params}\` is used but no matching \`@tailwind ${i2.params}\` directive is present.`);
      } else if (i2.name === "responsive") {
        if (!e2.has("utilities"))
          throw i2.error("`@responsive` is used but `@tailwind utilities` is missing.");
      } else if (i2.name === "variants" && !e2.has("utilities"))
        throw i2.error("`@variants` is used but `@tailwind utilities` is missing.");
  }
  return { tailwindDirectives: e2, applyDirectives: n2 };
}
vr();
var $f = H(Na());
var $a = "3.3.2";
var zn = { name: "tailwindcss", version: $a, description: "A utility-first CSS framework for rapidly building custom user interfaces.", license: "MIT", main: "lib/index.js", types: "types/index.d.ts", repository: "https://github.com/tailwindlabs/tailwindcss.git", bugs: "https://github.com/tailwindlabs/tailwindcss/issues", homepage: "https://tailwindcss.com", bin: { tailwind: "lib/cli.js", tailwindcss: "lib/cli.js" }, tailwindcss: { engine: "stable" }, scripts: { prebuild: "npm run generate && rimraf lib", build: `swc src --out-dir lib --copy-files --config jsc.transform.optimizer.globals.vars.__OXIDE__='"false"'`, postbuild: "esbuild lib/cli-peer-dependencies.js --bundle --platform=node --outfile=peers/index.js --define:process.env.CSS_TRANSFORMER_WASM=false", "rebuild-fixtures": "npm run build && node -r @swc/register scripts/rebuildFixtures.js", style: "eslint .", pretest: "npm run generate", test: "jest", "test:integrations": "npm run test --prefix ./integrations", "install:integrations": "node scripts/install-integrations.js", "generate:plugin-list": "node -r @swc/register scripts/create-plugin-list.js", "generate:types": "node -r @swc/register scripts/generate-types.js", generate: "npm run generate:plugin-list && npm run generate:types", "release-channel": "node ./scripts/release-channel.js", "release-notes": "node ./scripts/release-notes.js", prepublishOnly: "npm install --force && npm run build" }, files: ["src/*", "cli/*", "lib/*", "peers/*", "scripts/*.js", "stubs/*", "nesting/*", "types/**/*", "*.d.ts", "*.css", "*.js"], devDependencies: { "@swc/cli": "^0.1.62", "@swc/core": "^1.3.55", "@swc/jest": "^0.2.26", "@swc/register": "^0.1.10", autoprefixer: "^10.4.14", browserslist: "^4.21.5", concurrently: "^8.0.1", cssnano: "^6.0.0", esbuild: "^0.17.18", eslint: "^8.39.0", "eslint-config-prettier": "^8.8.0", "eslint-plugin-prettier": "^4.2.1", jest: "^29.5.0", "jest-diff": "^29.5.0", lightningcss: "1.18.0", prettier: "^2.8.8", rimraf: "^5.0.0", "source-map-js": "^1.0.2", turbo: "^1.9.3" }, dependencies: { "@alloc/quick-lru": "^5.2.0", arg: "^5.0.2", chokidar: "^3.5.3", didyoumean: "^1.2.2", dlv: "^1.1.3", "fast-glob": "^3.2.12", "glob-parent": "^6.0.2", "is-glob": "^4.0.3", jiti: "^1.18.2", lilconfig: "^2.1.0", micromatch: "^4.0.5", "normalize-path": "^3.0.0", "object-hash": "^3.0.0", picocolors: "^1.0.0", postcss: "^8.4.23", "postcss-import": "^15.1.0", "postcss-js": "^4.0.1", "postcss-load-config": "^4.0.1", "postcss-nested": "^6.0.1", "postcss-selector-parser": "^6.0.11", "postcss-value-parser": "^4.2.0", resolve: "^1.22.2", sucrase: "^3.32.0" }, browserslist: ["> 1%", "not edge <= 18", "not ie 11", "not op_mini all"], jest: { testTimeout: 3e4, setupFilesAfterEnv: ["<rootDir>/jest/customMatchers.js"], testPathIgnorePatterns: ["/node_modules/", "/integrations/", "/standalone-cli/", "\\.test\\.skip\\.js$"], transformIgnorePatterns: ["node_modules/(?!lightningcss)"], transform: { "\\.js$": "@swc/jest", "\\.ts$": "@swc/jest" } }, engines: { node: ">=14.0.0" } };
var Vn = typeof process < "u" ? { NODE_ENV: "production", DEBUG: Dp(void 0), ENGINE: zn.tailwindcss.engine } : { NODE_ENV: "production", DEBUG: false, ENGINE: zn.tailwindcss.engine };
var Wn = /* @__PURE__ */ new Map();
var ke = new String("*");
var mt = Symbol("__NONE__");
function Dp(t2) {
  if (t2 === void 0)
    return false;
  if (t2 === "true" || t2 === "1")
    return true;
  if (t2 === "false" || t2 === "0")
    return false;
  if (t2 === "*")
    return true;
  let e2 = t2.split(",").map((r2) => r2.split(":")[0]);
  return e2.includes("-tailwindcss") ? false : !!e2.includes("tailwindcss");
}
var $ = H(Ke(), 1);
var R = $.default;
var Kb = $.default.stringify;
var Zb = $.default.fromJSON;
var ex = $.default.plugin;
var tx = $.default.parse;
var rx = $.default.list;
var nx = $.default.document;
var ix = $.default.comment;
var sx = $.default.atRule;
var ax = $.default.rule;
var ox = $.default.decl;
var lx = $.default.root;
var ux = $.default.CssSyntaxError;
var fx = $.default.Declaration;
var cx = $.default.Container;
var px = $.default.Processor;
var dx = $.default.Document;
var hx = $.default.Comment;
var mx = $.default.Warning;
var gx = $.default.AtRule;
var yx = $.default.Result;
var vx = $.default.Input;
var wx = $.default.Rule;
var bx = $.default.Root;
var xx = $.default.Node;
var wn = H(ve());
var $u = H(Su());
var rt = H(qu(), 1);
var tn = rt.default;
var jx = rt.default.objectify;
var zx = rt.default.parse;
var Vx = rt.default.async;
var Wx = rt.default.sync;
function nt(t2) {
  return Array.isArray(t2) ? t2.flatMap((e2) => R([(0, $u.default)({ bubble: ["screen"] })]).process(e2, { parser: tn }).root.nodes) : nt([t2]);
}
function X(t2) {
  if (Object.prototype.toString.call(t2) !== "[object Object]")
    return false;
  let e2 = Object.getPrototypeOf(t2);
  return e2 === null || e2 === Object.prototype;
}
var Uu = H(ve());
function it(t2, e2, r2 = false) {
  if (t2 === "")
    return e2;
  let n2 = typeof e2 == "string" ? (0, Uu.default)().astSync(e2) : e2;
  return n2.walkClasses((i2) => {
    let a2 = i2.value, s2 = r2 && a2.startsWith("-");
    i2.value = s2 ? `-${t2}${a2.slice(1)}` : `${t2}${a2}`;
  }), typeof e2 == "string" ? n2.toString() : n2;
}
function Be(t2) {
  return t2.replace(/\\,/g, "\\2c ");
}
var ks = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
var C0 = /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i;
var A0 = /^#([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i;
var Pe = /(?:\d+|\d*\.\d+)%?/;
var rn = /(?:\s*,\s*|\s+)/;
var ju = /\s*[,/]\s*/;
var Ie = /var\(--(?:[^ )]*?)\)/;
var _0 = new RegExp(`^(rgba?)\\(\\s*(${Pe.source}|${Ie.source})(?:${rn.source}(${Pe.source}|${Ie.source}))?(?:${rn.source}(${Pe.source}|${Ie.source}))?(?:${ju.source}(${Pe.source}|${Ie.source}))?\\s*\\)$`);
var T0 = new RegExp(`^(hsla?)\\(\\s*((?:${Pe.source})(?:deg|rad|grad|turn)?|${Ie.source})(?:${rn.source}(${Pe.source}|${Ie.source}))?(?:${rn.source}(${Pe.source}|${Ie.source}))?(?:${ju.source}(${Pe.source}|${Ie.source}))?\\s*\\)$`);
function ir(t2, { loose: e2 = false } = {}) {
  var a2, s2, o2;
  if (typeof t2 != "string")
    return null;
  if (t2 = t2.trim(), t2 === "transparent")
    return { mode: "rgb", color: ["0", "0", "0"], alpha: "0" };
  if (t2 in ks)
    return { mode: "rgb", color: ks[t2].map((l2) => l2.toString()) };
  let r2 = t2.replace(A0, (l2, u2, f2, p2, c2) => ["#", u2, u2, f2, f2, p2, p2, c2 ? c2 + c2 : ""].join("")).match(C0);
  if (r2 !== null)
    return { mode: "rgb", color: [parseInt(r2[1], 16), parseInt(r2[2], 16), parseInt(r2[3], 16)].map((l2) => l2.toString()), alpha: r2[4] ? (parseInt(r2[4], 16) / 255).toString() : void 0 };
  let n2 = (a2 = t2.match(_0)) != null ? a2 : t2.match(T0);
  if (n2 === null)
    return null;
  let i2 = [n2[2], n2[3], n2[4]].filter(Boolean).map((l2) => l2.toString());
  return i2.length === 2 && i2[0].startsWith("var(") ? { mode: n2[1], color: [i2[0]], alpha: i2[1] } : !e2 && i2.length !== 3 || i2.length < 3 && !i2.some((l2) => /^var\(.*?\)$/.test(l2)) ? null : { mode: n2[1], color: i2, alpha: (o2 = (s2 = n2[5]) == null ? void 0 : s2.toString) == null ? void 0 : o2.call(s2) };
}
function Os({ mode: t2, color: e2, alpha: r2 }) {
  let n2 = r2 !== void 0;
  return t2 === "rgba" || t2 === "hsla" ? `${t2}(${e2.join(", ")}${n2 ? `, ${r2}` : ""})` : `${t2}(${e2.join(" ")}${n2 ? ` / ${r2}` : ""})`;
}
function we(t2, e2, r2) {
  if (typeof t2 == "function")
    return t2({ opacityValue: e2 });
  let n2 = ir(t2, { loose: true });
  return n2 === null ? r2 : Os({ ...n2, alpha: e2 });
}
function Z({ color: t2, property: e2, variable: r2 }) {
  let n2 = [].concat(e2);
  if (typeof t2 == "function")
    return { [r2]: "1", ...Object.fromEntries(n2.map((a2) => [a2, t2({ opacityVariable: r2, opacityValue: `var(${r2})` })])) };
  let i2 = ir(t2);
  return i2 === null ? Object.fromEntries(n2.map((a2) => [a2, t2])) : i2.alpha !== void 0 ? Object.fromEntries(n2.map((a2) => [a2, t2])) : { [r2]: "1", ...Object.fromEntries(n2.map((a2) => [a2, Os({ ...i2, alpha: `var(${r2})` })])) };
}
function ee(t2, e2) {
  let r2 = [], n2 = [], i2 = 0, a2 = false;
  for (let s2 = 0; s2 < t2.length; s2++) {
    let o2 = t2[s2];
    r2.length === 0 && o2 === e2[0] && !a2 && (e2.length === 1 || t2.slice(s2, s2 + e2.length) === e2) && (n2.push(t2.slice(i2, s2)), i2 = s2 + e2.length), a2 ? a2 = false : o2 === "\\" && (a2 = true), o2 === "(" || o2 === "[" || o2 === "{" ? r2.push(o2) : (o2 === ")" && r2[r2.length - 1] === "(" || o2 === "]" && r2[r2.length - 1] === "[" || o2 === "}" && r2[r2.length - 1] === "{") && r2.pop();
  }
  return n2.push(t2.slice(i2)), n2;
}
var P0 = /* @__PURE__ */ new Set(["inset", "inherit", "initial", "revert", "unset"]);
var I0 = /\ +(?![^(]*\))/g;
var zu = /^-?(\d+|\.\d+)(.*?)$/g;
function nn(t2) {
  return ee(t2, ",").map((r2) => {
    let n2 = r2.trim(), i2 = { raw: n2 }, a2 = n2.split(I0), s2 = /* @__PURE__ */ new Set();
    for (let o2 of a2)
      zu.lastIndex = 0, !s2.has("KEYWORD") && P0.has(o2) ? (i2.keyword = o2, s2.add("KEYWORD")) : zu.test(o2) ? s2.has("X") ? s2.has("Y") ? s2.has("BLUR") ? s2.has("SPREAD") || (i2.spread = o2, s2.add("SPREAD")) : (i2.blur = o2, s2.add("BLUR")) : (i2.y = o2, s2.add("Y")) : (i2.x = o2, s2.add("X")) : i2.color ? (i2.unknown || (i2.unknown = []), i2.unknown.push(o2)) : i2.color = o2;
    return i2.valid = i2.x !== void 0 && i2.y !== void 0, i2;
  });
}
function Vu(t2) {
  return t2.map((e2) => e2.valid ? [e2.keyword, e2.x, e2.y, e2.blur, e2.spread, e2.color].filter(Boolean).join(" ") : e2.raw).join(", ");
}
var R0 = ["min", "max", "clamp", "calc"];
function Es(t2) {
  return R0.some((e2) => new RegExp(`^${e2}\\(.*\\)`).test(t2));
}
var Wu = "--tw-placeholder";
var D0 = new RegExp(Wu, "g");
function z(t2, e2 = true) {
  return t2.startsWith("--") ? `var(${t2})` : t2.includes("url(") ? t2.split(/(url\(.*?\))/g).filter(Boolean).map((r2) => /^url\(.*?\)$/.test(r2) ? r2 : z(r2, false)).join("") : (t2 = t2.replace(/([^\\])_+/g, (r2, n2) => n2 + " ".repeat(r2.length - 1)).replace(/^_/g, " ").replace(/\\_/g, "_"), e2 && (t2 = t2.trim()), t2 = t2.replace(/(calc|min|max|clamp)\(.+\)/g, (r2) => {
    let n2 = [];
    return r2.replace(/var\((--.+?)[,)]/g, (i2, a2) => (n2.push(a2), i2.replace(a2, Wu))).replace(/(-?\d*\.?\d(?!\b-\d.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, "$1 $2 ").replace(D0, () => n2.shift());
  }), t2);
}
function Cs(t2) {
  return t2.startsWith("url(");
}
function As(t2) {
  return !isNaN(Number(t2)) || Es(t2);
}
function sr(t2) {
  return t2.endsWith("%") && As(t2.slice(0, -1)) || Es(t2);
}
var M0 = ["cm", "mm", "Q", "in", "pc", "pt", "px", "em", "ex", "ch", "rem", "lh", "rlh", "vw", "vh", "vmin", "vmax", "vb", "vi", "svw", "svh", "lvw", "lvh", "dvw", "dvh", "cqw", "cqh", "cqi", "cqb", "cqmin", "cqmax"];
var F0 = `(?:${M0.join("|")})`;
function ar(t2) {
  return t2 === "0" || new RegExp(`^[+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?${F0}$`).test(t2) || Es(t2);
}
var L0 = /* @__PURE__ */ new Set(["thin", "medium", "thick"]);
function Bu(t2) {
  return L0.has(t2);
}
function Gu(t2) {
  let e2 = nn(z(t2));
  for (let r2 of e2)
    if (!r2.valid)
      return false;
  return true;
}
function Yu(t2) {
  let e2 = 0;
  return ee(t2, "_").every((n2) => (n2 = z(n2), n2.startsWith("var(") ? true : ir(n2, { loose: true }) !== null ? (e2++, true) : false)) ? e2 > 0 : false;
}
function Hu(t2) {
  let e2 = 0;
  return ee(t2, ",").every((n2) => (n2 = z(n2), n2.startsWith("var(") ? true : Cs(n2) || q0(n2) || ["element(", "image(", "cross-fade(", "image-set("].some((i2) => n2.startsWith(i2)) ? (e2++, true) : false)) ? e2 > 0 : false;
}
var N0 = /* @__PURE__ */ new Set(["linear-gradient", "radial-gradient", "repeating-linear-gradient", "repeating-radial-gradient", "conic-gradient"]);
function q0(t2) {
  t2 = z(t2);
  for (let e2 of N0)
    if (t2.startsWith(`${e2}(`))
      return true;
  return false;
}
var $0 = /* @__PURE__ */ new Set(["center", "top", "right", "bottom", "left"]);
function Qu(t2) {
  let e2 = 0;
  return ee(t2, "_").every((n2) => (n2 = z(n2), n2.startsWith("var(") ? true : $0.has(n2) || ar(n2) || sr(n2) ? (e2++, true) : false)) ? e2 > 0 : false;
}
function Ju(t2) {
  let e2 = 0;
  return ee(t2, ",").every((n2) => (n2 = z(n2), n2.startsWith("var(") ? true : n2.includes(" ") && !/(['"])([^"']+)\1/g.test(n2) || /^\d/g.test(n2) ? false : (e2++, true))) ? e2 > 0 : false;
}
var U0 = /* @__PURE__ */ new Set(["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong"]);
function Xu(t2) {
  return U0.has(t2);
}
var j0 = /* @__PURE__ */ new Set(["xx-small", "x-small", "small", "medium", "large", "x-large", "x-large", "xxx-large"]);
function Ku(t2) {
  return j0.has(t2);
}
var z0 = /* @__PURE__ */ new Set(["larger", "smaller"]);
function Zu(t2) {
  return z0.has(t2);
}
function Re(t2) {
  if (t2 = `${t2}`, t2 === "0")
    return "0";
  if (/^[+-]?(\d+|\d*\.\d+)(e[+-]?\d+)?(%|\w+)?$/.test(t2))
    return t2.replace(/^[+-]?/, (r2) => r2 === "-" ? "" : "-");
  let e2 = ["var", "calc", "min", "max", "clamp"];
  for (let r2 of e2)
    if (t2.includes(`${r2}(`))
      return `calc(${t2} * -1)`;
}
function ef(t2) {
  let e2 = ["cover", "contain"];
  return ee(t2, ",").every((r2) => {
    let n2 = ee(r2, "_").filter(Boolean);
    return n2.length === 1 && e2.includes(n2[0]) ? true : n2.length !== 1 && n2.length !== 2 ? false : n2.every((i2) => ar(i2) || sr(i2) || i2 === "auto");
  });
}
Gn();
var tf = { optimizeUniversalDefaults: false, generalizedModifiers: true, get disableColorOpacityUtilitiesByDefault() {
}, get relativeContentPathsByDefault() {
} };
var sn = { future: ["hoverOnlyWhenSupported", "respectDefaultRingColorOpacity", "disableColorOpacityUtilitiesByDefault", "relativeContentPathsByDefault"], experimental: ["optimizeUniversalDefaults", "generalizedModifiers"] };
function G(t2, e2) {
  var r2, n2, i2, a2, s2, o2;
  return sn.future.includes(e2) ? t2.future === "all" || ((i2 = (n2 = (r2 = t2 == null ? void 0 : t2.future) == null ? void 0 : r2[e2]) != null ? n2 : tf[e2]) != null ? i2 : false) : sn.experimental.includes(e2) ? t2.experimental === "all" || ((o2 = (s2 = (a2 = t2 == null ? void 0 : t2.experimental) == null ? void 0 : a2[e2]) != null ? s2 : tf[e2]) != null ? o2 : false) : false;
}
function nf(t2) {
  if (false) {
    let e2 = rf(t2).map((r2) => Bn.yellow(r2)).join(", ");
    L.warn("experimental-flags-enabled", [`You have enabled experimental features: ${e2}`, "Experimental features in Tailwind CSS are not covered by semver, may introduce breaking changes, and can change at any time."]);
  }
}
function af(t2, e2) {
  t2.walkClasses((r2) => {
    r2.value = e2(r2.value), r2.raws && r2.raws.value && (r2.raws.value = Be(r2.raws.value));
  });
}
function of(t2, e2) {
  if (!De(t2))
    return;
  let r2 = t2.slice(1, -1);
  if (!!e2(r2))
    return z(r2);
}
function V0(t2, e2 = {}, r2) {
  let n2 = e2[t2];
  if (n2 !== void 0)
    return Re(n2);
  if (De(t2)) {
    let i2 = of(t2, r2);
    return i2 === void 0 ? void 0 : Re(i2);
  }
}
function an(t2, e2 = {}, { validate: r2 = () => true } = {}) {
  var i2;
  let n2 = (i2 = e2.values) == null ? void 0 : i2[t2];
  return n2 !== void 0 ? n2 : e2.supportsNegativeValues && t2.startsWith("-") ? V0(t2.slice(1), e2.values, r2) : of(t2, r2);
}
function De(t2) {
  return t2.startsWith("[") && t2.endsWith("]");
}
function lf(t2) {
  let e2 = t2.lastIndexOf("/");
  return e2 === -1 || e2 === t2.length - 1 ? [t2, void 0] : De(t2) && !t2.includes("]/[") ? [t2, void 0] : [t2.slice(0, e2), t2.slice(e2 + 1)];
}
function st(t2) {
  if (typeof t2 == "string" && t2.includes("<alpha-value>")) {
    let e2 = t2;
    return ({ opacityValue: r2 = 1 }) => e2.replace("<alpha-value>", r2);
  }
  return t2;
}
function uf(t2) {
  return z(t2.slice(1, -1));
}
function W0(t2, e2 = {}, { tailwindConfig: r2 = {} } = {}) {
  var a2, s2, o2, l2, u2, f2;
  if (((a2 = e2.values) == null ? void 0 : a2[t2]) !== void 0)
    return st((s2 = e2.values) == null ? void 0 : s2[t2]);
  let [n2, i2] = lf(t2);
  if (i2 !== void 0) {
    let p2 = (l2 = (o2 = e2.values) == null ? void 0 : o2[n2]) != null ? l2 : De(n2) ? n2.slice(1, -1) : void 0;
    return p2 === void 0 ? void 0 : (p2 = st(p2), De(i2) ? we(p2, uf(i2)) : ((f2 = (u2 = r2.theme) == null ? void 0 : u2.opacity) == null ? void 0 : f2[i2]) === void 0 ? void 0 : we(p2, r2.theme.opacity[i2]));
  }
  return an(t2, e2, { validate: Yu });
}
function B0(t2, e2 = {}) {
  var r2;
  return (r2 = e2.values) == null ? void 0 : r2[t2];
}
function oe(t2) {
  return (e2, r2) => an(e2, r2, { validate: t2 });
}
var _s = { any: an, color: W0, url: oe(Cs), image: oe(Hu), length: oe(ar), percentage: oe(sr), position: oe(Qu), lookup: B0, "generic-name": oe(Xu), "family-name": oe(Ju), number: oe(As), "line-width": oe(Bu), "absolute-size": oe(Ku), "relative-size": oe(Zu), shadow: oe(Gu), size: oe(ef) };
var sf = Object.keys(_s);
function G0(t2, e2) {
  let r2 = t2.indexOf(e2);
  return r2 === -1 ? [void 0, t2] : [t2.slice(0, r2), t2.slice(r2 + 1)];
}
function Ts(t2, e2, r2, n2) {
  if (r2.values && e2 in r2.values)
    for (let { type: a2 } of t2 != null ? t2 : []) {
      let s2 = _s[a2](e2, r2, { tailwindConfig: n2 });
      if (s2 !== void 0)
        return [s2, a2, null];
    }
  if (De(e2)) {
    let a2 = e2.slice(1, -1), [s2, o2] = G0(a2, ":");
    if (!/^[\w-_]+$/g.test(s2))
      o2 = a2;
    else if (s2 !== void 0 && !sf.includes(s2))
      return [];
    if (o2.length > 0 && sf.includes(s2))
      return [an(`[${o2}]`, r2), s2, null];
  }
  let i2 = Ps(t2, e2, r2, n2);
  for (let a2 of i2)
    return a2;
  return [];
}
function* Ps(t2, e2, r2, n2) {
  var l2, u2;
  let i2 = G(n2, "generalizedModifiers"), [a2, s2] = lf(e2);
  if (i2 && r2.modifiers != null && (r2.modifiers === "any" || typeof r2.modifiers == "object" && (s2 && De(s2) || s2 in r2.modifiers)) || (a2 = e2, s2 = void 0), s2 !== void 0 && a2 === "" && (a2 = "DEFAULT"), s2 !== void 0 && typeof r2.modifiers == "object") {
    let f2 = (u2 = (l2 = r2.modifiers) == null ? void 0 : l2[s2]) != null ? u2 : null;
    f2 !== null ? s2 = f2 : De(s2) && (s2 = uf(s2));
  }
  for (let { type: f2 } of t2 != null ? t2 : []) {
    let p2 = _s[f2](a2, r2, { tailwindConfig: n2 });
    p2 !== void 0 && (yield [p2, f2, s2 != null ? s2 : null]);
  }
}
var be = H(ve());
var hf = H(jr());
var ff = H(ve());
function re(t2) {
  var r2, n2;
  let e2 = ff.default.className();
  return e2.value = t2, Be((n2 = (r2 = e2 == null ? void 0 : e2.raws) == null ? void 0 : r2.value) != null ? n2 : e2.value);
}
var Is = { "::after": ["terminal", "jumpable"], "::backdrop": ["terminal"], "::before": ["terminal", "jumpable"], "::cue": ["terminal"], "::cue-region": ["terminal"], "::first-letter": ["terminal", "jumpable"], "::first-line": ["terminal", "jumpable"], "::grammar-error": ["terminal"], "::marker": ["terminal"], "::part": ["terminal", "actionable"], "::placeholder": ["terminal"], "::selection": ["terminal"], "::slotted": ["terminal"], "::spelling-error": ["terminal"], "::target-text": ["terminal"], "::file-selector-button": ["terminal", "actionable"], "::-webkit-progress-bar": ["terminal", "actionable"], "::-webkit-scrollbar": ["terminal", "actionable"], "::-webkit-scrollbar-button": ["terminal", "actionable"], "::-webkit-scrollbar-thumb": ["terminal", "actionable"], "::-webkit-scrollbar-track": ["terminal", "actionable"], "::-webkit-scrollbar-track-piece": ["terminal", "actionable"], "::-webkit-scrollbar-corner": ["terminal", "actionable"], "::-webkit-resizer": ["terminal", "actionable"], ":after": ["terminal", "jumpable"], ":before": ["terminal", "jumpable"], ":first-letter": ["terminal", "jumpable"], ":first-line": ["terminal", "jumpable"], __default__: ["actionable"] };
function at(t2) {
  let [e2] = cf(t2);
  return e2.forEach(([r2, n2]) => r2.removeChild(n2)), t2.nodes.push(...e2.map(([, r2]) => r2)), t2;
}
function cf(t2) {
  var n2;
  let e2 = [], r2 = null;
  for (let i2 of t2.nodes)
    if (i2.type === "combinator")
      e2 = e2.filter(([, a2]) => Rs(a2).includes("jumpable")), r2 = null;
    else if (i2.type === "pseudo") {
      Y0(i2) ? (r2 = i2, e2.push([t2, i2, null])) : r2 && H0(i2, r2) ? e2.push([t2, i2, r2]) : r2 = null;
      for (let a2 of (n2 = i2.nodes) != null ? n2 : []) {
        let [s2, o2] = cf(a2);
        r2 = o2 || r2, e2.push(...s2);
      }
    }
  return [e2, r2];
}
function pf(t2) {
  return t2.value.startsWith("::") || Is[t2.value] !== void 0;
}
function Y0(t2) {
  return pf(t2) && Rs(t2).includes("terminal");
}
function H0(t2, e2) {
  return t2.type !== "pseudo" || pf(t2) ? false : Rs(e2).includes("actionable");
}
function Rs(t2) {
  var e2;
  return (e2 = Is[t2.value]) != null ? e2 : Is.__default__;
}
var Ds = ":merge";
function ot(t2, { context: e2, candidate: r2 }) {
  var s2;
  let n2 = (s2 = e2 == null ? void 0 : e2.tailwindConfig.prefix) != null ? s2 : "", i2 = t2.map((o2) => {
    let l2 = (0, be.default)().astSync(o2.format);
    return { ...o2, ast: o2.isArbitraryVariant ? l2 : it(n2, l2) };
  }), a2 = be.default.root({ nodes: [be.default.selector({ nodes: [be.default.className({ value: re(r2) })] })] });
  for (let { ast: o2 } of i2)
    [a2, o2] = J0(a2, o2), o2.walkNesting((l2) => l2.replaceWith(...a2.nodes[0].nodes)), a2 = o2;
  return a2;
}
function df(t2) {
  let e2 = [];
  for (; t2.prev() && t2.prev().type !== "combinator"; )
    t2 = t2.prev();
  for (; t2 && t2.type !== "combinator"; )
    e2.push(t2), t2 = t2.next();
  return e2;
}
function Q0(t2) {
  return t2.sort((e2, r2) => e2.type === "tag" && r2.type === "class" ? -1 : e2.type === "class" && r2.type === "tag" ? 1 : e2.type === "class" && r2.type === "pseudo" && r2.value.startsWith("::") ? -1 : e2.type === "pseudo" && e2.value.startsWith("::") && r2.type === "class" ? 1 : t2.index(e2) - t2.index(r2)), t2;
}
function Ms(t2, e2) {
  let r2 = false;
  t2.walk((n2) => {
    if (n2.type === "class" && n2.value === e2)
      return r2 = true, false;
  }), r2 || t2.remove();
}
function on(t2, e2, { context: r2, candidate: n2, base: i2 }) {
  var f2, p2;
  let a2 = (p2 = (f2 = r2 == null ? void 0 : r2.tailwindConfig) == null ? void 0 : f2.separator) != null ? p2 : ":";
  i2 = i2 != null ? i2 : n2.split(new RegExp(`\\${a2}(?![^[]*\\])`)).pop();
  let s2 = (0, be.default)().astSync(t2);
  s2.walkClasses((c2) => {
    c2.raws && c2.value.includes(i2) && (c2.raws.value = re((0, hf.default)(c2.raws.value)));
  }), s2.each((c2) => Ms(c2, i2));
  let o2 = Array.isArray(e2) ? ot(e2, { context: r2, candidate: n2 }) : e2;
  if (o2 === null)
    return s2.toString();
  let l2 = be.default.comment({ value: "/*__simple__*/" }), u2 = be.default.comment({ value: "/*__simple__*/" });
  return s2.walkClasses((c2) => {
    if (c2.value !== i2)
      return;
    let d2 = c2.parent, h2 = o2.nodes[0].nodes;
    if (d2.nodes.length === 1) {
      c2.replaceWith(...h2);
      return;
    }
    let y3 = df(c2);
    d2.insertBefore(y3[0], l2), d2.insertAfter(y3[y3.length - 1], u2);
    for (let g2 of h2)
      d2.insertBefore(y3[0], g2.clone());
    c2.remove(), y3 = df(l2);
    let m = d2.index(l2);
    d2.nodes.splice(m, y3.length, ...Q0(be.default.selector({ nodes: y3 })).nodes), l2.remove(), u2.remove();
  }), s2.walkPseudos((c2) => {
    c2.value === Ds && c2.replaceWith(c2.nodes);
  }), s2.each((c2) => at(c2)), s2.toString();
}
function J0(t2, e2) {
  let r2 = [];
  return t2.walkPseudos((n2) => {
    n2.value === Ds && r2.push({ pseudo: n2, value: n2.nodes[0].toString() });
  }), e2.walkPseudos((n2) => {
    if (n2.value !== Ds)
      return;
    let i2 = n2.nodes[0].toString(), a2 = r2.find((u2) => u2.value === i2);
    if (!a2)
      return;
    let s2 = [], o2 = n2.next();
    for (; o2 && o2.type !== "combinator"; )
      s2.push(o2), o2 = o2.next();
    let l2 = o2;
    a2.pseudo.parent.insertAfter(a2.pseudo, be.default.selector({ nodes: s2.map((u2) => u2.clone()) })), n2.remove(), s2.forEach((u2) => u2.remove()), l2 && l2.type === "combinator" && l2.remove();
  }), [t2, e2];
}
function Fs(t2) {
  return Be(`.${re(t2)}`);
}
function ln(t2, e2) {
  return Fs(or(t2, e2));
}
function or(t2, e2) {
  return e2 === "DEFAULT" ? t2 : e2 === "-" || e2 === "-DEFAULT" ? `-${t2}` : e2.startsWith("-") ? `-${t2}${e2}` : e2.startsWith("/") ? `${t2}${e2}` : `${t2}-${e2}`;
}
var Cf = H(qs());
var Vs = H(ve());
function Ce(t2) {
  return ["fontSize", "outline"].includes(t2) ? (e2) => (typeof e2 == "function" && (e2 = e2({})), Array.isArray(e2) && (e2 = e2[0]), e2) : t2 === "fontFamily" ? (e2) => {
    typeof e2 == "function" && (e2 = e2({}));
    let r2 = Array.isArray(e2) && X(e2[1]) ? e2[0] : e2;
    return Array.isArray(r2) ? r2.join(", ") : r2;
  } : ["boxShadow", "transitionProperty", "transitionDuration", "transitionDelay", "transitionTimingFunction", "backgroundImage", "backgroundSize", "backgroundColor", "cursor", "animation"].includes(t2) ? (e2) => (typeof e2 == "function" && (e2 = e2({})), Array.isArray(e2) && (e2 = e2.join(", ")), e2) : ["gridTemplateColumns", "gridTemplateRows", "objectPosition"].includes(t2) ? (e2) => (typeof e2 == "function" && (e2 = e2({})), typeof e2 == "string" && (e2 = R.list.comma(e2).join(" ")), e2) : (e2, r2 = {}) => (typeof e2 == "function" && (e2 = e2(r2)), e2);
}
vr();
kt();
function T(t2, e2 = [[t2, [t2]]], { filterDefault: r2 = false, ...n2 } = {}) {
  let i2 = Ce(t2);
  return function({ matchUtilities: a2, theme: s2 }) {
    var o2;
    for (let l2 of e2) {
      let u2 = Array.isArray(l2[0]) ? l2 : [l2];
      a2(u2.reduce((f2, [p2, c2]) => Object.assign(f2, { [p2]: (d2) => c2.reduce((h2, y3) => Array.isArray(y3) ? Object.assign(h2, { [y3[0]]: y3[1] }) : Object.assign(h2, { [y3]: i2(d2) }), {}) }), {}), { ...n2, values: r2 ? Object.fromEntries(Object.entries((o2 = s2(t2)) != null ? o2 : {}).filter(([f2]) => f2 !== "DEFAULT")) : s2(t2) });
    }
  };
}
function Me(t2) {
  return t2 = Array.isArray(t2) ? t2 : [t2], t2.map((e2) => {
    let r2 = e2.values.map((n2) => n2.raw !== void 0 ? n2.raw : [n2.min && `(min-width: ${n2.min})`, n2.max && `(max-width: ${n2.max})`].filter(Boolean).join(" and "));
    return e2.not ? `not all and ${r2}` : r2;
  }).join(", ");
}
var X0 = /* @__PURE__ */ new Set(["normal", "reverse", "alternate", "alternate-reverse"]);
var K0 = /* @__PURE__ */ new Set(["running", "paused"]);
var Z0 = /* @__PURE__ */ new Set(["none", "forwards", "backwards", "both"]);
var ev = /* @__PURE__ */ new Set(["infinite"]);
var tv = /* @__PURE__ */ new Set(["linear", "ease", "ease-in", "ease-out", "ease-in-out", "step-start", "step-end"]);
var rv = ["cubic-bezier", "steps"];
var nv = /\,(?![^(]*\))/g;
var iv = /\ +(?![^(]*\))/g;
var mf = /^(-?[\d.]+m?s)$/;
var sv = /^(\d+)$/;
function $s(t2) {
  return t2.split(nv).map((r2) => {
    let n2 = r2.trim(), i2 = { value: n2 }, a2 = n2.split(iv), s2 = /* @__PURE__ */ new Set();
    for (let o2 of a2)
      !s2.has("DIRECTIONS") && X0.has(o2) ? (i2.direction = o2, s2.add("DIRECTIONS")) : !s2.has("PLAY_STATES") && K0.has(o2) ? (i2.playState = o2, s2.add("PLAY_STATES")) : !s2.has("FILL_MODES") && Z0.has(o2) ? (i2.fillMode = o2, s2.add("FILL_MODES")) : !s2.has("ITERATION_COUNTS") && (ev.has(o2) || sv.test(o2)) ? (i2.iterationCount = o2, s2.add("ITERATION_COUNTS")) : !s2.has("TIMING_FUNCTION") && tv.has(o2) || !s2.has("TIMING_FUNCTION") && rv.some((l2) => o2.startsWith(`${l2}(`)) ? (i2.timingFunction = o2, s2.add("TIMING_FUNCTION")) : !s2.has("DURATION") && mf.test(o2) ? (i2.duration = o2, s2.add("DURATION")) : !s2.has("DELAY") && mf.test(o2) ? (i2.delay = o2, s2.add("DELAY")) : s2.has("NAME") ? (i2.unknown || (i2.unknown = []), i2.unknown.push(o2)) : (i2.name = o2, s2.add("NAME"));
    return i2;
  });
}
var gf = (t2) => Object.assign({}, ...Object.entries(t2 != null ? t2 : {}).flatMap(([e2, r2]) => typeof r2 == "object" ? Object.entries(gf(r2)).map(([n2, i2]) => ({ [e2 + (n2 === "DEFAULT" ? "" : `-${n2}`)]: i2 })) : [{ [`${e2}`]: r2 }]));
var Q = gf;
function M(t2) {
  return typeof t2 == "function" ? t2({}) : t2;
}
function Fe(t2, e2 = true) {
  return Array.isArray(t2) ? t2.map((r2) => {
    if (e2 && Array.isArray(r2))
      throw new Error("The tuple syntax is not supported for `screens`.");
    if (typeof r2 == "string")
      return { name: r2.toString(), not: false, values: [{ min: r2, max: void 0 }] };
    let [n2, i2] = r2;
    return n2 = n2.toString(), typeof i2 == "string" ? { name: n2, not: false, values: [{ min: i2, max: void 0 }] } : Array.isArray(i2) ? { name: n2, not: false, values: i2.map((a2) => yf(a2)) } : { name: n2, not: false, values: [yf(i2)] };
  }) : Fe(Object.entries(t2 != null ? t2 : {}), false);
}
function un(t2) {
  return t2.values.length !== 1 ? { result: false, reason: "multiple-values" } : t2.values[0].raw !== void 0 ? { result: false, reason: "raw-values" } : t2.values[0].min !== void 0 && t2.values[0].max !== void 0 ? { result: false, reason: "min-and-max" } : { result: true, reason: null };
}
function vf(t2, e2, r2) {
  let n2 = fn(e2, t2), i2 = fn(r2, t2), a2 = un(n2), s2 = un(i2);
  if (a2.reason === "multiple-values" || s2.reason === "multiple-values")
    throw new Error("Attempted to sort a screen with multiple values. This should never happen. Please open a bug report.");
  if (a2.reason === "raw-values" || s2.reason === "raw-values")
    throw new Error("Attempted to sort a screen with raw values. This should never happen. Please open a bug report.");
  if (a2.reason === "min-and-max" || s2.reason === "min-and-max")
    throw new Error("Attempted to sort a screen with both min and max values. This should never happen. Please open a bug report.");
  let { min: o2, max: l2 } = n2.values[0], { min: u2, max: f2 } = i2.values[0];
  e2.not && ([o2, l2] = [l2, o2]), r2.not && ([u2, f2] = [f2, u2]), o2 = o2 === void 0 ? o2 : parseFloat(o2), l2 = l2 === void 0 ? l2 : parseFloat(l2), u2 = u2 === void 0 ? u2 : parseFloat(u2), f2 = f2 === void 0 ? f2 : parseFloat(f2);
  let [p2, c2] = t2 === "min" ? [o2, u2] : [f2, l2];
  return p2 - c2;
}
function fn(t2, e2) {
  return typeof t2 == "object" ? t2 : { name: "arbitrary-screen", values: [{ [e2]: t2 }] };
}
function yf({ "min-width": t2, min: e2 = t2, max: r2, raw: n2 } = {}) {
  return { min: e2, max: r2, raw: n2 };
}
function cn(t2, e2) {
  t2.walkDecls((r2) => {
    if (e2.includes(r2.prop)) {
      r2.remove();
      return;
    }
    for (let n2 of e2)
      r2.value.includes(`/ var(${n2})`) && (r2.value = r2.value.replace(`/ var(${n2})`, ""));
  });
}
var ne = { pseudoElementVariants: ({ addVariant: t2 }) => {
  t2("first-letter", "&::first-letter"), t2("first-line", "&::first-line"), t2("marker", [({ container: e2 }) => (cn(e2, ["--tw-text-opacity"]), "& *::marker"), ({ container: e2 }) => (cn(e2, ["--tw-text-opacity"]), "&::marker")]), t2("selection", ["& *::selection", "&::selection"]), t2("file", "&::file-selector-button"), t2("placeholder", "&::placeholder"), t2("backdrop", "&::backdrop"), t2("before", ({ container: e2 }) => (e2.walkRules((r2) => {
    let n2 = false;
    r2.walkDecls("content", () => {
      n2 = true;
    }), n2 || r2.prepend(R.decl({ prop: "content", value: "var(--tw-content)" }));
  }), "&::before")), t2("after", ({ container: e2 }) => (e2.walkRules((r2) => {
    let n2 = false;
    r2.walkDecls("content", () => {
      n2 = true;
    }), n2 || r2.prepend(R.decl({ prop: "content", value: "var(--tw-content)" }));
  }), "&::after"));
}, pseudoClassVariants: ({ addVariant: t2, matchVariant: e2, config: r2 }) => {
  let n2 = [["first", "&:first-child"], ["last", "&:last-child"], ["only", "&:only-child"], ["odd", "&:nth-child(odd)"], ["even", "&:nth-child(even)"], "first-of-type", "last-of-type", "only-of-type", ["visited", ({ container: a2 }) => (cn(a2, ["--tw-text-opacity", "--tw-border-opacity", "--tw-bg-opacity"]), "&:visited")], "target", ["open", "&[open]"], "default", "checked", "indeterminate", "placeholder-shown", "autofill", "optional", "required", "valid", "invalid", "in-range", "out-of-range", "read-only", "empty", "focus-within", ["hover", G(r2(), "hoverOnlyWhenSupported") ? "@media (hover: hover) and (pointer: fine) { &:hover }" : "&:hover"], "focus", "focus-visible", "active", "enabled", "disabled"].map((a2) => Array.isArray(a2) ? a2 : [a2, `&:${a2}`]);
  for (let [a2, s2] of n2)
    t2(a2, (o2) => typeof s2 == "function" ? s2(o2) : s2);
  let i2 = { group: (a2, { modifier: s2 }) => s2 ? [`:merge(.group\\/${re(s2)})`, " &"] : [":merge(.group)", " &"], peer: (a2, { modifier: s2 }) => s2 ? [`:merge(.peer\\/${re(s2)})`, " ~ &"] : [":merge(.peer)", " ~ &"] };
  for (let [a2, s2] of Object.entries(i2))
    e2(a2, (o2 = "", l2) => {
      let u2 = z(typeof o2 == "function" ? o2(l2) : o2);
      u2.includes("&") || (u2 = "&" + u2);
      let [f2, p2] = s2("", l2), c2 = null, d2 = null, h2 = 0;
      for (let y3 = 0; y3 < u2.length; ++y3) {
        let m = u2[y3];
        m === "&" ? c2 = y3 : m === "'" || m === '"' ? h2 += 1 : c2 !== null && m === " " && !h2 && (d2 = y3);
      }
      return c2 !== null && d2 === null && (d2 = u2.length), u2.slice(0, c2) + f2 + u2.slice(c2 + 1, d2) + p2 + u2.slice(d2);
    }, { values: Object.fromEntries(n2) });
}, directionVariants: ({ addVariant: t2 }) => {
  t2("ltr", ':is([dir="ltr"] &)'), t2("rtl", ':is([dir="rtl"] &)');
}, reducedMotionVariants: ({ addVariant: t2 }) => {
  t2("motion-safe", "@media (prefers-reduced-motion: no-preference)"), t2("motion-reduce", "@media (prefers-reduced-motion: reduce)");
}, darkVariants: ({ config: t2, addVariant: e2 }) => {
  let [r2, n2 = ".dark"] = [].concat(t2("darkMode", "media"));
  r2 === false && (r2 = "media", L.warn("darkmode-false", ["The `darkMode` option in your Tailwind CSS configuration is set to `false`, which now behaves the same as `media`.", "Change `darkMode` to `media` or remove it entirely.", "https://tailwindcss.com/docs/upgrade-guide#remove-dark-mode-configuration"])), r2 === "class" ? e2("dark", `:is(${n2} &)`) : r2 === "media" && e2("dark", "@media (prefers-color-scheme: dark)");
}, printVariant: ({ addVariant: t2 }) => {
  t2("print", "@media print");
}, screenVariants: ({ theme: t2, addVariant: e2, matchVariant: r2 }) => {
  var g2;
  let n2 = (g2 = t2("screens")) != null ? g2 : {}, i2 = Object.values(n2).every((w2) => typeof w2 == "string"), a2 = Fe(t2("screens")), s2 = /* @__PURE__ */ new Set([]);
  function o2(w2) {
    var b3, v2;
    return (v2 = (b3 = w2.match(/(\D+)$/)) == null ? void 0 : b3[1]) != null ? v2 : "(none)";
  }
  function l2(w2) {
    w2 !== void 0 && s2.add(o2(w2));
  }
  function u2(w2) {
    return l2(w2), s2.size === 1;
  }
  for (let w2 of a2)
    for (let b3 of w2.values)
      l2(b3.min), l2(b3.max);
  let f2 = s2.size <= 1;
  function p2(w2) {
    return Object.fromEntries(a2.filter((b3) => un(b3).result).map((b3) => {
      let { min: v2, max: O2 } = b3.values[0];
      if (w2 === "min" && v2 !== void 0)
        return b3;
      if (w2 === "min" && O2 !== void 0)
        return { ...b3, not: !b3.not };
      if (w2 === "max" && O2 !== void 0)
        return b3;
      if (w2 === "max" && v2 !== void 0)
        return { ...b3, not: !b3.not };
    }).map((b3) => [b3.name, b3]));
  }
  function c2(w2) {
    return (b3, v2) => vf(w2, b3.value, v2.value);
  }
  let d2 = c2("max"), h2 = c2("min");
  function y3(w2) {
    return (b3) => {
      if (i2)
        if (f2) {
          if (typeof b3 == "string" && !u2(b3))
            return L.warn("minmax-have-mixed-units", ["The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."]), [];
        } else
          return L.warn("mixed-screen-units", ["The `min-*` and `max-*` variants are not supported with a `screens` configuration containing mixed units."]), [];
      else
        return L.warn("complex-screen-config", ["The `min-*` and `max-*` variants are not supported with a `screens` configuration containing objects."]), [];
      return [`@media ${Me(fn(b3, w2))}`];
    };
  }
  r2("max", y3("max"), { sort: d2, values: i2 ? p2("max") : {} });
  let m = "min-screens";
  for (let w2 of a2)
    e2(w2.name, `@media ${Me(w2)}`, { id: m, sort: i2 && f2 ? h2 : void 0, value: w2 });
  r2("min", y3("min"), { id: m, sort: h2 });
}, supportsVariants: ({ matchVariant: t2, theme: e2 }) => {
  var r2;
  t2("supports", (n2 = "") => {
    let i2 = z(n2), a2 = /^\w*\s*\(/.test(i2);
    return i2 = a2 ? i2.replace(/\b(and|or|not)\b/g, " $1 ") : i2, a2 ? `@supports ${i2}` : (i2.includes(":") || (i2 = `${i2}: var(--tw)`), i2.startsWith("(") && i2.endsWith(")") || (i2 = `(${i2})`), `@supports ${i2}`);
  }, { values: (r2 = e2("supports")) != null ? r2 : {} });
}, ariaVariants: ({ matchVariant: t2, theme: e2 }) => {
  var r2, n2, i2;
  t2("aria", (a2) => `&[aria-${z(a2)}]`, { values: (r2 = e2("aria")) != null ? r2 : {} }), t2("group-aria", (a2, { modifier: s2 }) => s2 ? `:merge(.group\\/${s2})[aria-${z(a2)}] &` : `:merge(.group)[aria-${z(a2)}] &`, { values: (n2 = e2("aria")) != null ? n2 : {} }), t2("peer-aria", (a2, { modifier: s2 }) => s2 ? `:merge(.peer\\/${s2})[aria-${z(a2)}] ~ &` : `:merge(.peer)[aria-${z(a2)}] ~ &`, { values: (i2 = e2("aria")) != null ? i2 : {} });
}, dataVariants: ({ matchVariant: t2, theme: e2 }) => {
  var r2, n2, i2;
  t2("data", (a2) => `&[data-${z(a2)}]`, { values: (r2 = e2("data")) != null ? r2 : {} }), t2("group-data", (a2, { modifier: s2 }) => s2 ? `:merge(.group\\/${s2})[data-${z(a2)}] &` : `:merge(.group)[data-${z(a2)}] &`, { values: (n2 = e2("data")) != null ? n2 : {} }), t2("peer-data", (a2, { modifier: s2 }) => s2 ? `:merge(.peer\\/${s2})[data-${z(a2)}] ~ &` : `:merge(.peer)[data-${z(a2)}] ~ &`, { values: (i2 = e2("data")) != null ? i2 : {} });
}, orientationVariants: ({ addVariant: t2 }) => {
  t2("portrait", "@media (orientation: portrait)"), t2("landscape", "@media (orientation: landscape)");
}, prefersContrastVariants: ({ addVariant: t2 }) => {
  t2("contrast-more", "@media (prefers-contrast: more)"), t2("contrast-less", "@media (prefers-contrast: less)");
} };
var he = ["translate(var(--tw-translate-x), var(--tw-translate-y))", "rotate(var(--tw-rotate))", "skewX(var(--tw-skew-x))", "skewY(var(--tw-skew-y))", "scaleX(var(--tw-scale-x))", "scaleY(var(--tw-scale-y))"].join(" ");
var xe = ["var(--tw-blur)", "var(--tw-brightness)", "var(--tw-contrast)", "var(--tw-grayscale)", "var(--tw-hue-rotate)", "var(--tw-invert)", "var(--tw-saturate)", "var(--tw-sepia)", "var(--tw-drop-shadow)"].join(" ");
var Se = ["var(--tw-backdrop-blur)", "var(--tw-backdrop-brightness)", "var(--tw-backdrop-contrast)", "var(--tw-backdrop-grayscale)", "var(--tw-backdrop-hue-rotate)", "var(--tw-backdrop-invert)", "var(--tw-backdrop-opacity)", "var(--tw-backdrop-saturate)", "var(--tw-backdrop-sepia)"].join(" ");
var wf = { preflight: ({ addBase: t2 }) => {
  let e2 = R.parse(ht.readFileSync(Kn("/", "./css/preflight.css"), "utf8"));
  t2([R.comment({ text: `! tailwindcss v${$a} | MIT License | https://tailwindcss.com` }), ...e2.nodes]);
}, container: (() => {
  function t2(r2 = []) {
    return r2.flatMap((n2) => n2.values.map((i2) => i2.min)).filter((n2) => n2 !== void 0);
  }
  function e2(r2, n2, i2) {
    if (typeof i2 > "u")
      return [];
    if (!(typeof i2 == "object" && i2 !== null))
      return [{ screen: "DEFAULT", minWidth: 0, padding: i2 }];
    let a2 = [];
    i2.DEFAULT && a2.push({ screen: "DEFAULT", minWidth: 0, padding: i2.DEFAULT });
    for (let s2 of r2)
      for (let o2 of n2)
        for (let { min: l2 } of o2.values)
          l2 === s2 && a2.push({ minWidth: s2, padding: i2[o2.name] });
    return a2;
  }
  return function({ addComponents: r2, theme: n2 }) {
    let i2 = Fe(n2("container.screens", n2("screens"))), a2 = t2(i2), s2 = e2(a2, i2, n2("container.padding")), o2 = (u2) => {
      let f2 = s2.find((p2) => p2.minWidth === u2);
      return f2 ? { paddingRight: f2.padding, paddingLeft: f2.padding } : {};
    }, l2 = Array.from(new Set(a2.slice().sort((u2, f2) => parseInt(u2) - parseInt(f2)))).map((u2) => ({ [`@media (min-width: ${u2})`]: { ".container": { "max-width": u2, ...o2(u2) } } }));
    r2([{ ".container": Object.assign({ width: "100%" }, n2("container.center", false) ? { marginRight: "auto", marginLeft: "auto" } : {}, o2(0)) }, ...l2]);
  };
})(), accessibility: ({ addUtilities: t2 }) => {
  t2({ ".sr-only": { position: "absolute", width: "1px", height: "1px", padding: "0", margin: "-1px", overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0" }, ".not-sr-only": { position: "static", width: "auto", height: "auto", padding: "0", margin: "0", overflow: "visible", clip: "auto", whiteSpace: "normal" } });
}, pointerEvents: ({ addUtilities: t2 }) => {
  t2({ ".pointer-events-none": { "pointer-events": "none" }, ".pointer-events-auto": { "pointer-events": "auto" } });
}, visibility: ({ addUtilities: t2 }) => {
  t2({ ".visible": { visibility: "visible" }, ".invisible": { visibility: "hidden" }, ".collapse": { visibility: "collapse" } });
}, position: ({ addUtilities: t2 }) => {
  t2({ ".static": { position: "static" }, ".fixed": { position: "fixed" }, ".absolute": { position: "absolute" }, ".relative": { position: "relative" }, ".sticky": { position: "sticky" } });
}, inset: T("inset", [["inset", ["inset"]], [["inset-x", ["left", "right"]], ["inset-y", ["top", "bottom"]]], [["start", ["inset-inline-start"]], ["end", ["inset-inline-end"]], ["top", ["top"]], ["right", ["right"]], ["bottom", ["bottom"]], ["left", ["left"]]]], { supportsNegativeValues: true }), isolation: ({ addUtilities: t2 }) => {
  t2({ ".isolate": { isolation: "isolate" }, ".isolation-auto": { isolation: "auto" } });
}, zIndex: T("zIndex", [["z", ["zIndex"]]], { supportsNegativeValues: true }), order: T("order", void 0, { supportsNegativeValues: true }), gridColumn: T("gridColumn", [["col", ["gridColumn"]]]), gridColumnStart: T("gridColumnStart", [["col-start", ["gridColumnStart"]]]), gridColumnEnd: T("gridColumnEnd", [["col-end", ["gridColumnEnd"]]]), gridRow: T("gridRow", [["row", ["gridRow"]]]), gridRowStart: T("gridRowStart", [["row-start", ["gridRowStart"]]]), gridRowEnd: T("gridRowEnd", [["row-end", ["gridRowEnd"]]]), float: ({ addUtilities: t2 }) => {
  t2({ ".float-right": { float: "right" }, ".float-left": { float: "left" }, ".float-none": { float: "none" } });
}, clear: ({ addUtilities: t2 }) => {
  t2({ ".clear-left": { clear: "left" }, ".clear-right": { clear: "right" }, ".clear-both": { clear: "both" }, ".clear-none": { clear: "none" } });
}, margin: T("margin", [["m", ["margin"]], [["mx", ["margin-left", "margin-right"]], ["my", ["margin-top", "margin-bottom"]]], [["ms", ["margin-inline-start"]], ["me", ["margin-inline-end"]], ["mt", ["margin-top"]], ["mr", ["margin-right"]], ["mb", ["margin-bottom"]], ["ml", ["margin-left"]]]], { supportsNegativeValues: true }), boxSizing: ({ addUtilities: t2 }) => {
  t2({ ".box-border": { "box-sizing": "border-box" }, ".box-content": { "box-sizing": "content-box" } });
}, lineClamp: ({ matchUtilities: t2, addUtilities: e2, theme: r2 }) => {
  t2({ "line-clamp": (n2) => ({ overflow: "hidden", display: "-webkit-box", "-webkit-box-orient": "vertical", "-webkit-line-clamp": `${n2}` }) }, { values: r2("lineClamp") }), e2({ ".line-clamp-none": { overflow: "visible", display: "block", "-webkit-box-orient": "horizontal", "-webkit-line-clamp": "none" } });
}, display: ({ addUtilities: t2 }) => {
  t2({ ".block": { display: "block" }, ".inline-block": { display: "inline-block" }, ".inline": { display: "inline" }, ".flex": { display: "flex" }, ".inline-flex": { display: "inline-flex" }, ".table": { display: "table" }, ".inline-table": { display: "inline-table" }, ".table-caption": { display: "table-caption" }, ".table-cell": { display: "table-cell" }, ".table-column": { display: "table-column" }, ".table-column-group": { display: "table-column-group" }, ".table-footer-group": { display: "table-footer-group" }, ".table-header-group": { display: "table-header-group" }, ".table-row-group": { display: "table-row-group" }, ".table-row": { display: "table-row" }, ".flow-root": { display: "flow-root" }, ".grid": { display: "grid" }, ".inline-grid": { display: "inline-grid" }, ".contents": { display: "contents" }, ".list-item": { display: "list-item" }, ".hidden": { display: "none" } });
}, aspectRatio: T("aspectRatio", [["aspect", ["aspect-ratio"]]]), height: T("height", [["h", ["height"]]]), maxHeight: T("maxHeight", [["max-h", ["maxHeight"]]]), minHeight: T("minHeight", [["min-h", ["minHeight"]]]), width: T("width", [["w", ["width"]]]), minWidth: T("minWidth", [["min-w", ["minWidth"]]]), maxWidth: T("maxWidth", [["max-w", ["maxWidth"]]]), flex: T("flex"), flexShrink: T("flexShrink", [["flex-shrink", ["flex-shrink"]], ["shrink", ["flex-shrink"]]]), flexGrow: T("flexGrow", [["flex-grow", ["flex-grow"]], ["grow", ["flex-grow"]]]), flexBasis: T("flexBasis", [["basis", ["flex-basis"]]]), tableLayout: ({ addUtilities: t2 }) => {
  t2({ ".table-auto": { "table-layout": "auto" }, ".table-fixed": { "table-layout": "fixed" } });
}, captionSide: ({ addUtilities: t2 }) => {
  t2({ ".caption-top": { "caption-side": "top" }, ".caption-bottom": { "caption-side": "bottom" } });
}, borderCollapse: ({ addUtilities: t2 }) => {
  t2({ ".border-collapse": { "border-collapse": "collapse" }, ".border-separate": { "border-collapse": "separate" } });
}, borderSpacing: ({ addDefaults: t2, matchUtilities: e2, theme: r2 }) => {
  t2("border-spacing", { "--tw-border-spacing-x": 0, "--tw-border-spacing-y": 0 }), e2({ "border-spacing": (n2) => ({ "--tw-border-spacing-x": n2, "--tw-border-spacing-y": n2, "@defaults border-spacing": {}, "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)" }), "border-spacing-x": (n2) => ({ "--tw-border-spacing-x": n2, "@defaults border-spacing": {}, "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)" }), "border-spacing-y": (n2) => ({ "--tw-border-spacing-y": n2, "@defaults border-spacing": {}, "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)" }) }, { values: r2("borderSpacing") });
}, transformOrigin: T("transformOrigin", [["origin", ["transformOrigin"]]]), translate: T("translate", [[["translate-x", [["@defaults transform", {}], "--tw-translate-x", ["transform", he]]], ["translate-y", [["@defaults transform", {}], "--tw-translate-y", ["transform", he]]]]], { supportsNegativeValues: true }), rotate: T("rotate", [["rotate", [["@defaults transform", {}], "--tw-rotate", ["transform", he]]]], { supportsNegativeValues: true }), skew: T("skew", [[["skew-x", [["@defaults transform", {}], "--tw-skew-x", ["transform", he]]], ["skew-y", [["@defaults transform", {}], "--tw-skew-y", ["transform", he]]]]], { supportsNegativeValues: true }), scale: T("scale", [["scale", [["@defaults transform", {}], "--tw-scale-x", "--tw-scale-y", ["transform", he]]], [["scale-x", [["@defaults transform", {}], "--tw-scale-x", ["transform", he]]], ["scale-y", [["@defaults transform", {}], "--tw-scale-y", ["transform", he]]]]], { supportsNegativeValues: true }), transform: ({ addDefaults: t2, addUtilities: e2 }) => {
  t2("transform", { "--tw-translate-x": "0", "--tw-translate-y": "0", "--tw-rotate": "0", "--tw-skew-x": "0", "--tw-skew-y": "0", "--tw-scale-x": "1", "--tw-scale-y": "1" }), e2({ ".transform": { "@defaults transform": {}, transform: he }, ".transform-cpu": { transform: he }, ".transform-gpu": { transform: he.replace("translate(var(--tw-translate-x), var(--tw-translate-y))", "translate3d(var(--tw-translate-x), var(--tw-translate-y), 0)") }, ".transform-none": { transform: "none" } });
}, animation: ({ matchUtilities: t2, theme: e2, config: r2 }) => {
  var a2;
  let n2 = (s2) => `${r2("prefix")}${re(s2)}`, i2 = Object.fromEntries(Object.entries((a2 = e2("keyframes")) != null ? a2 : {}).map(([s2, o2]) => [s2, { [`@keyframes ${n2(s2)}`]: o2 }]));
  t2({ animate: (s2) => {
    let o2 = $s(s2);
    return [...o2.flatMap((l2) => i2[l2.name]), { animation: o2.map(({ name: l2, value: u2 }) => l2 === void 0 || i2[l2] === void 0 ? u2 : u2.replace(l2, n2(l2))).join(", ") }];
  } }, { values: e2("animation") });
}, cursor: T("cursor"), touchAction: ({ addDefaults: t2, addUtilities: e2 }) => {
  t2("touch-action", { "--tw-pan-x": " ", "--tw-pan-y": " ", "--tw-pinch-zoom": " " });
  let r2 = "var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)";
  e2({ ".touch-auto": { "touch-action": "auto" }, ".touch-none": { "touch-action": "none" }, ".touch-pan-x": { "@defaults touch-action": {}, "--tw-pan-x": "pan-x", "touch-action": r2 }, ".touch-pan-left": { "@defaults touch-action": {}, "--tw-pan-x": "pan-left", "touch-action": r2 }, ".touch-pan-right": { "@defaults touch-action": {}, "--tw-pan-x": "pan-right", "touch-action": r2 }, ".touch-pan-y": { "@defaults touch-action": {}, "--tw-pan-y": "pan-y", "touch-action": r2 }, ".touch-pan-up": { "@defaults touch-action": {}, "--tw-pan-y": "pan-up", "touch-action": r2 }, ".touch-pan-down": { "@defaults touch-action": {}, "--tw-pan-y": "pan-down", "touch-action": r2 }, ".touch-pinch-zoom": { "@defaults touch-action": {}, "--tw-pinch-zoom": "pinch-zoom", "touch-action": r2 }, ".touch-manipulation": { "touch-action": "manipulation" } });
}, userSelect: ({ addUtilities: t2 }) => {
  t2({ ".select-none": { "user-select": "none" }, ".select-text": { "user-select": "text" }, ".select-all": { "user-select": "all" }, ".select-auto": { "user-select": "auto" } });
}, resize: ({ addUtilities: t2 }) => {
  t2({ ".resize-none": { resize: "none" }, ".resize-y": { resize: "vertical" }, ".resize-x": { resize: "horizontal" }, ".resize": { resize: "both" } });
}, scrollSnapType: ({ addDefaults: t2, addUtilities: e2 }) => {
  t2("scroll-snap-type", { "--tw-scroll-snap-strictness": "proximity" }), e2({ ".snap-none": { "scroll-snap-type": "none" }, ".snap-x": { "@defaults scroll-snap-type": {}, "scroll-snap-type": "x var(--tw-scroll-snap-strictness)" }, ".snap-y": { "@defaults scroll-snap-type": {}, "scroll-snap-type": "y var(--tw-scroll-snap-strictness)" }, ".snap-both": { "@defaults scroll-snap-type": {}, "scroll-snap-type": "both var(--tw-scroll-snap-strictness)" }, ".snap-mandatory": { "--tw-scroll-snap-strictness": "mandatory" }, ".snap-proximity": { "--tw-scroll-snap-strictness": "proximity" } });
}, scrollSnapAlign: ({ addUtilities: t2 }) => {
  t2({ ".snap-start": { "scroll-snap-align": "start" }, ".snap-end": { "scroll-snap-align": "end" }, ".snap-center": { "scroll-snap-align": "center" }, ".snap-align-none": { "scroll-snap-align": "none" } });
}, scrollSnapStop: ({ addUtilities: t2 }) => {
  t2({ ".snap-normal": { "scroll-snap-stop": "normal" }, ".snap-always": { "scroll-snap-stop": "always" } });
}, scrollMargin: T("scrollMargin", [["scroll-m", ["scroll-margin"]], [["scroll-mx", ["scroll-margin-left", "scroll-margin-right"]], ["scroll-my", ["scroll-margin-top", "scroll-margin-bottom"]]], [["scroll-ms", ["scroll-margin-inline-start"]], ["scroll-me", ["scroll-margin-inline-end"]], ["scroll-mt", ["scroll-margin-top"]], ["scroll-mr", ["scroll-margin-right"]], ["scroll-mb", ["scroll-margin-bottom"]], ["scroll-ml", ["scroll-margin-left"]]]], { supportsNegativeValues: true }), scrollPadding: T("scrollPadding", [["scroll-p", ["scroll-padding"]], [["scroll-px", ["scroll-padding-left", "scroll-padding-right"]], ["scroll-py", ["scroll-padding-top", "scroll-padding-bottom"]]], [["scroll-ps", ["scroll-padding-inline-start"]], ["scroll-pe", ["scroll-padding-inline-end"]], ["scroll-pt", ["scroll-padding-top"]], ["scroll-pr", ["scroll-padding-right"]], ["scroll-pb", ["scroll-padding-bottom"]], ["scroll-pl", ["scroll-padding-left"]]]]), listStylePosition: ({ addUtilities: t2 }) => {
  t2({ ".list-inside": { "list-style-position": "inside" }, ".list-outside": { "list-style-position": "outside" } });
}, listStyleType: T("listStyleType", [["list", ["listStyleType"]]]), listStyleImage: T("listStyleImage", [["list-image", ["listStyleImage"]]]), appearance: ({ addUtilities: t2 }) => {
  t2({ ".appearance-none": { appearance: "none" } });
}, columns: T("columns", [["columns", ["columns"]]]), breakBefore: ({ addUtilities: t2 }) => {
  t2({ ".break-before-auto": { "break-before": "auto" }, ".break-before-avoid": { "break-before": "avoid" }, ".break-before-all": { "break-before": "all" }, ".break-before-avoid-page": { "break-before": "avoid-page" }, ".break-before-page": { "break-before": "page" }, ".break-before-left": { "break-before": "left" }, ".break-before-right": { "break-before": "right" }, ".break-before-column": { "break-before": "column" } });
}, breakInside: ({ addUtilities: t2 }) => {
  t2({ ".break-inside-auto": { "break-inside": "auto" }, ".break-inside-avoid": { "break-inside": "avoid" }, ".break-inside-avoid-page": { "break-inside": "avoid-page" }, ".break-inside-avoid-column": { "break-inside": "avoid-column" } });
}, breakAfter: ({ addUtilities: t2 }) => {
  t2({ ".break-after-auto": { "break-after": "auto" }, ".break-after-avoid": { "break-after": "avoid" }, ".break-after-all": { "break-after": "all" }, ".break-after-avoid-page": { "break-after": "avoid-page" }, ".break-after-page": { "break-after": "page" }, ".break-after-left": { "break-after": "left" }, ".break-after-right": { "break-after": "right" }, ".break-after-column": { "break-after": "column" } });
}, gridAutoColumns: T("gridAutoColumns", [["auto-cols", ["gridAutoColumns"]]]), gridAutoFlow: ({ addUtilities: t2 }) => {
  t2({ ".grid-flow-row": { gridAutoFlow: "row" }, ".grid-flow-col": { gridAutoFlow: "column" }, ".grid-flow-dense": { gridAutoFlow: "dense" }, ".grid-flow-row-dense": { gridAutoFlow: "row dense" }, ".grid-flow-col-dense": { gridAutoFlow: "column dense" } });
}, gridAutoRows: T("gridAutoRows", [["auto-rows", ["gridAutoRows"]]]), gridTemplateColumns: T("gridTemplateColumns", [["grid-cols", ["gridTemplateColumns"]]]), gridTemplateRows: T("gridTemplateRows", [["grid-rows", ["gridTemplateRows"]]]), flexDirection: ({ addUtilities: t2 }) => {
  t2({ ".flex-row": { "flex-direction": "row" }, ".flex-row-reverse": { "flex-direction": "row-reverse" }, ".flex-col": { "flex-direction": "column" }, ".flex-col-reverse": { "flex-direction": "column-reverse" } });
}, flexWrap: ({ addUtilities: t2 }) => {
  t2({ ".flex-wrap": { "flex-wrap": "wrap" }, ".flex-wrap-reverse": { "flex-wrap": "wrap-reverse" }, ".flex-nowrap": { "flex-wrap": "nowrap" } });
}, placeContent: ({ addUtilities: t2 }) => {
  t2({ ".place-content-center": { "place-content": "center" }, ".place-content-start": { "place-content": "start" }, ".place-content-end": { "place-content": "end" }, ".place-content-between": { "place-content": "space-between" }, ".place-content-around": { "place-content": "space-around" }, ".place-content-evenly": { "place-content": "space-evenly" }, ".place-content-baseline": { "place-content": "baseline" }, ".place-content-stretch": { "place-content": "stretch" } });
}, placeItems: ({ addUtilities: t2 }) => {
  t2({ ".place-items-start": { "place-items": "start" }, ".place-items-end": { "place-items": "end" }, ".place-items-center": { "place-items": "center" }, ".place-items-baseline": { "place-items": "baseline" }, ".place-items-stretch": { "place-items": "stretch" } });
}, alignContent: ({ addUtilities: t2 }) => {
  t2({ ".content-normal": { "align-content": "normal" }, ".content-center": { "align-content": "center" }, ".content-start": { "align-content": "flex-start" }, ".content-end": { "align-content": "flex-end" }, ".content-between": { "align-content": "space-between" }, ".content-around": { "align-content": "space-around" }, ".content-evenly": { "align-content": "space-evenly" }, ".content-baseline": { "align-content": "baseline" }, ".content-stretch": { "align-content": "stretch" } });
}, alignItems: ({ addUtilities: t2 }) => {
  t2({ ".items-start": { "align-items": "flex-start" }, ".items-end": { "align-items": "flex-end" }, ".items-center": { "align-items": "center" }, ".items-baseline": { "align-items": "baseline" }, ".items-stretch": { "align-items": "stretch" } });
}, justifyContent: ({ addUtilities: t2 }) => {
  t2({ ".justify-normal": { "justify-content": "normal" }, ".justify-start": { "justify-content": "flex-start" }, ".justify-end": { "justify-content": "flex-end" }, ".justify-center": { "justify-content": "center" }, ".justify-between": { "justify-content": "space-between" }, ".justify-around": { "justify-content": "space-around" }, ".justify-evenly": { "justify-content": "space-evenly" }, ".justify-stretch": { "justify-content": "stretch" } });
}, justifyItems: ({ addUtilities: t2 }) => {
  t2({ ".justify-items-start": { "justify-items": "start" }, ".justify-items-end": { "justify-items": "end" }, ".justify-items-center": { "justify-items": "center" }, ".justify-items-stretch": { "justify-items": "stretch" } });
}, gap: T("gap", [["gap", ["gap"]], [["gap-x", ["columnGap"]], ["gap-y", ["rowGap"]]]]), space: ({ matchUtilities: t2, addUtilities: e2, theme: r2 }) => {
  t2({ "space-x": (n2) => (n2 = n2 === "0" ? "0px" : n2, { "& > :not([hidden]) ~ :not([hidden])": { "--tw-space-x-reverse": "0", "margin-right": `calc(${n2} * var(--tw-space-x-reverse))`, "margin-left": `calc(${n2} * calc(1 - var(--tw-space-x-reverse)))` } }), "space-y": (n2) => (n2 = n2 === "0" ? "0px" : n2, { "& > :not([hidden]) ~ :not([hidden])": { "--tw-space-y-reverse": "0", "margin-top": `calc(${n2} * calc(1 - var(--tw-space-y-reverse)))`, "margin-bottom": `calc(${n2} * var(--tw-space-y-reverse))` } }) }, { values: r2("space"), supportsNegativeValues: true }), e2({ ".space-y-reverse > :not([hidden]) ~ :not([hidden])": { "--tw-space-y-reverse": "1" }, ".space-x-reverse > :not([hidden]) ~ :not([hidden])": { "--tw-space-x-reverse": "1" } });
}, divideWidth: ({ matchUtilities: t2, addUtilities: e2, theme: r2 }) => {
  t2({ "divide-x": (n2) => (n2 = n2 === "0" ? "0px" : n2, { "& > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-x-reverse": "0", "border-right-width": `calc(${n2} * var(--tw-divide-x-reverse))`, "border-left-width": `calc(${n2} * calc(1 - var(--tw-divide-x-reverse)))` } }), "divide-y": (n2) => (n2 = n2 === "0" ? "0px" : n2, { "& > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-y-reverse": "0", "border-top-width": `calc(${n2} * calc(1 - var(--tw-divide-y-reverse)))`, "border-bottom-width": `calc(${n2} * var(--tw-divide-y-reverse))` } }) }, { values: r2("divideWidth"), type: ["line-width", "length", "any"] }), e2({ ".divide-y-reverse > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-y-reverse": "1" }, ".divide-x-reverse > :not([hidden]) ~ :not([hidden])": { "@defaults border-width": {}, "--tw-divide-x-reverse": "1" } });
}, divideStyle: ({ addUtilities: t2 }) => {
  t2({ ".divide-solid > :not([hidden]) ~ :not([hidden])": { "border-style": "solid" }, ".divide-dashed > :not([hidden]) ~ :not([hidden])": { "border-style": "dashed" }, ".divide-dotted > :not([hidden]) ~ :not([hidden])": { "border-style": "dotted" }, ".divide-double > :not([hidden]) ~ :not([hidden])": { "border-style": "double" }, ".divide-none > :not([hidden]) ~ :not([hidden])": { "border-style": "none" } });
}, divideColor: ({ matchUtilities: t2, theme: e2, corePlugins: r2 }) => {
  t2({ divide: (n2) => r2("divideOpacity") ? { ["& > :not([hidden]) ~ :not([hidden])"]: Z({ color: n2, property: "border-color", variable: "--tw-divide-opacity" }) } : { ["& > :not([hidden]) ~ :not([hidden])"]: { "border-color": M(n2) } } }, { values: (({ DEFAULT: n2, ...i2 }) => i2)(Q(e2("divideColor"))), type: ["color", "any"] });
}, divideOpacity: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ "divide-opacity": (r2) => ({ ["& > :not([hidden]) ~ :not([hidden])"]: { "--tw-divide-opacity": r2 } }) }, { values: e2("divideOpacity") });
}, placeSelf: ({ addUtilities: t2 }) => {
  t2({ ".place-self-auto": { "place-self": "auto" }, ".place-self-start": { "place-self": "start" }, ".place-self-end": { "place-self": "end" }, ".place-self-center": { "place-self": "center" }, ".place-self-stretch": { "place-self": "stretch" } });
}, alignSelf: ({ addUtilities: t2 }) => {
  t2({ ".self-auto": { "align-self": "auto" }, ".self-start": { "align-self": "flex-start" }, ".self-end": { "align-self": "flex-end" }, ".self-center": { "align-self": "center" }, ".self-stretch": { "align-self": "stretch" }, ".self-baseline": { "align-self": "baseline" } });
}, justifySelf: ({ addUtilities: t2 }) => {
  t2({ ".justify-self-auto": { "justify-self": "auto" }, ".justify-self-start": { "justify-self": "start" }, ".justify-self-end": { "justify-self": "end" }, ".justify-self-center": { "justify-self": "center" }, ".justify-self-stretch": { "justify-self": "stretch" } });
}, overflow: ({ addUtilities: t2 }) => {
  t2({ ".overflow-auto": { overflow: "auto" }, ".overflow-hidden": { overflow: "hidden" }, ".overflow-clip": { overflow: "clip" }, ".overflow-visible": { overflow: "visible" }, ".overflow-scroll": { overflow: "scroll" }, ".overflow-x-auto": { "overflow-x": "auto" }, ".overflow-y-auto": { "overflow-y": "auto" }, ".overflow-x-hidden": { "overflow-x": "hidden" }, ".overflow-y-hidden": { "overflow-y": "hidden" }, ".overflow-x-clip": { "overflow-x": "clip" }, ".overflow-y-clip": { "overflow-y": "clip" }, ".overflow-x-visible": { "overflow-x": "visible" }, ".overflow-y-visible": { "overflow-y": "visible" }, ".overflow-x-scroll": { "overflow-x": "scroll" }, ".overflow-y-scroll": { "overflow-y": "scroll" } });
}, overscrollBehavior: ({ addUtilities: t2 }) => {
  t2({ ".overscroll-auto": { "overscroll-behavior": "auto" }, ".overscroll-contain": { "overscroll-behavior": "contain" }, ".overscroll-none": { "overscroll-behavior": "none" }, ".overscroll-y-auto": { "overscroll-behavior-y": "auto" }, ".overscroll-y-contain": { "overscroll-behavior-y": "contain" }, ".overscroll-y-none": { "overscroll-behavior-y": "none" }, ".overscroll-x-auto": { "overscroll-behavior-x": "auto" }, ".overscroll-x-contain": { "overscroll-behavior-x": "contain" }, ".overscroll-x-none": { "overscroll-behavior-x": "none" } });
}, scrollBehavior: ({ addUtilities: t2 }) => {
  t2({ ".scroll-auto": { "scroll-behavior": "auto" }, ".scroll-smooth": { "scroll-behavior": "smooth" } });
}, textOverflow: ({ addUtilities: t2 }) => {
  t2({ ".truncate": { overflow: "hidden", "text-overflow": "ellipsis", "white-space": "nowrap" }, ".overflow-ellipsis": { "text-overflow": "ellipsis" }, ".text-ellipsis": { "text-overflow": "ellipsis" }, ".text-clip": { "text-overflow": "clip" } });
}, hyphens: ({ addUtilities: t2 }) => {
  t2({ ".hyphens-none": { hyphens: "none" }, ".hyphens-manual": { hyphens: "manual" }, ".hyphens-auto": { hyphens: "auto" } });
}, whitespace: ({ addUtilities: t2 }) => {
  t2({ ".whitespace-normal": { "white-space": "normal" }, ".whitespace-nowrap": { "white-space": "nowrap" }, ".whitespace-pre": { "white-space": "pre" }, ".whitespace-pre-line": { "white-space": "pre-line" }, ".whitespace-pre-wrap": { "white-space": "pre-wrap" }, ".whitespace-break-spaces": { "white-space": "break-spaces" } });
}, wordBreak: ({ addUtilities: t2 }) => {
  t2({ ".break-normal": { "overflow-wrap": "normal", "word-break": "normal" }, ".break-words": { "overflow-wrap": "break-word" }, ".break-all": { "word-break": "break-all" }, ".break-keep": { "word-break": "keep-all" } });
}, borderRadius: T("borderRadius", [["rounded", ["border-radius"]], [["rounded-s", ["border-start-start-radius", "border-end-start-radius"]], ["rounded-e", ["border-start-end-radius", "border-end-end-radius"]], ["rounded-t", ["border-top-left-radius", "border-top-right-radius"]], ["rounded-r", ["border-top-right-radius", "border-bottom-right-radius"]], ["rounded-b", ["border-bottom-right-radius", "border-bottom-left-radius"]], ["rounded-l", ["border-top-left-radius", "border-bottom-left-radius"]]], [["rounded-ss", ["border-start-start-radius"]], ["rounded-se", ["border-start-end-radius"]], ["rounded-ee", ["border-end-end-radius"]], ["rounded-es", ["border-end-start-radius"]], ["rounded-tl", ["border-top-left-radius"]], ["rounded-tr", ["border-top-right-radius"]], ["rounded-br", ["border-bottom-right-radius"]], ["rounded-bl", ["border-bottom-left-radius"]]]]), borderWidth: T("borderWidth", [["border", [["@defaults border-width", {}], "border-width"]], [["border-x", [["@defaults border-width", {}], "border-left-width", "border-right-width"]], ["border-y", [["@defaults border-width", {}], "border-top-width", "border-bottom-width"]]], [["border-s", [["@defaults border-width", {}], "border-inline-start-width"]], ["border-e", [["@defaults border-width", {}], "border-inline-end-width"]], ["border-t", [["@defaults border-width", {}], "border-top-width"]], ["border-r", [["@defaults border-width", {}], "border-right-width"]], ["border-b", [["@defaults border-width", {}], "border-bottom-width"]], ["border-l", [["@defaults border-width", {}], "border-left-width"]]]], { type: ["line-width", "length"] }), borderStyle: ({ addUtilities: t2 }) => {
  t2({ ".border-solid": { "border-style": "solid" }, ".border-dashed": { "border-style": "dashed" }, ".border-dotted": { "border-style": "dotted" }, ".border-double": { "border-style": "double" }, ".border-hidden": { "border-style": "hidden" }, ".border-none": { "border-style": "none" } });
}, borderColor: ({ matchUtilities: t2, theme: e2, corePlugins: r2 }) => {
  t2({ border: (n2) => r2("borderOpacity") ? Z({ color: n2, property: "border-color", variable: "--tw-border-opacity" }) : { "border-color": M(n2) } }, { values: (({ DEFAULT: n2, ...i2 }) => i2)(Q(e2("borderColor"))), type: ["color", "any"] }), t2({ "border-x": (n2) => r2("borderOpacity") ? Z({ color: n2, property: ["border-left-color", "border-right-color"], variable: "--tw-border-opacity" }) : { "border-left-color": M(n2), "border-right-color": M(n2) }, "border-y": (n2) => r2("borderOpacity") ? Z({ color: n2, property: ["border-top-color", "border-bottom-color"], variable: "--tw-border-opacity" }) : { "border-top-color": M(n2), "border-bottom-color": M(n2) } }, { values: (({ DEFAULT: n2, ...i2 }) => i2)(Q(e2("borderColor"))), type: ["color", "any"] }), t2({ "border-s": (n2) => r2("borderOpacity") ? Z({ color: n2, property: "border-inline-start-color", variable: "--tw-border-opacity" }) : { "border-inline-start-color": M(n2) }, "border-e": (n2) => r2("borderOpacity") ? Z({ color: n2, property: "border-inline-end-color", variable: "--tw-border-opacity" }) : { "border-inline-end-color": M(n2) }, "border-t": (n2) => r2("borderOpacity") ? Z({ color: n2, property: "border-top-color", variable: "--tw-border-opacity" }) : { "border-top-color": M(n2) }, "border-r": (n2) => r2("borderOpacity") ? Z({ color: n2, property: "border-right-color", variable: "--tw-border-opacity" }) : { "border-right-color": M(n2) }, "border-b": (n2) => r2("borderOpacity") ? Z({ color: n2, property: "border-bottom-color", variable: "--tw-border-opacity" }) : { "border-bottom-color": M(n2) }, "border-l": (n2) => r2("borderOpacity") ? Z({ color: n2, property: "border-left-color", variable: "--tw-border-opacity" }) : { "border-left-color": M(n2) } }, { values: (({ DEFAULT: n2, ...i2 }) => i2)(Q(e2("borderColor"))), type: ["color", "any"] });
}, borderOpacity: T("borderOpacity", [["border-opacity", ["--tw-border-opacity"]]]), backgroundColor: ({ matchUtilities: t2, theme: e2, corePlugins: r2 }) => {
  t2({ bg: (n2) => r2("backgroundOpacity") ? Z({ color: n2, property: "background-color", variable: "--tw-bg-opacity" }) : { "background-color": M(n2) } }, { values: Q(e2("backgroundColor")), type: ["color", "any"] });
}, backgroundOpacity: T("backgroundOpacity", [["bg-opacity", ["--tw-bg-opacity"]]]), backgroundImage: T("backgroundImage", [["bg", ["background-image"]]], { type: ["lookup", "image", "url"] }), gradientColorStops: (() => {
  function t2(e2) {
    return we(e2, 0, "rgb(255 255 255 / 0)");
  }
  return function({ matchUtilities: e2, theme: r2, addDefaults: n2 }) {
    n2("gradient-color-stops", { "--tw-gradient-from-position": " ", "--tw-gradient-via-position": " ", "--tw-gradient-to-position": " " });
    let i2 = { values: Q(r2("gradientColorStops")), type: ["color", "any"] }, a2 = { values: r2("gradientColorStopPositions"), type: ["length", "percentage"] };
    e2({ from: (s2) => {
      let o2 = t2(s2);
      return { "@defaults gradient-color-stops": {}, "--tw-gradient-from": `${M(s2)} var(--tw-gradient-from-position)`, "--tw-gradient-to": `${o2} var(--tw-gradient-to-position)`, "--tw-gradient-stops": "var(--tw-gradient-from), var(--tw-gradient-to)" };
    } }, i2), e2({ from: (s2) => ({ "--tw-gradient-from-position": s2 }) }, a2), e2({ via: (s2) => {
      let o2 = t2(s2);
      return { "@defaults gradient-color-stops": {}, "--tw-gradient-to": `${o2}  var(--tw-gradient-to-position)`, "--tw-gradient-stops": `var(--tw-gradient-from), ${M(s2)} var(--tw-gradient-via-position), var(--tw-gradient-to)` };
    } }, i2), e2({ via: (s2) => ({ "--tw-gradient-via-position": s2 }) }, a2), e2({ to: (s2) => ({ "@defaults gradient-color-stops": {}, "--tw-gradient-to": `${M(s2)} var(--tw-gradient-to-position)` }) }, i2), e2({ to: (s2) => ({ "--tw-gradient-to-position": s2 }) }, a2);
  };
})(), boxDecorationBreak: ({ addUtilities: t2 }) => {
  t2({ ".decoration-slice": { "box-decoration-break": "slice" }, ".decoration-clone": { "box-decoration-break": "clone" }, ".box-decoration-slice": { "box-decoration-break": "slice" }, ".box-decoration-clone": { "box-decoration-break": "clone" } });
}, backgroundSize: T("backgroundSize", [["bg", ["background-size"]]], { type: ["lookup", "length", "percentage", "size"] }), backgroundAttachment: ({ addUtilities: t2 }) => {
  t2({ ".bg-fixed": { "background-attachment": "fixed" }, ".bg-local": { "background-attachment": "local" }, ".bg-scroll": { "background-attachment": "scroll" } });
}, backgroundClip: ({ addUtilities: t2 }) => {
  t2({ ".bg-clip-border": { "background-clip": "border-box" }, ".bg-clip-padding": { "background-clip": "padding-box" }, ".bg-clip-content": { "background-clip": "content-box" }, ".bg-clip-text": { "background-clip": "text" } });
}, backgroundPosition: T("backgroundPosition", [["bg", ["background-position"]]], { type: ["lookup", ["position", { preferOnConflict: true }]] }), backgroundRepeat: ({ addUtilities: t2 }) => {
  t2({ ".bg-repeat": { "background-repeat": "repeat" }, ".bg-no-repeat": { "background-repeat": "no-repeat" }, ".bg-repeat-x": { "background-repeat": "repeat-x" }, ".bg-repeat-y": { "background-repeat": "repeat-y" }, ".bg-repeat-round": { "background-repeat": "round" }, ".bg-repeat-space": { "background-repeat": "space" } });
}, backgroundOrigin: ({ addUtilities: t2 }) => {
  t2({ ".bg-origin-border": { "background-origin": "border-box" }, ".bg-origin-padding": { "background-origin": "padding-box" }, ".bg-origin-content": { "background-origin": "content-box" } });
}, fill: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ fill: (r2) => ({ fill: M(r2) }) }, { values: Q(e2("fill")), type: ["color", "any"] });
}, stroke: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ stroke: (r2) => ({ stroke: M(r2) }) }, { values: Q(e2("stroke")), type: ["color", "url", "any"] });
}, strokeWidth: T("strokeWidth", [["stroke", ["stroke-width"]]], { type: ["length", "number", "percentage"] }), objectFit: ({ addUtilities: t2 }) => {
  t2({ ".object-contain": { "object-fit": "contain" }, ".object-cover": { "object-fit": "cover" }, ".object-fill": { "object-fit": "fill" }, ".object-none": { "object-fit": "none" }, ".object-scale-down": { "object-fit": "scale-down" } });
}, objectPosition: T("objectPosition", [["object", ["object-position"]]]), padding: T("padding", [["p", ["padding"]], [["px", ["padding-left", "padding-right"]], ["py", ["padding-top", "padding-bottom"]]], [["ps", ["padding-inline-start"]], ["pe", ["padding-inline-end"]], ["pt", ["padding-top"]], ["pr", ["padding-right"]], ["pb", ["padding-bottom"]], ["pl", ["padding-left"]]]]), textAlign: ({ addUtilities: t2 }) => {
  t2({ ".text-left": { "text-align": "left" }, ".text-center": { "text-align": "center" }, ".text-right": { "text-align": "right" }, ".text-justify": { "text-align": "justify" }, ".text-start": { "text-align": "start" }, ".text-end": { "text-align": "end" } });
}, textIndent: T("textIndent", [["indent", ["text-indent"]]], { supportsNegativeValues: true }), verticalAlign: ({ addUtilities: t2, matchUtilities: e2 }) => {
  t2({ ".align-baseline": { "vertical-align": "baseline" }, ".align-top": { "vertical-align": "top" }, ".align-middle": { "vertical-align": "middle" }, ".align-bottom": { "vertical-align": "bottom" }, ".align-text-top": { "vertical-align": "text-top" }, ".align-text-bottom": { "vertical-align": "text-bottom" }, ".align-sub": { "vertical-align": "sub" }, ".align-super": { "vertical-align": "super" } }), e2({ align: (r2) => ({ "vertical-align": r2 }) });
}, fontFamily: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ font: (r2) => {
    let [n2, i2 = {}] = Array.isArray(r2) && X(r2[1]) ? r2 : [r2], { fontFeatureSettings: a2, fontVariationSettings: s2 } = i2;
    return { "font-family": Array.isArray(n2) ? n2.join(", ") : n2, ...a2 === void 0 ? {} : { "font-feature-settings": a2 }, ...s2 === void 0 ? {} : { "font-variation-settings": s2 } };
  } }, { values: e2("fontFamily"), type: ["lookup", "generic-name", "family-name"] });
}, fontSize: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ text: (r2, { modifier: n2 }) => {
    let [i2, a2] = Array.isArray(r2) ? r2 : [r2];
    if (n2)
      return { "font-size": i2, "line-height": n2 };
    let { lineHeight: s2, letterSpacing: o2, fontWeight: l2 } = X(a2) ? a2 : { lineHeight: a2 };
    return { "font-size": i2, ...s2 === void 0 ? {} : { "line-height": s2 }, ...o2 === void 0 ? {} : { "letter-spacing": o2 }, ...l2 === void 0 ? {} : { "font-weight": l2 } };
  } }, { values: e2("fontSize"), modifiers: e2("lineHeight"), type: ["absolute-size", "relative-size", "length", "percentage"] });
}, fontWeight: T("fontWeight", [["font", ["fontWeight"]]], { type: ["lookup", "number", "any"] }), textTransform: ({ addUtilities: t2 }) => {
  t2({ ".uppercase": { "text-transform": "uppercase" }, ".lowercase": { "text-transform": "lowercase" }, ".capitalize": { "text-transform": "capitalize" }, ".normal-case": { "text-transform": "none" } });
}, fontStyle: ({ addUtilities: t2 }) => {
  t2({ ".italic": { "font-style": "italic" }, ".not-italic": { "font-style": "normal" } });
}, fontVariantNumeric: ({ addDefaults: t2, addUtilities: e2 }) => {
  let r2 = "var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)";
  t2("font-variant-numeric", { "--tw-ordinal": " ", "--tw-slashed-zero": " ", "--tw-numeric-figure": " ", "--tw-numeric-spacing": " ", "--tw-numeric-fraction": " " }), e2({ ".normal-nums": { "font-variant-numeric": "normal" }, ".ordinal": { "@defaults font-variant-numeric": {}, "--tw-ordinal": "ordinal", "font-variant-numeric": r2 }, ".slashed-zero": { "@defaults font-variant-numeric": {}, "--tw-slashed-zero": "slashed-zero", "font-variant-numeric": r2 }, ".lining-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-figure": "lining-nums", "font-variant-numeric": r2 }, ".oldstyle-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-figure": "oldstyle-nums", "font-variant-numeric": r2 }, ".proportional-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-spacing": "proportional-nums", "font-variant-numeric": r2 }, ".tabular-nums": { "@defaults font-variant-numeric": {}, "--tw-numeric-spacing": "tabular-nums", "font-variant-numeric": r2 }, ".diagonal-fractions": { "@defaults font-variant-numeric": {}, "--tw-numeric-fraction": "diagonal-fractions", "font-variant-numeric": r2 }, ".stacked-fractions": { "@defaults font-variant-numeric": {}, "--tw-numeric-fraction": "stacked-fractions", "font-variant-numeric": r2 } });
}, lineHeight: T("lineHeight", [["leading", ["lineHeight"]]]), letterSpacing: T("letterSpacing", [["tracking", ["letterSpacing"]]], { supportsNegativeValues: true }), textColor: ({ matchUtilities: t2, theme: e2, corePlugins: r2 }) => {
  t2({ text: (n2) => r2("textOpacity") ? Z({ color: n2, property: "color", variable: "--tw-text-opacity" }) : { color: M(n2) } }, { values: Q(e2("textColor")), type: ["color", "any"] });
}, textOpacity: T("textOpacity", [["text-opacity", ["--tw-text-opacity"]]]), textDecoration: ({ addUtilities: t2 }) => {
  t2({ ".underline": { "text-decoration-line": "underline" }, ".overline": { "text-decoration-line": "overline" }, ".line-through": { "text-decoration-line": "line-through" }, ".no-underline": { "text-decoration-line": "none" } });
}, textDecorationColor: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ decoration: (r2) => ({ "text-decoration-color": M(r2) }) }, { values: Q(e2("textDecorationColor")), type: ["color", "any"] });
}, textDecorationStyle: ({ addUtilities: t2 }) => {
  t2({ ".decoration-solid": { "text-decoration-style": "solid" }, ".decoration-double": { "text-decoration-style": "double" }, ".decoration-dotted": { "text-decoration-style": "dotted" }, ".decoration-dashed": { "text-decoration-style": "dashed" }, ".decoration-wavy": { "text-decoration-style": "wavy" } });
}, textDecorationThickness: T("textDecorationThickness", [["decoration", ["text-decoration-thickness"]]], { type: ["length", "percentage"] }), textUnderlineOffset: T("textUnderlineOffset", [["underline-offset", ["text-underline-offset"]]], { type: ["length", "percentage", "any"] }), fontSmoothing: ({ addUtilities: t2 }) => {
  t2({ ".antialiased": { "-webkit-font-smoothing": "antialiased", "-moz-osx-font-smoothing": "grayscale" }, ".subpixel-antialiased": { "-webkit-font-smoothing": "auto", "-moz-osx-font-smoothing": "auto" } });
}, placeholderColor: ({ matchUtilities: t2, theme: e2, corePlugins: r2 }) => {
  t2({ placeholder: (n2) => r2("placeholderOpacity") ? { "&::placeholder": Z({ color: n2, property: "color", variable: "--tw-placeholder-opacity" }) } : { "&::placeholder": { color: M(n2) } } }, { values: Q(e2("placeholderColor")), type: ["color", "any"] });
}, placeholderOpacity: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ "placeholder-opacity": (r2) => ({ ["&::placeholder"]: { "--tw-placeholder-opacity": r2 } }) }, { values: e2("placeholderOpacity") });
}, caretColor: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ caret: (r2) => ({ "caret-color": M(r2) }) }, { values: Q(e2("caretColor")), type: ["color", "any"] });
}, accentColor: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ accent: (r2) => ({ "accent-color": M(r2) }) }, { values: Q(e2("accentColor")), type: ["color", "any"] });
}, opacity: T("opacity", [["opacity", ["opacity"]]]), backgroundBlendMode: ({ addUtilities: t2 }) => {
  t2({ ".bg-blend-normal": { "background-blend-mode": "normal" }, ".bg-blend-multiply": { "background-blend-mode": "multiply" }, ".bg-blend-screen": { "background-blend-mode": "screen" }, ".bg-blend-overlay": { "background-blend-mode": "overlay" }, ".bg-blend-darken": { "background-blend-mode": "darken" }, ".bg-blend-lighten": { "background-blend-mode": "lighten" }, ".bg-blend-color-dodge": { "background-blend-mode": "color-dodge" }, ".bg-blend-color-burn": { "background-blend-mode": "color-burn" }, ".bg-blend-hard-light": { "background-blend-mode": "hard-light" }, ".bg-blend-soft-light": { "background-blend-mode": "soft-light" }, ".bg-blend-difference": { "background-blend-mode": "difference" }, ".bg-blend-exclusion": { "background-blend-mode": "exclusion" }, ".bg-blend-hue": { "background-blend-mode": "hue" }, ".bg-blend-saturation": { "background-blend-mode": "saturation" }, ".bg-blend-color": { "background-blend-mode": "color" }, ".bg-blend-luminosity": { "background-blend-mode": "luminosity" } });
}, mixBlendMode: ({ addUtilities: t2 }) => {
  t2({ ".mix-blend-normal": { "mix-blend-mode": "normal" }, ".mix-blend-multiply": { "mix-blend-mode": "multiply" }, ".mix-blend-screen": { "mix-blend-mode": "screen" }, ".mix-blend-overlay": { "mix-blend-mode": "overlay" }, ".mix-blend-darken": { "mix-blend-mode": "darken" }, ".mix-blend-lighten": { "mix-blend-mode": "lighten" }, ".mix-blend-color-dodge": { "mix-blend-mode": "color-dodge" }, ".mix-blend-color-burn": { "mix-blend-mode": "color-burn" }, ".mix-blend-hard-light": { "mix-blend-mode": "hard-light" }, ".mix-blend-soft-light": { "mix-blend-mode": "soft-light" }, ".mix-blend-difference": { "mix-blend-mode": "difference" }, ".mix-blend-exclusion": { "mix-blend-mode": "exclusion" }, ".mix-blend-hue": { "mix-blend-mode": "hue" }, ".mix-blend-saturation": { "mix-blend-mode": "saturation" }, ".mix-blend-color": { "mix-blend-mode": "color" }, ".mix-blend-luminosity": { "mix-blend-mode": "luminosity" }, ".mix-blend-plus-lighter": { "mix-blend-mode": "plus-lighter" } });
}, boxShadow: (() => {
  let t2 = Ce("boxShadow"), e2 = ["var(--tw-ring-offset-shadow, 0 0 #0000)", "var(--tw-ring-shadow, 0 0 #0000)", "var(--tw-shadow)"].join(", ");
  return function({ matchUtilities: r2, addDefaults: n2, theme: i2 }) {
    n2(" box-shadow", { "--tw-ring-offset-shadow": "0 0 #0000", "--tw-ring-shadow": "0 0 #0000", "--tw-shadow": "0 0 #0000", "--tw-shadow-colored": "0 0 #0000" }), r2({ shadow: (a2) => {
      a2 = t2(a2);
      let s2 = nn(a2);
      for (let o2 of s2)
        !o2.valid || (o2.color = "var(--tw-shadow-color)");
      return { "@defaults box-shadow": {}, "--tw-shadow": a2 === "none" ? "0 0 #0000" : a2, "--tw-shadow-colored": a2 === "none" ? "0 0 #0000" : Vu(s2), "box-shadow": e2 };
    } }, { values: i2("boxShadow"), type: ["shadow"] });
  };
})(), boxShadowColor: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ shadow: (r2) => ({ "--tw-shadow-color": M(r2), "--tw-shadow": "var(--tw-shadow-colored)" }) }, { values: Q(e2("boxShadowColor")), type: ["color", "any"] });
}, outlineStyle: ({ addUtilities: t2 }) => {
  t2({ ".outline-none": { outline: "2px solid transparent", "outline-offset": "2px" }, ".outline": { "outline-style": "solid" }, ".outline-dashed": { "outline-style": "dashed" }, ".outline-dotted": { "outline-style": "dotted" }, ".outline-double": { "outline-style": "double" } });
}, outlineWidth: T("outlineWidth", [["outline", ["outline-width"]]], { type: ["length", "number", "percentage"] }), outlineOffset: T("outlineOffset", [["outline-offset", ["outline-offset"]]], { type: ["length", "number", "percentage", "any"], supportsNegativeValues: true }), outlineColor: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ outline: (r2) => ({ "outline-color": M(r2) }) }, { values: Q(e2("outlineColor")), type: ["color", "any"] });
}, ringWidth: ({ matchUtilities: t2, addDefaults: e2, addUtilities: r2, theme: n2, config: i2 }) => {
  let a2 = (() => {
    var o2, l2;
    if (G(i2(), "respectDefaultRingColorOpacity"))
      return n2("ringColor.DEFAULT");
    let s2 = n2("ringOpacity.DEFAULT", "0.5");
    return (o2 = n2("ringColor")) != null && o2.DEFAULT ? we((l2 = n2("ringColor")) == null ? void 0 : l2.DEFAULT, s2, `rgb(147 197 253 / ${s2})`) : `rgb(147 197 253 / ${s2})`;
  })();
  e2("ring-width", { "--tw-ring-inset": " ", "--tw-ring-offset-width": n2("ringOffsetWidth.DEFAULT", "0px"), "--tw-ring-offset-color": n2("ringOffsetColor.DEFAULT", "#fff"), "--tw-ring-color": a2, "--tw-ring-offset-shadow": "0 0 #0000", "--tw-ring-shadow": "0 0 #0000", "--tw-shadow": "0 0 #0000", "--tw-shadow-colored": "0 0 #0000" }), t2({ ring: (s2) => ({ "@defaults ring-width": {}, "--tw-ring-offset-shadow": "var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)", "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(${s2} + var(--tw-ring-offset-width)) var(--tw-ring-color)`, "box-shadow": ["var(--tw-ring-offset-shadow)", "var(--tw-ring-shadow)", "var(--tw-shadow, 0 0 #0000)"].join(", ") }) }, { values: n2("ringWidth"), type: "length" }), r2({ ".ring-inset": { "@defaults ring-width": {}, "--tw-ring-inset": "inset" } });
}, ringColor: ({ matchUtilities: t2, theme: e2, corePlugins: r2 }) => {
  t2({ ring: (n2) => r2("ringOpacity") ? Z({ color: n2, property: "--tw-ring-color", variable: "--tw-ring-opacity" }) : { "--tw-ring-color": M(n2) } }, { values: Object.fromEntries(Object.entries(Q(e2("ringColor"))).filter(([n2]) => n2 !== "DEFAULT")), type: ["color", "any"] });
}, ringOpacity: (t2) => {
  let { config: e2 } = t2;
  return T("ringOpacity", [["ring-opacity", ["--tw-ring-opacity"]]], { filterDefault: !G(e2(), "respectDefaultRingColorOpacity") })(t2);
}, ringOffsetWidth: T("ringOffsetWidth", [["ring-offset", ["--tw-ring-offset-width"]]], { type: "length" }), ringOffsetColor: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ "ring-offset": (r2) => ({ "--tw-ring-offset-color": M(r2) }) }, { values: Q(e2("ringOffsetColor")), type: ["color", "any"] });
}, blur: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ blur: (r2) => ({ "--tw-blur": `blur(${r2})`, "@defaults filter": {}, filter: xe }) }, { values: e2("blur") });
}, brightness: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ brightness: (r2) => ({ "--tw-brightness": `brightness(${r2})`, "@defaults filter": {}, filter: xe }) }, { values: e2("brightness") });
}, contrast: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ contrast: (r2) => ({ "--tw-contrast": `contrast(${r2})`, "@defaults filter": {}, filter: xe }) }, { values: e2("contrast") });
}, dropShadow: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ "drop-shadow": (r2) => ({ "--tw-drop-shadow": Array.isArray(r2) ? r2.map((n2) => `drop-shadow(${n2})`).join(" ") : `drop-shadow(${r2})`, "@defaults filter": {}, filter: xe }) }, { values: e2("dropShadow") });
}, grayscale: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ grayscale: (r2) => ({ "--tw-grayscale": `grayscale(${r2})`, "@defaults filter": {}, filter: xe }) }, { values: e2("grayscale") });
}, hueRotate: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ "hue-rotate": (r2) => ({ "--tw-hue-rotate": `hue-rotate(${r2})`, "@defaults filter": {}, filter: xe }) }, { values: e2("hueRotate"), supportsNegativeValues: true });
}, invert: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ invert: (r2) => ({ "--tw-invert": `invert(${r2})`, "@defaults filter": {}, filter: xe }) }, { values: e2("invert") });
}, saturate: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ saturate: (r2) => ({ "--tw-saturate": `saturate(${r2})`, "@defaults filter": {}, filter: xe }) }, { values: e2("saturate") });
}, sepia: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ sepia: (r2) => ({ "--tw-sepia": `sepia(${r2})`, "@defaults filter": {}, filter: xe }) }, { values: e2("sepia") });
}, filter: ({ addDefaults: t2, addUtilities: e2 }) => {
  t2("filter", { "--tw-blur": " ", "--tw-brightness": " ", "--tw-contrast": " ", "--tw-grayscale": " ", "--tw-hue-rotate": " ", "--tw-invert": " ", "--tw-saturate": " ", "--tw-sepia": " ", "--tw-drop-shadow": " " }), e2({ ".filter": { "@defaults filter": {}, filter: xe }, ".filter-none": { filter: "none" } });
}, backdropBlur: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ "backdrop-blur": (r2) => ({ "--tw-backdrop-blur": `blur(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e2("backdropBlur") });
}, backdropBrightness: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ "backdrop-brightness": (r2) => ({ "--tw-backdrop-brightness": `brightness(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e2("backdropBrightness") });
}, backdropContrast: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ "backdrop-contrast": (r2) => ({ "--tw-backdrop-contrast": `contrast(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e2("backdropContrast") });
}, backdropGrayscale: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ "backdrop-grayscale": (r2) => ({ "--tw-backdrop-grayscale": `grayscale(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e2("backdropGrayscale") });
}, backdropHueRotate: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ "backdrop-hue-rotate": (r2) => ({ "--tw-backdrop-hue-rotate": `hue-rotate(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e2("backdropHueRotate"), supportsNegativeValues: true });
}, backdropInvert: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ "backdrop-invert": (r2) => ({ "--tw-backdrop-invert": `invert(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e2("backdropInvert") });
}, backdropOpacity: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ "backdrop-opacity": (r2) => ({ "--tw-backdrop-opacity": `opacity(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e2("backdropOpacity") });
}, backdropSaturate: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ "backdrop-saturate": (r2) => ({ "--tw-backdrop-saturate": `saturate(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e2("backdropSaturate") });
}, backdropSepia: ({ matchUtilities: t2, theme: e2 }) => {
  t2({ "backdrop-sepia": (r2) => ({ "--tw-backdrop-sepia": `sepia(${r2})`, "@defaults backdrop-filter": {}, "backdrop-filter": Se }) }, { values: e2("backdropSepia") });
}, backdropFilter: ({ addDefaults: t2, addUtilities: e2 }) => {
  t2("backdrop-filter", { "--tw-backdrop-blur": " ", "--tw-backdrop-brightness": " ", "--tw-backdrop-contrast": " ", "--tw-backdrop-grayscale": " ", "--tw-backdrop-hue-rotate": " ", "--tw-backdrop-invert": " ", "--tw-backdrop-opacity": " ", "--tw-backdrop-saturate": " ", "--tw-backdrop-sepia": " " }), e2({ ".backdrop-filter": { "@defaults backdrop-filter": {}, "backdrop-filter": Se }, ".backdrop-filter-none": { "backdrop-filter": "none" } });
}, transitionProperty: ({ matchUtilities: t2, theme: e2 }) => {
  let r2 = e2("transitionTimingFunction.DEFAULT"), n2 = e2("transitionDuration.DEFAULT");
  t2({ transition: (i2) => ({ "transition-property": i2, ...i2 === "none" ? {} : { "transition-timing-function": r2, "transition-duration": n2 } }) }, { values: e2("transitionProperty") });
}, transitionDelay: T("transitionDelay", [["delay", ["transitionDelay"]]]), transitionDuration: T("transitionDuration", [["duration", ["transitionDuration"]]], { filterDefault: true }), transitionTimingFunction: T("transitionTimingFunction", [["ease", ["transitionTimingFunction"]]], { filterDefault: true }), willChange: T("willChange", [["will-change", ["will-change"]]]), content: T("content", [["content", ["--tw-content", ["content", "var(--tw-content)"]]]]) };
function Le(t2) {
  if (Array.isArray(t2))
    return t2;
  let e2 = t2.split("[").length - 1, r2 = t2.split("]").length - 1;
  if (e2 !== r2)
    throw new Error(`Path is invalid. Has unbalanced brackets: ${t2}`);
  return t2.split(/\.(?![^\[]*\])|[\[\]]/g).filter(Boolean);
}
var xf = /* @__PURE__ */ new Map([["{", "}"], ["[", "]"], ["(", ")"]]);
var bf = new Map(Array.from(xf.entries()).map(([t2, e2]) => [e2, t2]));
var av = /* @__PURE__ */ new Set(['"', "'", "`"]);
function lt(t2) {
  let e2 = [], r2 = false;
  for (let n2 = 0; n2 < t2.length; n2++) {
    let i2 = t2[n2];
    if (i2 === ":" && !r2 && e2.length === 0)
      return false;
    if (av.has(i2) && t2[n2 - 1] !== "\\" && (r2 = !r2), !r2 && t2[n2 - 1] !== "\\") {
      if (xf.has(i2))
        e2.push(i2);
      else if (bf.has(i2)) {
        let a2 = bf.get(i2);
        if (e2.length <= 0 || e2.pop() !== a2)
          return false;
      }
    }
  }
  return !(e2.length > 0);
}
function pn(t2) {
  return (t2 > 0n) - (t2 < 0n);
}
function Sf(t2, e2) {
  let r2 = 0n, n2 = 0n;
  for (let [i2, a2] of e2)
    t2 & i2 && (r2 = r2 | i2, n2 = n2 | a2);
  return t2 & ~r2 | n2;
}
var dn = class {
  constructor() {
    this.offsets = { defaults: 0n, base: 0n, components: 0n, utilities: 0n, variants: 0n, user: 0n }, this.layerPositions = { defaults: 0n, base: 1n, components: 2n, utilities: 3n, user: 4n, variants: 5n }, this.reservedVariantBits = 0n, this.variantOffsets = /* @__PURE__ */ new Map();
  }
  create(e2) {
    return { layer: e2, parentLayer: e2, arbitrary: 0n, variants: 0n, parallelIndex: 0n, index: this.offsets[e2]++, options: [] };
  }
  arbitraryProperty() {
    return { ...this.create("utilities"), arbitrary: 1n };
  }
  forVariant(e2, r2 = 0) {
    let n2 = this.variantOffsets.get(e2);
    if (n2 === void 0)
      throw new Error(`Cannot find offset for unknown variant ${e2}`);
    return { ...this.create("variants"), variants: n2 << BigInt(r2) };
  }
  applyVariantOffset(e2, r2, n2) {
    return n2.variant = r2.variants, { ...e2, layer: "variants", parentLayer: e2.layer === "variants" ? e2.parentLayer : e2.layer, variants: e2.variants | r2.variants, options: n2.sort ? [].concat(n2, e2.options) : e2.options, parallelIndex: kf([e2.parallelIndex, r2.parallelIndex]) };
  }
  applyParallelOffset(e2, r2) {
    return { ...e2, parallelIndex: BigInt(r2) };
  }
  recordVariants(e2, r2) {
    for (let n2 of e2)
      this.recordVariant(n2, r2(n2));
  }
  recordVariant(e2, r2 = 1) {
    return this.variantOffsets.set(e2, 1n << this.reservedVariantBits), this.reservedVariantBits += BigInt(r2), { ...this.create("variants"), variants: this.variantOffsets.get(e2) };
  }
  compare(e2, r2) {
    var n2;
    if (e2.layer !== r2.layer)
      return this.layerPositions[e2.layer] - this.layerPositions[r2.layer];
    if (e2.parentLayer !== r2.parentLayer)
      return this.layerPositions[e2.parentLayer] - this.layerPositions[r2.parentLayer];
    for (let i2 of e2.options)
      for (let a2 of r2.options) {
        if (i2.id !== a2.id || !i2.sort || !a2.sort)
          continue;
        let s2 = (n2 = kf([i2.variant, a2.variant])) != null ? n2 : 0n, o2 = ~(s2 | s2 - 1n), l2 = e2.variants & o2, u2 = r2.variants & o2;
        if (l2 !== u2)
          continue;
        let f2 = i2.sort({ value: i2.value, modifier: i2.modifier }, { value: a2.value, modifier: a2.modifier });
        if (f2 !== 0)
          return f2;
      }
    return e2.variants !== r2.variants ? e2.variants - r2.variants : e2.parallelIndex !== r2.parallelIndex ? e2.parallelIndex - r2.parallelIndex : e2.arbitrary !== r2.arbitrary ? e2.arbitrary - r2.arbitrary : e2.index - r2.index;
  }
  recalculateVariantOffsets() {
    let e2 = Array.from(this.variantOffsets.entries()).filter(([i2]) => i2.startsWith("[")).sort(([i2], [a2]) => ov(i2, a2)), r2 = e2.map(([, i2]) => i2).sort((i2, a2) => pn(i2 - a2));
    return e2.map(([, i2], a2) => [i2, r2[a2]]).filter(([i2, a2]) => i2 !== a2);
  }
  remapArbitraryVariantOffsets(e2) {
    let r2 = this.recalculateVariantOffsets();
    return r2.length === 0 ? e2 : e2.map((n2) => {
      let [i2, a2] = n2;
      return i2 = { ...i2, variants: Sf(i2.variants, r2) }, [i2, a2];
    });
  }
  sort(e2) {
    return e2 = this.remapArbitraryVariantOffsets(e2), e2.sort(([r2], [n2]) => pn(this.compare(r2, n2)));
  }
};
function kf(t2) {
  let e2 = null;
  for (let r2 of t2)
    e2 = e2 != null ? e2 : r2, e2 = e2 > r2 ? e2 : r2;
  return e2;
}
function ov(t2, e2) {
  let r2 = t2.length, n2 = e2.length, i2 = r2 < n2 ? r2 : n2;
  for (let a2 = 0; a2 < i2; a2++) {
    let s2 = t2.charCodeAt(a2) - e2.charCodeAt(a2);
    if (s2 !== 0)
      return s2;
  }
  return r2 - n2;
}
var Us = { AddVariant: Symbol.for("ADD_VARIANT"), MatchVariant: Symbol.for("MATCH_VARIANT") };
var zs = { Base: 1 << 0, Dynamic: 1 << 1 };
function js(t2, e2) {
  let r2 = t2.tailwindConfig.prefix;
  return typeof r2 == "function" ? r2(e2) : r2 + e2;
}
function Of({ type: t2 = "any", ...e2 }) {
  let r2 = [].concat(t2);
  return { ...e2, types: r2.map((n2) => Array.isArray(n2) ? { type: n2[0], ...n2[1] } : { type: n2, preferOnConflict: false }) };
}
function lv(t2) {
  let e2 = [], r2 = "", n2 = 0;
  for (let i2 = 0; i2 < t2.length; i2++) {
    let a2 = t2[i2];
    if (a2 === "\\")
      r2 += "\\" + t2[++i2];
    else if (a2 === "{")
      ++n2, e2.push(r2.trim()), r2 = "";
    else if (a2 === "}") {
      if (--n2 < 0)
        throw new Error("Your { and } are unbalanced.");
      e2.push(r2.trim()), r2 = "";
    } else
      r2 += a2;
  }
  return r2.length > 0 && e2.push(r2.trim()), e2 = e2.filter((i2) => i2 !== ""), e2;
}
function uv(t2, e2, { before: r2 = [] } = {}) {
  if (r2 = [].concat(r2), r2.length <= 0) {
    t2.push(e2);
    return;
  }
  let n2 = t2.length - 1;
  for (let i2 of r2) {
    let a2 = t2.indexOf(i2);
    a2 !== -1 && (n2 = Math.min(n2, a2));
  }
  t2.splice(n2, 0, e2);
}
function Af(t2) {
  return Array.isArray(t2) ? t2.flatMap((e2) => !Array.isArray(e2) && !X(e2) ? e2 : nt(e2)) : Af([t2]);
}
function Ef(t2, e2) {
  return (0, Vs.default)((n2) => {
    let i2 = [];
    return e2 && e2(n2), n2.walkClasses((a2) => {
      i2.push(a2.value);
    }), i2;
  }).transformSync(t2);
}
function fv(t2, e2 = { containsNonOnDemandable: false }, r2 = 0) {
  let n2 = [];
  if (t2.type === "rule") {
    let i2 = function(a2) {
      a2.walkPseudos((s2) => {
        s2.value === ":not" && s2.remove();
      });
    };
    for (let a2 of t2.selectors) {
      let s2 = Ef(a2, i2);
      s2.length === 0 && (e2.containsNonOnDemandable = true);
      for (let o2 of s2)
        n2.push(o2);
    }
  } else
    t2.type === "atrule" && t2.walkRules((i2) => {
      for (let a2 of i2.selectors.flatMap((s2) => Ef(s2)))
        n2.push(a2);
    });
  return r2 === 0 ? [e2.containsNonOnDemandable || n2.length === 0, n2] : n2;
}
function hn(t2) {
  return Af(t2).flatMap((e2) => {
    let r2 = /* @__PURE__ */ new Map(), [n2, i2] = fv(e2);
    return n2 && i2.unshift(ke), i2.map((a2) => (r2.has(e2) || r2.set(e2, e2), [a2, r2.get(e2)]));
  });
}
function mn(t2) {
  return t2.startsWith("@") || t2.includes("&");
}
function lr(t2) {
  t2 = t2.replace(/\n+/g, "").replace(/\s{1,}/g, " ").trim();
  let e2 = lv(t2).map((r2) => {
    if (!r2.startsWith("@"))
      return ({ format: a2 }) => a2(r2);
    let [, n2, i2] = /@(.*?)( .+|[({].*)/g.exec(r2);
    return ({ wrap: a2 }) => a2(R.atRule({ name: n2, params: i2.trim() }));
  }).reverse();
  return (r2) => {
    for (let n2 of e2)
      n2(r2);
  };
}
function cv(t2, e2, { variantList: r2, variantMap: n2, offsets: i2, classList: a2 }) {
  function s2(c2, d2) {
    return c2 ? (0, Cf.default)(t2, c2, d2) : t2;
  }
  function o2(c2) {
    return it(t2.prefix, c2);
  }
  function l2(c2, d2) {
    return c2 === ke ? ke : d2.respectPrefix ? e2.tailwindConfig.prefix + c2 : c2;
  }
  function u2(c2, d2, h2 = {}) {
    let y3 = Le(c2), m = s2(["theme", ...y3], d2);
    return Ce(y3[0])(m, h2);
  }
  let f2 = 0, p2 = { postcss: R, prefix: o2, e: re, config: s2, theme: u2, corePlugins: (c2) => Array.isArray(t2.corePlugins) ? t2.corePlugins.includes(c2) : s2(["corePlugins", c2], true), variants: () => [], addBase(c2) {
    for (let [d2, h2] of hn(c2)) {
      let y3 = l2(d2, {}), m = i2.create("base");
      e2.candidateRuleMap.has(y3) || e2.candidateRuleMap.set(y3, []), e2.candidateRuleMap.get(y3).push([{ sort: m, layer: "base" }, h2]);
    }
  }, addDefaults(c2, d2) {
    let h2 = { [`@defaults ${c2}`]: d2 };
    for (let [y3, m] of hn(h2)) {
      let g2 = l2(y3, {});
      e2.candidateRuleMap.has(g2) || e2.candidateRuleMap.set(g2, []), e2.candidateRuleMap.get(g2).push([{ sort: i2.create("defaults"), layer: "defaults" }, m]);
    }
  }, addComponents(c2, d2) {
    d2 = Object.assign({}, { preserveSource: false, respectPrefix: true, respectImportant: false }, Array.isArray(d2) ? {} : d2);
    for (let [y3, m] of hn(c2)) {
      let g2 = l2(y3, d2);
      a2.add(g2), e2.candidateRuleMap.has(g2) || e2.candidateRuleMap.set(g2, []), e2.candidateRuleMap.get(g2).push([{ sort: i2.create("components"), layer: "components", options: d2 }, m]);
    }
  }, addUtilities(c2, d2) {
    d2 = Object.assign({}, { preserveSource: false, respectPrefix: true, respectImportant: true }, Array.isArray(d2) ? {} : d2);
    for (let [y3, m] of hn(c2)) {
      let g2 = l2(y3, d2);
      a2.add(g2), e2.candidateRuleMap.has(g2) || e2.candidateRuleMap.set(g2, []), e2.candidateRuleMap.get(g2).push([{ sort: i2.create("utilities"), layer: "utilities", options: d2 }, m]);
    }
  }, matchUtilities: function(c2, d2) {
    d2 = Of({ ...{ respectPrefix: true, respectImportant: true, modifiers: false }, ...d2 });
    let y3 = i2.create("utilities");
    for (let m in c2) {
      let b3 = function(O2, { isOnlyPlugin: x2 }) {
        let [A, E2, I2] = Ts(d2.types, O2, d2, t2);
        if (A === void 0)
          return [];
        if (!d2.types.some(({ type: B2 }) => B2 === E2))
          if (x2)
            L.warn([`Unnecessary typehint \`${E2}\` in \`${m}-${O2}\`.`, `You can safely update it to \`${m}-${O2.replace(E2 + ":", "")}\`.`]);
          else
            return [];
        if (!lt(A))
          return [];
        let F = { get modifier() {
          return d2.modifiers || L.warn(`modifier-used-without-options-for-${m}`, ["Your plugin must set `modifiers: true` in its options to support modifiers."]), I2;
        } }, Y2 = G(t2, "generalizedModifiers");
        return [].concat(Y2 ? w2(A, F) : w2(A)).filter(Boolean).map((B2) => ({ [ln(m, O2)]: B2 }));
      }, g2 = l2(m, d2), w2 = c2[m];
      a2.add([g2, d2]);
      let v2 = [{ sort: y3, layer: "utilities", options: d2 }, b3];
      e2.candidateRuleMap.has(g2) || e2.candidateRuleMap.set(g2, []), e2.candidateRuleMap.get(g2).push(v2);
    }
  }, matchComponents: function(c2, d2) {
    d2 = Of({ ...{ respectPrefix: true, respectImportant: false, modifiers: false }, ...d2 });
    let y3 = i2.create("components");
    for (let m in c2) {
      let b3 = function(O2, { isOnlyPlugin: x2 }) {
        let [A, E2, I2] = Ts(d2.types, O2, d2, t2);
        if (A === void 0)
          return [];
        if (!d2.types.some(({ type: B2 }) => B2 === E2))
          if (x2)
            L.warn([`Unnecessary typehint \`${E2}\` in \`${m}-${O2}\`.`, `You can safely update it to \`${m}-${O2.replace(E2 + ":", "")}\`.`]);
          else
            return [];
        if (!lt(A))
          return [];
        let F = { get modifier() {
          return d2.modifiers || L.warn(`modifier-used-without-options-for-${m}`, ["Your plugin must set `modifiers: true` in its options to support modifiers."]), I2;
        } }, Y2 = G(t2, "generalizedModifiers");
        return [].concat(Y2 ? w2(A, F) : w2(A)).filter(Boolean).map((B2) => ({ [ln(m, O2)]: B2 }));
      }, g2 = l2(m, d2), w2 = c2[m];
      a2.add([g2, d2]);
      let v2 = [{ sort: y3, layer: "components", options: d2 }, b3];
      e2.candidateRuleMap.has(g2) || e2.candidateRuleMap.set(g2, []), e2.candidateRuleMap.get(g2).push(v2);
    }
  }, addVariant(c2, d2, h2 = {}) {
    d2 = [].concat(d2).map((y3) => {
      if (typeof y3 != "string")
        return (m = {}) => {
          let { args: g2, modifySelectors: w2, container: b3, separator: v2, wrap: O2, format: x2 } = m, A = y3(Object.assign({ modifySelectors: w2, container: b3, separator: v2 }, h2.type === Us.MatchVariant && { args: g2, wrap: O2, format: x2 }));
          if (typeof A == "string" && !mn(A))
            throw new Error(`Your custom variant \`${c2}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
          return Array.isArray(A) ? A.filter((E2) => typeof E2 == "string").map((E2) => lr(E2)) : A && typeof A == "string" && lr(A)(m);
        };
      if (!mn(y3))
        throw new Error(`Your custom variant \`${c2}\` has an invalid format string. Make sure it's an at-rule or contains a \`&\` placeholder.`);
      return lr(y3);
    }), uv(r2, c2, h2), n2.set(c2, d2), e2.variantOptions.set(c2, h2);
  }, matchVariant(c2, d2, h2) {
    var b3, v2, O2;
    let y3 = (b3 = h2 == null ? void 0 : h2.id) != null ? b3 : ++f2, m = c2 === "@", g2 = G(t2, "generalizedModifiers");
    for (let [x2, A] of Object.entries((v2 = h2 == null ? void 0 : h2.values) != null ? v2 : {}))
      x2 !== "DEFAULT" && p2.addVariant(m ? `${c2}${x2}` : `${c2}-${x2}`, ({ args: E2, container: I2 }) => d2(A, g2 ? { modifier: E2 == null ? void 0 : E2.modifier, container: I2 } : { container: I2 }), { ...h2, value: A, id: y3, type: Us.MatchVariant, variantInfo: zs.Base });
    let w2 = "DEFAULT" in ((O2 = h2 == null ? void 0 : h2.values) != null ? O2 : {});
    p2.addVariant(c2, ({ args: x2, container: A }) => {
      var E2;
      return (x2 == null ? void 0 : x2.value) === mt && !w2 ? null : d2((x2 == null ? void 0 : x2.value) === mt ? h2.values.DEFAULT : (E2 = x2 == null ? void 0 : x2.value) != null ? E2 : typeof x2 == "string" ? x2 : "", g2 ? { modifier: x2 == null ? void 0 : x2.modifier, container: A } : { container: A });
    }, { ...h2, id: y3, type: Us.MatchVariant, variantInfo: zs.Dynamic });
  } };
  return p2;
}
function _f(t2) {
  t2.walkAtRules((e2) => {
    ["responsive", "variants"].includes(e2.name) && (_f(e2), e2.before(e2.nodes), e2.remove());
  });
}
function pv(t2) {
  let e2 = [];
  return t2.each((r2) => {
    r2.type === "atrule" && ["responsive", "variants"].includes(r2.name) && (r2.name = "layer", r2.params = "utilities");
  }), t2.walkAtRules("layer", (r2) => {
    if (_f(r2), r2.params === "base") {
      for (let n2 of r2.nodes)
        e2.push(function({ addBase: i2 }) {
          i2(n2, { respectPrefix: false });
        });
      r2.remove();
    } else if (r2.params === "components") {
      for (let n2 of r2.nodes)
        e2.push(function({ addComponents: i2 }) {
          i2(n2, { respectPrefix: false, preserveSource: true });
        });
      r2.remove();
    } else if (r2.params === "utilities") {
      for (let n2 of r2.nodes)
        e2.push(function({ addUtilities: i2 }) {
          i2(n2, { respectPrefix: false, preserveSource: true });
        });
      r2.remove();
    }
  }), e2;
}
function dv(t2, e2) {
  let r2 = Object.entries({ ...ne, ...wf }).map(([o2, l2]) => t2.tailwindConfig.corePlugins.includes(o2) ? l2 : null).filter(Boolean), n2 = t2.tailwindConfig.plugins.map((o2) => (o2.__isOptionsFunction && (o2 = o2()), typeof o2 == "function" ? o2 : o2.handler)), i2 = pv(e2), a2 = [ne.pseudoElementVariants, ne.pseudoClassVariants, ne.ariaVariants, ne.dataVariants], s2 = [ne.supportsVariants, ne.directionVariants, ne.reducedMotionVariants, ne.prefersContrastVariants, ne.darkVariants, ne.printVariant, ne.screenVariants, ne.orientationVariants];
  return [...r2, ...a2, ...n2, ...s2, ...i2];
}
function hv(t2, e2) {
  var f2, p2, c2;
  let r2 = [], n2 = /* @__PURE__ */ new Map();
  e2.variantMap = n2;
  let i2 = new dn();
  e2.offsets = i2;
  let a2 = /* @__PURE__ */ new Set(), s2 = cv(e2.tailwindConfig, e2, { variantList: r2, variantMap: n2, offsets: i2, classList: a2 });
  for (let d2 of t2)
    if (Array.isArray(d2))
      for (let h2 of d2)
        h2(s2);
    else
      d2 == null || d2(s2);
  i2.recordVariants(r2, (d2) => n2.get(d2).length);
  for (let [d2, h2] of n2.entries())
    e2.variantMap.set(d2, h2.map((y3, m) => [i2.forVariant(d2, m), y3]));
  let o2 = ((f2 = e2.tailwindConfig.safelist) != null ? f2 : []).filter(Boolean);
  if (o2.length > 0) {
    let d2 = [];
    for (let h2 of o2) {
      if (typeof h2 == "string") {
        e2.changedContent.push({ content: h2, extension: "html" });
        continue;
      }
      if (h2 instanceof RegExp) {
        L.warn("root-regex", ["Regular expressions in `safelist` work differently in Tailwind CSS v3.0.", "Update your `safelist` configuration to eliminate this warning.", "https://tailwindcss.com/docs/content-configuration#safelisting-classes"]);
        continue;
      }
      d2.push(h2);
    }
    if (d2.length > 0) {
      let h2 = /* @__PURE__ */ new Map(), y3 = e2.tailwindConfig.prefix.length, m = d2.some((g2) => g2.pattern.source.includes("!"));
      for (let g2 of a2) {
        let w2 = Array.isArray(g2) ? (() => {
          var A;
          let [b3, v2] = g2, x2 = Object.keys((A = v2 == null ? void 0 : v2.values) != null ? A : {}).map((E2) => or(b3, E2));
          return v2 != null && v2.supportsNegativeValues && (x2 = [...x2, ...x2.map((E2) => "-" + E2)], x2 = [...x2, ...x2.map((E2) => E2.slice(0, y3) + "-" + E2.slice(y3))]), v2.types.some(({ type: E2 }) => E2 === "color") && (x2 = [...x2, ...x2.flatMap((E2) => Object.keys(e2.tailwindConfig.theme.opacity).map((I2) => `${E2}/${I2}`))]), m && (v2 == null ? void 0 : v2.respectImportant) && (x2 = [...x2, ...x2.map((E2) => "!" + E2)]), x2;
        })() : [g2];
        for (let b3 of w2)
          for (let { pattern: v2, variants: O2 = [] } of d2)
            if (v2.lastIndex = 0, h2.has(v2) || h2.set(v2, 0), !!v2.test(b3)) {
              h2.set(v2, h2.get(v2) + 1), e2.changedContent.push({ content: b3, extension: "html" });
              for (let x2 of O2)
                e2.changedContent.push({ content: x2 + e2.tailwindConfig.separator + b3, extension: "html" });
            }
      }
      for (let [g2, w2] of h2.entries())
        w2 === 0 && L.warn([`The safelist pattern \`${g2}\` doesn't match any Tailwind CSS classes.`, "Fix this pattern or remove it from your `safelist` configuration.", "https://tailwindcss.com/docs/content-configuration#safelisting-classes"]);
    }
  }
  let l2 = (c2 = [].concat((p2 = e2.tailwindConfig.darkMode) != null ? p2 : "media")[1]) != null ? c2 : "dark", u2 = [js(e2, l2), js(e2, "group"), js(e2, "peer")];
  e2.getClassOrder = function(h2) {
    let y3 = [...h2].sort((b3, v2) => b3 === v2 ? 0 : b3 < v2 ? -1 : 1), m = new Map(y3.map((b3) => [b3, null])), g2 = gn(new Set(y3), e2);
    g2 = e2.offsets.sort(g2);
    let w2 = BigInt(u2.length);
    for (let [, b3] of g2)
      m.set(b3.raws.tailwind.candidate, w2++);
    return h2.map((b3) => {
      var x2;
      let v2 = (x2 = m.get(b3)) != null ? x2 : null, O2 = u2.indexOf(b3);
      return v2 === null && O2 !== -1 && (v2 = BigInt(O2)), [b3, v2];
    });
  }, e2.getClassList = function(h2 = {}) {
    var m, g2, w2, b3;
    let y3 = [];
    for (let v2 of a2)
      if (Array.isArray(v2)) {
        let [O2, x2] = v2, A = [], E2 = Object.keys((m = x2 == null ? void 0 : x2.modifiers) != null ? m : {});
        (g2 = x2 == null ? void 0 : x2.types) != null && g2.some(({ type: Y2 }) => Y2 === "color") && E2.push(...Object.keys((w2 = e2.tailwindConfig.theme.opacity) != null ? w2 : {}));
        let I2 = { modifiers: E2 }, F = h2.includeMetadata && E2.length > 0;
        for (let [Y2, K2] of Object.entries((b3 = x2 == null ? void 0 : x2.values) != null ? b3 : {})) {
          if (K2 == null)
            continue;
          let B2 = or(O2, Y2);
          if (y3.push(F ? [B2, I2] : B2), (x2 == null ? void 0 : x2.supportsNegativeValues) && Re(K2)) {
            let qe2 = or(O2, `-${Y2}`);
            A.push(F ? [qe2, I2] : qe2);
          }
        }
        y3.push(...A);
      } else
        y3.push(v2);
    return y3;
  }, e2.getVariants = function() {
    var y3;
    let h2 = [];
    for (let [m, g2] of e2.variantOptions.entries())
      g2.variantInfo !== zs.Base && h2.push({ name: m, isArbitrary: g2.type === Symbol.for("MATCH_VARIANT"), values: Object.keys((y3 = g2.values) != null ? y3 : {}), hasDash: m !== "@", selectors({ modifier: w2, value: b3 } = {}) {
        var Ca, Aa, _a, Ta;
        let v2 = "__TAILWIND_PLACEHOLDER__", O2 = R.rule({ selector: `.${v2}` }), x2 = R.root({ nodes: [O2.clone()] }), A = x2.toString(), E2 = ((Ca = e2.variantMap.get(m)) != null ? Ca : []).flatMap(([ie2, se2]) => se2), I2 = [];
        for (let ie2 of E2) {
          let se2 = [], hr2 = { args: { modifier: w2, value: (_a = (Aa = g2.values) == null ? void 0 : Aa[b3]) != null ? _a : b3 }, separator: e2.tailwindConfig.separator, modifySelectors(pe2) {
            return x2.each((qn2) => {
              qn2.type === "rule" && (qn2.selectors = qn2.selectors.map((Pa) => pe2({ get className() {
                return Ws(Pa);
              }, selector: Pa })));
            }), x2;
          }, format(pe2) {
            se2.push(pe2);
          }, wrap(pe2) {
            se2.push(`@${pe2.name} ${pe2.params} { & }`);
          }, container: x2 }, mr2 = ie2(hr2);
          if (se2.length > 0 && I2.push(se2), Array.isArray(mr2))
            for (let pe2 of mr2)
              se2 = [], pe2(hr2), I2.push(se2);
        }
        let F = [], Y2 = x2.toString();
        A !== Y2 && (x2.walkRules((ie2) => {
          let se2 = ie2.selector, hr2 = (0, Vs.default)((mr2) => {
            mr2.walkClasses((pe2) => {
              pe2.value = `${m}${e2.tailwindConfig.separator}${pe2.value}`;
            });
          }).processSync(se2);
          F.push(se2.replace(hr2, "&").replace(v2, "&"));
        }), x2.walkAtRules((ie2) => {
          F.push(`@${ie2.name} (${ie2.params}) { & }`);
        }));
        let K2 = !(b3 in ((Ta = g2.values) != null ? Ta : {}));
        I2 = I2.map((ie2) => ie2.map((se2) => ({ format: se2, isArbitraryVariant: K2 }))), F = F.map((ie2) => ({ format: ie2, isArbitraryVariant: K2 }));
        let B2 = { candidate: v2, context: e2 }, qe2 = I2.map((ie2) => on(`.${v2}`, ot(ie2, B2), B2).replace(`.${v2}`, "&").replace("{ & }", "").trim());
        return F.length > 0 && qe2.push(ot(F, B2).toString().replace(`.${v2}`, "&")), qe2;
      } });
    return h2;
  };
}
function Tf(t2, e2) {
  !t2.classCache.has(e2) || (t2.notClassCache.add(e2), t2.classCache.delete(e2), t2.applyClassCache.delete(e2), t2.candidateRuleMap.delete(e2), t2.candidateRuleCache.delete(e2), t2.stylesheetCache = null);
}
function mv(t2, e2) {
  let r2 = e2.raws.tailwind.candidate;
  if (!!r2) {
    for (let n2 of t2.ruleCache)
      n2[1].raws.tailwind.candidate === r2 && t2.ruleCache.delete(n2);
    Tf(t2, r2);
  }
}
function Pf(t2, e2 = [], r2 = R.root()) {
  var a2;
  let n2 = { disposables: [], ruleCache: /* @__PURE__ */ new Set(), candidateRuleCache: /* @__PURE__ */ new Map(), classCache: /* @__PURE__ */ new Map(), applyClassCache: /* @__PURE__ */ new Map(), notClassCache: new Set((a2 = t2.blocklist) != null ? a2 : []), postCssNodeCache: /* @__PURE__ */ new Map(), candidateRuleMap: /* @__PURE__ */ new Map(), tailwindConfig: t2, changedContent: e2, variantMap: /* @__PURE__ */ new Map(), stylesheetCache: null, variantOptions: /* @__PURE__ */ new Map(), markInvalidUtilityCandidate: (s2) => Tf(n2, s2), markInvalidUtilityNode: (s2) => mv(n2, s2) }, i2 = dv(n2, r2);
  return hv(i2, n2), n2;
}
var Bs = H(ve());
function yn(t2, e2) {
  let r2 = (0, Bs.default)().astSync(t2);
  return r2.each((n2) => {
    n2.nodes[0].type === "pseudo" && n2.nodes[0].value === ":is" && n2.nodes.every((a2) => a2.type !== "combinator") || (n2.nodes = [Bs.default.pseudo({ value: ":is", nodes: [n2.clone()] })]), at(n2);
  }), `${e2} ${r2.toString()}`;
}
var gv = (0, wn.default)((t2) => t2.first.filter(({ type: e2 }) => e2 === "class").pop().value);
function Ws(t2) {
  return gv.transformSync(t2);
}
function* yv(t2) {
  let e2 = 1 / 0;
  for (; e2 >= 0; ) {
    let r2, n2 = false;
    if (e2 === 1 / 0 && t2.endsWith("]")) {
      let s2 = t2.indexOf("[");
      t2[s2 - 1] === "-" ? r2 = s2 - 1 : t2[s2 - 1] === "/" ? (r2 = s2 - 1, n2 = true) : r2 = -1;
    } else
      e2 === 1 / 0 && t2.includes("/") ? (r2 = t2.lastIndexOf("/"), n2 = true) : r2 = t2.lastIndexOf("-", e2);
    if (r2 < 0)
      break;
    let i2 = t2.slice(0, r2), a2 = t2.slice(n2 ? r2 : r2 + 1);
    e2 = r2 - 1, !(i2 === "" || a2 === "/") && (yield [i2, a2]);
  }
}
function vv(t2, e2) {
  if (t2.length === 0 || e2.tailwindConfig.prefix === "")
    return t2;
  for (let r2 of t2) {
    let [n2] = r2;
    if (n2.options.respectPrefix) {
      let i2 = R.root({ nodes: [r2[1].clone()] }), a2 = r2[1].raws.tailwind.classCandidate;
      i2.walkRules((s2) => {
        let o2 = a2.startsWith("-");
        s2.selector = it(e2.tailwindConfig.prefix, s2.selector, o2);
      }), r2[1] = i2.nodes[0];
    }
  }
  return t2;
}
function wv(t2, e2) {
  if (t2.length === 0)
    return t2;
  let r2 = [];
  for (let [n2, i2] of t2) {
    let a2 = R.root({ nodes: [i2.clone()] });
    a2.walkRules((s2) => {
      let o2 = (0, wn.default)().astSync(s2.selector);
      o2.each((l2) => Ms(l2, e2)), af(o2, (l2) => l2 === e2 ? `!${l2}` : l2), s2.selector = o2.toString(), s2.walkDecls((l2) => l2.important = true);
    }), r2.push([{ ...n2, important: true }, a2.nodes[0]]);
  }
  return r2;
}
function bv(t2, e2, r2) {
  var i2;
  if (e2.length === 0)
    return e2;
  let n2 = { modifier: null, value: mt };
  {
    let [a2, ...s2] = ee(t2, "/");
    if (s2.length > 1 && (a2 = a2 + "/" + s2.slice(0, -1).join("/"), s2 = s2.slice(-1)), s2.length && !r2.variantMap.has(t2) && (t2 = a2, n2.modifier = s2[0], !G(r2.tailwindConfig, "generalizedModifiers")))
      return [];
  }
  if (t2.endsWith("]") && !t2.startsWith("[")) {
    let a2 = /(.)(-?)\[(.*)\]/g.exec(t2);
    if (a2) {
      let [, s2, o2, l2] = a2;
      if (s2 === "@" && o2 === "-")
        return [];
      if (s2 !== "@" && o2 === "")
        return [];
      t2 = t2.replace(`${o2}[${l2}]`, ""), n2.value = l2;
    }
  }
  if (Ys(t2) && !r2.variantMap.has(t2)) {
    let a2 = r2.offsets.recordVariant(t2), s2 = z(t2.slice(1, -1)), o2 = ee(s2, ",");
    if (o2.length > 1)
      return [];
    if (!o2.every(mn))
      return [];
    let l2 = o2.map((u2, f2) => [r2.offsets.applyParallelOffset(a2, f2), lr(u2.trim())]);
    r2.variantMap.set(t2, l2);
  }
  if (r2.variantMap.has(t2)) {
    let a2 = Ys(t2), s2 = r2.variantMap.get(t2).slice(), o2 = [];
    for (let [l2, u2] of e2) {
      if (l2.layer === "user")
        continue;
      let f2 = R.root({ nodes: [u2.clone()] });
      for (let [p2, c2, d2] of s2) {
        let m = function() {
          h2.raws.neededBackup || (h2.raws.neededBackup = true, h2.walkRules((v2) => v2.raws.originalSelector = v2.selector));
        }, g2 = function(v2) {
          return m(), h2.each((O2) => {
            O2.type === "rule" && (O2.selectors = O2.selectors.map((x2) => v2({ get className() {
              return Ws(x2);
            }, selector: x2 })));
          }), h2;
        }, h2 = (d2 != null ? d2 : f2).clone(), y3 = [], w2 = c2({ get container() {
          return m(), h2;
        }, separator: r2.tailwindConfig.separator, modifySelectors: g2, wrap(v2) {
          let O2 = h2.nodes;
          h2.removeAll(), v2.append(O2), h2.append(v2);
        }, format(v2) {
          y3.push({ format: v2, isArbitraryVariant: a2 });
        }, args: n2 });
        if (Array.isArray(w2)) {
          for (let [v2, O2] of w2.entries())
            s2.push([r2.offsets.applyParallelOffset(p2, v2), O2, h2.clone()]);
          continue;
        }
        if (typeof w2 == "string" && y3.push({ format: w2, isArbitraryVariant: a2 }), w2 === null)
          continue;
        h2.raws.neededBackup && (delete h2.raws.neededBackup, h2.walkRules((v2) => {
          let O2 = v2.raws.originalSelector;
          if (!O2 || (delete v2.raws.originalSelector, O2 === v2.selector))
            return;
          let x2 = v2.selector, A = (0, wn.default)((E2) => {
            E2.walkClasses((I2) => {
              I2.value = `${t2}${r2.tailwindConfig.separator}${I2.value}`;
            });
          }).processSync(O2);
          y3.push({ format: x2.replace(A, "&"), isArbitraryVariant: a2 }), v2.selector = O2;
        })), h2.nodes[0].raws.tailwind = { ...h2.nodes[0].raws.tailwind, parentLayer: l2.layer };
        let b3 = [{ ...l2, sort: r2.offsets.applyVariantOffset(l2.sort, p2, Object.assign(n2, r2.variantOptions.get(t2))), collectedFormats: ((i2 = l2.collectedFormats) != null ? i2 : []).concat(y3) }, h2.nodes[0]];
        o2.push(b3);
      }
    }
    return o2;
  }
  return [];
}
function Gs(t2, e2, r2 = {}) {
  return !X(t2) && !Array.isArray(t2) ? [[t2], r2] : Array.isArray(t2) ? Gs(t2[0], e2, t2[1]) : (e2.has(t2) || e2.set(t2, nt(t2)), [e2.get(t2), r2]);
}
var xv = /^[a-z_-]/;
function Sv(t2) {
  return xv.test(t2);
}
function kv(t2) {
  if (!t2.includes("://"))
    return false;
  try {
    let e2 = new URL(t2);
    return e2.scheme !== "" && e2.host !== "";
  } catch {
    return false;
  }
}
function If(t2) {
  let e2 = true;
  return t2.walkDecls((r2) => {
    if (!Rf(r2.prop, r2.value))
      return e2 = false, false;
  }), e2;
}
function Rf(t2, e2) {
  if (kv(`${t2}:${e2}`))
    return false;
  try {
    return R.parse(`a{${t2}:${e2}}`).toResult(), true;
  } catch {
    return false;
  }
}
function Ov(t2, e2) {
  var s2;
  let [, r2, n2] = (s2 = t2.match(/^\[([a-zA-Z0-9-_]+):(\S+)\]$/)) != null ? s2 : [];
  if (n2 === void 0 || !Sv(r2) || !lt(n2))
    return null;
  let i2 = z(n2);
  return Rf(r2, i2) ? [[{ sort: e2.offsets.arbitraryProperty(), layer: "utilities" }, () => ({ [Fs(t2)]: { [r2]: i2 } })]] : null;
}
function* Ev(t2, e2) {
  e2.candidateRuleMap.has(t2) && (yield [e2.candidateRuleMap.get(t2), "DEFAULT"]), yield* function* (o2) {
    o2 !== null && (yield [o2, "DEFAULT"]);
  }(Ov(t2, e2));
  let r2 = t2, n2 = false, i2 = e2.tailwindConfig.prefix, a2 = i2.length, s2 = r2.startsWith(i2) || r2.startsWith(`-${i2}`);
  r2[a2] === "-" && s2 && (n2 = true, r2 = i2 + r2.slice(a2 + 1)), n2 && e2.candidateRuleMap.has(r2) && (yield [e2.candidateRuleMap.get(r2), "-DEFAULT"]);
  for (let [o2, l2] of yv(r2))
    e2.candidateRuleMap.has(o2) && (yield [e2.candidateRuleMap.get(o2), n2 ? `-${l2}` : l2]);
}
function Cv(t2, e2) {
  return t2 === ke ? [ke] : ee(t2, e2);
}
function* Av(t2, e2) {
  var r2, n2;
  for (let i2 of t2)
    i2[1].raws.tailwind = { ...i2[1].raws.tailwind, classCandidate: e2, preserveSource: (n2 = (r2 = i2[0].options) == null ? void 0 : r2.preserveSource) != null ? n2 : false }, yield i2;
}
function* bn(t2, e2, r2 = t2) {
  var o2, l2, u2, f2;
  let n2 = e2.tailwindConfig.separator, [i2, ...a2] = Cv(t2, n2).reverse(), s2 = false;
  if (i2.startsWith("!") && (s2 = true, i2 = i2.slice(1)), G(e2.tailwindConfig, "variantGrouping") && i2.startsWith("(") && i2.endsWith(")")) {
    let p2 = a2.slice().reverse().join(n2);
    for (let c2 of ee(i2.slice(1, -1), ","))
      yield* bn(p2 + n2 + c2, e2, r2);
  }
  for (let p2 of Ev(i2, e2)) {
    let c2 = [], d2 = /* @__PURE__ */ new Map(), [h2, y3] = p2, m = h2.length === 1;
    for (let [g2, w2] of h2) {
      let b3 = [];
      if (typeof w2 == "function")
        for (let v2 of [].concat(w2(y3, { isOnlyPlugin: m }))) {
          let [O2, x2] = Gs(v2, e2.postCssNodeCache);
          for (let A of O2)
            b3.push([{ ...g2, options: { ...g2.options, ...x2 } }, A]);
        }
      else if (y3 === "DEFAULT" || y3 === "-DEFAULT") {
        let v2 = w2, [O2, x2] = Gs(v2, e2.postCssNodeCache);
        for (let A of O2)
          b3.push([{ ...g2, options: { ...g2.options, ...x2 } }, A]);
      }
      if (b3.length > 0) {
        let v2 = Array.from(Ps((l2 = (o2 = g2.options) == null ? void 0 : o2.types) != null ? l2 : [], y3, (u2 = g2.options) != null ? u2 : {}, e2.tailwindConfig)).map(([O2, x2]) => x2);
        v2.length > 0 && d2.set(b3, v2), c2.push(b3);
      }
    }
    if (Ys(y3)) {
      if (c2.length > 1) {
        let b3 = function(O2) {
          return O2.length === 1 ? O2[0] : O2.find((x2) => {
            let A = d2.get(x2);
            return x2.some(([{ options: E2 }, I2]) => If(I2) ? E2.types.some(({ type: F, preferOnConflict: Y2 }) => A.includes(F) && Y2) : false);
          });
        }, [g2, w2] = c2.reduce((O2, x2) => (x2.some(([{ options: E2 }]) => E2.types.some(({ type: I2 }) => I2 === "any")) ? O2[0].push(x2) : O2[1].push(x2), O2), [[], []]), v2 = (f2 = b3(w2)) != null ? f2 : b3(g2);
        if (v2)
          c2 = [v2];
        else {
          let O2 = c2.map((A) => {
            var E2;
            return /* @__PURE__ */ new Set([...(E2 = d2.get(A)) != null ? E2 : []]);
          });
          for (let A of O2)
            for (let E2 of A) {
              let I2 = false;
              for (let F of O2)
                A !== F && F.has(E2) && (F.delete(E2), I2 = true);
              I2 && A.delete(E2);
            }
          let x2 = [];
          for (let [A, E2] of O2.entries())
            for (let I2 of E2) {
              let F = c2[A].map(([, Y2]) => Y2).flat().map((Y2) => Y2.toString().split(`
`).slice(1, -1).map((K2) => K2.trim()).map((K2) => `      ${K2}`).join(`
`)).join(`

`);
              x2.push(`  Use \`${t2.replace("[", `[${I2}:`)}\` for \`${F.trim()}\``);
              break;
            }
          L.warn([`The class \`${t2}\` is ambiguous and matches multiple utilities.`, ...x2, `If this is content and not a class, replace it with \`${t2.replace("[", "&lsqb;").replace("]", "&rsqb;")}\` to silence this warning.`]);
          continue;
        }
      }
      c2 = c2.map((g2) => g2.filter((w2) => If(w2[1])));
    }
    c2 = c2.flat(), c2 = Array.from(Av(c2, i2)), c2 = vv(c2, e2), s2 && (c2 = wv(c2, i2));
    for (let g2 of a2)
      c2 = bv(g2, c2, e2);
    for (let g2 of c2)
      g2[1].raws.tailwind = { ...g2[1].raws.tailwind, candidate: t2 }, g2 = _v(g2, { context: e2, candidate: t2, original: r2 }), g2 !== null && (yield g2);
  }
}
function _v(t2, { context: e2, candidate: r2, original: n2 }) {
  if (!t2[0].collectedFormats)
    return t2;
  let i2 = true, a2;
  try {
    a2 = ot(t2[0].collectedFormats, { context: e2, candidate: r2 });
  } catch {
    return null;
  }
  let s2 = R.root({ nodes: [t2[1].clone()] });
  return s2.walkRules((o2) => {
    if (!vn(o2))
      try {
        o2.selector = on(o2.selector, a2, { candidate: n2, context: e2 });
      } catch {
        return i2 = false, false;
      }
  }), i2 ? (t2[1] = s2.nodes[0], t2) : null;
}
function vn(t2) {
  return t2.parent && t2.parent.type === "atrule" && t2.parent.name === "keyframes";
}
function Tv(t2) {
  if (t2 === true)
    return (e2) => {
      vn(e2) || e2.walkDecls((r2) => {
        r2.parent.type === "rule" && !vn(r2.parent) && (r2.important = true);
      });
    };
  if (typeof t2 == "string")
    return (e2) => {
      vn(e2) || (e2.selectors = e2.selectors.map((r2) => yn(r2, t2)));
    };
}
function gn(t2, e2) {
  var i2;
  let r2 = [], n2 = Tv(e2.tailwindConfig.important);
  for (let a2 of t2) {
    if (e2.notClassCache.has(a2))
      continue;
    if (e2.candidateRuleCache.has(a2)) {
      r2 = r2.concat(Array.from(e2.candidateRuleCache.get(a2)));
      continue;
    }
    let s2 = Array.from(bn(a2, e2));
    if (s2.length === 0) {
      e2.notClassCache.add(a2);
      continue;
    }
    e2.classCache.set(a2, s2);
    let o2 = (i2 = e2.candidateRuleCache.get(a2)) != null ? i2 : /* @__PURE__ */ new Set();
    e2.candidateRuleCache.set(a2, o2);
    for (let l2 of s2) {
      let [{ sort: u2, options: f2 }, p2] = l2;
      if (f2.respectImportant && n2) {
        let d2 = R.root({ nodes: [p2.clone()] });
        d2.walkRules(n2), p2 = d2.nodes[0];
      }
      let c2 = [u2, p2];
      o2.add(c2), e2.ruleCache.add(c2), r2.push(c2);
    }
  }
  return r2;
}
function Ys(t2) {
  return t2.startsWith("[") && t2.endsWith("]");
}
function Ge(t2, e2 = void 0, r2 = void 0) {
  return t2.map((n2) => {
    var s2;
    let i2 = n2.clone(), a2 = ((s2 = n2.raws.tailwind) == null ? void 0 : s2.preserveSource) !== true || !i2.source;
    return e2 !== void 0 && a2 && (i2.source = e2, "walk" in i2 && i2.walk((o2) => {
      o2.source = e2;
    })), r2 !== void 0 && (i2.raws.tailwind = { ...i2.raws.tailwind, ...r2 }), i2;
  });
}
var Df = /[\\^$.*+?()[\]{}|]/g;
var Pv = RegExp(Df.source);
function xn(t2) {
  return t2 = Array.isArray(t2) ? t2 : [t2], t2 = t2.map((e2) => e2 instanceof RegExp ? e2.source : e2), t2.join("");
}
function ce(t2) {
  return new RegExp(xn(t2), "g");
}
function ut(t2) {
  return `(?:${t2.map(xn).join("|")})`;
}
function Hs(t2) {
  return `(?:${xn(t2)})?`;
}
function Mf(t2) {
  return `(?:${xn(t2)})*`;
}
function Ff(t2) {
  return t2 && Pv.test(t2) ? t2.replace(Df, "\\$&") : t2 || "";
}
function Lf(t2) {
  let e2 = Array.from(Rv(t2));
  return (r2) => {
    var i2;
    let n2 = [];
    for (let a2 of e2)
      n2 = [...n2, ...(i2 = r2.match(a2)) != null ? i2 : []];
    return n2.filter((a2) => a2 !== void 0).map(Fv);
  };
}
function* Rv(t2) {
  let e2 = t2.tailwindConfig.separator, r2 = G(t2.tailwindConfig, "variantGrouping"), n2 = t2.tailwindConfig.prefix !== "" ? Hs(ce([/-?/, Ff(t2.tailwindConfig.prefix)])) : "", i2 = ut([/\[[^\s:'"`]+:[^\s\[\]]+\]/, /\[[^\s:'"`]+:[^\s]+?\[[^\s]+\][^\s]+?\]/, ce([/-?(?:\w+)/, Hs(ut([ce([/-(?:\w+-)*\[[^\s:]+\]/, /(?![{([]])/, /(?:\/[^\s'"`\\><$]*)?/]), ce([/-(?:\w+-)*\[[^\s]+\]/, /(?![{([]])/, /(?:\/[^\s'"`\\$]*)?/]), /[-\/][^\s'"`\\$={><]*/]))])]), a2 = [ut([ce([/@\[[^\s"'`]+\](\/[^\s"'`]+)?/, e2]), ce([/([^\s"'`\[\\]+-)?\[[^\s"'`]+\]/, e2]), ce([/[^\s"'`\[\\]+/, e2])]), ut([ce([/([^\s"'`\[\\]+-)?\[[^\s`]+\]/, e2]), ce([/[^\s`\[\\]+/, e2])])];
  for (let s2 of a2)
    yield ce(["((?=((", s2, ")+))\\2)?", /!?/, n2, r2 ? ut([ce([/\(/, i2, Mf([/,/, i2]), /\)/]), i2]) : i2]);
  yield /[^<>"'`\s.(){}[\]#=%$]*[^<>"'`\s.(){}[\]#=%:$]/g;
}
var Dv = /([\[\]'"`])([^\[\]'"`])?/g;
var Mv = /[^"'`\s<>\]]+/;
function Fv(t2) {
  if (!t2.includes("-["))
    return t2;
  let e2 = 0, r2 = [], n2 = t2.matchAll(Dv);
  n2 = Array.from(n2).flatMap((i2) => {
    let [, ...a2] = i2;
    return a2.map((s2, o2) => Object.assign([], i2, { index: i2.index + o2, 0: s2 }));
  });
  for (let i2 of n2) {
    let a2 = i2[0], s2 = r2[r2.length - 1];
    if (a2 === s2 ? r2.pop() : (a2 === "'" || a2 === '"' || a2 === "`") && r2.push(a2), !s2) {
      if (a2 === "[") {
        e2++;
        continue;
      } else if (a2 === "]") {
        e2--;
        continue;
      }
      if (e2 < 0)
        return t2.substring(0, i2.index - 1);
      if (e2 === 0 && !Mv.test(a2))
        return t2.substring(0, i2.index);
    }
  }
  return t2;
}
var Ae = Vn;
var Nf = { DEFAULT: Lf };
var qf = { DEFAULT: (t2) => t2, svelte: (t2) => t2.replace(/(?:^|\s)class:/g, " ") };
function Lv(t2, e2) {
  let r2 = t2.tailwindConfig.content.extract;
  return r2[e2] || r2.DEFAULT || Nf[e2] || Nf.DEFAULT(t2);
}
function Nv(t2, e2) {
  let r2 = t2.content.transform;
  return r2[e2] || r2.DEFAULT || qf[e2] || qf.DEFAULT;
}
var ur = /* @__PURE__ */ new WeakMap();
function qv(t2, e2, r2, n2) {
  ur.has(e2) || ur.set(e2, new $f.default({ maxSize: 25e3 }));
  for (let i2 of t2.split(`
`))
    if (i2 = i2.trim(), !n2.has(i2))
      if (n2.add(i2), ur.get(e2).has(i2))
        for (let a2 of ur.get(e2).get(i2))
          r2.add(a2);
      else {
        let a2 = e2(i2).filter((o2) => o2 !== "!*"), s2 = new Set(a2);
        for (let o2 of s2)
          r2.add(o2);
        ur.get(e2).set(i2, s2);
      }
}
function $v(t2, e2) {
  let r2 = e2.offsets.sort(t2), n2 = { base: /* @__PURE__ */ new Set(), defaults: /* @__PURE__ */ new Set(), components: /* @__PURE__ */ new Set(), utilities: /* @__PURE__ */ new Set(), variants: /* @__PURE__ */ new Set() };
  for (let [i2, a2] of r2)
    n2[i2.layer].add(a2);
  return n2;
}
function Qs(t2) {
  return (e2) => {
    var h2;
    let r2 = { base: null, components: null, utilities: null, variants: null };
    if (e2.walkAtRules((y3) => {
      y3.name === "tailwind" && Object.keys(r2).includes(y3.params) && (r2[y3.params] = y3);
    }), Object.values(r2).every((y3) => y3 === null))
      return e2;
    let n2 = /* @__PURE__ */ new Set([...(h2 = t2.candidates) != null ? h2 : [], ke]), i2 = /* @__PURE__ */ new Set();
    Ae.DEBUG && console.time("Reading changed files");
    for (let { file: y3, content: m, extension: g2 } of t2.changedContent) {
      let w2 = Nv(t2.tailwindConfig, g2), b3 = Lv(t2, g2);
      m = y3 ? ht.readFileSync(y3, "utf8") : m, qv(w2(m), b3, n2, i2);
    }
    Ae.DEBUG && console.timeEnd("Reading changed files");
    let a2 = t2.classCache.size;
    Ae.DEBUG && console.time("Generate rules"), Ae.DEBUG && console.time("Sorting candidates");
    let s2 = new Set([...n2].sort((y3, m) => y3 === m ? 0 : y3 < m ? -1 : 1));
    Ae.DEBUG && console.timeEnd("Sorting candidates"), gn(s2, t2), Ae.DEBUG && console.timeEnd("Generate rules"), Ae.DEBUG && console.time("Build stylesheet"), (t2.stylesheetCache === null || t2.classCache.size !== a2) && (t2.stylesheetCache = $v([...t2.ruleCache], t2)), Ae.DEBUG && console.timeEnd("Build stylesheet");
    let { defaults: o2, base: l2, components: u2, utilities: f2, variants: p2 } = t2.stylesheetCache;
    r2.base && (r2.base.before(Ge([...l2, ...o2], r2.base.source, { layer: "base" })), r2.base.remove()), r2.components && (r2.components.before(Ge([...u2], r2.components.source, { layer: "components" })), r2.components.remove()), r2.utilities && (r2.utilities.before(Ge([...f2], r2.utilities.source, { layer: "utilities" })), r2.utilities.remove());
    let c2 = Array.from(p2).filter((y3) => {
      var g2;
      let m = (g2 = y3.raws.tailwind) == null ? void 0 : g2.parentLayer;
      return m === "components" ? r2.components !== null : m === "utilities" ? r2.utilities !== null : true;
    });
    r2.variants ? (r2.variants.before(Ge(c2, r2.variants.source, { layer: "variants" })), r2.variants.remove()) : c2.length > 0 && e2.append(Ge(c2, e2.source, { layer: "variants" }));
    let d2 = c2.some((y3) => {
      var m;
      return ((m = y3.raws.tailwind) == null ? void 0 : m.parentLayer) === "utilities";
    });
    r2.utilities && f2.size === 0 && !d2 && L.warn("content-problems", ["No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.", "https://tailwindcss.com/docs/content-configuration"]), Ae.DEBUG && (console.log("Potential classes: ", n2.size), console.log("Active contexts: ", Wn.size)), t2.changedContent = [], e2.walkAtRules("layer", (y3) => {
      Object.keys(r2).includes(y3.params) && y3.remove();
    });
  };
}
var kn = H(ve());
function Sn(t2) {
  let e2 = /* @__PURE__ */ new Map();
  R.root({ nodes: [t2.clone()] }).walkRules((a2) => {
    (0, kn.default)((s2) => {
      s2.walkClasses((o2) => {
        let l2 = o2.parent.toString(), u2 = e2.get(l2);
        u2 || e2.set(l2, u2 = /* @__PURE__ */ new Set()), u2.add(o2.value);
      });
    }).processSync(a2.selector);
  });
  let n2 = Array.from(e2.values(), (a2) => Array.from(a2)), i2 = n2.flat();
  return Object.assign(i2, { groups: n2 });
}
var Uv = (0, kn.default)();
function Js(t2) {
  return Uv.astSync(t2);
}
function Uf(t2, e2) {
  let r2 = /* @__PURE__ */ new Set();
  for (let n2 of t2)
    r2.add(n2.split(e2).pop());
  return Array.from(r2);
}
function jf(t2, e2) {
  let r2 = t2.tailwindConfig.prefix;
  return typeof r2 == "function" ? r2(e2) : r2 + e2;
}
function* Vf(t2) {
  for (yield t2; t2.parent; )
    yield t2.parent, t2 = t2.parent;
}
function jv(t2, e2 = {}) {
  let r2 = t2.nodes;
  t2.nodes = [];
  let n2 = t2.clone(e2);
  return t2.nodes = r2, n2;
}
function zv(t2) {
  for (let e2 of Vf(t2))
    if (t2 !== e2) {
      if (e2.type === "root")
        break;
      t2 = jv(e2, { nodes: [t2] });
    }
  return t2;
}
function Vv(t2, e2) {
  let r2 = /* @__PURE__ */ new Map();
  return t2.walkRules((n2) => {
    var s2;
    for (let o2 of Vf(n2))
      if (((s2 = o2.raws.tailwind) == null ? void 0 : s2.layer) !== void 0)
        return;
    let i2 = zv(n2), a2 = e2.offsets.create("user");
    for (let o2 of Sn(n2)) {
      let l2 = r2.get(o2) || [];
      r2.set(o2, l2), l2.push([{ layer: "user", sort: a2, important: false }, i2]);
    }
  }), r2;
}
function Wv(t2, e2) {
  for (let r2 of t2) {
    if (e2.notClassCache.has(r2) || e2.applyClassCache.has(r2))
      continue;
    if (e2.classCache.has(r2)) {
      e2.applyClassCache.set(r2, e2.classCache.get(r2).map(([i2, a2]) => [i2, a2.clone()]));
      continue;
    }
    let n2 = Array.from(bn(r2, e2));
    if (n2.length === 0) {
      e2.notClassCache.add(r2);
      continue;
    }
    e2.applyClassCache.set(r2, n2);
  }
  return e2.applyClassCache;
}
function Bv(t2) {
  let e2 = null;
  return { get: (r2) => (e2 = e2 || t2(), e2.get(r2)), has: (r2) => (e2 = e2 || t2(), e2.has(r2)) };
}
function Gv(t2) {
  return { get: (e2) => t2.flatMap((r2) => r2.get(e2) || []), has: (e2) => t2.some((r2) => r2.has(e2)) };
}
function zf(t2) {
  let e2 = t2.split(/[\s\t\n]+/g);
  return e2[e2.length - 1] === "!important" ? [e2.slice(0, -1), true] : [e2, false];
}
function Wf(t2, e2, r2) {
  let n2 = /* @__PURE__ */ new Set(), i2 = [];
  if (t2.walkAtRules("apply", (l2) => {
    let [u2] = zf(l2.params);
    for (let f2 of u2)
      n2.add(f2);
    i2.push(l2);
  }), i2.length === 0)
    return;
  let a2 = Gv([r2, Wv(n2, e2)]);
  function s2(l2, u2, f2) {
    let p2 = Js(l2), c2 = Js(u2), h2 = Js(`.${re(f2)}`).nodes[0].nodes[0];
    return p2.each((y3) => {
      let m = /* @__PURE__ */ new Set();
      c2.each((g2) => {
        let w2 = false;
        g2 = g2.clone(), g2.walkClasses((b3) => {
          b3.value === h2.value && (w2 || (b3.replaceWith(...y3.nodes.map((v2) => v2.clone())), m.add(g2), w2 = true));
        });
      });
      for (let g2 of m) {
        let w2 = [[]];
        for (let b3 of g2.nodes)
          b3.type === "combinator" ? (w2.push(b3), w2.push([])) : w2[w2.length - 1].push(b3);
        g2.nodes = [];
        for (let b3 of w2)
          Array.isArray(b3) && b3.sort((v2, O2) => v2.type === "tag" && O2.type === "class" ? -1 : v2.type === "class" && O2.type === "tag" ? 1 : v2.type === "class" && O2.type === "pseudo" && O2.value.startsWith("::") ? -1 : v2.type === "pseudo" && v2.value.startsWith("::") && O2.type === "class" ? 1 : 0), g2.nodes = g2.nodes.concat(b3);
      }
      y3.replaceWith(...m);
    }), p2.toString();
  }
  let o2 = /* @__PURE__ */ new Map();
  for (let l2 of i2) {
    let [u2] = o2.get(l2.parent) || [[], l2.source];
    o2.set(l2.parent, [u2, l2.source]);
    let [f2, p2] = zf(l2.params);
    if (l2.parent.type === "atrule") {
      if (l2.parent.name === "screen") {
        let c2 = l2.parent.params;
        throw l2.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${f2.map((d2) => `${c2}:${d2}`).join(" ")} instead.`);
      }
      throw l2.error(`@apply is not supported within nested at-rules like @${l2.parent.name}. You can fix this by un-nesting @${l2.parent.name}.`);
    }
    for (let c2 of f2) {
      if ([jf(e2, "group"), jf(e2, "peer")].includes(c2))
        throw l2.error(`@apply should not be used with the '${c2}' utility`);
      if (!a2.has(c2))
        throw l2.error(`The \`${c2}\` class does not exist. If \`${c2}\` is a custom class, make sure it is defined within a \`@layer\` directive.`);
      let d2 = a2.get(c2);
      u2.push([c2, p2, d2]);
    }
  }
  for (let [l2, [u2, f2]] of o2) {
    let p2 = [];
    for (let [d2, h2, y3] of u2) {
      let m = [d2, ...Uf([d2], e2.tailwindConfig.separator)];
      for (let [g2, w2] of y3) {
        let b3 = Sn(l2), v2 = Sn(w2);
        if (v2 = v2.groups.filter((E2) => E2.some((I2) => m.includes(I2))).flat(), v2 = v2.concat(Uf(v2, e2.tailwindConfig.separator)), b3.some((E2) => v2.includes(E2)))
          throw w2.error(`You cannot \`@apply\` the \`${d2}\` utility here because it creates a circular dependency.`);
        let x2 = R.root({ nodes: [w2.clone()] });
        x2.walk((E2) => {
          E2.source = f2;
        }), (w2.type !== "atrule" || w2.type === "atrule" && w2.name !== "keyframes") && x2.walkRules((E2) => {
          if (!Sn(E2).some((B2) => B2 === d2)) {
            E2.remove();
            return;
          }
          let I2 = typeof e2.tailwindConfig.important == "string" ? e2.tailwindConfig.important : null, Y2 = l2.raws.tailwind !== void 0 && I2 && l2.selector.indexOf(I2) === 0 ? l2.selector.slice(I2.length) : l2.selector;
          E2.selector = s2(Y2, E2.selector, d2), I2 && Y2 !== l2.selector && (E2.selector = yn(E2.selector, I2)), E2.walkDecls((B2) => {
            B2.important = g2.important || h2;
          });
          let K2 = (0, kn.default)().astSync(E2.selector);
          K2.each((B2) => at(B2)), E2.selector = K2.toString();
        }), x2.nodes[0] && p2.push([g2.sort, x2.nodes[0]]);
      }
    }
    let c2 = e2.offsets.sort(p2).map((d2) => d2[1]);
    l2.after(c2);
  }
  for (let l2 of i2)
    l2.parent.nodes.length > 1 ? l2.remove() : l2.parent.remove();
  Wf(t2, e2, r2);
}
function Xs(t2) {
  return (e2) => {
    let r2 = Bv(() => Vv(e2, t2));
    Wf(e2, t2, r2);
  };
}
var fr = H(qs());
var oc = H(Bf());
var oa = H(sc());
function sa(t2) {
  return typeof t2 == "object" && t2 !== null;
}
function tw(t2, e2) {
  let r2 = Le(e2);
  do
    if (r2.pop(), (0, fr.default)(t2, r2) !== void 0)
      break;
  while (r2.length);
  return r2.length ? r2 : void 0;
}
function ct(t2) {
  return typeof t2 == "string" ? t2 : t2.reduce((e2, r2, n2) => r2.includes(".") ? `${e2}[${r2}]` : n2 === 0 ? r2 : `${e2}.${r2}`, "");
}
function lc(t2) {
  return t2.map((e2) => `'${e2}'`).join(", ");
}
function ac(t2) {
  return lc(Object.keys(t2));
}
function aa(t2, e2, r2, n2 = {}) {
  let i2 = Array.isArray(e2) ? ct(e2) : e2.replace(/^['"]+|['"]+$/g, ""), a2 = Array.isArray(e2) ? e2 : Le(i2), s2 = (0, fr.default)(t2.theme, a2, r2);
  if (s2 === void 0) {
    let l2 = `'${i2}' does not exist in your theme config.`, u2 = a2.slice(0, -1), f2 = (0, fr.default)(t2.theme, u2);
    if (sa(f2)) {
      let p2 = Object.keys(f2).filter((d2) => aa(t2, [...u2, d2]).isValid), c2 = (0, oc.default)(a2[a2.length - 1], p2);
      c2 ? l2 += ` Did you mean '${ct([...u2, c2])}'?` : p2.length > 0 && (l2 += ` '${ct(u2)}' has the following valid keys: ${lc(p2)}`);
    } else {
      let p2 = tw(t2.theme, i2);
      if (p2) {
        let c2 = (0, fr.default)(t2.theme, p2);
        sa(c2) ? l2 += ` '${ct(p2)}' has the following keys: ${ac(c2)}` : l2 += ` '${ct(p2)}' is not an object.`;
      } else
        l2 += ` Your theme has the following top-level keys: ${ac(t2.theme)}`;
    }
    return { isValid: false, error: l2 };
  }
  if (!(typeof s2 == "string" || typeof s2 == "number" || typeof s2 == "function" || s2 instanceof String || s2 instanceof Number || Array.isArray(s2))) {
    let l2 = `'${i2}' was found but does not resolve to a string.`;
    if (sa(s2)) {
      let u2 = Object.keys(s2).filter((f2) => aa(t2, [...a2, f2]).isValid);
      u2.length && (l2 += ` Did you mean something like '${ct([...a2, u2[0]])}'?`);
    }
    return { isValid: false, error: l2 };
  }
  let [o2] = a2;
  return { isValid: true, value: Ce(o2)(s2, n2) };
}
function rw(t2, e2, r2) {
  e2 = e2.map((i2) => uc(t2, i2, r2));
  let n2 = [""];
  for (let i2 of e2)
    i2.type === "div" && i2.value === "," ? n2.push("") : n2[n2.length - 1] += oa.default.stringify(i2);
  return n2;
}
function uc(t2, e2, r2) {
  if (e2.type === "function" && r2[e2.value] !== void 0) {
    let n2 = rw(t2, e2.nodes, r2);
    e2.type = "word", e2.value = r2[e2.value](t2, ...n2);
  }
  return e2;
}
function nw(t2, e2, r2) {
  return (0, oa.default)(e2).walk((n2) => {
    uc(t2, n2, r2);
  }).toString();
}
var iw = { atrule: "params", decl: "value" };
function* sw(t2) {
  t2 = t2.replace(/^['"]+|['"]+$/g, "");
  let e2 = t2.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]+))$/), r2;
  yield [t2, void 0], e2 && (t2 = e2[1], r2 = e2[2], yield [t2, r2]);
}
function aw(t2, e2, r2) {
  var i2;
  let n2 = Array.from(sw(e2)).map(([a2, s2]) => Object.assign(aa(t2, a2, r2, { opacityValue: s2 }), { resolvedPath: a2, alpha: s2 }));
  return (i2 = n2.find((a2) => a2.isValid)) != null ? i2 : n2[0];
}
function fc(t2) {
  let e2 = t2.tailwindConfig, r2 = { theme: (n2, i2, ...a2) => {
    var c2;
    let { isValid: s2, value: o2, error: l2, alpha: u2 } = aw(e2, i2, a2.length ? a2 : void 0);
    if (!s2) {
      let d2 = n2.parent, h2 = (c2 = d2 == null ? void 0 : d2.raws.tailwind) == null ? void 0 : c2.candidate;
      if (d2 && h2 !== void 0) {
        t2.markInvalidUtilityNode(d2), d2.remove(), L.warn("invalid-theme-key-in-class", [`The utility \`${h2}\` contains an invalid theme value and was not generated.`]);
        return;
      }
      throw n2.error(l2);
    }
    let f2 = st(o2);
    return (u2 !== void 0 || f2 !== void 0 && typeof f2 == "function") && (u2 === void 0 && (u2 = 1), o2 = we(f2, u2, f2)), o2;
  }, screen: (n2, i2) => {
    i2 = i2.replace(/^['"]+/g, "").replace(/['"]+$/g, "");
    let s2 = Fe(e2.theme.screens).find(({ name: o2 }) => o2 === i2);
    if (!s2)
      throw n2.error(`The '${i2}' screen does not exist in your theme.`);
    return Me(s2);
  } };
  return (n2) => {
    n2.walk((i2) => {
      let a2 = iw[i2.type];
      a2 !== void 0 && (i2[a2] = nw(i2, i2[a2], r2));
    });
  };
}
function cc({ tailwindConfig: { theme: t2 } }) {
  return function(e2) {
    e2.walkAtRules("screen", (r2) => {
      let n2 = r2.params, a2 = Fe(t2.screens).find(({ name: s2 }) => s2 === n2);
      if (!a2)
        throw r2.error(`No \`${n2}\` screen found.`);
      r2.name = "media", r2.params = Me(a2);
    });
  };
}
var Tn = H(ve());
var pc = { id(t2) {
  return Tn.default.attribute({ attribute: "id", operator: "=", value: t2.value, quoteMark: '"' });
} };
function ow(t2) {
  let e2 = t2.filter((o2) => o2.type !== "pseudo" || o2.nodes.length > 0 ? true : o2.value.startsWith("::") || [":before", ":after", ":first-line", ":first-letter"].includes(o2.value)).reverse(), r2 = /* @__PURE__ */ new Set(["tag", "class", "id", "attribute"]), n2 = e2.findIndex((o2) => r2.has(o2.type));
  if (n2 === -1)
    return e2.reverse().join("").trim();
  let i2 = e2[n2], a2 = pc[i2.type] ? pc[i2.type](i2) : i2;
  e2 = e2.slice(0, n2);
  let s2 = e2.findIndex((o2) => o2.type === "combinator" && o2.value === ">");
  return s2 !== -1 && (e2.splice(0, s2), e2.unshift(Tn.default.universal())), [a2, ...e2.reverse()].join("").trim();
}
var lw = (0, Tn.default)((t2) => t2.map((e2) => {
  let r2 = e2.split((n2) => n2.type === "combinator" && n2.value === " ").pop();
  return ow(r2);
}));
var la = /* @__PURE__ */ new Map();
function uw(t2) {
  return la.has(t2) || la.set(t2, lw.transformSync(t2)), la.get(t2);
}
function ua({ tailwindConfig: t2 }) {
  return (e2) => {
    var i2, a2;
    let r2 = /* @__PURE__ */ new Map(), n2 = /* @__PURE__ */ new Set();
    if (e2.walkAtRules("defaults", (s2) => {
      if (s2.nodes && s2.nodes.length > 0) {
        n2.add(s2);
        return;
      }
      let o2 = s2.params;
      r2.has(o2) || r2.set(o2, /* @__PURE__ */ new Set()), r2.get(o2).add(s2.parent), s2.remove();
    }), G(t2, "optimizeUniversalDefaults"))
      for (let s2 of n2) {
        let o2 = /* @__PURE__ */ new Map(), l2 = (i2 = r2.get(s2.params)) != null ? i2 : [];
        for (let u2 of l2)
          for (let f2 of uw(u2.selector)) {
            let p2 = f2.includes(":-") || f2.includes("::-") ? f2 : "__DEFAULT__", c2 = (a2 = o2.get(p2)) != null ? a2 : /* @__PURE__ */ new Set();
            o2.set(p2, c2), c2.add(f2);
          }
        if (G(t2, "optimizeUniversalDefaults")) {
          if (o2.size === 0) {
            s2.remove();
            continue;
          }
          for (let [, u2] of o2) {
            let f2 = R.rule({ source: s2.source });
            f2.selectors = [...u2], f2.append(s2.nodes.map((p2) => p2.clone())), s2.before(f2);
          }
        }
        s2.remove();
      }
    else if (n2.size) {
      let s2 = R.rule({ selectors: ["*", "::before", "::after"] });
      for (let l2 of n2)
        s2.append(l2.nodes), s2.parent || l2.before(s2), s2.source || (s2.source = l2.source), l2.remove();
      let o2 = s2.clone({ selectors: ["::backdrop"] });
      s2.after(o2);
    }
  };
}
var dc = { atrule: ["name", "params"], rule: ["selector"] };
var fw = new Set(Object.keys(dc));
function fa() {
  function t2(e2) {
    let r2 = null;
    e2.each((n2) => {
      if (!fw.has(n2.type)) {
        r2 = null;
        return;
      }
      if (r2 === null) {
        r2 = n2;
        return;
      }
      let i2 = dc[n2.type];
      n2.type === "atrule" && n2.name === "font-face" ? r2 = n2 : i2.every((a2) => {
        var s2, o2;
        return ((s2 = n2[a2]) != null ? s2 : "").replace(/\s+/g, " ") === ((o2 = r2[a2]) != null ? o2 : "").replace(/\s+/g, " ");
      }) ? (n2.nodes && r2.append(n2.nodes), n2.remove()) : r2 = n2;
    }), e2.each((n2) => {
      n2.type === "atrule" && t2(n2);
    });
  }
  return (e2) => {
    t2(e2);
  };
}
function ca() {
  return (t2) => {
    t2.walkRules((e2) => {
      let r2 = /* @__PURE__ */ new Map(), n2 = /* @__PURE__ */ new Set([]), i2 = /* @__PURE__ */ new Map();
      e2.walkDecls((a2) => {
        if (a2.parent === e2) {
          if (r2.has(a2.prop)) {
            if (r2.get(a2.prop).value === a2.value) {
              n2.add(r2.get(a2.prop)), r2.set(a2.prop, a2);
              return;
            }
            i2.has(a2.prop) || i2.set(a2.prop, /* @__PURE__ */ new Set()), i2.get(a2.prop).add(r2.get(a2.prop)), i2.get(a2.prop).add(a2);
          }
          r2.set(a2.prop, a2);
        }
      });
      for (let a2 of n2)
        a2.remove();
      for (let a2 of i2.values()) {
        let s2 = /* @__PURE__ */ new Map();
        for (let o2 of a2) {
          let l2 = pw(o2.value);
          l2 !== null && (s2.has(l2) || s2.set(l2, /* @__PURE__ */ new Set()), s2.get(l2).add(o2));
        }
        for (let o2 of s2.values()) {
          let l2 = Array.from(o2).slice(0, -1);
          for (let u2 of l2)
            u2.remove();
        }
      }
    });
  };
}
var cw = Symbol("unitless-number");
function pw(t2) {
  var r2;
  let e2 = /^-?\d*.?\d+([\w%]+)?$/g.exec(t2);
  return e2 ? (r2 = e2[1]) != null ? r2 : cw : null;
}
function dw(t2) {
  if (!t2.walkAtRules)
    return;
  let e2 = /* @__PURE__ */ new Set();
  if (t2.walkAtRules("apply", (r2) => {
    e2.add(r2.parent);
  }), e2.size !== 0)
    for (let r2 of e2) {
      let n2 = [], i2 = [];
      for (let a2 of r2.nodes)
        a2.type === "atrule" && a2.name === "apply" ? (i2.length > 0 && (n2.push(i2), i2 = []), n2.push([a2])) : i2.push(a2);
      if (i2.length > 0 && n2.push(i2), n2.length !== 1) {
        for (let a2 of [...n2].reverse()) {
          let s2 = r2.clone({ nodes: [] });
          s2.append(a2), r2.after(s2);
        }
        r2.remove();
      }
    }
}
function Pn() {
  return (t2) => {
    dw(t2);
  };
}
function hw(t2) {
  return t2.type === "root";
}
function mw(t2) {
  return t2.type === "atrule" && t2.name === "layer";
}
function hc(t2) {
  return (e2, r2) => {
    let n2 = false;
    e2.walkAtRules("tailwind", (i2) => {
      if (n2)
        return false;
      if (i2.parent && !(hw(i2.parent) || mw(i2.parent)))
        return n2 = true, i2.warn(r2, ["Nested @tailwind rules were detected, but are not supported.", "Consider using a prefix to scope Tailwind's classes: https://tailwindcss.com/docs/configuration#prefix", "Alternatively, use the important selector strategy: https://tailwindcss.com/docs/configuration#selector-strategy"].join(`
`)), false;
    }), e2.walkRules((i2) => {
      if (n2)
        return false;
      i2.walkRules((a2) => (n2 = true, a2.warn(r2, ["Nested CSS was detected, but CSS nesting has not been configured correctly.", "Please enable a CSS nesting plugin *before* Tailwind in your configuration.", "See how here: https://tailwindcss.com/docs/using-with-preprocessors#nesting"].join(`
`)), false));
    });
  };
}
function pa(t2) {
  return function(e2, r2) {
    let { tailwindDirectives: n2, applyDirectives: i2 } = Un(e2);
    hc()(e2, r2), Pn()(e2, r2);
    let a2 = t2({ tailwindDirectives: n2, applyDirectives: i2, registerDependency(s2) {
      r2.messages.push({ plugin: "tailwindcss", parent: r2.opts.from, ...s2 });
    }, createContext(s2, o2) {
      return Pf(s2, o2, e2);
    } })(e2, r2);
    if (a2.tailwindConfig.separator === "-")
      throw new Error("The '-' character cannot be used as a custom separator in JIT mode due to parsing ambiguity. Please use another character like '_' instead.");
    nf(a2.tailwindConfig), Qs(a2)(e2, r2), Pn()(e2, r2), Xs(a2)(e2, r2), fc(a2)(e2, r2), cc(a2)(e2, r2), ua(a2)(e2, r2), fa(a2)(e2, r2), ca(a2)(e2, r2);
  };
}
var mc = ["preflight", "container", "accessibility", "pointerEvents", "visibility", "position", "inset", "isolation", "zIndex", "order", "gridColumn", "gridColumnStart", "gridColumnEnd", "gridRow", "gridRowStart", "gridRowEnd", "float", "clear", "margin", "boxSizing", "lineClamp", "display", "aspectRatio", "height", "maxHeight", "minHeight", "width", "minWidth", "maxWidth", "flex", "flexShrink", "flexGrow", "flexBasis", "tableLayout", "captionSide", "borderCollapse", "borderSpacing", "transformOrigin", "translate", "rotate", "skew", "scale", "transform", "animation", "cursor", "touchAction", "userSelect", "resize", "scrollSnapType", "scrollSnapAlign", "scrollSnapStop", "scrollMargin", "scrollPadding", "listStylePosition", "listStyleType", "listStyleImage", "appearance", "columns", "breakBefore", "breakInside", "breakAfter", "gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateColumns", "gridTemplateRows", "flexDirection", "flexWrap", "placeContent", "placeItems", "alignContent", "alignItems", "justifyContent", "justifyItems", "gap", "space", "divideWidth", "divideStyle", "divideColor", "divideOpacity", "placeSelf", "alignSelf", "justifySelf", "overflow", "overscrollBehavior", "scrollBehavior", "textOverflow", "hyphens", "whitespace", "wordBreak", "borderRadius", "borderWidth", "borderStyle", "borderColor", "borderOpacity", "backgroundColor", "backgroundOpacity", "backgroundImage", "gradientColorStops", "boxDecorationBreak", "backgroundSize", "backgroundAttachment", "backgroundClip", "backgroundPosition", "backgroundRepeat", "backgroundOrigin", "fill", "stroke", "strokeWidth", "objectFit", "objectPosition", "padding", "textAlign", "textIndent", "verticalAlign", "fontFamily", "fontSize", "fontWeight", "textTransform", "fontStyle", "fontVariantNumeric", "lineHeight", "letterSpacing", "textColor", "textOpacity", "textDecoration", "textDecorationColor", "textDecorationStyle", "textDecorationThickness", "textUnderlineOffset", "fontSmoothing", "placeholderColor", "placeholderOpacity", "caretColor", "accentColor", "opacity", "backgroundBlendMode", "mixBlendMode", "boxShadow", "boxShadowColor", "outlineStyle", "outlineWidth", "outlineOffset", "outlineColor", "ringWidth", "ringColor", "ringOpacity", "ringOffsetWidth", "ringOffsetColor", "blur", "brightness", "contrast", "dropShadow", "grayscale", "hueRotate", "invert", "saturate", "sepia", "filter", "backdropBlur", "backdropBrightness", "backdropContrast", "backdropGrayscale", "backdropHueRotate", "backdropInvert", "backdropOpacity", "backdropSaturate", "backdropSepia", "backdropFilter", "transitionProperty", "transitionDelay", "transitionDuration", "transitionTimingFunction", "willChange", "content"];
function gc(t2, e2) {
  return t2 === void 0 ? e2 : Array.isArray(t2) ? t2 : [...new Set(e2.filter((n2) => t2 !== false && t2[n2] !== false).concat(Object.keys(t2).filter((n2) => t2[n2] !== false)))];
}
function cr({ version: t2, from: e2, to: r2 }) {
  L.warn(`${e2}-color-renamed`, [`As of Tailwind CSS ${t2}, \`${e2}\` has been renamed to \`${r2}\`.`, "Update your configuration file to silence this warning."]);
}
var yc = { inherit: "inherit", current: "currentColor", transparent: "transparent", black: "#000", white: "#fff", slate: { 50: "#f8fafc", 100: "#f1f5f9", 200: "#e2e8f0", 300: "#cbd5e1", 400: "#94a3b8", 500: "#64748b", 600: "#475569", 700: "#334155", 800: "#1e293b", 900: "#0f172a", 950: "#020617" }, gray: { 50: "#f9fafb", 100: "#f3f4f6", 200: "#e5e7eb", 300: "#d1d5db", 400: "#9ca3af", 500: "#6b7280", 600: "#4b5563", 700: "#374151", 800: "#1f2937", 900: "#111827", 950: "#030712" }, zinc: { 50: "#fafafa", 100: "#f4f4f5", 200: "#e4e4e7", 300: "#d4d4d8", 400: "#a1a1aa", 500: "#71717a", 600: "#52525b", 700: "#3f3f46", 800: "#27272a", 900: "#18181b", 950: "#09090b" }, neutral: { 50: "#fafafa", 100: "#f5f5f5", 200: "#e5e5e5", 300: "#d4d4d4", 400: "#a3a3a3", 500: "#737373", 600: "#525252", 700: "#404040", 800: "#262626", 900: "#171717", 950: "#0a0a0a" }, stone: { 50: "#fafaf9", 100: "#f5f5f4", 200: "#e7e5e4", 300: "#d6d3d1", 400: "#a8a29e", 500: "#78716c", 600: "#57534e", 700: "#44403c", 800: "#292524", 900: "#1c1917", 950: "#0c0a09" }, red: { 50: "#fef2f2", 100: "#fee2e2", 200: "#fecaca", 300: "#fca5a5", 400: "#f87171", 500: "#ef4444", 600: "#dc2626", 700: "#b91c1c", 800: "#991b1b", 900: "#7f1d1d", 950: "#450a0a" }, orange: { 50: "#fff7ed", 100: "#ffedd5", 200: "#fed7aa", 300: "#fdba74", 400: "#fb923c", 500: "#f97316", 600: "#ea580c", 700: "#c2410c", 800: "#9a3412", 900: "#7c2d12", 950: "#431407" }, amber: { 50: "#fffbeb", 100: "#fef3c7", 200: "#fde68a", 300: "#fcd34d", 400: "#fbbf24", 500: "#f59e0b", 600: "#d97706", 700: "#b45309", 800: "#92400e", 900: "#78350f", 950: "#451a03" }, yellow: { 50: "#fefce8", 100: "#fef9c3", 200: "#fef08a", 300: "#fde047", 400: "#facc15", 500: "#eab308", 600: "#ca8a04", 700: "#a16207", 800: "#854d0e", 900: "#713f12", 950: "#422006" }, lime: { 50: "#f7fee7", 100: "#ecfccb", 200: "#d9f99d", 300: "#bef264", 400: "#a3e635", 500: "#84cc16", 600: "#65a30d", 700: "#4d7c0f", 800: "#3f6212", 900: "#365314", 950: "#1a2e05" }, green: { 50: "#f0fdf4", 100: "#dcfce7", 200: "#bbf7d0", 300: "#86efac", 400: "#4ade80", 500: "#22c55e", 600: "#16a34a", 700: "#15803d", 800: "#166534", 900: "#14532d", 950: "#052e16" }, emerald: { 50: "#ecfdf5", 100: "#d1fae5", 200: "#a7f3d0", 300: "#6ee7b7", 400: "#34d399", 500: "#10b981", 600: "#059669", 700: "#047857", 800: "#065f46", 900: "#064e3b", 950: "#022c22" }, teal: { 50: "#f0fdfa", 100: "#ccfbf1", 200: "#99f6e4", 300: "#5eead4", 400: "#2dd4bf", 500: "#14b8a6", 600: "#0d9488", 700: "#0f766e", 800: "#115e59", 900: "#134e4a", 950: "#042f2e" }, cyan: { 50: "#ecfeff", 100: "#cffafe", 200: "#a5f3fc", 300: "#67e8f9", 400: "#22d3ee", 500: "#06b6d4", 600: "#0891b2", 700: "#0e7490", 800: "#155e75", 900: "#164e63", 950: "#083344" }, sky: { 50: "#f0f9ff", 100: "#e0f2fe", 200: "#bae6fd", 300: "#7dd3fc", 400: "#38bdf8", 500: "#0ea5e9", 600: "#0284c7", 700: "#0369a1", 800: "#075985", 900: "#0c4a6e", 950: "#082f49" }, blue: { 50: "#eff6ff", 100: "#dbeafe", 200: "#bfdbfe", 300: "#93c5fd", 400: "#60a5fa", 500: "#3b82f6", 600: "#2563eb", 700: "#1d4ed8", 800: "#1e40af", 900: "#1e3a8a", 950: "#172554" }, indigo: { 50: "#eef2ff", 100: "#e0e7ff", 200: "#c7d2fe", 300: "#a5b4fc", 400: "#818cf8", 500: "#6366f1", 600: "#4f46e5", 700: "#4338ca", 800: "#3730a3", 900: "#312e81", 950: "#1e1b4b" }, violet: { 50: "#f5f3ff", 100: "#ede9fe", 200: "#ddd6fe", 300: "#c4b5fd", 400: "#a78bfa", 500: "#8b5cf6", 600: "#7c3aed", 700: "#6d28d9", 800: "#5b21b6", 900: "#4c1d95", 950: "#2e1065" }, purple: { 50: "#faf5ff", 100: "#f3e8ff", 200: "#e9d5ff", 300: "#d8b4fe", 400: "#c084fc", 500: "#a855f7", 600: "#9333ea", 700: "#7e22ce", 800: "#6b21a8", 900: "#581c87", 950: "#3b0764" }, fuchsia: { 50: "#fdf4ff", 100: "#fae8ff", 200: "#f5d0fe", 300: "#f0abfc", 400: "#e879f9", 500: "#d946ef", 600: "#c026d3", 700: "#a21caf", 800: "#86198f", 900: "#701a75", 950: "#4a044e" }, pink: { 50: "#fdf2f8", 100: "#fce7f3", 200: "#fbcfe8", 300: "#f9a8d4", 400: "#f472b6", 500: "#ec4899", 600: "#db2777", 700: "#be185d", 800: "#9d174d", 900: "#831843", 950: "#500724" }, rose: { 50: "#fff1f2", 100: "#ffe4e6", 200: "#fecdd3", 300: "#fda4af", 400: "#fb7185", 500: "#f43f5e", 600: "#e11d48", 700: "#be123c", 800: "#9f1239", 900: "#881337", 950: "#4c0519" }, get lightBlue() {
  return cr({ version: "v2.2", from: "lightBlue", to: "sky" }), this.sky;
}, get warmGray() {
  return cr({ version: "v3.0", from: "warmGray", to: "stone" }), this.stone;
}, get trueGray() {
  return cr({ version: "v3.0", from: "trueGray", to: "neutral" }), this.neutral;
}, get coolGray() {
  return cr({ version: "v3.0", from: "coolGray", to: "gray" }), this.gray;
}, get blueGray() {
  return cr({ version: "v3.0", from: "blueGray", to: "slate" }), this.slate;
} };
function da(t2, ...e2) {
  var r2, n2;
  for (let i2 of e2) {
    for (let a2 in i2)
      (r2 = t2 == null ? void 0 : t2.hasOwnProperty) != null && r2.call(t2, a2) || (t2[a2] = i2[a2]);
    for (let a2 of Object.getOwnPropertySymbols(i2))
      (n2 = t2 == null ? void 0 : t2.hasOwnProperty) != null && n2.call(t2, a2) || (t2[a2] = i2[a2]);
  }
  return t2;
}
function vc(t2) {
  var r2;
  (() => {
    if (t2.purge || !t2.content || !Array.isArray(t2.content) && !(typeof t2.content == "object" && t2.content !== null))
      return false;
    if (Array.isArray(t2.content))
      return t2.content.every((n2) => typeof n2 == "string" ? true : !(typeof (n2 == null ? void 0 : n2.raw) != "string" || (n2 == null ? void 0 : n2.extension) && typeof (n2 == null ? void 0 : n2.extension) != "string"));
    if (typeof t2.content == "object" && t2.content !== null) {
      if (Object.keys(t2.content).some((n2) => !["files", "relative", "extract", "transform"].includes(n2)))
        return false;
      if (Array.isArray(t2.content.files)) {
        if (!t2.content.files.every((n2) => typeof n2 == "string" ? true : !(typeof (n2 == null ? void 0 : n2.raw) != "string" || (n2 == null ? void 0 : n2.extension) && typeof (n2 == null ? void 0 : n2.extension) != "string")))
          return false;
        if (typeof t2.content.extract == "object") {
          for (let n2 of Object.values(t2.content.extract))
            if (typeof n2 != "function")
              return false;
        } else if (!(t2.content.extract === void 0 || typeof t2.content.extract == "function"))
          return false;
        if (typeof t2.content.transform == "object") {
          for (let n2 of Object.values(t2.content.transform))
            if (typeof n2 != "function")
              return false;
        } else if (!(t2.content.transform === void 0 || typeof t2.content.transform == "function"))
          return false;
        if (typeof t2.content.relative != "boolean" && typeof t2.content.relative < "u")
          return false;
      }
      return true;
    }
    return false;
  })() || L.warn("purge-deprecation", ["The `purge`/`content` options have changed in Tailwind CSS v3.0.", "Update your configuration file to eliminate this warning.", "https://tailwindcss.com/docs/upgrade-guide#configure-content-sources"]), t2.safelist = (() => {
    var s2;
    let { content: n2, purge: i2, safelist: a2 } = t2;
    return Array.isArray(a2) ? a2 : Array.isArray(n2 == null ? void 0 : n2.safelist) ? n2.safelist : Array.isArray(i2 == null ? void 0 : i2.safelist) ? i2.safelist : Array.isArray((s2 = i2 == null ? void 0 : i2.options) == null ? void 0 : s2.safelist) ? i2.options.safelist : [];
  })(), t2.blocklist = (() => {
    let { blocklist: n2 } = t2;
    if (Array.isArray(n2)) {
      if (n2.every((i2) => typeof i2 == "string"))
        return n2;
      L.warn("blocklist-invalid", ["The `blocklist` option must be an array of strings.", "https://tailwindcss.com/docs/content-configuration#discarding-classes"]);
    }
    return [];
  })(), typeof t2.prefix == "function" ? (L.warn("prefix-function", ["As of Tailwind CSS v3.0, `prefix` cannot be a function.", "Update `prefix` in your configuration to be a string to eliminate this warning.", "https://tailwindcss.com/docs/upgrade-guide#prefix-cannot-be-a-function"]), t2.prefix = "") : t2.prefix = (r2 = t2.prefix) != null ? r2 : "", t2.content = { relative: (() => {
    let { content: n2 } = t2;
    return n2 != null && n2.relative ? n2.relative : G(t2, "relativeContentPathsByDefault");
  })(), files: (() => {
    let { content: n2, purge: i2 } = t2;
    return Array.isArray(i2) ? i2 : Array.isArray(i2 == null ? void 0 : i2.content) ? i2.content : Array.isArray(n2) ? n2 : Array.isArray(n2 == null ? void 0 : n2.content) ? n2.content : Array.isArray(n2 == null ? void 0 : n2.files) ? n2.files : [];
  })(), extract: (() => {
    let n2 = (() => {
      var s2, o2, l2, u2, f2, p2, c2, d2, h2, y3;
      return (s2 = t2.purge) != null && s2.extract ? t2.purge.extract : (o2 = t2.content) != null && o2.extract ? t2.content.extract : (u2 = (l2 = t2.purge) == null ? void 0 : l2.extract) != null && u2.DEFAULT ? t2.purge.extract.DEFAULT : (p2 = (f2 = t2.content) == null ? void 0 : f2.extract) != null && p2.DEFAULT ? t2.content.extract.DEFAULT : (d2 = (c2 = t2.purge) == null ? void 0 : c2.options) != null && d2.extractors ? t2.purge.options.extractors : (y3 = (h2 = t2.content) == null ? void 0 : h2.options) != null && y3.extractors ? t2.content.options.extractors : {};
    })(), i2 = {}, a2 = (() => {
      var s2, o2, l2, u2;
      if ((o2 = (s2 = t2.purge) == null ? void 0 : s2.options) != null && o2.defaultExtractor)
        return t2.purge.options.defaultExtractor;
      if ((u2 = (l2 = t2.content) == null ? void 0 : l2.options) != null && u2.defaultExtractor)
        return t2.content.options.defaultExtractor;
    })();
    if (a2 !== void 0 && (i2.DEFAULT = a2), typeof n2 == "function")
      i2.DEFAULT = n2;
    else if (Array.isArray(n2))
      for (let { extensions: s2, extractor: o2 } of n2 != null ? n2 : [])
        for (let l2 of s2)
          i2[l2] = o2;
    else
      typeof n2 == "object" && n2 !== null && Object.assign(i2, n2);
    return i2;
  })(), transform: (() => {
    let n2 = (() => {
      var a2, s2, o2, l2, u2, f2;
      return (a2 = t2.purge) != null && a2.transform ? t2.purge.transform : (s2 = t2.content) != null && s2.transform ? t2.content.transform : (l2 = (o2 = t2.purge) == null ? void 0 : o2.transform) != null && l2.DEFAULT ? t2.purge.transform.DEFAULT : (f2 = (u2 = t2.content) == null ? void 0 : u2.transform) != null && f2.DEFAULT ? t2.content.transform.DEFAULT : {};
    })(), i2 = {};
    return typeof n2 == "function" && (i2.DEFAULT = n2), typeof n2 == "object" && n2 !== null && Object.assign(i2, n2), i2;
  })() };
  for (let n2 of t2.content.files)
    if (typeof n2 == "string" && /{([^,]*?)}/g.test(n2)) {
      L.warn("invalid-glob-braces", [`The glob pattern ${n2} in your Tailwind CSS configuration is invalid.`, `Update it to ${n2.replace(/{([^,]*?)}/g, "$1")} to silence this warning.`]);
      break;
    }
  return t2;
}
function In(t2) {
  return Array.isArray(t2) ? t2.map((e2) => In(e2)) : typeof t2 == "object" && t2 !== null ? Object.fromEntries(Object.entries(t2).map(([e2, r2]) => [e2, In(r2)])) : t2;
}
function pt(t2) {
  return typeof t2 == "function";
}
function pr(t2, ...e2) {
  let r2 = e2.pop();
  for (let n2 of e2)
    for (let i2 in n2) {
      let a2 = r2(t2[i2], n2[i2]);
      a2 === void 0 ? X(t2[i2]) && X(n2[i2]) ? t2[i2] = pr({}, t2[i2], n2[i2], r2) : t2[i2] = n2[i2] : t2[i2] = a2;
    }
  return t2;
}
var ha = { colors: yc, negative(t2) {
  return Object.keys(t2).filter((e2) => t2[e2] !== "0").reduce((e2, r2) => {
    let n2 = Re(t2[r2]);
    return n2 !== void 0 && (e2[`-${r2}`] = n2), e2;
  }, {});
}, breakpoints(t2) {
  return Object.keys(t2).filter((e2) => typeof t2[e2] == "string").reduce((e2, r2) => ({ ...e2, [`screen-${r2}`]: t2[r2] }), {});
} };
function gw(t2, ...e2) {
  return pt(t2) ? t2(...e2) : t2;
}
function yw(t2) {
  return t2.reduce((e2, { extend: r2 }) => pr(e2, r2, (n2, i2) => n2 === void 0 ? [i2] : Array.isArray(n2) ? [i2, ...n2] : [i2, n2]), {});
}
function vw(t2) {
  return { ...t2.reduce((e2, r2) => da(e2, r2), {}), extend: yw(t2) };
}
function wc(t2, e2) {
  if (Array.isArray(t2) && X(t2[0]))
    return t2.concat(e2);
  if (Array.isArray(e2) && X(e2[0]) && X(t2))
    return [t2, ...e2];
  if (Array.isArray(e2))
    return e2;
}
function ww({ extend: t2, ...e2 }) {
  return pr(e2, t2, (r2, n2) => !pt(r2) && !n2.some(pt) ? pr({}, r2, ...n2, wc) : (i2, a2) => pr({}, ...[r2, ...n2].map((s2) => gw(s2, i2, a2)), wc));
}
function* bw(t2) {
  let e2 = Le(t2);
  if (e2.length === 0 || (yield e2, Array.isArray(t2)))
    return;
  let r2 = /^(.*?)\s*\/\s*([^/]+)$/, n2 = t2.match(r2);
  if (n2 !== null) {
    let [, i2, a2] = n2, s2 = Le(i2);
    s2.alpha = a2, yield s2;
  }
}
function xw(t2) {
  let e2 = (r2, n2) => {
    for (let i2 of bw(r2)) {
      let a2 = 0, s2 = t2;
      for (; s2 != null && a2 < i2.length; )
        s2 = s2[i2[a2++]], s2 = pt(s2) && (i2.alpha === void 0 || a2 <= i2.length - 1) ? s2(e2, ha) : s2;
      if (s2 !== void 0) {
        if (i2.alpha !== void 0) {
          let o2 = st(s2);
          return we(o2, i2.alpha, M(o2));
        }
        return X(s2) ? In(s2) : s2;
      }
    }
    return n2;
  };
  return Object.assign(e2, { theme: e2, ...ha }), Object.keys(t2).reduce((r2, n2) => (r2[n2] = pt(t2[n2]) ? t2[n2](e2, ha) : t2[n2], r2), {});
}
function bc(t2) {
  let e2 = [];
  return t2.forEach((r2) => {
    var i2;
    e2 = [...e2, r2];
    let n2 = (i2 = r2 == null ? void 0 : r2.plugins) != null ? i2 : [];
    n2.length !== 0 && n2.forEach((a2) => {
      var s2;
      a2.__isOptionsFunction && (a2 = a2()), e2 = [...e2, ...bc([(s2 = a2 == null ? void 0 : a2.config) != null ? s2 : {}])];
    });
  }), e2;
}
function Sw(t2) {
  return [...t2].reduceRight((r2, n2) => pt(n2) ? n2({ corePlugins: r2 }) : gc(n2, r2), mc);
}
function kw(t2) {
  return [...t2].reduceRight((r2, n2) => [...r2, ...n2], []);
}
function ma(t2) {
  let e2 = [...bc(t2), { prefix: "", important: false, separator: ":" }];
  return vc(da({ theme: xw(ww(vw(e2.map((r2) => {
    var n2;
    return (n2 = r2 == null ? void 0 : r2.theme) != null ? n2 : {};
  })))), corePlugins: Sw(e2.map((r2) => r2.corePlugins)), plugins: kw(t2.map((r2) => {
    var n2;
    return (n2 = r2 == null ? void 0 : r2.plugins) != null ? n2 : [];
  })) }, ...e2));
}
var kc = H(Sc());
function Rn(t2) {
  var i2;
  let e2 = ((i2 = t2 == null ? void 0 : t2.presets) != null ? i2 : [kc.default]).slice().reverse().flatMap((a2) => Rn(a2 instanceof Function ? a2() : a2)), r2 = { respectDefaultRingColorOpacity: { theme: { ringColor: ({ theme: a2 }) => ({ DEFAULT: "#3b82f67f", ...a2("colors") }) } }, disableColorOpacityUtilitiesByDefault: { corePlugins: { backgroundOpacity: false, borderOpacity: false, divideOpacity: false, placeholderOpacity: false, ringOpacity: false, textOpacity: false } } }, n2 = Object.keys(r2).filter((a2) => G(t2, a2)).map((a2) => r2[a2]);
  return [t2, ...n2, ...e2];
}
function ga(...t2) {
  let [, ...e2] = Rn(t2[0]);
  return ma([...t2, ...e2]);
}
var Oc = (t2) => {
  var n2;
  let e2 = ga((n2 = t2.config) != null ? n2 : {});
  return pa((i2) => () => i2.createContext(e2, [{ content: t2.content }]));
};
var wp = H(vp(), 1);
var bp = (t2) => {
  let e2 = Oc({ config: t2.config, content: t2.content });
  return R([e2, (0, wp.default)()]).process(xp, { from: void 0 }).css;
};
var xp = String.raw`
  @tailwind base;
  @tailwind components;
  @tailwind utilities;
`;
function kp(t2) {
  let e2 = R.parse(t2);
  return tn.objectify(e2);
}
var sb = (t2, e2) => {
  var i2, a2;
  let r2 = (a2 = (i2 = e2 == null ? void 0 : e2.corePlugins) == null ? void 0 : i2.preflight) != null ? a2 : false, n2 = (e2 == null ? void 0 : e2.corePlugins) || {};
  return bp({ config: { ...e2, corePlugins: { ...n2, preflight: r2 } }, content: t2 });
};
var Op = ({ config: t2, options: e2 }) => ({ twi: Ea(t2, e2), twj: Cp(t2, e2) });
var Ep = (...t2) => {
  let e2 = "";
  return typeof t2[0] == "string" ? e2 = t2[0] : Array.isArray(t2[0]) ? e2 = t2.flat(1 / 0).map((r2) => Ep(r2)).join(" ") : typeof t2[0] == "object" && (e2 = Object.entries(t2[0]).filter((r2) => !!r2[1]).map((r2) => r2[0]).join(" ")), e2 = e2.replace(/\s+/g, " "), e2;
};
var Ea = (t2, e2) => (...r2) => {
  let n2 = Ep(r2), { 1: i2 } = r2 || {}, s2 = { ...{ merge: true, minify: true, ignoreMediaQueries: true }, ...e2, ...i2 }, o2 = Ra(sb(n2, t2));
  return s2 != null && s2.ignoreMediaQueries ? o2.removeMediaQueries() : (o2.removeUndefined(), o2.combineMediaQueries()), o2.fixRGB(), s2 != null && s2.merge && o2.merge(), s2 != null && s2.minify && o2.minify(), o2.get();
};
var Cp = (t2, e2) => (...r2) => kp(Ea(t2, e2)(r2));
var Sp = Ea();
var ab = Cp();

// node_modules/@pmndrs/uikit/dist/convert/html/generated-property-types.js
var generatedPropertyTypes = { "Inheriting": { "textAlign": [["block", "center", "left", "middle", "right"]], "verticalAlign": [["bottom", "center", "middle", "top"]], "color": ["string", "number"], "opacity": ["number"], "letterSpacing": ["number"], "lineHeight": ["percentage", "number"], "fontSize": ["number"], "wordBreak": [["break-all", "break-word", "keep-all"]], "fontFamily": ["string"], "fontWeight": [["black", "bold", "extra-black", "extra-bold", "extra-light", "light", "medium", "normal", "semi-bold", "thin"], "number"], "scrollbarOpacity": ["number"], "scrollbarColor": ["string", "number"], "scrollbarWidth": ["number"], "scrollbarBorderRightWidth": ["number"], "scrollbarBorderTopWidth": ["number"], "scrollbarBorderLeftWidth": ["number"], "scrollbarBorderBottomWidth": ["number"], "scrollbarBorderTopLeftRadius": ["number"], "scrollbarBorderTopRightRadius": ["number"], "scrollbarBorderBottomLeftRadius": ["number"], "scrollbarBorderBottomRightRadius": ["number"], "scrollbarBorderColor": ["string", "number"], "scrollbarBorderBend": ["number"], "scrollbarBorderOpacity": ["number"], "scrollbarBorderRadius": ["number"], "scrollbarBorderTopRadius": ["number"], "scrollbarBorderLeftRadius": ["number"], "scrollbarBorderRightRadius": ["number"], "scrollbarBorderBottomRadius": ["number"], "scrollbarBorderWidth": ["number"], "scrollbarBorderXWidth": ["number"], "scrollbarBorderYWidth": ["number"], "caretOpacity": ["number"], "caretColor": ["string", "number"], "caretWidth": ["number"], "caretBorderRightWidth": ["number"], "caretBorderTopWidth": ["number"], "caretBorderLeftWidth": ["number"], "caretBorderBottomWidth": ["number"], "caretBorderTopLeftRadius": ["number"], "caretBorderTopRightRadius": ["number"], "caretBorderBottomLeftRadius": ["number"], "caretBorderBottomRightRadius": ["number"], "caretBorderColor": ["string", "number"], "caretBorderBend": ["number"], "caretBorderOpacity": ["number"], "selectionOpacity": ["number"], "selectionColor": ["string", "number"], "selectionBorderRightWidth": ["number"], "selectionBorderTopWidth": ["number"], "selectionBorderLeftWidth": ["number"], "selectionBorderBottomWidth": ["number"], "selectionBorderTopLeftRadius": ["number"], "selectionBorderTopRightRadius": ["number"], "selectionBorderBottomLeftRadius": ["number"], "selectionBorderBottomRightRadius": ["number"], "selectionBorderColor": ["string", "number"], "selectionBorderBend": ["number"], "selectionBorderOpacity": ["number"], "caretBorderRadius": ["number"], "caretBorderTopRadius": ["number"], "caretBorderLeftRadius": ["number"], "caretBorderRightRadius": ["number"], "caretBorderBottomRadius": ["number"], "caretBorderWidth": ["number"], "caretBorderXWidth": ["number"], "caretBorderYWidth": ["number"], "selectionBorderRadius": ["number"], "selectionBorderTopRadius": ["number"], "selectionBorderLeftRadius": ["number"], "selectionBorderRightRadius": ["number"], "selectionBorderBottomRadius": ["number"], "selectionBorderWidth": ["number"], "selectionBorderXWidth": ["number"], "selectionBorderYWidth": ["number"] }, "Shared": { "positionType": [["absolute", "relative", "static"]], "positionTop": ["percentage", "number"], "positionLeft": ["percentage", "number"], "positionRight": ["percentage", "number"], "positionBottom": ["percentage", "number"], "alignContent": [["auto", "baseline", "center", "flex-end", "flex-start", "space-around", "space-between", "space-evenly", "stretch"]], "alignItems": [["auto", "baseline", "center", "flex-end", "flex-start", "space-around", "space-between", "space-evenly", "stretch"]], "alignSelf": [["auto", "baseline", "center", "flex-end", "flex-start", "space-around", "space-between", "space-evenly", "stretch"]], "flexDirection": [["column", "column-reverse", "row", "row-reverse"]], "flexWrap": [["no-wrap", "wrap", "wrap-reverse"]], "justifyContent": [["center", "flex-end", "flex-start", "space-around", "space-between", "space-evenly"]], "marginTop": ["percentage", ["auto"], "number"], "marginLeft": ["percentage", ["auto"], "number"], "marginRight": ["percentage", ["auto"], "number"], "marginBottom": ["percentage", ["auto"], "number"], "flexBasis": ["percentage", ["auto"], "number"], "flexGrow": ["number"], "flexShrink": ["number"], "width": ["percentage", ["auto"], "number"], "height": ["percentage", ["auto"], "number"], "minWidth": ["percentage", "number"], "minHeight": ["percentage", "number"], "maxWidth": ["percentage", "number"], "maxHeight": ["percentage", "number"], "aspectRatio": ["number"], "borderTopWidth": ["number"], "borderLeftWidth": ["number"], "borderRightWidth": ["number"], "borderBottomWidth": ["number"], "overflow": [["hidden", "scroll", "visible"]], "display": [["flex", "none"]], "paddingTop": ["percentage", "number"], "paddingLeft": ["percentage", "number"], "paddingRight": ["percentage", "number"], "paddingBottom": ["percentage", "number"], "gapRow": ["number"], "gapColumn": ["number"], "borderTopLeftRadius": ["number"], "borderTopRightRadius": ["number"], "borderBottomLeftRadius": ["number"], "borderBottomRightRadius": ["number"], "backgroundOpacity": ["number"], "backgroundColor": ["string", "number"], "borderColor": ["string", "number"], "borderBend": ["number"], "borderOpacity": ["number"], "zIndexOffset": ["number"], "transformTranslateX": ["percentage", "number"], "transformTranslateY": ["percentage", "number"], "transformTranslateZ": ["number"], "transformRotateX": ["number"], "transformRotateY": ["number"], "transformRotateZ": ["number"], "transformScaleX": ["percentage", "number"], "transformScaleY": ["percentage", "number"], "transformScaleZ": ["percentage", "number"], "transformOriginX": [["center", "left", "middle", "right"]], "transformOriginY": [["bottom", "center", "middle", "top"]], "receiveShadow": ["boolean"], "castShadow": ["boolean"], "visibility": [["hidden", "visible"]], "inset": ["percentage", "number"], "padding": ["percentage", "number"], "paddingX": ["percentage", "number"], "paddingY": ["percentage", "number"], "margin": ["percentage", ["auto"], "number"], "marginX": ["percentage", ["auto"], "number"], "marginY": ["percentage", ["auto"], "number"], "gap": ["number"], "borderWidth": ["number"], "borderXWidth": ["number"], "borderYWidth": ["number"], "borderRadius": ["number"], "borderTopRadius": ["number"], "borderLeftRadius": ["number"], "borderRightRadius": ["number"], "borderBottomRadius": ["number"], "transformScale": ["percentage", "number"], "cursor": ["string"] }, "Container": {}, "Image": { "keepAspectRatio": ["boolean"], "objectFit": [["cover", "fill"]], "src": ["string"] }, "Svg": { "keepAspectRatio": ["boolean"], "src": ["string"] }, "Icon": {}, "Input": { "disabled": ["boolean"], "type": [["password", "text"]], "value": ["string"], "tabIndex": ["number"], "multiline": ["boolean"], "defaultValue": ["string"] }, "Text": {}, "Video": { "keepAspectRatio": ["boolean"], "objectFit": [["cover", "fill"]], "src": ["string"], "volume": ["number"], "preservesPitch": ["boolean"], "playbackRate": ["number"], "muted": ["boolean"], "loop": ["boolean"], "autoplay": ["boolean"] } };

// node_modules/@pmndrs/uikit/dist/convert/html/properties.js
var propertyRenamings = {
  //yoga
  rowGap: "gapRow",
  columnGap: "gapColumn",
  position: "positionType",
  top: "positionTop",
  left: "positionLeft",
  right: "positionRight",
  bottom: "positionBottom",
  //ours
  zIndex: "zIndexOffset"
};
var transformRegex = /(translate|rotate)(X|Y|Z|3d)?\((\s*[^,)]+\s*(?:,\s*[^,)]+\s*)*)\)/g;
var customCssTranslation = {
  transform: (set, property) => {
    if (typeof property != "string") {
      return;
    }
    let result;
    while ((result = transformRegex.exec(property)) != null) {
      let [, operation, type, values] = result;
      let [x2, y3, z3] = values.split(",").map((s2) => s2.trim());
      const prefix = `transform${operation[0].toUpperCase()}${operation.slice(1)}`;
      if (operation === "rotate") {
        type ?? (type = "Z");
      }
      y3 ?? (y3 = x2);
      z3 ?? (z3 = x2);
      if (type === "X" || type === "3d" || type === void 0) {
        set(`${prefix}X`, x2);
      }
      if (type === "Y" || type === "3d" || type === void 0) {
        set(`${prefix}Y`, y3);
      }
      if (type === "Z" || type === "3d") {
        set(`${prefix}Z`, z3);
      }
    }
  },
  flex: (set, property) => {
    if (typeof property != "string") {
      return;
    }
    if (property === "auto") {
      set("flexGrow", "1");
      set("flexShrink", "1");
      set("flexBasis", "auto");
      return;
    }
    if (property === "none") {
      set("flexGrow", "0");
      set("flexShrink", "0");
      set("flexBasis", "auto");
    }
    if (property === "initial") {
      set("flexGrow", "0");
      set("flexShrink", "1");
      set("flexBasis", "auto");
    }
    let flexGrowShink = [];
    let flexBasis;
    const parts = property.split(/\s+/);
    for (const part of parts) {
      if (part === "auto") {
        flexBasis = part;
        continue;
      }
      const result = digitsWithUnitRegex.exec(part);
      if (result == null) {
        return;
      }
      const [, float, unit] = result;
      if (unit === "") {
        flexGrowShink.push(float);
        continue;
      }
      flexBasis = `${float}${unit}`;
    }
    const [flexGrow, flexShrink] = flexGrowShink;
    if (flexGrow != null) {
      set("flexGrow", flexGrow);
    }
    if (flexShrink != null) {
      set("flexShrink", flexShrink);
    }
    if (flexBasis != null) {
      set("flexBasis", flexBasis);
    }
  }
};
function isInheritingProperty(key) {
  switch (key) {
    case "opacity":
    case "color":
    case "textAlign":
    case "verticalAlign":
    case "fontSize":
    case "letterSpacing":
    case "lineHeight":
    case "wordBreak":
    case "fontFamily":
    case "fontWeight":
    case "visibility":
      return true;
    default:
      return key.startsWith("caret") || key.startsWith("scrollbar") || key.startsWith("selection");
  }
}
var conditionals = ["sm", "md", "lg", "xl", "2xl", "focus", "hover", "active", "dark"];
function convertProperties(propertyTypes, properties, colorMap, convertKey) {
  let result;
  const set = (key, value) => {
    const converted = convertProperty(propertyTypes, key, value, colorMap);
    if (converted == null) {
      return;
    }
    if (result == null) {
      result = {};
    }
    result[key] = converted;
  };
  for (let key in properties) {
    let property = properties[key];
    if (conditionals.includes(key) && property != null && typeof property === "object") {
      const conditionalProperties = convertProperties(propertyTypes, property, colorMap, convertKey);
      if (conditionalProperties != null) {
        if (result == null) {
          result = {};
        }
        result[key] = conditionalProperties;
        continue;
      }
    }
    if (key in propertyRenamings) {
      key = propertyRenamings[key];
    }
    if (convertKey != null) {
      key = convertKey(key);
    }
    if (key in customCssTranslation) {
      customCssTranslation[key](set, property);
      continue;
    }
    if (key === "positionType" && property === "fixed") {
      property = "absolute";
    }
    if (key === "display" && property === "block") {
      property = "flex";
    }
    if (key === "overflow" && property === "auto") {
      property = "scroll";
    }
    if (key === "borderColor" && property === "transparent") {
      key = "borderOpacity";
      property = "0";
    }
    if (key === "backgroundColor" && property === "transparent") {
      if (result == null) {
        result = {};
      }
      result[key] = void 0;
      return;
    }
    if (key === "opacity") {
      set("backgroundOpacity", property);
    }
    set(key, property);
  }
  return result;
}
var nonDigitRegex = /[^\d\.-]/;
function convertProperty(propertyTypes, key, value, colorMap) {
  if (key === "panelMaterialClass") {
    return value;
  }
  if (Array.isArray(propertyTypes)) {
    return firstNotNull(propertyTypes, (type) => convertProperty(type, key, value, colorMap));
  }
  const types = propertyTypes[key];
  if (types == null) {
    return void 0;
  }
  return firstNotNull(types, (type) => {
    if (Array.isArray(type)) {
      return typeof value === "string" && type.includes(value) ? value : void 0;
    }
    if (type === "boolean") {
      return value != "false";
    }
    if (type === "string") {
      return typeof value === "string" ? applyCustomColor(value, colorMap) ?? value : void 0;
    }
    if (type === "percentage") {
      return typeof value === "string" && percentageRegex.test(value) ? value : void 0;
    }
    let result = toNumber(value);
    if (result != null && key === "lineHeight" && !nonDigitRegex.test(value)) {
      return `${result * 100}%`;
    }
    return result;
  });
}
function firstNotNull(array, fn3) {
  const length = array.length;
  for (let i2 = 0; i2 < length; i2++) {
    const result = fn3(array[i2]);
    if (result != null) {
      return result;
    }
  }
  return void 0;
}
var divisionExpression = /(\d+)\s*\/\s*(\d+)/;
var digitsWithUnitRegex = /^(-?\d+|\d*\.\d+)([^\s\d]*)$/;
var unitMultiplierMap = {
  rem: 16,
  em: 16,
  px: 1,
  "": 1
};
function toNumber(value) {
  let result;
  result = digitsWithUnitRegex.exec(value);
  if (result != null) {
    const [, float, unit] = result;
    const multiplier2 = unitMultiplierMap[unit];
    if (multiplier2 != null) {
      return Number.parseFloat(float) * multiplier2;
    }
  }
  result = divisionExpression.exec(value);
  if (result != null) {
    const [, a2, b3] = result;
    return Number.parseFloat(a2) / Number.parseFloat(b3);
  }
}
var variableRegex = /^\$(.+)$/;
function applyCustomColor(value, customColors) {
  if (customColors == null) {
    return void 0;
  }
  const result = variableRegex.exec(value);
  if (result == null) {
    return value;
  }
  const entry = customColors[result[1]];
  if (entry == null) {
    throw new Error(`unknown custom color "${result[1]}"`);
  }
  if (typeof entry === "function") {
    return entry();
  }
  return entry;
}

// node_modules/@pmndrs/uikit/dist/convert/html/internals.js
var import_node_html_parser2 = __toESM(require_dist(), 1);
var styleTagRegex = /\<style\>(?:.|\s)*?\<\/style\>/gm;
var cssClassRegex = /\s*\.([^\{]+)\s*\{([^}]*)\}/g;
var cssPropsRegex = /([^:\s]+)\s*\:\s*([^;\s]+(?:[ \t]+[^;\s]+)*)\s*\;?\s*/g;
var spaceXYRegex = /(-?)space-(x|y)-(\d+)/g;
var PlasticMaterial = class extends MeshPhongMaterial {
  constructor() {
    super({
      specular: "#111",
      shininess: 100
    });
  }
};
var GlassMaterial = class extends MeshPhysicalMaterial {
  constructor() {
    super({
      transmission: 0.5,
      roughness: 0.1,
      reflectivity: 0.5,
      iridescence: 0.4,
      thickness: 0.05,
      specularIntensity: 1,
      metalness: 0.3,
      ior: 2,
      envMapIntensity: 1
    });
  }
};
var MetalMaterial = class extends MeshPhysicalMaterial {
  constructor() {
    super({
      metalness: 0.8,
      roughness: 0.1
    });
  }
};
var voidTagRegex = /<((\S+).*)\/>/g;
var mediaQueryRegex = /@media\(min-width:(\d+)px\)([^@]+)/gm;
var breakpoints = {
  "640": "sm",
  "768": "md",
  "1024": "lg",
  "1280": "xl",
  "1536": "2xl"
};
function parseHtml(text, colorMap) {
  text = text.replaceAll(styleTagRegex, "").replaceAll(voidTagRegex, (_3, tagContent, tagName) => `<${tagContent}></${tagName}>`);
  const element = (0, import_node_html_parser.parse)(text, { voidTag: { tags: [] } });
  const themeColors = {};
  for (const key in colorMap) {
    themeColors[key.replaceAll(/([A-Z])/g, (_3, char) => `-${char.toLowerCase()}`)] = `$${key}`;
  }
  const classes = /* @__PURE__ */ new Map([
    [
      "material-plastic",
      {
        panelMaterialClass: PlasticMaterial
      }
    ],
    [
      "material-metal",
      {
        panelMaterialClass: MetalMaterial
      }
    ],
    [
      "material-glass",
      {
        panelMaterialClass: GlassMaterial
      }
    ],
    [
      "border-bend",
      {
        borderBend: 0.5
      }
    ],
    [
      "inline-flex",
      {
        alignSelf: "flex-start"
      }
    ]
  ]);
  const css = Op({
    config: {
      theme: {
        extend: {
          colors: themeColors
        }
      }
    }
  }).twi(collectClasses(element).replaceAll(conditionalRegex, (_3, _selector, className) => className).replaceAll(spaceXYRegex, (className, negative, dir, value) => {
    const multiplier2 = negative === "-" ? -1 : 1;
    switch (dir) {
      case "x":
        classes.set(className, { flexDirection: "row", columnGap: parseFloat(value) * 4 * multiplier2 });
        break;
      case "y":
        classes.set(className, { flexDirection: "column", rowGap: parseFloat(value) * 4 * multiplier2 });
        break;
    }
    return "";
  }), { merge: false, ignoreMediaQueries: false }).replaceAll(/\\(.)/g, (_3, result) => result).replaceAll(mediaQueryRegex, (_3, breakpoint, content) => {
    const prefix = breakpoints[breakpoint];
    if (prefix == null) {
      return "";
    }
    content = content.slice(1, -1);
    parseCssClassDefinitions(content, (key, properties) => {
      const existingProperties = classes.get(key) ?? {};
      classes.set(key, { ...existingProperties, [prefix]: { ...existingProperties[prefix], ...properties } });
    });
    return "";
  });
  parseCssClassDefinitions(css, (key, properties) => classes.set(key, { ...classes.get(key), ...properties }));
  return { classes, element };
}
function parseCssClassDefinitions(css, set) {
  let classesResult;
  let contentResult;
  while ((classesResult = cssClassRegex.exec(css)) != null) {
    const [, className, classContent] = classesResult;
    const properties = {};
    while ((contentResult = cssPropsRegex.exec(classContent)) != null) {
      const [, name, value] = contentResult;
      properties[kebabToCamelCase(name)] = value;
    }
    set(className, properties);
  }
}
function collectClasses(element) {
  let result = "";
  if (element instanceof import_node_html_parser.HTMLElement) {
    result += " " + (element.classNames ?? "");
    result += " " + (element.attributes.className ?? "");
  }
  const childrenLength = element.childNodes.length;
  for (let i2 = 0; i2 < childrenLength; i2++) {
    result += collectClasses(element.childNodes[i2]);
  }
  return result;
}
function convertParsedHtml(element, classes, generate, colorMap, componentMap) {
  return convertParsedHtmlRecursive(element, classes, 0, generate, colorMap, componentMap);
}
var conversionPropertyTypes = {
  Inheriting: generatedPropertyTypes.Inheriting,
  Container: [generatedPropertyTypes.Inheriting, generatedPropertyTypes.Shared, generatedPropertyTypes.Container],
  Icon: [generatedPropertyTypes.Inheriting, generatedPropertyTypes.Shared, generatedPropertyTypes.Icon],
  Image: [generatedPropertyTypes.Inheriting, generatedPropertyTypes.Shared, generatedPropertyTypes.Image],
  Input: [generatedPropertyTypes.Inheriting, generatedPropertyTypes.Shared, generatedPropertyTypes.Input],
  Svg: [generatedPropertyTypes.Inheriting, generatedPropertyTypes.Shared, generatedPropertyTypes.Svg],
  Text: [generatedPropertyTypes.Inheriting, generatedPropertyTypes.Shared, generatedPropertyTypes.Text],
  Video: [generatedPropertyTypes.Inheriting, generatedPropertyTypes.Shared, generatedPropertyTypes.Video]
};
function convertParsedHtmlRecursive(element, classes, index, generate, colorMap, componentMap) {
  var _a;
  if (element instanceof import_node_html_parser.HTMLElement && ((_a = element.tagName) == null ? void 0 : _a.toLowerCase()) === "svg") {
    const { width, height, ...restAttributes } = element.attributes;
    const { inheritingProperties: inheritingProperties2, properties: properties2, srOnly: srOnly2 } = convertMergeSortProperties(false, [...conversionPropertyTypes.Icon, { svgWidth: ["number"], svgHeight: ["number"] }], classes, { svgWidth: toNumber(width) ?? 24, svgHeight: toNumber(height) ?? 24, text: element.toString() }, restAttributes, colorMap);
    if (srOnly2) {
      return void 0;
    }
    return generate(element, "Icon", false, { ...inheritingProperties2, ...properties2 }, index);
  }
  const [{ skipIfEmpty, defaultProperties, children, propertyTypes, renderAs }, custom] = nodeToConversionData(element, componentMap);
  if (skipIfEmpty && element.childNodes.length === 0) {
    return void 0;
  }
  if (skipIfEmpty && element.childNodes.length === 1) {
    return convertParsedHtmlRecursive(element.childNodes[0], classes, index, generate, colorMap, componentMap);
  }
  const { inheritingProperties, properties, srOnly } = element instanceof import_node_html_parser.HTMLElement ? convertMergeSortProperties(custom, propertyTypes, classes, defaultProperties, element.attributes, colorMap) : { inheritingProperties: void 0, properties: void 0, srOnly: false };
  if (srOnly) {
    return void 0;
  }
  switch (children) {
    case "none":
      return generate(element, renderAs, custom, { ...inheritingProperties, ...properties }, index);
    case "text":
      if (!(element instanceof import_node_html_parser.TextNode)) {
        return generate(element, renderAs, custom, { ...inheritingProperties, ...properties }, index, element.childNodes.filter(filterTextNode).map((e2) => e2.text.trim()).filter((text2) => text2.length > 0));
      }
      const text = element.text.trim();
      if (text.length === 0) {
        return void 0;
      }
      return generate(element, renderAs, custom, { ...inheritingProperties, ...properties }, index, [text]);
  }
  let result = generate(element, renderAs, custom, properties ?? {}, index, element.childNodes.map((node, i2) => convertParsedHtmlRecursive(node, classes, i2, generate, colorMap, componentMap)).filter(filterNull));
  if (inheritingProperties == null || Object.keys(inheritingProperties).length > 0) {
    result = generate(void 0, "DefaultProperties", false, inheritingProperties ?? {}, index, [result]);
  }
  return result;
}
function filterTextNode(val) {
  return val instanceof import_node_html_parser.TextNode;
}
function nodeToConversionData(element, customComponents) {
  if (element instanceof import_node_html_parser.TextNode) {
    return [
      {
        propertyTypes: conversionPropertyTypes.Text,
        renderAs: "Text",
        children: "text"
      },
      false
    ];
  }
  if (element.rawTagName == null) {
    return [
      {
        skipIfEmpty: true,
        propertyTypes: {},
        renderAs: "Fragment"
      },
      false
    ];
  }
  if (customComponents != null && element.rawTagName in customComponents) {
    return [customComponents[element.rawTagName], true];
  }
  let { children, defaultProperties, renderAs, skipIfEmpty } = htmlDefaults[element.rawTagName.toLowerCase()] ?? {};
  if (element.childNodes.length > 0 && element.childNodes.every((e2) => e2 instanceof import_node_html_parser.TextNode) && element.childNodes.some((e2) => e2 instanceof import_node_html_parser.TextNode && e2.text.trim().length > 0)) {
    renderAs ?? (renderAs = "Text");
    children ?? (children = "text");
  }
  renderAs ?? (renderAs = "Container");
  return [
    {
      propertyTypes: conversionPropertyTypes[renderAs],
      renderAs,
      children,
      defaultProperties,
      skipIfEmpty
    },
    false
  ];
}
function filterNull(val) {
  return val != null;
}
function convertMergeSortProperties(custom, propertyTypes, classes, defaultProperties, attributes, colorMap) {
  const [properties, srOnly] = convertHtmlAttributes(custom, propertyTypes, classes, attributes, colorMap);
  const result = {
    ...defaultProperties,
    ...properties
  };
  const inheritingProperties = {};
  for (const key in result) {
    if (!isInheritingProperty(key)) {
      continue;
    }
    inheritingProperties[key] = result[key];
    delete result[key];
  }
  return {
    inheritingProperties,
    properties: result,
    srOnly
  };
}
var kebebToCamelRegex = /-([a-zA-z])/g;
function kebabToCamelCase(name) {
  return name.replaceAll(kebebToCamelRegex, (_3, group) => group.toUpperCase());
}
function convertHtmlAttributes(custom, propertyTypes, classes, { class: _class, className, style, ...rest }, colorMap) {
  let srOnly = false;
  const result = convertProperties(propertyTypes, rest, colorMap, kebabToCamelCase) ?? {};
  if (_class != null) {
    if (_class.includes("sr-only")) {
      srOnly = true;
    }
    Object.assign(result, convertTailwind(propertyTypes, classes, _class, colorMap));
  }
  if (className != null) {
    if (className.includes("sr-only")) {
      srOnly = true;
    }
    Object.assign(result, convertTailwind(propertyTypes, classes, className, colorMap));
  }
  let styles = [];
  try {
    if (style != null) {
      styles = (0, import_inline_style_parser.default)(style);
    }
  } catch {
  }
  const stylesMap = {};
  for (const style2 of styles) {
    if (style2.type === "comment") {
      continue;
    }
    stylesMap[kebabToCamelCase(style2.property)] = style2.value;
  }
  Object.assign(result, convertProperties(propertyTypes, stylesMap, colorMap, kebabToCamelCase) ?? {});
  if (!custom && !("display" in result) && !("flexDirection" in result)) {
    const key = "flexDirection";
    const value = convertProperty(propertyTypes, key, "column", colorMap);
    if (value != null) {
      result[key] = value;
    }
  }
  return [result, srOnly];
}
var nonWhitespaceRegex = /\S+/g;
function tailwindToJson(classNames, classes) {
  const result = {};
  let classNameResult;
  while ((classNameResult = nonWhitespaceRegex.exec(classNames)) != null) {
    const [className] = classNameResult;
    const classesEntry = classes.get(className);
    if (classesEntry == null) {
      continue;
    }
    Object.assign(result, classesEntry);
  }
  return result;
}
var conditionalRegex = /(\S+)\:(\S+)/g;
function convertTailwind(propertyTypes, classes, className, colorMap) {
  const properties = {};
  const withoutConditionals = className.replaceAll(conditionalRegex, (_3, conditional, value) => {
    properties[conditional] = {
      ...properties[conditional],
      ...tailwindToJson(value, classes)
    };
    return "";
  });
  Object.assign(properties, tailwindToJson(withoutConditionals, classes));
  return convertProperties(propertyTypes, properties, colorMap) ?? {};
}

// node_modules/@react-three/uikit/dist/font.js
var import_react = __toESM(require_react(), 1);
var FontFamiliesContext = (0, import_react.createContext)(null);
function FontFamilyProvider(properties) {
  let { children, ...fontFamilies } = properties;
  const existinFontFamilyUrls = (0, import_react.useContext)(FontFamiliesContext);
  if (existinFontFamilyUrls != null) {
    fontFamilies = { ...existinFontFamilyUrls, ...fontFamilies };
  }
  return (0, import_jsx_runtime.jsx)(FontFamiliesContext.Provider, { value: fontFamilies, children });
}
function useFontFamilies() {
  return (0, import_react.useContext)(FontFamiliesContext);
}
function useMeasureText(fontFamily, fontWeight) {
  const fontFamilies = useFontFamilies();
  const propertiesSignal = (0, import_react.useMemo)(() => d(new MergedProperties()), []);
  propertiesSignal.value = new MergedProperties();
  propertiesSignal.value.add("fontFamily", fontFamily);
  propertiesSignal.value.add("fontWeight", fontWeight);
  const initializers = (0, import_react.useMemo)(() => [], []);
  const renderer = useThree((state) => state.gl);
  const font = (0, import_react.useMemo)(() => computedFont(propertiesSignal, d(fontFamilies), renderer, initializers), [fontFamilies, initializers, propertiesSignal, renderer]);
  (0, import_react.useEffect)(() => {
    const subscriptions = [];
    initialize(initializers, subscriptions);
    return () => unsubscribeSubscriptions(subscriptions);
  }, [initializers]);
  return (0, import_react.useCallback)(async (properties) => {
    let fontValue = font.peek();
    if (fontValue == null) {
      fontValue = await new Promise((resolve) => {
        const unsubscribe = font.subscribe((font2) => {
          if (font2 == null) {
            return;
          }
          unsubscribe();
          resolve(font2);
        });
      });
    }
    return measureGlyphLayout({ ...properties, font: fontValue }, properties.availableWidth);
  }, [font]);
}

// node_modules/@react-three/uikit/dist/context.js
var import_react2 = __toESM(require_react(), 1);
var ParentContext = (0, import_react2.createContext)(void 0);
function useParent() {
  const parent = (0, import_react2.useContext)(ParentContext);
  if (parent == null) {
    throw new Error(`Cannot be used outside of a uikit component.`);
  }
  return parent;
}
var ParentProvider = ParentContext.Provider;

// node_modules/@react-three/uikit/dist/responsive.js
function useRootSize() {
  return useParent().root.size;
}

// node_modules/@pmndrs/uikit/dist/vanilla/fullscreen.js
var vectorHelper5 = new Vector2();

// node_modules/@react-three/uikit/dist/default.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);
var DefaultPropertiesContext = (0, import_react3.createContext)(void 0);
function useDefaultProperties() {
  return (0, import_react3.useContext)(DefaultPropertiesContext);
}
function DefaultProperties(properties) {
  const existingDefaultProperties = (0, import_react3.useContext)(DefaultPropertiesContext);
  const result = { ...existingDefaultProperties };
  for (const key in properties) {
    if (key === "children") {
      continue;
    }
    const value = properties[key];
    if (value == null) {
      continue;
    }
    result[key] = value;
  }
  return (0, import_jsx_runtime2.jsx)(DefaultPropertiesContext.Provider, { value: result, children: properties.children });
}

// node_modules/@react-three/uikit/dist/container.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react6 = __toESM(require_react(), 1);

// node_modules/@react-three/uikit/dist/utilts.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react4 = __toESM(require_react(), 1);
var eventHandlerKeys = [
  "onClick",
  "onContextMenu",
  "onDoubleClick",
  "onPointerCancel",
  "onPointerDown",
  "onPointerEnter",
  "onPointerLeave",
  "onPointerMissed",
  "onPointerMove",
  "onPointerOut",
  "onPointerOver",
  "onPointerUp",
  "onWheel"
];
var AddHandlers = (0, import_react4.forwardRef)(({ handlers: handlersSignal, allowSkippingChildren, userHandlers, children }, ref) => {
  const [systemHandlers, setSystemHandlers] = (0, import_react4.useState)(() => handlersSignal.peek());
  (0, import_react4.useEffect)(() => E(() => {
    const handlers2 = handlersSignal.value;
    const ref2 = void setTimeout(() => setSystemHandlers(handlers2), 0);
    return () => clearTimeout(ref2);
  }), [handlersSignal]);
  const handlers = (0, import_react4.useMemo)(() => {
    const result = { ...systemHandlers };
    const keysLength = eventHandlerKeys.length;
    for (let i2 = 0; i2 < keysLength; i2++) {
      const key = eventHandlerKeys[i2];
      addHandler(key, result, userHandlers[key]);
    }
    if (Object.keys(result).length === 0) {
      return void 0;
    }
    return result;
  }, [systemHandlers, userHandlers]);
  if (allowSkippingChildren && handlers == null) {
    return null;
  }
  return (0, import_jsx_runtime3.jsx)("object3D", { ref, matrixAutoUpdate: false, ...handlers, children });
});
function usePropertySignals(properties) {
  const propertySignals = (0, import_react4.useMemo)(() => ({
    style: d(void 0),
    properties: d(void 0),
    default: d(void 0)
  }), []);
  propertySignals.properties.value = properties;
  propertySignals.default.value = useDefaultProperties();
  return propertySignals;
}

// node_modules/@react-three/uikit/dist/ref.js
var import_react5 = __toESM(require_react(), 1);
function useComponentInternals(ref, pixelSize, styleSignal, internals, interactionPanel, additional) {
  (0, import_react5.useImperativeHandle)(ref, () => {
    const { scrollPosition, paddingInset, borderInset, relativeCenter, size, maxScrollPosition } = internals;
    return {
      setStyle: (style) => styleSignal.value = style,
      getStyle: () => styleSignal.peek(),
      getComputedProperty: (key) => n(() => internals.mergedProperties.value.read(key, void 0)),
      pixelSize,
      borderInset,
      paddingInset,
      center: relativeCenter,
      maxScrollPosition,
      size,
      interactionPanel: interactionPanel instanceof Mesh ? interactionPanel : interactionPanel.current,
      scrollPosition,
      isClipped: internals.isClipped,
      ...additional
    };
  }, [internals, pixelSize, interactionPanel, additional, styleSignal]);
}

// node_modules/@react-three/uikit/dist/container.js
var Container = (0, import_react6.forwardRef)((properties, ref) => {
  const parent = useParent();
  const outerRef = (0, import_react6.useRef)(null);
  const innerRef = (0, import_react6.useRef)(null);
  const propertySignals = usePropertySignals(properties);
  const internals = (0, import_react6.useMemo)(() => createContainer(parent, propertySignals.style, propertySignals.properties, propertySignals.default, outerRef, innerRef), [parent, propertySignals]);
  internals.interactionPanel.name = properties.name ?? "";
  (0, import_react6.useEffect)(() => {
    const subscriptions = [];
    initialize(internals.initializers, subscriptions);
    return () => unsubscribeSubscriptions(subscriptions);
  }, [parent, propertySignals, internals]);
  useComponentInternals(ref, parent.root.pixelSize, propertySignals.style, internals, internals.interactionPanel);
  return (0, import_jsx_runtime4.jsxs)(AddHandlers, { userHandlers: properties, handlers: internals.handlers, ref: outerRef, children: [(0, import_jsx_runtime4.jsx)("primitive", { object: internals.interactionPanel }), (0, import_jsx_runtime4.jsx)("object3D", { matrixAutoUpdate: false, ref: innerRef, children: (0, import_jsx_runtime4.jsx)(ParentProvider, { value: internals, children: properties.children }) })] });
});

// node_modules/@react-three/uikit/dist/root.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);
var Root2 = (0, import_react7.forwardRef)((properties, ref) => {
  const renderer = useThree((state) => state.gl);
  renderer.setTransparentSort(reversePainterSortStable);
  const store = useStore();
  const outerRef = (0, import_react7.useRef)(null);
  const innerRef = (0, import_react7.useRef)(null);
  const pixelSizeSignal = (0, import_react7.useMemo)(() => d(void 0), []);
  pixelSizeSignal.value = properties.pixelSize;
  const propertySignals = usePropertySignals(properties);
  const onFrameSet = (0, import_react7.useMemo)(() => /* @__PURE__ */ new Set(), []);
  const whileOnFrameRef = (0, import_react7.useRef)(false);
  const invalidate = useThree((s2) => s2.invalidate);
  const internals = (0, import_react7.useMemo)(
    () => createRoot(
      w(() => readReactive(pixelSizeSignal.value) ?? DEFAULT_PIXEL_SIZE),
      propertySignals.style,
      propertySignals.properties,
      propertySignals.default,
      outerRef,
      innerRef,
      () => store.getState().camera,
      renderer,
      onFrameSet,
      () => {
        if (whileOnFrameRef.current) {
          return;
        }
        invalidate();
      },
      //requestFrame = invalidate, because invalidate always causes another frame
      invalidate
    ),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [invalidate]
  );
  internals.interactionPanel.name = properties.name ?? "";
  (0, import_react7.useEffect)(() => {
    const subscriptions = [];
    initialize(internals.initializers, subscriptions);
    return () => unsubscribeSubscriptions(subscriptions);
  }, [internals]);
  useFrame((_3, delta) => {
    whileOnFrameRef.current = true;
    for (const onFrame of onFrameSet) {
      onFrame(delta);
    }
    whileOnFrameRef.current = false;
  });
  useComponentInternals(ref, internals.root.pixelSize, propertySignals.style, internals, internals.interactionPanel);
  return (0, import_jsx_runtime5.jsxs)(AddHandlers, { userHandlers: properties, handlers: internals.handlers, ref: outerRef, children: [(0, import_jsx_runtime5.jsx)("primitive", { object: internals.interactionPanel }), (0, import_jsx_runtime5.jsx)("object3D", { matrixAutoUpdate: false, ref: innerRef, children: (0, import_jsx_runtime5.jsx)(ParentProvider, { value: internals, children: properties.children }) })] });
});

// node_modules/@react-three/uikit/dist/image.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);
var Image2 = (0, import_react8.forwardRef)((properties, ref) => {
  const parent = useParent();
  const outerRef = (0, import_react8.useRef)(null);
  const innerRef = (0, import_react8.useRef)(null);
  const propertySignals = usePropertySignals(properties);
  const internals = (0, import_react8.useMemo)(
    () => createImage(parent, propertySignals.style, propertySignals.properties, propertySignals.default, outerRef, innerRef),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  internals.interactionPanel.name = properties.name ?? "";
  (0, import_react8.useEffect)(() => {
    const subscriptions = [];
    initialize(internals.initializers, subscriptions);
    return () => unsubscribeSubscriptions(subscriptions);
  }, [internals]);
  useComponentInternals(ref, parent.root.pixelSize, propertySignals.style, internals, internals.interactionPanel);
  return (0, import_jsx_runtime6.jsxs)(AddHandlers, { userHandlers: properties, ref: outerRef, handlers: internals.handlers, children: [(0, import_jsx_runtime6.jsx)("primitive", { object: internals.interactionPanel }), (0, import_jsx_runtime6.jsx)("object3D", { matrixAutoUpdate: false, ref: innerRef, children: (0, import_jsx_runtime6.jsx)(ParentProvider, { value: internals, children: properties.children }) })] });
});

// node_modules/@react-three/uikit/dist/text.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react9 = __toESM(require_react(), 1);
var Text = (0, import_react9.forwardRef)((properties, ref) => {
  const parent = useParent();
  const outerRef = (0, import_react9.useRef)(null);
  const propertySignals = usePropertySignals(properties);
  const textSignal = (0, import_react9.useMemo)(() => d(void 0), []);
  textSignal.value = properties.children;
  const fontFamilies = (0, import_react9.useMemo)(() => d(void 0), []);
  fontFamilies.value = useFontFamilies();
  const internals = (0, import_react9.useMemo)(() => createText(parent, textSignal, fontFamilies, propertySignals.style, propertySignals.properties, propertySignals.default, outerRef), [fontFamilies, parent, propertySignals, textSignal]);
  internals.interactionPanel.name = properties.name ?? "";
  (0, import_react9.useEffect)(() => {
    const subscriptions = [];
    initialize(internals.initializers, subscriptions);
    return () => unsubscribeSubscriptions(subscriptions);
  }, [internals]);
  useComponentInternals(ref, parent.root.pixelSize, propertySignals.style, internals, internals.interactionPanel);
  return (0, import_jsx_runtime7.jsx)(AddHandlers, { allowSkippingChildren: true, userHandlers: properties, handlers: internals.handlers, ref: outerRef, children: (0, import_jsx_runtime7.jsx)("primitive", { object: internals.interactionPanel }) });
});

// node_modules/@react-three/uikit/dist/svg.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_react10 = __toESM(require_react(), 1);
var Svg = (0, import_react10.forwardRef)((properties, ref) => {
  const parent = useParent();
  const outerRef = (0, import_react10.useRef)(null);
  const innerRef = (0, import_react10.useRef)(null);
  const propertySignals = usePropertySignals(properties);
  const internals = (0, import_react10.useMemo)(() => createSvg(parent, propertySignals.style, propertySignals.properties, propertySignals.default, outerRef, innerRef), [parent, propertySignals]);
  internals.interactionPanel.name = properties.name ?? "";
  (0, import_react10.useEffect)(() => {
    const subscriptions = [];
    initialize(internals.initializers, subscriptions);
    return () => unsubscribeSubscriptions(subscriptions);
  }, [internals]);
  useComponentInternals(ref, parent.root.pixelSize, propertySignals.style, internals, internals.interactionPanel);
  return (0, import_jsx_runtime8.jsxs)(AddHandlers, { userHandlers: properties, ref: outerRef, handlers: internals.handlers, children: [(0, import_jsx_runtime8.jsx)("primitive", { object: internals.interactionPanel }), (0, import_jsx_runtime8.jsx)("primitive", { object: internals.centerGroup }), (0, import_jsx_runtime8.jsx)("object3D", { matrixAutoUpdate: false, ref: innerRef, children: (0, import_jsx_runtime8.jsx)(ParentProvider, { value: internals, children: properties.children }) })] });
});

// node_modules/@react-three/uikit/dist/icon.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_react11 = __toESM(require_react(), 1);
var Icon = (0, import_react11.forwardRef)((properties, ref) => {
  const parent = useParent();
  const outerRef = (0, import_react11.useRef)(null);
  const propertySignals = usePropertySignals(properties);
  const internals = (0, import_react11.useMemo)(() => createIcon(parent, properties.text, properties.svgWidth, properties.svgHeight, propertySignals.style, propertySignals.properties, propertySignals.default, outerRef), [parent, properties.svgHeight, properties.svgWidth, properties.text, propertySignals]);
  internals.interactionPanel.name = properties.name ?? "";
  (0, import_react11.useEffect)(() => {
    const subscriptions = [];
    initialize(internals.initializers, subscriptions);
    return () => unsubscribeSubscriptions(subscriptions);
  }, [internals]);
  useComponentInternals(ref, parent.root.pixelSize, propertySignals.style, internals, internals.interactionPanel);
  return (0, import_jsx_runtime9.jsxs)(AddHandlers, { userHandlers: properties, ref: outerRef, handlers: internals.handlers, children: [(0, import_jsx_runtime9.jsx)("primitive", { object: internals.interactionPanel }), (0, import_jsx_runtime9.jsx)("primitive", { object: internals.iconGroup })] });
});

// node_modules/@react-three/uikit/dist/input.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var import_react12 = __toESM(require_react(), 1);
var Input = (0, import_react12.forwardRef)((properties, ref) => {
  const parent = useParent();
  const outerRef = (0, import_react12.useRef)(null);
  const propertySignals = usePropertySignals(properties);
  const fontFamilies = (0, import_react12.useMemo)(() => d(void 0), []);
  fontFamilies.value = useFontFamilies();
  const internals = (0, import_react12.useMemo)(
    () => createInput(parent, fontFamilies, propertySignals.style, propertySignals.properties, propertySignals.default, outerRef),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  internals.interactionPanel.name = properties.name ?? "";
  (0, import_react12.useEffect)(() => {
    const subscriptions = [];
    initialize(internals.initializers, subscriptions);
    return () => unsubscribeSubscriptions(subscriptions);
  }, [internals]);
  useComponentInternals(ref, parent.root.pixelSize, propertySignals.style, internals, internals.interactionPanel, (0, import_react12.useMemo)(() => ({ focus: internals.focus, current: internals.valueSignal }), [internals.focus, internals.valueSignal]));
  return (0, import_jsx_runtime10.jsx)(AddHandlers, { allowSkippingChildren: true, userHandlers: properties, handlers: internals.handlers, ref: outerRef, children: (0, import_jsx_runtime10.jsx)("primitive", { object: internals.interactionPanel }) });
});

// node_modules/@react-three/uikit/dist/custom.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var import_react13 = __toESM(require_react(), 1);
var CustomContainer = (0, import_react13.forwardRef)((properties, ref) => {
  const parent = useParent();
  const outerRef = (0, import_react13.useRef)(null);
  const innerRef = (0, import_react13.useRef)(null);
  const propertySignals = usePropertySignals(properties);
  const internals = (0, import_react13.useMemo)(() => createCustomContainer(parent, propertySignals.style, propertySignals.properties, propertySignals.default, outerRef, innerRef), [parent, propertySignals]);
  (0, import_react13.useEffect)(() => {
    const subscriptions = [];
    initialize(internals.initializers, subscriptions);
    return () => unsubscribeSubscriptions(subscriptions);
  }, [internals]);
  useComponentInternals(ref, parent.root.pixelSize, propertySignals.style, internals, innerRef);
  (0, import_react13.useEffect)(() => {
    if (innerRef.current && properties.name) {
      innerRef.current.name = properties.name;
    }
  }, [properties.name]);
  return (0, import_jsx_runtime11.jsx)(AddHandlers, { userHandlers: properties, handlers: internals.handlers, ref: outerRef, children: (0, import_jsx_runtime11.jsx)(ParentProvider, { value: void 0, children: (0, import_jsx_runtime11.jsx)("mesh", { ref: innerRef, matrixAutoUpdate: false, geometry: panelGeometry, customDepthMaterial: properties.customDepthMaterial, customDistanceMaterial: properties.customDistanceMaterial, children: properties.children }) }) });
});

// node_modules/@react-three/uikit/dist/content.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var import_react14 = __toESM(require_react(), 1);
var Content = (0, import_react14.forwardRef)((properties, ref) => {
  const parent = useParent();
  const outerRef = (0, import_react14.useRef)(null);
  const innerRef = (0, import_react14.useRef)(null);
  const propertySignals = usePropertySignals(properties);
  const internals = (0, import_react14.useMemo)(() => createContent(parent, propertySignals.style, propertySignals.properties, propertySignals.default, outerRef, innerRef), [parent, propertySignals]);
  internals.interactionPanel.name = properties.name ?? "";
  (0, import_react14.useEffect)(() => {
    const subscriptions = [];
    initialize(internals.initializers, subscriptions);
    return () => unsubscribeSubscriptions(subscriptions);
  }, [internals]);
  useComponentInternals(ref, parent.root.pixelSize, propertySignals.style, internals, internals.interactionPanel);
  return (0, import_jsx_runtime12.jsxs)(AddHandlers, { userHandlers: properties, handlers: internals.handlers, ref: outerRef, children: [(0, import_jsx_runtime12.jsx)("primitive", { object: internals.interactionPanel }), (0, import_jsx_runtime12.jsx)("object3D", { matrixAutoUpdate: false, ref: innerRef, children: (0, import_jsx_runtime12.jsx)(ParentProvider, { value: void 0, children: properties.children }) })] });
});

// node_modules/@react-three/uikit/dist/fullscreen.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var import_react15 = __toESM(require_react(), 1);
var Fullscreen = (0, import_react15.forwardRef)((properties, ref) => {
  const store = useStore();
  const [sizeX, sizeY, pixelSize] = (0, import_react15.useMemo)(() => [d(1), d(1), d(1)], []);
  const camera = useThree((s2) => s2.camera);
  const distanceToCamera = properties.distanceToCamera ?? camera.near + 0.1;
  (0, import_react15.useEffect)(() => {
    const fn3 = ({ camera: camera2, size: { height } }) => r(() => updateSizeFullscreen(sizeX, sizeY, pixelSize, distanceToCamera, camera2, height));
    fn3(store.getState());
    return store.subscribe(fn3);
  }, [pixelSize, sizeX, sizeY, store, distanceToCamera]);
  const attachCamera = properties.attachCamera ?? true;
  return (0, import_jsx_runtime13.jsxs)(import_jsx_runtime13.Fragment, { children: [attachCamera && (0, import_jsx_runtime13.jsx)("primitive", { object: camera }), createPortal((0, import_jsx_runtime13.jsx)("group", { "position-z": -distanceToCamera, children: (0, import_jsx_runtime13.jsx)(Root2, { ref, ...properties, sizeX, sizeY, pixelSize, children: properties.children }) }), camera)] });
});

// node_modules/@react-three/uikit/dist/suspending.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var import_react16 = __toESM(require_react(), 1);
var SuspendingImage = (0, import_react16.forwardRef)(({ src, ...props }, ref) => {
  const texture = useLoader(TextureLoader, src);
  texture.colorSpace = SRGBColorSpace;
  texture.matrixAutoUpdate = false;
  return (0, import_jsx_runtime14.jsx)(Image2, { ref, src: texture, ...props });
});

// node_modules/@react-three/uikit/dist/portal.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var import_react17 = __toESM(require_react(), 1);
var privateKeys = [
  "set",
  "get",
  "setSize",
  "setFrameloop",
  "setDpr",
  "events",
  "invalidate",
  "advance",
  "size",
  "viewport"
];
var isOrthographicCamera = (def) => def && def.isOrthographicCamera;
var Portal = (0, import_react17.forwardRef)(({ children, dpr, frames = Infinity, renderPriority = 0, eventPriority = 0, ...props }, ref) => {
  const fbo = (0, import_react17.useMemo)(() => new u(void 0), []);
  const imageRef = (0, import_react17.useRef)(null);
  const previousRoot = useStore();
  dpr ?? (dpr = previousRoot.getState().viewport.dpr);
  (0, import_react17.useImperativeHandle)(ref, () => imageRef.current, []);
  const texture = (0, import_react17.useMemo)(() => w(() => {
    var _a;
    return (_a = fbo.value) == null ? void 0 : _a.texture;
  }), [fbo]);
  const usePortalStore = (0, import_react17.useMemo)(() => {
    let previousState = previousRoot.getState();
    const camera = new PerspectiveCamera(50, 1, 0.1, 1e3);
    camera.position.set(0, 0, 5);
    const pointer = new Vector2();
    let ownState = {
      events: { compute: uvCompute.bind(null, imageRef), priority: eventPriority },
      size: { width: 1, height: 1, left: 0, top: 0 },
      camera,
      scene: new Scene(),
      raycaster: new Raycaster(),
      pointer,
      mouse: pointer,
      previousRoot
    };
    const store = create((innerSet, get) => {
      const merge = () => {
        const result = {};
        for (const key in previousState) {
          if (privateKeys.includes(key)) {
            continue;
          }
          result[key] = previousState[key];
        }
        return Object.assign(result, ownState, {
          events: { ...previousState.events, ...ownState.events },
          viewport: Object.assign({}, previousState.viewport, previousState.viewport.getCurrentViewport(camera, new Vector3(), ownState.size))
        });
      };
      const update = () => innerSet(merge());
      return {
        ...previousState,
        // Set and get refer to this root-state
        set(newOwnState) {
          if (typeof newOwnState === "function") {
            newOwnState = newOwnState(get());
          }
          Object.assign(ownState, newOwnState);
          update();
        },
        setPreviousState(prevState) {
          previousState = prevState;
          update();
        },
        get,
        // Layers are allowed to override events
        setEvents(events) {
          Object.assign(ownState.events, events);
          update();
        },
        ...merge()
      };
    });
    return Object.assign(store, {
      setState(state) {
        store.getState().set(state);
      }
    });
  }, [eventPriority, previousRoot]);
  (0, import_react17.useEffect)(() => previousRoot.subscribe(usePortalStore.getState().setPreviousState), [previousRoot, usePortalStore]);
  (0, import_react17.useEffect)(() => {
    if (imageRef.current == null) {
      return;
    }
    const renderTarget = fbo.value = new WebGLRenderTarget(1, 1, {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      type: HalfFloatType
    });
    const { size } = imageRef.current;
    const unsubscribeSetSize = E(() => {
      if (size.value == null) {
        return;
      }
      const [width, height] = size.value;
      renderTarget.setSize(width * dpr, height * dpr);
      usePortalStore.setState({
        size: { width, height, top: 0, left: 0 },
        viewport: { ...previousRoot.getState().viewport, width, height, aspect: width / height }
      });
    });
    return () => {
      unsubscribeSetSize();
      renderTarget.dispose();
    };
  }, [fbo, previousRoot, usePortalStore, dpr]);
  return (0, import_jsx_runtime15.jsxs)(import_jsx_runtime15.Fragment, { children: [reconciler.createPortal((0, import_jsx_runtime15.jsx)(context.Provider, { value: usePortalStore, children: (0, import_jsx_runtime15.jsxs)(ChildrenToFBO, { renderPriority, frames, fbo, children: [children, (0, import_jsx_runtime15.jsx)("group", { onPointerOver: () => null })] }) }), usePortalStore, null), (0, import_jsx_runtime15.jsx)(Image2, { src: texture, objectFit: "fill", keepAspectRatio: false, ...props, ref: imageRef })] });
});
function uvCompute({ current }, event, state, previous) {
  var _a, _b, _c;
  if (current == null || previous == null) {
    return false;
  }
  if (!previous.raycaster.camera)
    (_c = (_b = previous.events).compute) == null ? void 0 : _c.call(_b, event, previous, (_a = previous.previousRoot) == null ? void 0 : _a.getState());
  const [intersection] = previous.raycaster.intersectObject(current.interactionPanel);
  if (!intersection)
    return false;
  const uv2 = intersection.uv;
  if (!uv2)
    return false;
  state.raycaster.setFromCamera(state.pointer.set(uv2.x * 2 - 1, uv2.y * 2 - 1), state.camera);
}
function ChildrenToFBO({ frames, renderPriority, children, fbo }) {
  const store = useStore();
  (0, import_react17.useEffect)(() => {
    return store.subscribe((state, prevState) => {
      const { size, camera } = state;
      if (size) {
        if (isOrthographicCamera(camera)) {
          camera.left = size.width / -2;
          camera.right = size.width / 2;
          camera.top = size.height / 2;
          camera.bottom = size.height / -2;
        } else {
          camera.aspect = size.width / size.height;
        }
        if (size !== prevState.size || camera !== prevState.camera) {
          camera.updateProjectionMatrix();
          camera.updateMatrixWorld();
        }
      }
    });
  }, [store]);
  let count = 0;
  let oldAutoClear;
  let oldXrEnabled;
  useFrame((state) => {
    const currentFBO = fbo.peek();
    if (currentFBO == null) {
      return;
    }
    if (frames === Infinity || count < frames) {
      oldAutoClear = state.gl.autoClear;
      oldXrEnabled = state.gl.xr.enabled;
      state.gl.autoClear = true;
      state.gl.xr.enabled = false;
      state.gl.setRenderTarget(currentFBO);
      state.gl.render(state.scene, state.camera);
      state.gl.setRenderTarget(null);
      state.gl.autoClear = oldAutoClear;
      state.gl.xr.enabled = oldXrEnabled;
      count++;
    }
  }, renderPriority);
  return (0, import_jsx_runtime15.jsx)(import_jsx_runtime15.Fragment, { children });
}

// node_modules/@react-three/uikit/dist/video.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var import_react18 = __toESM(require_react(), 1);
var VideoContext = (0, import_react18.createContext)(void 0);
function useVideoElement() {
  const element = (0, import_react18.useContext)(VideoContext);
  if (element == null) {
    throw new Error(`useVideoElement can only be executed inside a Video component`);
  }
  return element;
}
var Video = (0, import_react18.forwardRef)((props, ref) => {
  const texture = (0, import_react18.useMemo)(() => d(void 0), []);
  const aspectRatio = (0, import_react18.useMemo)(() => d(1), []);
  const providedHtmlElement = props.src instanceof HTMLVideoElement ? props.src : void 0;
  const element = (0, import_react18.useMemo)(() => providedHtmlElement ?? document.createElement("video"), [providedHtmlElement]);
  const invalidate = useThree((s2) => s2.invalidate);
  (0, import_react18.useEffect)(() => setupVideoElementInvalidation(element, invalidate), [element, invalidate]);
  updateVideoElement(element, props);
  (0, import_react18.useEffect)(() => {
    const updateAspectRatio = () => aspectRatio.value = element.videoWidth / element.videoHeight;
    updateAspectRatio();
    element.addEventListener("resize", updateAspectRatio);
    return () => element.removeEventListener("resize", updateAspectRatio);
  }, [aspectRatio, element]);
  (0, import_react18.useEffect)(() => {
    const videoTexture = new VideoTexture(element);
    videoTexture.colorSpace = SRGBColorSpace;
    texture.value = videoTexture;
    return () => videoTexture.dispose();
  }, [texture, element]);
  const internalRef = (0, import_react18.useRef)(null);
  (0, import_react18.useImperativeHandle)(ref, () => ({ ...internalRef.current, element }), [element]);
  return (0, import_jsx_runtime16.jsx)(VideoContext.Provider, { value: element, children: (0, import_jsx_runtime16.jsx)(Image2, { aspectRatio, ...props, ref: internalRef, src: texture }) });
});

// node_modules/@react-three/uikit/node_modules/prettier/standalone.mjs
var yu = Object.create;
var He = Object.defineProperty;
var Au = Object.getOwnPropertyDescriptor;
var Bu2 = Object.getOwnPropertyNames;
var wu = Object.getPrototypeOf;
var xu = Object.prototype.hasOwnProperty;
var sr2 = (e2) => {
  throw TypeError(e2);
};
var _u = (e2, t2) => () => (e2 && (t2 = e2(e2 = 0)), t2);
var At2 = (e2, t2) => () => (t2 || e2((t2 = { exports: {} }).exports, t2), t2.exports);
var We = (e2, t2) => {
  for (var r2 in t2)
    He(e2, r2, { get: t2[r2], enumerable: true });
};
var ar2 = (e2, t2, r2, n2) => {
  if (t2 && typeof t2 == "object" || typeof t2 == "function")
    for (let o2 of Bu2(t2))
      !xu.call(e2, o2) && o2 !== r2 && He(e2, o2, { get: () => t2[o2], enumerable: !(n2 = Au(t2, o2)) || n2.enumerable });
  return e2;
};
var Me2 = (e2, t2, r2) => (r2 = e2 != null ? yu(wu(e2)) : {}, ar2(t2 || !e2 || !e2.__esModule ? He(r2, "default", { value: e2, enumerable: true }) : r2, e2));
var vu = (e2) => ar2(He({}, "__esModule", { value: true }), e2);
var bu = (e2, t2, r2) => t2.has(e2) || sr2("Cannot " + r2);
var Dr = (e2, t2, r2) => t2.has(e2) ? sr2("Cannot add the same private member more than once") : t2 instanceof WeakSet ? t2.add(e2) : t2.set(e2, r2);
var pe = (e2, t2, r2) => (bu(e2, t2, "access private method"), r2);
var it2 = At2((ia, sn2) => {
  "use strict";
  var on2 = new Proxy(String, { get: () => on2 });
  sn2.exports = on2;
});
var Tn2 = {};
We(Tn2, { default: () => _o, shouldHighlight: () => xo });
var xo;
var _o;
var kn2 = _u(() => {
  xo = () => false, _o = String;
});
var Pn2 = At2((bD, Xt) => {
  var g2 = String, Ln = function() {
    return { isColorSupported: false, reset: g2, bold: g2, dim: g2, italic: g2, underline: g2, inverse: g2, hidden: g2, strikethrough: g2, black: g2, red: g2, green: g2, yellow: g2, blue: g2, magenta: g2, cyan: g2, white: g2, gray: g2, bgBlack: g2, bgRed: g2, bgGreen: g2, bgYellow: g2, bgBlue: g2, bgMagenta: g2, bgCyan: g2, bgWhite: g2 };
  };
  Xt.exports = Ln();
  Xt.exports.createColors = Ln;
});
var $n2 = At2((Ct) => {
  "use strict";
  Object.defineProperty(Ct, "__esModule", { value: true });
  Ct.codeFrameColumns = Mn2;
  Ct.default = To;
  var In2 = (kn2(), vu(Tn2)), Hn = vo(Pn2(), true);
  function Wn2(e2) {
    if (typeof WeakMap != "function")
      return null;
    var t2 = /* @__PURE__ */ new WeakMap(), r2 = /* @__PURE__ */ new WeakMap();
    return (Wn2 = function(n2) {
      return n2 ? r2 : t2;
    })(e2);
  }
  function vo(e2, t2) {
    if (!t2 && e2 && e2.__esModule)
      return e2;
    if (e2 === null || typeof e2 != "object" && typeof e2 != "function")
      return { default: e2 };
    var r2 = Wn2(t2);
    if (r2 && r2.has(e2))
      return r2.get(e2);
    var n2 = { __proto__: null }, o2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var u2 in e2)
      if (u2 !== "default" && {}.hasOwnProperty.call(e2, u2)) {
        var i2 = o2 ? Object.getOwnPropertyDescriptor(e2, u2) : null;
        i2 && (i2.get || i2.set) ? Object.defineProperty(n2, u2, i2) : n2[u2] = e2[u2];
      }
    return n2.default = e2, r2 && r2.set(e2, n2), n2;
  }
  var bo = Hn.default, Rn2 = (e2, t2) => (r2) => e2(t2(r2)), Zt;
  function Oo(e2) {
    if (e2) {
      var t2;
      return (t2 = Zt) != null || (Zt = (0, Hn.createColors)(true)), Zt;
    }
    return bo;
  }
  var Yn2 = false;
  function So(e2) {
    return { gutter: e2.gray, marker: Rn2(e2.red, e2.bold), message: Rn2(e2.red, e2.bold) };
  }
  var jn = /\r\n|[\n\r\u2028\u2029]/;
  function No(e2, t2, r2) {
    let n2 = Object.assign({ column: 0, line: -1 }, e2.start), o2 = Object.assign({}, n2, e2.end), { linesAbove: u2 = 2, linesBelow: i2 = 3 } = r2 || {}, s2 = n2.line, a2 = n2.column, D = o2.line, l2 = o2.column, d2 = Math.max(s2 - (u2 + 1), 0), f2 = Math.min(t2.length, D + i2);
    s2 === -1 && (d2 = 0), D === -1 && (f2 = t2.length);
    let p2 = D - s2, c2 = {};
    if (p2)
      for (let F = 0; F <= p2; F++) {
        let m = F + s2;
        if (!a2)
          c2[m] = true;
        else if (F === 0) {
          let E2 = t2[m - 1].length;
          c2[m] = [a2, E2 - a2 + 1];
        } else if (F === p2)
          c2[m] = [0, l2];
        else {
          let E2 = t2[m - F].length;
          c2[m] = [0, E2];
        }
      }
    else
      a2 === l2 ? a2 ? c2[s2] = [a2, 0] : c2[s2] = true : c2[s2] = [a2, l2 - a2];
    return { start: d2, end: f2, markerLines: c2 };
  }
  function Mn2(e2, t2, r2 = {}) {
    let n2 = (r2.highlightCode || r2.forceColor) && (0, In2.shouldHighlight)(r2), o2 = Oo(r2.forceColor), u2 = So(o2), i2 = (F, m) => n2 ? F(m) : m, s2 = e2.split(jn), { start: a2, end: D, markerLines: l2 } = No(t2, s2, r2), d2 = t2.start && typeof t2.start.column == "number", f2 = String(D).length, c2 = (n2 ? (0, In2.default)(e2, r2) : e2).split(jn, D).slice(a2, D).map((F, m) => {
      let E2 = a2 + 1 + m, w2 = ` ${` ${E2}`.slice(-f2)} |`, h2 = l2[E2], C = !l2[E2 + 1];
      if (h2) {
        let k = "";
        if (Array.isArray(h2)) {
          let v2 = F.slice(0, Math.max(h2[0] - 1, 0)).replace(/[^\t]/g, " "), $2 = h2[1] || 1;
          k = [`
 `, i2(u2.gutter, w2.replace(/\d/g, " ")), " ", v2, i2(u2.marker, "^").repeat($2)].join(""), C && r2.message && (k += " " + i2(u2.message, r2.message));
        }
        return [i2(u2.marker, ">"), i2(u2.gutter, w2), F.length > 0 ? ` ${F}` : "", k].join("");
      } else
        return ` ${i2(u2.gutter, w2)}${F.length > 0 ? ` ${F}` : ""}`;
    }).join(`
`);
    return r2.message && !d2 && (c2 = `${" ".repeat(f2 + 1)}${r2.message}
${c2}`), n2 ? o2.reset(c2) : c2;
  }
  function To(e2, t2, r2, n2 = {}) {
    if (!Yn2) {
      Yn2 = true;
      let u2 = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      {
        let i2 = new Error(u2);
        i2.name = "DeprecationWarning", console.warn(new Error(u2));
      }
    }
    return r2 = Math.max(r2, 0), Mn2(e2, { start: { column: r2, line: t2 } }, n2);
  }
});
var ir2 = {};
We(ir2, { __debug: () => di, check: () => fi, doc: () => nr, format: () => gu, formatWithCursor: () => Cu2, getSupportInfo: () => pi2, util: () => or2, version: () => fu });
var Ou = (e2, t2, r2, n2) => {
  if (!(e2 && t2 == null))
    return t2.replaceAll ? t2.replaceAll(r2, n2) : r2.global ? t2.replace(r2, n2) : t2.split(r2).join(n2);
};
var ne2 = Ou;
function Z2() {
}
Z2.prototype = { diff: function(t2, r2) {
  var n2, o2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, u2 = o2.callback;
  typeof o2 == "function" && (u2 = o2, o2 = {}), this.options = o2;
  var i2 = this;
  function s2(h2) {
    return u2 ? (setTimeout(function() {
      u2(void 0, h2);
    }, 0), true) : h2;
  }
  t2 = this.castInput(t2), r2 = this.castInput(r2), t2 = this.removeEmpty(this.tokenize(t2)), r2 = this.removeEmpty(this.tokenize(r2));
  var a2 = r2.length, D = t2.length, l2 = 1, d2 = a2 + D;
  o2.maxEditLength && (d2 = Math.min(d2, o2.maxEditLength));
  var f2 = (n2 = o2.timeout) !== null && n2 !== void 0 ? n2 : 1 / 0, p2 = Date.now() + f2, c2 = [{ oldPos: -1, lastComponent: void 0 }], F = this.extractCommon(c2[0], r2, t2, 0);
  if (c2[0].oldPos + 1 >= D && F + 1 >= a2)
    return s2([{ value: this.join(r2), count: r2.length }]);
  var m = -1 / 0, E2 = 1 / 0;
  function A() {
    for (var h2 = Math.max(m, -l2); h2 <= Math.min(E2, l2); h2 += 2) {
      var C = void 0, k = c2[h2 - 1], v2 = c2[h2 + 1];
      k && (c2[h2 - 1] = void 0);
      var $2 = false;
      if (v2) {
        var ye = v2.oldPos - h2;
        $2 = v2 && 0 <= ye && ye < a2;
      }
      var yt2 = k && k.oldPos + 1 < D;
      if (!$2 && !yt2) {
        c2[h2] = void 0;
        continue;
      }
      if (!yt2 || $2 && k.oldPos + 1 < v2.oldPos ? C = i2.addToPath(v2, true, void 0, 0) : C = i2.addToPath(k, void 0, true, 1), F = i2.extractCommon(C, r2, t2, h2), C.oldPos + 1 >= D && F + 1 >= a2)
        return s2(Su2(i2, C.lastComponent, r2, t2, i2.useLongestToken));
      c2[h2] = C, C.oldPos + 1 >= D && (E2 = Math.min(E2, h2 - 1)), F + 1 >= a2 && (m = Math.max(m, h2 + 1));
    }
    l2++;
  }
  if (u2)
    (function h2() {
      setTimeout(function() {
        if (l2 > d2 || Date.now() > p2)
          return u2();
        A() || h2();
      }, 0);
    })();
  else
    for (; l2 <= d2 && Date.now() <= p2; ) {
      var w2 = A();
      if (w2)
        return w2;
    }
}, addToPath: function(t2, r2, n2, o2) {
  var u2 = t2.lastComponent;
  return u2 && u2.added === r2 && u2.removed === n2 ? { oldPos: t2.oldPos + o2, lastComponent: { count: u2.count + 1, added: r2, removed: n2, previousComponent: u2.previousComponent } } : { oldPos: t2.oldPos + o2, lastComponent: { count: 1, added: r2, removed: n2, previousComponent: u2 } };
}, extractCommon: function(t2, r2, n2, o2) {
  for (var u2 = r2.length, i2 = n2.length, s2 = t2.oldPos, a2 = s2 - o2, D = 0; a2 + 1 < u2 && s2 + 1 < i2 && this.equals(r2[a2 + 1], n2[s2 + 1]); )
    a2++, s2++, D++;
  return D && (t2.lastComponent = { count: D, previousComponent: t2.lastComponent }), t2.oldPos = s2, a2;
}, equals: function(t2, r2) {
  return this.options.comparator ? this.options.comparator(t2, r2) : t2 === r2 || this.options.ignoreCase && t2.toLowerCase() === r2.toLowerCase();
}, removeEmpty: function(t2) {
  for (var r2 = [], n2 = 0; n2 < t2.length; n2++)
    t2[n2] && r2.push(t2[n2]);
  return r2;
}, castInput: function(t2) {
  return t2;
}, tokenize: function(t2) {
  return t2.split("");
}, join: function(t2) {
  return t2.join("");
} };
function Su2(e2, t2, r2, n2, o2) {
  for (var u2 = [], i2; t2; )
    u2.push(t2), i2 = t2.previousComponent, delete t2.previousComponent, t2 = i2;
  u2.reverse();
  for (var s2 = 0, a2 = u2.length, D = 0, l2 = 0; s2 < a2; s2++) {
    var d2 = u2[s2];
    if (d2.removed) {
      if (d2.value = e2.join(n2.slice(l2, l2 + d2.count)), l2 += d2.count, s2 && u2[s2 - 1].added) {
        var p2 = u2[s2 - 1];
        u2[s2 - 1] = u2[s2], u2[s2] = p2;
      }
    } else {
      if (!d2.added && o2) {
        var f2 = r2.slice(D, D + d2.count);
        f2 = f2.map(function(F, m) {
          var E2 = n2[l2 + m];
          return E2.length > F.length ? E2 : F;
        }), d2.value = e2.join(f2);
      } else
        d2.value = e2.join(r2.slice(D, D + d2.count));
      D += d2.count, d2.added || (l2 += d2.count);
    }
  }
  var c2 = u2[a2 - 1];
  return a2 > 1 && typeof c2.value == "string" && (c2.added || c2.removed) && e2.equals("", c2.value) && (u2[a2 - 2].value += c2.value, u2.pop()), u2;
}
var hi2 = new Z2();
var lr2 = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
var cr2 = /\S/;
var fr2 = new Z2();
fr2.equals = function(e2, t2) {
  return this.options.ignoreCase && (e2 = e2.toLowerCase(), t2 = t2.toLowerCase()), e2 === t2 || this.options.ignoreWhitespace && !cr2.test(e2) && !cr2.test(t2);
};
fr2.tokenize = function(e2) {
  for (var t2 = e2.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), r2 = 0; r2 < t2.length - 1; r2++)
    !t2[r2 + 1] && t2[r2 + 2] && lr2.test(t2[r2]) && lr2.test(t2[r2 + 2]) && (t2[r2] += t2[r2 + 2], t2.splice(r2 + 1, 2), r2--);
  return t2;
};
var pr2 = new Z2();
pr2.tokenize = function(e2) {
  this.options.stripTrailingCr && (e2 = e2.replace(/\r\n/g, `
`));
  var t2 = [], r2 = e2.split(/(\n|\r\n)/);
  r2[r2.length - 1] || r2.pop();
  for (var n2 = 0; n2 < r2.length; n2++) {
    var o2 = r2[n2];
    n2 % 2 && !this.options.newlineIsToken ? t2[t2.length - 1] += o2 : (this.options.ignoreWhitespace && (o2 = o2.trim()), t2.push(o2));
  }
  return t2;
};
var Nu = new Z2();
Nu.tokenize = function(e2) {
  return e2.split(/(\S.+?[.!?])(?=\s+|$)/);
};
var Tu = new Z2();
Tu.tokenize = function(e2) {
  return e2.split(/([{}:;,]|\s+)/);
};
function $e2(e2) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? $e2 = function(t2) {
    return typeof t2;
  } : $e2 = function(t2) {
    return t2 && typeof Symbol == "function" && t2.constructor === Symbol && t2 !== Symbol.prototype ? "symbol" : typeof t2;
  }, $e2(e2);
}
var ku = Object.prototype.toString;
var Ae2 = new Z2();
Ae2.useLongestToken = true;
Ae2.tokenize = pr2.tokenize;
Ae2.castInput = function(e2) {
  var t2 = this.options, r2 = t2.undefinedReplacement, n2 = t2.stringifyReplacer, o2 = n2 === void 0 ? function(u2, i2) {
    return typeof i2 > "u" ? r2 : i2;
  } : n2;
  return typeof e2 == "string" ? e2 : JSON.stringify(Bt(e2, null, null, o2), o2, "  ");
};
Ae2.equals = function(e2, t2) {
  return Z2.prototype.equals.call(Ae2, e2.replace(/,([\r\n])/g, "$1"), t2.replace(/,([\r\n])/g, "$1"));
};
function Bt(e2, t2, r2, n2, o2) {
  t2 = t2 || [], r2 = r2 || [], n2 && (e2 = n2(o2, e2));
  var u2;
  for (u2 = 0; u2 < t2.length; u2 += 1)
    if (t2[u2] === e2)
      return r2[u2];
  var i2;
  if (ku.call(e2) === "[object Array]") {
    for (t2.push(e2), i2 = new Array(e2.length), r2.push(i2), u2 = 0; u2 < e2.length; u2 += 1)
      i2[u2] = Bt(e2[u2], t2, r2, n2, o2);
    return t2.pop(), r2.pop(), i2;
  }
  if (e2 && e2.toJSON && (e2 = e2.toJSON()), $e2(e2) === "object" && e2 !== null) {
    t2.push(e2), i2 = {}, r2.push(i2);
    var s2 = [], a2;
    for (a2 in e2)
      e2.hasOwnProperty(a2) && s2.push(a2);
    for (s2.sort(), u2 = 0; u2 < s2.length; u2 += 1)
      a2 = s2[u2], i2[a2] = Bt(e2[a2], t2, r2, n2, a2);
    t2.pop(), r2.pop();
  } else
    i2 = e2;
  return i2;
}
var Ve = new Z2();
Ve.tokenize = function(e2) {
  return e2.slice();
};
Ve.join = Ve.removeEmpty = function(e2) {
  return e2;
};
function dr2(e2, t2, r2) {
  return Ve.diff(e2, t2, r2);
}
function Fr(e2) {
  let t2 = e2.indexOf("\r");
  return t2 >= 0 ? e2.charAt(t2 + 1) === `
` ? "crlf" : "cr" : "lf";
}
function Be2(e2) {
  switch (e2) {
    case "cr":
      return "\r";
    case "crlf":
      return `\r
`;
    default:
      return `
`;
  }
}
function wt2(e2, t2) {
  let r2;
  switch (t2) {
    case `
`:
      r2 = /\n/gu;
      break;
    case "\r":
      r2 = /\r/gu;
      break;
    case `\r
`:
      r2 = /\r\n/gu;
      break;
    default:
      throw new Error(`Unexpected "eol" ${JSON.stringify(t2)}.`);
  }
  let n2 = e2.match(r2);
  return n2 ? n2.length : 0;
}
function mr(e2) {
  return ne2(false, e2, /\r\n?/gu, `
`);
}
var U = "string";
var W = "array";
var z2 = "cursor";
var L2 = "indent";
var P = "align";
var I = "trim";
var x = "group";
var S2 = "fill";
var _2 = "if-break";
var R2 = "indent-if-break";
var Y = "line-suffix";
var j = "line-suffix-boundary";
var B = "line";
var N = "label";
var b2 = "break-parent";
var Ue = /* @__PURE__ */ new Set([z2, L2, P, I, x, S2, _2, R2, Y, j, B, N, b2]);
function Lu2(e2) {
  if (typeof e2 == "string")
    return U;
  if (Array.isArray(e2))
    return W;
  if (!e2)
    return;
  let { type: t2 } = e2;
  if (Ue.has(t2))
    return t2;
}
var G2 = Lu2;
var Pu = (e2) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(e2);
function Iu(e2) {
  let t2 = e2 === null ? "null" : typeof e2;
  if (t2 !== "string" && t2 !== "object")
    return `Unexpected doc '${t2}', 
Expected it to be 'string' or 'object'.`;
  if (G2(e2))
    throw new Error("doc is valid.");
  let r2 = Object.prototype.toString.call(e2);
  if (r2 !== "[object Object]")
    return `Unexpected doc '${r2}'.`;
  let n2 = Pu([...Ue].map((o2) => `'${o2}'`));
  return `Unexpected doc.type '${e2.type}'.
Expected it to be ${n2}.`;
}
var xt2 = class extends Error {
  constructor(t2) {
    super(Iu(t2));
    __publicField(this, "name", "InvalidDocError");
    this.doc = t2;
  }
};
var Q2 = xt2;
var Er = {};
function Ru(e2, t2, r2, n2) {
  let o2 = [e2];
  for (; o2.length > 0; ) {
    let u2 = o2.pop();
    if (u2 === Er) {
      r2(o2.pop());
      continue;
    }
    r2 && o2.push(u2, Er);
    let i2 = G2(u2);
    if (!i2)
      throw new Q2(u2);
    if ((t2 == null ? void 0 : t2(u2)) !== false)
      switch (i2) {
        case W:
        case S2: {
          let s2 = i2 === W ? u2 : u2.parts;
          for (let a2 = s2.length, D = a2 - 1; D >= 0; --D)
            o2.push(s2[D]);
          break;
        }
        case _2:
          o2.push(u2.flatContents, u2.breakContents);
          break;
        case x:
          if (n2 && u2.expandedStates)
            for (let s2 = u2.expandedStates.length, a2 = s2 - 1; a2 >= 0; --a2)
              o2.push(u2.expandedStates[a2]);
          else
            o2.push(u2.contents);
          break;
        case P:
        case L2:
        case R2:
        case N:
        case Y:
          o2.push(u2.contents);
          break;
        case U:
        case z2:
        case I:
        case j:
        case B:
        case b2:
          break;
        default:
          throw new Q2(u2);
      }
  }
}
var we2 = Ru;
var hr = () => {
};
var K = hr;
var ze = hr;
function De2(e2) {
  return K(e2), { type: L2, contents: e2 };
}
function ae(e2, t2) {
  return K(t2), { type: P, contents: t2, n: e2 };
}
function _t(e2, t2 = {}) {
  return K(e2), ze(t2.expandedStates, true), { type: x, id: t2.id, contents: e2, break: !!t2.shouldBreak, expandedStates: t2.expandedStates };
}
function Cr(e2) {
  return ae(Number.NEGATIVE_INFINITY, e2);
}
function gr2(e2) {
  return ae({ type: "root" }, e2);
}
function yr2(e2) {
  return ae(-1, e2);
}
function Ar2(e2, t2) {
  return _t(e2[0], { ...t2, expandedStates: e2 });
}
function Ge2(e2) {
  return ze(e2), { type: S2, parts: e2 };
}
function Br(e2, t2 = "", r2 = {}) {
  return K(e2), t2 !== "" && K(t2), { type: _2, breakContents: e2, flatContents: t2, groupId: r2.groupId };
}
function wr(e2, t2) {
  return K(e2), { type: R2, contents: e2, groupId: t2.groupId, negate: t2.negate };
}
function xe2(e2) {
  return K(e2), { type: Y, contents: e2 };
}
var xr2 = { type: j };
var de = { type: b2 };
var _r2 = { type: I };
var _e2 = { type: B, hard: true };
var vt = { type: B, hard: true, literal: true };
var Ke2 = { type: B };
var vr2 = { type: B, soft: true };
var q = [_e2, de];
var qe = [vt, de];
var ve2 = { type: z2 };
function be2(e2, t2) {
  K(e2), ze(t2);
  let r2 = [];
  for (let n2 = 0; n2 < t2.length; n2++)
    n2 !== 0 && r2.push(e2), r2.push(t2[n2]);
  return r2;
}
function Je(e2, t2, r2) {
  K(e2);
  let n2 = e2;
  if (t2 > 0) {
    for (let o2 = 0; o2 < Math.floor(t2 / r2); ++o2)
      n2 = De2(n2);
    n2 = ae(t2 % r2, n2), n2 = ae(Number.NEGATIVE_INFINITY, n2);
  }
  return n2;
}
function br2(e2, t2) {
  return K(t2), e2 ? { type: N, label: e2, contents: t2 } : t2;
}
function ee2(e2) {
  var t2;
  if (!e2)
    return "";
  if (Array.isArray(e2)) {
    let r2 = [];
    for (let n2 of e2)
      if (Array.isArray(n2))
        r2.push(...ee2(n2));
      else {
        let o2 = ee2(n2);
        o2 !== "" && r2.push(o2);
      }
    return r2;
  }
  return e2.type === _2 ? { ...e2, breakContents: ee2(e2.breakContents), flatContents: ee2(e2.flatContents) } : e2.type === x ? { ...e2, contents: ee2(e2.contents), expandedStates: (t2 = e2.expandedStates) == null ? void 0 : t2.map(ee2) } : e2.type === S2 ? { type: "fill", parts: e2.parts.map(ee2) } : e2.contents ? { ...e2, contents: ee2(e2.contents) } : e2;
}
function Or(e2) {
  let t2 = /* @__PURE__ */ Object.create(null), r2 = /* @__PURE__ */ new Set();
  return n2(ee2(e2));
  function n2(u2, i2, s2) {
    var a2, D;
    if (typeof u2 == "string")
      return JSON.stringify(u2);
    if (Array.isArray(u2)) {
      let l2 = u2.map(n2).filter(Boolean);
      return l2.length === 1 ? l2[0] : `[${l2.join(", ")}]`;
    }
    if (u2.type === B) {
      let l2 = ((a2 = s2 == null ? void 0 : s2[i2 + 1]) == null ? void 0 : a2.type) === b2;
      return u2.literal ? l2 ? "literalline" : "literallineWithoutBreakParent" : u2.hard ? l2 ? "hardline" : "hardlineWithoutBreakParent" : u2.soft ? "softline" : "line";
    }
    if (u2.type === b2)
      return ((D = s2 == null ? void 0 : s2[i2 - 1]) == null ? void 0 : D.type) === B && s2[i2 - 1].hard ? void 0 : "breakParent";
    if (u2.type === I)
      return "trim";
    if (u2.type === L2)
      return "indent(" + n2(u2.contents) + ")";
    if (u2.type === P)
      return u2.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + n2(u2.contents) + ")" : u2.n < 0 ? "dedent(" + n2(u2.contents) + ")" : u2.n.type === "root" ? "markAsRoot(" + n2(u2.contents) + ")" : "align(" + JSON.stringify(u2.n) + ", " + n2(u2.contents) + ")";
    if (u2.type === _2)
      return "ifBreak(" + n2(u2.breakContents) + (u2.flatContents ? ", " + n2(u2.flatContents) : "") + (u2.groupId ? (u2.flatContents ? "" : ', ""') + `, { groupId: ${o2(u2.groupId)} }` : "") + ")";
    if (u2.type === R2) {
      let l2 = [];
      u2.negate && l2.push("negate: true"), u2.groupId && l2.push(`groupId: ${o2(u2.groupId)}`);
      let d2 = l2.length > 0 ? `, { ${l2.join(", ")} }` : "";
      return `indentIfBreak(${n2(u2.contents)}${d2})`;
    }
    if (u2.type === x) {
      let l2 = [];
      u2.break && u2.break !== "propagated" && l2.push("shouldBreak: true"), u2.id && l2.push(`id: ${o2(u2.id)}`);
      let d2 = l2.length > 0 ? `, { ${l2.join(", ")} }` : "";
      return u2.expandedStates ? `conditionalGroup([${u2.expandedStates.map((f2) => n2(f2)).join(",")}]${d2})` : `group(${n2(u2.contents)}${d2})`;
    }
    if (u2.type === S2)
      return `fill([${u2.parts.map((l2) => n2(l2)).join(", ")}])`;
    if (u2.type === Y)
      return "lineSuffix(" + n2(u2.contents) + ")";
    if (u2.type === j)
      return "lineSuffixBoundary";
    if (u2.type === N)
      return `label(${JSON.stringify(u2.label)}, ${n2(u2.contents)})`;
    throw new Error("Unknown doc type " + u2.type);
  }
  function o2(u2) {
    if (typeof u2 != "symbol")
      return JSON.stringify(String(u2));
    if (u2 in t2)
      return t2[u2];
    let i2 = u2.description || "symbol";
    for (let s2 = 0; ; s2++) {
      let a2 = i2 + (s2 > 0 ? ` #${s2}` : "");
      if (!r2.has(a2))
        return r2.add(a2), t2[u2] = `Symbol.for(${JSON.stringify(a2)})`;
    }
  }
}
var Yu2 = (e2, t2, r2) => {
  if (!(e2 && t2 == null))
    return Array.isArray(t2) || typeof t2 == "string" ? t2[r2 < 0 ? t2.length + r2 : r2] : t2.at(r2);
};
var y2 = Yu2;
var Sr = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
function Nr2(e2) {
  return e2 === 12288 || e2 >= 65281 && e2 <= 65376 || e2 >= 65504 && e2 <= 65510;
}
function Tr(e2) {
  return e2 >= 4352 && e2 <= 4447 || e2 === 8986 || e2 === 8987 || e2 === 9001 || e2 === 9002 || e2 >= 9193 && e2 <= 9196 || e2 === 9200 || e2 === 9203 || e2 === 9725 || e2 === 9726 || e2 === 9748 || e2 === 9749 || e2 >= 9800 && e2 <= 9811 || e2 === 9855 || e2 === 9875 || e2 === 9889 || e2 === 9898 || e2 === 9899 || e2 === 9917 || e2 === 9918 || e2 === 9924 || e2 === 9925 || e2 === 9934 || e2 === 9940 || e2 === 9962 || e2 === 9970 || e2 === 9971 || e2 === 9973 || e2 === 9978 || e2 === 9981 || e2 === 9989 || e2 === 9994 || e2 === 9995 || e2 === 10024 || e2 === 10060 || e2 === 10062 || e2 >= 10067 && e2 <= 10069 || e2 === 10071 || e2 >= 10133 && e2 <= 10135 || e2 === 10160 || e2 === 10175 || e2 === 11035 || e2 === 11036 || e2 === 11088 || e2 === 11093 || e2 >= 11904 && e2 <= 11929 || e2 >= 11931 && e2 <= 12019 || e2 >= 12032 && e2 <= 12245 || e2 >= 12272 && e2 <= 12287 || e2 >= 12289 && e2 <= 12350 || e2 >= 12353 && e2 <= 12438 || e2 >= 12441 && e2 <= 12543 || e2 >= 12549 && e2 <= 12591 || e2 >= 12593 && e2 <= 12686 || e2 >= 12688 && e2 <= 12771 || e2 >= 12783 && e2 <= 12830 || e2 >= 12832 && e2 <= 12871 || e2 >= 12880 && e2 <= 19903 || e2 >= 19968 && e2 <= 42124 || e2 >= 42128 && e2 <= 42182 || e2 >= 43360 && e2 <= 43388 || e2 >= 44032 && e2 <= 55203 || e2 >= 63744 && e2 <= 64255 || e2 >= 65040 && e2 <= 65049 || e2 >= 65072 && e2 <= 65106 || e2 >= 65108 && e2 <= 65126 || e2 >= 65128 && e2 <= 65131 || e2 >= 94176 && e2 <= 94180 || e2 === 94192 || e2 === 94193 || e2 >= 94208 && e2 <= 100343 || e2 >= 100352 && e2 <= 101589 || e2 >= 101632 && e2 <= 101640 || e2 >= 110576 && e2 <= 110579 || e2 >= 110581 && e2 <= 110587 || e2 === 110589 || e2 === 110590 || e2 >= 110592 && e2 <= 110882 || e2 === 110898 || e2 >= 110928 && e2 <= 110930 || e2 === 110933 || e2 >= 110948 && e2 <= 110951 || e2 >= 110960 && e2 <= 111355 || e2 === 126980 || e2 === 127183 || e2 === 127374 || e2 >= 127377 && e2 <= 127386 || e2 >= 127488 && e2 <= 127490 || e2 >= 127504 && e2 <= 127547 || e2 >= 127552 && e2 <= 127560 || e2 === 127568 || e2 === 127569 || e2 >= 127584 && e2 <= 127589 || e2 >= 127744 && e2 <= 127776 || e2 >= 127789 && e2 <= 127797 || e2 >= 127799 && e2 <= 127868 || e2 >= 127870 && e2 <= 127891 || e2 >= 127904 && e2 <= 127946 || e2 >= 127951 && e2 <= 127955 || e2 >= 127968 && e2 <= 127984 || e2 === 127988 || e2 >= 127992 && e2 <= 128062 || e2 === 128064 || e2 >= 128066 && e2 <= 128252 || e2 >= 128255 && e2 <= 128317 || e2 >= 128331 && e2 <= 128334 || e2 >= 128336 && e2 <= 128359 || e2 === 128378 || e2 === 128405 || e2 === 128406 || e2 === 128420 || e2 >= 128507 && e2 <= 128591 || e2 >= 128640 && e2 <= 128709 || e2 === 128716 || e2 >= 128720 && e2 <= 128722 || e2 >= 128725 && e2 <= 128727 || e2 >= 128732 && e2 <= 128735 || e2 === 128747 || e2 === 128748 || e2 >= 128756 && e2 <= 128764 || e2 >= 128992 && e2 <= 129003 || e2 === 129008 || e2 >= 129292 && e2 <= 129338 || e2 >= 129340 && e2 <= 129349 || e2 >= 129351 && e2 <= 129535 || e2 >= 129648 && e2 <= 129660 || e2 >= 129664 && e2 <= 129672 || e2 >= 129680 && e2 <= 129725 || e2 >= 129727 && e2 <= 129733 || e2 >= 129742 && e2 <= 129755 || e2 >= 129760 && e2 <= 129768 || e2 >= 129776 && e2 <= 129784 || e2 >= 131072 && e2 <= 196605 || e2 >= 196608 && e2 <= 262141;
}
var kr2 = (e2) => !(Nr2(e2) || Tr(e2));
var ju2 = /[^\x20-\x7F]/u;
function Hu2(e2) {
  if (!e2)
    return 0;
  if (!ju2.test(e2))
    return e2.length;
  e2 = e2.replace(Sr(), "  ");
  let t2 = 0;
  for (let r2 of e2) {
    let n2 = r2.codePointAt(0);
    n2 <= 31 || n2 >= 127 && n2 <= 159 || n2 >= 768 && n2 <= 879 || (t2 += kr2(n2) ? 1 : 2);
  }
  return t2;
}
var Oe2 = Hu2;
function Ne(e2, t2) {
  if (typeof e2 == "string")
    return t2(e2);
  let r2 = /* @__PURE__ */ new Map();
  return n2(e2);
  function n2(u2) {
    if (r2.has(u2))
      return r2.get(u2);
    let i2 = o2(u2);
    return r2.set(u2, i2), i2;
  }
  function o2(u2) {
    switch (G2(u2)) {
      case W:
        return t2(u2.map(n2));
      case S2:
        return t2({ ...u2, parts: u2.parts.map(n2) });
      case _2:
        return t2({ ...u2, breakContents: n2(u2.breakContents), flatContents: n2(u2.flatContents) });
      case x: {
        let { expandedStates: i2, contents: s2 } = u2;
        return i2 ? (i2 = i2.map(n2), s2 = i2[0]) : s2 = n2(s2), t2({ ...u2, contents: s2, expandedStates: i2 });
      }
      case P:
      case L2:
      case R2:
      case N:
      case Y:
        return t2({ ...u2, contents: n2(u2.contents) });
      case U:
      case z2:
      case I:
      case j:
      case B:
      case b2:
        return t2(u2);
      default:
        throw new Q2(u2);
    }
  }
}
function Xe(e2, t2, r2) {
  let n2 = r2, o2 = false;
  function u2(i2) {
    if (o2)
      return false;
    let s2 = t2(i2);
    s2 !== void 0 && (o2 = true, n2 = s2);
  }
  return we2(e2, u2), n2;
}
function Wu2(e2) {
  if (e2.type === x && e2.break || e2.type === B && e2.hard || e2.type === b2)
    return true;
}
function Ir(e2) {
  return Xe(e2, Wu2, false);
}
function Lr2(e2) {
  if (e2.length > 0) {
    let t2 = y2(false, e2, -1);
    !t2.expandedStates && !t2.break && (t2.break = "propagated");
  }
  return null;
}
function Rr(e2) {
  let t2 = /* @__PURE__ */ new Set(), r2 = [];
  function n2(u2) {
    if (u2.type === b2 && Lr2(r2), u2.type === x) {
      if (r2.push(u2), t2.has(u2))
        return false;
      t2.add(u2);
    }
  }
  function o2(u2) {
    u2.type === x && r2.pop().break && Lr2(r2);
  }
  we2(e2, n2, o2, true);
}
function Mu2(e2) {
  return e2.type === B && !e2.hard ? e2.soft ? "" : " " : e2.type === _2 ? e2.flatContents : e2;
}
function Yr2(e2) {
  return Ne(e2, Mu2);
}
function Pr(e2) {
  for (e2 = [...e2]; e2.length >= 2 && y2(false, e2, -2).type === B && y2(false, e2, -1).type === b2; )
    e2.length -= 2;
  if (e2.length > 0) {
    let t2 = Se2(y2(false, e2, -1));
    e2[e2.length - 1] = t2;
  }
  return e2;
}
function Se2(e2) {
  switch (G2(e2)) {
    case L2:
    case R2:
    case x:
    case Y:
    case N: {
      let t2 = Se2(e2.contents);
      return { ...e2, contents: t2 };
    }
    case _2:
      return { ...e2, breakContents: Se2(e2.breakContents), flatContents: Se2(e2.flatContents) };
    case S2:
      return { ...e2, parts: Pr(e2.parts) };
    case W:
      return Pr(e2);
    case U:
      return e2.replace(/[\n\r]*$/u, "");
    case P:
    case z2:
    case I:
    case j:
    case B:
    case b2:
      break;
    default:
      throw new Q2(e2);
  }
  return e2;
}
function Ze(e2) {
  return Se2(Vu2(e2));
}
function $u2(e2) {
  switch (G2(e2)) {
    case S2:
      if (e2.parts.every((t2) => t2 === ""))
        return "";
      break;
    case x:
      if (!e2.contents && !e2.id && !e2.break && !e2.expandedStates)
        return "";
      if (e2.contents.type === x && e2.contents.id === e2.id && e2.contents.break === e2.break && e2.contents.expandedStates === e2.expandedStates)
        return e2.contents;
      break;
    case P:
    case L2:
    case R2:
    case Y:
      if (!e2.contents)
        return "";
      break;
    case _2:
      if (!e2.flatContents && !e2.breakContents)
        return "";
      break;
    case W: {
      let t2 = [];
      for (let r2 of e2) {
        if (!r2)
          continue;
        let [n2, ...o2] = Array.isArray(r2) ? r2 : [r2];
        typeof n2 == "string" && typeof y2(false, t2, -1) == "string" ? t2[t2.length - 1] += n2 : t2.push(n2), t2.push(...o2);
      }
      return t2.length === 0 ? "" : t2.length === 1 ? t2[0] : t2;
    }
    case U:
    case z2:
    case I:
    case j:
    case B:
    case N:
    case b2:
      break;
    default:
      throw new Q2(e2);
  }
  return e2;
}
function Vu2(e2) {
  return Ne(e2, (t2) => $u2(t2));
}
function jr2(e2, t2 = qe) {
  return Ne(e2, (r2) => typeof r2 == "string" ? be2(t2, r2.split(`
`)) : r2);
}
function Uu2(e2) {
  if (e2.type === B)
    return true;
}
function Hr2(e2) {
  return Xe(e2, Uu2, false);
}
function Qe2(e2, t2) {
  return e2.type === N ? { ...e2, contents: t2(e2.contents) } : t2(e2);
}
var H2 = Symbol("MODE_BREAK");
var J2 = Symbol("MODE_FLAT");
var Te = Symbol("cursor");
function Wr() {
  return { value: "", length: 0, queue: [] };
}
function zu2(e2, t2) {
  return bt(e2, { type: "indent" }, t2);
}
function Gu2(e2, t2, r2) {
  return t2 === Number.NEGATIVE_INFINITY ? e2.root || Wr() : t2 < 0 ? bt(e2, { type: "dedent" }, r2) : t2 ? t2.type === "root" ? { ...e2, root: e2 } : bt(e2, { type: typeof t2 == "string" ? "stringAlign" : "numberAlign", n: t2 }, r2) : e2;
}
function bt(e2, t2, r2) {
  let n2 = t2.type === "dedent" ? e2.queue.slice(0, -1) : [...e2.queue, t2], o2 = "", u2 = 0, i2 = 0, s2 = 0;
  for (let c2 of n2)
    switch (c2.type) {
      case "indent":
        l2(), r2.useTabs ? a2(1) : D(r2.tabWidth);
        break;
      case "stringAlign":
        l2(), o2 += c2.n, u2 += c2.n.length;
        break;
      case "numberAlign":
        i2 += 1, s2 += c2.n;
        break;
      default:
        throw new Error(`Unexpected type '${c2.type}'`);
    }
  return f2(), { ...e2, value: o2, length: u2, queue: n2 };
  function a2(c2) {
    o2 += "	".repeat(c2), u2 += r2.tabWidth * c2;
  }
  function D(c2) {
    o2 += " ".repeat(c2), u2 += c2;
  }
  function l2() {
    r2.useTabs ? d2() : f2();
  }
  function d2() {
    i2 > 0 && a2(i2), p2();
  }
  function f2() {
    s2 > 0 && D(s2), p2();
  }
  function p2() {
    i2 = 0, s2 = 0;
  }
}
function Ot(e2) {
  let t2 = 0, r2 = 0, n2 = e2.length;
  e:
    for (; n2--; ) {
      let o2 = e2[n2];
      if (o2 === Te) {
        r2++;
        continue;
      }
      for (let u2 = o2.length - 1; u2 >= 0; u2--) {
        let i2 = o2[u2];
        if (i2 === " " || i2 === "	")
          t2++;
        else {
          e2[n2] = o2.slice(0, u2 + 1);
          break e;
        }
      }
    }
  if (t2 > 0 || r2 > 0)
    for (e2.length = n2 + 1; r2-- > 0; )
      e2.push(Te);
  return t2;
}
function et(e2, t2, r2, n2, o2, u2) {
  if (r2 === Number.POSITIVE_INFINITY)
    return true;
  let i2 = t2.length, s2 = [e2], a2 = [];
  for (; r2 >= 0; ) {
    if (s2.length === 0) {
      if (i2 === 0)
        return true;
      s2.push(t2[--i2]);
      continue;
    }
    let { mode: D, doc: l2 } = s2.pop(), d2 = G2(l2);
    switch (d2) {
      case U:
        a2.push(l2), r2 -= Oe2(l2);
        break;
      case W:
      case S2: {
        let f2 = d2 === W ? l2 : l2.parts;
        for (let p2 = f2.length - 1; p2 >= 0; p2--)
          s2.push({ mode: D, doc: f2[p2] });
        break;
      }
      case L2:
      case P:
      case R2:
      case N:
        s2.push({ mode: D, doc: l2.contents });
        break;
      case I:
        r2 += Ot(a2);
        break;
      case x: {
        if (u2 && l2.break)
          return false;
        let f2 = l2.break ? H2 : D, p2 = l2.expandedStates && f2 === H2 ? y2(false, l2.expandedStates, -1) : l2.contents;
        s2.push({ mode: f2, doc: p2 });
        break;
      }
      case _2: {
        let p2 = (l2.groupId ? o2[l2.groupId] || J2 : D) === H2 ? l2.breakContents : l2.flatContents;
        p2 && s2.push({ mode: D, doc: p2 });
        break;
      }
      case B:
        if (D === H2 || l2.hard)
          return true;
        l2.soft || (a2.push(" "), r2--);
        break;
      case Y:
        n2 = true;
        break;
      case j:
        if (n2)
          return false;
        break;
    }
  }
  return false;
}
function Fe2(e2, t2) {
  let r2 = {}, n2 = t2.printWidth, o2 = Be2(t2.endOfLine), u2 = 0, i2 = [{ ind: Wr(), mode: H2, doc: e2 }], s2 = [], a2 = false, D = [], l2 = 0;
  for (Rr(e2); i2.length > 0; ) {
    let { ind: f2, mode: p2, doc: c2 } = i2.pop();
    switch (G2(c2)) {
      case U: {
        let F = o2 !== `
` ? ne2(false, c2, `
`, o2) : c2;
        s2.push(F), i2.length > 0 && (u2 += Oe2(F));
        break;
      }
      case W:
        for (let F = c2.length - 1; F >= 0; F--)
          i2.push({ ind: f2, mode: p2, doc: c2[F] });
        break;
      case z2:
        if (l2 >= 2)
          throw new Error("There are too many 'cursor' in doc.");
        s2.push(Te), l2++;
        break;
      case L2:
        i2.push({ ind: zu2(f2, t2), mode: p2, doc: c2.contents });
        break;
      case P:
        i2.push({ ind: Gu2(f2, c2.n, t2), mode: p2, doc: c2.contents });
        break;
      case I:
        u2 -= Ot(s2);
        break;
      case x:
        switch (p2) {
          case J2:
            if (!a2) {
              i2.push({ ind: f2, mode: c2.break ? H2 : J2, doc: c2.contents });
              break;
            }
          case H2: {
            a2 = false;
            let F = { ind: f2, mode: J2, doc: c2.contents }, m = n2 - u2, E2 = D.length > 0;
            if (!c2.break && et(F, i2, m, E2, r2))
              i2.push(F);
            else if (c2.expandedStates) {
              let A = y2(false, c2.expandedStates, -1);
              if (c2.break) {
                i2.push({ ind: f2, mode: H2, doc: A });
                break;
              } else
                for (let w2 = 1; w2 < c2.expandedStates.length + 1; w2++)
                  if (w2 >= c2.expandedStates.length) {
                    i2.push({ ind: f2, mode: H2, doc: A });
                    break;
                  } else {
                    let h2 = c2.expandedStates[w2], C = { ind: f2, mode: J2, doc: h2 };
                    if (et(C, i2, m, E2, r2)) {
                      i2.push(C);
                      break;
                    }
                  }
            } else
              i2.push({ ind: f2, mode: H2, doc: c2.contents });
            break;
          }
        }
        c2.id && (r2[c2.id] = y2(false, i2, -1).mode);
        break;
      case S2: {
        let F = n2 - u2, { parts: m } = c2;
        if (m.length === 0)
          break;
        let [E2, A] = m, w2 = { ind: f2, mode: J2, doc: E2 }, h2 = { ind: f2, mode: H2, doc: E2 }, C = et(w2, [], F, D.length > 0, r2, true);
        if (m.length === 1) {
          C ? i2.push(w2) : i2.push(h2);
          break;
        }
        let k = { ind: f2, mode: J2, doc: A }, v2 = { ind: f2, mode: H2, doc: A };
        if (m.length === 2) {
          C ? i2.push(k, w2) : i2.push(v2, h2);
          break;
        }
        m.splice(0, 2);
        let $2 = { ind: f2, mode: p2, doc: Ge2(m) }, ye = m[0];
        et({ ind: f2, mode: J2, doc: [E2, A, ye] }, [], F, D.length > 0, r2, true) ? i2.push($2, k, w2) : C ? i2.push($2, v2, w2) : i2.push($2, v2, h2);
        break;
      }
      case _2:
      case R2: {
        let F = c2.groupId ? r2[c2.groupId] : p2;
        if (F === H2) {
          let m = c2.type === _2 ? c2.breakContents : c2.negate ? c2.contents : De2(c2.contents);
          m && i2.push({ ind: f2, mode: p2, doc: m });
        }
        if (F === J2) {
          let m = c2.type === _2 ? c2.flatContents : c2.negate ? De2(c2.contents) : c2.contents;
          m && i2.push({ ind: f2, mode: p2, doc: m });
        }
        break;
      }
      case Y:
        D.push({ ind: f2, mode: p2, doc: c2.contents });
        break;
      case j:
        D.length > 0 && i2.push({ ind: f2, mode: p2, doc: _e2 });
        break;
      case B:
        switch (p2) {
          case J2:
            if (c2.hard)
              a2 = true;
            else {
              c2.soft || (s2.push(" "), u2 += 1);
              break;
            }
          case H2:
            if (D.length > 0) {
              i2.push({ ind: f2, mode: p2, doc: c2 }, ...D.reverse()), D.length = 0;
              break;
            }
            c2.literal ? f2.root ? (s2.push(o2, f2.root.value), u2 = f2.root.length) : (s2.push(o2), u2 = 0) : (u2 -= Ot(s2), s2.push(o2 + f2.value), u2 = f2.length);
            break;
        }
        break;
      case N:
        i2.push({ ind: f2, mode: p2, doc: c2.contents });
        break;
      case b2:
        break;
      default:
        throw new Q2(c2);
    }
    i2.length === 0 && D.length > 0 && (i2.push(...D.reverse()), D.length = 0);
  }
  let d2 = s2.indexOf(Te);
  if (d2 !== -1) {
    let f2 = s2.indexOf(Te, d2 + 1), p2 = s2.slice(0, d2).join(""), c2 = s2.slice(d2 + 1, f2).join(""), F = s2.slice(f2 + 1).join("");
    return { formatted: p2 + c2 + F, cursorNodeStart: p2.length, cursorNodeText: c2 };
  }
  return { formatted: s2.join("") };
}
function Ku2(e2, t2, r2 = 0) {
  let n2 = 0;
  for (let o2 = r2; o2 < e2.length; ++o2)
    e2[o2] === "	" ? n2 = n2 + t2 - n2 % t2 : n2++;
  return n2;
}
var me = Ku2;
var te;
var Nt;
var tt;
var St2 = class {
  constructor(t2) {
    Dr(this, te);
    this.stack = [t2];
  }
  get key() {
    let { stack: t2, siblings: r2 } = this;
    return y2(false, t2, r2 === null ? -2 : -4) ?? null;
  }
  get index() {
    return this.siblings === null ? null : y2(false, this.stack, -2);
  }
  get node() {
    return y2(false, this.stack, -1);
  }
  get parent() {
    return this.getNode(1);
  }
  get grandparent() {
    return this.getNode(2);
  }
  get isInArray() {
    return this.siblings !== null;
  }
  get siblings() {
    let { stack: t2 } = this, r2 = y2(false, t2, -3);
    return Array.isArray(r2) ? r2 : null;
  }
  get next() {
    let { siblings: t2 } = this;
    return t2 === null ? null : t2[this.index + 1];
  }
  get previous() {
    let { siblings: t2 } = this;
    return t2 === null ? null : t2[this.index - 1];
  }
  get isFirst() {
    return this.index === 0;
  }
  get isLast() {
    let { siblings: t2, index: r2 } = this;
    return t2 !== null && r2 === t2.length - 1;
  }
  get isRoot() {
    return this.stack.length === 1;
  }
  get root() {
    return this.stack[0];
  }
  get ancestors() {
    return [...pe(this, te, tt).call(this)];
  }
  getName() {
    let { stack: t2 } = this, { length: r2 } = t2;
    return r2 > 1 ? y2(false, t2, -2) : null;
  }
  getValue() {
    return y2(false, this.stack, -1);
  }
  getNode(t2 = 0) {
    let r2 = pe(this, te, Nt).call(this, t2);
    return r2 === -1 ? null : this.stack[r2];
  }
  getParentNode(t2 = 0) {
    return this.getNode(t2 + 1);
  }
  call(t2, ...r2) {
    let { stack: n2 } = this, { length: o2 } = n2, u2 = y2(false, n2, -1);
    for (let i2 of r2)
      u2 = u2[i2], n2.push(i2, u2);
    try {
      return t2(this);
    } finally {
      n2.length = o2;
    }
  }
  callParent(t2, r2 = 0) {
    let n2 = pe(this, te, Nt).call(this, r2 + 1), o2 = this.stack.splice(n2 + 1);
    try {
      return t2(this);
    } finally {
      this.stack.push(...o2);
    }
  }
  each(t2, ...r2) {
    let { stack: n2 } = this, { length: o2 } = n2, u2 = y2(false, n2, -1);
    for (let i2 of r2)
      u2 = u2[i2], n2.push(i2, u2);
    try {
      for (let i2 = 0; i2 < u2.length; ++i2)
        n2.push(i2, u2[i2]), t2(this, i2, u2), n2.length -= 2;
    } finally {
      n2.length = o2;
    }
  }
  map(t2, ...r2) {
    let n2 = [];
    return this.each((o2, u2, i2) => {
      n2[u2] = t2(o2, u2, i2);
    }, ...r2), n2;
  }
  match(...t2) {
    let r2 = this.stack.length - 1, n2 = null, o2 = this.stack[r2--];
    for (let u2 of t2) {
      if (o2 === void 0)
        return false;
      let i2 = null;
      if (typeof n2 == "number" && (i2 = n2, n2 = this.stack[r2--], o2 = this.stack[r2--]), u2 && !u2(o2, n2, i2))
        return false;
      n2 = this.stack[r2--], o2 = this.stack[r2--];
    }
    return true;
  }
  findAncestor(t2) {
    for (let r2 of pe(this, te, tt).call(this))
      if (t2(r2))
        return r2;
  }
  hasAncestor(t2) {
    for (let r2 of pe(this, te, tt).call(this))
      if (t2(r2))
        return true;
    return false;
  }
};
te = /* @__PURE__ */ new WeakSet(), Nt = function(t2) {
  let { stack: r2 } = this;
  for (let n2 = r2.length - 1; n2 >= 0; n2 -= 2)
    if (!Array.isArray(r2[n2]) && --t2 < 0)
      return n2;
  return -1;
}, tt = function* () {
  let { stack: t2 } = this;
  for (let r2 = t2.length - 3; r2 >= 0; r2 -= 2) {
    let n2 = t2[r2];
    Array.isArray(n2) || (yield n2);
  }
};
var Mr = St2;
var $r2 = new Proxy(() => {
}, { get: () => $r2 });
var ke2 = $r2;
function qu2(e2) {
  return e2 !== null && typeof e2 == "object";
}
var Vr = qu2;
function* Tt(e2, t2) {
  let { getVisitorKeys: r2, filter: n2 = () => true } = t2, o2 = (u2) => Vr(u2) && n2(u2);
  for (let u2 of r2(e2)) {
    let i2 = e2[u2];
    if (Array.isArray(i2))
      for (let s2 of i2)
        o2(s2) && (yield s2);
    else
      o2(i2) && (yield i2);
  }
}
function* Ur(e2, t2) {
  let r2 = [e2];
  for (let n2 = 0; n2 < r2.length; n2++) {
    let o2 = r2[n2];
    for (let u2 of Tt(o2, t2))
      yield u2, r2.push(u2);
  }
}
function Ee(e2) {
  return (t2, r2, n2) => {
    let o2 = !!(n2 != null && n2.backwards);
    if (r2 === false)
      return false;
    let { length: u2 } = t2, i2 = r2;
    for (; i2 >= 0 && i2 < u2; ) {
      let s2 = t2.charAt(i2);
      if (e2 instanceof RegExp) {
        if (!e2.test(s2))
          return i2;
      } else if (!e2.includes(s2))
        return i2;
      o2 ? i2-- : i2++;
    }
    return i2 === -1 || i2 === u2 ? i2 : false;
  };
}
var zr = Ee(/\s/u);
var T2 = Ee(" 	");
var rt2 = Ee(",; 	");
var nt2 = Ee(/[^\n\r]/u);
function Ju2(e2, t2, r2) {
  let n2 = !!(r2 != null && r2.backwards);
  if (t2 === false)
    return false;
  let o2 = e2.charAt(t2);
  if (n2) {
    if (e2.charAt(t2 - 1) === "\r" && o2 === `
`)
      return t2 - 2;
    if (o2 === `
` || o2 === "\r" || o2 === "\u2028" || o2 === "\u2029")
      return t2 - 1;
  } else {
    if (o2 === "\r" && e2.charAt(t2 + 1) === `
`)
      return t2 + 2;
    if (o2 === `
` || o2 === "\r" || o2 === "\u2028" || o2 === "\u2029")
      return t2 + 1;
  }
  return t2;
}
var M2 = Ju2;
function Xu2(e2, t2, r2 = {}) {
  let n2 = T2(e2, r2.backwards ? t2 - 1 : t2, r2), o2 = M2(e2, n2, r2);
  return n2 !== o2;
}
var V = Xu2;
function Zu2(e2) {
  return Array.isArray(e2) && e2.length > 0;
}
var kt2 = Zu2;
var Gr2 = /* @__PURE__ */ new Set(["tokens", "comments", "parent", "enclosingNode", "precedingNode", "followingNode"]);
var Qu2 = (e2) => Object.keys(e2).filter((t2) => !Gr2.has(t2));
function eo(e2) {
  return e2 ? (t2) => e2(t2, Gr2) : Qu2;
}
var X2 = eo;
function to(e2) {
  let t2 = e2.type || e2.kind || "(unknown type)", r2 = String(e2.name || e2.id && (typeof e2.id == "object" ? e2.id.name : e2.id) || e2.key && (typeof e2.key == "object" ? e2.key.name : e2.key) || e2.value && (typeof e2.value == "object" ? "" : String(e2.value)) || e2.operator || "");
  return r2.length > 20 && (r2 = r2.slice(0, 19) + "…"), t2 + (r2 ? " " + r2 : "");
}
function Lt(e2, t2) {
  (e2.comments ?? (e2.comments = [])).push(t2), t2.printed = false, t2.nodeDescription = to(e2);
}
function ue(e2, t2) {
  t2.leading = true, t2.trailing = false, Lt(e2, t2);
}
function re2(e2, t2, r2) {
  t2.leading = false, t2.trailing = false, r2 && (t2.marker = r2), Lt(e2, t2);
}
function oe2(e2, t2) {
  t2.leading = false, t2.trailing = true, Lt(e2, t2);
}
var Pt = /* @__PURE__ */ new WeakMap();
function ut2(e2, t2) {
  if (Pt.has(e2))
    return Pt.get(e2);
  let { printer: { getCommentChildNodes: r2, canAttachComment: n2, getVisitorKeys: o2 }, locStart: u2, locEnd: i2 } = t2;
  if (!n2)
    return [];
  let s2 = ((r2 == null ? void 0 : r2(e2, t2)) ?? [...Tt(e2, { getVisitorKeys: X2(o2) })]).flatMap((a2) => n2(a2) ? [a2] : ut2(a2, t2));
  return s2.sort((a2, D) => u2(a2) - u2(D) || i2(a2) - i2(D)), Pt.set(e2, s2), s2;
}
function qr(e2, t2, r2, n2) {
  let { locStart: o2, locEnd: u2 } = r2, i2 = o2(t2), s2 = u2(t2), a2 = ut2(e2, r2), D, l2, d2 = 0, f2 = a2.length;
  for (; d2 < f2; ) {
    let p2 = d2 + f2 >> 1, c2 = a2[p2], F = o2(c2), m = u2(c2);
    if (F <= i2 && s2 <= m)
      return qr(c2, t2, r2, c2);
    if (m <= i2) {
      D = c2, d2 = p2 + 1;
      continue;
    }
    if (s2 <= F) {
      l2 = c2, f2 = p2;
      continue;
    }
    throw new Error("Comment location overlaps with node location");
  }
  if ((n2 == null ? void 0 : n2.type) === "TemplateLiteral") {
    let { quasis: p2 } = n2, c2 = Rt(p2, t2, r2);
    D && Rt(p2, D, r2) !== c2 && (D = null), l2 && Rt(p2, l2, r2) !== c2 && (l2 = null);
  }
  return { enclosingNode: n2, precedingNode: D, followingNode: l2 };
}
var It = () => false;
function Jr(e2, t2) {
  let { comments: r2 } = e2;
  if (delete e2.comments, !kt2(r2) || !t2.printer.canAttachComment)
    return;
  let n2 = [], { locStart: o2, locEnd: u2, printer: { experimentalFeatures: { avoidAstMutation: i2 = false } = {}, handleComments: s2 = {} }, originalText: a2 } = t2, { ownLine: D = It, endOfLine: l2 = It, remaining: d2 = It } = s2, f2 = r2.map((p2, c2) => ({ ...qr(e2, p2, t2), comment: p2, text: a2, options: t2, ast: e2, isLastComment: r2.length - 1 === c2 }));
  for (let [p2, c2] of f2.entries()) {
    let { comment: F, precedingNode: m, enclosingNode: E2, followingNode: A, text: w2, options: h2, ast: C, isLastComment: k } = c2;
    if (h2.parser === "json" || h2.parser === "json5" || h2.parser === "jsonc" || h2.parser === "__js_expression" || h2.parser === "__ts_expression" || h2.parser === "__vue_expression" || h2.parser === "__vue_ts_expression") {
      if (o2(F) - o2(C) <= 0) {
        ue(C, F);
        continue;
      }
      if (u2(F) - u2(C) >= 0) {
        oe2(C, F);
        continue;
      }
    }
    let v2;
    if (i2 ? v2 = [c2] : (F.enclosingNode = E2, F.precedingNode = m, F.followingNode = A, v2 = [F, w2, h2, C, k]), ro(w2, h2, f2, p2))
      F.placement = "ownLine", D(...v2) || (A ? ue(A, F) : m ? oe2(m, F) : E2 ? re2(E2, F) : re2(C, F));
    else if (no(w2, h2, f2, p2))
      F.placement = "endOfLine", l2(...v2) || (m ? oe2(m, F) : A ? ue(A, F) : E2 ? re2(E2, F) : re2(C, F));
    else if (F.placement = "remaining", !d2(...v2))
      if (m && A) {
        let $2 = n2.length;
        $2 > 0 && n2[$2 - 1].followingNode !== A && Kr(n2, h2), n2.push(c2);
      } else
        m ? oe2(m, F) : A ? ue(A, F) : E2 ? re2(E2, F) : re2(C, F);
  }
  if (Kr(n2, t2), !i2)
    for (let p2 of r2)
      delete p2.precedingNode, delete p2.enclosingNode, delete p2.followingNode;
}
var Xr = (e2) => !/[\S\n\u2028\u2029]/u.test(e2);
function ro(e2, t2, r2, n2) {
  let { comment: o2, precedingNode: u2 } = r2[n2], { locStart: i2, locEnd: s2 } = t2, a2 = i2(o2);
  if (u2)
    for (let D = n2 - 1; D >= 0; D--) {
      let { comment: l2, precedingNode: d2 } = r2[D];
      if (d2 !== u2 || !Xr(e2.slice(s2(l2), a2)))
        break;
      a2 = i2(l2);
    }
  return V(e2, a2, { backwards: true });
}
function no(e2, t2, r2, n2) {
  let { comment: o2, followingNode: u2 } = r2[n2], { locStart: i2, locEnd: s2 } = t2, a2 = s2(o2);
  if (u2)
    for (let D = n2 + 1; D < r2.length; D++) {
      let { comment: l2, followingNode: d2 } = r2[D];
      if (d2 !== u2 || !Xr(e2.slice(a2, i2(l2))))
        break;
      a2 = s2(l2);
    }
  return V(e2, a2);
}
function Kr(e2, t2) {
  var s2, a2;
  let r2 = e2.length;
  if (r2 === 0)
    return;
  let { precedingNode: n2, followingNode: o2 } = e2[0], u2 = t2.locStart(o2), i2;
  for (i2 = r2; i2 > 0; --i2) {
    let { comment: D, precedingNode: l2, followingNode: d2 } = e2[i2 - 1];
    ke2.strictEqual(l2, n2), ke2.strictEqual(d2, o2);
    let f2 = t2.originalText.slice(t2.locEnd(D), u2);
    if (((a2 = (s2 = t2.printer).isGap) == null ? void 0 : a2.call(s2, f2, t2)) ?? /^[\s(]*$/u.test(f2))
      u2 = t2.locStart(D);
    else
      break;
  }
  for (let [D, { comment: l2 }] of e2.entries())
    D < i2 ? oe2(n2, l2) : ue(o2, l2);
  for (let D of [n2, o2])
    D.comments && D.comments.length > 1 && D.comments.sort((l2, d2) => t2.locStart(l2) - t2.locStart(d2));
  e2.length = 0;
}
function Rt(e2, t2, r2) {
  let n2 = r2.locStart(t2) - 1;
  for (let o2 = 1; o2 < e2.length; ++o2)
    if (n2 < r2.locStart(e2[o2]))
      return o2 - 1;
  return 0;
}
function uo(e2, t2) {
  let r2 = t2 - 1;
  r2 = T2(e2, r2, { backwards: true }), r2 = M2(e2, r2, { backwards: true }), r2 = T2(e2, r2, { backwards: true });
  let n2 = M2(e2, r2, { backwards: true });
  return r2 !== n2;
}
var Le2 = uo;
function Zr(e2, t2) {
  let r2 = e2.node;
  return r2.printed = true, t2.printer.printComment(e2, t2);
}
function oo(e2, t2) {
  var l2;
  let r2 = e2.node, n2 = [Zr(e2, t2)], { printer: o2, originalText: u2, locStart: i2, locEnd: s2 } = t2;
  if ((l2 = o2.isBlockComment) == null ? void 0 : l2.call(o2, r2)) {
    let d2 = V(u2, s2(r2)) ? V(u2, i2(r2), { backwards: true }) ? q : Ke2 : " ";
    n2.push(d2);
  } else
    n2.push(q);
  let D = M2(u2, T2(u2, s2(r2)));
  return D !== false && V(u2, D) && n2.push(q), n2;
}
function io(e2, t2, r2) {
  var D;
  let n2 = e2.node, o2 = Zr(e2, t2), { printer: u2, originalText: i2, locStart: s2 } = t2, a2 = (D = u2.isBlockComment) == null ? void 0 : D.call(u2, n2);
  if (r2 != null && r2.hasLineSuffix && !(r2 != null && r2.isBlock) || V(i2, s2(n2), { backwards: true })) {
    let l2 = Le2(i2, s2(n2));
    return { doc: xe2([q, l2 ? q : "", o2]), isBlock: a2, hasLineSuffix: true };
  }
  return !a2 || r2 != null && r2.hasLineSuffix ? { doc: [xe2([" ", o2]), de], isBlock: a2, hasLineSuffix: true } : { doc: [" ", o2], isBlock: a2, hasLineSuffix: false };
}
function so(e2, t2) {
  let r2 = e2.node;
  if (!r2)
    return {};
  let n2 = t2[Symbol.for("printedComments")];
  if ((r2.comments || []).filter((a2) => !n2.has(a2)).length === 0)
    return { leading: "", trailing: "" };
  let u2 = [], i2 = [], s2;
  return e2.each(() => {
    let a2 = e2.node;
    if (n2 != null && n2.has(a2))
      return;
    let { leading: D, trailing: l2 } = a2;
    D ? u2.push(oo(e2, t2)) : l2 && (s2 = io(e2, t2, s2), i2.push(s2.doc));
  }, "comments"), { leading: u2, trailing: i2 };
}
function Qr(e2, t2, r2) {
  let { leading: n2, trailing: o2 } = so(e2, r2);
  return !n2 && !o2 ? t2 : Qe2(t2, (u2) => [n2, u2, o2]);
}
function en2(e2) {
  let { [Symbol.for("comments")]: t2, [Symbol.for("printedComments")]: r2 } = e2;
  for (let n2 of t2) {
    if (!n2.printed && !r2.has(n2))
      throw new Error('Comment "' + n2.value.trim() + '" was not printed. Please report this error!');
    delete n2.printed;
  }
}
function ao(e2) {
  return () => {
  };
}
var tn2 = ao;
var Pe2 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "ConfigError");
  }
};
var Ie2 = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "UndefinedParserError");
  }
};
var rn2 = { cursorOffset: { category: "Special", type: "int", default: -1, range: { start: -1, end: 1 / 0, step: 1 }, description: "Print (to stderr) where a cursor at the given position would move to after formatting.", cliCategory: "Editor" }, endOfLine: { category: "Global", type: "choice", default: "lf", description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: `Maintain existing
(mixed values within one file are normalised by looking at what's used after the first line)` }] }, filepath: { category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { category: "Special", type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other" }, parser: { category: "Global", type: "choice", default: void 0, description: "Which parser to use.", exception: (e2) => typeof e2 == "string" || typeof e2 == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", description: "JavaScript" }, { value: "babel-flow", description: "Flow" }, { value: "babel-ts", description: "TypeScript" }, { value: "typescript", description: "TypeScript" }, { value: "acorn", description: "JavaScript" }, { value: "espree", description: "JavaScript" }, { value: "meriyah", description: "JavaScript" }, { value: "css", description: "CSS" }, { value: "less", description: "Less" }, { value: "scss", description: "SCSS" }, { value: "json", description: "JSON" }, { value: "json5", description: "JSON5" }, { value: "jsonc", description: "JSON with Comments" }, { value: "json-stringify", description: "JSON.stringify" }, { value: "graphql", description: "GraphQL" }, { value: "markdown", description: "Markdown" }, { value: "mdx", description: "MDX" }, { value: "vue", description: "Vue" }, { value: "yaml", description: "YAML" }, { value: "glimmer", description: "Ember / Handlebars" }, { value: "html", description: "HTML" }, { value: "angular", description: "Angular" }, { value: "lwc", description: "Lightning Web Components" }] }, plugins: { type: "path", array: true, default: [{ value: [] }], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e2) => typeof e2 == "string" || typeof e2 == "object", cliName: "plugin", cliCategory: "Config" }, printWidth: { category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: 1 / 0, step: 1 } }, rangeEnd: { category: "Special", type: "int", default: 1 / 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code ending at a given character offset (exclusive).
The range will extend forwards to the end of the selected statement.`, cliCategory: "Editor" }, rangeStart: { category: "Special", type: "int", default: 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code starting at a given character offset.
The range will extend backwards to the start of the first line containing the selected statement.`, cliCategory: "Editor" }, requirePragma: { category: "Special", type: "boolean", default: false, description: `Require either '@prettier' or '@format' to be present in the file's first docblock comment
in order for it to be formatted.`, cliCategory: "Other" }, tabWidth: { type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: 1 / 0, step: 1 } }, useTabs: { category: "Global", type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { category: "Global", type: "choice", default: "auto", description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
function ot2({ plugins: e2 = [], showDeprecated: t2 = false } = {}) {
  let r2 = e2.flatMap((o2) => o2.languages ?? []), n2 = [];
  for (let o2 of lo(Object.assign({}, ...e2.map(({ options: u2 }) => u2), rn2)))
    !t2 && o2.deprecated || (Array.isArray(o2.choices) && (t2 || (o2.choices = o2.choices.filter((u2) => !u2.deprecated)), o2.name === "parser" && (o2.choices = [...o2.choices, ...Do(o2.choices, r2, e2)])), o2.pluginDefaults = Object.fromEntries(e2.filter((u2) => {
      var i2;
      return ((i2 = u2.defaultOptions) == null ? void 0 : i2[o2.name]) !== void 0;
    }).map((u2) => [u2.name, u2.defaultOptions[o2.name]])), n2.push(o2));
  return { languages: r2, options: n2 };
}
function* Do(e2, t2, r2) {
  let n2 = new Set(e2.map((o2) => o2.value));
  for (let o2 of t2)
    if (o2.parsers) {
      for (let u2 of o2.parsers)
        if (!n2.has(u2)) {
          n2.add(u2);
          let i2 = r2.find((a2) => a2.parsers && Object.prototype.hasOwnProperty.call(a2.parsers, u2)), s2 = o2.name;
          i2 != null && i2.name && (s2 += ` (plugin: ${i2.name})`), yield { value: u2, description: s2 };
        }
    }
}
function lo(e2) {
  let t2 = [];
  for (let [r2, n2] of Object.entries(e2)) {
    let o2 = { name: r2, ...n2 };
    Array.isArray(o2.default) && (o2.default = y2(false, o2.default, -1).value), t2.push(o2);
  }
  return t2;
}
var co = (e2) => String(e2).split(/[/\\]/u).pop();
function nn2(e2, t2) {
  if (!t2)
    return;
  let r2 = co(t2).toLowerCase();
  return e2.find(({ filenames: n2 }) => n2 == null ? void 0 : n2.some((o2) => o2.toLowerCase() === r2)) ?? e2.find(({ extensions: n2 }) => n2 == null ? void 0 : n2.some((o2) => r2.endsWith(o2)));
}
function fo(e2, t2) {
  if (t2)
    return e2.find(({ name: r2 }) => r2.toLowerCase() === t2) ?? e2.find(({ aliases: r2 }) => r2 == null ? void 0 : r2.includes(t2)) ?? e2.find(({ extensions: r2 }) => r2 == null ? void 0 : r2.includes(`.${t2}`));
}
function po(e2, t2) {
  let r2 = e2.plugins.flatMap((o2) => o2.languages ?? []), n2 = fo(r2, t2.language) ?? nn2(r2, t2.physicalFile) ?? nn2(r2, t2.file) ?? (t2.physicalFile, void 0);
  return n2 == null ? void 0 : n2.parsers[0];
}
var un2 = po;
var ie = { key: (e2) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e2) ? e2 : JSON.stringify(e2), value(e2) {
  if (e2 === null || typeof e2 != "object")
    return JSON.stringify(e2);
  if (Array.isArray(e2))
    return `[${e2.map((r2) => ie.value(r2)).join(", ")}]`;
  let t2 = Object.keys(e2);
  return t2.length === 0 ? "{}" : `{ ${t2.map((r2) => `${ie.key(r2)}: ${ie.value(e2[r2])}`).join(", ")} }`;
}, pair: ({ key: e2, value: t2 }) => ie.value({ [e2]: t2 }) };
var Yt = Me2(it2(), 1);
var an2 = (e2, t2, { descriptor: r2 }) => {
  let n2 = [`${Yt.default.yellow(typeof e2 == "string" ? r2.key(e2) : r2.pair(e2))} is deprecated`];
  return t2 && n2.push(`we now treat it as ${Yt.default.blue(typeof t2 == "string" ? r2.key(t2) : r2.pair(t2))}`), n2.join("; ") + ".";
};
var le = Me2(it2(), 1);
var st2 = Symbol.for("vnopts.VALUE_NOT_EXIST");
var he2 = Symbol.for("vnopts.VALUE_UNCHANGED");
var Dn = " ".repeat(2);
var cn2 = (e2, t2, r2) => {
  let { text: n2, list: o2 } = r2.normalizeExpectedResult(r2.schemas[e2].expected(r2)), u2 = [];
  return n2 && u2.push(ln2(e2, t2, n2, r2.descriptor)), o2 && u2.push([ln2(e2, t2, o2.title, r2.descriptor)].concat(o2.values.map((i2) => fn2(i2, r2.loggerPrintWidth))).join(`
`)), pn2(u2, r2.loggerPrintWidth);
};
function ln2(e2, t2, r2, n2) {
  return [`Invalid ${le.default.red(n2.key(e2))} value.`, `Expected ${le.default.blue(r2)},`, `but received ${t2 === st2 ? le.default.gray("nothing") : le.default.red(n2.value(t2))}.`].join(" ");
}
function fn2({ text: e2, list: t2 }, r2) {
  let n2 = [];
  return e2 && n2.push(`- ${le.default.blue(e2)}`), t2 && n2.push([`- ${le.default.blue(t2.title)}:`].concat(t2.values.map((o2) => fn2(o2, r2 - Dn.length).replace(/^|\n/g, `$&${Dn}`))).join(`
`)), pn2(n2, r2);
}
function pn2(e2, t2) {
  if (e2.length === 1)
    return e2[0];
  let [r2, n2] = e2, [o2, u2] = e2.map((i2) => i2.split(`
`, 1)[0].length);
  return o2 > t2 && o2 > u2 ? n2 : r2;
}
var Wt = Me2(it2(), 1);
var jt = [];
var dn2 = [];
function Ht(e2, t2) {
  if (e2 === t2)
    return 0;
  let r2 = e2;
  e2.length > t2.length && (e2 = t2, t2 = r2);
  let n2 = e2.length, o2 = t2.length;
  for (; n2 > 0 && e2.charCodeAt(~-n2) === t2.charCodeAt(~-o2); )
    n2--, o2--;
  let u2 = 0;
  for (; u2 < n2 && e2.charCodeAt(u2) === t2.charCodeAt(u2); )
    u2++;
  if (n2 -= u2, o2 -= u2, n2 === 0)
    return o2;
  let i2, s2, a2, D, l2 = 0, d2 = 0;
  for (; l2 < n2; )
    dn2[l2] = e2.charCodeAt(u2 + l2), jt[l2] = ++l2;
  for (; d2 < o2; )
    for (i2 = t2.charCodeAt(u2 + d2), a2 = d2++, s2 = d2, l2 = 0; l2 < n2; l2++)
      D = i2 === dn2[l2] ? a2 : a2 + 1, a2 = jt[l2], s2 = jt[l2] = a2 > s2 ? D > s2 ? s2 + 1 : D : D > a2 ? a2 + 1 : D;
  return s2;
}
var at2 = (e2, t2, { descriptor: r2, logger: n2, schemas: o2 }) => {
  let u2 = [`Ignored unknown option ${Wt.default.yellow(r2.pair({ key: e2, value: t2 }))}.`], i2 = Object.keys(o2).sort().find((s2) => Ht(e2, s2) < 3);
  i2 && u2.push(`Did you mean ${Wt.default.blue(r2.key(i2))}?`), n2.warn(u2.join(" "));
};
var Fo = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
function mo(e2, t2) {
  let r2 = new e2(t2), n2 = Object.create(r2);
  for (let o2 of Fo)
    o2 in t2 && (n2[o2] = Eo(t2[o2], r2, O.prototype[o2].length));
  return n2;
}
var O = class {
  static create(t2) {
    return mo(this, t2);
  }
  constructor(t2) {
    this.name = t2.name;
  }
  default(t2) {
  }
  expected(t2) {
    return "nothing";
  }
  validate(t2, r2) {
    return false;
  }
  deprecated(t2, r2) {
    return false;
  }
  forward(t2, r2) {
  }
  redirect(t2, r2) {
  }
  overlap(t2, r2, n2) {
    return t2;
  }
  preprocess(t2, r2) {
    return t2;
  }
  postprocess(t2, r2) {
    return he2;
  }
};
function Eo(e2, t2, r2) {
  return typeof e2 == "function" ? (...n2) => e2(...n2.slice(0, r2 - 1), t2, ...n2.slice(r2 - 1)) : () => e2;
}
var Dt = class extends O {
  constructor(t2) {
    super(t2), this._sourceName = t2.sourceName;
  }
  expected(t2) {
    return t2.schemas[this._sourceName].expected(t2);
  }
  validate(t2, r2) {
    return r2.schemas[this._sourceName].validate(t2, r2);
  }
  redirect(t2, r2) {
    return this._sourceName;
  }
};
var lt2 = class extends O {
  expected() {
    return "anything";
  }
  validate() {
    return true;
  }
};
var ct2 = class extends O {
  constructor({ valueSchema: t2, name: r2 = t2.name, ...n2 }) {
    super({ ...n2, name: r2 }), this._valueSchema = t2;
  }
  expected(t2) {
    let { text: r2, list: n2 } = t2.normalizeExpectedResult(this._valueSchema.expected(t2));
    return { text: r2 && `an array of ${r2}`, list: n2 && { title: "an array of the following values", values: [{ list: n2 }] } };
  }
  validate(t2, r2) {
    if (!Array.isArray(t2))
      return false;
    let n2 = [];
    for (let o2 of t2) {
      let u2 = r2.normalizeValidateResult(this._valueSchema.validate(o2, r2), o2);
      u2 !== true && n2.push(u2.value);
    }
    return n2.length === 0 ? true : { value: n2 };
  }
  deprecated(t2, r2) {
    let n2 = [];
    for (let o2 of t2) {
      let u2 = r2.normalizeDeprecatedResult(this._valueSchema.deprecated(o2, r2), o2);
      u2 !== false && n2.push(...u2.map(({ value: i2 }) => ({ value: [i2] })));
    }
    return n2;
  }
  forward(t2, r2) {
    let n2 = [];
    for (let o2 of t2) {
      let u2 = r2.normalizeForwardResult(this._valueSchema.forward(o2, r2), o2);
      n2.push(...u2.map(Fn));
    }
    return n2;
  }
  redirect(t2, r2) {
    let n2 = [], o2 = [];
    for (let u2 of t2) {
      let i2 = r2.normalizeRedirectResult(this._valueSchema.redirect(u2, r2), u2);
      "remain" in i2 && n2.push(i2.remain), o2.push(...i2.redirect.map(Fn));
    }
    return n2.length === 0 ? { redirect: o2 } : { redirect: o2, remain: n2 };
  }
  overlap(t2, r2) {
    return t2.concat(r2);
  }
};
function Fn({ from: e2, to: t2 }) {
  return { from: [e2], to: t2 };
}
var ft = class extends O {
  expected() {
    return "true or false";
  }
  validate(t2) {
    return typeof t2 == "boolean";
  }
};
function En(e2, t2) {
  let r2 = /* @__PURE__ */ Object.create(null);
  for (let n2 of e2) {
    let o2 = n2[t2];
    if (r2[o2])
      throw new Error(`Duplicate ${t2} ${JSON.stringify(o2)}`);
    r2[o2] = n2;
  }
  return r2;
}
function hn2(e2, t2) {
  let r2 = /* @__PURE__ */ new Map();
  for (let n2 of e2) {
    let o2 = n2[t2];
    if (r2.has(o2))
      throw new Error(`Duplicate ${t2} ${JSON.stringify(o2)}`);
    r2.set(o2, n2);
  }
  return r2;
}
function Cn() {
  let e2 = /* @__PURE__ */ Object.create(null);
  return (t2) => {
    let r2 = JSON.stringify(t2);
    return e2[r2] ? true : (e2[r2] = true, false);
  };
}
function gn2(e2, t2) {
  let r2 = [], n2 = [];
  for (let o2 of e2)
    t2(o2) ? r2.push(o2) : n2.push(o2);
  return [r2, n2];
}
function yn2(e2) {
  return e2 === Math.floor(e2);
}
function An(e2, t2) {
  if (e2 === t2)
    return 0;
  let r2 = typeof e2, n2 = typeof t2, o2 = ["undefined", "object", "boolean", "number", "string"];
  return r2 !== n2 ? o2.indexOf(r2) - o2.indexOf(n2) : r2 !== "string" ? Number(e2) - Number(t2) : e2.localeCompare(t2);
}
function Bn2(e2) {
  return (...t2) => {
    let r2 = e2(...t2);
    return typeof r2 == "string" ? new Error(r2) : r2;
  };
}
function Mt(e2) {
  return e2 === void 0 ? {} : e2;
}
function $t(e2) {
  if (typeof e2 == "string")
    return { text: e2 };
  let { text: t2, list: r2 } = e2;
  return ho((t2 || r2) !== void 0, "Unexpected `expected` result, there should be at least one field."), r2 ? { text: t2, list: { title: r2.title, values: r2.values.map($t) } } : { text: t2 };
}
function Vt(e2, t2) {
  return e2 === true ? true : e2 === false ? { value: t2 } : e2;
}
function Ut(e2, t2, r2 = false) {
  return e2 === false ? false : e2 === true ? r2 ? true : [{ value: t2 }] : "value" in e2 ? [e2] : e2.length === 0 ? false : e2;
}
function mn2(e2, t2) {
  return typeof e2 == "string" || "key" in e2 ? { from: t2, to: e2 } : "from" in e2 ? { from: e2.from, to: e2.to } : { from: t2, to: e2.to };
}
function pt2(e2, t2) {
  return e2 === void 0 ? [] : Array.isArray(e2) ? e2.map((r2) => mn2(r2, t2)) : [mn2(e2, t2)];
}
function zt(e2, t2) {
  let r2 = pt2(typeof e2 == "object" && "redirect" in e2 ? e2.redirect : e2, t2);
  return r2.length === 0 ? { remain: t2, redirect: r2 } : typeof e2 == "object" && "remain" in e2 ? { remain: e2.remain, redirect: r2 } : { redirect: r2 };
}
function ho(e2, t2) {
  if (!e2)
    throw new Error(t2);
}
var dt2 = class extends O {
  constructor(t2) {
    super(t2), this._choices = hn2(t2.choices.map((r2) => r2 && typeof r2 == "object" ? r2 : { value: r2 }), "value");
  }
  expected({ descriptor: t2 }) {
    let r2 = Array.from(this._choices.keys()).map((i2) => this._choices.get(i2)).filter(({ hidden: i2 }) => !i2).map((i2) => i2.value).sort(An).map(t2.value), n2 = r2.slice(0, -2), o2 = r2.slice(-2);
    return { text: n2.concat(o2.join(" or ")).join(", "), list: { title: "one of the following values", values: r2 } };
  }
  validate(t2) {
    return this._choices.has(t2);
  }
  deprecated(t2) {
    let r2 = this._choices.get(t2);
    return r2 && r2.deprecated ? { value: t2 } : false;
  }
  forward(t2) {
    let r2 = this._choices.get(t2);
    return r2 ? r2.forward : void 0;
  }
  redirect(t2) {
    let r2 = this._choices.get(t2);
    return r2 ? r2.redirect : void 0;
  }
};
var Ft2 = class extends O {
  expected() {
    return "a number";
  }
  validate(t2, r2) {
    return typeof t2 == "number";
  }
};
var mt2 = class extends Ft2 {
  expected() {
    return "an integer";
  }
  validate(t2, r2) {
    return r2.normalizeValidateResult(super.validate(t2, r2), t2) === true && yn2(t2);
  }
};
var Re2 = class extends O {
  expected() {
    return "a string";
  }
  validate(t2) {
    return typeof t2 == "string";
  }
};
var wn2 = ie;
var xn2 = at2;
var _n = cn2;
var vn2 = an2;
var Et2 = class {
  constructor(t2, r2) {
    let { logger: n2 = console, loggerPrintWidth: o2 = 80, descriptor: u2 = wn2, unknown: i2 = xn2, invalid: s2 = _n, deprecated: a2 = vn2, missing: D = () => false, required: l2 = () => false, preprocess: d2 = (p2) => p2, postprocess: f2 = () => he2 } = r2 || {};
    this._utils = { descriptor: u2, logger: n2 || { warn: () => {
    } }, loggerPrintWidth: o2, schemas: En(t2, "name"), normalizeDefaultResult: Mt, normalizeExpectedResult: $t, normalizeDeprecatedResult: Ut, normalizeForwardResult: pt2, normalizeRedirectResult: zt, normalizeValidateResult: Vt }, this._unknownHandler = i2, this._invalidHandler = Bn2(s2), this._deprecatedHandler = a2, this._identifyMissing = (p2, c2) => !(p2 in c2) || D(p2, c2), this._identifyRequired = l2, this._preprocess = d2, this._postprocess = f2, this.cleanHistory();
  }
  cleanHistory() {
    this._hasDeprecationWarned = Cn();
  }
  normalize(t2) {
    let r2 = {}, o2 = [this._preprocess(t2, this._utils)], u2 = () => {
      for (; o2.length !== 0; ) {
        let i2 = o2.shift(), s2 = this._applyNormalization(i2, r2);
        o2.push(...s2);
      }
    };
    u2();
    for (let i2 of Object.keys(this._utils.schemas)) {
      let s2 = this._utils.schemas[i2];
      if (!(i2 in r2)) {
        let a2 = Mt(s2.default(this._utils));
        "value" in a2 && o2.push({ [i2]: a2.value });
      }
    }
    u2();
    for (let i2 of Object.keys(this._utils.schemas)) {
      if (!(i2 in r2))
        continue;
      let s2 = this._utils.schemas[i2], a2 = r2[i2], D = s2.postprocess(a2, this._utils);
      D !== he2 && (this._applyValidation(D, i2, s2), r2[i2] = D);
    }
    return this._applyPostprocess(r2), this._applyRequiredCheck(r2), r2;
  }
  _applyNormalization(t2, r2) {
    let n2 = [], { knownKeys: o2, unknownKeys: u2 } = this._partitionOptionKeys(t2);
    for (let i2 of o2) {
      let s2 = this._utils.schemas[i2], a2 = s2.preprocess(t2[i2], this._utils);
      this._applyValidation(a2, i2, s2);
      let D = ({ from: p2, to: c2 }) => {
        n2.push(typeof c2 == "string" ? { [c2]: p2 } : { [c2.key]: c2.value });
      }, l2 = ({ value: p2, redirectTo: c2 }) => {
        let F = Ut(s2.deprecated(p2, this._utils), a2, true);
        if (F !== false)
          if (F === true)
            this._hasDeprecationWarned(i2) || this._utils.logger.warn(this._deprecatedHandler(i2, c2, this._utils));
          else
            for (let { value: m } of F) {
              let E2 = { key: i2, value: m };
              if (!this._hasDeprecationWarned(E2)) {
                let A = typeof c2 == "string" ? { key: c2, value: m } : c2;
                this._utils.logger.warn(this._deprecatedHandler(E2, A, this._utils));
              }
            }
      };
      pt2(s2.forward(a2, this._utils), a2).forEach(D);
      let f2 = zt(s2.redirect(a2, this._utils), a2);
      if (f2.redirect.forEach(D), "remain" in f2) {
        let p2 = f2.remain;
        r2[i2] = i2 in r2 ? s2.overlap(r2[i2], p2, this._utils) : p2, l2({ value: p2 });
      }
      for (let { from: p2, to: c2 } of f2.redirect)
        l2({ value: p2, redirectTo: c2 });
    }
    for (let i2 of u2) {
      let s2 = t2[i2];
      this._applyUnknownHandler(i2, s2, r2, (a2, D) => {
        n2.push({ [a2]: D });
      });
    }
    return n2;
  }
  _applyRequiredCheck(t2) {
    for (let r2 of Object.keys(this._utils.schemas))
      if (this._identifyMissing(r2, t2) && this._identifyRequired(r2))
        throw this._invalidHandler(r2, st2, this._utils);
  }
  _partitionOptionKeys(t2) {
    let [r2, n2] = gn2(Object.keys(t2).filter((o2) => !this._identifyMissing(o2, t2)), (o2) => o2 in this._utils.schemas);
    return { knownKeys: r2, unknownKeys: n2 };
  }
  _applyValidation(t2, r2, n2) {
    let o2 = Vt(n2.validate(t2, this._utils), t2);
    if (o2 !== true)
      throw this._invalidHandler(r2, o2.value, this._utils);
  }
  _applyUnknownHandler(t2, r2, n2, o2) {
    let u2 = this._unknownHandler(t2, r2, this._utils);
    if (u2)
      for (let i2 of Object.keys(u2)) {
        if (this._identifyMissing(i2, u2))
          continue;
        let s2 = u2[i2];
        i2 in this._utils.schemas ? o2(i2, s2) : n2[i2] = s2;
      }
  }
  _applyPostprocess(t2) {
    let r2 = this._postprocess(t2, this._utils);
    if (r2 !== he2) {
      if (r2.delete)
        for (let n2 of r2.delete)
          delete t2[n2];
      if (r2.override) {
        let { knownKeys: n2, unknownKeys: o2 } = this._partitionOptionKeys(r2.override);
        for (let u2 of n2) {
          let i2 = r2.override[u2];
          this._applyValidation(i2, u2, this._utils.schemas[u2]), t2[u2] = i2;
        }
        for (let u2 of o2) {
          let i2 = r2.override[u2];
          this._applyUnknownHandler(u2, i2, t2, (s2, a2) => {
            let D = this._utils.schemas[s2];
            this._applyValidation(a2, s2, D), t2[s2] = a2;
          });
        }
      }
    }
  }
};
var Gt;
function go(e2, t2, { logger: r2 = false, isCLI: n2 = false, passThrough: o2 = false, FlagSchema: u2, descriptor: i2 } = {}) {
  if (n2) {
    if (!u2)
      throw new Error("'FlagSchema' option is required.");
    if (!i2)
      throw new Error("'descriptor' option is required.");
  } else
    i2 = ie;
  let s2 = o2 ? Array.isArray(o2) ? (f2, p2) => o2.includes(f2) ? { [f2]: p2 } : void 0 : (f2, p2) => ({ [f2]: p2 }) : (f2, p2, c2) => {
    let { _: F, ...m } = c2.schemas;
    return at2(f2, p2, { ...c2, schemas: m });
  }, a2 = yo(t2, { isCLI: n2, FlagSchema: u2 }), D = new Et2(a2, { logger: r2, unknown: s2, descriptor: i2 }), l2 = r2 !== false;
  l2 && Gt && (D._hasDeprecationWarned = Gt);
  let d2 = D.normalize(e2);
  return l2 && (Gt = D._hasDeprecationWarned), d2;
}
function yo(e2, { isCLI: t2, FlagSchema: r2 }) {
  let n2 = [];
  t2 && n2.push(lt2.create({ name: "_" }));
  for (let o2 of e2)
    n2.push(Ao(o2, { isCLI: t2, optionInfos: e2, FlagSchema: r2 })), o2.alias && t2 && n2.push(Dt.create({ name: o2.alias, sourceName: o2.name }));
  return n2;
}
function Ao(e2, { isCLI: t2, optionInfos: r2, FlagSchema: n2 }) {
  let { name: o2 } = e2, u2 = { name: o2 }, i2, s2 = {};
  switch (e2.type) {
    case "int":
      i2 = mt2, t2 && (u2.preprocess = Number);
      break;
    case "string":
      i2 = Re2;
      break;
    case "choice":
      i2 = dt2, u2.choices = e2.choices.map((a2) => a2 != null && a2.redirect ? { ...a2, redirect: { to: { key: e2.name, value: a2.redirect } } } : a2);
      break;
    case "boolean":
      i2 = ft;
      break;
    case "flag":
      i2 = n2, u2.flags = r2.flatMap((a2) => [a2.alias, a2.description && a2.name, a2.oppositeDescription && `no-${a2.name}`].filter(Boolean));
      break;
    case "path":
      i2 = Re2;
      break;
    default:
      throw new Error(`Unexpected type ${e2.type}`);
  }
  if (e2.exception ? u2.validate = (a2, D, l2) => e2.exception(a2) || D.validate(a2, l2) : u2.validate = (a2, D, l2) => a2 === void 0 || D.validate(a2, l2), e2.redirect && (s2.redirect = (a2) => a2 ? { to: typeof e2.redirect == "string" ? e2.redirect : { key: e2.redirect.option, value: e2.redirect.value } } : void 0), e2.deprecated && (s2.deprecated = true), t2 && !e2.array) {
    let a2 = u2.preprocess || ((D) => D);
    u2.preprocess = (D, l2, d2) => l2.preprocess(a2(Array.isArray(D) ? y2(false, D, -1) : D), d2);
  }
  return e2.array ? ct2.create({ ...t2 ? { preprocess: (a2) => Array.isArray(a2) ? a2 : [a2] } : {}, ...s2, valueSchema: i2.create(u2) }) : i2.create({ ...u2, ...s2 });
}
var bn2 = go;
var Bo2 = (e2, t2, r2) => {
  if (!(e2 && t2 == null)) {
    if (t2.findLast)
      return t2.findLast(r2);
    for (let n2 = t2.length - 1; n2 >= 0; n2--) {
      let o2 = t2[n2];
      if (r2(o2, n2, t2))
        return o2;
    }
  }
};
var Kt = Bo2;
function qt(e2, t2) {
  if (!t2)
    throw new Error("parserName is required.");
  let r2 = Kt(false, e2, (o2) => o2.parsers && Object.prototype.hasOwnProperty.call(o2.parsers, t2));
  if (r2)
    return r2;
  let n2 = `Couldn't resolve parser "${t2}".`;
  throw n2 += " Plugins must be explicitly added to the standalone bundle.", new Pe2(n2);
}
function On(e2, t2) {
  if (!t2)
    throw new Error("astFormat is required.");
  let r2 = Kt(false, e2, (o2) => o2.printers && Object.prototype.hasOwnProperty.call(o2.printers, t2));
  if (r2)
    return r2;
  let n2 = `Couldn't find plugin for AST format "${t2}".`;
  throw n2 += " Plugins must be explicitly added to the standalone bundle.", new Pe2(n2);
}
function ht2({ plugins: e2, parser: t2 }) {
  let r2 = qt(e2, t2);
  return Jt(r2, t2);
}
function Jt(e2, t2) {
  let r2 = e2.parsers[t2];
  return typeof r2 == "function" ? r2() : r2;
}
function Sn2(e2, t2) {
  let r2 = e2.printers[t2];
  return typeof r2 == "function" ? r2() : r2;
}
var Nn = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
async function wo(e2, t2 = {}) {
  var d2;
  let r2 = { ...e2 };
  if (!r2.parser)
    if (r2.filepath) {
      if (r2.parser = un2(r2, { physicalFile: r2.filepath }), !r2.parser)
        throw new Ie2(`No parser could be inferred for file "${r2.filepath}".`);
    } else
      throw new Ie2("No parser and no file path given, couldn't infer a parser.");
  let n2 = ot2({ plugins: e2.plugins, showDeprecated: true }).options, o2 = { ...Nn, ...Object.fromEntries(n2.filter((f2) => f2.default !== void 0).map((f2) => [f2.name, f2.default])) }, u2 = qt(r2.plugins, r2.parser), i2 = await Jt(u2, r2.parser);
  r2.astFormat = i2.astFormat, r2.locEnd = i2.locEnd, r2.locStart = i2.locStart;
  let s2 = (d2 = u2.printers) != null && d2[i2.astFormat] ? u2 : On(r2.plugins, i2.astFormat), a2 = await Sn2(s2, i2.astFormat);
  r2.printer = a2;
  let D = s2.defaultOptions ? Object.fromEntries(Object.entries(s2.defaultOptions).filter(([, f2]) => f2 !== void 0)) : {}, l2 = { ...o2, ...D };
  for (let [f2, p2] of Object.entries(l2))
    (r2[f2] === null || r2[f2] === void 0) && (r2[f2] = p2);
  return r2.parser === "json" && (r2.trailingComma = "none"), bn2(r2, n2, { passThrough: Object.keys(Nn), ...t2 });
}
var se = wo;
var Vn2 = Me2($n2(), 1);
async function ko(e2, t2) {
  let r2 = await ht2(t2), n2 = r2.preprocess ? r2.preprocess(e2, t2) : e2;
  t2.originalText = n2;
  let o2;
  try {
    o2 = await r2.parse(n2, t2, t2);
  } catch (u2) {
    Lo(u2, e2);
  }
  return { text: n2, ast: o2 };
}
function Lo(e2, t2) {
  let { loc: r2 } = e2;
  if (r2) {
    let n2 = (0, Vn2.codeFrameColumns)(t2, r2, { highlightCode: true });
    throw e2.message += `
` + n2, e2.codeFrame = n2, e2;
  }
  throw e2;
}
var ce2 = ko;
async function Un2(e2, t2, r2, n2, o2) {
  let { embeddedLanguageFormatting: u2, printer: { embed: i2, hasPrettierIgnore: s2 = () => false, getVisitorKeys: a2 } } = r2;
  if (!i2 || u2 !== "auto")
    return;
  if (i2.length > 2)
    throw new Error("printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/en/plugins.html#optional-embed");
  let D = X2(i2.getVisitorKeys ?? a2), l2 = [];
  p2();
  let d2 = e2.stack;
  for (let { print: c2, node: F, pathStack: m } of l2)
    try {
      e2.stack = m;
      let E2 = await c2(f2, t2, e2, r2);
      E2 && o2.set(F, E2);
    } catch (E2) {
      if (globalThis.PRETTIER_DEBUG)
        throw E2;
    }
  e2.stack = d2;
  function f2(c2, F) {
    return Po(c2, F, r2, n2);
  }
  function p2() {
    let { node: c2 } = e2;
    if (c2 === null || typeof c2 != "object" || s2(e2))
      return;
    for (let m of D(c2))
      Array.isArray(c2[m]) ? e2.each(p2, m) : e2.call(p2, m);
    let F = i2(e2, r2);
    if (F) {
      if (typeof F == "function") {
        l2.push({ print: F, node: c2, pathStack: [...e2.stack] });
        return;
      }
      o2.set(c2, F);
    }
  }
}
async function Po(e2, t2, r2, n2) {
  let o2 = await se({ ...r2, ...t2, parentParser: r2.parser, originalText: e2 }, { passThrough: true }), { ast: u2 } = await ce2(e2, o2), i2 = await n2(u2, o2);
  return Ze(i2);
}
function Io(e2, t2) {
  let { originalText: r2, [Symbol.for("comments")]: n2, locStart: o2, locEnd: u2, [Symbol.for("printedComments")]: i2 } = t2, { node: s2 } = e2, a2 = o2(s2), D = u2(s2);
  for (let l2 of n2)
    o2(l2) >= a2 && u2(l2) <= D && i2.add(l2);
  return r2.slice(a2, D);
}
var zn2 = Io;
async function Ye(e2, t2) {
  ({ ast: e2 } = await Qt(e2, t2));
  let r2 = /* @__PURE__ */ new Map(), n2 = new Mr(e2), o2 = tn2(t2), u2 = /* @__PURE__ */ new Map();
  await Un2(n2, s2, t2, Ye, u2);
  let i2 = await Gn2(n2, t2, s2, void 0, u2);
  return en2(t2), i2;
  function s2(D, l2) {
    return D === void 0 || D === n2 ? a2(l2) : Array.isArray(D) ? n2.call(() => a2(l2), ...D) : n2.call(() => a2(l2), D);
  }
  function a2(D) {
    o2(n2);
    let l2 = n2.node;
    if (l2 == null)
      return "";
    let d2 = l2 && typeof l2 == "object" && D === void 0;
    if (d2 && r2.has(l2))
      return r2.get(l2);
    let f2 = Gn2(n2, t2, s2, D, u2);
    return d2 && r2.set(l2, f2), f2;
  }
}
function Gn2(e2, t2, r2, n2, o2) {
  var a2;
  let { node: u2 } = e2, { printer: i2 } = t2, s2;
  return (a2 = i2.hasPrettierIgnore) != null && a2.call(i2, e2) ? s2 = zn2(e2, t2) : o2.has(u2) ? s2 = o2.get(u2) : s2 = i2.print(e2, t2, r2, n2), u2 === t2.cursorNode && (s2 = Qe2(s2, (D) => [ve2, D, ve2])), i2.printComment && (!i2.willPrintOwnComments || !i2.willPrintOwnComments(e2, t2)) && (s2 = Qr(e2, s2, t2)), s2;
}
async function Qt(e2, t2) {
  let r2 = e2.comments ?? [];
  t2[Symbol.for("comments")] = r2, t2[Symbol.for("tokens")] = e2.tokens ?? [], t2[Symbol.for("printedComments")] = /* @__PURE__ */ new Set(), Jr(e2, t2);
  let { printer: { preprocess: n2 } } = t2;
  return e2 = n2 ? await n2(e2, t2) : e2, { ast: e2, comments: r2 };
}
function Ro2(e2, t2) {
  let { cursorOffset: r2, locStart: n2, locEnd: o2 } = t2, u2 = X2(t2.printer.getVisitorKeys), i2 = (a2) => n2(a2) <= r2 && o2(a2) >= r2, s2 = e2;
  for (let a2 of Ur(e2, { getVisitorKeys: u2, filter: i2 }))
    s2 = a2;
  return s2;
}
var Kn2 = Ro2;
function Yo(e2, t2) {
  let { printer: { massageAstNode: r2, getVisitorKeys: n2 } } = t2;
  if (!r2)
    return e2;
  let o2 = X2(n2), u2 = r2.ignoredProperties ?? /* @__PURE__ */ new Set();
  return i2(e2);
  function i2(s2, a2) {
    if (!(s2 !== null && typeof s2 == "object"))
      return s2;
    if (Array.isArray(s2))
      return s2.map((f2) => i2(f2, a2)).filter(Boolean);
    let D = {}, l2 = new Set(o2(s2));
    for (let f2 in s2)
      !Object.prototype.hasOwnProperty.call(s2, f2) || u2.has(f2) || (l2.has(f2) ? D[f2] = i2(s2[f2], s2) : D[f2] = s2[f2]);
    let d2 = r2(s2, D, a2);
    if (d2 !== null)
      return d2 ?? D;
  }
}
var qn = Yo;
var jo = (e2, t2, r2) => {
  if (!(e2 && t2 == null)) {
    if (t2.findLastIndex)
      return t2.findLastIndex(r2);
    for (let n2 = t2.length - 1; n2 >= 0; n2--) {
      let o2 = t2[n2];
      if (r2(o2, n2, t2))
        return n2;
    }
    return -1;
  }
};
var Jn = jo;
var Ho = ({ parser: e2 }) => e2 === "json" || e2 === "json5" || e2 === "jsonc" || e2 === "json-stringify";
function Wo(e2, t2) {
  let r2 = [e2.node, ...e2.parentNodes], n2 = /* @__PURE__ */ new Set([t2.node, ...t2.parentNodes]);
  return r2.find((o2) => Qn2.has(o2.type) && n2.has(o2));
}
function Xn(e2) {
  let t2 = Jn(false, e2, (r2) => r2.type !== "Program" && r2.type !== "File");
  return t2 === -1 ? e2 : e2.slice(0, t2 + 1);
}
function Mo(e2, t2, { locStart: r2, locEnd: n2 }) {
  let o2 = e2.node, u2 = t2.node;
  if (o2 === u2)
    return { startNode: o2, endNode: u2 };
  let i2 = r2(e2.node);
  for (let a2 of Xn(t2.parentNodes))
    if (r2(a2) >= i2)
      u2 = a2;
    else
      break;
  let s2 = n2(t2.node);
  for (let a2 of Xn(e2.parentNodes)) {
    if (n2(a2) <= s2)
      o2 = a2;
    else
      break;
    if (o2 === u2)
      break;
  }
  return { startNode: o2, endNode: u2 };
}
function er(e2, t2, r2, n2, o2 = [], u2) {
  let { locStart: i2, locEnd: s2 } = r2, a2 = i2(e2), D = s2(e2);
  if (!(t2 > D || t2 < a2 || u2 === "rangeEnd" && t2 === a2 || u2 === "rangeStart" && t2 === D)) {
    for (let l2 of ut2(e2, r2)) {
      let d2 = er(l2, t2, r2, n2, [e2, ...o2], u2);
      if (d2)
        return d2;
    }
    if (!n2 || n2(e2, o2[0]))
      return { node: e2, parentNodes: o2 };
  }
}
function $o(e2, t2) {
  return t2 !== "DeclareExportDeclaration" && e2 !== "TypeParameterDeclaration" && (e2 === "Directive" || e2 === "TypeAlias" || e2 === "TSExportAssignment" || e2.startsWith("Declare") || e2.startsWith("TSDeclare") || e2.endsWith("Statement") || e2.endsWith("Declaration"));
}
var Qn2 = /* @__PURE__ */ new Set(["JsonRoot", "ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]);
var Vo = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
function Zn2(e2, t2, r2) {
  if (!t2)
    return false;
  switch (e2.parser) {
    case "flow":
    case "babel":
    case "babel-flow":
    case "babel-ts":
    case "typescript":
    case "acorn":
    case "espree":
    case "meriyah":
    case "__babel_estree":
      return $o(t2.type, r2 == null ? void 0 : r2.type);
    case "json":
    case "json5":
    case "jsonc":
    case "json-stringify":
      return Qn2.has(t2.type);
    case "graphql":
      return Vo.has(t2.kind);
    case "vue":
      return t2.tag !== "root";
  }
  return false;
}
function eu(e2, t2, r2) {
  let { rangeStart: n2, rangeEnd: o2, locStart: u2, locEnd: i2 } = t2;
  ke2.ok(o2 > n2);
  let s2 = e2.slice(n2, o2).search(/\S/u), a2 = s2 === -1;
  if (!a2)
    for (n2 += s2; o2 > n2 && !/\S/u.test(e2[o2 - 1]); --o2)
      ;
  let D = er(r2, n2, t2, (p2, c2) => Zn2(t2, p2, c2), [], "rangeStart"), l2 = a2 ? D : er(r2, o2, t2, (p2) => Zn2(t2, p2), [], "rangeEnd");
  if (!D || !l2)
    return { rangeStart: 0, rangeEnd: 0 };
  let d2, f2;
  if (Ho(t2)) {
    let p2 = Wo(D, l2);
    d2 = p2, f2 = p2;
  } else
    ({ startNode: d2, endNode: f2 } = Mo(D, l2, t2));
  return { rangeStart: Math.min(u2(d2), u2(f2)), rangeEnd: Math.max(i2(d2), i2(f2)) };
}
var uu = "\uFEFF";
var tu = Symbol("cursor");
async function ou2(e2, t2, r2 = 0) {
  if (!e2 || e2.trim().length === 0)
    return { formatted: "", cursorOffset: -1, comments: [] };
  let { ast: n2, text: o2 } = await ce2(e2, t2);
  t2.cursorOffset >= 0 && (t2.cursorNode = Kn2(n2, t2));
  let u2 = await Ye(n2, t2, r2);
  r2 > 0 && (u2 = Je([q, u2], r2, t2.tabWidth));
  let i2 = Fe2(u2, t2);
  if (r2 > 0) {
    let a2 = i2.formatted.trim();
    i2.cursorNodeStart !== void 0 && (i2.cursorNodeStart -= i2.formatted.indexOf(a2)), i2.formatted = a2 + Be2(t2.endOfLine);
  }
  let s2 = t2[Symbol.for("comments")];
  if (t2.cursorOffset >= 0) {
    let a2, D, l2, d2, f2;
    if (t2.cursorNode && i2.cursorNodeText ? (a2 = t2.locStart(t2.cursorNode), D = o2.slice(a2, t2.locEnd(t2.cursorNode)), l2 = t2.cursorOffset - a2, d2 = i2.cursorNodeStart, f2 = i2.cursorNodeText) : (a2 = 0, D = o2, l2 = t2.cursorOffset, d2 = 0, f2 = i2.formatted), D === f2)
      return { formatted: i2.formatted, cursorOffset: d2 + l2, comments: s2 };
    let p2 = D.split("");
    p2.splice(l2, 0, tu);
    let c2 = f2.split(""), F = dr2(p2, c2), m = d2;
    for (let E2 of F)
      if (E2.removed) {
        if (E2.value.includes(tu))
          break;
      } else
        m += E2.count;
    return { formatted: i2.formatted, cursorOffset: m, comments: s2 };
  }
  return { formatted: i2.formatted, cursorOffset: -1, comments: s2 };
}
async function Uo(e2, t2) {
  let { ast: r2, text: n2 } = await ce2(e2, t2), { rangeStart: o2, rangeEnd: u2 } = eu(n2, t2, r2), i2 = n2.slice(o2, u2), s2 = Math.min(o2, n2.lastIndexOf(`
`, o2) + 1), a2 = n2.slice(s2, o2).match(/^\s*/u)[0], D = me(a2, t2.tabWidth), l2 = await ou2(i2, { ...t2, rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: t2.cursorOffset > o2 && t2.cursorOffset <= u2 ? t2.cursorOffset - o2 : -1, endOfLine: "lf" }, D), d2 = l2.formatted.trimEnd(), { cursorOffset: f2 } = t2;
  f2 > u2 ? f2 += d2.length - i2.length : l2.cursorOffset >= 0 && (f2 = l2.cursorOffset + o2);
  let p2 = n2.slice(0, o2) + d2 + n2.slice(u2);
  if (t2.endOfLine !== "lf") {
    let c2 = Be2(t2.endOfLine);
    f2 >= 0 && c2 === `\r
` && (f2 += wt2(p2.slice(0, f2), `
`)), p2 = ne2(false, p2, `
`, c2);
  }
  return { formatted: p2, cursorOffset: f2, comments: l2.comments };
}
function tr(e2, t2, r2) {
  return typeof t2 != "number" || Number.isNaN(t2) || t2 < 0 || t2 > e2.length ? r2 : t2;
}
function ru(e2, t2) {
  let { cursorOffset: r2, rangeStart: n2, rangeEnd: o2 } = t2;
  return r2 = tr(e2, r2, -1), n2 = tr(e2, n2, 0), o2 = tr(e2, o2, e2.length), { ...t2, cursorOffset: r2, rangeStart: n2, rangeEnd: o2 };
}
function iu(e2, t2) {
  let { cursorOffset: r2, rangeStart: n2, rangeEnd: o2, endOfLine: u2 } = ru(e2, t2), i2 = e2.charAt(0) === uu;
  if (i2 && (e2 = e2.slice(1), r2--, n2--, o2--), u2 === "auto" && (u2 = Fr(e2)), e2.includes("\r")) {
    let s2 = (a2) => wt2(e2.slice(0, Math.max(a2, 0)), `\r
`);
    r2 -= s2(r2), n2 -= s2(n2), o2 -= s2(o2), e2 = mr(e2);
  }
  return { hasBOM: i2, text: e2, options: ru(e2, { ...t2, cursorOffset: r2, rangeStart: n2, rangeEnd: o2, endOfLine: u2 }) };
}
async function nu(e2, t2) {
  let r2 = await ht2(t2);
  return !r2.hasPragma || r2.hasPragma(e2);
}
async function rr(e2, t2) {
  let { hasBOM: r2, text: n2, options: o2 } = iu(e2, await se(t2));
  if (o2.rangeStart >= o2.rangeEnd && n2 !== "" || o2.requirePragma && !await nu(n2, o2))
    return { formatted: e2, cursorOffset: t2.cursorOffset, comments: [] };
  let u2;
  return o2.rangeStart > 0 || o2.rangeEnd < n2.length ? u2 = await Uo(n2, o2) : (!o2.requirePragma && o2.insertPragma && o2.printer.insertPragma && !await nu(n2, o2) && (n2 = o2.printer.insertPragma(n2)), u2 = await ou2(n2, o2)), r2 && (u2.formatted = uu + u2.formatted, u2.cursorOffset >= 0 && u2.cursorOffset++), u2;
}
async function su2(e2, t2, r2) {
  let { text: n2, options: o2 } = iu(e2, await se(t2)), u2 = await ce2(n2, o2);
  return r2 && (r2.preprocessForPrint && (u2.ast = await Qt(u2.ast, o2)), r2.massage && (u2.ast = qn(u2.ast, o2))), u2;
}
async function au(e2, t2) {
  t2 = await se(t2);
  let r2 = await Ye(e2, t2);
  return Fe2(r2, t2);
}
async function Du(e2, t2) {
  let r2 = Or(e2), { formatted: n2 } = await rr(r2, { ...t2, parser: "__js_expression" });
  return n2;
}
async function lu2(e2, t2) {
  t2 = await se(t2);
  let { ast: r2 } = await ce2(e2, t2);
  return Ye(r2, t2);
}
async function cu(e2, t2) {
  return Fe2(e2, await se(t2));
}
var nr = {};
We(nr, { builders: () => Go, printer: () => Ko2, utils: () => qo });
var Go = { join: be2, line: Ke2, softline: vr2, hardline: q, literalline: qe, group: _t, conditionalGroup: Ar2, fill: Ge2, lineSuffix: xe2, lineSuffixBoundary: xr2, cursor: ve2, breakParent: de, ifBreak: Br, trim: _r2, indent: De2, indentIfBreak: wr, align: ae, addAlignmentToDoc: Je, markAsRoot: gr2, dedentToRoot: Cr, dedent: yr2, hardlineWithoutBreakParent: _e2, literallineWithoutBreakParent: vt, label: br2, concat: (e2) => e2 };
var Ko2 = { printDocToString: Fe2 };
var qo = { willBreak: Ir, traverseDoc: we2, findInDoc: Xe, mapDoc: Ne, removeLines: Yr2, stripTrailingHardline: Ze, replaceEndOfLine: jr2, canBreak: Hr2 };
var fu = "3.3.3";
var or2 = {};
We(or2, { addDanglingComment: () => re2, addLeadingComment: () => ue, addTrailingComment: () => oe2, getAlignmentSize: () => me, getIndentSize: () => pu2, getMaxContinuousCount: () => du2, getNextNonSpaceNonCommentCharacter: () => Fu, getNextNonSpaceNonCommentCharacterIndex: () => si, getStringWidth: () => Oe2, hasNewline: () => V, hasNewlineInRange: () => mu, hasSpaces: () => Eu, isNextLineEmpty: () => ci2, isNextLineEmptyAfterIndex: () => gt, isPreviousLineEmpty: () => Di, makeString: () => hu, skip: () => Ee, skipEverythingButNewLine: () => nt2, skipInlineComment: () => Ce2, skipNewline: () => M2, skipSpaces: () => T2, skipToLineEnd: () => rt2, skipTrailingComment: () => ge, skipWhitespace: () => zr });
function Jo(e2, t2) {
  if (t2 === false)
    return false;
  if (e2.charAt(t2) === "/" && e2.charAt(t2 + 1) === "*") {
    for (let r2 = t2 + 2; r2 < e2.length; ++r2)
      if (e2.charAt(r2) === "*" && e2.charAt(r2 + 1) === "/")
        return r2 + 2;
  }
  return t2;
}
var Ce2 = Jo;
function Xo(e2, t2) {
  return t2 === false ? false : e2.charAt(t2) === "/" && e2.charAt(t2 + 1) === "/" ? nt2(e2, t2) : t2;
}
var ge = Xo;
function Zo(e2, t2) {
  let r2 = null, n2 = t2;
  for (; n2 !== r2; )
    r2 = n2, n2 = T2(e2, n2), n2 = Ce2(e2, n2), n2 = ge(e2, n2), n2 = M2(e2, n2);
  return n2;
}
var je = Zo;
function Qo(e2, t2) {
  let r2 = null, n2 = t2;
  for (; n2 !== r2; )
    r2 = n2, n2 = rt2(e2, n2), n2 = Ce2(e2, n2), n2 = T2(e2, n2);
  return n2 = ge(e2, n2), n2 = M2(e2, n2), n2 !== false && V(e2, n2);
}
var gt = Qo;
function ei2(e2, t2) {
  let r2 = e2.lastIndexOf(`
`);
  return r2 === -1 ? 0 : me(e2.slice(r2 + 1).match(/^[\t ]*/u)[0], t2);
}
var pu2 = ei2;
function ur2(e2) {
  if (typeof e2 != "string")
    throw new TypeError("Expected a string");
  return e2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function ti(e2, t2) {
  let r2 = e2.match(new RegExp(`(${ur2(t2)})+`, "gu"));
  return r2 === null ? 0 : r2.reduce((n2, o2) => Math.max(n2, o2.length / t2.length), 0);
}
var du2 = ti;
function ri2(e2, t2) {
  let r2 = je(e2, t2);
  return r2 === false ? "" : e2.charAt(r2);
}
var Fu = ri2;
function ni(e2, t2, r2) {
  for (let n2 = t2; n2 < r2; ++n2)
    if (e2.charAt(n2) === `
`)
      return true;
  return false;
}
var mu = ni;
function ui(e2, t2, r2 = {}) {
  return T2(e2, r2.backwards ? t2 - 1 : t2, r2) !== t2;
}
var Eu = ui;
function oi(e2, t2, r2) {
  let n2 = t2 === '"' ? "'" : '"', u2 = ne2(false, e2, /\\(.)|(["'])/gsu, (i2, s2, a2) => s2 === n2 ? s2 : a2 === t2 ? "\\" + a2 : a2 || (r2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(s2) ? s2 : "\\" + s2));
  return t2 + u2 + t2;
}
var hu = oi;
function ii(e2, t2, r2) {
  return je(e2, r2(t2));
}
function si(e2, t2) {
  return arguments.length === 2 || typeof t2 == "number" ? je(e2, t2) : ii(...arguments);
}
function ai(e2, t2, r2) {
  return Le2(e2, r2(t2));
}
function Di(e2, t2) {
  return arguments.length === 2 || typeof t2 == "number" ? Le2(e2, t2) : ai(...arguments);
}
function li2(e2, t2, r2) {
  return gt(e2, r2(t2));
}
function ci2(e2, t2) {
  return arguments.length === 2 || typeof t2 == "number" ? gt(e2, t2) : li2(...arguments);
}
function fe(e2, t2 = 1) {
  return async (...r2) => {
    let n2 = r2[t2] ?? {}, o2 = n2.plugins ?? [];
    return r2[t2] = { ...n2, plugins: Array.isArray(o2) ? o2 : Object.values(o2) }, e2(...r2);
  };
}
var Cu2 = fe(rr);
async function gu(e2, t2) {
  let { formatted: r2 } = await Cu2(e2, { ...t2, cursorOffset: -1 });
  return r2;
}
async function fi(e2, t2) {
  return await gu(e2, t2) === e2;
}
var pi2 = fe(ot2, 0);
var di = { parse: fe(su2), formatAST: fe(au), formatDoc: fe(Du), printToDoc: fe(lu2), printDocToString: fe(cu) };

// node_modules/@react-three/uikit/dist/convert/html/index.js
var starBabel = __toESM(require_babel(), 1);
var starEstree = __toESM(require_estree(), 1);

// node_modules/@react-three/uikit/dist/convert/html/preview.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var import_react19 = __toESM(require_react(), 1);
function PreviewHtml({ children, colorMap, customHook }) {
  const { classes, element } = (0, import_react19.useMemo)(() => parseHtml(children, colorMap), [children, colorMap]);
  return (0, import_jsx_runtime17.jsx)(PreviewParsedHtml, { classes, element, colorMap, customHook });
}
function PreviewParsedHtml({ classes, element, colorMap, componentMap, customHook }) {
  return (0, import_react19.useMemo)(() => {
    try {
      return convertParsedHtml(element, classes, createRenderElement(componentMap, customHook), colorMap, componentMap);
    } catch (e2) {
      console.error(e2);
      return null;
    }
  }, [element, classes, componentMap, colorMap, customHook]);
}
function createRenderElement(componentMap, customHook) {
  const Component2 = ({ custom, props, typeName, children, element }) => {
    const ref = (0, import_react19.useRef)(null);
    props = (customHook == null ? void 0 : customHook(element, ref, props)) ?? props;
    if (custom && componentMap != null) {
      const Component3 = componentMap[typeName].renderAsImpl;
      if (Component3 == null) {
        throw new Error(`unknown custom component "${typeName}"`);
      }
      return (0, import_jsx_runtime17.jsx)(Component3, { ...props, ref, children });
    }
    switch (typeName) {
      case "Video":
        return (0, import_jsx_runtime17.jsx)(Video, { ...props, ref });
      case "Image":
        return (0, import_jsx_runtime17.jsx)(Image2, { ...props, ref, children });
      case "Svg":
        return (0, import_jsx_runtime17.jsx)(Svg, { ...props, ref, children });
      case "Icon":
        return (0, import_jsx_runtime17.jsx)(Icon, { ...props, ref });
      case "Input":
        return (0, import_jsx_runtime17.jsx)(Input, { ...props, ref });
      case "Text":
        return (0, import_jsx_runtime17.jsx)(Text, { ...props, ref, children: (children == null ? void 0 : children.join("")) ?? "" });
      case "Container":
        return (0, import_jsx_runtime17.jsx)(Container, { ...props, ref, children });
      case "DefaultProperties":
        return (0, import_jsx_runtime17.jsx)(DefaultProperties, { ...props, children });
      case "Fragment":
        return (0, import_jsx_runtime17.jsx)(import_jsx_runtime17.Fragment, { children });
    }
  };
  return (element, typeName, custom, props, index, children) => (0, import_jsx_runtime17.jsx)(Component2, { element, custom, props, typeName, children }, index);
}

// node_modules/@react-three/uikit/dist/convert/html/index.js
function htmlToCode2(html, colorMap, componentMap) {
  const { classes, element } = parseHtml(html, colorMap);
  return parsedHtmlToCode(element, classes, colorMap, componentMap);
}
function parsedHtmlToCode(element, classes, colorMap, componentMap) {
  return gu(`export default function Index() { return ${convertParsedHtml(element, classes, elementToCode, colorMap, componentMap) ?? `null`} }`, {
    parser: "babel",
    plugins: [starBabel.default ?? starBabel, starEstree.default ?? starEstree],
    semi: false
  });
}
function elementToCode(element, typeName, custom, props, index, children) {
  const propsText = Object.entries(props).filter(([, value]) => typeof value != "undefined").map(([name, value]) => {
    const firstChar = name[0];
    if ("0" <= firstChar && firstChar <= "9") {
      return `{...${JSON.stringify({ [name]: value })}}`;
    }
    if (name === "panelMaterialClass" && typeof value === "function") {
      return `${name}={${value.name}}`;
    }
    switch (typeof value) {
      case "number":
        return `${name}={${value}}`;
      case "string":
        if (value.includes("\n")) {
          return `${name}={\`${value.replaceAll("`", "\\`")}\`}`;
        }
        return `${name}="${value.replaceAll('"', "'")}"`;
      case "boolean":
        return `${name}={${value ? "true" : "false"}}`;
      case "object":
        return `${name}={${JSON.stringify(value)}}`;
    }
    throw new Error(`unable to generate property "${name}" with value of type "${typeof value}"`);
  }).join(" ");
  if (children == null) {
    return `<${typeName} ${propsText} />`;
  }
  if (typeName === "Fragment") {
    typeName = "";
  }
  return `<${typeName} ${propsText} >${children.join("\n")}</${typeName}>`;
}
var export_ConversionHtmlNode = import_node_html_parser2.HTMLElement;
var export_ConversionNode = import_node_html_parser2.Node;
export {
  Container,
  Content,
  export_ConversionHtmlNode as ConversionHtmlNode,
  export_ConversionNode as ConversionNode,
  CustomContainer,
  DefaultProperties,
  FontFamilyProvider,
  Fullscreen,
  GlassMaterial,
  Icon,
  Image2 as Image,
  Input,
  MetalMaterial,
  PlasticMaterial,
  Portal,
  PreviewHtml,
  PreviewParsedHtml,
  Root2 as Root,
  SuspendingImage,
  Svg,
  Text,
  Video,
  basedOnPreferredColorScheme,
  canvasInputProps,
  conversionPropertyTypes,
  getPreferredColorScheme,
  htmlToCode2 as htmlToCode,
  isDarkMode,
  parsedHtmlToCode,
  privateKeys,
  setPreferredColorScheme,
  useMeasureText,
  useRootSize,
  useVideoElement
};
/*! Bundled license information:

he/he.js:
  (*! https://mths.be/he v1.2.0 by @mathias | MIT license *)

tw-to-css/dist/index.mjs:
  (*! https://mths.be/cssesc v3.0.0 by @mathias *)
*/
//# sourceMappingURL=@react-three_uikit.js.map
