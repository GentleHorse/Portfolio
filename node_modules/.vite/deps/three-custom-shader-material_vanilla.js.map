{
  "version": 3,
  "sources": ["../../three-custom-shader-material/dist/vanilla-307d3a93.esm.js", "../../three-custom-shader-material/vanilla/dist/three-custom-shader-material-vanilla.esm.js"],
  "sourcesContent": ["import objectHash from 'object-hash';\nimport * as THREE from 'three';\nimport tokenize from 'glsl-tokenizer';\nimport stringify from 'glsl-token-string';\nimport tokenFunctions from 'glsl-token-functions';\n\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nvar keywords = {\n  position: 'csm_Position',\n  positionRaw: 'csm_PositionRaw',\n  pointSize: 'csm_PointSize',\n  fragColor: 'csm_FragColor',\n  // PBR\n  diffuseColor: 'csm_DiffuseColor',\n  // Color + alpha\n  normal: 'csm_Normal',\n  // Normal\n  roughness: 'csm_Roughness',\n  // Roughness\n  metalness: 'csm_Metalness',\n  // Metalness\n  emissive: 'csm_Emissive',\n  // Emissive\n  ao: 'csm_AO',\n  // AO\n  bump: 'csm_Bump',\n  // Bump\n  depthAlpha: 'csm_DepthAlpha' // Depth\n};\n\nvar _defaultPatchMap, _shaderMaterial_Patch;\nvar defaultPatchMap = (_defaultPatchMap = {}, _defineProperty(_defaultPatchMap, \"\".concat(keywords.normal), {\n  '#include <beginnormal_vertex>': \"\\n    vec3 objectNormal = \".concat(keywords.normal, \";\\n    #ifdef USE_TANGENT\\n\\t    vec3 objectTangent = vec3( tangent.xyz );\\n    #endif\\n    \")\n}), _defineProperty(_defaultPatchMap, \"\".concat(keywords.position), {\n  '#include <begin_vertex>': \"\\n    vec3 transformed = \".concat(keywords.position, \";\\n  \")\n}), _defineProperty(_defaultPatchMap, \"\".concat(keywords.positionRaw), {\n  '#include <begin_vertex>': \"\\n    vec4 csm_internal_positionUnprojected = \".concat(keywords.positionRaw, \";\\n    mat4x4 csm_internal_unprojectMatrix = projectionMatrix * modelViewMatrix;\\n    #ifdef USE_INSTANCING\\n      csm_internal_unprojectMatrix = csm_internal_unprojectMatrix * instanceMatrix;\\n    #endif\\n    csm_internal_positionUnprojected = inverse(csm_internal_unprojectMatrix) * csm_internal_positionUnprojected;\\n    vec3 transformed = csm_internal_positionUnprojected.xyz;\\n  \")\n}), _defineProperty(_defaultPatchMap, \"\".concat(keywords.pointSize), {\n  'gl_PointSize = size;': \"\\n    gl_PointSize = \".concat(keywords.pointSize, \";\\n    \")\n}), _defineProperty(_defaultPatchMap, \"\".concat(keywords.diffuseColor), {\n  '#include <color_fragment>': \"\\n    #include <color_fragment>\\n    diffuseColor = \".concat(keywords.diffuseColor, \";\\n  \")\n}), _defineProperty(_defaultPatchMap, \"\".concat(keywords.fragColor), {\n  '#include <dithering_fragment>': \"\\n    #include <dithering_fragment>\\n    gl_FragColor  = \".concat(keywords.fragColor, \";\\n  \")\n}), _defineProperty(_defaultPatchMap, \"\".concat(keywords.emissive), {\n  'vec3 totalEmissiveRadiance = emissive;': \"\\n    vec3 totalEmissiveRadiance = \".concat(keywords.emissive, \";\\n    \")\n}), _defineProperty(_defaultPatchMap, \"\".concat(keywords.roughness), {\n  '#include <roughnessmap_fragment>': \"\\n    #include <roughnessmap_fragment>\\n    roughnessFactor = \".concat(keywords.roughness, \";\\n    \")\n}), _defineProperty(_defaultPatchMap, \"\".concat(keywords.metalness), {\n  '#include <metalnessmap_fragment>': \"\\n    #include <metalnessmap_fragment>\\n    metalnessFactor = \".concat(keywords.metalness, \";\\n    \")\n}), _defineProperty(_defaultPatchMap, \"\".concat(keywords.ao), {\n  '#include <aomap_fragment>': \"\\n    #include <aomap_fragment>\\n    reflectedLight.indirectDiffuse *= 1. - \".concat(keywords.ao, \";\\n    \")\n}), _defineProperty(_defaultPatchMap, \"\".concat(keywords.bump), {\n  '#include <normal_fragment_maps>': \"\\n    #include <normal_fragment_maps>\\n\\n    vec3 csm_internal_orthogonal = \".concat(keywords.bump, \" - (dot(\").concat(keywords.bump, \", normal) * normal);\\n    vec3 csm_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_internal_orthogonal;\\n    normal = normalize(normal - csm_internal_projectedbump);\\n    \")\n}), _defineProperty(_defaultPatchMap, \"\".concat(keywords.depthAlpha), {\n  'gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );': \"\\n      gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity * \".concat(keywords.depthAlpha, \" );\\n    \"),\n  'gl_FragColor = packDepthToRGBA( fragCoordZ );': \"\\n      gl_FragColor = packDepthToRGBA( fragCoordZ );\\n      gl_FragColor.a *= \".concat(keywords.depthAlpha, \";\\n    \")\n}), _defaultPatchMap);\nvar shaderMaterial_PatchMap = (_shaderMaterial_Patch = {}, _defineProperty(_shaderMaterial_Patch, \"\".concat(keywords.position), {\n  'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );': \"\\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( \".concat(keywords.position, \", 1.0 );\\n  \")\n}), _defineProperty(_shaderMaterial_Patch, \"\".concat(keywords.positionRaw), {\n  'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );': \"\\n    gl_Position = \".concat(keywords.position, \";\\n  \")\n}), _defineProperty(_shaderMaterial_Patch, \"\".concat(keywords.diffuseColor), {\n  'gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );': \"\\n    gl_FragColor = \".concat(keywords.diffuseColor, \";\\n  \")\n}), _defineProperty(_shaderMaterial_Patch, \"\".concat(keywords.fragColor), {\n  'gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );': \"\\n    gl_FragColor = \".concat(keywords.fragColor, \";\\n  \")\n}), _shaderMaterial_Patch);\n\nvar defaultDefinitions = /* glsl */\"\\n\\n#ifdef IS_VERTEX\\n    // csm_Position & csm_PositionRaw\\n    #ifdef IS_UNKNOWN\\n        vec3 csm_Position = vec3(0.0);\\n        vec4 csm_PositionRaw = vec4(0.0);\\n        vec3 csm_Normal = vec3(0.0);\\n    #else\\n        vec3 csm_Position = position;\\n        vec4 csm_PositionRaw = projectionMatrix * modelViewMatrix * vec4(position, 1.);\\n        vec3 csm_Normal = normal;\\n    #endif\\n\\n    // csm_PointSize\\n    #ifdef IS_POINTSMATERIAL\\n        float csm_PointSize = size;\\n    #endif\\n#else\\n    // csm_DiffuseColor & csm_FragColor\\n    #if defined IS_UNKNOWN || defined IS_SHADERMATERIAL || defined IS_MESHDEPTHMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_SHADOWMATERIAL\\n        vec4 csm_DiffuseColor = vec4(1.0, 0.0, 1.0, 1.0);\\n        vec4 csm_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\\n    #else\\n        #ifdef USE_MAP\\n            vec4 _csm_sampledDiffuseColor = texture2D(map, vMapUv);\\n\\n            #ifdef DECODE_VIDEO_TEXTURE\\n            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)\\n            _csm_sampledDiffuseColor = vec4(mix(pow(_csm_sampledDiffuseColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), _csm_sampledDiffuseColor.rgb * 0.0773993808, vec3(lessThanEqual(_csm_sampledDiffuseColor.rgb, vec3(0.04045)))), _csm_sampledDiffuseColor.w);\\n            #endif\\n\\n            vec4 csm_DiffuseColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;\\n            vec4 csm_FragColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;\\n        #else\\n            vec4 csm_DiffuseColor = vec4(diffuse, opacity);\\n            vec4 csm_FragColor = vec4(diffuse, opacity);\\n        #endif\\n    #endif\\n\\n    // csm_Emissive, csm_Roughness, csm_Metalness\\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL\\n        vec3 csm_Emissive = emissive;\\n        float csm_Roughness = roughness;\\n        float csm_Metalness = metalness;\\n    #endif\\n\\n    // csm_AO\\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL\\n        float csm_AO = 0.0;\\n    #endif\\n\\n    // csm_Bump\\n    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL \\n        vec3 csm_Bump = vec3(0.0);\\n    #endif\\n\\n    float csm_DepthAlpha = 1.0;\\n#endif\\n\";\nvar defaultVertDefinitions = /* glsl */\"\\n    varying mat4 csm_internal_vModelViewMatrix;\\n\";\nvar defaultVertMain = /* glsl */\"\\n    csm_internal_vModelViewMatrix = modelViewMatrix;\\n\";\nvar defaultFragDefinitions = /* glsl */\"\\n    varying mat4 csm_internal_vModelViewMatrix;\\n\";\nvar defaultFragMain = /* glsl */\"\\n    \\n\";\n\nvar _defaultAvailabilityM;\nvar defaultAvailabilityMap = (_defaultAvailabilityM = {}, _defineProperty(_defaultAvailabilityM, \"\".concat(keywords.position), '*'), _defineProperty(_defaultAvailabilityM, \"\".concat(keywords.positionRaw), '*'), _defineProperty(_defaultAvailabilityM, \"\".concat(keywords.normal), '*'), _defineProperty(_defaultAvailabilityM, \"\".concat(keywords.pointSize), ['PointsMaterial']), _defineProperty(_defaultAvailabilityM, \"\".concat(keywords.diffuseColor), '*'), _defineProperty(_defaultAvailabilityM, \"\".concat(keywords.fragColor), '*'), _defineProperty(_defaultAvailabilityM, \"\".concat(keywords.emissive), ['MeshStandardMaterial', 'MeshPhysicalMaterial']), _defineProperty(_defaultAvailabilityM, \"\".concat(keywords.roughness), ['MeshStandardMaterial', 'MeshPhysicalMaterial']), _defineProperty(_defaultAvailabilityM, \"\".concat(keywords.metalness), ['MeshStandardMaterial', 'MeshPhysicalMaterial']), _defineProperty(_defaultAvailabilityM, \"\".concat(keywords.ao), ['MeshStandardMaterial', 'MeshPhysicalMaterial', 'MeshBasicMaterial', 'MeshLambertMaterial', 'MeshPhongMaterial', 'MeshToonMaterial']), _defineProperty(_defaultAvailabilityM, \"\".concat(keywords.bump), ['MeshLambertMaterial', 'MeshMatcapMaterial', 'MeshNormalMaterial', 'MeshPhongMaterial', 'MeshPhysicalMaterial', 'MeshStandardMaterial', 'MeshToonMaterial', 'ShadowMaterial']), _defineProperty(_defaultAvailabilityM, \"\".concat(keywords.depthAlpha), '*'), _defaultAvailabilityM);\n\nvar _excluded = [\"baseMaterial\", \"fragmentShader\", \"vertexShader\", \"uniforms\", \"patchMap\", \"cacheKey\", \"silent\"];\nvar replaceAll = function replaceAll(str, find, rep) {\n  return str.split(find).join(rep);\n};\nvar escapeRegExpMatch = function escapeRegExpMatch(s) {\n  return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n};\nvar isExactMatch = function isExactMatch(str, match) {\n  return new RegExp(\"\\\\b\".concat(escapeRegExpMatch(match), \"\\\\b\")).test(str);\n};\n\n// Hacky, yikes!\nfunction isConstructor(f) {\n  try {\n    // @ts-ignore\n    new f();\n  } catch (err) {\n    if (err.message.indexOf('is not a constructor') >= 0) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction copyObject(target, source) {\n  var silent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  Object.assign(target, source);\n  var proto = Object.getPrototypeOf(source);\n  Object.entries(Object.getOwnPropertyDescriptors(proto)).filter(function (e) {\n    var isGetter = typeof e[1].get === 'function';\n    var isSetter = typeof e[1].set === 'function';\n    var isFunction = typeof e[1].value === 'function';\n    var isConstructor = e[0] === 'constructor';\n    return (isGetter || isSetter || isFunction) && !isConstructor;\n  }).forEach(function (val) {\n    // If function exists on target, rename it with \"base_\" prefix\n    if (typeof target[val[0]] === 'function') {\n      if (!silent) console.warn(\"Function \".concat(val[0], \" already exists on CSM, renaming to base_\").concat(val[0]));\n      var baseName = \"base_\".concat(val[0]);\n      target[baseName] = val[1].value.bind(target);\n      return;\n    }\n    Object.defineProperty(target, val[0], val[1]);\n  });\n}\nfunction isFunctionEmpty(fn) {\n  var fnString = fn.toString().trim();\n  var fnBody = fnString.substring(fnString.indexOf('{') + 1, fnString.lastIndexOf('}'));\n  return fnBody.trim().length === 0;\n}\nfunction stripSpaces(str) {\n  return str.replace(/\\s/g, '');\n}\nfunction replaceLastOccurrence(str, find, rep) {\n  var index = str.lastIndexOf(find);\n  if (index === -1) {\n    return str;\n  }\n  return str.substring(0, index) + rep + str.substring(index + find.length);\n}\nvar CustomShaderMaterial = /*#__PURE__*/function (_THREE$Material) {\n  _inherits(CustomShaderMaterial, _THREE$Material);\n  var _super = _createSuper(CustomShaderMaterial);\n  function CustomShaderMaterial(_ref) {\n    var _this;\n    var baseMaterial = _ref.baseMaterial,\n      fragmentShader = _ref.fragmentShader,\n      vertexShader = _ref.vertexShader,\n      uniforms = _ref.uniforms,\n      patchMap = _ref.patchMap,\n      cacheKey = _ref.cacheKey,\n      silent = _ref.silent,\n      opts = _objectWithoutProperties(_ref, _excluded);\n    _classCallCheck(this, CustomShaderMaterial);\n    var base;\n    if (isConstructor(baseMaterial)) {\n      // If base material is a constructor, instantiate it\n      base = new baseMaterial(opts);\n    } else {\n      // Else, copy options onto base material and use the already create\n      // instance as the base material\n      base = baseMaterial;\n      Object.assign(base, opts);\n    }\n\n    // Supporting RawShaderMaterial is redundant as there is nothing\n    // to patch, extend or override\n    if (base.type === 'RawShaderMaterial') {\n      throw new Error('CustomShaderMaterial does not support RawShaderMaterial');\n    }\n\n    // Copy all properties from base material onto this material\n    // Rename any functions that already exist on this material with \"base_\" prefix\n    _this = _super.call(this);\n    copyObject(_assertThisInitialized(_this), base, silent);\n\n    // Set up private internals\n    _this.__csm = {\n      patchMap: patchMap || {},\n      fragmentShader: fragmentShader || '',\n      vertexShader: vertexShader || '',\n      cacheKey: cacheKey,\n      baseMaterial: baseMaterial,\n      instanceID: THREE.MathUtils.generateUUID(),\n      type: base.type,\n      isAlreadyExtended: !isFunctionEmpty(base.onBeforeCompile),\n      cacheHash: \"\",\n      silent: silent\n    };\n    _this.uniforms = _objectSpread2(_objectSpread2({}, _this.uniforms || {}), uniforms || {});\n\n    // Scoped to avoid name collisions\n    {\n      // Generate material and assign cache key\n      var _this$__csm = _this.__csm,\n        _fragmentShader = _this$__csm.fragmentShader,\n        _vertexShader = _this$__csm.vertexShader;\n      var _uniforms = _this.uniforms;\n      _this.__csm.cacheHash = _this.getCacheHash();\n      _this.generateMaterial(_fragmentShader, _vertexShader, _uniforms);\n    }\n    return _this;\n  }\n\n  /**\r\n   *\r\n   * Update the material with new arguments.\r\n   * TODO: Fix memory leak.\r\n   *\r\n   * @param opts Options to update the material with.\r\n   *\r\n   * @deprecated This method leaks memory.\r\n   */\n  _createClass(CustomShaderMaterial, [{\n    key: \"update\",\n    value: function update() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      // Basically just re-run the last bit of the constructor\n      this.uniforms = opts.uniforms || this.uniforms;\n      Object.assign(this.__csm, opts);\n      var _this$__csm2 = this.__csm,\n        fragmentShader = _this$__csm2.fragmentShader,\n        vertexShader = _this$__csm2.vertexShader;\n      var uniforms = this.uniforms;\n      var newHash = this.getCacheHash();\n      this.__csm.cacheHash = newHash;\n      this.generateMaterial(fragmentShader, vertexShader, uniforms);\n    }\n\n    /**\r\n     * Returns a new instance of this material with the same options.\r\n     *\r\n     * @returns A clone of this material.\r\n     */\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var opts = {\n        baseMaterial: this.__csm.baseMaterial,\n        fragmentShader: this.__csm.fragmentShader,\n        vertexShader: this.__csm.vertexShader,\n        uniforms: this.uniforms,\n        silent: this.__csm.silent,\n        patchMap: this.__csm.patchMap,\n        cacheKey: this.__csm.cacheKey\n      };\n      var clone = new this.constructor(opts);\n      Object.assign(this, clone);\n      return clone;\n    }\n\n    /**\r\n     * Internally calculates the cache key for this instance of CSM.\r\n     * If no specific CSM inputs are provided, the cache key is the same as the default\r\n     * cache key, i.e. `baseMaterial.onBeforeCompile.toString()`. Not meant to be called directly.\r\n     *\r\n     * This method is quite expensive owing to the hashing function and string manip.\r\n     *\r\n     * TODO:\r\n     * - Optimize string manip.\r\n     * - Find faster hash function\r\n     *\r\n     * @returns {string} A cache key for this instance of CSM.\r\n     */\n  }, {\n    key: \"getCacheHash\",\n    value: function getCacheHash() {\n      // The cache key is a hash of the fragment shader, vertex shader, and uniforms\n      var _this$__csm3 = this.__csm,\n        fragmentShader = _this$__csm3.fragmentShader,\n        vertexShader = _this$__csm3.vertexShader;\n      var uniforms = this.uniforms;\n      var serializedUniforms = Object.values(uniforms).reduce(function (prev, _ref2) {\n        var value = _ref2.value;\n        return prev + JSON.stringify(value);\n      }, '');\n\n      // We strip spaces because whitespace is not significant in GLSL\n      // and we want `blah` and `     blah ` to be the same.\n      var hashInp = stripSpaces(fragmentShader) + stripSpaces(vertexShader) + serializedUniforms;\n\n      // If CSM inputs are empty, use default cache key\n      // This means that `<baseMaterial />` and <CSM baseMaterial={baseMaterial} />`\n      // are the same shader program, i.e they share the same cache key\n      return hashInp.trim().length > 0 ? objectHash(hashInp) : this.customProgramCacheKey();\n    }\n\n    /**\r\n     * Does the internal shader generation. Not meant to be called directly.\r\n     *\r\n     * @param fragmentShader\r\n     * @param vertexShader\r\n     * @param uniforms\r\n     */\n  }, {\n    key: \"generateMaterial\",\n    value: function generateMaterial(fragmentShader, vertexShader, uniforms) {\n      var _this2 = this;\n      // Get parsed shaders. A Parsed shader is a shader with\n      // it's `#define`s, function and var definitions and main separated.\n      var parsedFragmentShader = this.parseShader(fragmentShader);\n      var parsedVertexShader = this.parseShader(vertexShader);\n      this.uniforms = uniforms || {};\n\n      // Set material cache key\n      this.customProgramCacheKey = function () {\n        return _this2.__csm.cacheHash;\n      };\n\n      // Set onBeforeCompile\n      var customOnBeforeCompile = function customOnBeforeCompile(shader) {\n        try {\n          // If Fragment shader is not empty, patch it\n          if (parsedFragmentShader) {\n            var patchedFragmentShader = _this2.patchShader(parsedFragmentShader, shader.fragmentShader, true);\n            shader.fragmentShader = _this2.getMaterialDefine() + patchedFragmentShader;\n          }\n\n          // If Vertex shader is not empty, patch it\n          if (parsedVertexShader) {\n            var patchedVertexShader = _this2.patchShader(parsedVertexShader, shader.vertexShader);\n            shader.vertexShader = '#define IS_VERTEX;\\n' + patchedVertexShader;\n            shader.vertexShader = _this2.getMaterialDefine() + shader.vertexShader;\n          }\n\n          // Patch uniforms\n          shader.uniforms = _objectSpread2(_objectSpread2({}, shader.uniforms), _this2.uniforms);\n          _this2.uniforms = shader.uniforms;\n        } catch (error) {\n          console.error(error);\n        }\n      };\n      if (this.__csm.isAlreadyExtended) {\n        // If the material has already been extending via onBeforeCompile has a\n        // then chain the new onBeforeCompile after the old one.\n        var prevOnBeforeCompile = this.onBeforeCompile;\n        this.onBeforeCompile = function (shader, renderer) {\n          prevOnBeforeCompile(shader, renderer);\n          customOnBeforeCompile(shader);\n        };\n      } else {\n        // Else just set the onBeforeCompile\n        this.onBeforeCompile = customOnBeforeCompile;\n      }\n      this.needsUpdate = true;\n    }\n\n    /**\r\n     * Patches input shader with custom shader. Not meant to be called directly.\r\n     * @param customShader\r\n     * @param shader\r\n     * @param isFrag\r\n     * @returns\r\n     */\n  }, {\n    key: \"patchShader\",\n    value: function patchShader(customShader, shader, isFrag) {\n      var _this3 = this;\n      var patchedShader = shader;\n\n      // Get the patch map, its a combination of the default patch map and the\n      // user defined patch map. The user defined map takes precedence.\n      var patchMap = _objectSpread2(_objectSpread2({}, this.getPatchMapForMaterial()), this.__csm.patchMap);\n\n      // Replace all entries in the patch map\n      Object.keys(patchMap).forEach(function (name) {\n        Object.keys(patchMap[name]).forEach(function (key) {\n          var availableIn = defaultAvailabilityMap[name];\n          var type = _this3.__csm.type;\n\n          // Only inject keywords that appear in the shader.\n          // If the keyword is '*', then inject the patch regardless.\n          if (name === '*' || isExactMatch(customShader.main, name)) {\n            if (!availableIn || Array.isArray(availableIn) && availableIn.includes(type) || availableIn === '*') {\n              patchedShader = replaceAll(patchedShader, key, patchMap[name][key]);\n            } else {\n              throw new Error(\"CSM: \".concat(name, \" is not available in \").concat(type, \". Shader cannot compile.\"));\n            }\n          }\n        });\n      });\n\n      // Inject defaults\n      patchedShader = patchedShader.replace('void main() {', \"\\n        #ifndef CSM_IS_HEAD_DEFAULTS_DEFINED\\n          \".concat(isFrag ? defaultFragDefinitions : defaultVertDefinitions, \"\\n          #define CSM_IS_HEAD_DEFAULTS_DEFINED 1\\n        #endif\\n\\n        \").concat(customShader.header, \"\\n        \\n        void main() {\\n          #ifndef CSM_IS_DEFAULTS_DEFINED\\n            \").concat(defaultDefinitions, \"\\n            #define CSM_IS_DEFAULTS_DEFINED 1\\n          #endif\\n          \\n          #ifndef CSM_IS_MAIN_DEFAULTS_DEFINED\\n            \").concat(isFrag ? defaultFragMain : defaultVertMain, \"\\n            #define CSM_IS_MAIN_DEFAULTS_DEFINED 1\\n          #endif\\n\\n          // CSM_START\\n      \"));\n      var needsCustomInjectionOrder = this.__csm.isAlreadyExtended;\n      var hasCSMEndMark = patchedShader.includes('// CSM_END');\n      if (needsCustomInjectionOrder && hasCSMEndMark) {\n        // If the shader has already been extended, and contains the\n        // CSM_END mark, then inject the custom shader after the CSM_END mark.\n        // This ensures that the last shader in the chain receives all the vars and\n        // values of the previous shaders.\n        // This means that any custom materials would have to have the CSM_END mark\n        // injected beforehand but thats the only way to know where the custom material's\n        // main function ends.\n        patchedShader = replaceLastOccurrence(patchedShader, '// CSM_END', \"\\n          // CSM_END\\n          \".concat(customShader.main, \"\\n          // CSM_END\\n        \"));\n      } else {\n        // Else inject the custom shader at the start of main\n        patchedShader = patchedShader.replace('// CSM_START', \"\\n        // CSM_START\\n        \".concat(customShader.main, \"\\n        // CSM_END\\n          \"));\n      }\n      patchedShader = customShader.defines + patchedShader;\n      return patchedShader;\n    }\n\n    /**\r\n     * This method is expensive owing to the tokenization and parsing of the shader.\r\n     *\r\n     * TODO:\r\n     * - Replace tokenization with regex\r\n     *\r\n     * @param shader\r\n     * @returns\r\n     */\n  }, {\n    key: \"parseShader\",\n    value: function parseShader(shader) {\n      if (!shader) return;\n\n      // Strip comments\n      var s = shader.replace(/\\/\\*\\*(.*?)\\*\\/|\\/\\/(.*?)\\n/gm, '');\n\n      // Tokenize and separate into defines, header and main\n      var tokens = tokenize(s);\n      var funcs = tokenFunctions(tokens);\n      var mainIndex = funcs.map(function (e) {\n        return e.name;\n      }).indexOf('main');\n      var variables = stringify(tokens.slice(0, mainIndex >= 0 ? funcs[mainIndex].outer[0] : undefined));\n      var mainBody = mainIndex >= 0 ? this.getShaderFromIndex(tokens, funcs[mainIndex].body) : '';\n      return {\n        defines: '',\n        header: variables,\n        main: mainBody\n      };\n    }\n\n    /**\r\n     * Gets the material type as a string. Not meant to be called directly.\r\n     * @returns\r\n     */\n  }, {\n    key: \"getMaterialDefine\",\n    value: function getMaterialDefine() {\n      var type = this.__csm.type;\n      return type ? \"#define IS_\".concat(type.toUpperCase(), \";\\n\") : \"#define IS_UNKNOWN;\\n\";\n    }\n\n    /**\r\n     * Gets the right patch map for the material. Not meant to be called directly.\r\n     * @returns\r\n     */\n  }, {\n    key: \"getPatchMapForMaterial\",\n    value: function getPatchMapForMaterial() {\n      switch (this.__csm.type) {\n        case 'ShaderMaterial':\n          return shaderMaterial_PatchMap;\n        default:\n          return defaultPatchMap;\n      }\n    }\n\n    /**\r\n     * Gets the shader from the tokens. Not meant to be called directly.\r\n     * @param tokens\r\n     * @param index\r\n     * @returns\r\n     */\n  }, {\n    key: \"getShaderFromIndex\",\n    value: function getShaderFromIndex(tokens, index) {\n      return stringify(tokens.slice(index[0], index[1]));\n    }\n  }]);\n  return CustomShaderMaterial;\n}(THREE.Material);\n\nexport { CustomShaderMaterial as C, _objectWithoutProperties as _, _objectSpread2 as a };\n", "export { C as default } from '../../dist/vanilla-307d3a93.esm.js';\nimport 'object-hash';\nimport 'three';\nimport 'glsl-tokenizer';\nimport 'glsl-token-string';\nimport 'glsl-token-functions';\n"],
  "mappings": "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",
  "names": ["_setPrototypeOf", "o", "p", "_getPrototypeOf", "replaceAll", "escapeRegExpMatch", "isExactMatch", "isConstructor", "CustomShaderMaterial", "clone", "objectHash", "customOnBeforeCompile", "tokenize", "tokenFunctions", "stringify", "import_object_hash", "import_glsl_tokenizer", "import_glsl_token_string", "import_glsl_token_functions"]
}
